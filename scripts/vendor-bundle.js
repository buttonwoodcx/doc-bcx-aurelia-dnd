/* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2013-2017 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
/**
 * bluebird build version 3.5.1
 * Features enabled: core
 * Features disabled: race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
*/
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";
var firstLineError;
try {throw new Error(); } catch (e) {firstLineError = e;}
var schedule = _dereq_("./schedule");
var Queue = _dereq_("./queue");
var util = _dereq_("./util");

function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule = schedule;
}

Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
};

Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
};

Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
};

Async.prototype.disableTrampolineIfNecessary = function() {
    if (util.hasDevTools) {
        this._trampolineEnabled = false;
    }
};

Async.prototype.haveItemsQueued = function () {
    return this._isTickUsed || this._haveDrainedQueues;
};


Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
            "\n");
        process.exit(2);
    } else {
        this.throwLater(e);
    }
};

Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () { throw arg; };
    }
    if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function() {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
};

function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
}

if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
} else {
    Async.prototype.invokeLater = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                setTimeout(function() {
                    fn.call(receiver, arg);
                }, 100);
            });
        }
    };

    Async.prototype.invoke = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                fn.call(receiver, arg);
            });
        }
    };

    Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
        } else {
            this._schedule(function() {
                promise._settlePromises();
            });
        }
    };
}

Async.prototype._drainQueue = function(queue) {
    while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};

Async.prototype._drainQueues = function () {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = Async;
module.exports.firstLineError = firstLineError;

},{"./queue":17,"./schedule":18,"./util":21}],2:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
var calledBind = false;
var rejectThis = function(_, e) {
    this._reject(e);
};

var targetRejected = function(e, context) {
    context.promiseRejectionQueued = true;
    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
};

var bindingResolved = function(thisArg, context) {
    if (((this._bitField & 50397184) === 0)) {
        this._resolveCallback(context.target);
    }
};

var bindingRejected = function(e, context) {
    if (!context.promiseRejectionQueued) this._reject(e);
};

Promise.prototype.bind = function (thisArg) {
    if (!calledBind) {
        calledBind = true;
        Promise.prototype._propagateFrom = debug.propagateFromFunction();
        Promise.prototype._boundValue = debug.boundValueFunction();
    }
    var maybePromise = tryConvertToPromise(thisArg);
    var ret = new Promise(INTERNAL);
    ret._propagateFrom(this, 1);
    var target = this._target();
    ret._setBoundTo(maybePromise);
    if (maybePromise instanceof Promise) {
        var context = {
            promiseRejectionQueued: false,
            promise: ret,
            target: target,
            bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, undefined, ret, context);
        maybePromise._then(
            bindingResolved, bindingRejected, undefined, ret, context);
        ret._setOnCancel(maybePromise);
    } else {
        ret._resolveCallback(target);
    }
    return ret;
};

Promise.prototype._setBoundTo = function (obj) {
    if (obj !== undefined) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
    } else {
        this._bitField = this._bitField & (~2097152);
    }
};

Promise.prototype._isBound = function () {
    return (this._bitField & 2097152) === 2097152;
};

Promise.bind = function (thisArg, value) {
    return Promise.resolve(value).bind(thisArg);
};
};

},{}],3:[function(_dereq_,module,exports){
"use strict";
var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict() {
    try { if (Promise === bluebird) Promise = old; }
    catch (e) {}
    return bluebird;
}
var bluebird = _dereq_("./promise")();
bluebird.noConflict = noConflict;
module.exports = bluebird;

},{"./promise":15}],4:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, PromiseArray, apiRejection, debug) {
var util = _dereq_("./util");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var async = Promise._async;

Promise.prototype["break"] = Promise.prototype.cancel = function() {
    if (!debug.cancellation()) return this._warn("cancellation is disabled");

    var promise = this;
    var child = promise;
    while (promise._isCancellable()) {
        if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
                child._followee().cancel();
            } else {
                child._cancelBranched();
            }
            break;
        }

        var parent = promise._cancellationParent;
        if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
                promise._followee().cancel();
            } else {
                promise._cancelBranched();
            }
            break;
        } else {
            if (promise._isFollowing()) promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
        }
    }
};

Promise.prototype._branchHasCancelled = function() {
    this._branchesRemainingToCancel--;
};

Promise.prototype._enoughBranchesHaveCancelled = function() {
    return this._branchesRemainingToCancel === undefined ||
           this._branchesRemainingToCancel <= 0;
};

Promise.prototype._cancelBy = function(canceller) {
    if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
    } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
        }
    }
    return false;
};

Promise.prototype._cancelBranched = function() {
    if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
    }
};

Promise.prototype._cancel = function() {
    if (!this._isCancellable()) return;
    this._setCancelled();
    async.invoke(this._cancelPromises, this, undefined);
};

Promise.prototype._cancelPromises = function() {
    if (this._length() > 0) this._settlePromises();
};

Promise.prototype._unsetOnCancel = function() {
    this._onCancelField = undefined;
};

Promise.prototype._isCancellable = function() {
    return this.isPending() && !this._isCancelled();
};

Promise.prototype.isCancellable = function() {
    return this.isPending() && !this.isCancelled();
};

Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
    if (util.isArray(onCancelCallback)) {
        for (var i = 0; i < onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
    } else if (onCancelCallback !== undefined) {
        if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
                var e = tryCatch(onCancelCallback).call(this._boundValue());
                if (e === errorObj) {
                    this._attachExtraTrace(e.e);
                    async.throwLater(e.e);
                }
            }
        } else {
            onCancelCallback._resultCancelled(this);
        }
    }
};

Promise.prototype._invokeOnCancel = function() {
    var onCancelCallback = this._onCancel();
    this._unsetOnCancel();
    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
};

Promise.prototype._invokeInternalOnCancel = function() {
    if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
    }
};

Promise.prototype._resultCancelled = function() {
    this.cancel();
};

};

},{"./util":21}],5:[function(_dereq_,module,exports){
"use strict";
module.exports = function(NEXT_FILTER) {
var util = _dereq_("./util");
var getKeys = _dereq_("./es5").keys;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function catchFilter(instances, cb, promise) {
    return function(e) {
        var boundTo = promise._boundValue();
        predicateLoop: for (var i = 0; i < instances.length; ++i) {
            var item = instances[i];

            if (item === Error ||
                (item != null && item.prototype instanceof Error)) {
                if (e instanceof item) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (typeof item === "function") {
                var matchesPredicate = tryCatch(item).call(boundTo, e);
                if (matchesPredicate === errorObj) {
                    return matchesPredicate;
                } else if (matchesPredicate) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (util.isObject(e)) {
                var keys = getKeys(item);
                for (var j = 0; j < keys.length; ++j) {
                    var key = keys[j];
                    if (item[key] != e[key]) {
                        continue predicateLoop;
                    }
                }
                return tryCatch(cb).call(boundTo, e);
            }
        }
        return NEXT_FILTER;
    };
}

return catchFilter;
};

},{"./es5":10,"./util":21}],6:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var longStackTraces = false;
var contextStack = [];

Promise.prototype._promiseCreated = function() {};
Promise.prototype._pushContext = function() {};
Promise.prototype._popContext = function() {return null;};
Promise._peekContext = Promise.prototype._peekContext = function() {};

function Context() {
    this._trace = new Context.CapturedTrace(peekContext());
}
Context.prototype._pushContext = function () {
    if (this._trace !== undefined) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
    }
};

Context.prototype._popContext = function () {
    if (this._trace !== undefined) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
    }
    return null;
};

function createContext() {
    if (longStackTraces) return new Context();
}

function peekContext() {
    var lastIndex = contextStack.length - 1;
    if (lastIndex >= 0) {
        return contextStack[lastIndex];
    }
    return undefined;
}
Context.CapturedTrace = null;
Context.create = createContext;
Context.deactivateLongStackTraces = function() {};
Context.activateLongStackTraces = function() {
    var Promise_pushContext = Promise.prototype._pushContext;
    var Promise_popContext = Promise.prototype._popContext;
    var Promise_PeekContext = Promise._peekContext;
    var Promise_peekContext = Promise.prototype._peekContext;
    var Promise_promiseCreated = Promise.prototype._promiseCreated;
    Context.deactivateLongStackTraces = function() {
        Promise.prototype._pushContext = Promise_pushContext;
        Promise.prototype._popContext = Promise_popContext;
        Promise._peekContext = Promise_PeekContext;
        Promise.prototype._peekContext = Promise_peekContext;
        Promise.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
    };
    longStackTraces = true;
    Promise.prototype._pushContext = Context.prototype._pushContext;
    Promise.prototype._popContext = Context.prototype._popContext;
    Promise._peekContext = Promise.prototype._peekContext = peekContext;
    Promise.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
    };
};
return Context;
};

},{}],7:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, Context) {
var getDomain = Promise._getDomain;
var async = Promise._async;
var Warning = _dereq_("./errors").Warning;
var util = _dereq_("./util");
var canAttachTrace = util.canAttachTrace;
var unhandledRejectionHandled;
var possiblyUnhandledRejection;
var bluebirdFramePattern =
    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
var stackFramePattern = null;
var formatStack = null;
var indentStackFrames = false;
var printWarning;
var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
                        (true ||
                         util.env("BLUEBIRD_DEBUG") ||
                         util.env("NODE_ENV") === "development"));

var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
    (debugging || util.env("BLUEBIRD_WARNINGS")));

var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 &&
    (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

Promise.prototype.suppressUnhandledRejections = function() {
    var target = this._target();
    target._bitField = ((target._bitField & (~1048576)) |
                      524288);
};

Promise.prototype._ensurePossibleRejectionHandled = function () {
    if ((this._bitField & 524288) !== 0) return;
    this._setRejectionIsUnhandled();
    var self = this;
    setTimeout(function() {
        self._notifyUnhandledRejection();
    }, 1);
};

Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
    fireRejectionEvent("rejectionHandled",
                                  unhandledRejectionHandled, undefined, this);
};

Promise.prototype._setReturnedNonUndefined = function() {
    this._bitField = this._bitField | 268435456;
};

Promise.prototype._returnedNonUndefined = function() {
    return (this._bitField & 268435456) !== 0;
};

Promise.prototype._notifyUnhandledRejection = function () {
    if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent("unhandledRejection",
                                      possiblyUnhandledRejection, reason, this);
    }
};

Promise.prototype._setUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField | 262144;
};

Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField & (~262144);
};

Promise.prototype._isUnhandledRejectionNotified = function () {
    return (this._bitField & 262144) > 0;
};

Promise.prototype._setRejectionIsUnhandled = function () {
    this._bitField = this._bitField | 1048576;
};

Promise.prototype._unsetRejectionIsUnhandled = function () {
    this._bitField = this._bitField & (~1048576);
    if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
    }
};

Promise.prototype._isRejectionUnhandled = function () {
    return (this._bitField & 1048576) > 0;
};

Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
    return warn(message, shouldUseOwnTrace, promise || this);
};

Promise.onPossiblyUnhandledRejection = function (fn) {
    var domain = getDomain();
    possiblyUnhandledRejection =
        typeof fn === "function" ? (domain === null ?
                                            fn : util.domainBind(domain, fn))
                                 : undefined;
};

Promise.onUnhandledRejectionHandled = function (fn) {
    var domain = getDomain();
    unhandledRejectionHandled =
        typeof fn === "function" ? (domain === null ?
                                            fn : util.domainBind(domain, fn))
                                 : undefined;
};

var disableLongStackTraces = function() {};
Promise.longStackTraces = function () {
    if (async.haveItemsQueued() && !config.longStackTraces) {
        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
            }
            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Context.deactivateLongStackTraces();
            async.enableTrampoline();
            config.longStackTraces = false;
        };
        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Context.activateLongStackTraces();
        async.disableTrampolineIfNecessary();
    }
};

Promise.hasLongStackTraces = function () {
    return config.longStackTraces && longStackTracesIsSupported();
};

var fireDomEvent = (function() {
    try {
        if (typeof CustomEvent === "function") {
            var event = new CustomEvent("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = new CustomEvent(name.toLowerCase(), {
                    detail: event,
                    cancelable: true
                });
                return !util.global.dispatchEvent(domEvent);
            };
        } else if (typeof Event === "function") {
            var event = new Event("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = new Event(name.toLowerCase(), {
                    cancelable: true
                });
                domEvent.detail = event;
                return !util.global.dispatchEvent(domEvent);
            };
        } else {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = document.createEvent("CustomEvent");
                domEvent.initCustomEvent(name.toLowerCase(), false, true,
                    event);
                return !util.global.dispatchEvent(domEvent);
            };
        }
    } catch (e) {}
    return function() {
        return false;
    };
})();

var fireGlobalEvent = (function() {
    if (util.isNode) {
        return function() {
            return process.emit.apply(process, arguments);
        };
    } else {
        if (!util.global) {
            return function() {
                return false;
            };
        }
        return function(name) {
            var methodName = "on" + name.toLowerCase();
            var method = util.global[methodName];
            if (!method) return false;
            method.apply(util.global, [].slice.call(arguments, 1));
            return true;
        };
    }
})();

function generatePromiseLifecycleEventObject(name, promise) {
    return {promise: promise};
}

var eventToObjectGenerator = {
    promiseCreated: generatePromiseLifecycleEventObject,
    promiseFulfilled: generatePromiseLifecycleEventObject,
    promiseRejected: generatePromiseLifecycleEventObject,
    promiseResolved: generatePromiseLifecycleEventObject,
    promiseCancelled: generatePromiseLifecycleEventObject,
    promiseChained: function(name, promise, child) {
        return {promise: promise, child: child};
    },
    warning: function(name, warning) {
        return {warning: warning};
    },
    unhandledRejection: function (name, reason, promise) {
        return {reason: reason, promise: promise};
    },
    rejectionHandled: generatePromiseLifecycleEventObject
};

var activeFireEvent = function (name) {
    var globalEventFired = false;
    try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
    } catch (e) {
        async.throwLater(e);
        globalEventFired = true;
    }

    var domEventFired = false;
    try {
        domEventFired = fireDomEvent(name,
                    eventToObjectGenerator[name].apply(null, arguments));
    } catch (e) {
        async.throwLater(e);
        domEventFired = true;
    }

    return domEventFired || globalEventFired;
};

Promise.config = function(opts) {
    opts = Object(opts);
    if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
            Promise.longStackTraces();
        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
            disableLongStackTraces();
        }
    }
    if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;

        if (util.isObject(warningsOption)) {
            if ("wForgottenReturn" in warningsOption) {
                wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
        }
    }
    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
        if (async.haveItemsQueued()) {
            throw new Error(
                "cannot enable cancellation after promises are in use");
        }
        Promise.prototype._clearCancellationData =
            cancellationClearCancellationData;
        Promise.prototype._propagateFrom = cancellationPropagateFrom;
        Promise.prototype._onCancel = cancellationOnCancel;
        Promise.prototype._setOnCancel = cancellationSetOnCancel;
        Promise.prototype._attachCancellationCallback =
            cancellationAttachCancellationCallback;
        Promise.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
    }
    if ("monitoring" in opts) {
        if (opts.monitoring && !config.monitoring) {
            config.monitoring = true;
            Promise.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config.monitoring) {
            config.monitoring = false;
            Promise.prototype._fireEvent = defaultFireEvent;
        }
    }
    return Promise;
};

function defaultFireEvent() { return false; }

Promise.prototype._fireEvent = defaultFireEvent;
Promise.prototype._execute = function(executor, resolve, reject) {
    try {
        executor(resolve, reject);
    } catch (e) {
        return e;
    }
};
Promise.prototype._onCancel = function () {};
Promise.prototype._setOnCancel = function (handler) { ; };
Promise.prototype._attachCancellationCallback = function(onCancel) {
    ;
};
Promise.prototype._captureStackTrace = function () {};
Promise.prototype._attachExtraTrace = function () {};
Promise.prototype._clearCancellationData = function() {};
Promise.prototype._propagateFrom = function (parent, flags) {
    ;
    ;
};

function cancellationExecute(executor, resolve, reject) {
    var promise = this;
    try {
        executor(resolve, reject, function(onCancel) {
            if (typeof onCancel !== "function") {
                throw new TypeError("onCancel must be a function, got: " +
                                    util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
        });
    } catch (e) {
        return e;
    }
}

function cancellationAttachCancellationCallback(onCancel) {
    if (!this._isCancellable()) return this;

    var previousOnCancel = this._onCancel();
    if (previousOnCancel !== undefined) {
        if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
        } else {
            this._setOnCancel([previousOnCancel, onCancel]);
        }
    } else {
        this._setOnCancel(onCancel);
    }
}

function cancellationOnCancel() {
    return this._onCancelField;
}

function cancellationSetOnCancel(onCancel) {
    this._onCancelField = onCancel;
}

function cancellationClearCancellationData() {
    this._cancellationParent = undefined;
    this._onCancelField = undefined;
}

function cancellationPropagateFrom(parent, flags) {
    if ((flags & 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === undefined) {
            branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
    }
    if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}

function bindingPropagateFrom(parent, flags) {
    if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}
var propagateFromFunction = bindingPropagateFrom;

function boundValueFunction() {
    var ret = this._boundTo;
    if (ret !== undefined) {
        if (ret instanceof Promise) {
            if (ret.isFulfilled()) {
                return ret.value();
            } else {
                return undefined;
            }
        }
    }
    return ret;
}

function longStackTracesCaptureStackTrace() {
    this._trace = new CapturedTrace(this._peekContext());
}

function longStackTracesAttachExtraTrace(error, ignoreSelf) {
    if (canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
            if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== undefined) {
            trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
            var parsed = parseStackAndMessage(error);
            util.notEnumerableProp(error, "stack",
                parsed.message + "\n" + parsed.stack.join("\n"));
            util.notEnumerableProp(error, "__stackCleaned__", true);
        }
    }
}

function checkForgottenReturns(returnValue, promiseCreated, name, promise,
                               parent) {
    if (returnValue === undefined && promiseCreated !== null &&
        wForgottenReturn) {
        if (parent !== undefined && parent._returnedNonUndefined()) return;
        if ((promise._bitField & 65535) === 0) return;

        if (name) name = name + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split("\n");
            var stack = cleanStack(traceLines);
            for (var i = stack.length - 1; i >= 0; --i) {
                var line = stack[i];
                if (!nodeFramePattern.test(line)) {
                    var lineMatches = line.match(parseLinePattern);
                    if (lineMatches) {
                        handlerLine  = "at " + lineMatches[1] +
                            ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                    }
                    break;
                }
            }

            if (stack.length > 0) {
                var firstUserLine = stack[0];
                for (var i = 0; i < traceLines.length; ++i) {

                    if (traceLines[i] === firstUserLine) {
                        if (i > 0) {
                            creatorLine = "\n" + traceLines[i - 1];
                        }
                        break;
                    }
                }

            }
        }
        var msg = "a promise was created in a " + name +
            "handler " + handlerLine + "but was not returned from it, " +
            "see http://goo.gl/rRqMUw" +
            creatorLine;
        promise._warn(msg, true, promiseCreated);
    }
}

function deprecated(name, replacement) {
    var message = name +
        " is deprecated and will be removed in a future version.";
    if (replacement) message += " Use " + replacement + " instead.";
    return warn(message);
}

function warn(message, shouldUseOwnTrace, promise) {
    if (!config.warnings) return;
    var warning = new Warning(message);
    var ctx;
    if (shouldUseOwnTrace) {
        promise._attachExtraTrace(warning);
    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
        ctx.attachExtraTrace(warning);
    } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
    }

    if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
    }
}

function reconstructStack(message, stacks) {
    for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
    }
    if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
    }
    return message + "\n" + stacks.join("\n");
}

function removeDuplicateOrEmptyJumps(stacks) {
    for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 ||
            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
            stacks.splice(i, 1);
            i--;
        }
    }
}

function removeCommonRoots(stacks) {
    var current = stacks[0];
    for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;

        for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
                commonRootMeetPoint = j;
                break;
            }
        }

        for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
                current.pop();
                currentLastIndex--;
            } else {
                break;
            }
        }
        current = prev;
    }
}

function cleanStack(stack) {
    var ret = [];
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = "    (No stack trace)" === line ||
            stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
                line = "    " + line;
            }
            ret.push(line);
        }
    }
    return ret;
}

function stackFramesAsArray(error) {
    var stack = error.stack.replace(/\s+$/g, "").split("\n");
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
        }
    }
    if (i > 0 && error.name != "SyntaxError") {
        stack = stack.slice(i);
    }
    return stack;
}

function parseStackAndMessage(error) {
    var stack = error.stack;
    var message = error.toString();
    stack = typeof stack === "string" && stack.length > 0
                ? stackFramesAsArray(error) : ["    (No stack trace)"];
    return {
        message: message,
        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
    };
}

function formatAndLogError(error, title, isSoft) {
    if (typeof console !== "undefined") {
        var message;
        if (util.isObject(error)) {
            var stack = error.stack;
            message = title + formatStack(stack, error);
        } else {
            message = title + String(error);
        }
        if (typeof printWarning === "function") {
            printWarning(message, isSoft);
        } else if (typeof console.log === "function" ||
            typeof console.log === "object") {
            console.log(message);
        }
    }
}

function fireRejectionEvent(name, localHandler, reason, promise) {
    var localEventFired = false;
    try {
        if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
                localHandler(promise);
            } else {
                localHandler(reason, promise);
            }
        }
    } catch (e) {
        async.throwLater(e);
    }

    if (name === "unhandledRejection") {
        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
            formatAndLogError(reason, "Unhandled rejection ");
        }
    } else {
        activeFireEvent(name, promise);
    }
}

function formatNonError(obj) {
    var str;
    if (typeof obj === "function") {
        str = "[function " +
            (obj.name || "anonymous") +
            "]";
    } else {
        str = obj && typeof obj.toString === "function"
            ? obj.toString() : util.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
            try {
                var newStr = JSON.stringify(obj);
                str = newStr;
            }
            catch(e) {

            }
        }
        if (str.length === 0) {
            str = "(empty array)";
        }
    }
    return ("(<" + snip(str) + ">, no stack trace)");
}

function snip(str) {
    var maxChars = 41;
    if (str.length < maxChars) {
        return str;
    }
    return str.substr(0, maxChars - 3) + "...";
}

function longStackTracesIsSupported() {
    return typeof captureStackTrace === "function";
}

var shouldIgnore = function() { return false; };
var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
function parseLineInfo(line) {
    var matches = line.match(parseLineInfoRegex);
    if (matches) {
        return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
        };
    }
}

function setBounds(firstLineError, lastLineError) {
    if (!longStackTracesIsSupported()) return;
    var firstStackLines = firstLineError.stack.split("\n");
    var lastStackLines = lastLineError.stack.split("\n");
    var firstIndex = -1;
    var lastIndex = -1;
    var firstFileName;
    var lastFileName;
    for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
        }
    }
    for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
        }
    }
    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
        firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
    }

    shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
            if (info.fileName === firstFileName &&
                (firstIndex <= info.line && info.line <= lastIndex)) {
                return true;
            }
        }
        return false;
    };
}

function CapturedTrace(parent) {
    this._parent = parent;
    this._promisesCreated = 0;
    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
    captureStackTrace(this, CapturedTrace);
    if (length > 32) this.uncycle();
}
util.inherits(CapturedTrace, Error);
Context.CapturedTrace = CapturedTrace;

CapturedTrace.prototype.uncycle = function() {
    var length = this._length;
    if (length < 2) return;
    var nodes = [];
    var stackToIndex = {};

    for (var i = 0, node = this; node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
    }
    length = this._length = i;
    for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
            stackToIndex[stack] = i;
        }
    }
    for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
            if (index > 0) {
                nodes[index - 1]._parent = undefined;
                nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = undefined;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

            if (index < length - 1) {
                cycleEdgeNode._parent = nodes[index + 1];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length =
                    cycleEdgeNode._parent._length + 1;
            } else {
                cycleEdgeNode._parent = undefined;
                cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
            }
            return;
        }
    }
};

CapturedTrace.prototype.attachExtraTrace = function(error) {
    if (error.__stackCleaned__) return;
    this.uncycle();
    var parsed = parseStackAndMessage(error);
    var message = parsed.message;
    var stacks = [parsed.stack];

    var trace = this;
    while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
    }
    removeCommonRoots(stacks);
    removeDuplicateOrEmptyJumps(stacks);
    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
    util.notEnumerableProp(error, "__stackCleaned__", true);
};

var captureStackTrace = (function stackDetection() {
    var v8stackFramePattern = /^\s*at\s*/;
    var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string") return stack;

        if (error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    if (typeof Error.stackTraceLimit === "number" &&
        typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace = Error.captureStackTrace;

        shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
        };
    }
    var err = new Error();

    if (typeof err.stack === "string" &&
        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
            o.stack = new Error().stack;
        };
    }

    var hasStackAfterThrow;
    try { throw new Error(); }
    catch(e) {
        hasStackAfterThrow = ("stack" in e);
    }
    if (!("stack" in err) && hasStackAfterThrow &&
        typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
            Error.stackTraceLimit += 6;
            try { throw new Error(); }
            catch(e) { o.stack = e.stack; }
            Error.stackTraceLimit -= 6;
        };
    }

    formatStack = function(stack, error) {
        if (typeof stack === "string") return stack;

        if ((typeof error === "object" ||
            typeof error === "function") &&
            error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    return null;

})([]);

if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
    printWarning = function (message) {
        console.warn(message);
    };
    if (util.isNode && process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
            console.warn(color + message + "\u001b[0m\n");
        };
    } else if (!util.isNode && typeof (new Error().stack) === "string") {
        printWarning = function(message, isSoft) {
            console.warn("%c" + message,
                        isSoft ? "color: darkorange" : "color: red");
        };
    }
}

var config = {
    warnings: warnings,
    longStackTraces: false,
    cancellation: false,
    monitoring: false
};

if (longStackTraces) Promise.longStackTraces();

return {
    longStackTraces: function() {
        return config.longStackTraces;
    },
    warnings: function() {
        return config.warnings;
    },
    cancellation: function() {
        return config.cancellation;
    },
    monitoring: function() {
        return config.monitoring;
    },
    propagateFromFunction: function() {
        return propagateFromFunction;
    },
    boundValueFunction: function() {
        return boundValueFunction;
    },
    checkForgottenReturns: checkForgottenReturns,
    setBounds: setBounds,
    warn: warn,
    deprecated: deprecated,
    CapturedTrace: CapturedTrace,
    fireDomEvent: fireDomEvent,
    fireGlobalEvent: fireGlobalEvent
};
};

},{"./errors":9,"./util":21}],8:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function returner() {
    return this.value;
}
function thrower() {
    throw this.reason;
}

Promise.prototype["return"] =
Promise.prototype.thenReturn = function (value) {
    if (value instanceof Promise) value.suppressUnhandledRejections();
    return this._then(
        returner, undefined, undefined, {value: value}, undefined);
};

Promise.prototype["throw"] =
Promise.prototype.thenThrow = function (reason) {
    return this._then(
        thrower, undefined, undefined, {reason: reason}, undefined);
};

Promise.prototype.catchThrow = function (reason) {
    if (arguments.length <= 1) {
        return this._then(
            undefined, thrower, undefined, {reason: reason}, undefined);
    } else {
        var _reason = arguments[1];
        var handler = function() {throw _reason;};
        return this.caught(reason, handler);
    }
};

Promise.prototype.catchReturn = function (value) {
    if (arguments.length <= 1) {
        if (value instanceof Promise) value.suppressUnhandledRejections();
        return this._then(
            undefined, returner, undefined, {value: value}, undefined);
    } else {
        var _value = arguments[1];
        if (_value instanceof Promise) _value.suppressUnhandledRejections();
        var handler = function() {return _value;};
        return this.caught(value, handler);
    }
};
};

},{}],9:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5");
var Objectfreeze = es5.freeze;
var util = _dereq_("./util");
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message",
            typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var Warning = subError("Warning", "warning");
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch(e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " +
    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    if (!(this instanceof OperationalError))
        return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }

}
inherits(OperationalError, Error);

var errorTypes = Error["__BluebirdErrorTypes__"];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
    });
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};

},{"./es5":10,"./util":21}],10:[function(_dereq_,module,exports){
var isES5 = (function(){
    "use strict";
    return this === undefined;
})();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectGetDescriptor = function(o, key) {
        return {value: o[key]};
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        }
        catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === "[object Array]";
        }
        catch(e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function() {
            return true;
        }
    };
}

},{}],11:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {
var util = _dereq_("./util");
var CancellationError = Promise.CancellationError;
var errorObj = util.errorObj;
var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);

function PassThroughHandlerContext(promise, type, handler) {
    this.promise = promise;
    this.type = type;
    this.handler = handler;
    this.called = false;
    this.cancelPromise = null;
}

PassThroughHandlerContext.prototype.isFinallyHandler = function() {
    return this.type === 0;
};

function FinallyHandlerCancelReaction(finallyHandler) {
    this.finallyHandler = finallyHandler;
}

FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
    checkCancel(this.finallyHandler);
};

function checkCancel(ctx, reason) {
    if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
        } else {
            ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
    }
    return false;
}

function succeed() {
    return finallyHandler.call(this, this.promise._target()._settledValue());
}
function fail(reason) {
    if (checkCancel(this, reason)) return;
    errorObj.e = reason;
    return errorObj;
}
function finallyHandler(reasonOrValue) {
    var promise = this.promise;
    var handler = this.handler;

    if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler()
            ? handler.call(promise._boundValue())
            : handler.call(promise._boundValue(), reasonOrValue);
        if (ret === NEXT_FILTER) {
            return ret;
        } else if (ret !== undefined) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                if (this.cancelPromise != null) {
                    if (maybePromise._isCancelled()) {
                        var reason =
                            new CancellationError("late cancellation observer");
                        promise._attachExtraTrace(reason);
                        errorObj.e = reason;
                        return errorObj;
                    } else if (maybePromise.isPending()) {
                        maybePromise._attachCancellationCallback(
                            new FinallyHandlerCancelReaction(this));
                    }
                }
                return maybePromise._then(
                    succeed, fail, undefined, this, undefined);
            }
        }
    }

    if (promise.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
    } else {
        checkCancel(this);
        return reasonOrValue;
    }
}

Promise.prototype._passThrough = function(handler, type, success, fail) {
    if (typeof handler !== "function") return this.then();
    return this._then(success,
                      fail,
                      undefined,
                      new PassThroughHandlerContext(this, type, handler),
                      undefined);
};

Promise.prototype.lastly =
Promise.prototype["finally"] = function (handler) {
    return this._passThrough(handler,
                             0,
                             finallyHandler,
                             finallyHandler);
};


Promise.prototype.tap = function (handler) {
    return this._passThrough(handler, 1, finallyHandler);
};

Promise.prototype.tapCatch = function (handlerOrPredicate) {
    var len = arguments.length;
    if(len === 1) {
        return this._passThrough(handlerOrPredicate,
                                 1,
                                 undefined,
                                 finallyHandler);
    } else {
         var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
                catchInstances[j++] = item;
            } else {
                return Promise.reject(new TypeError(
                    "tapCatch statement predicate: "
                    + "expecting an object but got " + util.classString(item)
                ));
            }
        }
        catchInstances.length = j;
        var handler = arguments[i];
        return this._passThrough(catchFilter(catchInstances, handler, this),
                                 1,
                                 undefined,
                                 finallyHandler);
    }

};

return PassThroughHandlerContext;
};

},{"./catch_filter":5,"./util":21}],12:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,
         getDomain) {
var util = _dereq_("./util");
var canEvaluate = util.canEvaluate;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var reject;

if (!true) {
if (canEvaluate) {
    var thenCallback = function(i) {
        return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
    };

    var promiseSetter = function(i) {
        return new Function("promise", "holder", "                           \n\
            'use strict';                                                    \n\
            holder.pIndex = promise;                                         \n\
            ".replace(/Index/g, i));
    };

    var generateHolderClass = function(total) {
        var props = new Array(total);
        for (var i = 0; i < props.length; ++i) {
            props[i] = "this.p" + (i+1);
        }
        var assignment = props.join(" = ") + " = null;";
        var cancellationCode= "var promise;\n" + props.map(function(prop) {
            return "                                                         \n\
                promise = " + prop + ";                                      \n\
                if (promise instanceof Promise) {                            \n\
                    promise.cancel();                                        \n\
                }                                                            \n\
            ";
        }).join("\n");
        var passedArguments = props.join(", ");
        var name = "Holder$" + total;


        var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
            'use strict';                                                    \n\
            function [TheName](fn) {                                         \n\
                [TheProperties]                                              \n\
                this.fn = fn;                                                \n\
                this.asyncNeeded = true;                                     \n\
                this.now = 0;                                                \n\
            }                                                                \n\
                                                                             \n\
            [TheName].prototype._callFunction = function(promise) {          \n\
                promise._pushContext();                                      \n\
                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
                promise._popContext();                                       \n\
                if (ret === errorObj) {                                      \n\
                    promise._rejectCallback(ret.e, false);                   \n\
                } else {                                                     \n\
                    promise._resolveCallback(ret);                           \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype.checkFulfillment = function(promise) {       \n\
                var now = ++this.now;                                        \n\
                if (now === [TheTotal]) {                                    \n\
                    if (this.asyncNeeded) {                                  \n\
                        async.invoke(this._callFunction, this, promise);     \n\
                    } else {                                                 \n\
                        this._callFunction(promise);                         \n\
                    }                                                        \n\
                                                                             \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype._resultCancelled = function() {              \n\
                [CancellationCode]                                           \n\
            };                                                               \n\
                                                                             \n\
            return [TheName];                                                \n\
        }(tryCatch, errorObj, Promise, async);                               \n\
        ";

        code = code.replace(/\[TheName\]/g, name)
            .replace(/\[TheTotal\]/g, total)
            .replace(/\[ThePassedArguments\]/g, passedArguments)
            .replace(/\[TheProperties\]/g, assignment)
            .replace(/\[CancellationCode\]/g, cancellationCode);

        return new Function("tryCatch", "errorObj", "Promise", "async", code)
                           (tryCatch, errorObj, Promise, async);
    };

    var holderClasses = [];
    var thenCallbacks = [];
    var promiseSetters = [];

    for (var i = 0; i < 8; ++i) {
        holderClasses.push(generateHolderClass(i + 1));
        thenCallbacks.push(thenCallback(i + 1));
        promiseSetters.push(promiseSetter(i + 1));
    }

    reject = function (reason) {
        this._reject(reason);
    };
}}

Promise.join = function () {
    var last = arguments.length - 1;
    var fn;
    if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (!true) {
            if (last <= 8 && canEvaluate) {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                var HolderClass = holderClasses[last - 1];
                var holder = new HolderClass(fn);
                var callbacks = thenCallbacks;

                for (var i = 0; i < last; ++i) {
                    var maybePromise = tryConvertToPromise(arguments[i], ret);
                    if (maybePromise instanceof Promise) {
                        maybePromise = maybePromise._target();
                        var bitField = maybePromise._bitField;
                        ;
                        if (((bitField & 50397184) === 0)) {
                            maybePromise._then(callbacks[i], reject,
                                               undefined, ret, holder);
                            promiseSetters[i](maybePromise, holder);
                            holder.asyncNeeded = false;
                        } else if (((bitField & 33554432) !== 0)) {
                            callbacks[i].call(ret,
                                              maybePromise._value(), holder);
                        } else if (((bitField & 16777216) !== 0)) {
                            ret._reject(maybePromise._reason());
                        } else {
                            ret._cancel();
                        }
                    } else {
                        callbacks[i].call(ret, maybePromise, holder);
                    }
                }

                if (!ret._isFateSealed()) {
                    if (holder.asyncNeeded) {
                        var domain = getDomain();
                        if (domain !== null) {
                            holder.fn = util.domainBind(domain, holder.fn);
                        }
                    }
                    ret._setAsyncGuaranteed();
                    ret._setOnCancel(holder);
                }
                return ret;
            }
        }
    }
    var args = [].slice.call(arguments);;
    if (fn) args.pop();
    var ret = new PromiseArray(args).promise();
    return fn !== undefined ? ret.spread(fn) : ret;
};

};

},{"./util":21}],13:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
var util = _dereq_("./util");
var tryCatch = util.tryCatch;

Promise.method = function (fn) {
    if (typeof fn !== "function") {
        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
    }
    return function () {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(
            value, promiseCreated, "Promise.method", ret);
        ret._resolveFromSyncValue(value);
        return ret;
    };
};

Promise.attempt = Promise["try"] = function (fn) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._pushContext();
    var value;
    if (arguments.length > 1) {
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
                                  : tryCatch(fn).call(ctx, arg);
    } else {
        value = tryCatch(fn)();
    }
    var promiseCreated = ret._popContext();
    debug.checkForgottenReturns(
        value, promiseCreated, "Promise.try", ret);
    ret._resolveFromSyncValue(value);
    return ret;
};

Promise.prototype._resolveFromSyncValue = function (value) {
    if (value === util.errorObj) {
        this._rejectCallback(value.e, false);
    } else {
        this._resolveCallback(value, true);
    }
};
};

},{"./util":21}],14:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util");
var maybeWrapAsError = util.maybeWrapAsError;
var errors = _dereq_("./errors");
var OperationalError = errors.OperationalError;
var es5 = _dereq_("./es5");

function isUntypedError(obj) {
    return obj instanceof Error &&
        es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise, multiArgs) {
    return function(err, value) {
        if (promise === null) return;
        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (!multiArgs) {
            promise._fulfill(value);
        } else {
            var args = [].slice.call(arguments, 1);;
            promise._fulfill(args);
        }
        promise = null;
    };
}

module.exports = nodebackForPromise;

},{"./errors":9,"./es5":10,"./util":21}],15:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
var makeSelfResolutionError = function () {
    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var reflectHandler = function() {
    return new Promise.PromiseInspection(this._target());
};
var apiRejection = function(msg) {
    return Promise.reject(new TypeError(msg));
};
function Proxyable() {}
var UNDEFINED_BINDING = {};
var util = _dereq_("./util");

var getDomain;
if (util.isNode) {
    getDomain = function() {
        var ret = process.domain;
        if (ret === undefined) ret = null;
        return ret;
    };
} else {
    getDomain = function() {
        return null;
    };
}
util.notEnumerableProp(Promise, "_getDomain", getDomain);

var es5 = _dereq_("./es5");
var Async = _dereq_("./async");
var async = new Async();
es5.defineProperty(Promise, "_async", {value: async});
var errors = _dereq_("./errors");
var TypeError = Promise.TypeError = errors.TypeError;
Promise.RangeError = errors.RangeError;
var CancellationError = Promise.CancellationError = errors.CancellationError;
Promise.TimeoutError = errors.TimeoutError;
Promise.OperationalError = errors.OperationalError;
Promise.RejectionError = errors.OperationalError;
Promise.AggregateError = errors.AggregateError;
var INTERNAL = function(){};
var APPLY = {};
var NEXT_FILTER = {};
var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);
var PromiseArray =
    _dereq_("./promise_array")(Promise, INTERNAL,
                               tryConvertToPromise, apiRejection, Proxyable);
var Context = _dereq_("./context")(Promise);
 /*jshint unused:false*/
var createContext = Context.create;
var debug = _dereq_("./debuggability")(Promise, Context);
var CapturedTrace = debug.CapturedTrace;
var PassThroughHandlerContext =
    _dereq_("./finally")(Promise, tryConvertToPromise, NEXT_FILTER);
var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);
var nodebackForPromise = _dereq_("./nodeback");
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
function check(self, executor) {
    if (self == null || self.constructor !== Promise) {
        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    if (typeof executor !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(executor));
    }

}

function Promise(executor) {
    if (executor !== INTERNAL) {
        check(this, executor);
    }
    this._bitField = 0;
    this._fulfillmentHandler0 = undefined;
    this._rejectionHandler0 = undefined;
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._resolveFromExecutor(executor);
    this._promiseCreated();
    this._fireEvent("promiseCreated", this);
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
    var len = arguments.length;
    if (len > 1) {
        var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
                catchInstances[j++] = item;
            } else {
                return apiRejection("Catch statement predicate: " +
                    "expecting an object but got " + util.classString(item));
            }
        }
        catchInstances.length = j;
        fn = arguments[i];
        return this.then(undefined, catchFilter(catchInstances, fn, this));
    }
    return this.then(undefined, fn);
};

Promise.prototype.reflect = function () {
    return this._then(reflectHandler,
        reflectHandler, undefined, this, undefined);
};

Promise.prototype.then = function (didFulfill, didReject) {
    if (debug.warnings() && arguments.length > 0 &&
        typeof didFulfill !== "function" &&
        typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " +
                util.classString(didFulfill);
        if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
        }
        this._warn(msg);
    }
    return this._then(didFulfill, didReject, undefined, undefined, undefined);
};

Promise.prototype.done = function (didFulfill, didReject) {
    var promise =
        this._then(didFulfill, didReject, undefined, undefined, undefined);
    promise._setIsFinal();
};

Promise.prototype.spread = function (fn) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
};

Promise.prototype.toJSON = function () {
    var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
    };
    if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
    } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
    }
    return ret;
};

Promise.prototype.all = function () {
    if (arguments.length > 0) {
        this._warn(".all() was passed arguments but it does not take any");
    }
    return new PromiseArray(this).promise();
};

Promise.prototype.error = function (fn) {
    return this.caught(util.originatesFromRejection, fn);
};

Promise.getNewLibraryCopy = module.exports;

Promise.is = function (val) {
    return val instanceof Promise;
};

Promise.fromNode = Promise.fromCallback = function(fn) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
                                         : false;
    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
    if (result === errorObj) {
        ret._rejectCallback(result.e, true);
    }
    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
    return ret;
};

Promise.all = function (promises) {
    return new PromiseArray(promises).promise();
};

Promise.cast = function (obj) {
    var ret = tryConvertToPromise(obj);
    if (!(ret instanceof Promise)) {
        ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._setFulfilled();
        ret._rejectionHandler0 = obj;
    }
    return ret;
};

Promise.resolve = Promise.fulfilled = Promise.cast;

Promise.reject = Promise.rejected = function (reason) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._rejectCallback(reason, true);
    return ret;
};

Promise.setScheduler = function(fn) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    return async.setScheduler(fn);
};

Promise.prototype._then = function (
    didFulfill,
    didReject,
    _,    receiver,
    internalData
) {
    var haveInternalData = internalData !== undefined;
    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
    var target = this._target();
    var bitField = target._bitField;

    if (!haveInternalData) {
        promise._propagateFrom(this, 3);
        promise._captureStackTrace();
        if (receiver === undefined &&
            ((this._bitField & 2097152) !== 0)) {
            if (!((bitField & 50397184) === 0)) {
                receiver = this._boundValue();
            } else {
                receiver = target === this ? undefined : this._boundTo;
            }
        }
        this._fireEvent("promiseChained", this, promise);
    }

    var domain = getDomain();
    if (!((bitField & 50397184) === 0)) {
        var handler, value, settler = target._settlePromiseCtx;
        if (((bitField & 33554432) !== 0)) {
            value = target._rejectionHandler0;
            handler = didFulfill;
        } else if (((bitField & 16777216) !== 0)) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
        } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
        }

        async.invoke(settler, target, {
            handler: domain === null ? handler
                : (typeof handler === "function" &&
                    util.domainBind(domain, handler)),
            promise: promise,
            receiver: receiver,
            value: value
        });
    } else {
        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
    }

    return promise;
};

Promise.prototype._length = function () {
    return this._bitField & 65535;
};

Promise.prototype._isFateSealed = function () {
    return (this._bitField & 117506048) !== 0;
};

Promise.prototype._isFollowing = function () {
    return (this._bitField & 67108864) === 67108864;
};

Promise.prototype._setLength = function (len) {
    this._bitField = (this._bitField & -65536) |
        (len & 65535);
};

Promise.prototype._setFulfilled = function () {
    this._bitField = this._bitField | 33554432;
    this._fireEvent("promiseFulfilled", this);
};

Promise.prototype._setRejected = function () {
    this._bitField = this._bitField | 16777216;
    this._fireEvent("promiseRejected", this);
};

Promise.prototype._setFollowing = function () {
    this._bitField = this._bitField | 67108864;
    this._fireEvent("promiseResolved", this);
};

Promise.prototype._setIsFinal = function () {
    this._bitField = this._bitField | 4194304;
};

Promise.prototype._isFinal = function () {
    return (this._bitField & 4194304) > 0;
};

Promise.prototype._unsetCancelled = function() {
    this._bitField = this._bitField & (~65536);
};

Promise.prototype._setCancelled = function() {
    this._bitField = this._bitField | 65536;
    this._fireEvent("promiseCancelled", this);
};

Promise.prototype._setWillBeCancelled = function() {
    this._bitField = this._bitField | 8388608;
};

Promise.prototype._setAsyncGuaranteed = function() {
    if (async.hasCustomScheduler()) return;
    this._bitField = this._bitField | 134217728;
};

Promise.prototype._receiverAt = function (index) {
    var ret = index === 0 ? this._receiver0 : this[
            index * 4 - 4 + 3];
    if (ret === UNDEFINED_BINDING) {
        return undefined;
    } else if (ret === undefined && this._isBound()) {
        return this._boundValue();
    }
    return ret;
};

Promise.prototype._promiseAt = function (index) {
    return this[
            index * 4 - 4 + 2];
};

Promise.prototype._fulfillmentHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 0];
};

Promise.prototype._rejectionHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 1];
};

Promise.prototype._boundValue = function() {};

Promise.prototype._migrateCallback0 = function (follower) {
    var bitField = follower._bitField;
    var fulfill = follower._fulfillmentHandler0;
    var reject = follower._rejectionHandler0;
    var promise = follower._promise0;
    var receiver = follower._receiverAt(0);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._migrateCallbackAt = function (follower, index) {
    var fulfill = follower._fulfillmentHandlerAt(index);
    var reject = follower._rejectionHandlerAt(index);
    var promise = follower._promiseAt(index);
    var receiver = follower._receiverAt(index);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._addCallbacks = function (
    fulfill,
    reject,
    promise,
    receiver,
    domain
) {
    var index = this._length();

    if (index >= 65535 - 4) {
        index = 0;
        this._setLength(0);
    }

    if (index === 0) {
        this._promise0 = promise;
        this._receiver0 = receiver;
        if (typeof fulfill === "function") {
            this._fulfillmentHandler0 =
                domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
            this._rejectionHandler0 =
                domain === null ? reject : util.domainBind(domain, reject);
        }
    } else {
        var base = index * 4 - 4;
        this[base + 2] = promise;
        this[base + 3] = receiver;
        if (typeof fulfill === "function") {
            this[base + 0] =
                domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
            this[base + 1] =
                domain === null ? reject : util.domainBind(domain, reject);
        }
    }
    this._setLength(index + 1);
    return index;
};

Promise.prototype._proxy = function (proxyable, arg) {
    this._addCallbacks(undefined, undefined, arg, proxyable, null);
};

Promise.prototype._resolveCallback = function(value, shouldBind) {
    if (((this._bitField & 117506048) !== 0)) return;
    if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false);
    var maybePromise = tryConvertToPromise(value, this);
    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

    if (shouldBind) this._propagateFrom(maybePromise, 2);

    var promise = maybePromise._target();

    if (promise === this) {
        this._reject(makeSelfResolutionError());
        return;
    }

    var bitField = promise._bitField;
    if (((bitField & 50397184) === 0)) {
        var len = this._length();
        if (len > 0) promise._migrateCallback0(this);
        for (var i = 1; i < len; ++i) {
            promise._migrateCallbackAt(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
    } else if (((bitField & 33554432) !== 0)) {
        this._fulfill(promise._value());
    } else if (((bitField & 16777216) !== 0)) {
        this._reject(promise._reason());
    } else {
        var reason = new CancellationError("late cancellation observer");
        promise._attachExtraTrace(reason);
        this._reject(reason);
    }
};

Promise.prototype._rejectCallback =
function(reason, synchronous, ignoreNonErrorWarnings) {
    var trace = util.ensureErrorObject(reason);
    var hasStack = trace === reason;
    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
        var message = "a promise was rejected with a non-error: " +
            util.classString(reason);
        this._warn(message, true);
    }
    this._attachExtraTrace(trace, synchronous ? hasStack : false);
    this._reject(reason);
};

Promise.prototype._resolveFromExecutor = function (executor) {
    if (executor === INTERNAL) return;
    var promise = this;
    this._captureStackTrace();
    this._pushContext();
    var synchronous = true;
    var r = this._execute(executor, function(value) {
        promise._resolveCallback(value);
    }, function (reason) {
        promise._rejectCallback(reason, synchronous);
    });
    synchronous = false;
    this._popContext();

    if (r !== undefined) {
        promise._rejectCallback(r, true);
    }
};

Promise.prototype._settlePromiseFromHandler = function (
    handler, receiver, value, promise
) {
    var bitField = promise._bitField;
    if (((bitField & 65536) !== 0)) return;
    promise._pushContext();
    var x;
    if (receiver === APPLY) {
        if (!value || typeof value.length !== "number") {
            x = errorObj;
            x.e = new TypeError("cannot .spread() a non-array: " +
                                    util.classString(value));
        } else {
            x = tryCatch(handler).apply(this._boundValue(), value);
        }
    } else {
        x = tryCatch(handler).call(receiver, value);
    }
    var promiseCreated = promise._popContext();
    bitField = promise._bitField;
    if (((bitField & 65536) !== 0)) return;

    if (x === NEXT_FILTER) {
        promise._reject(value);
    } else if (x === errorObj) {
        promise._rejectCallback(x.e, false);
    } else {
        debug.checkForgottenReturns(x, promiseCreated, "",  promise, this);
        promise._resolveCallback(x);
    }
};

Promise.prototype._target = function() {
    var ret = this;
    while (ret._isFollowing()) ret = ret._followee();
    return ret;
};

Promise.prototype._followee = function() {
    return this._rejectionHandler0;
};

Promise.prototype._setFollowee = function(promise) {
    this._rejectionHandler0 = promise;
};

Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
    var isPromise = promise instanceof Promise;
    var bitField = this._bitField;
    var asyncGuaranteed = ((bitField & 134217728) !== 0);
    if (((bitField & 65536) !== 0)) {
        if (isPromise) promise._invokeInternalOnCancel();

        if (receiver instanceof PassThroughHandlerContext &&
            receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise;
            if (tryCatch(handler).call(receiver, value) === errorObj) {
                promise._reject(errorObj.e);
            }
        } else if (handler === reflectHandler) {
            promise._fulfill(reflectHandler.call(receiver));
        } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
        } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
        } else {
            receiver.cancel();
        }
    } else if (typeof handler === "function") {
        if (!isPromise) {
            handler.call(receiver, value, promise);
        } else {
            if (asyncGuaranteed) promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (receiver instanceof Proxyable) {
        if (!receiver._isResolved()) {
            if (((bitField & 33554432) !== 0)) {
                receiver._promiseFulfilled(value, promise);
            } else {
                receiver._promiseRejected(value, promise);
            }
        }
    } else if (isPromise) {
        if (asyncGuaranteed) promise._setAsyncGuaranteed();
        if (((bitField & 33554432) !== 0)) {
            promise._fulfill(value);
        } else {
            promise._reject(value);
        }
    }
};

Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
    var handler = ctx.handler;
    var promise = ctx.promise;
    var receiver = ctx.receiver;
    var value = ctx.value;
    if (typeof handler === "function") {
        if (!(promise instanceof Promise)) {
            handler.call(receiver, value, promise);
        } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (promise instanceof Promise) {
        promise._reject(value);
    }
};

Promise.prototype._settlePromiseCtx = function(ctx) {
    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
};

Promise.prototype._settlePromise0 = function(handler, value, bitField) {
    var promise = this._promise0;
    var receiver = this._receiverAt(0);
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._settlePromise(promise, handler, receiver, value);
};

Promise.prototype._clearCallbackDataAtIndex = function(index) {
    var base = index * 4 - 4;
    this[base + 2] =
    this[base + 3] =
    this[base + 0] =
    this[base + 1] = undefined;
};

Promise.prototype._fulfill = function (value) {
    var bitField = this._bitField;
    if (((bitField & 117506048) >>> 16)) return;
    if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._reject(err);
    }
    this._setFulfilled();
    this._rejectionHandler0 = value;

    if ((bitField & 65535) > 0) {
        if (((bitField & 134217728) !== 0)) {
            this._settlePromises();
        } else {
            async.settlePromises(this);
        }
    }
};

Promise.prototype._reject = function (reason) {
    var bitField = this._bitField;
    if (((bitField & 117506048) >>> 16)) return;
    this._setRejected();
    this._fulfillmentHandler0 = reason;

    if (this._isFinal()) {
        return async.fatalError(reason, util.isNode);
    }

    if ((bitField & 65535) > 0) {
        async.settlePromises(this);
    } else {
        this._ensurePossibleRejectionHandled();
    }
};

Promise.prototype._fulfillPromises = function (len, value) {
    for (var i = 1; i < len; i++) {
        var handler = this._fulfillmentHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, value);
    }
};

Promise.prototype._rejectPromises = function (len, reason) {
    for (var i = 1; i < len; i++) {
        var handler = this._rejectionHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, reason);
    }
};

Promise.prototype._settlePromises = function () {
    var bitField = this._bitField;
    var len = (bitField & 65535);

    if (len > 0) {
        if (((bitField & 16842752) !== 0)) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
        } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
        }
        this._setLength(0);
    }
    this._clearCancellationData();
};

Promise.prototype._settledValue = function() {
    var bitField = this._bitField;
    if (((bitField & 33554432) !== 0)) {
        return this._rejectionHandler0;
    } else if (((bitField & 16777216) !== 0)) {
        return this._fulfillmentHandler0;
    }
};

function deferResolve(v) {this.promise._resolveCallback(v);}
function deferReject(v) {this.promise._rejectCallback(v, false);}

Promise.defer = Promise.pending = function() {
    debug.deprecated("Promise.defer", "new Promise");
    var promise = new Promise(INTERNAL);
    return {
        promise: promise,
        resolve: deferResolve,
        reject: deferReject
    };
};

util.notEnumerableProp(Promise,
                       "_makeSelfResolutionError",
                       makeSelfResolutionError);

_dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection,
    debug);
_dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);
_dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);
_dereq_("./direct_resolve")(Promise);
_dereq_("./synchronous_inspection")(Promise);
_dereq_("./join")(
    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
Promise.Promise = Promise;
Promise.version = "3.5.1";
                                                         
    util.toFastProperties(Promise);                                          
    util.toFastProperties(Promise.prototype);                                
    function fillTypes(value) {                                              
        var p = new Promise(INTERNAL);                                       
        p._fulfillmentHandler0 = value;                                      
        p._rejectionHandler0 = value;                                        
        p._promise0 = value;                                                 
        p._receiver0 = value;                                                
    }                                                                        
    // Complete slack tracking, opt out of field-type tracking and           
    // stabilize map                                                         
    fillTypes({a: 1});                                                       
    fillTypes({b: 2});                                                       
    fillTypes({c: 3});                                                       
    fillTypes(1);                                                            
    fillTypes(function(){});                                                 
    fillTypes(undefined);                                                    
    fillTypes(false);                                                        
    fillTypes(new Promise(INTERNAL));                                        
    debug.setBounds(Async.firstLineError, util.lastLineError);               
    return Promise;                                                          

};

},{"./async":1,"./bind":2,"./cancel":4,"./catch_filter":5,"./context":6,"./debuggability":7,"./direct_resolve":8,"./errors":9,"./es5":10,"./finally":11,"./join":12,"./method":13,"./nodeback":14,"./promise_array":16,"./synchronous_inspection":19,"./thenables":20,"./util":21}],16:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise,
    apiRejection, Proxyable) {
var util = _dereq_("./util");
var isArray = util.isArray;

function toResolutionValue(val) {
    switch(val) {
    case -2: return [];
    case -3: return {};
    case -6: return new Map();
    }
}

function PromiseArray(values) {
    var promise = this._promise = new Promise(INTERNAL);
    if (values instanceof Promise) {
        promise._propagateFrom(values, 3);
    }
    promise._setOnCancel(this);
    this._values = values;
    this._length = 0;
    this._totalResolved = 0;
    this._init(undefined, -2);
}
util.inherits(PromiseArray, Proxyable);

PromiseArray.prototype.length = function () {
    return this._length;
};

PromiseArray.prototype.promise = function () {
    return this._promise;
};

PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
    var values = tryConvertToPromise(this._values, this._promise);
    if (values instanceof Promise) {
        values = values._target();
        var bitField = values._bitField;
        ;
        this._values = values;

        if (((bitField & 50397184) === 0)) {
            this._promise._setAsyncGuaranteed();
            return values._then(
                init,
                this._reject,
                undefined,
                this,
                resolveValueIfEmpty
           );
        } else if (((bitField & 33554432) !== 0)) {
            values = values._value();
        } else if (((bitField & 16777216) !== 0)) {
            return this._reject(values._reason());
        } else {
            return this._cancel();
        }
    }
    values = util.asArray(values);
    if (values === null) {
        var err = apiRejection(
            "expecting an array or an iterable object but got " + util.classString(values)).reason();
        this._promise._rejectCallback(err, false);
        return;
    }

    if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
        }
        else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
    }
    this._iterate(values);
};

PromiseArray.prototype._iterate = function(values) {
    var len = this.getActualLength(values.length);
    this._length = len;
    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
    var result = this._promise;
    var isResolved = false;
    var bitField = null;
    for (var i = 0; i < len; ++i) {
        var maybePromise = tryConvertToPromise(values[i], result);

        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
        } else {
            bitField = null;
        }

        if (isResolved) {
            if (bitField !== null) {
                maybePromise.suppressUnhandledRejections();
            }
        } else if (bitField !== null) {
            if (((bitField & 50397184) === 0)) {
                maybePromise._proxy(this, i);
                this._values[i] = maybePromise;
            } else if (((bitField & 33554432) !== 0)) {
                isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if (((bitField & 16777216) !== 0)) {
                isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
                isResolved = this._promiseCancelled(i);
            }
        } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
        }
    }
    if (!isResolved) result._setAsyncGuaranteed();
};

PromiseArray.prototype._isResolved = function () {
    return this._values === null;
};

PromiseArray.prototype._resolve = function (value) {
    this._values = null;
    this._promise._fulfill(value);
};

PromiseArray.prototype._cancel = function() {
    if (this._isResolved() || !this._promise._isCancellable()) return;
    this._values = null;
    this._promise._cancel();
};

PromiseArray.prototype._reject = function (reason) {
    this._values = null;
    this._promise._rejectCallback(reason, false);
};

PromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
    }
    return false;
};

PromiseArray.prototype._promiseCancelled = function() {
    this._cancel();
    return true;
};

PromiseArray.prototype._promiseRejected = function (reason) {
    this._totalResolved++;
    this._reject(reason);
    return true;
};

PromiseArray.prototype._resultCancelled = function() {
    if (this._isResolved()) return;
    var values = this._values;
    this._cancel();
    if (values instanceof Promise) {
        values.cancel();
    } else {
        for (var i = 0; i < values.length; ++i) {
            if (values[i] instanceof Promise) {
                values[i].cancel();
            }
        }
    }
};

PromiseArray.prototype.shouldCopyValues = function () {
    return true;
};

PromiseArray.prototype.getActualLength = function (len) {
    return len;
};

return PromiseArray;
};

},{"./util":21}],17:[function(_dereq_,module,exports){
"use strict";
function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[(j + 0) & wrapMask] = fn;
    this[(j + 1) & wrapMask] = receiver;
    this[(j + 2) & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = (front + 1) & (this._capacity - 1);
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = (front + length) & (oldCapacity - 1);
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};

module.exports = Queue;

},{}],18:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util");
var schedule;
var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var NativePromise = util.getNativePromise();
if (util.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = global.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode
                ? function(fn) { GlobalSetImmediate.call(global, fn); }
                : function(fn) { ProcessNextTick.call(process, fn); };
} else if (typeof NativePromise === "function" &&
           typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
        nativePromise.then(fn);
    };
} else if ((typeof MutationObserver !== "undefined") &&
          !(typeof window !== "undefined" &&
            window.navigator &&
            (window.navigator.standalone || window.cordova))) {
    schedule = (function() {
        var div = document.createElement("div");
        var opts = {attributes: true};
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
            div.classList.toggle("foo");
            toggleScheduled = false;
        });
        o2.observe(div2, opts);

        var scheduleToggle = function() {
            if (toggleScheduled) return;
            toggleScheduled = true;
            div2.classList.toggle("foo");
        };

        return function schedule(fn) {
            var o = new MutationObserver(function() {
                o.disconnect();
                fn();
            });
            o.observe(div, opts);
            scheduleToggle();
        };
    })();
} else if (typeof setImmediate !== "undefined") {
    schedule = function (fn) {
        setImmediate(fn);
    };
} else if (typeof setTimeout !== "undefined") {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
} else {
    schedule = noAsyncScheduler;
}
module.exports = schedule;

},{"./util":21}],19:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function PromiseInspection(promise) {
    if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValueField = promise._isFateSealed()
            ? promise._settledValue() : undefined;
    }
    else {
        this._bitField = 0;
        this._settledValueField = undefined;
    }
}

PromiseInspection.prototype._settledValue = function() {
    return this._settledValueField;
};

var value = PromiseInspection.prototype.value = function () {
    if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    return this._settledValue();
};

var reason = PromiseInspection.prototype.error =
PromiseInspection.prototype.reason = function () {
    if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    return this._settledValue();
};

var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
    return (this._bitField & 33554432) !== 0;
};

var isRejected = PromiseInspection.prototype.isRejected = function () {
    return (this._bitField & 16777216) !== 0;
};

var isPending = PromiseInspection.prototype.isPending = function () {
    return (this._bitField & 50397184) === 0;
};

var isResolved = PromiseInspection.prototype.isResolved = function () {
    return (this._bitField & 50331648) !== 0;
};

PromiseInspection.prototype.isCancelled = function() {
    return (this._bitField & 8454144) !== 0;
};

Promise.prototype.__isCancelled = function() {
    return (this._bitField & 65536) === 65536;
};

Promise.prototype._isCancelled = function() {
    return this._target().__isCancelled();
};

Promise.prototype.isCancelled = function() {
    return (this._target()._bitField & 8454144) !== 0;
};

Promise.prototype.isPending = function() {
    return isPending.call(this._target());
};

Promise.prototype.isRejected = function() {
    return isRejected.call(this._target());
};

Promise.prototype.isFulfilled = function() {
    return isFulfilled.call(this._target());
};

Promise.prototype.isResolved = function() {
    return isResolved.call(this._target());
};

Promise.prototype.value = function() {
    return value.call(this._target());
};

Promise.prototype.reason = function() {
    var target = this._target();
    target._unsetRejectionIsUnhandled();
    return reason.call(target);
};

Promise.prototype._value = function() {
    return this._settledValue();
};

Promise.prototype._reason = function() {
    this._unsetRejectionIsUnhandled();
    return this._settledValue();
};

Promise.PromiseInspection = PromiseInspection;
};

},{}],20:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = _dereq_("./util");
var errorObj = util.errorObj;
var isObject = util.isObject;

function tryConvertToPromise(obj, context) {
    if (isObject(obj)) {
        if (obj instanceof Promise) return obj;
        var then = getThen(obj);
        if (then === errorObj) {
            if (context) context._pushContext();
            var ret = Promise.reject(then.e);
            if (context) context._popContext();
            return ret;
        } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj)) {
                var ret = new Promise(INTERNAL);
                obj._then(
                    ret._fulfill,
                    ret._reject,
                    undefined,
                    ret,
                    null
                );
                return ret;
            }
            return doThenable(obj, then, context);
        }
    }
    return obj;
}

function doGetThen(obj) {
    return obj.then;
}

function getThen(obj) {
    try {
        return doGetThen(obj);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

var hasProp = {}.hasOwnProperty;
function isAnyBluebirdPromise(obj) {
    try {
        return hasProp.call(obj, "_promise0");
    } catch (e) {
        return false;
    }
}

function doThenable(x, then, context) {
    var promise = new Promise(INTERNAL);
    var ret = promise;
    if (context) context._pushContext();
    promise._captureStackTrace();
    if (context) context._popContext();
    var synchronous = true;
    var result = util.tryCatch(then).call(x, resolve, reject);
    synchronous = false;

    if (promise && result === errorObj) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
    }

    function resolve(value) {
        if (!promise) return;
        promise._resolveCallback(value);
        promise = null;
    }

    function reject(reason) {
        if (!promise) return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
    }
    return ret;
}

return tryConvertToPromise;
};

},{"./util":21}],21:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5");
var canEvaluate = typeof navigator == "undefined";

var errorObj = {e: {}};
var tryCatchTarget;
var globalObject = typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    typeof global !== "undefined" ? global :
    this !== undefined ? this : null;

function tryCatcher() {
    try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) &&
                propertyName.charAt(propertyName.length-1) !== "$"
           ) {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};


function isPrimitive(val) {
    return val == null || val === true || val === false ||
        typeof val === "string" || typeof val === "number";

}

function isObject(value) {
    return typeof value === "function" ||
           typeof value === "object" && value !== null;
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);

        if (desc != null) {
            return desc.get == null && desc.set == null
                    ? desc.value
                    : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}

function thrower(r) {
    throw r;
}

var inheritedDataKeys = (function() {
    var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
    ];

    var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
                return true;
            }
        }
        return false;
    };

    if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) {
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null && !isExcludedProto(obj)) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj) {
            if (isExcludedProto(obj)) return [];
            var ret = [];

            /*jshint forin:false */
            enumeration: for (var key in obj) {
                if (hasProp.call(obj, key)) {
                    ret.push(key);
                } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                        if (hasProp.call(excludedPrototypes[i], key)) {
                            continue enumeration;
                        }
                    }
                    ret.push(key);
                }
            }
            return ret;
        };
    }

})();

var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.names(fn.prototype);

            var hasMethods = es5.isES5 && keys.length > 1;
            var hasMethodsOtherThanConstructor = keys.length > 0 &&
                !(keys.length === 1 && keys[0] === "constructor");
            var hasThisAssignmentAndStaticMethods =
                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

            if (hasMethods || hasMethodsOtherThanConstructor ||
                hasThisAssignmentAndStaticMethods) {
                return true;
            }
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027,-W055,-W031*/
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var l = 8;
    while (l--) new FakeConstructor();
    return obj;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for(var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + "";
    } catch (e) {
        return "[no string representation]";
    }
}

function isError(obj) {
    return obj instanceof Error ||
        (obj !== null &&
           typeof obj === "object" &&
           typeof obj.message === "string" &&
           typeof obj.name === "string");
}

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    }
    catch(ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
        e["isOperational"] === true);
}

function canAttachTrace(obj) {
    return isError(obj) && es5.propertyIsWritable(obj, "stack");
}

var ensureErrorObject = (function() {
    if (!("stack" in new Error())) {
        return function(value) {
            if (canAttachTrace(value)) return value;
            try {throw new Error(safeToString(value));}
            catch(err) {return err;}
        };
    } else {
        return function(value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
        };
    }
})();

function classString(obj) {
    return {}.toString.call(obj);
}

function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
            try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore) {}
        }
    }
}

var asArray = function(v) {
    if (es5.isArray(v)) {
        return v;
    }
    return null;
};

if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function(v) {
        return Array.from(v);
    } : function(v) {
        var ret = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!((itResult = it.next()).done)) {
            ret.push(itResult.value);
        }
        return ret;
    };

    asArray = function(v) {
        if (es5.isArray(v)) {
            return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
            return ArrayFrom(v);
        }
        return null;
    };
}

var isNode = typeof process !== "undefined" &&
        classString(process).toLowerCase() === "[object process]";

var hasEnvVariables = typeof process !== "undefined" &&
    typeof process.env !== "undefined";

function env(key) {
    return hasEnvVariables ? process.env[key] : undefined;
}

function getNativePromise() {
    if (typeof Promise === "function") {
        try {
            var promise = new Promise(function(){});
            if ({}.toString.call(promise) === "[object Promise]") {
                return Promise;
            }
        } catch (e) {}
    }
}

function domainBind(self, cb) {
    return self.bind(cb);
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    asArray: asArray,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    isError: isError,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome &&
                 typeof chrome.loadTimes === "function",
    isNode: isNode,
    hasEnvVariables: hasEnvVariables,
    env: env,
    global: globalObject,
    getNativePromise: getNativePromise,
    domainBind: domainBind
};
ret.isRecentNode = ret.isNode && (function() {
    var version = process.versions.node.split(".").map(Number);
    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
})();

if (ret.isNode) ret.toFastProperties(process);

try {throw new Error(); } catch (e) {ret.lastLineError = e;}
module.exports = ret;

},{"./es5":10}]},{},[3])(3)
});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
//Configure Bluebird Promises.
Promise.config({
  warnings: {
    wForgottenReturn: false
  }
});

/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.5 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.5',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));

_aureliaConfigureModuleLoader();
define('aurelia-binding/dist/commonjs/aurelia-binding',['require','exports','module','aurelia-logging','aurelia-pal','aurelia-task-queue','aurelia-metadata'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSetObserver = exports.BindingEngine = exports.NameExpression = exports.Listener = exports.ListenerExpression = exports.BindingBehaviorResource = exports.ValueConverterResource = exports.Call = exports.CallExpression = exports.Binding = exports.BindingExpression = exports.ObjectObservationAdapter = exports.ObserverLocator = exports.SVGAnalyzer = exports.presentationAttributes = exports.presentationElements = exports.elements = exports.ComputedExpression = exports.ClassObserver = exports.SelectValueObserver = exports.CheckedObserver = exports.ValueAttributeObserver = exports.StyleObserver = exports.DataAttributeObserver = exports.dataAttributeAccessor = exports.XLinkAttributeObserver = exports.SetterObserver = exports.PrimitiveObserver = exports.propertyAccessor = exports.DirtyCheckProperty = exports.DirtyChecker = exports.EventSubscriber = exports.EventManager = exports.delegationStrategy = exports.getMapObserver = exports.ParserImplementation = exports.Parser = exports.Scanner = exports.Lexer = exports.Token = exports.bindingMode = exports.ExpressionCloner = exports.Unparser = exports.LiteralObject = exports.LiteralArray = exports.LiteralString = exports.LiteralPrimitive = exports.PrefixNot = exports.Binary = exports.CallFunction = exports.CallMember = exports.CallScope = exports.AccessKeyed = exports.AccessMember = exports.AccessScope = exports.AccessThis = exports.Conditional = exports.Assign = exports.ValueConverter = exports.BindingBehavior = exports.Chain = exports.Expression = exports.getArrayObserver = exports.CollectionLengthObserver = exports.ModifyCollectionObserver = exports.ExpressionObserver = exports.sourceContext = exports.targetContext = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _dec2, _class, _dec3, _class2, _dec4, _class3, _dec5, _class5, _dec6, _class7, _dec7, _class8, _dec8, _class9, _dec9, _class10, _class12, _temp, _dec10, _class13, _class14, _temp2;

exports.camelCase = camelCase;
exports.createOverrideContext = createOverrideContext;
exports.getContextFor = getContextFor;
exports.createScopeForTest = createScopeForTest;
exports.connectable = connectable;
exports.enqueueBindingConnect = enqueueBindingConnect;
exports.subscriberCollection = subscriberCollection;
exports.calcSplices = calcSplices;
exports.mergeSplice = mergeSplice;
exports.projectArraySplices = projectArraySplices;
exports.getChangeRecords = getChangeRecords;
exports.cloneExpression = cloneExpression;
exports.hasDeclaredDependencies = hasDeclaredDependencies;
exports.declarePropertyDependencies = declarePropertyDependencies;
exports.computedFrom = computedFrom;
exports.createComputedObserver = createComputedObserver;
exports.valueConverter = valueConverter;
exports.bindingBehavior = bindingBehavior;
exports.observable = observable;
exports.connectBindingToSignal = connectBindingToSignal;
exports.signalBindings = signalBindings;

var _aureliaLogging = require('aurelia-logging');

var LogManager = _interopRequireWildcard(_aureliaLogging);

var _aureliaPal = require('aurelia-pal');

var _aureliaTaskQueue = require('aurelia-task-queue');

var _aureliaMetadata = require('aurelia-metadata');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var targetContext = exports.targetContext = 'Binding:target';
var sourceContext = exports.sourceContext = 'Binding:source';

var map = Object.create(null);

function camelCase(name) {
  if (name in map) {
    return map[name];
  }
  var result = name.charAt(0).toLowerCase() + name.slice(1).replace(/[_.-](\w|$)/g, function (_, x) {
    return x.toUpperCase();
  });
  map[name] = result;
  return result;
}

function createOverrideContext(bindingContext, parentOverrideContext) {
  return {
    bindingContext: bindingContext,
    parentOverrideContext: parentOverrideContext || null
  };
}

function getContextFor(name, scope, ancestor) {
  var oc = scope.overrideContext;

  if (ancestor) {
    while (ancestor && oc) {
      ancestor--;
      oc = oc.parentOverrideContext;
    }
    if (ancestor || !oc) {
      return undefined;
    }
    return name in oc ? oc : oc.bindingContext;
  }

  while (oc && !(name in oc) && !(oc.bindingContext && name in oc.bindingContext)) {
    oc = oc.parentOverrideContext;
  }
  if (oc) {
    return name in oc ? oc : oc.bindingContext;
  }

  return scope.bindingContext || scope.overrideContext;
}

function createScopeForTest(bindingContext, parentBindingContext) {
  if (parentBindingContext) {
    return {
      bindingContext: bindingContext,
      overrideContext: createOverrideContext(bindingContext, createOverrideContext(parentBindingContext))
    };
  }
  return {
    bindingContext: bindingContext,
    overrideContext: createOverrideContext(bindingContext)
  };
}

var slotNames = [];
var versionSlotNames = [];

for (var i = 0; i < 100; i++) {
  slotNames.push('_observer' + i);
  versionSlotNames.push('_observerVersion' + i);
}

function addObserver(observer) {
  var observerSlots = this._observerSlots === undefined ? 0 : this._observerSlots;
  var i = observerSlots;
  while (i-- && this[slotNames[i]] !== observer) {}

  if (i === -1) {
    i = 0;
    while (this[slotNames[i]]) {
      i++;
    }
    this[slotNames[i]] = observer;
    observer.subscribe(sourceContext, this);

    if (i === observerSlots) {
      this._observerSlots = i + 1;
    }
  }

  if (this._version === undefined) {
    this._version = 0;
  }
  this[versionSlotNames[i]] = this._version;
}

function observeProperty(obj, propertyName) {
  var observer = this.observerLocator.getObserver(obj, propertyName);
  addObserver.call(this, observer);
}

function observeArray(array) {
  var observer = this.observerLocator.getArrayObserver(array);
  addObserver.call(this, observer);
}

function unobserve(all) {
  var i = this._observerSlots;
  while (i--) {
    if (all || this[versionSlotNames[i]] !== this._version) {
      var observer = this[slotNames[i]];
      this[slotNames[i]] = null;
      if (observer) {
        observer.unsubscribe(sourceContext, this);
      }
    }
  }
}

function connectable() {
  return function (target) {
    target.prototype.observeProperty = observeProperty;
    target.prototype.observeArray = observeArray;
    target.prototype.unobserve = unobserve;
    target.prototype.addObserver = addObserver;
  };
}

var queue = [];
var queued = {};
var nextId = 0;
var minimumImmediate = 100;
var frameBudget = 15;

var isFlushRequested = false;
var immediate = 0;

function flush(animationFrameStart) {
  var length = queue.length;
  var i = 0;
  while (i < length) {
    var binding = queue[i];
    queued[binding.__connectQueueId] = false;
    binding.connect(true);
    i++;

    if (i % 100 === 0 && _aureliaPal.PLATFORM.performance.now() - animationFrameStart > frameBudget) {
      break;
    }
  }
  queue.splice(0, i);

  if (queue.length) {
    _aureliaPal.PLATFORM.requestAnimationFrame(flush);
  } else {
    isFlushRequested = false;
    immediate = 0;
  }
}

function enqueueBindingConnect(binding) {
  if (immediate < minimumImmediate) {
    immediate++;
    binding.connect(false);
  } else {
    var id = binding.__connectQueueId;
    if (id === undefined) {
      id = nextId;
      nextId++;
      binding.__connectQueueId = id;
    }

    if (!queued[id]) {
      queue.push(binding);
      queued[id] = true;
    }
  }
  if (!isFlushRequested) {
    isFlushRequested = true;
    _aureliaPal.PLATFORM.requestAnimationFrame(flush);
  }
}

function addSubscriber(context, callable) {
  if (this.hasSubscriber(context, callable)) {
    return false;
  }
  if (!this._context0) {
    this._context0 = context;
    this._callable0 = callable;
    return true;
  }
  if (!this._context1) {
    this._context1 = context;
    this._callable1 = callable;
    return true;
  }
  if (!this._context2) {
    this._context2 = context;
    this._callable2 = callable;
    return true;
  }
  if (!this._contextsRest) {
    this._contextsRest = [context];
    this._callablesRest = [callable];
    return true;
  }
  this._contextsRest.push(context);
  this._callablesRest.push(callable);
  return true;
}

function removeSubscriber(context, callable) {
  if (this._context0 === context && this._callable0 === callable) {
    this._context0 = null;
    this._callable0 = null;
    return true;
  }
  if (this._context1 === context && this._callable1 === callable) {
    this._context1 = null;
    this._callable1 = null;
    return true;
  }
  if (this._context2 === context && this._callable2 === callable) {
    this._context2 = null;
    this._callable2 = null;
    return true;
  }
  var callables = this._callablesRest;
  if (callables === undefined || callables.length === 0) {
    return false;
  }
  var contexts = this._contextsRest;
  var i = 0;
  while (!(callables[i] === callable && contexts[i] === context) && callables.length > i) {
    i++;
  }
  if (i >= callables.length) {
    return false;
  }
  contexts.splice(i, 1);
  callables.splice(i, 1);
  return true;
}

var arrayPool1 = [];
var arrayPool2 = [];
var poolUtilization = [];

function callSubscribers(newValue, oldValue) {
  var context0 = this._context0;
  var callable0 = this._callable0;
  var context1 = this._context1;
  var callable1 = this._callable1;
  var context2 = this._context2;
  var callable2 = this._callable2;
  var length = this._contextsRest ? this._contextsRest.length : 0;
  var contextsRest = void 0;
  var callablesRest = void 0;
  var poolIndex = void 0;
  var i = void 0;
  if (length) {
    poolIndex = poolUtilization.length;
    while (poolIndex-- && poolUtilization[poolIndex]) {}
    if (poolIndex < 0) {
      poolIndex = poolUtilization.length;
      contextsRest = [];
      callablesRest = [];
      poolUtilization.push(true);
      arrayPool1.push(contextsRest);
      arrayPool2.push(callablesRest);
    } else {
      poolUtilization[poolIndex] = true;
      contextsRest = arrayPool1[poolIndex];
      callablesRest = arrayPool2[poolIndex];
    }

    i = length;
    while (i--) {
      contextsRest[i] = this._contextsRest[i];
      callablesRest[i] = this._callablesRest[i];
    }
  }

  if (context0) {
    if (callable0) {
      callable0.call(context0, newValue, oldValue);
    } else {
      context0(newValue, oldValue);
    }
  }
  if (context1) {
    if (callable1) {
      callable1.call(context1, newValue, oldValue);
    } else {
      context1(newValue, oldValue);
    }
  }
  if (context2) {
    if (callable2) {
      callable2.call(context2, newValue, oldValue);
    } else {
      context2(newValue, oldValue);
    }
  }
  if (length) {
    for (i = 0; i < length; i++) {
      var callable = callablesRest[i];
      var context = contextsRest[i];
      if (callable) {
        callable.call(context, newValue, oldValue);
      } else {
        context(newValue, oldValue);
      }
      contextsRest[i] = null;
      callablesRest[i] = null;
    }
    poolUtilization[poolIndex] = false;
  }
}

function hasSubscribers() {
  return !!(this._context0 || this._context1 || this._context2 || this._contextsRest && this._contextsRest.length);
}

function hasSubscriber(context, callable) {
  var has = this._context0 === context && this._callable0 === callable || this._context1 === context && this._callable1 === callable || this._context2 === context && this._callable2 === callable;
  if (has) {
    return true;
  }
  var index = void 0;
  var contexts = this._contextsRest;
  if (!contexts || (index = contexts.length) === 0) {
    return false;
  }
  var callables = this._callablesRest;
  while (index--) {
    if (contexts[index] === context && callables[index] === callable) {
      return true;
    }
  }
  return false;
}

function subscriberCollection() {
  return function (target) {
    target.prototype.addSubscriber = addSubscriber;
    target.prototype.removeSubscriber = removeSubscriber;
    target.prototype.callSubscribers = callSubscribers;
    target.prototype.hasSubscribers = hasSubscribers;
    target.prototype.hasSubscriber = hasSubscriber;
  };
}

var ExpressionObserver = exports.ExpressionObserver = (_dec = connectable(), _dec2 = subscriberCollection(), _dec(_class = _dec2(_class = function () {
  function ExpressionObserver(scope, expression, observerLocator, lookupFunctions) {
    

    this.scope = scope;
    this.expression = expression;
    this.observerLocator = observerLocator;
    this.lookupFunctions = lookupFunctions;
  }

  ExpressionObserver.prototype.getValue = function getValue() {
    return this.expression.evaluate(this.scope, this.lookupFunctions);
  };

  ExpressionObserver.prototype.setValue = function setValue(newValue) {
    this.expression.assign(this.scope, newValue);
  };

  ExpressionObserver.prototype.subscribe = function subscribe(context, callable) {
    var _this = this;

    if (!this.hasSubscribers()) {
      this.oldValue = this.expression.evaluate(this.scope, this.lookupFunctions);
      this.expression.connect(this, this.scope);
    }
    this.addSubscriber(context, callable);
    if (arguments.length === 1 && context instanceof Function) {
      return {
        dispose: function dispose() {
          _this.unsubscribe(context, callable);
        }
      };
    }
  };

  ExpressionObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.unobserve(true);
      this.oldValue = undefined;
    }
  };

  ExpressionObserver.prototype.call = function call() {
    var newValue = this.expression.evaluate(this.scope, this.lookupFunctions);
    var oldValue = this.oldValue;
    if (newValue !== oldValue) {
      this.oldValue = newValue;
      this.callSubscribers(newValue, oldValue);
    }
    this._version++;
    this.expression.connect(this, this.scope);
    this.unobserve(false);
  };

  return ExpressionObserver;
}()) || _class) || _class);


function isIndex(s) {
  return +s === s >>> 0;
}

function toNumber(s) {
  return +s;
}

function newSplice(index, removed, addedCount) {
  return {
    index: index,
    removed: removed,
    addedCount: addedCount
  };
}

var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;

function ArraySplice() {}

ArraySplice.prototype = {
  calcEditDistances: function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    var rowCount = oldEnd - oldStart + 1;
    var columnCount = currentEnd - currentStart + 1;
    var distances = new Array(rowCount);
    var north = void 0;
    var west = void 0;

    for (var _i = 0; _i < rowCount; ++_i) {
      distances[_i] = new Array(columnCount);
      distances[_i][0] = _i;
    }

    for (var j = 0; j < columnCount; ++j) {
      distances[0][j] = j;
    }

    for (var _i2 = 1; _i2 < rowCount; ++_i2) {
      for (var _j = 1; _j < columnCount; ++_j) {
        if (this.equals(current[currentStart + _j - 1], old[oldStart + _i2 - 1])) {
          distances[_i2][_j] = distances[_i2 - 1][_j - 1];
        } else {
          north = distances[_i2 - 1][_j] + 1;
          west = distances[_i2][_j - 1] + 1;
          distances[_i2][_j] = north < west ? north : west;
        }
      }
    }

    return distances;
  },

  spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {
    var i = distances.length - 1;
    var j = distances[0].length - 1;
    var current = distances[i][j];
    var edits = [];
    while (i > 0 || j > 0) {
      if (i === 0) {
        edits.push(EDIT_ADD);
        j--;
        continue;
      }
      if (j === 0) {
        edits.push(EDIT_DELETE);
        i--;
        continue;
      }
      var northWest = distances[i - 1][j - 1];
      var west = distances[i - 1][j];
      var north = distances[i][j - 1];

      var min = void 0;
      if (west < north) {
        min = west < northWest ? west : northWest;
      } else {
        min = north < northWest ? north : northWest;
      }

      if (min === northWest) {
        if (northWest === current) {
          edits.push(EDIT_LEAVE);
        } else {
          edits.push(EDIT_UPDATE);
          current = northWest;
        }
        i--;
        j--;
      } else if (min === west) {
        edits.push(EDIT_DELETE);
        i--;
        current = west;
      } else {
        edits.push(EDIT_ADD);
        j--;
        current = north;
      }
    }

    edits.reverse();
    return edits;
  },

  calcSplices: function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    var prefixCount = 0;
    var suffixCount = 0;

    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
    if (currentStart === 0 && oldStart === 0) {
      prefixCount = this.sharedPrefix(current, old, minLength);
    }

    if (currentEnd === current.length && oldEnd === old.length) {
      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
    }

    currentStart += prefixCount;
    oldStart += prefixCount;
    currentEnd -= suffixCount;
    oldEnd -= suffixCount;

    if (currentEnd - currentStart === 0 && oldEnd - oldStart === 0) {
      return [];
    }

    if (currentStart === currentEnd) {
      var _splice = newSplice(currentStart, [], 0);
      while (oldStart < oldEnd) {
        _splice.removed.push(old[oldStart++]);
      }

      return [_splice];
    } else if (oldStart === oldEnd) {
      return [newSplice(currentStart, [], currentEnd - currentStart)];
    }

    var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

    var splice = undefined;
    var splices = [];
    var index = currentStart;
    var oldIndex = oldStart;
    for (var _i3 = 0; _i3 < ops.length; ++_i3) {
      switch (ops[_i3]) {
        case EDIT_LEAVE:
          if (splice) {
            splices.push(splice);
            splice = undefined;
          }

          index++;
          oldIndex++;
          break;
        case EDIT_UPDATE:
          if (!splice) {
            splice = newSplice(index, [], 0);
          }

          splice.addedCount++;
          index++;

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
        case EDIT_ADD:
          if (!splice) {
            splice = newSplice(index, [], 0);
          }

          splice.addedCount++;
          index++;
          break;
        case EDIT_DELETE:
          if (!splice) {
            splice = newSplice(index, [], 0);
          }

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
      }
    }

    if (splice) {
      splices.push(splice);
    }
    return splices;
  },

  sharedPrefix: function sharedPrefix(current, old, searchLength) {
    for (var _i4 = 0; _i4 < searchLength; ++_i4) {
      if (!this.equals(current[_i4], old[_i4])) {
        return _i4;
      }
    }

    return searchLength;
  },

  sharedSuffix: function sharedSuffix(current, old, searchLength) {
    var index1 = current.length;
    var index2 = old.length;
    var count = 0;
    while (count < searchLength && this.equals(current[--index1], old[--index2])) {
      count++;
    }

    return count;
  },

  calculateSplices: function calculateSplices(current, previous) {
    return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
  },

  equals: function equals(currentValue, previousValue) {
    return currentValue === previousValue;
  }
};

var arraySplice = new ArraySplice();

function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  return arraySplice.calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd);
}

function intersect(start1, end1, start2, end2) {
  if (end1 < start2 || end2 < start1) {
    return -1;
  }

  if (end1 === start2 || end2 === start1) {
    return 0;
  }

  if (start1 < start2) {
    if (end1 < end2) {
      return end1 - start2;
    }

    return end2 - start2;
  }

  if (end2 < end1) {
    return end2 - start1;
  }

  return end1 - start1;
}

function mergeSplice(splices, index, removed, addedCount) {
  var splice = newSplice(index, removed, addedCount);

  var inserted = false;
  var insertionOffset = 0;

  for (var _i5 = 0; _i5 < splices.length; _i5++) {
    var current = splices[_i5];
    current.index += insertionOffset;

    if (inserted) {
      continue;
    }

    var intersectCount = intersect(splice.index, splice.index + splice.removed.length, current.index, current.index + current.addedCount);

    if (intersectCount >= 0) {

      splices.splice(_i5, 1);
      _i5--;

      insertionOffset -= current.addedCount - current.removed.length;

      splice.addedCount += current.addedCount - intersectCount;
      var deleteCount = splice.removed.length + current.removed.length - intersectCount;

      if (!splice.addedCount && !deleteCount) {
        inserted = true;
      } else {
        var currentRemoved = current.removed;

        if (splice.index < current.index) {
          var prepend = splice.removed.slice(0, current.index - splice.index);
          Array.prototype.push.apply(prepend, currentRemoved);
          currentRemoved = prepend;
        }

        if (splice.index + splice.removed.length > current.index + current.addedCount) {
          var append = splice.removed.slice(current.index + current.addedCount - splice.index);
          Array.prototype.push.apply(currentRemoved, append);
        }

        splice.removed = currentRemoved;
        if (current.index < splice.index) {
          splice.index = current.index;
        }
      }
    } else if (splice.index < current.index) {

      inserted = true;

      splices.splice(_i5, 0, splice);
      _i5++;

      var offset = splice.addedCount - splice.removed.length;
      current.index += offset;
      insertionOffset += offset;
    }
  }

  if (!inserted) {
    splices.push(splice);
  }
}

function createInitialSplices(array, changeRecords) {
  var splices = [];

  for (var _i6 = 0; _i6 < changeRecords.length; _i6++) {
    var record = changeRecords[_i6];
    switch (record.type) {
      case 'splice':
        mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);
        break;
      case 'add':
      case 'update':
      case 'delete':
        if (!isIndex(record.name)) {
          continue;
        }

        var index = toNumber(record.name);
        if (index < 0) {
          continue;
        }

        mergeSplice(splices, index, [record.oldValue], record.type === 'delete' ? 0 : 1);
        break;
      default:
        console.error('Unexpected record type: ' + JSON.stringify(record));
        break;
    }
  }

  return splices;
}

function projectArraySplices(array, changeRecords) {
  var splices = [];

  createInitialSplices(array, changeRecords).forEach(function (splice) {
    if (splice.addedCount === 1 && splice.removed.length === 1) {
      if (splice.removed[0] !== array[splice.index]) {
        splices.push(splice);
      }

      return;
    }

    splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount, splice.removed, 0, splice.removed.length));
  });

  return splices;
}

function newRecord(type, object, key, oldValue) {
  return {
    type: type,
    object: object,
    key: key,
    oldValue: oldValue
  };
}

function getChangeRecords(map) {
  var entries = new Array(map.size);
  var keys = map.keys();
  var i = 0;
  var item = void 0;

  while (item = keys.next()) {
    if (item.done) {
      break;
    }

    entries[i] = newRecord('added', map, item.value);
    i++;
  }

  return entries;
}

var ModifyCollectionObserver = exports.ModifyCollectionObserver = (_dec3 = subscriberCollection(), _dec3(_class2 = function () {
  function ModifyCollectionObserver(taskQueue, collection) {
    

    this.taskQueue = taskQueue;
    this.queued = false;
    this.changeRecords = null;
    this.oldCollection = null;
    this.collection = collection;
    this.lengthPropertyName = collection instanceof Map || collection instanceof Set ? 'size' : 'length';
  }

  ModifyCollectionObserver.prototype.subscribe = function subscribe(context, callable) {
    this.addSubscriber(context, callable);
  };

  ModifyCollectionObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    this.removeSubscriber(context, callable);
  };

  ModifyCollectionObserver.prototype.addChangeRecord = function addChangeRecord(changeRecord) {
    if (!this.hasSubscribers() && !this.lengthObserver) {
      return;
    }

    if (changeRecord.type === 'splice') {
      var index = changeRecord.index;
      var arrayLength = changeRecord.object.length;
      if (index > arrayLength) {
        index = arrayLength - changeRecord.addedCount;
      } else if (index < 0) {
        index = arrayLength + changeRecord.removed.length + index - changeRecord.addedCount;
      }
      if (index < 0) {
        index = 0;
      }
      changeRecord.index = index;
    }

    if (this.changeRecords === null) {
      this.changeRecords = [changeRecord];
    } else {
      this.changeRecords.push(changeRecord);
    }

    if (!this.queued) {
      this.queued = true;
      this.taskQueue.queueMicroTask(this);
    }
  };

  ModifyCollectionObserver.prototype.flushChangeRecords = function flushChangeRecords() {
    if (this.changeRecords && this.changeRecords.length || this.oldCollection) {
      this.call();
    }
  };

  ModifyCollectionObserver.prototype.reset = function reset(oldCollection) {
    this.oldCollection = oldCollection;

    if (this.hasSubscribers() && !this.queued) {
      this.queued = true;
      this.taskQueue.queueMicroTask(this);
    }
  };

  ModifyCollectionObserver.prototype.getLengthObserver = function getLengthObserver() {
    return this.lengthObserver || (this.lengthObserver = new CollectionLengthObserver(this.collection));
  };

  ModifyCollectionObserver.prototype.call = function call() {
    var changeRecords = this.changeRecords;
    var oldCollection = this.oldCollection;
    var records = void 0;

    this.queued = false;
    this.changeRecords = [];
    this.oldCollection = null;

    if (this.hasSubscribers()) {
      if (oldCollection) {
        if (this.collection instanceof Map || this.collection instanceof Set) {
          records = getChangeRecords(oldCollection);
        } else {
          records = calcSplices(this.collection, 0, this.collection.length, oldCollection, 0, oldCollection.length);
        }
      } else {
        if (this.collection instanceof Map || this.collection instanceof Set) {
          records = changeRecords;
        } else {
          records = projectArraySplices(this.collection, changeRecords);
        }
      }

      this.callSubscribers(records);
    }

    if (this.lengthObserver) {
      this.lengthObserver.call(this.collection[this.lengthPropertyName]);
    }
  };

  return ModifyCollectionObserver;
}()) || _class2);
var CollectionLengthObserver = exports.CollectionLengthObserver = (_dec4 = subscriberCollection(), _dec4(_class3 = function () {
  function CollectionLengthObserver(collection) {
    

    this.collection = collection;
    this.lengthPropertyName = collection instanceof Map || collection instanceof Set ? 'size' : 'length';
    this.currentValue = collection[this.lengthPropertyName];
  }

  CollectionLengthObserver.prototype.getValue = function getValue() {
    return this.collection[this.lengthPropertyName];
  };

  CollectionLengthObserver.prototype.setValue = function setValue(newValue) {
    this.collection[this.lengthPropertyName] = newValue;
  };

  CollectionLengthObserver.prototype.subscribe = function subscribe(context, callable) {
    this.addSubscriber(context, callable);
  };

  CollectionLengthObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    this.removeSubscriber(context, callable);
  };

  CollectionLengthObserver.prototype.call = function call(newValue) {
    var oldValue = this.currentValue;
    this.callSubscribers(newValue, oldValue);
    this.currentValue = newValue;
  };

  return CollectionLengthObserver;
}()) || _class3);

var pop = Array.prototype.pop;
var push = Array.prototype.push;
var reverse = Array.prototype.reverse;
var shift = Array.prototype.shift;
var sort = Array.prototype.sort;
var splice = Array.prototype.splice;
var unshift = Array.prototype.unshift;

Array.prototype.pop = function () {
  var notEmpty = this.length > 0;
  var methodCallResult = pop.apply(this, arguments);
  if (notEmpty && this.__array_observer__ !== undefined) {
    this.__array_observer__.addChangeRecord({
      type: 'delete',
      object: this,
      name: this.length,
      oldValue: methodCallResult
    });
  }
  return methodCallResult;
};

Array.prototype.push = function () {
  var methodCallResult = push.apply(this, arguments);
  if (this.__array_observer__ !== undefined) {
    this.__array_observer__.addChangeRecord({
      type: 'splice',
      object: this,
      index: this.length - arguments.length,
      removed: [],
      addedCount: arguments.length
    });
  }
  return methodCallResult;
};

Array.prototype.reverse = function () {
  var oldArray = void 0;
  if (this.__array_observer__ !== undefined) {
    this.__array_observer__.flushChangeRecords();
    oldArray = this.slice();
  }
  var methodCallResult = reverse.apply(this, arguments);
  if (this.__array_observer__ !== undefined) {
    this.__array_observer__.reset(oldArray);
  }
  return methodCallResult;
};

Array.prototype.shift = function () {
  var notEmpty = this.length > 0;
  var methodCallResult = shift.apply(this, arguments);
  if (notEmpty && this.__array_observer__ !== undefined) {
    this.__array_observer__.addChangeRecord({
      type: 'delete',
      object: this,
      name: 0,
      oldValue: methodCallResult
    });
  }
  return methodCallResult;
};

Array.prototype.sort = function () {
  var oldArray = void 0;
  if (this.__array_observer__ !== undefined) {
    this.__array_observer__.flushChangeRecords();
    oldArray = this.slice();
  }
  var methodCallResult = sort.apply(this, arguments);
  if (this.__array_observer__ !== undefined) {
    this.__array_observer__.reset(oldArray);
  }
  return methodCallResult;
};

Array.prototype.splice = function () {
  var methodCallResult = splice.apply(this, arguments);
  if (this.__array_observer__ !== undefined) {
    this.__array_observer__.addChangeRecord({
      type: 'splice',
      object: this,
      index: +arguments[0],
      removed: methodCallResult,
      addedCount: arguments.length > 2 ? arguments.length - 2 : 0
    });
  }
  return methodCallResult;
};

Array.prototype.unshift = function () {
  var methodCallResult = unshift.apply(this, arguments);
  if (this.__array_observer__ !== undefined) {
    this.__array_observer__.addChangeRecord({
      type: 'splice',
      object: this,
      index: 0,
      removed: [],
      addedCount: arguments.length
    });
  }
  return methodCallResult;
};

function _getArrayObserver(taskQueue, array) {
  return ModifyArrayObserver.for(taskQueue, array);
}

exports.getArrayObserver = _getArrayObserver;

var ModifyArrayObserver = function (_ModifyCollectionObse) {
  _inherits(ModifyArrayObserver, _ModifyCollectionObse);

  function ModifyArrayObserver(taskQueue, array) {
    

    return _possibleConstructorReturn(this, _ModifyCollectionObse.call(this, taskQueue, array));
  }

  ModifyArrayObserver.for = function _for(taskQueue, array) {
    if (!('__array_observer__' in array)) {
      Reflect.defineProperty(array, '__array_observer__', {
        value: ModifyArrayObserver.create(taskQueue, array),
        enumerable: false, configurable: false
      });
    }
    return array.__array_observer__;
  };

  ModifyArrayObserver.create = function create(taskQueue, array) {
    return new ModifyArrayObserver(taskQueue, array);
  };

  return ModifyArrayObserver;
}(ModifyCollectionObserver);

var Expression = exports.Expression = function () {
  function Expression() {
    

    this.isChain = false;
    this.isAssignable = false;
  }

  Expression.prototype.evaluate = function evaluate(scope, lookupFunctions, args) {
    throw new Error('Binding expression "' + this + '" cannot be evaluated.');
  };

  Expression.prototype.assign = function assign(scope, value, lookupFunctions) {
    throw new Error('Binding expression "' + this + '" cannot be assigned to.');
  };

  Expression.prototype.toString = function toString() {
    return typeof FEATURE_NO_UNPARSER === 'undefined' ? _Unparser.unparse(this) : Function.prototype.toString.call(this);
  };

  return Expression;
}();

var Chain = exports.Chain = function (_Expression) {
  _inherits(Chain, _Expression);

  function Chain(expressions) {
    

    var _this3 = _possibleConstructorReturn(this, _Expression.call(this));

    _this3.expressions = expressions;
    _this3.isChain = true;
    return _this3;
  }

  Chain.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var result = void 0;
    var expressions = this.expressions;
    var last = void 0;

    for (var _i7 = 0, length = expressions.length; _i7 < length; ++_i7) {
      last = expressions[_i7].evaluate(scope, lookupFunctions);

      if (last !== null) {
        result = last;
      }
    }

    return result;
  };

  Chain.prototype.accept = function accept(visitor) {
    return visitor.visitChain(this);
  };

  return Chain;
}(Expression);

var BindingBehavior = exports.BindingBehavior = function (_Expression2) {
  _inherits(BindingBehavior, _Expression2);

  function BindingBehavior(expression, name, args) {
    

    var _this4 = _possibleConstructorReturn(this, _Expression2.call(this));

    _this4.expression = expression;
    _this4.name = name;
    _this4.args = args;
    return _this4;
  }

  BindingBehavior.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    return this.expression.evaluate(scope, lookupFunctions);
  };

  BindingBehavior.prototype.assign = function assign(scope, value, lookupFunctions) {
    return this.expression.assign(scope, value, lookupFunctions);
  };

  BindingBehavior.prototype.accept = function accept(visitor) {
    return visitor.visitBindingBehavior(this);
  };

  BindingBehavior.prototype.connect = function connect(binding, scope) {
    this.expression.connect(binding, scope);
  };

  BindingBehavior.prototype.bind = function bind(binding, scope, lookupFunctions) {
    if (this.expression.expression && this.expression.bind) {
      this.expression.bind(binding, scope, lookupFunctions);
    }
    var behavior = lookupFunctions.bindingBehaviors(this.name);
    if (!behavior) {
      throw new Error('No BindingBehavior named "' + this.name + '" was found!');
    }
    var behaviorKey = 'behavior-' + this.name;
    if (binding[behaviorKey]) {
      throw new Error('A binding behavior named "' + this.name + '" has already been applied to "' + this.expression + '"');
    }
    binding[behaviorKey] = behavior;
    behavior.bind.apply(behavior, [binding, scope].concat(evalList(scope, this.args, binding.lookupFunctions)));
  };

  BindingBehavior.prototype.unbind = function unbind(binding, scope) {
    var behaviorKey = 'behavior-' + this.name;
    binding[behaviorKey].unbind(binding, scope);
    binding[behaviorKey] = null;
    if (this.expression.expression && this.expression.unbind) {
      this.expression.unbind(binding, scope);
    }
  };

  return BindingBehavior;
}(Expression);

var ValueConverter = exports.ValueConverter = function (_Expression3) {
  _inherits(ValueConverter, _Expression3);

  function ValueConverter(expression, name, args, allArgs) {
    

    var _this5 = _possibleConstructorReturn(this, _Expression3.call(this));

    _this5.expression = expression;
    _this5.name = name;
    _this5.args = args;
    _this5.allArgs = allArgs;
    return _this5;
  }

  ValueConverter.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var converter = lookupFunctions.valueConverters(this.name);
    if (!converter) {
      throw new Error('No ValueConverter named "' + this.name + '" was found!');
    }

    if ('toView' in converter) {
      return converter.toView.apply(converter, evalList(scope, this.allArgs, lookupFunctions));
    }

    return this.allArgs[0].evaluate(scope, lookupFunctions);
  };

  ValueConverter.prototype.assign = function assign(scope, value, lookupFunctions) {
    var converter = lookupFunctions.valueConverters(this.name);
    if (!converter) {
      throw new Error('No ValueConverter named "' + this.name + '" was found!');
    }

    if ('fromView' in converter) {
      value = converter.fromView.apply(converter, [value].concat(evalList(scope, this.args, lookupFunctions)));
    }

    return this.allArgs[0].assign(scope, value, lookupFunctions);
  };

  ValueConverter.prototype.accept = function accept(visitor) {
    return visitor.visitValueConverter(this);
  };

  ValueConverter.prototype.connect = function connect(binding, scope) {
    var expressions = this.allArgs;
    var i = expressions.length;
    while (i--) {
      expressions[i].connect(binding, scope);
    }
    var converter = binding.lookupFunctions.valueConverters(this.name);
    if (!converter) {
      throw new Error('No ValueConverter named "' + this.name + '" was found!');
    }
    var signals = converter.signals;
    if (signals === undefined) {
      return;
    }
    i = signals.length;
    while (i--) {
      connectBindingToSignal(binding, signals[i]);
    }
  };

  return ValueConverter;
}(Expression);

var Assign = exports.Assign = function (_Expression4) {
  _inherits(Assign, _Expression4);

  function Assign(target, value) {
    

    var _this6 = _possibleConstructorReturn(this, _Expression4.call(this));

    _this6.target = target;
    _this6.value = value;
    _this6.isAssignable = true;
    return _this6;
  }

  Assign.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    return this.target.assign(scope, this.value.evaluate(scope, lookupFunctions));
  };

  Assign.prototype.accept = function accept(vistor) {
    vistor.visitAssign(this);
  };

  Assign.prototype.connect = function connect(binding, scope) {};

  Assign.prototype.assign = function assign(scope, value) {
    this.value.assign(scope, value);
    this.target.assign(scope, value);
  };

  return Assign;
}(Expression);

var Conditional = exports.Conditional = function (_Expression5) {
  _inherits(Conditional, _Expression5);

  function Conditional(condition, yes, no) {
    

    var _this7 = _possibleConstructorReturn(this, _Expression5.call(this));

    _this7.condition = condition;
    _this7.yes = yes;
    _this7.no = no;
    return _this7;
  }

  Conditional.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    return !!this.condition.evaluate(scope, lookupFunctions) ? this.yes.evaluate(scope, lookupFunctions) : this.no.evaluate(scope, lookupFunctions);
  };

  Conditional.prototype.accept = function accept(visitor) {
    return visitor.visitConditional(this);
  };

  Conditional.prototype.connect = function connect(binding, scope) {
    this.condition.connect(binding, scope);
    if (this.condition.evaluate(scope)) {
      this.yes.connect(binding, scope);
    } else {
      this.no.connect(binding, scope);
    }
  };

  return Conditional;
}(Expression);

var AccessThis = exports.AccessThis = function (_Expression6) {
  _inherits(AccessThis, _Expression6);

  function AccessThis(ancestor) {
    

    var _this8 = _possibleConstructorReturn(this, _Expression6.call(this));

    _this8.ancestor = ancestor;
    return _this8;
  }

  AccessThis.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var oc = scope.overrideContext;
    var i = this.ancestor;
    while (i-- && oc) {
      oc = oc.parentOverrideContext;
    }
    return i < 1 && oc ? oc.bindingContext : undefined;
  };

  AccessThis.prototype.accept = function accept(visitor) {
    return visitor.visitAccessThis(this);
  };

  AccessThis.prototype.connect = function connect(binding, scope) {};

  return AccessThis;
}(Expression);

var AccessScope = exports.AccessScope = function (_Expression7) {
  _inherits(AccessScope, _Expression7);

  function AccessScope(name, ancestor) {
    

    var _this9 = _possibleConstructorReturn(this, _Expression7.call(this));

    _this9.name = name;
    _this9.ancestor = ancestor;
    _this9.isAssignable = true;
    return _this9;
  }

  AccessScope.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var context = getContextFor(this.name, scope, this.ancestor);
    return context[this.name];
  };

  AccessScope.prototype.assign = function assign(scope, value) {
    var context = getContextFor(this.name, scope, this.ancestor);
    return context ? context[this.name] = value : undefined;
  };

  AccessScope.prototype.accept = function accept(visitor) {
    return visitor.visitAccessScope(this);
  };

  AccessScope.prototype.connect = function connect(binding, scope) {
    var context = getContextFor(this.name, scope, this.ancestor);
    binding.observeProperty(context, this.name);
  };

  return AccessScope;
}(Expression);

var AccessMember = exports.AccessMember = function (_Expression8) {
  _inherits(AccessMember, _Expression8);

  function AccessMember(object, name) {
    

    var _this10 = _possibleConstructorReturn(this, _Expression8.call(this));

    _this10.object = object;
    _this10.name = name;
    _this10.isAssignable = true;
    return _this10;
  }

  AccessMember.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var instance = this.object.evaluate(scope, lookupFunctions);
    return instance === null || instance === undefined ? instance : instance[this.name];
  };

  AccessMember.prototype.assign = function assign(scope, value) {
    var instance = this.object.evaluate(scope);

    if (instance === null || instance === undefined) {
      instance = {};
      this.object.assign(scope, instance);
    }

    instance[this.name] = value;
    return value;
  };

  AccessMember.prototype.accept = function accept(visitor) {
    return visitor.visitAccessMember(this);
  };

  AccessMember.prototype.connect = function connect(binding, scope) {
    this.object.connect(binding, scope);
    var obj = this.object.evaluate(scope);
    if (obj) {
      binding.observeProperty(obj, this.name);
    }
  };

  return AccessMember;
}(Expression);

var AccessKeyed = exports.AccessKeyed = function (_Expression9) {
  _inherits(AccessKeyed, _Expression9);

  function AccessKeyed(object, key) {
    

    var _this11 = _possibleConstructorReturn(this, _Expression9.call(this));

    _this11.object = object;
    _this11.key = key;
    _this11.isAssignable = true;
    return _this11;
  }

  AccessKeyed.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var instance = this.object.evaluate(scope, lookupFunctions);
    var lookup = this.key.evaluate(scope, lookupFunctions);
    return getKeyed(instance, lookup);
  };

  AccessKeyed.prototype.assign = function assign(scope, value) {
    var instance = this.object.evaluate(scope);
    var lookup = this.key.evaluate(scope);
    return setKeyed(instance, lookup, value);
  };

  AccessKeyed.prototype.accept = function accept(visitor) {
    return visitor.visitAccessKeyed(this);
  };

  AccessKeyed.prototype.connect = function connect(binding, scope) {
    this.object.connect(binding, scope);
    var obj = this.object.evaluate(scope);
    if (obj instanceof Object) {
      this.key.connect(binding, scope);
      var key = this.key.evaluate(scope);

      if (key !== null && key !== undefined && !(Array.isArray(obj) && typeof key === 'number')) {
        binding.observeProperty(obj, key);
      }
    }
  };

  return AccessKeyed;
}(Expression);

var CallScope = exports.CallScope = function (_Expression10) {
  _inherits(CallScope, _Expression10);

  function CallScope(name, args, ancestor) {
    

    var _this12 = _possibleConstructorReturn(this, _Expression10.call(this));

    _this12.name = name;
    _this12.args = args;
    _this12.ancestor = ancestor;
    return _this12;
  }

  CallScope.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
    var args = evalList(scope, this.args, lookupFunctions);
    var context = getContextFor(this.name, scope, this.ancestor);
    var func = getFunction(context, this.name, mustEvaluate);
    if (func) {
      return func.apply(context, args);
    }
    return undefined;
  };

  CallScope.prototype.accept = function accept(visitor) {
    return visitor.visitCallScope(this);
  };

  CallScope.prototype.connect = function connect(binding, scope) {
    var args = this.args;
    var i = args.length;
    while (i--) {
      args[i].connect(binding, scope);
    }
  };

  return CallScope;
}(Expression);

var CallMember = exports.CallMember = function (_Expression11) {
  _inherits(CallMember, _Expression11);

  function CallMember(object, name, args) {
    

    var _this13 = _possibleConstructorReturn(this, _Expression11.call(this));

    _this13.object = object;
    _this13.name = name;
    _this13.args = args;
    return _this13;
  }

  CallMember.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
    var instance = this.object.evaluate(scope, lookupFunctions);
    var args = evalList(scope, this.args, lookupFunctions);
    var func = getFunction(instance, this.name, mustEvaluate);
    if (func) {
      return func.apply(instance, args);
    }
    return undefined;
  };

  CallMember.prototype.accept = function accept(visitor) {
    return visitor.visitCallMember(this);
  };

  CallMember.prototype.connect = function connect(binding, scope) {
    this.object.connect(binding, scope);
    var obj = this.object.evaluate(scope);
    if (getFunction(obj, this.name, false)) {
      var args = this.args;
      var _i8 = args.length;
      while (_i8--) {
        args[_i8].connect(binding, scope);
      }
    }
  };

  return CallMember;
}(Expression);

var CallFunction = exports.CallFunction = function (_Expression12) {
  _inherits(CallFunction, _Expression12);

  function CallFunction(func, args) {
    

    var _this14 = _possibleConstructorReturn(this, _Expression12.call(this));

    _this14.func = func;
    _this14.args = args;
    return _this14;
  }

  CallFunction.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
    var func = this.func.evaluate(scope, lookupFunctions);
    if (typeof func === 'function') {
      return func.apply(null, evalList(scope, this.args, lookupFunctions));
    }
    if (!mustEvaluate && (func === null || func === undefined)) {
      return undefined;
    }
    throw new Error(this.func + ' is not a function');
  };

  CallFunction.prototype.accept = function accept(visitor) {
    return visitor.visitCallFunction(this);
  };

  CallFunction.prototype.connect = function connect(binding, scope) {
    this.func.connect(binding, scope);
    var func = this.func.evaluate(scope);
    if (typeof func === 'function') {
      var args = this.args;
      var _i9 = args.length;
      while (_i9--) {
        args[_i9].connect(binding, scope);
      }
    }
  };

  return CallFunction;
}(Expression);

var Binary = exports.Binary = function (_Expression13) {
  _inherits(Binary, _Expression13);

  function Binary(operation, left, right) {
    

    var _this15 = _possibleConstructorReturn(this, _Expression13.call(this));

    _this15.operation = operation;
    _this15.left = left;
    _this15.right = right;
    return _this15;
  }

  Binary.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var left = this.left.evaluate(scope, lookupFunctions);

    switch (this.operation) {
      case '&&':
        return left && this.right.evaluate(scope, lookupFunctions);
      case '||':
        return left || this.right.evaluate(scope, lookupFunctions);
    }

    var right = this.right.evaluate(scope, lookupFunctions);

    switch (this.operation) {
      case '==':
        return left == right;
      case '===':
        return left === right;
      case '!=':
        return left != right;
      case '!==':
        return left !== right;
    }

    if (left === null || right === null || left === undefined || right === undefined) {
      switch (this.operation) {
        case '+':
          if (left !== null && left !== undefined) return left;
          if (right !== null && right !== undefined) return right;
          return 0;
        case '-':
          if (left !== null && left !== undefined) return left;
          if (right !== null && right !== undefined) return 0 - right;
          return 0;
      }

      return null;
    }

    switch (this.operation) {
      case '+':
        return autoConvertAdd(left, right);
      case '-':
        return left - right;
      case '*':
        return left * right;
      case '/':
        return left / right;
      case '%':
        return left % right;
      case '<':
        return left < right;
      case '>':
        return left > right;
      case '<=':
        return left <= right;
      case '>=':
        return left >= right;
      case '^':
        return left ^ right;
    }

    throw new Error('Internal error [' + this.operation + '] not handled');
  };

  Binary.prototype.accept = function accept(visitor) {
    return visitor.visitBinary(this);
  };

  Binary.prototype.connect = function connect(binding, scope) {
    this.left.connect(binding, scope);
    var left = this.left.evaluate(scope);
    if (this.operation === '&&' && !left || this.operation === '||' && left) {
      return;
    }
    this.right.connect(binding, scope);
  };

  return Binary;
}(Expression);

var PrefixNot = exports.PrefixNot = function (_Expression14) {
  _inherits(PrefixNot, _Expression14);

  function PrefixNot(operation, expression) {
    

    var _this16 = _possibleConstructorReturn(this, _Expression14.call(this));

    _this16.operation = operation;
    _this16.expression = expression;
    return _this16;
  }

  PrefixNot.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    return !this.expression.evaluate(scope, lookupFunctions);
  };

  PrefixNot.prototype.accept = function accept(visitor) {
    return visitor.visitPrefix(this);
  };

  PrefixNot.prototype.connect = function connect(binding, scope) {
    this.expression.connect(binding, scope);
  };

  return PrefixNot;
}(Expression);

var LiteralPrimitive = exports.LiteralPrimitive = function (_Expression15) {
  _inherits(LiteralPrimitive, _Expression15);

  function LiteralPrimitive(value) {
    

    var _this17 = _possibleConstructorReturn(this, _Expression15.call(this));

    _this17.value = value;
    return _this17;
  }

  LiteralPrimitive.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    return this.value;
  };

  LiteralPrimitive.prototype.accept = function accept(visitor) {
    return visitor.visitLiteralPrimitive(this);
  };

  LiteralPrimitive.prototype.connect = function connect(binding, scope) {};

  return LiteralPrimitive;
}(Expression);

var LiteralString = exports.LiteralString = function (_Expression16) {
  _inherits(LiteralString, _Expression16);

  function LiteralString(value) {
    

    var _this18 = _possibleConstructorReturn(this, _Expression16.call(this));

    _this18.value = value;
    return _this18;
  }

  LiteralString.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    return this.value;
  };

  LiteralString.prototype.accept = function accept(visitor) {
    return visitor.visitLiteralString(this);
  };

  LiteralString.prototype.connect = function connect(binding, scope) {};

  return LiteralString;
}(Expression);

var LiteralArray = exports.LiteralArray = function (_Expression17) {
  _inherits(LiteralArray, _Expression17);

  function LiteralArray(elements) {
    

    var _this19 = _possibleConstructorReturn(this, _Expression17.call(this));

    _this19.elements = elements;
    return _this19;
  }

  LiteralArray.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var elements = this.elements;
    var result = [];

    for (var _i10 = 0, length = elements.length; _i10 < length; ++_i10) {
      result[_i10] = elements[_i10].evaluate(scope, lookupFunctions);
    }

    return result;
  };

  LiteralArray.prototype.accept = function accept(visitor) {
    return visitor.visitLiteralArray(this);
  };

  LiteralArray.prototype.connect = function connect(binding, scope) {
    var length = this.elements.length;
    for (var _i11 = 0; _i11 < length; _i11++) {
      this.elements[_i11].connect(binding, scope);
    }
  };

  return LiteralArray;
}(Expression);

var LiteralObject = exports.LiteralObject = function (_Expression18) {
  _inherits(LiteralObject, _Expression18);

  function LiteralObject(keys, values) {
    

    var _this20 = _possibleConstructorReturn(this, _Expression18.call(this));

    _this20.keys = keys;
    _this20.values = values;
    return _this20;
  }

  LiteralObject.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var instance = {};
    var keys = this.keys;
    var values = this.values;

    for (var _i12 = 0, length = keys.length; _i12 < length; ++_i12) {
      instance[keys[_i12]] = values[_i12].evaluate(scope, lookupFunctions);
    }

    return instance;
  };

  LiteralObject.prototype.accept = function accept(visitor) {
    return visitor.visitLiteralObject(this);
  };

  LiteralObject.prototype.connect = function connect(binding, scope) {
    var length = this.keys.length;
    for (var _i13 = 0; _i13 < length; _i13++) {
      this.values[_i13].connect(binding, scope);
    }
  };

  return LiteralObject;
}(Expression);

function evalList(scope, list, lookupFunctions) {
  var length = list.length;
  var result = [];
  for (var _i14 = 0; _i14 < length; _i14++) {
    result[_i14] = list[_i14].evaluate(scope, lookupFunctions);
  }
  return result;
}

function autoConvertAdd(a, b) {
  if (a !== null && b !== null) {
    if (typeof a === 'string' && typeof b !== 'string') {
      return a + b.toString();
    }

    if (typeof a !== 'string' && typeof b === 'string') {
      return a.toString() + b;
    }

    return a + b;
  }

  if (a !== null) {
    return a;
  }

  if (b !== null) {
    return b;
  }

  return 0;
}

function getFunction(obj, name, mustExist) {
  var func = obj === null || obj === undefined ? null : obj[name];
  if (typeof func === 'function') {
    return func;
  }
  if (!mustExist && (func === null || func === undefined)) {
    return null;
  }
  throw new Error(name + ' is not a function');
}

function getKeyed(obj, key) {
  if (Array.isArray(obj)) {
    return obj[parseInt(key, 10)];
  } else if (obj) {
    return obj[key];
  } else if (obj === null || obj === undefined) {
    return undefined;
  }

  return obj[key];
}

function setKeyed(obj, key, value) {
  if (Array.isArray(obj)) {
    var index = parseInt(key, 10);

    if (obj.length <= index) {
      obj.length = index + 1;
    }

    obj[index] = value;
  } else {
    obj[key] = value;
  }

  return value;
}

var _Unparser = null;

exports.Unparser = _Unparser;
if (typeof FEATURE_NO_UNPARSER === 'undefined') {
  exports.Unparser = _Unparser = function () {
    function Unparser(buffer) {
      

      this.buffer = buffer;
    }

    Unparser.unparse = function unparse(expression) {
      var buffer = [];
      var visitor = new _Unparser(buffer);

      expression.accept(visitor);

      return buffer.join('');
    };

    Unparser.prototype.write = function write(text) {
      this.buffer.push(text);
    };

    Unparser.prototype.writeArgs = function writeArgs(args) {
      this.write('(');

      for (var _i15 = 0, length = args.length; _i15 < length; ++_i15) {
        if (_i15 !== 0) {
          this.write(',');
        }

        args[_i15].accept(this);
      }

      this.write(')');
    };

    Unparser.prototype.visitChain = function visitChain(chain) {
      var expressions = chain.expressions;

      for (var _i16 = 0, length = expressions.length; _i16 < length; ++_i16) {
        if (_i16 !== 0) {
          this.write(';');
        }

        expressions[_i16].accept(this);
      }
    };

    Unparser.prototype.visitBindingBehavior = function visitBindingBehavior(behavior) {
      var args = behavior.args;

      behavior.expression.accept(this);
      this.write('&' + behavior.name);

      for (var _i17 = 0, length = args.length; _i17 < length; ++_i17) {
        this.write(':');
        args[_i17].accept(this);
      }
    };

    Unparser.prototype.visitValueConverter = function visitValueConverter(converter) {
      var args = converter.args;

      converter.expression.accept(this);
      this.write('|' + converter.name);

      for (var _i18 = 0, length = args.length; _i18 < length; ++_i18) {
        this.write(':');
        args[_i18].accept(this);
      }
    };

    Unparser.prototype.visitAssign = function visitAssign(assign) {
      assign.target.accept(this);
      this.write('=');
      assign.value.accept(this);
    };

    Unparser.prototype.visitConditional = function visitConditional(conditional) {
      conditional.condition.accept(this);
      this.write('?');
      conditional.yes.accept(this);
      this.write(':');
      conditional.no.accept(this);
    };

    Unparser.prototype.visitAccessThis = function visitAccessThis(access) {
      if (access.ancestor === 0) {
        this.write('$this');
        return;
      }
      this.write('$parent');
      var i = access.ancestor - 1;
      while (i--) {
        this.write('.$parent');
      }
    };

    Unparser.prototype.visitAccessScope = function visitAccessScope(access) {
      var i = access.ancestor;
      while (i--) {
        this.write('$parent.');
      }
      this.write(access.name);
    };

    Unparser.prototype.visitAccessMember = function visitAccessMember(access) {
      access.object.accept(this);
      this.write('.' + access.name);
    };

    Unparser.prototype.visitAccessKeyed = function visitAccessKeyed(access) {
      access.object.accept(this);
      this.write('[');
      access.key.accept(this);
      this.write(']');
    };

    Unparser.prototype.visitCallScope = function visitCallScope(call) {
      var i = call.ancestor;
      while (i--) {
        this.write('$parent.');
      }
      this.write(call.name);
      this.writeArgs(call.args);
    };

    Unparser.prototype.visitCallFunction = function visitCallFunction(call) {
      call.func.accept(this);
      this.writeArgs(call.args);
    };

    Unparser.prototype.visitCallMember = function visitCallMember(call) {
      call.object.accept(this);
      this.write('.' + call.name);
      this.writeArgs(call.args);
    };

    Unparser.prototype.visitPrefix = function visitPrefix(prefix) {
      this.write('(' + prefix.operation);
      prefix.expression.accept(this);
      this.write(')');
    };

    Unparser.prototype.visitBinary = function visitBinary(binary) {
      binary.left.accept(this);
      this.write(binary.operation);
      binary.right.accept(this);
    };

    Unparser.prototype.visitLiteralPrimitive = function visitLiteralPrimitive(literal) {
      this.write('' + literal.value);
    };

    Unparser.prototype.visitLiteralArray = function visitLiteralArray(literal) {
      var elements = literal.elements;

      this.write('[');

      for (var _i19 = 0, length = elements.length; _i19 < length; ++_i19) {
        if (_i19 !== 0) {
          this.write(',');
        }

        elements[_i19].accept(this);
      }

      this.write(']');
    };

    Unparser.prototype.visitLiteralObject = function visitLiteralObject(literal) {
      var keys = literal.keys;
      var values = literal.values;

      this.write('{');

      for (var _i20 = 0, length = keys.length; _i20 < length; ++_i20) {
        if (_i20 !== 0) {
          this.write(',');
        }

        this.write('\'' + keys[_i20] + '\':');
        values[_i20].accept(this);
      }

      this.write('}');
    };

    Unparser.prototype.visitLiteralString = function visitLiteralString(literal) {
      var escaped = literal.value.replace(/'/g, "\'");
      this.write('\'' + escaped + '\'');
    };

    return Unparser;
  }();
}

var ExpressionCloner = exports.ExpressionCloner = function () {
  function ExpressionCloner() {
    
  }

  ExpressionCloner.prototype.cloneExpressionArray = function cloneExpressionArray(array) {
    var clonedArray = [];
    var i = array.length;
    while (i--) {
      clonedArray[i] = array[i].accept(this);
    }
    return clonedArray;
  };

  ExpressionCloner.prototype.visitChain = function visitChain(chain) {
    return new Chain(this.cloneExpressionArray(chain.expressions));
  };

  ExpressionCloner.prototype.visitBindingBehavior = function visitBindingBehavior(behavior) {
    return new BindingBehavior(behavior.expression.accept(this), behavior.name, this.cloneExpressionArray(behavior.args));
  };

  ExpressionCloner.prototype.visitValueConverter = function visitValueConverter(converter) {
    return new ValueConverter(converter.expression.accept(this), converter.name, this.cloneExpressionArray(converter.args));
  };

  ExpressionCloner.prototype.visitAssign = function visitAssign(assign) {
    return new Assign(assign.target.accept(this), assign.value.accept(this));
  };

  ExpressionCloner.prototype.visitConditional = function visitConditional(conditional) {
    return new Conditional(conditional.condition.accept(this), conditional.yes.accept(this), conditional.no.accept(this));
  };

  ExpressionCloner.prototype.visitAccessThis = function visitAccessThis(access) {
    return new AccessThis(access.ancestor);
  };

  ExpressionCloner.prototype.visitAccessScope = function visitAccessScope(access) {
    return new AccessScope(access.name, access.ancestor);
  };

  ExpressionCloner.prototype.visitAccessMember = function visitAccessMember(access) {
    return new AccessMember(access.object.accept(this), access.name);
  };

  ExpressionCloner.prototype.visitAccessKeyed = function visitAccessKeyed(access) {
    return new AccessKeyed(access.object.accept(this), access.key.accept(this));
  };

  ExpressionCloner.prototype.visitCallScope = function visitCallScope(call) {
    return new CallScope(call.name, this.cloneExpressionArray(call.args), call.ancestor);
  };

  ExpressionCloner.prototype.visitCallFunction = function visitCallFunction(call) {
    return new CallFunction(call.func.accept(this), this.cloneExpressionArray(call.args));
  };

  ExpressionCloner.prototype.visitCallMember = function visitCallMember(call) {
    return new CallMember(call.object.accept(this), call.name, this.cloneExpressionArray(call.args));
  };

  ExpressionCloner.prototype.visitPrefix = function visitPrefix(prefix) {
    return new PrefixNot(prefix.operation, prefix.expression.accept(this));
  };

  ExpressionCloner.prototype.visitBinary = function visitBinary(binary) {
    return new Binary(binary.operation, binary.left.accept(this), binary.right.accept(this));
  };

  ExpressionCloner.prototype.visitLiteralPrimitive = function visitLiteralPrimitive(literal) {
    return new LiteralPrimitive(literal);
  };

  ExpressionCloner.prototype.visitLiteralArray = function visitLiteralArray(literal) {
    return new LiteralArray(this.cloneExpressionArray(literal.elements));
  };

  ExpressionCloner.prototype.visitLiteralObject = function visitLiteralObject(literal) {
    return new LiteralObject(literal.keys, this.cloneExpressionArray(literal.values));
  };

  ExpressionCloner.prototype.visitLiteralString = function visitLiteralString(literal) {
    return new LiteralString(literal.value);
  };

  return ExpressionCloner;
}();

function cloneExpression(expression) {
  var visitor = new ExpressionCloner();
  return expression.accept(visitor);
}

var bindingMode = exports.bindingMode = {
  oneTime: 0,
  toView: 1,
  oneWay: 1,
  twoWay: 2,
  fromView: 3
};

var Token = exports.Token = function () {
  function Token(index, text) {
    

    this.index = index;
    this.text = text;
  }

  Token.prototype.withOp = function withOp(op) {
    this.opKey = op;
    return this;
  };

  Token.prototype.withGetterSetter = function withGetterSetter(key) {
    this.key = key;
    return this;
  };

  Token.prototype.withValue = function withValue(value) {
    this.value = value;
    return this;
  };

  Token.prototype.toString = function toString() {
    return 'Token(' + this.text + ')';
  };

  return Token;
}();

var Lexer = exports.Lexer = function () {
  function Lexer() {
    
  }

  Lexer.prototype.lex = function lex(text) {
    var scanner = new Scanner(text);
    var tokens = [];
    var token = scanner.scanToken();

    while (token) {
      tokens.push(token);
      token = scanner.scanToken();
    }

    return tokens;
  };

  return Lexer;
}();

var Scanner = exports.Scanner = function () {
  function Scanner(input) {
    

    this.input = input;
    this.length = input.length;
    this.peek = 0;
    this.index = -1;

    this.advance();
  }

  Scanner.prototype.scanToken = function scanToken() {
    while (this.peek <= $SPACE) {
      if (++this.index >= this.length) {
        this.peek = $EOF;
        return null;
      }

      this.peek = this.input.charCodeAt(this.index);
    }

    if (isIdentifierStart(this.peek)) {
      return this.scanIdentifier();
    }

    if (isDigit(this.peek)) {
      return this.scanNumber(this.index);
    }

    var start = this.index;

    switch (this.peek) {
      case $PERIOD:
        this.advance();
        return isDigit(this.peek) ? this.scanNumber(start) : new Token(start, '.');
      case $LPAREN:
      case $RPAREN:
      case $LBRACE:
      case $RBRACE:
      case $LBRACKET:
      case $RBRACKET:
      case $COMMA:
      case $COLON:
      case $SEMICOLON:
        return this.scanCharacter(start, String.fromCharCode(this.peek));
      case $SQ:
      case $DQ:
        return this.scanString();
      case $PLUS:
      case $MINUS:
      case $STAR:
      case $SLASH:
      case $PERCENT:
      case $CARET:
      case $QUESTION:
        return this.scanOperator(start, String.fromCharCode(this.peek));
      case $LT:
      case $GT:
      case $BANG:
      case $EQ:
        return this.scanComplexOperator(start, $EQ, String.fromCharCode(this.peek), '=');
      case $AMPERSAND:
        return this.scanComplexOperator(start, $AMPERSAND, '&', '&');
      case $BAR:
        return this.scanComplexOperator(start, $BAR, '|', '|');
      case $NBSP:
        while (isWhitespace(this.peek)) {
          this.advance();
        }

        return this.scanToken();
    }

    var character = String.fromCharCode(this.peek);
    this.error('Unexpected character [' + character + ']');
    return null;
  };

  Scanner.prototype.scanCharacter = function scanCharacter(start, text) {
    assert(this.peek === text.charCodeAt(0));
    this.advance();
    return new Token(start, text);
  };

  Scanner.prototype.scanOperator = function scanOperator(start, text) {
    assert(this.peek === text.charCodeAt(0));
    assert(OPERATORS[text] === 1);
    this.advance();
    return new Token(start, text).withOp(text);
  };

  Scanner.prototype.scanComplexOperator = function scanComplexOperator(start, code, one, two) {
    assert(this.peek === one.charCodeAt(0));
    this.advance();

    var text = one;

    if (this.peek === code) {
      this.advance();
      text += two;
    }

    if (this.peek === code) {
      this.advance();
      text += two;
    }

    assert(OPERATORS[text] === 1);

    return new Token(start, text).withOp(text);
  };

  Scanner.prototype.scanIdentifier = function scanIdentifier() {
    assert(isIdentifierStart(this.peek));
    var start = this.index;

    this.advance();

    while (isIdentifierPart(this.peek)) {
      this.advance();
    }

    var text = this.input.substring(start, this.index);
    var result = new Token(start, text);

    if (OPERATORS[text] === 1) {
      result.withOp(text);
    } else {
      result.withGetterSetter(text);
    }

    return result;
  };

  Scanner.prototype.scanNumber = function scanNumber(start) {
    assert(isDigit(this.peek));
    var simple = this.index === start;
    this.advance();

    while (true) {
      if (!isDigit(this.peek)) {
        if (this.peek === $PERIOD) {
          simple = false;
        } else if (isExponentStart(this.peek)) {
          this.advance();

          if (isExponentSign(this.peek)) {
            this.advance();
          }

          if (!isDigit(this.peek)) {
            this.error('Invalid exponent', -1);
          }

          simple = false;
        } else {
          break;
        }
      }

      this.advance();
    }

    var text = this.input.substring(start, this.index);
    var value = simple ? parseInt(text, 10) : parseFloat(text);
    return new Token(start, text).withValue(value);
  };

  Scanner.prototype.scanString = function scanString() {
    assert(this.peek === $SQ || this.peek === $DQ);

    var start = this.index;
    var quote = this.peek;

    this.advance();

    var buffer = void 0;
    var marker = this.index;

    while (this.peek !== quote) {
      if (this.peek === $BACKSLASH) {
        if (!buffer) {
          buffer = [];
        }

        buffer.push(this.input.substring(marker, this.index));
        this.advance();

        var _unescaped = void 0;

        if (this.peek === $u) {
          var hex = this.input.substring(this.index + 1, this.index + 5);

          if (!/[A-Z0-9]{4}/.test(hex)) {
            this.error('Invalid unicode escape [\\u' + hex + ']');
          }

          _unescaped = parseInt(hex, 16);

          for (var _i21 = 0; _i21 < 5; ++_i21) {
            this.advance();
          }
        } else {
          _unescaped = unescape(this.peek);
          this.advance();
        }

        buffer.push(String.fromCharCode(_unescaped));
        marker = this.index;
      } else if (this.peek === $EOF) {
        this.error('Unterminated quote');
      } else {
        this.advance();
      }
    }

    var last = this.input.substring(marker, this.index);
    this.advance();
    var text = this.input.substring(start, this.index);

    var unescaped = last;

    if (buffer !== null && buffer !== undefined) {
      buffer.push(last);
      unescaped = buffer.join('');
    }

    return new Token(start, text).withValue(unescaped);
  };

  Scanner.prototype.advance = function advance() {
    if (++this.index >= this.length) {
      this.peek = $EOF;
    } else {
      this.peek = this.input.charCodeAt(this.index);
    }
  };

  Scanner.prototype.error = function error(message) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var position = this.index + offset;
    throw new Error('Lexer Error: ' + message + ' at column ' + position + ' in expression [' + this.input + ']');
  };

  return Scanner;
}();

var OPERATORS = {
  'undefined': 1,
  'null': 1,
  'true': 1,
  'false': 1,
  '+': 1,
  '-': 1,
  '*': 1,
  '/': 1,
  '%': 1,
  '^': 1,
  '=': 1,
  '==': 1,
  '===': 1,
  '!=': 1,
  '!==': 1,
  '<': 1,
  '>': 1,
  '<=': 1,
  '>=': 1,
  '&&': 1,
  '||': 1,
  '&': 1,
  '|': 1,
  '!': 1,
  '?': 1
};

var $EOF = 0;
var $TAB = 9;
var $LF = 10;
var $VTAB = 11;
var $FF = 12;
var $CR = 13;
var $SPACE = 32;
var $BANG = 33;
var $DQ = 34;
var $$ = 36;
var $PERCENT = 37;
var $AMPERSAND = 38;
var $SQ = 39;
var $LPAREN = 40;
var $RPAREN = 41;
var $STAR = 42;
var $PLUS = 43;
var $COMMA = 44;
var $MINUS = 45;
var $PERIOD = 46;
var $SLASH = 47;
var $COLON = 58;
var $SEMICOLON = 59;
var $LT = 60;
var $EQ = 61;
var $GT = 62;
var $QUESTION = 63;

var $0 = 48;
var $9 = 57;

var $A = 65;
var $E = 69;
var $Z = 90;

var $LBRACKET = 91;
var $BACKSLASH = 92;
var $RBRACKET = 93;
var $CARET = 94;
var $_ = 95;

var $a = 97;
var $e = 101;
var $f = 102;
var $n = 110;
var $r = 114;
var $t = 116;
var $u = 117;
var $v = 118;
var $z = 122;

var $LBRACE = 123;
var $BAR = 124;
var $RBRACE = 125;
var $NBSP = 160;

function isWhitespace(code) {
  return code >= $TAB && code <= $SPACE || code === $NBSP;
}

function isIdentifierStart(code) {
  return $a <= code && code <= $z || $A <= code && code <= $Z || code === $_ || code === $$;
}

function isIdentifierPart(code) {
  return $a <= code && code <= $z || $A <= code && code <= $Z || $0 <= code && code <= $9 || code === $_ || code === $$;
}

function isDigit(code) {
  return $0 <= code && code <= $9;
}

function isExponentStart(code) {
  return code === $e || code === $E;
}

function isExponentSign(code) {
  return code === $MINUS || code === $PLUS;
}

function unescape(code) {
  switch (code) {
    case $n:
      return $LF;
    case $f:
      return $FF;
    case $r:
      return $CR;
    case $t:
      return $TAB;
    case $v:
      return $VTAB;
    default:
      return code;
  }
}

function assert(condition, message) {
  if (!condition) {
    throw message || 'Assertion failed';
  }
}

var EOF = new Token(-1, null);

var Parser = exports.Parser = function () {
  function Parser() {
    

    this.cache = {};
    this.lexer = new Lexer();
  }

  Parser.prototype.parse = function parse(input) {
    input = input || '';

    return this.cache[input] || (this.cache[input] = new ParserImplementation(this.lexer, input).parseChain());
  };

  return Parser;
}();

var ParserImplementation = exports.ParserImplementation = function () {
  function ParserImplementation(lexer, input) {
    

    this.index = 0;
    this.input = input;
    this.tokens = lexer.lex(input);
  }

  ParserImplementation.prototype.parseChain = function parseChain() {
    var isChain = false;
    var expressions = [];

    while (this.optional(';')) {
      isChain = true;
    }

    while (this.index < this.tokens.length) {
      if (this.peek.text === ')' || this.peek.text === '}' || this.peek.text === ']') {
        this.error('Unconsumed token ' + this.peek.text);
      }

      var expr = this.parseBindingBehavior();
      expressions.push(expr);

      while (this.optional(';')) {
        isChain = true;
      }

      if (isChain) {
        this.error('Multiple expressions are not allowed.');
      }
    }

    return expressions.length === 1 ? expressions[0] : new Chain(expressions);
  };

  ParserImplementation.prototype.parseBindingBehavior = function parseBindingBehavior() {
    var result = this.parseValueConverter();

    while (this.optional('&')) {
      var name = this.peek.text;
      var args = [];

      this.advance();

      while (this.optional(':')) {
        args.push(this.parseExpression());
      }

      result = new BindingBehavior(result, name, args);
    }

    return result;
  };

  ParserImplementation.prototype.parseValueConverter = function parseValueConverter() {
    var result = this.parseExpression();

    while (this.optional('|')) {
      var name = this.peek.text;
      var args = [];

      this.advance();

      while (this.optional(':')) {
        args.push(this.parseExpression());
      }

      result = new ValueConverter(result, name, args, [result].concat(args));
    }

    return result;
  };

  ParserImplementation.prototype.parseExpression = function parseExpression() {
    var start = this.peek.index;
    var result = this.parseConditional();

    while (this.peek.text === '=') {
      if (!result.isAssignable) {
        var end = this.index < this.tokens.length ? this.peek.index : this.input.length;
        var expression = this.input.substring(start, end);

        this.error('Expression ' + expression + ' is not assignable');
      }

      this.expect('=');
      result = new Assign(result, this.parseConditional());
    }

    return result;
  };

  ParserImplementation.prototype.parseConditional = function parseConditional() {
    var start = this.peek.index;
    var result = this.parseLogicalOr();

    if (this.optional('?')) {
      var yes = this.parseExpression();

      if (!this.optional(':')) {
        var end = this.index < this.tokens.length ? this.peek.index : this.input.length;
        var expression = this.input.substring(start, end);

        this.error('Conditional expression ' + expression + ' requires all 3 expressions');
      }

      var no = this.parseExpression();
      result = new Conditional(result, yes, no);
    }

    return result;
  };

  ParserImplementation.prototype.parseLogicalOr = function parseLogicalOr() {
    var result = this.parseLogicalAnd();

    while (this.optional('||')) {
      result = new Binary('||', result, this.parseLogicalAnd());
    }

    return result;
  };

  ParserImplementation.prototype.parseLogicalAnd = function parseLogicalAnd() {
    var result = this.parseEquality();

    while (this.optional('&&')) {
      result = new Binary('&&', result, this.parseEquality());
    }

    return result;
  };

  ParserImplementation.prototype.parseEquality = function parseEquality() {
    var result = this.parseRelational();

    while (true) {
      if (this.optional('==')) {
        result = new Binary('==', result, this.parseRelational());
      } else if (this.optional('!=')) {
        result = new Binary('!=', result, this.parseRelational());
      } else if (this.optional('===')) {
        result = new Binary('===', result, this.parseRelational());
      } else if (this.optional('!==')) {
        result = new Binary('!==', result, this.parseRelational());
      } else {
        return result;
      }
    }
  };

  ParserImplementation.prototype.parseRelational = function parseRelational() {
    var result = this.parseAdditive();

    while (true) {
      if (this.optional('<')) {
        result = new Binary('<', result, this.parseAdditive());
      } else if (this.optional('>')) {
        result = new Binary('>', result, this.parseAdditive());
      } else if (this.optional('<=')) {
        result = new Binary('<=', result, this.parseAdditive());
      } else if (this.optional('>=')) {
        result = new Binary('>=', result, this.parseAdditive());
      } else {
        return result;
      }
    }
  };

  ParserImplementation.prototype.parseAdditive = function parseAdditive() {
    var result = this.parseMultiplicative();

    while (true) {
      if (this.optional('+')) {
        result = new Binary('+', result, this.parseMultiplicative());
      } else if (this.optional('-')) {
        result = new Binary('-', result, this.parseMultiplicative());
      } else {
        return result;
      }
    }
  };

  ParserImplementation.prototype.parseMultiplicative = function parseMultiplicative() {
    var result = this.parsePrefix();

    while (true) {
      if (this.optional('*')) {
        result = new Binary('*', result, this.parsePrefix());
      } else if (this.optional('%')) {
        result = new Binary('%', result, this.parsePrefix());
      } else if (this.optional('/')) {
        result = new Binary('/', result, this.parsePrefix());
      } else {
        return result;
      }
    }
  };

  ParserImplementation.prototype.parsePrefix = function parsePrefix() {
    if (this.optional('+')) {
      return this.parsePrefix();
    } else if (this.optional('-')) {
      return new Binary('-', new LiteralPrimitive(0), this.parsePrefix());
    } else if (this.optional('!')) {
      return new PrefixNot('!', this.parsePrefix());
    }

    return this.parseAccessOrCallMember();
  };

  ParserImplementation.prototype.parseAccessOrCallMember = function parseAccessOrCallMember() {
    var result = this.parsePrimary();

    while (true) {
      if (this.optional('.')) {
        var name = this.peek.text;

        this.advance();

        if (this.optional('(')) {
          var args = this.parseExpressionList(')');
          this.expect(')');
          if (result instanceof AccessThis) {
            result = new CallScope(name, args, result.ancestor);
          } else {
            result = new CallMember(result, name, args);
          }
        } else {
          if (result instanceof AccessThis) {
            result = new AccessScope(name, result.ancestor);
          } else {
            result = new AccessMember(result, name);
          }
        }
      } else if (this.optional('[')) {
        var key = this.parseExpression();
        this.expect(']');
        result = new AccessKeyed(result, key);
      } else if (this.optional('(')) {
        var _args = this.parseExpressionList(')');
        this.expect(')');
        result = new CallFunction(result, _args);
      } else {
        return result;
      }
    }
  };

  ParserImplementation.prototype.parsePrimary = function parsePrimary() {
    if (this.optional('(')) {
      var result = this.parseExpression();
      this.expect(')');
      return result;
    } else if (this.optional('null')) {
      return new LiteralPrimitive(null);
    } else if (this.optional('undefined')) {
      return new LiteralPrimitive(undefined);
    } else if (this.optional('true')) {
      return new LiteralPrimitive(true);
    } else if (this.optional('false')) {
      return new LiteralPrimitive(false);
    } else if (this.optional('[')) {
      var _elements = this.parseExpressionList(']');
      this.expect(']');
      return new LiteralArray(_elements);
    } else if (this.peek.text === '{') {
      return this.parseObject();
    } else if (this.peek.key !== null && this.peek.key !== undefined) {
      return this.parseAccessOrCallScope();
    } else if (this.peek.value !== null && this.peek.value !== undefined) {
      var value = this.peek.value;
      this.advance();
      return value instanceof String || typeof value === 'string' ? new LiteralString(value) : new LiteralPrimitive(value);
    } else if (this.index >= this.tokens.length) {
      throw new Error('Unexpected end of expression: ' + this.input);
    } else {
      this.error('Unexpected token ' + this.peek.text);
    }
  };

  ParserImplementation.prototype.parseAccessOrCallScope = function parseAccessOrCallScope() {
    var name = this.peek.key;

    this.advance();

    if (name === '$this') {
      return new AccessThis(0);
    }

    var ancestor = 0;
    while (name === '$parent') {
      ancestor++;
      if (this.optional('.')) {
        name = this.peek.key;
        this.advance();
      } else if (this.peek === EOF || this.peek.text === '(' || this.peek.text === ')' || this.peek.text === '[' || this.peek.text === '}' || this.peek.text === ',' || this.peek.text === '|' || this.peek.text === '&') {
        return new AccessThis(ancestor);
      } else {
        this.error('Unexpected token ' + this.peek.text);
      }
    }

    if (this.optional('(')) {
      var args = this.parseExpressionList(')');
      this.expect(')');
      return new CallScope(name, args, ancestor);
    }

    return new AccessScope(name, ancestor);
  };

  ParserImplementation.prototype.parseObject = function parseObject() {
    var keys = [];
    var values = [];

    this.expect('{');

    if (this.peek.text !== '}') {
      do {
        var peek = this.peek;
        var value = peek.value;
        keys.push(typeof value === 'string' ? value : peek.text);

        this.advance();
        if (peek.key && (this.peek.text === ',' || this.peek.text === '}')) {
          --this.index;
          values.push(this.parseAccessOrCallScope());
        } else {
          this.expect(':');
          values.push(this.parseExpression());
        }
      } while (this.optional(','));
    }

    this.expect('}');

    return new LiteralObject(keys, values);
  };

  ParserImplementation.prototype.parseExpressionList = function parseExpressionList(terminator) {
    var result = [];

    if (this.peek.text !== terminator) {
      do {
        result.push(this.parseExpression());
      } while (this.optional(','));
    }

    return result;
  };

  ParserImplementation.prototype.optional = function optional(text) {
    if (this.peek.text === text) {
      this.advance();
      return true;
    }

    return false;
  };

  ParserImplementation.prototype.expect = function expect(text) {
    if (this.peek.text === text) {
      this.advance();
    } else {
      this.error('Missing expected ' + text);
    }
  };

  ParserImplementation.prototype.advance = function advance() {
    this.index++;
  };

  ParserImplementation.prototype.error = function error(message) {
    var location = this.index < this.tokens.length ? 'at column ' + (this.tokens[this.index].index + 1) + ' in' : 'at the end of the expression';

    throw new Error('Parser Error: ' + message + ' ' + location + ' [' + this.input + ']');
  };

  _createClass(ParserImplementation, [{
    key: 'peek',
    get: function get() {
      return this.index < this.tokens.length ? this.tokens[this.index] : EOF;
    }
  }]);

  return ParserImplementation;
}();

var mapProto = Map.prototype;

function _getMapObserver(taskQueue, map) {
  return ModifyMapObserver.for(taskQueue, map);
}

exports.getMapObserver = _getMapObserver;

var ModifyMapObserver = function (_ModifyCollectionObse2) {
  _inherits(ModifyMapObserver, _ModifyCollectionObse2);

  function ModifyMapObserver(taskQueue, map) {
    

    return _possibleConstructorReturn(this, _ModifyCollectionObse2.call(this, taskQueue, map));
  }

  ModifyMapObserver.for = function _for(taskQueue, map) {
    if (!('__map_observer__' in map)) {
      Reflect.defineProperty(map, '__map_observer__', {
        value: ModifyMapObserver.create(taskQueue, map),
        enumerable: false, configurable: false
      });
    }
    return map.__map_observer__;
  };

  ModifyMapObserver.create = function create(taskQueue, map) {
    var observer = new ModifyMapObserver(taskQueue, map);

    var proto = mapProto;
    if (proto.set !== map.set || proto.delete !== map.delete || proto.clear !== map.clear) {
      proto = {
        set: map.set,
        delete: map.delete,
        clear: map.clear
      };
    }

    map.set = function () {
      var hasValue = map.has(arguments[0]);
      var type = hasValue ? 'update' : 'add';
      var oldValue = map.get(arguments[0]);
      var methodCallResult = proto.set.apply(map, arguments);
      if (!hasValue || oldValue !== map.get(arguments[0])) {
        observer.addChangeRecord({
          type: type,
          object: map,
          key: arguments[0],
          oldValue: oldValue
        });
      }
      return methodCallResult;
    };

    map.delete = function () {
      var hasValue = map.has(arguments[0]);
      var oldValue = map.get(arguments[0]);
      var methodCallResult = proto.delete.apply(map, arguments);
      if (hasValue) {
        observer.addChangeRecord({
          type: 'delete',
          object: map,
          key: arguments[0],
          oldValue: oldValue
        });
      }
      return methodCallResult;
    };

    map.clear = function () {
      var methodCallResult = proto.clear.apply(map, arguments);
      observer.addChangeRecord({
        type: 'clear',
        object: map
      });
      return methodCallResult;
    };

    return observer;
  };

  return ModifyMapObserver;
}(ModifyCollectionObserver);

function findOriginalEventTarget(event) {
  return event.path && event.path[0] || event.deepPath && event.deepPath[0] || event.target;
}

function stopPropagation() {
  this.standardStopPropagation();
  this.propagationStopped = true;
}

function handleCapturedEvent(event) {
  event.propagationStopped = false;
  var target = findOriginalEventTarget(event);

  var orderedCallbacks = [];

  while (target) {
    if (target.capturedCallbacks) {
      var callback = target.capturedCallbacks[event.type];
      if (callback) {
        if (event.stopPropagation !== stopPropagation) {
          event.standardStopPropagation = event.stopPropagation;
          event.stopPropagation = stopPropagation;
        }
        orderedCallbacks.push(callback);
      }
    }
    target = target.parentNode;
  }
  for (var _i22 = orderedCallbacks.length - 1; _i22 >= 0 && !event.propagationStopped; _i22--) {
    var orderedCallback = orderedCallbacks[_i22];
    if ('handleEvent' in orderedCallback) {
      orderedCallback.handleEvent(event);
    } else {
      orderedCallback(event);
    }
  }
}

var CapturedHandlerEntry = function () {
  function CapturedHandlerEntry(eventName) {
    

    this.eventName = eventName;
    this.count = 0;
  }

  CapturedHandlerEntry.prototype.increment = function increment() {
    this.count++;

    if (this.count === 1) {
      _aureliaPal.DOM.addEventListener(this.eventName, handleCapturedEvent, true);
    }
  };

  CapturedHandlerEntry.prototype.decrement = function decrement() {
    this.count--;

    if (this.count === 0) {
      _aureliaPal.DOM.removeEventListener(this.eventName, handleCapturedEvent, true);
    }
  };

  return CapturedHandlerEntry;
}();

function handleDelegatedEvent(event) {
  event.propagationStopped = false;
  var target = findOriginalEventTarget(event);

  while (target && !event.propagationStopped) {
    if (target.delegatedCallbacks) {
      var callback = target.delegatedCallbacks[event.type];
      if (callback) {
        if (event.stopPropagation !== stopPropagation) {
          event.standardStopPropagation = event.stopPropagation;
          event.stopPropagation = stopPropagation;
        }
        if ('handleEvent' in callback) {
          callback.handleEvent(event);
        } else {
          callback(event);
        }
      }
    }

    target = target.parentNode;
  }
}

var DelegateHandlerEntry = function () {
  function DelegateHandlerEntry(eventName) {
    

    this.eventName = eventName;
    this.count = 0;
  }

  DelegateHandlerEntry.prototype.increment = function increment() {
    this.count++;

    if (this.count === 1) {
      _aureliaPal.DOM.addEventListener(this.eventName, handleDelegatedEvent, false);
    }
  };

  DelegateHandlerEntry.prototype.decrement = function decrement() {
    this.count--;

    if (this.count === 0) {
      _aureliaPal.DOM.removeEventListener(this.eventName, handleDelegatedEvent, false);
    }
  };

  return DelegateHandlerEntry;
}();

var DelegationEntryHandler = function () {
  function DelegationEntryHandler(entry, lookup, targetEvent) {
    

    this.entry = entry;
    this.lookup = lookup;
    this.targetEvent = targetEvent;
  }

  DelegationEntryHandler.prototype.dispose = function dispose() {
    this.entry.decrement();
    this.lookup[this.targetEvent] = null;
    this.entry = this.lookup = this.targetEvent = null;
  };

  return DelegationEntryHandler;
}();

var EventHandler = function () {
  function EventHandler(target, targetEvent, callback) {
    

    this.target = target;
    this.targetEvent = targetEvent;
    this.callback = callback;
  }

  EventHandler.prototype.dispose = function dispose() {
    this.target.removeEventListener(this.targetEvent, this.callback);
    this.target = this.targetEvent = this.callback = null;
  };

  return EventHandler;
}();

var DefaultEventStrategy = function () {
  function DefaultEventStrategy() {
    

    this.delegatedHandlers = {};
    this.capturedHandlers = {};
  }

  DefaultEventStrategy.prototype.subscribe = function subscribe(target, targetEvent, callback, strategy, disposable) {
    var delegatedHandlers = void 0;
    var capturedHandlers = void 0;
    var handlerEntry = void 0;

    if (strategy === delegationStrategy.bubbling) {
      delegatedHandlers = this.delegatedHandlers;
      handlerEntry = delegatedHandlers[targetEvent] || (delegatedHandlers[targetEvent] = new DelegateHandlerEntry(targetEvent));
      var delegatedCallbacks = target.delegatedCallbacks || (target.delegatedCallbacks = {});

      handlerEntry.increment();
      delegatedCallbacks[targetEvent] = callback;

      if (disposable === true) {
        return new DelegationEntryHandler(handlerEntry, delegatedCallbacks, targetEvent);
      }

      return function () {
        handlerEntry.decrement();
        delegatedCallbacks[targetEvent] = null;
      };
    }
    if (strategy === delegationStrategy.capturing) {
      capturedHandlers = this.capturedHandlers;
      handlerEntry = capturedHandlers[targetEvent] || (capturedHandlers[targetEvent] = new CapturedHandlerEntry(targetEvent));
      var capturedCallbacks = target.capturedCallbacks || (target.capturedCallbacks = {});

      handlerEntry.increment();
      capturedCallbacks[targetEvent] = callback;

      if (disposable === true) {
        return new DelegationEntryHandler(handlerEntry, capturedCallbacks, targetEvent);
      }

      return function () {
        handlerEntry.decrement();
        capturedCallbacks[targetEvent] = null;
      };
    }

    target.addEventListener(targetEvent, callback);

    if (disposable === true) {
      return new EventHandler(target, targetEvent, callback);
    }

    return function () {
      target.removeEventListener(targetEvent, callback);
    };
  };

  return DefaultEventStrategy;
}();

var delegationStrategy = exports.delegationStrategy = {
  none: 0,
  capturing: 1,
  bubbling: 2
};

var EventManager = exports.EventManager = function () {
  function EventManager() {
    

    this.elementHandlerLookup = {};
    this.eventStrategyLookup = {};

    this.registerElementConfig({
      tagName: 'input',
      properties: {
        value: ['change', 'input'],
        checked: ['change', 'input'],
        files: ['change', 'input']
      }
    });

    this.registerElementConfig({
      tagName: 'textarea',
      properties: {
        value: ['change', 'input']
      }
    });

    this.registerElementConfig({
      tagName: 'select',
      properties: {
        value: ['change']
      }
    });

    this.registerElementConfig({
      tagName: 'content editable',
      properties: {
        value: ['change', 'input', 'blur', 'keyup', 'paste']
      }
    });

    this.registerElementConfig({
      tagName: 'scrollable element',
      properties: {
        scrollTop: ['scroll'],
        scrollLeft: ['scroll']
      }
    });

    this.defaultEventStrategy = new DefaultEventStrategy();
  }

  EventManager.prototype.registerElementConfig = function registerElementConfig(config) {
    var tagName = config.tagName.toLowerCase();
    var properties = config.properties;
    var propertyName = void 0;

    var lookup = this.elementHandlerLookup[tagName] = {};

    for (propertyName in properties) {
      if (properties.hasOwnProperty(propertyName)) {
        lookup[propertyName] = properties[propertyName];
      }
    }
  };

  EventManager.prototype.registerEventStrategy = function registerEventStrategy(eventName, strategy) {
    this.eventStrategyLookup[eventName] = strategy;
  };

  EventManager.prototype.getElementHandler = function getElementHandler(target, propertyName) {
    var tagName = void 0;
    var lookup = this.elementHandlerLookup;

    if (target.tagName) {
      tagName = target.tagName.toLowerCase();

      if (lookup[tagName] && lookup[tagName][propertyName]) {
        return new EventSubscriber(lookup[tagName][propertyName]);
      }

      if (propertyName === 'textContent' || propertyName === 'innerHTML') {
        return new EventSubscriber(lookup['content editable'].value);
      }

      if (propertyName === 'scrollTop' || propertyName === 'scrollLeft') {
        return new EventSubscriber(lookup['scrollable element'][propertyName]);
      }
    }

    return null;
  };

  EventManager.prototype.addEventListener = function addEventListener(target, targetEvent, callbackOrListener, delegate, disposable) {
    return (this.eventStrategyLookup[targetEvent] || this.defaultEventStrategy).subscribe(target, targetEvent, callbackOrListener, delegate, disposable);
  };

  return EventManager;
}();

var EventSubscriber = exports.EventSubscriber = function () {
  function EventSubscriber(events) {
    

    this.events = events;
    this.element = null;
    this.handler = null;
  }

  EventSubscriber.prototype.subscribe = function subscribe(element, callbackOrListener) {
    this.element = element;
    this.handler = callbackOrListener;

    var events = this.events;
    for (var _i23 = 0, ii = events.length; ii > _i23; ++_i23) {
      element.addEventListener(events[_i23], callbackOrListener);
    }
  };

  EventSubscriber.prototype.dispose = function dispose() {
    if (this.element === null) {
      return;
    }
    var element = this.element;
    var callbackOrListener = this.handler;
    var events = this.events;
    for (var _i24 = 0, ii = events.length; ii > _i24; ++_i24) {
      element.removeEventListener(events[_i24], callbackOrListener);
    }
    this.element = this.handler = null;
  };

  return EventSubscriber;
}();

var DirtyChecker = exports.DirtyChecker = function () {
  function DirtyChecker() {
    

    this.tracked = [];
    this.checkDelay = 120;
  }

  DirtyChecker.prototype.addProperty = function addProperty(property) {
    var tracked = this.tracked;

    tracked.push(property);

    if (tracked.length === 1) {
      this.scheduleDirtyCheck();
    }
  };

  DirtyChecker.prototype.removeProperty = function removeProperty(property) {
    var tracked = this.tracked;
    tracked.splice(tracked.indexOf(property), 1);
  };

  DirtyChecker.prototype.scheduleDirtyCheck = function scheduleDirtyCheck() {
    var _this22 = this;

    setTimeout(function () {
      return _this22.check();
    }, this.checkDelay);
  };

  DirtyChecker.prototype.check = function check() {
    var tracked = this.tracked;
    var i = tracked.length;

    while (i--) {
      var current = tracked[i];

      if (current.isDirty()) {
        current.call();
      }
    }

    if (tracked.length) {
      this.scheduleDirtyCheck();
    }
  };

  return DirtyChecker;
}();

var DirtyCheckProperty = exports.DirtyCheckProperty = (_dec5 = subscriberCollection(), _dec5(_class5 = function () {
  function DirtyCheckProperty(dirtyChecker, obj, propertyName) {
    

    this.dirtyChecker = dirtyChecker;
    this.obj = obj;
    this.propertyName = propertyName;
  }

  DirtyCheckProperty.prototype.getValue = function getValue() {
    return this.obj[this.propertyName];
  };

  DirtyCheckProperty.prototype.setValue = function setValue(newValue) {
    this.obj[this.propertyName] = newValue;
  };

  DirtyCheckProperty.prototype.call = function call() {
    var oldValue = this.oldValue;
    var newValue = this.getValue();

    this.callSubscribers(newValue, oldValue);

    this.oldValue = newValue;
  };

  DirtyCheckProperty.prototype.isDirty = function isDirty() {
    return this.oldValue !== this.obj[this.propertyName];
  };

  DirtyCheckProperty.prototype.subscribe = function subscribe(context, callable) {
    if (!this.hasSubscribers()) {
      this.oldValue = this.getValue();
      this.dirtyChecker.addProperty(this);
    }
    this.addSubscriber(context, callable);
  };

  DirtyCheckProperty.prototype.unsubscribe = function unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.dirtyChecker.removeProperty(this);
    }
  };

  return DirtyCheckProperty;
}()) || _class5);


var logger = LogManager.getLogger('property-observation');

var propertyAccessor = exports.propertyAccessor = {
  getValue: function getValue(obj, propertyName) {
    return obj[propertyName];
  },
  setValue: function setValue(value, obj, propertyName) {
    obj[propertyName] = value;
  }
};

var PrimitiveObserver = exports.PrimitiveObserver = function () {
  function PrimitiveObserver(primitive, propertyName) {
    

    this.doNotCache = true;

    this.primitive = primitive;
    this.propertyName = propertyName;
  }

  PrimitiveObserver.prototype.getValue = function getValue() {
    return this.primitive[this.propertyName];
  };

  PrimitiveObserver.prototype.setValue = function setValue() {
    var type = _typeof(this.primitive);
    throw new Error('The ' + this.propertyName + ' property of a ' + type + ' (' + this.primitive + ') cannot be assigned.');
  };

  PrimitiveObserver.prototype.subscribe = function subscribe() {};

  PrimitiveObserver.prototype.unsubscribe = function unsubscribe() {};

  return PrimitiveObserver;
}();

var SetterObserver = exports.SetterObserver = (_dec6 = subscriberCollection(), _dec6(_class7 = function () {
  function SetterObserver(taskQueue, obj, propertyName) {
    

    this.taskQueue = taskQueue;
    this.obj = obj;
    this.propertyName = propertyName;
    this.queued = false;
    this.observing = false;
  }

  SetterObserver.prototype.getValue = function getValue() {
    return this.obj[this.propertyName];
  };

  SetterObserver.prototype.setValue = function setValue(newValue) {
    this.obj[this.propertyName] = newValue;
  };

  SetterObserver.prototype.getterValue = function getterValue() {
    return this.currentValue;
  };

  SetterObserver.prototype.setterValue = function setterValue(newValue) {
    var oldValue = this.currentValue;

    if (oldValue !== newValue) {
      if (!this.queued) {
        this.oldValue = oldValue;
        this.queued = true;
        this.taskQueue.queueMicroTask(this);
      }

      this.currentValue = newValue;
    }
  };

  SetterObserver.prototype.call = function call() {
    var oldValue = this.oldValue;
    var newValue = this.currentValue;

    this.queued = false;

    this.callSubscribers(newValue, oldValue);
  };

  SetterObserver.prototype.subscribe = function subscribe(context, callable) {
    if (!this.observing) {
      this.convertProperty();
    }
    this.addSubscriber(context, callable);
  };

  SetterObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    this.removeSubscriber(context, callable);
  };

  SetterObserver.prototype.convertProperty = function convertProperty() {
    this.observing = true;
    this.currentValue = this.obj[this.propertyName];
    this.setValue = this.setterValue;
    this.getValue = this.getterValue;

    if (!Reflect.defineProperty(this.obj, this.propertyName, {
      configurable: true,
      enumerable: this.propertyName in this.obj ? this.obj.propertyIsEnumerable(this.propertyName) : true,
      get: this.getValue.bind(this),
      set: this.setValue.bind(this)
    })) {
      logger.warn('Cannot observe property \'' + this.propertyName + '\' of object', this.obj);
    }
  };

  return SetterObserver;
}()) || _class7);

var XLinkAttributeObserver = exports.XLinkAttributeObserver = function () {
  function XLinkAttributeObserver(element, propertyName, attributeName) {
    

    this.element = element;
    this.propertyName = propertyName;
    this.attributeName = attributeName;
  }

  XLinkAttributeObserver.prototype.getValue = function getValue() {
    return this.element.getAttributeNS('http://www.w3.org/1999/xlink', this.attributeName);
  };

  XLinkAttributeObserver.prototype.setValue = function setValue(newValue) {
    return this.element.setAttributeNS('http://www.w3.org/1999/xlink', this.attributeName, newValue);
  };

  XLinkAttributeObserver.prototype.subscribe = function subscribe() {
    throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
  };

  return XLinkAttributeObserver;
}();

var dataAttributeAccessor = exports.dataAttributeAccessor = {
  getValue: function getValue(obj, propertyName) {
    return obj.getAttribute(propertyName);
  },
  setValue: function setValue(value, obj, propertyName) {
    if (value === null || value === undefined) {
      obj.removeAttribute(propertyName);
    } else {
      obj.setAttribute(propertyName, value);
    }
  }
};

var DataAttributeObserver = exports.DataAttributeObserver = function () {
  function DataAttributeObserver(element, propertyName) {
    

    this.element = element;
    this.propertyName = propertyName;
  }

  DataAttributeObserver.prototype.getValue = function getValue() {
    return this.element.getAttribute(this.propertyName);
  };

  DataAttributeObserver.prototype.setValue = function setValue(newValue) {
    if (newValue === null || newValue === undefined) {
      return this.element.removeAttribute(this.propertyName);
    }
    return this.element.setAttribute(this.propertyName, newValue);
  };

  DataAttributeObserver.prototype.subscribe = function subscribe() {
    throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
  };

  return DataAttributeObserver;
}();

var StyleObserver = exports.StyleObserver = function () {
  function StyleObserver(element, propertyName) {
    

    this.element = element;
    this.propertyName = propertyName;

    this.styles = null;
    this.version = 0;
  }

  StyleObserver.prototype.getValue = function getValue() {
    return this.element.style.cssText;
  };

  StyleObserver.prototype._setProperty = function _setProperty(style, value) {
    var priority = '';

    if (value !== null && value !== undefined && typeof value.indexOf === 'function' && value.indexOf('!important') !== -1) {
      priority = 'important';
      value = value.replace('!important', '');
    }
    this.element.style.setProperty(style, value, priority);
  };

  StyleObserver.prototype.setValue = function setValue(newValue) {
    var styles = this.styles || {};
    var style = void 0;
    var version = this.version;

    if (newValue !== null && newValue !== undefined) {
      if (newValue instanceof Object) {
        var value = void 0;
        for (style in newValue) {
          if (newValue.hasOwnProperty(style)) {
            value = newValue[style];
            style = style.replace(/([A-Z])/g, function (m) {
              return '-' + m.toLowerCase();
            });
            styles[style] = version;
            this._setProperty(style, value);
          }
        }
      } else if (newValue.length) {
        var rx = /\s*([\w\-]+)\s*:\s*((?:(?:[\w\-]+\(\s*(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[\w\-]+\(\s*(?:^"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^\)]*)\),?|[^\)]*)\),?|"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^;]*),?\s*)+);?/g;
        var pair = void 0;
        while ((pair = rx.exec(newValue)) !== null) {
          style = pair[1];
          if (!style) {
            continue;
          }

          styles[style] = version;
          this._setProperty(style, pair[2]);
        }
      }
    }

    this.styles = styles;
    this.version += 1;

    if (version === 0) {
      return;
    }

    version -= 1;
    for (style in styles) {
      if (!styles.hasOwnProperty(style) || styles[style] !== version) {
        continue;
      }

      this.element.style.removeProperty(style);
    }
  };

  StyleObserver.prototype.subscribe = function subscribe() {
    throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
  };

  return StyleObserver;
}();

var ValueAttributeObserver = exports.ValueAttributeObserver = (_dec7 = subscriberCollection(), _dec7(_class8 = function () {
  function ValueAttributeObserver(element, propertyName, handler) {
    

    this.element = element;
    this.propertyName = propertyName;
    this.handler = handler;
    if (propertyName === 'files') {
      this.setValue = function () {};
    }
  }

  ValueAttributeObserver.prototype.getValue = function getValue() {
    return this.element[this.propertyName];
  };

  ValueAttributeObserver.prototype.setValue = function setValue(newValue) {
    newValue = newValue === undefined || newValue === null ? '' : newValue;
    if (this.element[this.propertyName] !== newValue) {
      this.element[this.propertyName] = newValue;
      this.notify();
    }
  };

  ValueAttributeObserver.prototype.notify = function notify() {
    var oldValue = this.oldValue;
    var newValue = this.getValue();

    this.callSubscribers(newValue, oldValue);

    this.oldValue = newValue;
  };

  ValueAttributeObserver.prototype.handleEvent = function handleEvent() {
    this.notify();
  };

  ValueAttributeObserver.prototype.subscribe = function subscribe(context, callable) {
    if (!this.hasSubscribers()) {
      this.oldValue = this.getValue();
      this.handler.subscribe(this.element, this);
    }

    this.addSubscriber(context, callable);
  };

  ValueAttributeObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.handler.dispose();
    }
  };

  return ValueAttributeObserver;
}()) || _class8);


var checkedArrayContext = 'CheckedObserver:array';
var checkedValueContext = 'CheckedObserver:value';

var CheckedObserver = exports.CheckedObserver = (_dec8 = subscriberCollection(), _dec8(_class9 = function () {
  function CheckedObserver(element, handler, observerLocator) {
    

    this.element = element;
    this.handler = handler;
    this.observerLocator = observerLocator;
  }

  CheckedObserver.prototype.getValue = function getValue() {
    return this.value;
  };

  CheckedObserver.prototype.setValue = function setValue(newValue) {
    if (this.initialSync && this.value === newValue) {
      return;
    }

    if (this.arrayObserver) {
      this.arrayObserver.unsubscribe(checkedArrayContext, this);
      this.arrayObserver = null;
    }

    if (this.element.type === 'checkbox' && Array.isArray(newValue)) {
      this.arrayObserver = this.observerLocator.getArrayObserver(newValue);
      this.arrayObserver.subscribe(checkedArrayContext, this);
    }

    this.oldValue = this.value;
    this.value = newValue;
    this.synchronizeElement();
    this.notify();

    if (!this.initialSync) {
      this.initialSync = true;
      this.observerLocator.taskQueue.queueMicroTask(this);
    }
  };

  CheckedObserver.prototype.call = function call(context, splices) {
    this.synchronizeElement();

    if (!this.valueObserver) {
      this.valueObserver = this.element.__observers__.model || this.element.__observers__.value;
      if (this.valueObserver) {
        this.valueObserver.subscribe(checkedValueContext, this);
      }
    }
  };

  CheckedObserver.prototype.synchronizeElement = function synchronizeElement() {
    var value = this.value;
    var element = this.element;
    var elementValue = element.hasOwnProperty('model') ? element.model : element.value;
    var isRadio = element.type === 'radio';
    var matcher = element.matcher || function (a, b) {
      return a === b;
    };

    element.checked = isRadio && !!matcher(value, elementValue) || !isRadio && value === true || !isRadio && Array.isArray(value) && value.findIndex(function (item) {
      return !!matcher(item, elementValue);
    }) !== -1;
  };

  CheckedObserver.prototype.synchronizeValue = function synchronizeValue() {
    var value = this.value;
    var element = this.element;
    var elementValue = element.hasOwnProperty('model') ? element.model : element.value;
    var index = void 0;
    var matcher = element.matcher || function (a, b) {
      return a === b;
    };

    if (element.type === 'checkbox') {
      if (Array.isArray(value)) {
        index = value.findIndex(function (item) {
          return !!matcher(item, elementValue);
        });
        if (element.checked && index === -1) {
          value.push(elementValue);
        } else if (!element.checked && index !== -1) {
          value.splice(index, 1);
        }

        return;
      }

      value = element.checked;
    } else if (element.checked) {
      value = elementValue;
    } else {
      return;
    }

    this.oldValue = this.value;
    this.value = value;
    this.notify();
  };

  CheckedObserver.prototype.notify = function notify() {
    var oldValue = this.oldValue;
    var newValue = this.value;

    if (newValue === oldValue) {
      return;
    }

    this.callSubscribers(newValue, oldValue);
  };

  CheckedObserver.prototype.handleEvent = function handleEvent() {
    this.synchronizeValue();
  };

  CheckedObserver.prototype.subscribe = function subscribe(context, callable) {
    if (!this.hasSubscribers()) {
      this.handler.subscribe(this.element, this);
    }
    this.addSubscriber(context, callable);
  };

  CheckedObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.handler.dispose();
    }
  };

  CheckedObserver.prototype.unbind = function unbind() {
    if (this.arrayObserver) {
      this.arrayObserver.unsubscribe(checkedArrayContext, this);
      this.arrayObserver = null;
    }
    if (this.valueObserver) {
      this.valueObserver.unsubscribe(checkedValueContext, this);
    }
  };

  return CheckedObserver;
}()) || _class9);


var selectArrayContext = 'SelectValueObserver:array';

var SelectValueObserver = exports.SelectValueObserver = (_dec9 = subscriberCollection(), _dec9(_class10 = function () {
  function SelectValueObserver(element, handler, observerLocator) {
    

    this.element = element;
    this.handler = handler;
    this.observerLocator = observerLocator;
  }

  SelectValueObserver.prototype.getValue = function getValue() {
    return this.value;
  };

  SelectValueObserver.prototype.setValue = function setValue(newValue) {
    if (newValue !== null && newValue !== undefined && this.element.multiple && !Array.isArray(newValue)) {
      throw new Error('Only null or Array instances can be bound to a multi-select.');
    }
    if (this.value === newValue) {
      return;
    }

    if (this.arrayObserver) {
      this.arrayObserver.unsubscribe(selectArrayContext, this);
      this.arrayObserver = null;
    }

    if (Array.isArray(newValue)) {
      this.arrayObserver = this.observerLocator.getArrayObserver(newValue);
      this.arrayObserver.subscribe(selectArrayContext, this);
    }

    this.oldValue = this.value;
    this.value = newValue;
    this.synchronizeOptions();
    this.notify();

    if (!this.initialSync) {
      this.initialSync = true;
      this.observerLocator.taskQueue.queueMicroTask(this);
    }
  };

  SelectValueObserver.prototype.call = function call(context, splices) {
    this.synchronizeOptions();
  };

  SelectValueObserver.prototype.synchronizeOptions = function synchronizeOptions() {
    var value = this.value;
    var isArray = void 0;

    if (Array.isArray(value)) {
      isArray = true;
    }

    var options = this.element.options;
    var i = options.length;
    var matcher = this.element.matcher || function (a, b) {
      return a === b;
    };

    var _loop = function _loop() {
      var option = options.item(i);
      var optionValue = option.hasOwnProperty('model') ? option.model : option.value;
      if (isArray) {
        option.selected = value.findIndex(function (item) {
          return !!matcher(optionValue, item);
        }) !== -1;
        return 'continue';
      }
      option.selected = !!matcher(optionValue, value);
    };

    while (i--) {
      var _ret = _loop();

      if (_ret === 'continue') continue;
    }
  };

  SelectValueObserver.prototype.synchronizeValue = function synchronizeValue() {
    var _this23 = this;

    var options = this.element.options;
    var count = 0;
    var value = [];

    for (var _i25 = 0, ii = options.length; _i25 < ii; _i25++) {
      var _option = options.item(_i25);
      if (!_option.selected) {
        continue;
      }
      value.push(_option.hasOwnProperty('model') ? _option.model : _option.value);
      count++;
    }

    if (this.element.multiple) {
      if (Array.isArray(this.value)) {
        var _ret2 = function () {
          var matcher = _this23.element.matcher || function (a, b) {
            return a === b;
          };

          var i = 0;

          var _loop2 = function _loop2() {
            var a = _this23.value[i];
            if (value.findIndex(function (b) {
              return matcher(a, b);
            }) === -1) {
              _this23.value.splice(i, 1);
            } else {
              i++;
            }
          };

          while (i < _this23.value.length) {
            _loop2();
          }

          i = 0;

          var _loop3 = function _loop3() {
            var a = value[i];
            if (_this23.value.findIndex(function (b) {
              return matcher(a, b);
            }) === -1) {
              _this23.value.push(a);
            }
            i++;
          };

          while (i < value.length) {
            _loop3();
          }
          return {
            v: void 0
          };
        }();

        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
      }
    } else {
      if (count === 0) {
        value = null;
      } else {
        value = value[0];
      }
    }

    if (value !== this.value) {
      this.oldValue = this.value;
      this.value = value;
      this.notify();
    }
  };

  SelectValueObserver.prototype.notify = function notify() {
    var oldValue = this.oldValue;
    var newValue = this.value;

    this.callSubscribers(newValue, oldValue);
  };

  SelectValueObserver.prototype.handleEvent = function handleEvent() {
    this.synchronizeValue();
  };

  SelectValueObserver.prototype.subscribe = function subscribe(context, callable) {
    if (!this.hasSubscribers()) {
      this.handler.subscribe(this.element, this);
    }
    this.addSubscriber(context, callable);
  };

  SelectValueObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.handler.dispose();
    }
  };

  SelectValueObserver.prototype.bind = function bind() {
    var _this24 = this;

    this.domObserver = _aureliaPal.DOM.createMutationObserver(function () {
      _this24.synchronizeOptions();
      _this24.synchronizeValue();
    });
    this.domObserver.observe(this.element, { childList: true, subtree: true });
  };

  SelectValueObserver.prototype.unbind = function unbind() {
    this.domObserver.disconnect();
    this.domObserver = null;

    if (this.arrayObserver) {
      this.arrayObserver.unsubscribe(selectArrayContext, this);
      this.arrayObserver = null;
    }
  };

  return SelectValueObserver;
}()) || _class10);

var ClassObserver = exports.ClassObserver = function () {
  function ClassObserver(element) {
    

    this.element = element;
    this.doNotCache = true;
    this.value = '';
    this.version = 0;
  }

  ClassObserver.prototype.getValue = function getValue() {
    return this.value;
  };

  ClassObserver.prototype.setValue = function setValue(newValue) {
    var nameIndex = this.nameIndex || {};
    var version = this.version;
    var names = void 0;
    var name = void 0;

    if (newValue !== null && newValue !== undefined && newValue.length) {
      names = newValue.split(/\s+/);
      for (var _i26 = 0, length = names.length; _i26 < length; _i26++) {
        name = names[_i26];
        if (name === '') {
          continue;
        }
        nameIndex[name] = version;
        this.element.classList.add(name);
      }
    }

    this.value = newValue;
    this.nameIndex = nameIndex;
    this.version += 1;

    if (version === 0) {
      return;
    }

    version -= 1;
    for (name in nameIndex) {
      if (!nameIndex.hasOwnProperty(name) || nameIndex[name] !== version) {
        continue;
      }
      this.element.classList.remove(name);
    }
  };

  ClassObserver.prototype.subscribe = function subscribe() {
    throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "class" property is not supported.');
  };

  return ClassObserver;
}();

function hasDeclaredDependencies(descriptor) {
  return !!(descriptor && descriptor.get && descriptor.get.dependencies);
}

function declarePropertyDependencies(ctor, propertyName, dependencies) {
  var descriptor = Object.getOwnPropertyDescriptor(ctor.prototype, propertyName);
  descriptor.get.dependencies = dependencies;
}

function computedFrom() {
  for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
    rest[_key] = arguments[_key];
  }

  return function (target, key, descriptor) {
    descriptor.get.dependencies = rest;
    return descriptor;
  };
}

var ComputedExpression = exports.ComputedExpression = function (_Expression19) {
  _inherits(ComputedExpression, _Expression19);

  function ComputedExpression(name, dependencies) {
    

    var _this25 = _possibleConstructorReturn(this, _Expression19.call(this));

    _this25.name = name;
    _this25.dependencies = dependencies;
    _this25.isAssignable = true;
    return _this25;
  }

  ComputedExpression.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    return scope.bindingContext[this.name];
  };

  ComputedExpression.prototype.assign = function assign(scope, value) {
    scope.bindingContext[this.name] = value;
  };

  ComputedExpression.prototype.accept = function accept(visitor) {
    throw new Error('not implemented');
  };

  ComputedExpression.prototype.connect = function connect(binding, scope) {
    var dependencies = this.dependencies;
    var i = dependencies.length;
    while (i--) {
      dependencies[i].connect(binding, scope);
    }
  };

  return ComputedExpression;
}(Expression);

function createComputedObserver(obj, propertyName, descriptor, observerLocator) {
  var dependencies = descriptor.get.dependencies;
  if (!(dependencies instanceof ComputedExpression)) {
    var _i27 = dependencies.length;
    while (_i27--) {
      dependencies[_i27] = observerLocator.parser.parse(dependencies[_i27]);
    }
    dependencies = descriptor.get.dependencies = new ComputedExpression(propertyName, dependencies);
  }

  var scope = { bindingContext: obj, overrideContext: createOverrideContext(obj) };
  return new ExpressionObserver(scope, dependencies, observerLocator);
}

var svgElements = void 0;
var svgPresentationElements = void 0;
var svgPresentationAttributes = void 0;
var svgAnalyzer = void 0;

if (typeof FEATURE_NO_SVG === 'undefined') {
  svgElements = {
    a: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'target', 'transform', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    altGlyph: ['class', 'dx', 'dy', 'externalResourcesRequired', 'format', 'glyphRef', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    altGlyphDef: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    altGlyphItem: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    animate: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    animateColor: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    animateMotion: ['accumulate', 'additive', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keyPoints', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'origin', 'path', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'rotate', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    animateTransform: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'type', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    circle: ['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'r', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    clipPath: ['class', 'clipPathUnits', 'externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    'color-profile': ['id', 'local', 'name', 'rendering-intent', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    cursor: ['externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    defs: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    desc: ['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space'],
    ellipse: ['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    feBlend: ['class', 'height', 'id', 'in', 'in2', 'mode', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feColorMatrix: ['class', 'height', 'id', 'in', 'result', 'style', 'type', 'values', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feComponentTransfer: ['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feComposite: ['class', 'height', 'id', 'in', 'in2', 'k1', 'k2', 'k3', 'k4', 'operator', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feConvolveMatrix: ['bias', 'class', 'divisor', 'edgeMode', 'height', 'id', 'in', 'kernelMatrix', 'kernelUnitLength', 'order', 'preserveAlpha', 'result', 'style', 'targetX', 'targetY', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feDiffuseLighting: ['class', 'diffuseConstant', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feDisplacementMap: ['class', 'height', 'id', 'in', 'in2', 'result', 'scale', 'style', 'width', 'x', 'xChannelSelector', 'xml:base', 'xml:lang', 'xml:space', 'y', 'yChannelSelector'],
    feDistantLight: ['azimuth', 'elevation', 'id', 'xml:base', 'xml:lang', 'xml:space'],
    feFlood: ['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feFuncA: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feFuncB: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feFuncG: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feFuncR: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feGaussianBlur: ['class', 'height', 'id', 'in', 'result', 'stdDeviation', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feImage: ['class', 'externalResourcesRequired', 'height', 'id', 'preserveAspectRatio', 'result', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feMerge: ['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feMergeNode: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    feMorphology: ['class', 'height', 'id', 'in', 'operator', 'radius', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feOffset: ['class', 'dx', 'dy', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    fePointLight: ['id', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z'],
    feSpecularLighting: ['class', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'specularConstant', 'specularExponent', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feSpotLight: ['id', 'limitingConeAngle', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'specularExponent', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z'],
    feTile: ['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feTurbulence: ['baseFrequency', 'class', 'height', 'id', 'numOctaves', 'result', 'seed', 'stitchTiles', 'style', 'type', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    filter: ['class', 'externalResourcesRequired', 'filterRes', 'filterUnits', 'height', 'id', 'primitiveUnits', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    font: ['class', 'externalResourcesRequired', 'horiz-adv-x', 'horiz-origin-x', 'horiz-origin-y', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face': ['accent-height', 'alphabetic', 'ascent', 'bbox', 'cap-height', 'descent', 'font-family', 'font-size', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'hanging', 'id', 'ideographic', 'mathematical', 'overline-position', 'overline-thickness', 'panose-1', 'slope', 'stemh', 'stemv', 'strikethrough-position', 'strikethrough-thickness', 'underline-position', 'underline-thickness', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'widths', 'x-height', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-format': ['id', 'string', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-name': ['id', 'name', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-src': ['id', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-uri': ['id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    foreignObject: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    g: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    glyph: ['arabic-form', 'class', 'd', 'glyph-name', 'horiz-adv-x', 'id', 'lang', 'orientation', 'style', 'unicode', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
    glyphRef: ['class', 'dx', 'dy', 'format', 'glyphRef', 'id', 'style', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    hkern: ['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space'],
    image: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    line: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'x1', 'x2', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2'],
    linearGradient: ['class', 'externalResourcesRequired', 'gradientTransform', 'gradientUnits', 'id', 'spreadMethod', 'style', 'x1', 'x2', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2'],
    marker: ['class', 'externalResourcesRequired', 'id', 'markerHeight', 'markerUnits', 'markerWidth', 'orient', 'preserveAspectRatio', 'refX', 'refY', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space'],
    mask: ['class', 'externalResourcesRequired', 'height', 'id', 'maskContentUnits', 'maskUnits', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    metadata: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    'missing-glyph': ['class', 'd', 'horiz-adv-x', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
    mpath: ['externalResourcesRequired', 'id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    path: ['class', 'd', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'pathLength', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    pattern: ['class', 'externalResourcesRequired', 'height', 'id', 'patternContentUnits', 'patternTransform', 'patternUnits', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'viewBox', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    polygon: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    polyline: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    radialGradient: ['class', 'cx', 'cy', 'externalResourcesRequired', 'fx', 'fy', 'gradientTransform', 'gradientUnits', 'id', 'r', 'spreadMethod', 'style', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    rect: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    script: ['externalResourcesRequired', 'id', 'type', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    set: ['attributeName', 'attributeType', 'begin', 'dur', 'end', 'externalResourcesRequired', 'fill', 'id', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    stop: ['class', 'id', 'offset', 'style', 'xml:base', 'xml:lang', 'xml:space'],
    style: ['id', 'media', 'title', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    svg: ['baseProfile', 'class', 'contentScriptType', 'contentStyleType', 'externalResourcesRequired', 'height', 'id', 'onabort', 'onactivate', 'onclick', 'onerror', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onresize', 'onscroll', 'onunload', 'onzoom', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'version', 'viewBox', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'zoomAndPan'],
    switch: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    symbol: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space'],
    text: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'transform', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    textPath: ['class', 'externalResourcesRequired', 'id', 'lengthAdjust', 'method', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'spacing', 'startOffset', 'style', 'systemLanguage', 'textLength', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    title: ['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space'],
    tref: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    tspan: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    use: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    view: ['externalResourcesRequired', 'id', 'preserveAspectRatio', 'viewBox', 'viewTarget', 'xml:base', 'xml:lang', 'xml:space', 'zoomAndPan'],
    vkern: ['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space']
  };


  svgPresentationElements = {
    'a': true,
    'altGlyph': true,
    'animate': true,
    'animateColor': true,
    'circle': true,
    'clipPath': true,
    'defs': true,
    'ellipse': true,
    'feBlend': true,
    'feColorMatrix': true,
    'feComponentTransfer': true,
    'feComposite': true,
    'feConvolveMatrix': true,
    'feDiffuseLighting': true,
    'feDisplacementMap': true,
    'feFlood': true,
    'feGaussianBlur': true,
    'feImage': true,
    'feMerge': true,
    'feMorphology': true,
    'feOffset': true,
    'feSpecularLighting': true,
    'feTile': true,
    'feTurbulence': true,
    'filter': true,
    'font': true,
    'foreignObject': true,
    'g': true,
    'glyph': true,
    'glyphRef': true,
    'image': true,
    'line': true,
    'linearGradient': true,
    'marker': true,
    'mask': true,
    'missing-glyph': true,
    'path': true,
    'pattern': true,
    'polygon': true,
    'polyline': true,
    'radialGradient': true,
    'rect': true,
    'stop': true,
    'svg': true,
    'switch': true,
    'symbol': true,
    'text': true,
    'textPath': true,
    'tref': true,
    'tspan': true,
    'use': true
  };

  svgPresentationAttributes = {
    'alignment-baseline': true,
    'baseline-shift': true,
    'clip-path': true,
    'clip-rule': true,
    'clip': true,
    'color-interpolation-filters': true,
    'color-interpolation': true,
    'color-profile': true,
    'color-rendering': true,
    'color': true,
    'cursor': true,
    'direction': true,
    'display': true,
    'dominant-baseline': true,
    'enable-background': true,
    'fill-opacity': true,
    'fill-rule': true,
    'fill': true,
    'filter': true,
    'flood-color': true,
    'flood-opacity': true,
    'font-family': true,
    'font-size-adjust': true,
    'font-size': true,
    'font-stretch': true,
    'font-style': true,
    'font-variant': true,
    'font-weight': true,
    'glyph-orientation-horizontal': true,
    'glyph-orientation-vertical': true,
    'image-rendering': true,
    'kerning': true,
    'letter-spacing': true,
    'lighting-color': true,
    'marker-end': true,
    'marker-mid': true,
    'marker-start': true,
    'mask': true,
    'opacity': true,
    'overflow': true,
    'pointer-events': true,
    'shape-rendering': true,
    'stop-color': true,
    'stop-opacity': true,
    'stroke-dasharray': true,
    'stroke-dashoffset': true,
    'stroke-linecap': true,
    'stroke-linejoin': true,
    'stroke-miterlimit': true,
    'stroke-opacity': true,
    'stroke-width': true,
    'stroke': true,
    'text-anchor': true,
    'text-decoration': true,
    'text-rendering': true,
    'unicode-bidi': true,
    'visibility': true,
    'word-spacing': true,
    'writing-mode': true
  };

  var createElement = function createElement(html) {
    var div = _aureliaPal.DOM.createElement('div');
    div.innerHTML = html;
    return div.firstChild;
  };

  svgAnalyzer = function () {
    function SVGAnalyzer() {
      

      if (createElement('<svg><altGlyph /></svg>').firstElementChild.nodeName === 'altglyph' && elements.altGlyph) {
        elements.altglyph = elements.altGlyph;
        delete elements.altGlyph;
        elements.altglyphdef = elements.altGlyphDef;
        delete elements.altGlyphDef;
        elements.altglyphitem = elements.altGlyphItem;
        delete elements.altGlyphItem;
        elements.glyphref = elements.glyphRef;
        delete elements.glyphRef;
      }
    }

    SVGAnalyzer.prototype.isStandardSvgAttribute = function isStandardSvgAttribute(nodeName, attributeName) {
      return presentationElements[nodeName] && presentationAttributes[attributeName] || elements[nodeName] && elements[nodeName].indexOf(attributeName) !== -1;
    };

    return SVGAnalyzer;
  }();
}

var elements = exports.elements = svgElements;
var presentationElements = exports.presentationElements = svgPresentationElements;
var presentationAttributes = exports.presentationAttributes = svgPresentationAttributes;
var SVGAnalyzer = exports.SVGAnalyzer = svgAnalyzer || function () {
  function _class11() {
    
  }

  _class11.prototype.isStandardSvgAttribute = function isStandardSvgAttribute() {
    return false;
  };

  return _class11;
}();

var ObserverLocator = exports.ObserverLocator = (_temp = _class12 = function () {
  function ObserverLocator(taskQueue, eventManager, dirtyChecker, svgAnalyzer, parser) {
    

    this.taskQueue = taskQueue;
    this.eventManager = eventManager;
    this.dirtyChecker = dirtyChecker;
    this.svgAnalyzer = svgAnalyzer;
    this.parser = parser;

    this.adapters = [];
    this.logger = LogManager.getLogger('observer-locator');
  }

  ObserverLocator.prototype.getObserver = function getObserver(obj, propertyName) {
    var observersLookup = obj.__observers__;
    var observer = void 0;

    if (observersLookup && propertyName in observersLookup) {
      return observersLookup[propertyName];
    }

    observer = this.createPropertyObserver(obj, propertyName);

    if (!observer.doNotCache) {
      if (observersLookup === undefined) {
        observersLookup = this.getOrCreateObserversLookup(obj);
      }

      observersLookup[propertyName] = observer;
    }

    return observer;
  };

  ObserverLocator.prototype.getOrCreateObserversLookup = function getOrCreateObserversLookup(obj) {
    return obj.__observers__ || this.createObserversLookup(obj);
  };

  ObserverLocator.prototype.createObserversLookup = function createObserversLookup(obj) {
    var value = {};

    if (!Reflect.defineProperty(obj, '__observers__', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: value
    })) {
      this.logger.warn('Cannot add observers to object', obj);
    }

    return value;
  };

  ObserverLocator.prototype.addAdapter = function addAdapter(adapter) {
    this.adapters.push(adapter);
  };

  ObserverLocator.prototype.getAdapterObserver = function getAdapterObserver(obj, propertyName, descriptor) {
    for (var _i28 = 0, ii = this.adapters.length; _i28 < ii; _i28++) {
      var adapter = this.adapters[_i28];
      var observer = adapter.getObserver(obj, propertyName, descriptor);
      if (observer) {
        return observer;
      }
    }
    return null;
  };

  ObserverLocator.prototype.createPropertyObserver = function createPropertyObserver(obj, propertyName) {
    var descriptor = void 0;
    var handler = void 0;
    var xlinkResult = void 0;

    if (!(obj instanceof Object)) {
      return new PrimitiveObserver(obj, propertyName);
    }

    if (obj instanceof _aureliaPal.DOM.Element) {
      if (propertyName === 'class') {
        return new ClassObserver(obj);
      }
      if (propertyName === 'style' || propertyName === 'css') {
        return new StyleObserver(obj, propertyName);
      }
      handler = this.eventManager.getElementHandler(obj, propertyName);
      if (propertyName === 'value' && obj.tagName.toLowerCase() === 'select') {
        return new SelectValueObserver(obj, handler, this);
      }
      if (propertyName === 'checked' && obj.tagName.toLowerCase() === 'input') {
        return new CheckedObserver(obj, handler, this);
      }
      if (handler) {
        return new ValueAttributeObserver(obj, propertyName, handler);
      }
      xlinkResult = /^xlink:(.+)$/.exec(propertyName);
      if (xlinkResult) {
        return new XLinkAttributeObserver(obj, propertyName, xlinkResult[1]);
      }
      if (propertyName === 'role' && (obj instanceof _aureliaPal.DOM.Element || obj instanceof _aureliaPal.DOM.SVGElement) || /^\w+:|^data-|^aria-/.test(propertyName) || obj instanceof _aureliaPal.DOM.SVGElement && this.svgAnalyzer.isStandardSvgAttribute(obj.nodeName, propertyName)) {
        return new DataAttributeObserver(obj, propertyName);
      }
    }

    descriptor = Object.getPropertyDescriptor(obj, propertyName);

    if (hasDeclaredDependencies(descriptor)) {
      return createComputedObserver(obj, propertyName, descriptor, this);
    }

    if (descriptor) {
      var existingGetterOrSetter = descriptor.get || descriptor.set;
      if (existingGetterOrSetter) {
        if (existingGetterOrSetter.getObserver) {
          return existingGetterOrSetter.getObserver(obj);
        }

        var adapterObserver = this.getAdapterObserver(obj, propertyName, descriptor);
        if (adapterObserver) {
          return adapterObserver;
        }
        return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
      }
    }

    if (obj instanceof Array) {
      if (propertyName === 'length') {
        return this.getArrayObserver(obj).getLengthObserver();
      }

      return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
    } else if (obj instanceof Map) {
      if (propertyName === 'size') {
        return this.getMapObserver(obj).getLengthObserver();
      }

      return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
    } else if (obj instanceof Set) {
      if (propertyName === 'size') {
        return this.getSetObserver(obj).getLengthObserver();
      }

      return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
    }

    return new SetterObserver(this.taskQueue, obj, propertyName);
  };

  ObserverLocator.prototype.getAccessor = function getAccessor(obj, propertyName) {
    if (obj instanceof _aureliaPal.DOM.Element) {
      if (propertyName === 'class' || propertyName === 'style' || propertyName === 'css' || propertyName === 'value' && (obj.tagName.toLowerCase() === 'input' || obj.tagName.toLowerCase() === 'select') || propertyName === 'checked' && obj.tagName.toLowerCase() === 'input' || propertyName === 'model' && obj.tagName.toLowerCase() === 'input' || /^xlink:.+$/.exec(propertyName)) {
        return this.getObserver(obj, propertyName);
      }
      if (/^\w+:|^data-|^aria-/.test(propertyName) || obj instanceof _aureliaPal.DOM.SVGElement && this.svgAnalyzer.isStandardSvgAttribute(obj.nodeName, propertyName) || obj.tagName.toLowerCase() === 'img' && propertyName === 'src' || obj.tagName.toLowerCase() === 'a' && propertyName === 'href') {
        return dataAttributeAccessor;
      }
    }
    return propertyAccessor;
  };

  ObserverLocator.prototype.getArrayObserver = function getArrayObserver(array) {
    return _getArrayObserver(this.taskQueue, array);
  };

  ObserverLocator.prototype.getMapObserver = function getMapObserver(map) {
    return _getMapObserver(this.taskQueue, map);
  };

  ObserverLocator.prototype.getSetObserver = function getSetObserver(set) {
    return _getSetObserver(this.taskQueue, set);
  };

  return ObserverLocator;
}(), _class12.inject = [_aureliaTaskQueue.TaskQueue, EventManager, DirtyChecker, SVGAnalyzer, Parser], _temp);

var ObjectObservationAdapter = exports.ObjectObservationAdapter = function () {
  function ObjectObservationAdapter() {
    
  }

  ObjectObservationAdapter.prototype.getObserver = function getObserver(object, propertyName, descriptor) {
    throw new Error('BindingAdapters must implement getObserver(object, propertyName).');
  };

  return ObjectObservationAdapter;
}();

var BindingExpression = exports.BindingExpression = function () {
  function BindingExpression(observerLocator, targetProperty, sourceExpression, mode, lookupFunctions, attribute) {
    

    this.observerLocator = observerLocator;
    this.targetProperty = targetProperty;
    this.sourceExpression = sourceExpression;
    this.mode = mode;
    this.lookupFunctions = lookupFunctions;
    this.attribute = attribute;
    this.discrete = false;
  }

  BindingExpression.prototype.createBinding = function createBinding(target) {
    return new Binding(this.observerLocator, this.sourceExpression, target, this.targetProperty, this.mode, this.lookupFunctions);
  };

  return BindingExpression;
}();

var Binding = exports.Binding = (_dec10 = connectable(), _dec10(_class13 = function () {
  function Binding(observerLocator, sourceExpression, target, targetProperty, mode, lookupFunctions) {
    

    this.observerLocator = observerLocator;
    this.sourceExpression = sourceExpression;
    this.target = target;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.lookupFunctions = lookupFunctions;
  }

  Binding.prototype.updateTarget = function updateTarget(value) {
    this.targetObserver.setValue(value, this.target, this.targetProperty);
  };

  Binding.prototype.updateSource = function updateSource(value) {
    this.sourceExpression.assign(this.source, value, this.lookupFunctions);
  };

  Binding.prototype.call = function call(context, newValue, oldValue) {
    if (!this.isBound) {
      return;
    }
    if (context === sourceContext) {
      oldValue = this.targetObserver.getValue(this.target, this.targetProperty);
      newValue = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
      if (newValue !== oldValue) {
        this.updateTarget(newValue);
      }
      if (this.mode !== bindingMode.oneTime) {
        this._version++;
        this.sourceExpression.connect(this, this.source);
        this.unobserve(false);
      }
      return;
    }
    if (context === targetContext) {
      if (newValue !== this.sourceExpression.evaluate(this.source, this.lookupFunctions)) {
        this.updateSource(newValue);
      }
      return;
    }
    throw new Error('Unexpected call context ' + context);
  };

  Binding.prototype.bind = function bind(source) {
    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this.source = source;

    if (this.sourceExpression.bind) {
      this.sourceExpression.bind(this, source, this.lookupFunctions);
    }

    var mode = this.mode;
    if (!this.targetObserver) {
      var method = mode === bindingMode.twoWay || mode === bindingMode.fromView ? 'getObserver' : 'getAccessor';
      this.targetObserver = this.observerLocator[method](this.target, this.targetProperty);
    }

    if ('bind' in this.targetObserver) {
      this.targetObserver.bind();
    }
    if (this.mode !== bindingMode.fromView) {
      var value = this.sourceExpression.evaluate(source, this.lookupFunctions);
      this.updateTarget(value);
    }

    if (mode === bindingMode.oneTime) {
      return;
    } else if (mode === bindingMode.toView) {
      enqueueBindingConnect(this);
    } else if (mode === bindingMode.twoWay) {
      this.sourceExpression.connect(this, source);
      this.targetObserver.subscribe(targetContext, this);
    } else if (mode === bindingMode.fromView) {
      this.targetObserver.subscribe(targetContext, this);
    }
  };

  Binding.prototype.unbind = function unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    if (this.sourceExpression.unbind) {
      this.sourceExpression.unbind(this, this.source);
    }
    this.source = null;
    if ('unbind' in this.targetObserver) {
      this.targetObserver.unbind();
    }
    if (this.targetObserver.unsubscribe) {
      this.targetObserver.unsubscribe(targetContext, this);
    }
    this.unobserve(true);
  };

  Binding.prototype.connect = function connect(evaluate) {
    if (!this.isBound) {
      return;
    }
    if (evaluate) {
      var value = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
      this.updateTarget(value);
    }
    this.sourceExpression.connect(this, this.source);
  };

  return Binding;
}()) || _class13);

var CallExpression = exports.CallExpression = function () {
  function CallExpression(observerLocator, targetProperty, sourceExpression, lookupFunctions) {
    

    this.observerLocator = observerLocator;
    this.targetProperty = targetProperty;
    this.sourceExpression = sourceExpression;
    this.lookupFunctions = lookupFunctions;
  }

  CallExpression.prototype.createBinding = function createBinding(target) {
    return new Call(this.observerLocator, this.sourceExpression, target, this.targetProperty, this.lookupFunctions);
  };

  return CallExpression;
}();

var Call = exports.Call = function () {
  function Call(observerLocator, sourceExpression, target, targetProperty, lookupFunctions) {
    

    this.sourceExpression = sourceExpression;
    this.target = target;
    this.targetProperty = observerLocator.getObserver(target, targetProperty);
    this.lookupFunctions = lookupFunctions;
  }

  Call.prototype.callSource = function callSource($event) {
    var overrideContext = this.source.overrideContext;
    Object.assign(overrideContext, $event);
    overrideContext.$event = $event;
    var mustEvaluate = true;
    var result = this.sourceExpression.evaluate(this.source, this.lookupFunctions, mustEvaluate);
    delete overrideContext.$event;
    for (var prop in $event) {
      delete overrideContext[prop];
    }
    return result;
  };

  Call.prototype.bind = function bind(source) {
    var _this26 = this;

    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this.source = source;

    if (this.sourceExpression.bind) {
      this.sourceExpression.bind(this, source, this.lookupFunctions);
    }
    this.targetProperty.setValue(function ($event) {
      return _this26.callSource($event);
    });
  };

  Call.prototype.unbind = function unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    if (this.sourceExpression.unbind) {
      this.sourceExpression.unbind(this, this.source);
    }
    this.source = null;
    this.targetProperty.setValue(null);
  };

  return Call;
}();

var ValueConverterResource = exports.ValueConverterResource = function () {
  function ValueConverterResource(name) {
    

    this.name = name;
  }

  ValueConverterResource.convention = function convention(name) {
    if (name.endsWith('ValueConverter')) {
      return new ValueConverterResource(camelCase(name.substring(0, name.length - 14)));
    }
  };

  ValueConverterResource.prototype.initialize = function initialize(container, target) {
    this.instance = container.get(target);
  };

  ValueConverterResource.prototype.register = function register(registry, name) {
    registry.registerValueConverter(name || this.name, this.instance);
  };

  ValueConverterResource.prototype.load = function load(container, target) {};

  return ValueConverterResource;
}();

function valueConverter(nameOrTarget) {
  if (nameOrTarget === undefined || typeof nameOrTarget === 'string') {
    return function (target) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ValueConverterResource(nameOrTarget), target);
    };
  }

  _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ValueConverterResource(), nameOrTarget);
}

var BindingBehaviorResource = exports.BindingBehaviorResource = function () {
  function BindingBehaviorResource(name) {
    

    this.name = name;
  }

  BindingBehaviorResource.convention = function convention(name) {
    if (name.endsWith('BindingBehavior')) {
      return new BindingBehaviorResource(camelCase(name.substring(0, name.length - 15)));
    }
  };

  BindingBehaviorResource.prototype.initialize = function initialize(container, target) {
    this.instance = container.get(target);
  };

  BindingBehaviorResource.prototype.register = function register(registry, name) {
    registry.registerBindingBehavior(name || this.name, this.instance);
  };

  BindingBehaviorResource.prototype.load = function load(container, target) {};

  return BindingBehaviorResource;
}();

function bindingBehavior(nameOrTarget) {
  if (nameOrTarget === undefined || typeof nameOrTarget === 'string') {
    return function (target) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new BindingBehaviorResource(nameOrTarget), target);
    };
  }

  _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new BindingBehaviorResource(), nameOrTarget);
}

var ListenerExpression = exports.ListenerExpression = function () {
  function ListenerExpression(eventManager, targetEvent, sourceExpression, delegationStrategy, preventDefault, lookupFunctions) {
    

    this.eventManager = eventManager;
    this.targetEvent = targetEvent;
    this.sourceExpression = sourceExpression;
    this.delegationStrategy = delegationStrategy;
    this.discrete = true;
    this.preventDefault = preventDefault;
    this.lookupFunctions = lookupFunctions;
  }

  ListenerExpression.prototype.createBinding = function createBinding(target) {
    return new Listener(this.eventManager, this.targetEvent, this.delegationStrategy, this.sourceExpression, target, this.preventDefault, this.lookupFunctions);
  };

  return ListenerExpression;
}();

var Listener = exports.Listener = function () {
  function Listener(eventManager, targetEvent, delegationStrategy, sourceExpression, target, preventDefault, lookupFunctions) {
    

    this.eventManager = eventManager;
    this.targetEvent = targetEvent;
    this.delegationStrategy = delegationStrategy;
    this.sourceExpression = sourceExpression;
    this.target = target;
    this.preventDefault = preventDefault;
    this.lookupFunctions = lookupFunctions;
  }

  Listener.prototype.callSource = function callSource(event) {
    var overrideContext = this.source.overrideContext;
    overrideContext.$event = event;
    var mustEvaluate = true;
    var result = this.sourceExpression.evaluate(this.source, this.lookupFunctions, mustEvaluate);
    delete overrideContext.$event;
    if (result !== true && this.preventDefault) {
      event.preventDefault();
    }
    return result;
  };

  Listener.prototype.handleEvent = function handleEvent(event) {
    this.callSource(event);
  };

  Listener.prototype.bind = function bind(source) {
    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this.source = source;

    if (this.sourceExpression.bind) {
      this.sourceExpression.bind(this, source, this.lookupFunctions);
    }
    this._handler = this.eventManager.addEventListener(this.target, this.targetEvent, this, this.delegationStrategy, true);
  };

  Listener.prototype.unbind = function unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    if (this.sourceExpression.unbind) {
      this.sourceExpression.unbind(this, this.source);
    }
    this.source = null;
    this._handler.dispose();
    this._handler = null;
  };

  return Listener;
}();

function getAU(element) {
  var au = element.au;

  if (au === undefined) {
    throw new Error('No Aurelia APIs are defined for the element: "' + element.tagName + '".');
  }

  return au;
}

var NameExpression = exports.NameExpression = function () {
  function NameExpression(sourceExpression, apiName, lookupFunctions) {
    

    this.sourceExpression = sourceExpression;
    this.apiName = apiName;
    this.lookupFunctions = lookupFunctions;
    this.discrete = true;
  }

  NameExpression.prototype.createBinding = function createBinding(target) {
    return new NameBinder(this.sourceExpression, NameExpression.locateAPI(target, this.apiName), this.lookupFunctions);
  };

  NameExpression.locateAPI = function locateAPI(element, apiName) {
    switch (apiName) {
      case 'element':
        return element;
      case 'controller':
        return getAU(element).controller;
      case 'view-model':
        return getAU(element).controller.viewModel;
      case 'view':
        return getAU(element).controller.view;
      default:
        var target = getAU(element)[apiName];

        if (target === undefined) {
          throw new Error('Attempted to reference "' + apiName + '", but it was not found amongst the target\'s API.');
        }

        return target.viewModel;
    }
  };

  return NameExpression;
}();

var NameBinder = function () {
  function NameBinder(sourceExpression, target, lookupFunctions) {
    

    this.sourceExpression = sourceExpression;
    this.target = target;
    this.lookupFunctions = lookupFunctions;
  }

  NameBinder.prototype.bind = function bind(source) {
    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this.source = source;
    if (this.sourceExpression.bind) {
      this.sourceExpression.bind(this, source, this.lookupFunctions);
    }
    this.sourceExpression.assign(this.source, this.target, this.lookupFunctions);
  };

  NameBinder.prototype.unbind = function unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    if (this.sourceExpression.evaluate(this.source, this.lookupFunctions) === this.target) {
      this.sourceExpression.assign(this.source, null, this.lookupFunctions);
    }
    if (this.sourceExpression.unbind) {
      this.sourceExpression.unbind(this, this.source);
    }
    this.source = null;
  };

  return NameBinder;
}();

var LookupFunctions = {
  bindingBehaviors: function bindingBehaviors(name) {
    return null;
  },
  valueConverters: function valueConverters(name) {
    return null;
  }
};

var BindingEngine = exports.BindingEngine = (_temp2 = _class14 = function () {
  function BindingEngine(observerLocator, parser) {
    

    this.observerLocator = observerLocator;
    this.parser = parser;
  }

  BindingEngine.prototype.createBindingExpression = function createBindingExpression(targetProperty, sourceExpression) {
    var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : bindingMode.toView;
    var lookupFunctions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : LookupFunctions;

    return new BindingExpression(this.observerLocator, targetProperty, this.parser.parse(sourceExpression), mode, lookupFunctions);
  };

  BindingEngine.prototype.propertyObserver = function propertyObserver(obj, propertyName) {
    var _this27 = this;

    return {
      subscribe: function subscribe(callback) {
        var observer = _this27.observerLocator.getObserver(obj, propertyName);
        observer.subscribe(callback);
        return {
          dispose: function dispose() {
            return observer.unsubscribe(callback);
          }
        };
      }
    };
  };

  BindingEngine.prototype.collectionObserver = function collectionObserver(collection) {
    var _this28 = this;

    return {
      subscribe: function subscribe(callback) {
        var observer = void 0;
        if (collection instanceof Array) {
          observer = _this28.observerLocator.getArrayObserver(collection);
        } else if (collection instanceof Map) {
          observer = _this28.observerLocator.getMapObserver(collection);
        } else if (collection instanceof Set) {
          observer = _this28.observerLocator.getSetObserver(collection);
        } else {
          throw new Error('collection must be an instance of Array, Map or Set.');
        }
        observer.subscribe(callback);
        return {
          dispose: function dispose() {
            return observer.unsubscribe(callback);
          }
        };
      }
    };
  };

  BindingEngine.prototype.expressionObserver = function expressionObserver(bindingContext, expression) {
    var scope = { bindingContext: bindingContext, overrideContext: createOverrideContext(bindingContext) };
    return new ExpressionObserver(scope, this.parser.parse(expression), this.observerLocator, LookupFunctions);
  };

  BindingEngine.prototype.parseExpression = function parseExpression(expression) {
    return this.parser.parse(expression);
  };

  BindingEngine.prototype.registerAdapter = function registerAdapter(adapter) {
    this.observerLocator.addAdapter(adapter);
  };

  return BindingEngine;
}(), _class14.inject = [ObserverLocator, Parser], _temp2);


var setProto = Set.prototype;

function _getSetObserver(taskQueue, set) {
  return ModifySetObserver.for(taskQueue, set);
}

exports.getSetObserver = _getSetObserver;

var ModifySetObserver = function (_ModifyCollectionObse3) {
  _inherits(ModifySetObserver, _ModifyCollectionObse3);

  function ModifySetObserver(taskQueue, set) {
    

    return _possibleConstructorReturn(this, _ModifyCollectionObse3.call(this, taskQueue, set));
  }

  ModifySetObserver.for = function _for(taskQueue, set) {
    if (!('__set_observer__' in set)) {
      Reflect.defineProperty(set, '__set_observer__', {
        value: ModifySetObserver.create(taskQueue, set),
        enumerable: false, configurable: false
      });
    }
    return set.__set_observer__;
  };

  ModifySetObserver.create = function create(taskQueue, set) {
    var observer = new ModifySetObserver(taskQueue, set);

    var proto = setProto;
    if (proto.add !== set.add || proto.delete !== set.delete || proto.clear !== set.clear) {
      proto = {
        add: set.add,
        delete: set.delete,
        clear: set.clear
      };
    }

    set.add = function () {
      var type = 'add';
      var oldSize = set.size;
      var methodCallResult = proto.add.apply(set, arguments);
      var hasValue = set.size === oldSize;
      if (!hasValue) {
        observer.addChangeRecord({
          type: type,
          object: set,
          value: Array.from(set).pop()
        });
      }
      return methodCallResult;
    };

    set.delete = function () {
      var hasValue = set.has(arguments[0]);
      var methodCallResult = proto.delete.apply(set, arguments);
      if (hasValue) {
        observer.addChangeRecord({
          type: 'delete',
          object: set,
          value: arguments[0]
        });
      }
      return methodCallResult;
    };

    set.clear = function () {
      var methodCallResult = proto.clear.apply(set, arguments);
      observer.addChangeRecord({
        type: 'clear',
        object: set
      });
      return methodCallResult;
    };

    return observer;
  };

  return ModifySetObserver;
}(ModifyCollectionObserver);

function observable(targetOrConfig, key, descriptor) {
  function deco(target, key, descriptor, config) {
    var isClassDecorator = key === undefined;
    if (isClassDecorator) {
      target = target.prototype;
      key = typeof config === 'string' ? config : config.name;
    }

    var innerPropertyName = '_' + key;
    var innerPropertyDescriptor = {
      configurable: true,
      enumerable: false,
      writable: true
    };

    var callbackName = config && config.changeHandler || key + 'Changed';

    if (descriptor) {
      if (typeof descriptor.initializer === 'function') {
        innerPropertyDescriptor.value = descriptor.initializer();
      }
    } else {
      descriptor = {};
    }

    if (!('enumerable' in descriptor)) {
      descriptor.enumerable = true;
    }

    delete descriptor.value;
    delete descriptor.writable;
    delete descriptor.initializer;

    Reflect.defineProperty(target, innerPropertyName, innerPropertyDescriptor);

    descriptor.get = function () {
      return this[innerPropertyName];
    };
    descriptor.set = function (newValue) {
      var oldValue = this[innerPropertyName];
      if (newValue === oldValue) {
        return;
      }

      this[innerPropertyName] = newValue;
      Reflect.defineProperty(this, innerPropertyName, { enumerable: false });

      if (this[callbackName]) {
        this[callbackName](newValue, oldValue, key);
      }
    };

    descriptor.get.dependencies = [innerPropertyName];

    if (isClassDecorator) {
      Reflect.defineProperty(target, key, descriptor);
    } else {
      return descriptor;
    }
  }

  if (key === undefined) {
    return function (t, k, d) {
      return deco(t, k, d, targetOrConfig);
    };
  }
  return deco(targetOrConfig, key, descriptor);
}

var signals = {};

function connectBindingToSignal(binding, name) {
  if (!signals.hasOwnProperty(name)) {
    signals[name] = 0;
  }
  binding.observeProperty(signals, name);
}

function signalBindings(name) {
  if (signals.hasOwnProperty(name)) {
    signals[name]++;
  }
}
});

define('aurelia-bootstrapper/dist/commonjs/aurelia-bootstrapper',['require','exports','module','aurelia-polyfills','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.starting = undefined;
exports.bootstrap = bootstrap;

require('aurelia-polyfills');

var _aureliaPal = require('aurelia-pal');

var bootstrapPromises = [];
var startResolve = void 0;

var startPromise = new Promise(function (resolve) {
  return startResolve = resolve;
});
var host = _aureliaPal.PLATFORM.global;
var isNodeLike = typeof process !== 'undefined' && !process.browser;

function ready() {
  if (!host.document || host.document.readyState === 'complete') {
    return Promise.resolve();
  }

  return new Promise(function (resolve) {
    host.document.addEventListener('DOMContentLoaded', completed);
    host.addEventListener('load', completed);

    function completed() {
      host.document.removeEventListener('DOMContentLoaded', completed);
      host.removeEventListener('load', completed);
      resolve();
    }
  });
}

function createLoader() {
  if (_aureliaPal.PLATFORM.Loader) {
    return Promise.resolve(new _aureliaPal.PLATFORM.Loader());
  }

  if (typeof AURELIA_WEBPACK_2_0 === 'undefined') {
    if (typeof __webpack_require__ !== 'undefined') {
      var m = __webpack_require__(require.resolve('aurelia-loader-webpack'));
      return Promise.resolve(new m.WebpackLoader());
    }

    if (host.System && typeof host.System.config === 'function') {
      return host.System.normalize('aurelia-bootstrapper').then(function (bsn) {
        return host.System.normalize('aurelia-loader-default', bsn);
      }).then(function (loaderName) {
        return host.System.import(loaderName).then(function (m) {
          return new m.DefaultLoader();
        });
      });
    }

    if (typeof host.require === 'function' && typeof host.require.version === 'string') {
      return new Promise(function (resolve, reject) {
        return host.require(['aurelia-loader-default'], function (m) {
          return resolve(new m.DefaultLoader());
        }, reject);
      });
    }

    if (isNodeLike && typeof module !== 'undefined' && typeof module.require !== 'undefined') {
      var _m = module.require('aurelia-loader-nodejs');
      return Promise.resolve(new _m.NodeJsLoader());
    }
  }

  return Promise.reject('No PLATFORM.Loader is defined and there is neither a System API (ES6) or a Require API (AMD) globally available to load your app.');
}

function initializePal(loader) {
  var type = void 0;

  var isRenderer = isNodeLike && (process.type === 'renderer' || process.versions['node-webkit']);

  if (isNodeLike && !isRenderer) {
    type = 'nodejs';
  } else if (typeof window !== 'undefined') {
    type = 'browser';
  } else if (typeof self !== 'undefined') {
    type = 'worker';
  } else {
    throw new Error('Could not determine platform implementation to load.');
  }

  return loader.loadModule('aurelia-pal-' + type).then(function (palModule) {
    return type === 'nodejs' && !_aureliaPal.isInitialized && palModule.globalize() || palModule.initialize();
  });
}

function preparePlatform(loader) {
  var map = function map(moduleId, relativeTo) {
    return loader.normalize(moduleId, relativeTo).then(function (normalized) {
      loader.map(moduleId, normalized);
      return normalized;
    });
  };

  return initializePal(loader).then(function () {
    return loader.normalize('aurelia-bootstrapper');
  }).then(function (bootstrapperName) {
    var frameworkPromise = map(_aureliaPal.PLATFORM.moduleName('aurelia-framework', { exports: ['Aurelia'] }), bootstrapperName);

    return Promise.all([frameworkPromise, frameworkPromise.then(function (frameworkName) {
      return map('aurelia-dependency-injection', frameworkName);
    }), map('aurelia-router', bootstrapperName), map('aurelia-logging-console', bootstrapperName)]);
  }).then(function (_ref) {
    var frameworkName = _ref[0];
    return loader.loadModule(frameworkName);
  }).then(function (fx) {
    return startResolve(function () {
      return new fx.Aurelia(loader);
    });
  });
}

function config(appHost, configModuleId, aurelia) {
  aurelia.host = appHost;
  aurelia.configModuleId = configModuleId || null;

  if (configModuleId) {
    return aurelia.loader.loadModule(configModuleId).then(function (customConfig) {
      if (!customConfig.configure) {
        throw new Error('Cannot initialize module \'' + configModuleId + '\' without a configure function.');
      }

      return customConfig.configure(aurelia);
    });
  }

  aurelia.use.standardConfiguration().developmentLogging();

  return aurelia.start().then(function () {
    return aurelia.setRoot();
  });
}

function run() {
  return ready().then(createLoader).then(preparePlatform).then(function () {
    var appHosts = host.document.querySelectorAll('[aurelia-app],[data-aurelia-app]');
    for (var i = 0, ii = appHosts.length; i < ii; ++i) {
      var appHost = appHosts[i];
      var moduleId = appHost.getAttribute('aurelia-app') || appHost.getAttribute('data-aurelia-app');
      bootstrap(config.bind(null, appHost, moduleId));
    }

    var toConsole = console.error.bind(console);
    var bootstraps = bootstrapPromises.map(function (p) {
      return p.catch(toConsole);
    });
    bootstrapPromises = null;
    return Promise.all(bootstraps);
  });
}

function bootstrap(configure) {
  var p = startPromise.then(function (factory) {
    return configure(factory());
  });
  if (bootstrapPromises) bootstrapPromises.push(p);
  return p;
}

var starting = exports.starting = run();
});

define('aurelia-dependency-injection/dist/commonjs/aurelia-dependency-injection',['require','exports','module','aurelia-metadata','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Container = exports.InvocationHandler = exports._emptyParameters = exports.SingletonRegistration = exports.TransientRegistration = exports.FactoryInvoker = exports.NewInstance = exports.Factory = exports.StrategyResolver = exports.Parent = exports.Optional = exports.All = exports.Lazy = exports.resolver = undefined;

var _dec, _class, _dec2, _class3, _dec3, _class5, _dec4, _class7, _dec5, _class9, _dec6, _class11, _dec7, _class13, _classInvokers;

exports.getDecoratorDependencies = getDecoratorDependencies;
exports.lazy = lazy;
exports.all = all;
exports.optional = optional;
exports.parent = parent;
exports.factory = factory;
exports.newInstance = newInstance;
exports.invoker = invoker;
exports.invokeAsFactory = invokeAsFactory;
exports.registration = registration;
exports.transient = transient;
exports.singleton = singleton;
exports.autoinject = autoinject;
exports.inject = inject;

var _aureliaMetadata = require('aurelia-metadata');

var _aureliaPal = require('aurelia-pal');



var resolver = exports.resolver = _aureliaMetadata.protocol.create('aurelia:resolver', function (target) {
  if (!(typeof target.get === 'function')) {
    return 'Resolvers must implement: get(container: Container, key: any): any';
  }

  return true;
});

var Lazy = exports.Lazy = (_dec = resolver(), _dec(_class = function () {
  function Lazy(key) {
    

    this._key = key;
  }

  Lazy.prototype.get = function get(container) {
    var _this = this;

    return function () {
      return container.get(_this._key);
    };
  };

  Lazy.of = function of(key) {
    return new Lazy(key);
  };

  return Lazy;
}()) || _class);
var All = exports.All = (_dec2 = resolver(), _dec2(_class3 = function () {
  function All(key) {
    

    this._key = key;
  }

  All.prototype.get = function get(container) {
    return container.getAll(this._key);
  };

  All.of = function of(key) {
    return new All(key);
  };

  return All;
}()) || _class3);
var Optional = exports.Optional = (_dec3 = resolver(), _dec3(_class5 = function () {
  function Optional(key) {
    var checkParent = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

    

    this._key = key;
    this._checkParent = checkParent;
  }

  Optional.prototype.get = function get(container) {
    if (container.hasResolver(this._key, this._checkParent)) {
      return container.get(this._key);
    }

    return null;
  };

  Optional.of = function of(key) {
    var checkParent = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

    return new Optional(key, checkParent);
  };

  return Optional;
}()) || _class5);
var Parent = exports.Parent = (_dec4 = resolver(), _dec4(_class7 = function () {
  function Parent(key) {
    

    this._key = key;
  }

  Parent.prototype.get = function get(container) {
    return container.parent ? container.parent.get(this._key) : null;
  };

  Parent.of = function of(key) {
    return new Parent(key);
  };

  return Parent;
}()) || _class7);
var StrategyResolver = exports.StrategyResolver = (_dec5 = resolver(), _dec5(_class9 = function () {
  function StrategyResolver(strategy, state) {
    

    this.strategy = strategy;
    this.state = state;
  }

  StrategyResolver.prototype.get = function get(container, key) {
    switch (this.strategy) {
      case 0:
        return this.state;
      case 1:
        var singleton = container.invoke(this.state);
        this.state = singleton;
        this.strategy = 0;
        return singleton;
      case 2:
        return container.invoke(this.state);
      case 3:
        return this.state(container, key, this);
      case 4:
        return this.state[0].get(container, key);
      case 5:
        return container.get(this.state);
      default:
        throw new Error('Invalid strategy: ' + this.strategy);
    }
  };

  return StrategyResolver;
}()) || _class9);
var Factory = exports.Factory = (_dec6 = resolver(), _dec6(_class11 = function () {
  function Factory(key) {
    

    this._key = key;
  }

  Factory.prototype.get = function get(container) {
    var _this2 = this;

    return function () {
      for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
        rest[_key] = arguments[_key];
      }

      return container.invoke(_this2._key, rest);
    };
  };

  Factory.of = function of(key) {
    return new Factory(key);
  };

  return Factory;
}()) || _class11);
var NewInstance = exports.NewInstance = (_dec7 = resolver(), _dec7(_class13 = function () {
  function NewInstance(key) {
    

    this.key = key;
    this.asKey = key;

    for (var _len2 = arguments.length, dynamicDependencies = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      dynamicDependencies[_key2 - 1] = arguments[_key2];
    }

    this.dynamicDependencies = dynamicDependencies;
  }

  NewInstance.prototype.get = function get(container) {
    var dynamicDependencies = this.dynamicDependencies.length > 0 ? this.dynamicDependencies.map(function (dependency) {
      return dependency['protocol:aurelia:resolver'] ? dependency.get(container) : container.get(dependency);
    }) : undefined;
    var instance = container.invoke(this.key, dynamicDependencies);
    container.registerInstance(this.asKey, instance);
    return instance;
  };

  NewInstance.prototype.as = function as(key) {
    this.asKey = key;
    return this;
  };

  NewInstance.of = function of(key) {
    for (var _len3 = arguments.length, dynamicDependencies = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      dynamicDependencies[_key3 - 1] = arguments[_key3];
    }

    return new (Function.prototype.bind.apply(NewInstance, [null].concat([key], dynamicDependencies)))();
  };

  return NewInstance;
}()) || _class13);
function getDecoratorDependencies(target, name) {
  var dependencies = target.inject;
  if (typeof dependencies === 'function') {
    throw new Error('Decorator ' + name + ' cannot be used with "inject()".  Please use an array instead.');
  }
  if (!dependencies) {
    dependencies = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target).slice();
    target.inject = dependencies;
  }

  return dependencies;
}

function lazy(keyValue) {
  return function (target, key, index) {
    var params = getDecoratorDependencies(target, 'lazy');
    params[index] = Lazy.of(keyValue);
  };
}

function all(keyValue) {
  return function (target, key, index) {
    var params = getDecoratorDependencies(target, 'all');
    params[index] = All.of(keyValue);
  };
}

function optional() {
  var checkParentOrTarget = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

  var deco = function deco(checkParent) {
    return function (target, key, index) {
      var params = getDecoratorDependencies(target, 'optional');
      params[index] = Optional.of(params[index], checkParent);
    };
  };
  if (typeof checkParentOrTarget === 'boolean') {
    return deco(checkParentOrTarget);
  }
  return deco(true);
}

function parent(target, key, index) {
  var params = getDecoratorDependencies(target, 'parent');
  params[index] = Parent.of(params[index]);
}

function factory(keyValue, asValue) {
  return function (target, key, index) {
    var params = getDecoratorDependencies(target, 'factory');
    var factory = Factory.of(keyValue);
    params[index] = asValue ? factory.as(asValue) : factory;
  };
}

function newInstance(asKeyOrTarget) {
  for (var _len4 = arguments.length, dynamicDependencies = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    dynamicDependencies[_key4 - 1] = arguments[_key4];
  }

  var deco = function deco(asKey) {
    return function (target, key, index) {
      var params = getDecoratorDependencies(target, 'newInstance');
      params[index] = NewInstance.of.apply(NewInstance, [params[index]].concat(dynamicDependencies));
      if (!!asKey) {
        params[index].as(asKey);
      }
    };
  };
  if (arguments.length >= 1) {
    return deco(asKeyOrTarget);
  }
  return deco();
}

function invoker(value) {
  return function (target) {
    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.invoker, value, target);
  };
}

function invokeAsFactory(potentialTarget) {
  var deco = function deco(target) {
    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.invoker, FactoryInvoker.instance, target);
  };

  return potentialTarget ? deco(potentialTarget) : deco;
}

var FactoryInvoker = exports.FactoryInvoker = function () {
  function FactoryInvoker() {
    
  }

  FactoryInvoker.prototype.invoke = function invoke(container, fn, dependencies) {
    var i = dependencies.length;
    var args = new Array(i);

    while (i--) {
      args[i] = container.get(dependencies[i]);
    }

    return fn.apply(undefined, args);
  };

  FactoryInvoker.prototype.invokeWithDynamicDependencies = function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
    var i = staticDependencies.length;
    var args = new Array(i);

    while (i--) {
      args[i] = container.get(staticDependencies[i]);
    }

    if (dynamicDependencies !== undefined) {
      args = args.concat(dynamicDependencies);
    }

    return fn.apply(undefined, args);
  };

  return FactoryInvoker;
}();

FactoryInvoker.instance = new FactoryInvoker();

function registration(value) {
  return function (target) {
    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.registration, value, target);
  };
}

function transient(key) {
  return registration(new TransientRegistration(key));
}

function singleton(keyOrRegisterInChild) {
  var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

  return registration(new SingletonRegistration(keyOrRegisterInChild, registerInChild));
}

var TransientRegistration = exports.TransientRegistration = function () {
  function TransientRegistration(key) {
    

    this._key = key;
  }

  TransientRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
    var existingResolver = container.getResolver(this._key || key);
    return existingResolver === undefined ? container.registerTransient(this._key || key, fn) : existingResolver;
  };

  return TransientRegistration;
}();

var SingletonRegistration = exports.SingletonRegistration = function () {
  function SingletonRegistration(keyOrRegisterInChild) {
    var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

    

    if (typeof keyOrRegisterInChild === 'boolean') {
      this._registerInChild = keyOrRegisterInChild;
    } else {
      this._key = keyOrRegisterInChild;
      this._registerInChild = registerInChild;
    }
  }

  SingletonRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
    var targetContainer = this._registerInChild ? container : container.root;
    var existingResolver = targetContainer.getResolver(this._key || key);
    return existingResolver === undefined ? targetContainer.registerSingleton(this._key || key, fn) : existingResolver;
  };

  return SingletonRegistration;
}();

function validateKey(key) {
  if (key === null || key === undefined) {
    throw new Error('key/value cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?');
  }
}
var _emptyParameters = exports._emptyParameters = Object.freeze([]);

_aureliaMetadata.metadata.registration = 'aurelia:registration';
_aureliaMetadata.metadata.invoker = 'aurelia:invoker';

var resolverDecorates = resolver.decorates;

var InvocationHandler = exports.InvocationHandler = function () {
  function InvocationHandler(fn, invoker, dependencies) {
    

    this.fn = fn;
    this.invoker = invoker;
    this.dependencies = dependencies;
  }

  InvocationHandler.prototype.invoke = function invoke(container, dynamicDependencies) {
    return dynamicDependencies !== undefined ? this.invoker.invokeWithDynamicDependencies(container, this.fn, this.dependencies, dynamicDependencies) : this.invoker.invoke(container, this.fn, this.dependencies);
  };

  return InvocationHandler;
}();

function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
  var i = staticDependencies.length;
  var args = new Array(i);
  var lookup = void 0;

  while (i--) {
    lookup = staticDependencies[i];

    if (lookup === null || lookup === undefined) {
      throw new Error('Constructor Parameter with index ' + i + ' cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?');
    } else {
      args[i] = container.get(lookup);
    }
  }

  if (dynamicDependencies !== undefined) {
    args = args.concat(dynamicDependencies);
  }

  return Reflect.construct(fn, args);
}

var classInvokers = (_classInvokers = {}, _classInvokers[0] = {
  invoke: function invoke(container, Type) {
    return new Type();
  },

  invokeWithDynamicDependencies: invokeWithDynamicDependencies
}, _classInvokers[1] = {
  invoke: function invoke(container, Type, deps) {
    return new Type(container.get(deps[0]));
  },

  invokeWithDynamicDependencies: invokeWithDynamicDependencies
}, _classInvokers[2] = {
  invoke: function invoke(container, Type, deps) {
    return new Type(container.get(deps[0]), container.get(deps[1]));
  },

  invokeWithDynamicDependencies: invokeWithDynamicDependencies
}, _classInvokers[3] = {
  invoke: function invoke(container, Type, deps) {
    return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]));
  },

  invokeWithDynamicDependencies: invokeWithDynamicDependencies
}, _classInvokers[4] = {
  invoke: function invoke(container, Type, deps) {
    return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]));
  },

  invokeWithDynamicDependencies: invokeWithDynamicDependencies
}, _classInvokers[5] = {
  invoke: function invoke(container, Type, deps) {
    return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]), container.get(deps[4]));
  },

  invokeWithDynamicDependencies: invokeWithDynamicDependencies
}, _classInvokers.fallback = {
  invoke: invokeWithDynamicDependencies,
  invokeWithDynamicDependencies: invokeWithDynamicDependencies
}, _classInvokers);

function getDependencies(f) {
  if (!f.hasOwnProperty('inject')) {
    return [];
  }

  if (typeof f.inject === 'function') {
    return f.inject();
  }

  return f.inject;
}

var Container = exports.Container = function () {
  function Container(configuration) {
    

    if (configuration === undefined) {
      configuration = {};
    }

    this._configuration = configuration;
    this._onHandlerCreated = configuration.onHandlerCreated;
    this._handlers = configuration.handlers || (configuration.handlers = new Map());
    this._resolvers = new Map();
    this.root = this;
    this.parent = null;
  }

  Container.prototype.makeGlobal = function makeGlobal() {
    Container.instance = this;
    return this;
  };

  Container.prototype.setHandlerCreatedCallback = function setHandlerCreatedCallback(onHandlerCreated) {
    this._onHandlerCreated = onHandlerCreated;
    this._configuration.onHandlerCreated = onHandlerCreated;
  };

  Container.prototype.registerInstance = function registerInstance(key, instance) {
    return this.registerResolver(key, new StrategyResolver(0, instance === undefined ? key : instance));
  };

  Container.prototype.registerSingleton = function registerSingleton(key, fn) {
    return this.registerResolver(key, new StrategyResolver(1, fn === undefined ? key : fn));
  };

  Container.prototype.registerTransient = function registerTransient(key, fn) {
    return this.registerResolver(key, new StrategyResolver(2, fn === undefined ? key : fn));
  };

  Container.prototype.registerHandler = function registerHandler(key, handler) {
    return this.registerResolver(key, new StrategyResolver(3, handler));
  };

  Container.prototype.registerAlias = function registerAlias(originalKey, aliasKey) {
    return this.registerResolver(aliasKey, new StrategyResolver(5, originalKey));
  };

  Container.prototype.registerResolver = function registerResolver(key, resolver) {
    validateKey(key);

    var allResolvers = this._resolvers;
    var result = allResolvers.get(key);

    if (result === undefined) {
      allResolvers.set(key, resolver);
    } else if (result.strategy === 4) {
      result.state.push(resolver);
    } else {
      allResolvers.set(key, new StrategyResolver(4, [result, resolver]));
    }

    return resolver;
  };

  Container.prototype.autoRegister = function autoRegister(key, fn) {
    fn = fn === undefined ? key : fn;

    if (typeof fn === 'function') {
      var _registration = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.registration, fn);

      if (_registration === undefined) {
        return this.registerResolver(key, new StrategyResolver(1, fn));
      }

      return _registration.registerResolver(this, key, fn);
    }

    return this.registerResolver(key, new StrategyResolver(0, fn));
  };

  Container.prototype.autoRegisterAll = function autoRegisterAll(fns) {
    var i = fns.length;
    while (i--) {
      this.autoRegister(fns[i]);
    }
  };

  Container.prototype.unregister = function unregister(key) {
    this._resolvers.delete(key);
  };

  Container.prototype.hasResolver = function hasResolver(key) {
    var checkParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

    validateKey(key);

    return this._resolvers.has(key) || checkParent && this.parent !== null && this.parent.hasResolver(key, checkParent);
  };

  Container.prototype.getResolver = function getResolver(key) {
    return this._resolvers.get(key);
  };

  Container.prototype.get = function get(key) {
    validateKey(key);

    if (key === Container) {
      return this;
    }

    if (resolverDecorates(key)) {
      return key.get(this, key);
    }

    var resolver = this._resolvers.get(key);

    if (resolver === undefined) {
      if (this.parent === null) {
        return this.autoRegister(key).get(this, key);
      }

      var _registration2 = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.registration, key);

      if (_registration2 === undefined) {
        return this.parent._get(key);
      }

      return _registration2.registerResolver(this, key, key).get(this, key);
    }

    return resolver.get(this, key);
  };

  Container.prototype._get = function _get(key) {
    var resolver = this._resolvers.get(key);

    if (resolver === undefined) {
      if (this.parent === null) {
        return this.autoRegister(key).get(this, key);
      }

      return this.parent._get(key);
    }

    return resolver.get(this, key);
  };

  Container.prototype.getAll = function getAll(key) {
    validateKey(key);

    var resolver = this._resolvers.get(key);

    if (resolver === undefined) {
      if (this.parent === null) {
        return _emptyParameters;
      }

      return this.parent.getAll(key);
    }

    if (resolver.strategy === 4) {
      var state = resolver.state;
      var i = state.length;
      var results = new Array(i);

      while (i--) {
        results[i] = state[i].get(this, key);
      }

      return results;
    }

    return [resolver.get(this, key)];
  };

  Container.prototype.createChild = function createChild() {
    var child = new Container(this._configuration);
    child.root = this.root;
    child.parent = this;
    return child;
  };

  Container.prototype.invoke = function invoke(fn, dynamicDependencies) {
    try {
      var _handler = this._handlers.get(fn);

      if (_handler === undefined) {
        _handler = this._createInvocationHandler(fn);
        this._handlers.set(fn, _handler);
      }

      return _handler.invoke(this, dynamicDependencies);
    } catch (e) {
      throw new _aureliaPal.AggregateError('Error invoking ' + fn.name + '. Check the inner error for details.', e, true);
    }
  };

  Container.prototype._createInvocationHandler = function _createInvocationHandler(fn) {
    var dependencies = void 0;

    if (fn.inject === undefined) {
      dependencies = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, fn) || _emptyParameters;
    } else {
      dependencies = [];
      var ctor = fn;
      while (typeof ctor === 'function') {
        var _dependencies;

        (_dependencies = dependencies).push.apply(_dependencies, getDependencies(ctor));
        ctor = Object.getPrototypeOf(ctor);
      }
    }

    var invoker = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.invoker, fn) || classInvokers[dependencies.length] || classInvokers.fallback;

    var handler = new InvocationHandler(fn, invoker, dependencies);
    return this._onHandlerCreated !== undefined ? this._onHandlerCreated(handler) : handler;
  };

  return Container;
}();

function autoinject(potentialTarget) {
  var deco = function deco(target) {
    var previousInject = target.inject ? target.inject.slice() : null;
    var autoInject = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target) || _emptyParameters;
    if (!previousInject) {
      target.inject = autoInject;
    } else {
      for (var i = 0; i < autoInject.length; i++) {
        if (previousInject[i] && previousInject[i] !== autoInject[i]) {
          var prevIndex = previousInject.indexOf(autoInject[i]);
          if (prevIndex > -1) {
            previousInject.splice(prevIndex, 1);
          }
          previousInject.splice(prevIndex > -1 && prevIndex < i ? i - 1 : i, 0, autoInject[i]);
        } else if (!previousInject[i]) {
          previousInject[i] = autoInject[i];
        }
      }
      target.inject = previousInject;
    }
  };

  return potentialTarget ? deco(potentialTarget) : deco;
}

function inject() {
  for (var _len5 = arguments.length, rest = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    rest[_key5] = arguments[_key5];
  }

  return function (target, key, descriptor) {
    if (typeof descriptor === 'number' && rest.length === 1) {
      var params = target.inject;
      if (typeof params === 'function') {
        throw new Error('Decorator inject cannot be used with "inject()".  Please use an array instead.');
      }
      if (!params) {
        params = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target).slice();
        target.inject = params;
      }
      params[descriptor] = rest[0];
      return;
    }

    if (descriptor) {
      var _fn = descriptor.value;
      _fn.inject = rest;
    } else {
      target.inject = rest;
    }
  };
}
});

define('aurelia-event-aggregator/dist/commonjs/aurelia-event-aggregator',['require','exports','module','aurelia-logging'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventAggregator = undefined;
exports.includeEventsIn = includeEventsIn;
exports.configure = configure;

var _aureliaLogging = require('aurelia-logging');

var LogManager = _interopRequireWildcard(_aureliaLogging);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }



var logger = LogManager.getLogger('event-aggregator');

var Handler = function () {
  function Handler(messageType, callback) {
    

    this.messageType = messageType;
    this.callback = callback;
  }

  Handler.prototype.handle = function handle(message) {
    if (message instanceof this.messageType) {
      this.callback.call(null, message);
    }
  };

  return Handler;
}();

function invokeCallback(callback, data, event) {
  try {
    callback(data, event);
  } catch (e) {
    logger.error(e);
  }
}

function invokeHandler(handler, data) {
  try {
    handler.handle(data);
  } catch (e) {
    logger.error(e);
  }
}

var EventAggregator = exports.EventAggregator = function () {
  function EventAggregator() {
    

    this.eventLookup = {};
    this.messageHandlers = [];
  }

  EventAggregator.prototype.publish = function publish(event, data) {
    var subscribers = void 0;
    var i = void 0;

    if (!event) {
      throw new Error('Event was invalid.');
    }

    if (typeof event === 'string') {
      subscribers = this.eventLookup[event];
      if (subscribers) {
        subscribers = subscribers.slice();
        i = subscribers.length;

        while (i--) {
          invokeCallback(subscribers[i], data, event);
        }
      }
    } else {
      subscribers = this.messageHandlers.slice();
      i = subscribers.length;

      while (i--) {
        invokeHandler(subscribers[i], event);
      }
    }
  };

  EventAggregator.prototype.subscribe = function subscribe(event, callback) {
    var handler = void 0;
    var subscribers = void 0;

    if (!event) {
      throw new Error('Event channel/type was invalid.');
    }

    if (typeof event === 'string') {
      handler = callback;
      subscribers = this.eventLookup[event] || (this.eventLookup[event] = []);
    } else {
      handler = new Handler(event, callback);
      subscribers = this.messageHandlers;
    }

    subscribers.push(handler);

    return {
      dispose: function dispose() {
        var idx = subscribers.indexOf(handler);
        if (idx !== -1) {
          subscribers.splice(idx, 1);
        }
      }
    };
  };

  EventAggregator.prototype.subscribeOnce = function subscribeOnce(event, callback) {
    var sub = this.subscribe(event, function (a, b) {
      sub.dispose();
      return callback(a, b);
    });

    return sub;
  };

  return EventAggregator;
}();

function includeEventsIn(obj) {
  var ea = new EventAggregator();

  obj.subscribeOnce = function (event, callback) {
    return ea.subscribeOnce(event, callback);
  };

  obj.subscribe = function (event, callback) {
    return ea.subscribe(event, callback);
  };

  obj.publish = function (event, data) {
    ea.publish(event, data);
  };

  return ea;
}

function configure(config) {
  config.instance(EventAggregator, includeEventsIn(config.aurelia));
}
});

define('aurelia-framework/dist/commonjs/aurelia-framework',['require','exports','module','aurelia-dependency-injection','aurelia-binding','aurelia-metadata','aurelia-templating','aurelia-loader','aurelia-task-queue','aurelia-path','aurelia-pal','aurelia-logging'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LogManager = exports.FrameworkConfiguration = exports.Aurelia = undefined;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

Object.keys(_aureliaDependencyInjection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaDependencyInjection[key];
    }
  });
});

var _aureliaBinding = require('aurelia-binding');

Object.keys(_aureliaBinding).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaBinding[key];
    }
  });
});

var _aureliaMetadata = require('aurelia-metadata');

Object.keys(_aureliaMetadata).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaMetadata[key];
    }
  });
});

var _aureliaTemplating = require('aurelia-templating');

Object.keys(_aureliaTemplating).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaTemplating[key];
    }
  });
});

var _aureliaLoader = require('aurelia-loader');

Object.keys(_aureliaLoader).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaLoader[key];
    }
  });
});

var _aureliaTaskQueue = require('aurelia-task-queue');

Object.keys(_aureliaTaskQueue).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaTaskQueue[key];
    }
  });
});

var _aureliaPath = require('aurelia-path');

Object.keys(_aureliaPath).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaPath[key];
    }
  });
});

var _aureliaPal = require('aurelia-pal');

Object.keys(_aureliaPal).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaPal[key];
    }
  });
});

var _aureliaLogging = require('aurelia-logging');

var TheLogManager = _interopRequireWildcard(_aureliaLogging);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }



function preventActionlessFormSubmit() {
  _aureliaPal.DOM.addEventListener('submit', function (evt) {
    var target = evt.target;
    var action = target.action;

    if (target.tagName.toLowerCase() === 'form' && !action) {
      evt.preventDefault();
    }
  });
}

var Aurelia = exports.Aurelia = function () {
  function Aurelia(loader, container, resources) {
    

    this.loader = loader || new _aureliaPal.PLATFORM.Loader();
    this.container = container || new _aureliaDependencyInjection.Container().makeGlobal();
    this.resources = resources || new _aureliaTemplating.ViewResources();
    this.use = new FrameworkConfiguration(this);
    this.logger = TheLogManager.getLogger('aurelia');
    this.hostConfigured = false;
    this.host = null;

    this.use.instance(Aurelia, this);
    this.use.instance(_aureliaLoader.Loader, this.loader);
    this.use.instance(_aureliaTemplating.ViewResources, this.resources);
  }

  Aurelia.prototype.start = function start() {
    var _this = this;

    if (this._started) {
      return this._started;
    }

    this.logger.info('Aurelia Starting');
    return this._started = this.use.apply().then(function () {
      preventActionlessFormSubmit();

      if (!_this.container.hasResolver(_aureliaTemplating.BindingLanguage)) {
        var message = 'You must configure Aurelia with a BindingLanguage implementation.';
        _this.logger.error(message);
        throw new Error(message);
      }

      _this.logger.info('Aurelia Started');
      var evt = _aureliaPal.DOM.createCustomEvent('aurelia-started', { bubbles: true, cancelable: true });
      _aureliaPal.DOM.dispatchEvent(evt);
      return _this;
    });
  };

  Aurelia.prototype.enhance = function enhance() {
    var _this2 = this;

    var bindingContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var applicationHost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    this._configureHost(applicationHost || _aureliaPal.DOM.querySelectorAll('body')[0]);

    return new Promise(function (resolve) {
      var engine = _this2.container.get(_aureliaTemplating.TemplatingEngine);
      _this2.root = engine.enhance({ container: _this2.container, element: _this2.host, resources: _this2.resources, bindingContext: bindingContext });
      _this2.root.attached();
      _this2._onAureliaComposed();
      resolve(_this2);
    });
  };

  Aurelia.prototype.setRoot = function setRoot() {
    var _this3 = this;

    var root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var applicationHost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    var instruction = {};

    if (this.root && this.root.viewModel && this.root.viewModel.router) {
      this.root.viewModel.router.deactivate();
      this.root.viewModel.router.reset();
    }

    this._configureHost(applicationHost);

    var engine = this.container.get(_aureliaTemplating.TemplatingEngine);
    var transaction = this.container.get(_aureliaTemplating.CompositionTransaction);
    delete transaction.initialComposition;

    if (!root) {
      if (this.configModuleId) {
        root = (0, _aureliaPath.relativeToFile)('./app', this.configModuleId);
      } else {
        root = 'app';
      }
    }

    instruction.viewModel = root;
    instruction.container = instruction.childContainer = this.container;
    instruction.viewSlot = this.hostSlot;
    instruction.host = this.host;

    return engine.compose(instruction).then(function (r) {
      _this3.root = r;
      instruction.viewSlot.attached();
      _this3._onAureliaComposed();
      return _this3;
    });
  };

  Aurelia.prototype._configureHost = function _configureHost(applicationHost) {
    if (this.hostConfigured) {
      return;
    }
    applicationHost = applicationHost || this.host;

    if (!applicationHost || typeof applicationHost === 'string') {
      this.host = _aureliaPal.DOM.getElementById(applicationHost || 'applicationHost');
    } else {
      this.host = applicationHost;
    }

    if (!this.host) {
      throw new Error('No applicationHost was specified.');
    }

    this.hostConfigured = true;
    this.host.aurelia = this;
    this.hostSlot = new _aureliaTemplating.ViewSlot(this.host, true);
    this.hostSlot.transformChildNodesIntoView();
    this.container.registerInstance(_aureliaPal.DOM.boundary, this.host);
  };

  Aurelia.prototype._onAureliaComposed = function _onAureliaComposed() {
    var evt = _aureliaPal.DOM.createCustomEvent('aurelia-composed', { bubbles: true, cancelable: true });
    setTimeout(function () {
      return _aureliaPal.DOM.dispatchEvent(evt);
    }, 1);
  };

  return Aurelia;
}();

var logger = TheLogManager.getLogger('aurelia');
var extPattern = /\.[^/.]+$/;

function runTasks(config, tasks) {
  var current = void 0;
  var next = function next() {
    current = tasks.shift();
    if (current) {
      return Promise.resolve(current(config)).then(next);
    }

    return Promise.resolve();
  };

  return next();
}

function loadPlugin(config, loader, info) {
  logger.debug('Loading plugin ' + info.moduleId + '.');
  config.resourcesRelativeTo = info.resourcesRelativeTo;

  var id = info.moduleId;

  if (info.resourcesRelativeTo.length > 1) {
    return loader.normalize(info.moduleId, info.resourcesRelativeTo[1]).then(function (normalizedId) {
      return _loadPlugin(normalizedId);
    });
  }

  return _loadPlugin(id);

  function _loadPlugin(moduleId) {
    return loader.loadModule(moduleId).then(function (m) {
      if ('configure' in m) {
        return Promise.resolve(m.configure(config, info.config || {})).then(function () {
          config.resourcesRelativeTo = null;
          logger.debug('Configured plugin ' + info.moduleId + '.');
        });
      }

      config.resourcesRelativeTo = null;
      logger.debug('Loaded plugin ' + info.moduleId + '.');
    });
  }
}

function loadResources(aurelia, resourcesToLoad, appResources) {
  var viewEngine = aurelia.container.get(_aureliaTemplating.ViewEngine);

  return Promise.all(Object.keys(resourcesToLoad).map(function (n) {
    return _normalize(resourcesToLoad[n]);
  })).then(function (loads) {
    var names = [];
    var importIds = [];

    loads.forEach(function (l) {
      names.push(undefined);
      importIds.push(l.importId);
    });

    return viewEngine.importViewResources(importIds, names, appResources);
  });

  function _normalize(load) {
    var moduleId = load.moduleId;
    var ext = getExt(moduleId);

    if (isOtherResource(moduleId)) {
      moduleId = removeExt(moduleId);
    }

    return aurelia.loader.normalize(moduleId, load.relativeTo).then(function (normalized) {
      return {
        name: load.moduleId,
        importId: isOtherResource(load.moduleId) ? addOriginalExt(normalized, ext) : normalized
      };
    });
  }

  function isOtherResource(name) {
    var ext = getExt(name);
    if (!ext) return false;
    if (ext === '') return false;
    if (ext === '.js' || ext === '.ts') return false;
    return true;
  }

  function removeExt(name) {
    return name.replace(extPattern, '');
  }

  function addOriginalExt(normalized, ext) {
    return removeExt(normalized) + '.' + ext;
  }
}

function getExt(name) {
  var match = name.match(extPattern);
  if (match && match.length > 0) {
    return match[0].split('.')[1];
  }
}

function assertProcessed(plugins) {
  if (plugins.processed) {
    throw new Error('This config instance has already been applied. To load more plugins or global resources, create a new FrameworkConfiguration instance.');
  }
}

var FrameworkConfiguration = function () {
  function FrameworkConfiguration(aurelia) {
    var _this4 = this;

    

    this.aurelia = aurelia;
    this.container = aurelia.container;
    this.info = [];
    this.processed = false;
    this.preTasks = [];
    this.postTasks = [];
    this.resourcesToLoad = {};
    this.preTask(function () {
      return aurelia.loader.normalize('aurelia-bootstrapper').then(function (name) {
        return _this4.bootstrapperName = name;
      });
    });
    this.postTask(function () {
      return loadResources(aurelia, _this4.resourcesToLoad, aurelia.resources);
    });
  }

  FrameworkConfiguration.prototype.instance = function instance(type, _instance) {
    this.container.registerInstance(type, _instance);
    return this;
  };

  FrameworkConfiguration.prototype.singleton = function singleton(type, implementation) {
    this.container.registerSingleton(type, implementation);
    return this;
  };

  FrameworkConfiguration.prototype.transient = function transient(type, implementation) {
    this.container.registerTransient(type, implementation);
    return this;
  };

  FrameworkConfiguration.prototype.preTask = function preTask(task) {
    assertProcessed(this);
    this.preTasks.push(task);
    return this;
  };

  FrameworkConfiguration.prototype.postTask = function postTask(task) {
    assertProcessed(this);
    this.postTasks.push(task);
    return this;
  };

  FrameworkConfiguration.prototype.feature = function feature(plugin) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var hasIndex = /\/index$/i.test(plugin);
    var moduleId = hasIndex || getExt(plugin) ? plugin : plugin + '/index';
    var root = hasIndex ? plugin.substr(0, plugin.length - 6) : plugin;
    return this.plugin({ moduleId: moduleId, resourcesRelativeTo: [root, ''], config: config });
  };

  FrameworkConfiguration.prototype.globalResources = function globalResources(resources) {
    assertProcessed(this);

    var toAdd = Array.isArray(resources) ? resources : arguments;
    var resource = void 0;
    var resourcesRelativeTo = this.resourcesRelativeTo || ['', ''];

    for (var i = 0, ii = toAdd.length; i < ii; ++i) {
      resource = toAdd[i];
      if (typeof resource !== 'string') {
        throw new Error('Invalid resource path [' + resource + ']. Resources must be specified as relative module IDs.');
      }

      var parent = resourcesRelativeTo[0];
      var grandParent = resourcesRelativeTo[1];
      var name = resource;

      if ((resource.startsWith('./') || resource.startsWith('../')) && parent !== '') {
        name = (0, _aureliaPath.join)(parent, resource);
      }

      this.resourcesToLoad[name] = { moduleId: name, relativeTo: grandParent };
    }

    return this;
  };

  FrameworkConfiguration.prototype.globalName = function globalName(resourcePath, newName) {
    assertProcessed(this);
    this.resourcesToLoad[resourcePath] = { moduleId: newName, relativeTo: '' };
    return this;
  };

  FrameworkConfiguration.prototype.plugin = function plugin(_plugin, config) {
    assertProcessed(this);

    if (typeof _plugin === 'string') {
      return this.plugin({ moduleId: _plugin, resourcesRelativeTo: [_plugin, ''], config: config || {} });
    }

    this.info.push(_plugin);
    return this;
  };

  FrameworkConfiguration.prototype._addNormalizedPlugin = function _addNormalizedPlugin(name, config) {
    var _this5 = this;

    var plugin = { moduleId: name, resourcesRelativeTo: [name, ''], config: config || {} };
    this.plugin(plugin);

    this.preTask(function () {
      var relativeTo = [name, _this5.bootstrapperName];
      plugin.moduleId = name;
      plugin.resourcesRelativeTo = relativeTo;
      return Promise.resolve();
    });

    return this;
  };

  FrameworkConfiguration.prototype.defaultBindingLanguage = function defaultBindingLanguage() {
    return this._addNormalizedPlugin('aurelia-templating-binding');
  };

  FrameworkConfiguration.prototype.router = function router() {
    return this._addNormalizedPlugin('aurelia-templating-router');
  };

  FrameworkConfiguration.prototype.history = function history() {
    return this._addNormalizedPlugin('aurelia-history-browser');
  };

  FrameworkConfiguration.prototype.defaultResources = function defaultResources() {
    return this._addNormalizedPlugin('aurelia-templating-resources');
  };

  FrameworkConfiguration.prototype.eventAggregator = function eventAggregator() {
    return this._addNormalizedPlugin('aurelia-event-aggregator');
  };

  FrameworkConfiguration.prototype.basicConfiguration = function basicConfiguration() {
    return this.defaultBindingLanguage().defaultResources().eventAggregator();
  };

  FrameworkConfiguration.prototype.standardConfiguration = function standardConfiguration() {
    return this.basicConfiguration().history().router();
  };

  FrameworkConfiguration.prototype.developmentLogging = function developmentLogging(level) {
    var _this6 = this;

    var logLevel = level ? TheLogManager.logLevel[level] : undefined;

    if (logLevel === undefined) {
      logLevel = TheLogManager.logLevel.debug;
    }

    this.preTask(function () {
      return _this6.aurelia.loader.normalize('aurelia-logging-console', _this6.bootstrapperName).then(function (name) {
        return _this6.aurelia.loader.loadModule(name).then(function (m) {
          TheLogManager.addAppender(new m.ConsoleAppender());
          TheLogManager.setLevel(logLevel);
        });
      });
    });

    return this;
  };

  FrameworkConfiguration.prototype.apply = function apply() {
    var _this7 = this;

    if (this.processed) {
      return Promise.resolve();
    }

    return runTasks(this, this.preTasks).then(function () {
      var loader = _this7.aurelia.loader;
      var info = _this7.info;
      var current = void 0;

      var next = function next() {
        current = info.shift();
        if (current) {
          return loadPlugin(_this7, loader, current).then(next);
        }

        _this7.processed = true;
        return Promise.resolve();
      };

      return next().then(function () {
        return runTasks(_this7, _this7.postTasks);
      });
    });
  };

  return FrameworkConfiguration;
}();

exports.FrameworkConfiguration = FrameworkConfiguration;
var LogManager = exports.LogManager = TheLogManager;
});

define('aurelia-history-browser/dist/commonjs/aurelia-history-browser',['require','exports','module','aurelia-pal','aurelia-history'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BrowserHistory = exports.DefaultLinkHandler = exports.LinkHandler = undefined;

var _class, _temp;

exports.configure = configure;

var _aureliaPal = require('aurelia-pal');

var _aureliaHistory = require('aurelia-history');

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var LinkHandler = exports.LinkHandler = function () {
  function LinkHandler() {
    
  }

  LinkHandler.prototype.activate = function activate(history) {};

  LinkHandler.prototype.deactivate = function deactivate() {};

  return LinkHandler;
}();

var DefaultLinkHandler = exports.DefaultLinkHandler = function (_LinkHandler) {
  _inherits(DefaultLinkHandler, _LinkHandler);

  function DefaultLinkHandler() {
    

    var _this = _possibleConstructorReturn(this, _LinkHandler.call(this));

    _this.handler = function (e) {
      var _DefaultLinkHandler$g = DefaultLinkHandler.getEventInfo(e);

      var shouldHandleEvent = _DefaultLinkHandler$g.shouldHandleEvent;
      var href = _DefaultLinkHandler$g.href;


      if (shouldHandleEvent) {
        e.preventDefault();
        _this.history.navigate(href);
      }
    };
    return _this;
  }

  DefaultLinkHandler.prototype.activate = function activate(history) {
    if (history._hasPushState) {
      this.history = history;
      _aureliaPal.DOM.addEventListener('click', this.handler, true);
    }
  };

  DefaultLinkHandler.prototype.deactivate = function deactivate() {
    _aureliaPal.DOM.removeEventListener('click', this.handler);
  };

  DefaultLinkHandler.getEventInfo = function getEventInfo(event) {
    var info = {
      shouldHandleEvent: false,
      href: null,
      anchor: null
    };

    var target = DefaultLinkHandler.findClosestAnchor(event.target);
    if (!target || !DefaultLinkHandler.targetIsThisWindow(target)) {
      return info;
    }

    if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
      return info;
    }

    var href = target.getAttribute('href');
    info.anchor = target;
    info.href = href;

    var leftButtonClicked = event.which === 1;
    var isRelative = href && !(href.charAt(0) === '#' || /^[a-z]+:/i.test(href));

    info.shouldHandleEvent = leftButtonClicked && isRelative;
    return info;
  };

  DefaultLinkHandler.findClosestAnchor = function findClosestAnchor(el) {
    while (el) {
      if (el.tagName === 'A') {
        return el;
      }

      el = el.parentNode;
    }
  };

  DefaultLinkHandler.targetIsThisWindow = function targetIsThisWindow(target) {
    var targetWindow = target.getAttribute('target');
    var win = _aureliaPal.PLATFORM.global;

    return !targetWindow || targetWindow === win.name || targetWindow === '_self' || targetWindow === 'top' && win === win.top;
  };

  return DefaultLinkHandler;
}(LinkHandler);

function configure(config) {
  config.singleton(_aureliaHistory.History, BrowserHistory);
  config.transient(LinkHandler, DefaultLinkHandler);
}

var BrowserHistory = exports.BrowserHistory = (_temp = _class = function (_History) {
  _inherits(BrowserHistory, _History);

  function BrowserHistory(linkHandler) {
    

    var _this2 = _possibleConstructorReturn(this, _History.call(this));

    _this2._isActive = false;
    _this2._checkUrlCallback = _this2._checkUrl.bind(_this2);

    _this2.location = _aureliaPal.PLATFORM.location;
    _this2.history = _aureliaPal.PLATFORM.history;
    _this2.linkHandler = linkHandler;
    return _this2;
  }

  BrowserHistory.prototype.activate = function activate(options) {
    if (this._isActive) {
      throw new Error('History has already been activated.');
    }

    var wantsPushState = !!options.pushState;

    this._isActive = true;
    this.options = Object.assign({}, { root: '/' }, this.options, options);

    this.root = ('/' + this.options.root + '/').replace(rootStripper, '/');

    this._wantsHashChange = this.options.hashChange !== false;
    this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);

    var eventName = void 0;
    if (this._hasPushState) {
      eventName = 'popstate';
    } else if (this._wantsHashChange) {
      eventName = 'hashchange';
    }

    _aureliaPal.PLATFORM.addEventListener(eventName, this._checkUrlCallback);

    if (this._wantsHashChange && wantsPushState) {
      var loc = this.location;
      var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

      if (!this._hasPushState && !atRoot) {
        this.fragment = this._getFragment(null, true);
        this.location.replace(this.root + this.location.search + '#' + this.fragment);

        return true;
      } else if (this._hasPushState && atRoot && loc.hash) {
          this.fragment = this._getHash().replace(routeStripper, '');
          this.history.replaceState({}, _aureliaPal.DOM.title, this.root + this.fragment + loc.search);
        }
    }

    if (!this.fragment) {
      this.fragment = this._getFragment();
    }

    this.linkHandler.activate(this);

    if (!this.options.silent) {
      return this._loadUrl();
    }
  };

  BrowserHistory.prototype.deactivate = function deactivate() {
    _aureliaPal.PLATFORM.removeEventListener('popstate', this._checkUrlCallback);
    _aureliaPal.PLATFORM.removeEventListener('hashchange', this._checkUrlCallback);
    this._isActive = false;
    this.linkHandler.deactivate();
  };

  BrowserHistory.prototype.getAbsoluteRoot = function getAbsoluteRoot() {
    var origin = createOrigin(this.location.protocol, this.location.hostname, this.location.port);
    return '' + origin + this.root;
  };

  BrowserHistory.prototype.navigate = function navigate(fragment) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var _ref$trigger = _ref.trigger;
    var trigger = _ref$trigger === undefined ? true : _ref$trigger;
    var _ref$replace = _ref.replace;
    var replace = _ref$replace === undefined ? false : _ref$replace;

    if (fragment && absoluteUrl.test(fragment)) {
      this.location.href = fragment;
      return true;
    }

    if (!this._isActive) {
      return false;
    }

    fragment = this._getFragment(fragment || '');

    if (this.fragment === fragment && !replace) {
      return false;
    }

    this.fragment = fragment;

    var url = this.root + fragment;

    if (fragment === '' && url !== '/') {
      url = url.slice(0, -1);
    }

    if (this._hasPushState) {
      url = url.replace('//', '/');
      this.history[replace ? 'replaceState' : 'pushState']({}, _aureliaPal.DOM.title, url);
    } else if (this._wantsHashChange) {
      updateHash(this.location, fragment, replace);
    } else {
      return this.location.assign(url);
    }

    if (trigger) {
      return this._loadUrl(fragment);
    }
  };

  BrowserHistory.prototype.navigateBack = function navigateBack() {
    this.history.back();
  };

  BrowserHistory.prototype.setTitle = function setTitle(title) {
    _aureliaPal.DOM.title = title;
  };

  BrowserHistory.prototype.setState = function setState(key, value) {
    var state = Object.assign({}, this.history.state);
    var _location = this.location;
    var pathname = _location.pathname;
    var search = _location.search;
    var hash = _location.hash;

    state[key] = value;
    this.history.replaceState(state, null, '' + pathname + search + hash);
  };

  BrowserHistory.prototype.getState = function getState(key) {
    var state = Object.assign({}, this.history.state);
    return state[key];
  };

  BrowserHistory.prototype._getHash = function _getHash() {
    return this.location.hash.substr(1);
  };

  BrowserHistory.prototype._getFragment = function _getFragment(fragment, forcePushState) {
    var root = void 0;

    if (!fragment) {
      if (this._hasPushState || !this._wantsHashChange || forcePushState) {
        fragment = this.location.pathname + this.location.search;
        root = this.root.replace(trailingSlash, '');
        if (!fragment.indexOf(root)) {
          fragment = fragment.substr(root.length);
        }
      } else {
        fragment = this._getHash();
      }
    }

    return '/' + fragment.replace(routeStripper, '');
  };

  BrowserHistory.prototype._checkUrl = function _checkUrl() {
    var current = this._getFragment();
    if (current !== this.fragment) {
      this._loadUrl();
    }
  };

  BrowserHistory.prototype._loadUrl = function _loadUrl(fragmentOverride) {
    var fragment = this.fragment = this._getFragment(fragmentOverride);

    return this.options.routeHandler ? this.options.routeHandler(fragment) : false;
  };

  return BrowserHistory;
}(_aureliaHistory.History), _class.inject = [LinkHandler], _temp);

var routeStripper = /^#?\/*|\s+$/g;

var rootStripper = /^\/+|\/+$/g;

var trailingSlash = /\/$/;

var absoluteUrl = /^([a-z][a-z0-9+\-.]*:)?\/\//i;

function updateHash(location, fragment, replace) {
  if (replace) {
    var _href = location.href.replace(/(javascript:|#).*$/, '');
    location.replace(_href + '#' + fragment);
  } else {
    location.hash = '#' + fragment;
  }
}

function createOrigin(protocol, hostname, port) {
  return protocol + '//' + hostname + (port ? ':' + port : '');
}
});

define('aurelia-history/dist/commonjs/aurelia-history',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});



function mi(name) {
  throw new Error('History must implement ' + name + '().');
}

var History = exports.History = function () {
  function History() {
    
  }

  History.prototype.activate = function activate(options) {
    mi('activate');
  };

  History.prototype.deactivate = function deactivate() {
    mi('deactivate');
  };

  History.prototype.getAbsoluteRoot = function getAbsoluteRoot() {
    mi('getAbsoluteRoot');
  };

  History.prototype.navigate = function navigate(fragment, options) {
    mi('navigate');
  };

  History.prototype.navigateBack = function navigateBack() {
    mi('navigateBack');
  };

  History.prototype.setTitle = function setTitle(title) {
    mi('setTitle');
  };

  History.prototype.setState = function setState(key, value) {
    mi('setState');
  };

  History.prototype.getState = function getState(key) {
    mi('getState');
  };

  return History;
}();
});

define('aurelia-loader-default/dist/commonjs/aurelia-loader-default',['require','exports','module','aurelia-loader','aurelia-pal','aurelia-metadata'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DefaultLoader = exports.TextTemplateLoader = undefined;

var _aureliaLoader = require('aurelia-loader');

var _aureliaPal = require('aurelia-pal');

var _aureliaMetadata = require('aurelia-metadata');

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var TextTemplateLoader = exports.TextTemplateLoader = function () {
  function TextTemplateLoader() {
    
  }

  TextTemplateLoader.prototype.loadTemplate = function loadTemplate(loader, entry) {
    return loader.loadText(entry.address).then(function (text) {
      entry.template = _aureliaPal.DOM.createTemplateFromMarkup(text);
    });
  };

  return TextTemplateLoader;
}();

function ensureOriginOnExports(executed, name) {
  var target = executed;
  var key = void 0;
  var exportedValue = void 0;

  if (target.__useDefault) {
    target = target['default'];
  }

  _aureliaMetadata.Origin.set(target, new _aureliaMetadata.Origin(name, 'default'));

  for (key in target) {
    exportedValue = target[key];

    if (typeof exportedValue === 'function') {
      _aureliaMetadata.Origin.set(exportedValue, new _aureliaMetadata.Origin(name, key));
    }
  }

  return executed;
}

var DefaultLoader = exports.DefaultLoader = function (_Loader) {
  _inherits(DefaultLoader, _Loader);

  function DefaultLoader() {
    

    var _this = _possibleConstructorReturn(this, _Loader.call(this));

    _this.textPluginName = 'text';


    _this.moduleRegistry = Object.create(null);
    _this.useTemplateLoader(new TextTemplateLoader());

    var that = _this;

    _this.addPlugin('template-registry-entry', {
      'fetch': function fetch(address) {
        var entry = that.getOrCreateTemplateRegistryEntry(address);
        return entry.templateIsLoaded ? entry : that.templateLoader.loadTemplate(that, entry).then(function (x) {
          return entry;
        });
      }
    });
    return _this;
  }

  DefaultLoader.prototype.useTemplateLoader = function useTemplateLoader(templateLoader) {
    this.templateLoader = templateLoader;
  };

  DefaultLoader.prototype.loadAllModules = function loadAllModules(ids) {
    var loads = [];

    for (var i = 0, ii = ids.length; i < ii; ++i) {
      loads.push(this.loadModule(ids[i]));
    }

    return Promise.all(loads);
  };

  DefaultLoader.prototype.loadTemplate = function loadTemplate(url) {
    return this._import(this.applyPluginToUrl(url, 'template-registry-entry'));
  };

  DefaultLoader.prototype.loadText = function loadText(url) {
    return this._import(this.applyPluginToUrl(url, this.textPluginName)).then(function (textOrModule) {
      if (typeof textOrModule === 'string') {
        return textOrModule;
      }

      return textOrModule['default'];
    });
  };

  return DefaultLoader;
}(_aureliaLoader.Loader);

_aureliaPal.PLATFORM.Loader = DefaultLoader;

if (!_aureliaPal.PLATFORM.global.System || !_aureliaPal.PLATFORM.global.System.import) {
  if (_aureliaPal.PLATFORM.global.requirejs && requirejs.s && requirejs.s.contexts && requirejs.s.contexts._ && requirejs.s.contexts._.defined) {
    _aureliaPal.PLATFORM.eachModule = function (callback) {
      var defined = requirejs.s.contexts._.defined;
      for (var key in defined) {
        try {
          if (callback(key, defined[key])) return;
        } catch (e) {}
      }
    };
  } else {
    _aureliaPal.PLATFORM.eachModule = function (callback) {};
  }

  DefaultLoader.prototype._import = function (moduleId) {
    return new Promise(function (resolve, reject) {
      _aureliaPal.PLATFORM.global.require([moduleId], resolve, reject);
    });
  };

  DefaultLoader.prototype.loadModule = function (id) {
    var _this2 = this;

    var existing = this.moduleRegistry[id];
    if (existing !== undefined) {
      return Promise.resolve(existing);
    }

    return new Promise(function (resolve, reject) {
      _aureliaPal.PLATFORM.global.require([id], function (m) {
        _this2.moduleRegistry[id] = m;
        resolve(ensureOriginOnExports(m, id));
      }, reject);
    });
  };

  DefaultLoader.prototype.map = function (id, source) {};

  DefaultLoader.prototype.normalize = function (moduleId, relativeTo) {
    return Promise.resolve(moduleId);
  };

  DefaultLoader.prototype.normalizeSync = function (moduleId, relativeTo) {
    return moduleId;
  };

  DefaultLoader.prototype.applyPluginToUrl = function (url, pluginName) {
    return pluginName + '!' + url;
  };

  DefaultLoader.prototype.addPlugin = function (pluginName, implementation) {
    var nonAnonDefine = define;
    nonAnonDefine(pluginName, [], {
      'load': function load(name, req, onload) {
        var result = implementation.fetch(name);
        Promise.resolve(result).then(onload);
      }
    });
  };
} else {
  _aureliaPal.PLATFORM.eachModule = function (callback) {
    if (System.registry) {
      var keys = Array.from(System.registry.keys());
      for (var i = 0; i < keys.length; i++) {
        try {
          var key = keys[i];
          if (callback(key, System.registry.get(key))) {
            return;
          }
        } catch (e) {}
      }
      return;
    }

    var modules = System._loader.modules;

    for (var _key in modules) {
      try {
        if (callback(_key, modules[_key].module)) return;
      } catch (e) {}
    }
  };

  System.set('text', System.newModule({
    'translate': function translate(load) {
      return 'module.exports = "' + load.source.replace(/(["\\])/g, '\\$1').replace(/[\f]/g, '\\f').replace(/[\b]/g, '\\b').replace(/[\n]/g, '\\n').replace(/[\t]/g, '\\t').replace(/[\r]/g, '\\r').replace(/[\u2028]/g, '\\u2028').replace(/[\u2029]/g, '\\u2029') + '";';
    }
  }));

  DefaultLoader.prototype._import = function (moduleId) {
    return System.import(moduleId);
  };

  DefaultLoader.prototype.loadModule = function (id) {
    var _this3 = this;

    return System.normalize(id).then(function (newId) {
      var existing = _this3.moduleRegistry[newId];
      if (existing !== undefined) {
        return Promise.resolve(existing);
      }

      return System.import(newId).then(function (m) {
        _this3.moduleRegistry[newId] = m;
        return ensureOriginOnExports(m, newId);
      });
    });
  };

  DefaultLoader.prototype.map = function (id, source) {
    var _map;

    System.config({ map: (_map = {}, _map[id] = source, _map) });
  };

  DefaultLoader.prototype.normalizeSync = function (moduleId, relativeTo) {
    return System.normalizeSync(moduleId, relativeTo);
  };

  DefaultLoader.prototype.normalize = function (moduleId, relativeTo) {
    return System.normalize(moduleId, relativeTo);
  };

  DefaultLoader.prototype.applyPluginToUrl = function (url, pluginName) {
    return url + '!' + pluginName;
  };

  DefaultLoader.prototype.addPlugin = function (pluginName, implementation) {
    System.set(pluginName, System.newModule({
      'fetch': function fetch(load, _fetch) {
        var result = implementation.fetch(load.address);
        return Promise.resolve(result).then(function (x) {
          load.metadata.result = x;
          return '';
        });
      },
      'instantiate': function instantiate(load) {
        return load.metadata.result;
      }
    }));
  };
}
});

define('aurelia-loader/dist/commonjs/aurelia-loader',['require','exports','module','aurelia-path','aurelia-metadata'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Loader = exports.TemplateRegistryEntry = exports.TemplateDependency = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _aureliaPath = require('aurelia-path');

var _aureliaMetadata = require('aurelia-metadata');



var TemplateDependency = exports.TemplateDependency = function TemplateDependency(src, name) {
  

  this.src = src;
  this.name = name;
};

var TemplateRegistryEntry = exports.TemplateRegistryEntry = function () {
  function TemplateRegistryEntry(address) {
    

    this.templateIsLoaded = false;
    this.factoryIsReady = false;
    this.resources = null;
    this.dependencies = null;

    this.address = address;
    this.onReady = null;
    this._template = null;
    this._factory = null;
  }

  TemplateRegistryEntry.prototype.addDependency = function addDependency(src, name) {
    var finalSrc = typeof src === 'string' ? (0, _aureliaPath.relativeToFile)(src, this.address) : _aureliaMetadata.Origin.get(src).moduleId;

    this.dependencies.push(new TemplateDependency(finalSrc, name));
  };

  _createClass(TemplateRegistryEntry, [{
    key: 'template',
    get: function get() {
      return this._template;
    },
    set: function set(value) {
      var address = this.address;
      var requires = void 0;
      var current = void 0;
      var src = void 0;
      var dependencies = void 0;

      this._template = value;
      this.templateIsLoaded = true;

      requires = value.content.querySelectorAll('require');
      dependencies = this.dependencies = new Array(requires.length);

      for (var i = 0, ii = requires.length; i < ii; ++i) {
        current = requires[i];
        src = current.getAttribute('from');

        if (!src) {
          throw new Error('<require> element in ' + address + ' has no "from" attribute.');
        }

        dependencies[i] = new TemplateDependency((0, _aureliaPath.relativeToFile)(src, address), current.getAttribute('as'));

        if (current.parentNode) {
          current.parentNode.removeChild(current);
        }
      }
    }
  }, {
    key: 'factory',
    get: function get() {
      return this._factory;
    },
    set: function set(value) {
      this._factory = value;
      this.factoryIsReady = true;
    }
  }]);

  return TemplateRegistryEntry;
}();

var Loader = exports.Loader = function () {
  function Loader() {
    

    this.templateRegistry = {};
  }

  Loader.prototype.map = function map(id, source) {
    throw new Error('Loaders must implement map(id, source).');
  };

  Loader.prototype.normalizeSync = function normalizeSync(moduleId, relativeTo) {
    throw new Error('Loaders must implement normalizeSync(moduleId, relativeTo).');
  };

  Loader.prototype.normalize = function normalize(moduleId, relativeTo) {
    throw new Error('Loaders must implement normalize(moduleId: string, relativeTo: string): Promise<string>.');
  };

  Loader.prototype.loadModule = function loadModule(id) {
    throw new Error('Loaders must implement loadModule(id).');
  };

  Loader.prototype.loadAllModules = function loadAllModules(ids) {
    throw new Error('Loader must implement loadAllModules(ids).');
  };

  Loader.prototype.loadTemplate = function loadTemplate(url) {
    throw new Error('Loader must implement loadTemplate(url).');
  };

  Loader.prototype.loadText = function loadText(url) {
    throw new Error('Loader must implement loadText(url).');
  };

  Loader.prototype.applyPluginToUrl = function applyPluginToUrl(url, pluginName) {
    throw new Error('Loader must implement applyPluginToUrl(url, pluginName).');
  };

  Loader.prototype.addPlugin = function addPlugin(pluginName, implementation) {
    throw new Error('Loader must implement addPlugin(pluginName, implementation).');
  };

  Loader.prototype.getOrCreateTemplateRegistryEntry = function getOrCreateTemplateRegistryEntry(address) {
    return this.templateRegistry[address] || (this.templateRegistry[address] = new TemplateRegistryEntry(address));
  };

  return Loader;
}();
});

define('aurelia-logging-console/dist/commonjs/aurelia-logging-console',['require','exports','module','aurelia-logging'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConsoleAppender = undefined;

var _aureliaLogging = require('aurelia-logging');



var ConsoleAppender = exports.ConsoleAppender = function () {
  function ConsoleAppender() {
    
  }

  ConsoleAppender.prototype.debug = function debug(logger) {
    var _console;

    for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    (_console = console).debug.apply(_console, ['DEBUG [' + logger.id + ']'].concat(rest));
  };

  ConsoleAppender.prototype.info = function info(logger) {
    var _console2;

    for (var _len2 = arguments.length, rest = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      rest[_key2 - 1] = arguments[_key2];
    }

    (_console2 = console).info.apply(_console2, ['INFO [' + logger.id + ']'].concat(rest));
  };

  ConsoleAppender.prototype.warn = function warn(logger) {
    var _console3;

    for (var _len3 = arguments.length, rest = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      rest[_key3 - 1] = arguments[_key3];
    }

    (_console3 = console).warn.apply(_console3, ['WARN [' + logger.id + ']'].concat(rest));
  };

  ConsoleAppender.prototype.error = function error(logger) {
    var _console4;

    for (var _len4 = arguments.length, rest = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      rest[_key4 - 1] = arguments[_key4];
    }

    (_console4 = console).error.apply(_console4, ['ERROR [' + logger.id + ']'].concat(rest));
  };

  return ConsoleAppender;
}();
});

define('aurelia-logging/dist/commonjs/aurelia-logging',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLogger = getLogger;
exports.addAppender = addAppender;
exports.removeAppender = removeAppender;
exports.getAppenders = getAppenders;
exports.clearAppenders = clearAppenders;
exports.addCustomLevel = addCustomLevel;
exports.removeCustomLevel = removeCustomLevel;
exports.setLevel = setLevel;
exports.getLevel = getLevel;



var logLevel = exports.logLevel = {
  none: 0,
  error: 10,
  warn: 20,
  info: 30,
  debug: 40
};

var loggers = {};
var appenders = [];
var globalDefaultLevel = logLevel.none;

var standardLevels = ['none', 'error', 'warn', 'info', 'debug'];
function isStandardLevel(level) {
  return standardLevels.filter(function (l) {
    return l === level;
  }).length > 0;
}

function appendArgs() {
  return [this].concat(Array.prototype.slice.call(arguments));
}

function logFactory(level) {
  var threshold = logLevel[level];
  return function () {
    if (this.level < threshold) {
      return;
    }

    var args = appendArgs.apply(this, arguments);
    var i = appenders.length;
    while (i--) {
      var _appenders$i;

      (_appenders$i = appenders[i])[level].apply(_appenders$i, args);
    }
  };
}

function logFactoryCustom(level) {
  var threshold = logLevel[level];
  return function () {
    if (this.level < threshold) {
      return;
    }

    var args = appendArgs.apply(this, arguments);
    var i = appenders.length;
    while (i--) {
      var appender = appenders[i];
      if (appender[level] !== undefined) {
        appender[level].apply(appender, args);
      }
    }
  };
}

function connectLoggers() {
  var proto = Logger.prototype;
  for (var _level in logLevel) {
    if (isStandardLevel(_level)) {
      if (_level !== 'none') {
        proto[_level] = logFactory(_level);
      }
    } else {
      proto[_level] = logFactoryCustom(_level);
    }
  }
}

function disconnectLoggers() {
  var proto = Logger.prototype;
  for (var _level2 in logLevel) {
    if (_level2 !== 'none') {
      proto[_level2] = function () {};
    }
  }
}

function getLogger(id) {
  return loggers[id] || new Logger(id);
}

function addAppender(appender) {
  if (appenders.push(appender) === 1) {
    connectLoggers();
  }
}

function removeAppender(appender) {
  appenders = appenders.filter(function (a) {
    return a !== appender;
  });
}

function getAppenders() {
  return [].concat(appenders);
}

function clearAppenders() {
  appenders = [];
  disconnectLoggers();
}

function addCustomLevel(name, value) {
  if (logLevel[name] !== undefined) {
    throw Error('Log level "' + name + '" already exists.');
  }

  if (isNaN(value)) {
    throw Error('Value must be a number.');
  }

  logLevel[name] = value;

  if (appenders.length > 0) {
    connectLoggers();
  } else {
    Logger.prototype[name] = function () {};
  }
}

function removeCustomLevel(name) {
  if (logLevel[name] === undefined) {
    return;
  }

  if (isStandardLevel(name)) {
    throw Error('Built-in log level "' + name + '" cannot be removed.');
  }

  delete logLevel[name];
  delete Logger.prototype[name];
}

function setLevel(level) {
  globalDefaultLevel = level;
  for (var key in loggers) {
    loggers[key].setLevel(level);
  }
}

function getLevel() {
  return globalDefaultLevel;
}

var Logger = exports.Logger = function () {
  function Logger(id) {
    

    var cached = loggers[id];
    if (cached) {
      return cached;
    }

    loggers[id] = this;
    this.id = id;
    this.level = globalDefaultLevel;
  }

  Logger.prototype.debug = function debug(message) {};

  Logger.prototype.info = function info(message) {};

  Logger.prototype.warn = function warn(message) {};

  Logger.prototype.error = function error(message) {};

  Logger.prototype.setLevel = function setLevel(level) {
    this.level = level;
  };

  return Logger;
}();
});

define('aurelia-metadata/dist/commonjs/aurelia-metadata',['require','exports','module','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Origin = exports.metadata = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.decorators = decorators;
exports.deprecated = deprecated;
exports.mixin = mixin;
exports.protocol = protocol;

var _aureliaPal = require('aurelia-pal');



function isObject(val) {
  return val && (typeof val === 'function' || (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object');
}

var metadata = exports.metadata = {
  resource: 'aurelia:resource',
  paramTypes: 'design:paramtypes',
  propertyType: 'design:type',
  properties: 'design:properties',
  get: function get(metadataKey, target, targetKey) {
    if (!isObject(target)) {
      return undefined;
    }
    var result = metadata.getOwn(metadataKey, target, targetKey);
    return result === undefined ? metadata.get(metadataKey, Object.getPrototypeOf(target), targetKey) : result;
  },
  getOwn: function getOwn(metadataKey, target, targetKey) {
    if (!isObject(target)) {
      return undefined;
    }
    return Reflect.getOwnMetadata(metadataKey, target, targetKey);
  },
  define: function define(metadataKey, metadataValue, target, targetKey) {
    Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
  },
  getOrCreateOwn: function getOrCreateOwn(metadataKey, Type, target, targetKey) {
    var result = metadata.getOwn(metadataKey, target, targetKey);

    if (result === undefined) {
      result = new Type();
      Reflect.defineMetadata(metadataKey, result, target, targetKey);
    }

    return result;
  }
};

var originStorage = new Map();
var unknownOrigin = Object.freeze({ moduleId: undefined, moduleMember: undefined });

var Origin = exports.Origin = function () {
  function Origin(moduleId, moduleMember) {
    

    this.moduleId = moduleId;
    this.moduleMember = moduleMember;
  }

  Origin.get = function get(fn) {
    var origin = originStorage.get(fn);

    if (origin === undefined) {
      _aureliaPal.PLATFORM.eachModule(function (key, value) {
        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
          for (var name in value) {
            var exp = value[name];
            if (exp === fn) {
              originStorage.set(fn, origin = new Origin(key, name));
              return true;
            }
          }
        }

        if (value === fn) {
          originStorage.set(fn, origin = new Origin(key, 'default'));
          return true;
        }

        return false;
      });
    }

    return origin || unknownOrigin;
  };

  Origin.set = function set(fn, origin) {
    originStorage.set(fn, origin);
  };

  return Origin;
}();

function decorators() {
  for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
    rest[_key] = arguments[_key];
  }

  var applicator = function applicator(target, key, descriptor) {
    var i = rest.length;

    if (key) {
      descriptor = descriptor || {
        value: target[key],
        writable: true,
        configurable: true,
        enumerable: true
      };

      while (i--) {
        descriptor = rest[i](target, key, descriptor) || descriptor;
      }

      Object.defineProperty(target, key, descriptor);
    } else {
      while (i--) {
        target = rest[i](target) || target;
      }
    }

    return target;
  };

  applicator.on = applicator;
  return applicator;
}

function deprecated(optionsOrTarget, maybeKey, maybeDescriptor) {
  function decorator(target, key, descriptor) {
    var methodSignature = target.constructor.name + '#' + key;
    var options = maybeKey ? {} : optionsOrTarget || {};
    var message = 'DEPRECATION - ' + methodSignature;

    if (typeof descriptor.value !== 'function') {
      throw new SyntaxError('Only methods can be marked as deprecated.');
    }

    if (options.message) {
      message += ' - ' + options.message;
    }

    return _extends({}, descriptor, {
      value: function deprecationWrapper() {
        if (options.error) {
          throw new Error(message);
        } else {
          console.warn(message);
        }

        return descriptor.value.apply(this, arguments);
      }
    });
  }

  return maybeKey ? decorator(optionsOrTarget, maybeKey, maybeDescriptor) : decorator;
}

function mixin(behavior) {
  var instanceKeys = Object.keys(behavior);

  function _mixin(possible) {
    var decorator = function decorator(target) {
      var resolvedTarget = typeof target === 'function' ? target.prototype : target;

      var i = instanceKeys.length;
      while (i--) {
        var property = instanceKeys[i];
        Object.defineProperty(resolvedTarget, property, {
          value: behavior[property],
          writable: true
        });
      }
    };

    return possible ? decorator(possible) : decorator;
  }

  return _mixin;
}

function alwaysValid() {
  return true;
}
function noCompose() {}

function ensureProtocolOptions(options) {
  if (options === undefined) {
    options = {};
  } else if (typeof options === 'function') {
    options = {
      validate: options
    };
  }

  if (!options.validate) {
    options.validate = alwaysValid;
  }

  if (!options.compose) {
    options.compose = noCompose;
  }

  return options;
}

function createProtocolValidator(validate) {
  return function (target) {
    var result = validate(target);
    return result === true;
  };
}

function createProtocolAsserter(name, validate) {
  return function (target) {
    var result = validate(target);
    if (result !== true) {
      throw new Error(result || name + ' was not correctly implemented.');
    }
  };
}

function protocol(name, options) {
  options = ensureProtocolOptions(options);

  var result = function result(target) {
    var resolvedTarget = typeof target === 'function' ? target.prototype : target;

    options.compose(resolvedTarget);
    result.assert(resolvedTarget);

    Object.defineProperty(resolvedTarget, 'protocol:' + name, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: true
    });
  };

  result.validate = createProtocolValidator(options.validate);
  result.assert = createProtocolAsserter(name, options.validate);

  return result;
}

protocol.create = function (name, options) {
  options = ensureProtocolOptions(options);
  var hidden = 'protocol:' + name;
  var result = function result(target) {
    var decorator = protocol(name, options);
    return target ? decorator(target) : decorator;
  };

  result.decorates = function (obj) {
    return obj[hidden] === true;
  };
  result.validate = createProtocolValidator(options.validate);
  result.assert = createProtocolAsserter(name, options.validate);

  return result;
};
});

define('aurelia-pal-browser/dist/commonjs/aurelia-pal-browser',['require','exports','module','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._DOM = exports._FEATURE = exports._PLATFORM = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.initialize = initialize;

var _aureliaPal = require('aurelia-pal');

var _PLATFORM = exports._PLATFORM = {
  location: window.location,
  history: window.history,
  addEventListener: function addEventListener(eventName, callback, capture) {
    this.global.addEventListener(eventName, callback, capture);
  },
  removeEventListener: function removeEventListener(eventName, callback, capture) {
    this.global.removeEventListener(eventName, callback, capture);
  },

  performance: window.performance,
  requestAnimationFrame: function requestAnimationFrame(callback) {
    return this.global.requestAnimationFrame(callback);
  }
};

if (typeof FEATURE_NO_IE === 'undefined') {
  var test = function test() {};

  if (test.name === undefined) {
    Object.defineProperty(Function.prototype, 'name', {
      get: function get() {
        var name = this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];

        Object.defineProperty(this, 'name', { value: name });
        return name;
      }
    });
  }
}

if (typeof FEATURE_NO_IE === 'undefined') {
  if (!('classList' in document.createElement('_')) || document.createElementNS && !('classList' in document.createElementNS('http://www.w3.org/2000/svg', 'g'))) {
    var protoProp = 'prototype';
    var strTrim = String.prototype.trim;
    var arrIndexOf = Array.prototype.indexOf;
    var emptyArray = [];

    var DOMEx = function DOMEx(type, message) {
      this.name = type;
      this.code = DOMException[type];
      this.message = message;
    };

    var checkTokenAndGetIndex = function checkTokenAndGetIndex(classList, token) {
      if (token === '') {
        throw new DOMEx('SYNTAX_ERR', 'An invalid or illegal string was specified');
      }

      if (/\s/.test(token)) {
        throw new DOMEx('INVALID_CHARACTER_ERR', 'String contains an invalid character');
      }

      return arrIndexOf.call(classList, token);
    };

    var ClassList = function ClassList(elem) {
      var trimmedClasses = strTrim.call(elem.getAttribute('class') || '');
      var classes = trimmedClasses ? trimmedClasses.split(/\s+/) : emptyArray;

      for (var i = 0, ii = classes.length; i < ii; ++i) {
        this.push(classes[i]);
      }

      this._updateClassName = function () {
        elem.setAttribute('class', this.toString());
      };
    };

    var classListProto = ClassList[protoProp] = [];

    DOMEx[protoProp] = Error[protoProp];

    classListProto.item = function (i) {
      return this[i] || null;
    };

    classListProto.contains = function (token) {
      token += '';
      return checkTokenAndGetIndex(this, token) !== -1;
    };

    classListProto.add = function () {
      var tokens = arguments;
      var i = 0;
      var ii = tokens.length;
      var token = void 0;
      var updated = false;

      do {
        token = tokens[i] + '';
        if (checkTokenAndGetIndex(this, token) === -1) {
          this.push(token);
          updated = true;
        }
      } while (++i < ii);

      if (updated) {
        this._updateClassName();
      }
    };

    classListProto.remove = function () {
      var tokens = arguments;
      var i = 0;
      var ii = tokens.length;
      var token = void 0;
      var updated = false;
      var index = void 0;

      do {
        token = tokens[i] + '';
        index = checkTokenAndGetIndex(this, token);
        while (index !== -1) {
          this.splice(index, 1);
          updated = true;
          index = checkTokenAndGetIndex(this, token);
        }
      } while (++i < ii);

      if (updated) {
        this._updateClassName();
      }
    };

    classListProto.toggle = function (token, force) {
      token += '';

      var result = this.contains(token);
      var method = result ? force !== true && 'remove' : force !== false && 'add';

      if (method) {
        this[method](token);
      }

      if (force === true || force === false) {
        return force;
      }

      return !result;
    };

    classListProto.toString = function () {
      return this.join(' ');
    };

    Object.defineProperty(Element.prototype, 'classList', {
      get: function get() {
        return new ClassList(this);
      },
      enumerable: true,
      configurable: true
    });
  } else {
    var testElement = document.createElement('_');
    testElement.classList.add('c1', 'c2');

    if (!testElement.classList.contains('c2')) {
      var createMethod = function createMethod(method) {
        var original = DOMTokenList.prototype[method];

        DOMTokenList.prototype[method] = function (token) {
          for (var i = 0, ii = arguments.length; i < ii; ++i) {
            token = arguments[i];
            original.call(this, token);
          }
        };
      };

      createMethod('add');
      createMethod('remove');
    }

    testElement.classList.toggle('c3', false);

    if (testElement.classList.contains('c3')) {
      var _toggle = DOMTokenList.prototype.toggle;

      DOMTokenList.prototype.toggle = function (token, force) {
        if (1 in arguments && !this.contains(token) === !force) {
          return force;
        }

        return _toggle.call(this, token);
      };
    }

    testElement = null;
  }
}

if (typeof FEATURE_NO_IE === 'undefined') {
  var _filterEntries = function _filterEntries(key, value) {
    var i = 0,
        n = _entries.length,
        result = [];
    for (; i < n; i++) {
      if (_entries[i][key] == value) {
        result.push(_entries[i]);
      }
    }
    return result;
  };

  var _clearEntries = function _clearEntries(type, name) {
    var i = _entries.length,
        entry;
    while (i--) {
      entry = _entries[i];
      if (entry.entryType == type && (name === void 0 || entry.name == name)) {
        _entries.splice(i, 1);
      }
    }
  };

  // @license http://opensource.org/licenses/MIT
  if ('performance' in window === false) {
    window.performance = {};
  }

  if ('now' in window.performance === false) {
    var nowOffset = Date.now();

    if (performance.timing && performance.timing.navigationStart) {
      nowOffset = performance.timing.navigationStart;
    }

    window.performance.now = function now() {
      return Date.now() - nowOffset;
    };
  }

  var startOffset = Date.now ? Date.now() : +new Date();
  var _entries = [];
  var _marksIndex = {};

  ;

  if (!window.performance.mark) {
    window.performance.mark = window.performance.webkitMark || function (name) {
      var mark = {
        name: name,
        entryType: "mark",
        startTime: window.performance.now(),
        duration: 0
      };

      _entries.push(mark);
      _marksIndex[name] = mark;
    };
  }

  if (!window.performance.measure) {
    window.performance.measure = window.performance.webkitMeasure || function (name, startMark, endMark) {
      startMark = _marksIndex[startMark].startTime;
      endMark = _marksIndex[endMark].startTime;

      _entries.push({
        name: name,
        entryType: "measure",
        startTime: startMark,
        duration: endMark - startMark
      });
    };
  }

  if (!window.performance.getEntriesByType) {
    window.performance.getEntriesByType = window.performance.webkitGetEntriesByType || function (type) {
      return _filterEntries("entryType", type);
    };
  }

  if (!window.performance.getEntriesByName) {
    window.performance.getEntriesByName = window.performance.webkitGetEntriesByName || function (name) {
      return _filterEntries("name", name);
    };
  }

  if (!window.performance.clearMarks) {
    window.performance.clearMarks = window.performance.webkitClearMarks || function (name) {
      _clearEntries("mark", name);
    };
  }

  if (!window.performance.clearMeasures) {
    window.performance.clearMeasures = window.performance.webkitClearMeasures || function (name) {
      _clearEntries("measure", name);
    };
  }

  _PLATFORM.performance = window.performance;
}

if (typeof FEATURE_NO_IE === 'undefined') {
  var con = window.console = window.console || {};
  var nop = function nop() {};

  if (!con.memory) con.memory = {};
  ('assert,clear,count,debug,dir,dirxml,error,exception,group,' + 'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' + 'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(',').forEach(function (m) {
    if (!con[m]) con[m] = nop;
  });

  if (_typeof(con.log) === 'object') {
    'log,info,warn,error,assert,dir,clear,profile,profileEnd'.split(',').forEach(function (method) {
      console[method] = this.bind(console[method], console);
    }, Function.prototype.call);
  }
}

if (typeof FEATURE_NO_IE === 'undefined') {
  if (!window.CustomEvent || typeof window.CustomEvent !== 'function') {
    var _CustomEvent = function _CustomEvent(event, params) {
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };

      var evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    };

    _CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = _CustomEvent;
  }
}

if (Element && !Element.prototype.matches) {
  var proto = Element.prototype;
  proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
}

var _FEATURE = exports._FEATURE = {
  shadowDOM: !!HTMLElement.prototype.attachShadow,
  scopedCSS: 'scoped' in document.createElement('style'),
  htmlTemplateElement: function () {
    var d = document.createElement('div');
    d.innerHTML = '<template></template>';
    return 'content' in d.children[0];
  }(),
  mutationObserver: !!(window.MutationObserver || window.WebKitMutationObserver),
  ensureHTMLTemplateElement: function ensureHTMLTemplateElement(t) {
    return t;
  }
};

if (typeof FEATURE_NO_IE === 'undefined') {
  var isSVGTemplate = function isSVGTemplate(el) {
    return el.tagName === 'template' && el.namespaceURI === 'http://www.w3.org/2000/svg';
  };

  var fixSVGTemplateElement = function fixSVGTemplateElement(el) {
    var template = el.ownerDocument.createElement('template');
    var attrs = el.attributes;
    var length = attrs.length;
    var attr = void 0;

    el.parentNode.insertBefore(template, el);

    while (length-- > 0) {
      attr = attrs[length];
      template.setAttribute(attr.name, attr.value);
      el.removeAttribute(attr.name);
    }

    el.parentNode.removeChild(el);

    return fixHTMLTemplateElement(template);
  };

  var fixHTMLTemplateElement = function fixHTMLTemplateElement(template) {
    var content = template.content = document.createDocumentFragment();
    var child = void 0;

    while (child = template.firstChild) {
      content.appendChild(child);
    }

    return template;
  };

  var fixHTMLTemplateElementRoot = function fixHTMLTemplateElementRoot(template) {
    var content = fixHTMLTemplateElement(template).content;
    var childTemplates = content.querySelectorAll('template');

    for (var i = 0, ii = childTemplates.length; i < ii; ++i) {
      var child = childTemplates[i];

      if (isSVGTemplate(child)) {
        fixSVGTemplateElement(child);
      } else {
        fixHTMLTemplateElement(child);
      }
    }

    return template;
  };

  if (!_FEATURE.htmlTemplateElement) {
    _FEATURE.ensureHTMLTemplateElement = fixHTMLTemplateElementRoot;
  }
}

var shadowPoly = window.ShadowDOMPolyfill || null;

var _DOM = exports._DOM = {
  Element: Element,
  NodeList: NodeList,
  SVGElement: SVGElement,
  boundary: 'aurelia-dom-boundary',
  addEventListener: function addEventListener(eventName, callback, capture) {
    document.addEventListener(eventName, callback, capture);
  },
  removeEventListener: function removeEventListener(eventName, callback, capture) {
    document.removeEventListener(eventName, callback, capture);
  },
  adoptNode: function adoptNode(node) {
    return document.adoptNode(node);
  },
  createAttribute: function createAttribute(name) {
    return document.createAttribute(name);
  },
  createElement: function createElement(tagName) {
    return document.createElement(tagName);
  },
  createTextNode: function createTextNode(text) {
    return document.createTextNode(text);
  },
  createComment: function createComment(text) {
    return document.createComment(text);
  },
  createDocumentFragment: function createDocumentFragment() {
    return document.createDocumentFragment();
  },
  createTemplateElement: function createTemplateElement() {
    var template = document.createElement('template');
    return _FEATURE.ensureHTMLTemplateElement(template);
  },
  createMutationObserver: function createMutationObserver(callback) {
    return new (window.MutationObserver || window.WebKitMutationObserver)(callback);
  },
  createCustomEvent: function createCustomEvent(eventType, options) {
    return new window.CustomEvent(eventType, options);
  },
  dispatchEvent: function dispatchEvent(evt) {
    document.dispatchEvent(evt);
  },
  getComputedStyle: function getComputedStyle(element) {
    return window.getComputedStyle(element);
  },
  getElementById: function getElementById(id) {
    return document.getElementById(id);
  },
  querySelector: function querySelector(query) {
    return document.querySelector(query);
  },
  querySelectorAll: function querySelectorAll(query) {
    return document.querySelectorAll(query);
  },
  nextElementSibling: function nextElementSibling(element) {
    if (element.nextElementSibling) {
      return element.nextElementSibling;
    }
    do {
      element = element.nextSibling;
    } while (element && element.nodeType !== 1);
    return element;
  },
  createTemplateFromMarkup: function createTemplateFromMarkup(markup) {
    var parser = document.createElement('div');
    parser.innerHTML = markup;

    var temp = parser.firstElementChild;
    if (!temp || temp.nodeName !== 'TEMPLATE') {
      throw new Error('Template markup must be wrapped in a <template> element e.g. <template> <!-- markup here --> </template>');
    }

    return _FEATURE.ensureHTMLTemplateElement(temp);
  },
  appendNode: function appendNode(newNode, parentNode) {
    (parentNode || document.body).appendChild(newNode);
  },
  replaceNode: function replaceNode(newNode, node, parentNode) {
    if (node.parentNode) {
      node.parentNode.replaceChild(newNode, node);
    } else if (shadowPoly !== null) {
      shadowPoly.unwrap(parentNode).replaceChild(shadowPoly.unwrap(newNode), shadowPoly.unwrap(node));
    } else {
      parentNode.replaceChild(newNode, node);
    }
  },
  removeNode: function removeNode(node, parentNode) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    } else if (parentNode) {
      if (shadowPoly !== null) {
        shadowPoly.unwrap(parentNode).removeChild(shadowPoly.unwrap(node));
      } else {
        parentNode.removeChild(node);
      }
    }
  },
  injectStyles: function injectStyles(styles, destination, prepend, id) {
    if (id) {
      var oldStyle = document.getElementById(id);
      if (oldStyle) {
        var isStyleTag = oldStyle.tagName.toLowerCase() === 'style';

        if (isStyleTag) {
          oldStyle.innerHTML = styles;
          return;
        }

        throw new Error('The provided id does not indicate a style tag.');
      }
    }

    var node = document.createElement('style');
    node.innerHTML = styles;
    node.type = 'text/css';

    if (id) {
      node.id = id;
    }

    destination = destination || document.head;

    if (prepend && destination.childNodes.length > 0) {
      destination.insertBefore(node, destination.childNodes[0]);
    } else {
      destination.appendChild(node);
    }

    return node;
  }
};

function initialize() {
  if (_aureliaPal.isInitialized) {
    return;
  }

  (0, _aureliaPal.initializePAL)(function (platform, feature, dom) {
    Object.assign(platform, _PLATFORM);
    Object.assign(feature, _FEATURE);
    Object.assign(dom, _DOM);

    Object.defineProperty(dom, 'title', {
      get: function get() {
        return document.title;
      },
      set: function set(value) {
        document.title = value;
      }
    });

    Object.defineProperty(dom, 'activeElement', {
      get: function get() {
        return document.activeElement;
      }
    });

    Object.defineProperty(platform, 'XMLHttpRequest', {
      get: function get() {
        return platform.global.XMLHttpRequest;
      }
    });
  });
}
});

define('aurelia-pal/dist/commonjs/aurelia-pal',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggregateError = AggregateError;
exports.initializePAL = initializePAL;
exports.reset = reset;
function AggregateError(message, innerError, skipIfAlreadyAggregate) {
  if (innerError) {
    if (innerError.innerError && skipIfAlreadyAggregate) {
      return innerError;
    }

    var separator = '\n------------------------------------------------\n';

    message += separator + 'Inner Error:\n';

    if (typeof innerError === 'string') {
      message += 'Message: ' + innerError;
    } else {
      if (innerError.message) {
        message += 'Message: ' + innerError.message;
      } else {
        message += 'Unknown Inner Error Type. Displaying Inner Error as JSON:\n ' + JSON.stringify(innerError, null, '  ');
      }

      if (innerError.stack) {
        message += '\nInner Error Stack:\n' + innerError.stack;
        message += '\nEnd Inner Error Stack';
      }
    }

    message += separator;
  }

  var e = new Error(message);
  if (innerError) {
    e.innerError = innerError;
  }

  return e;
}

var FEATURE = exports.FEATURE = {};

var PLATFORM = exports.PLATFORM = {
  noop: function noop() {},
  eachModule: function eachModule() {},
  moduleName: function (_moduleName) {
    function moduleName(_x) {
      return _moduleName.apply(this, arguments);
    }

    moduleName.toString = function () {
      return _moduleName.toString();
    };

    return moduleName;
  }(function (moduleName) {
    return moduleName;
  })
};

PLATFORM.global = function () {
  if (typeof self !== 'undefined') {
    return self;
  }

  if (typeof global !== 'undefined') {
    return global;
  }

  return new Function('return this')();
}();

var DOM = exports.DOM = {};
var isInitialized = exports.isInitialized = false;
function initializePAL(callback) {
  if (isInitialized) {
    return;
  }
  exports.isInitialized = isInitialized = true;
  if (typeof Object.getPropertyDescriptor !== 'function') {
    Object.getPropertyDescriptor = function (subject, name) {
      var pd = Object.getOwnPropertyDescriptor(subject, name);
      var proto = Object.getPrototypeOf(subject);
      while (typeof pd === 'undefined' && proto !== null) {
        pd = Object.getOwnPropertyDescriptor(proto, name);
        proto = Object.getPrototypeOf(proto);
      }
      return pd;
    };
  }

  callback(PLATFORM, FEATURE, DOM);
}
function reset() {
  exports.isInitialized = isInitialized = false;
}
});

define('aurelia-path/dist/commonjs/aurelia-path',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.relativeToFile = relativeToFile;
exports.join = join;
exports.buildQueryString = buildQueryString;
exports.parseQueryString = parseQueryString;

function trimDots(ary) {
  for (var i = 0; i < ary.length; ++i) {
    var part = ary[i];
    if (part === '.') {
      ary.splice(i, 1);
      i -= 1;
    } else if (part === '..') {
      if (i === 0 || i === 1 && ary[2] === '..' || ary[i - 1] === '..') {
        continue;
      } else if (i > 0) {
        ary.splice(i - 1, 2);
        i -= 2;
      }
    }
  }
}

function relativeToFile(name, file) {
  var fileParts = file && file.split('/');
  var nameParts = name.trim().split('/');

  if (nameParts[0].charAt(0) === '.' && fileParts) {
    var normalizedBaseParts = fileParts.slice(0, fileParts.length - 1);
    nameParts.unshift.apply(nameParts, normalizedBaseParts);
  }

  trimDots(nameParts);

  return nameParts.join('/');
}

function join(path1, path2) {
  if (!path1) {
    return path2;
  }

  if (!path2) {
    return path1;
  }

  var schemeMatch = path1.match(/^([^/]*?:)\//);
  var scheme = schemeMatch && schemeMatch.length > 0 ? schemeMatch[1] : '';
  path1 = path1.substr(scheme.length);

  var urlPrefix = void 0;
  if (path1.indexOf('///') === 0 && scheme === 'file:') {
    urlPrefix = '///';
  } else if (path1.indexOf('//') === 0) {
    urlPrefix = '//';
  } else if (path1.indexOf('/') === 0) {
    urlPrefix = '/';
  } else {
    urlPrefix = '';
  }

  var trailingSlash = path2.slice(-1) === '/' ? '/' : '';

  var url1 = path1.split('/');
  var url2 = path2.split('/');
  var url3 = [];

  for (var i = 0, ii = url1.length; i < ii; ++i) {
    if (url1[i] === '..') {
      url3.pop();
    } else if (url1[i] === '.' || url1[i] === '') {
      continue;
    } else {
      url3.push(url1[i]);
    }
  }

  for (var _i = 0, _ii = url2.length; _i < _ii; ++_i) {
    if (url2[_i] === '..') {
      url3.pop();
    } else if (url2[_i] === '.' || url2[_i] === '') {
      continue;
    } else {
      url3.push(url2[_i]);
    }
  }

  return scheme + urlPrefix + url3.join('/') + trailingSlash;
}

var encode = encodeURIComponent;
var encodeKey = function encodeKey(k) {
  return encode(k).replace('%24', '$');
};

function buildParam(key, value, traditional) {
  var result = [];
  if (value === null || value === undefined) {
    return result;
  }
  if (Array.isArray(value)) {
    for (var i = 0, l = value.length; i < l; i++) {
      if (traditional) {
        result.push(encodeKey(key) + '=' + encode(value[i]));
      } else {
        var arrayKey = key + '[' + (_typeof(value[i]) === 'object' && value[i] !== null ? i : '') + ']';
        result = result.concat(buildParam(arrayKey, value[i]));
      }
    }
  } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && !traditional) {
    for (var propertyName in value) {
      result = result.concat(buildParam(key + '[' + propertyName + ']', value[propertyName]));
    }
  } else {
    result.push(encodeKey(key) + '=' + encode(value));
  }
  return result;
}

function buildQueryString(params, traditional) {
  var pairs = [];
  var keys = Object.keys(params || {}).sort();
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    pairs = pairs.concat(buildParam(key, params[key], traditional));
  }

  if (pairs.length === 0) {
    return '';
  }

  return pairs.join('&');
}

function processScalarParam(existedParam, value) {
  if (Array.isArray(existedParam)) {
    existedParam.push(value);
    return existedParam;
  }
  if (existedParam !== undefined) {
    return [existedParam, value];
  }

  return value;
}

function parseComplexParam(queryParams, keys, value) {
  var currentParams = queryParams;
  var keysLastIndex = keys.length - 1;
  for (var j = 0; j <= keysLastIndex; j++) {
    var key = keys[j] === '' ? currentParams.length : keys[j];
    if (j < keysLastIndex) {
      var prevValue = !currentParams[key] || _typeof(currentParams[key]) === 'object' ? currentParams[key] : [currentParams[key]];
      currentParams = currentParams[key] = prevValue || (isNaN(keys[j + 1]) ? {} : []);
    } else {
      currentParams = currentParams[key] = value;
    }
  }
}

function parseQueryString(queryString) {
  var queryParams = {};
  if (!queryString || typeof queryString !== 'string') {
    return queryParams;
  }

  var query = queryString;
  if (query.charAt(0) === '?') {
    query = query.substr(1);
  }

  var pairs = query.replace(/\+/g, ' ').split('&');
  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i].split('=');
    var key = decodeURIComponent(pair[0]);
    if (!key) {
      continue;
    }

    var keys = key.split('][');
    var keysLastIndex = keys.length - 1;

    if (/\[/.test(keys[0]) && /\]$/.test(keys[keysLastIndex])) {
      keys[keysLastIndex] = keys[keysLastIndex].replace(/\]$/, '');
      keys = keys.shift().split('[').concat(keys);
      keysLastIndex = keys.length - 1;
    } else {
      keysLastIndex = 0;
    }

    if (pair.length >= 2) {
      var value = pair[1] ? decodeURIComponent(pair[1]) : '';
      if (keysLastIndex) {
        parseComplexParam(queryParams, keys, value);
      } else {
        queryParams[key] = processScalarParam(queryParams[key], value);
      }
    } else {
      queryParams[key] = true;
    }
  }
  return queryParams;
}
});

define('aurelia-polyfills/dist/commonjs/aurelia-polyfills',['require','exports','module','aurelia-pal'],function (require, exports, module) {'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _aureliaPal = require('aurelia-pal');

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  (function (Object, GOPS) {
    'use strict';

    if (GOPS in Object) return;

    var setDescriptor,
        G = _aureliaPal.PLATFORM.global,
        id = 0,
        random = '' + Math.random(),
        prefix = '__\x01symbol:',
        prefixLength = prefix.length,
        internalSymbol = '__\x01symbol@@' + random,
        DP = 'defineProperty',
        DPies = 'defineProperties',
        GOPN = 'getOwnPropertyNames',
        GOPD = 'getOwnPropertyDescriptor',
        PIE = 'propertyIsEnumerable',
        gOPN = Object[GOPN],
        gOPD = Object[GOPD],
        create = Object.create,
        keys = Object.keys,
        defineProperty = Object[DP],
        $defineProperties = Object[DPies],
        descriptor = gOPD(Object, GOPN),
        ObjectProto = Object.prototype,
        hOP = ObjectProto.hasOwnProperty,
        pIE = ObjectProto[PIE],
        toString = ObjectProto.toString,
        indexOf = Array.prototype.indexOf || function (v) {
      for (var i = this.length; i-- && this[i] !== v;) {}
      return i;
    },
        addInternalIfNeeded = function addInternalIfNeeded(o, uid, enumerable) {
      if (!hOP.call(o, internalSymbol)) {
        defineProperty(o, internalSymbol, {
          enumerable: false,
          configurable: false,
          writable: false,
          value: {}
        });
      }
      o[internalSymbol]['@@' + uid] = enumerable;
    },
        createWithSymbols = function createWithSymbols(proto, descriptors) {
      var self = create(proto);
      if (descriptors !== null && (typeof descriptors === 'undefined' ? 'undefined' : _typeof(descriptors)) === 'object') {
        gOPN(descriptors).forEach(function (key) {
          if (propertyIsEnumerable.call(descriptors, key)) {
            $defineProperty(self, key, descriptors[key]);
          }
        });
      }
      return self;
    },
        copyAsNonEnumerable = function copyAsNonEnumerable(descriptor) {
      var newDescriptor = create(descriptor);
      newDescriptor.enumerable = false;
      return newDescriptor;
    },
        get = function get() {},
        onlyNonSymbols = function onlyNonSymbols(name) {
      return name != internalSymbol && !hOP.call(source, name);
    },
        onlySymbols = function onlySymbols(name) {
      return name != internalSymbol && hOP.call(source, name);
    },
        propertyIsEnumerable = function propertyIsEnumerable(key) {
      var uid = '' + key;
      return onlySymbols(uid) ? hOP.call(this, uid) && this[internalSymbol] && this[internalSymbol]['@@' + uid] : pIE.call(this, key);
    },
        setAndGetSymbol = function setAndGetSymbol(uid) {
      var descriptor = {
        enumerable: false,
        configurable: true,
        get: get,
        set: function set(value) {
          setDescriptor(this, uid, {
            enumerable: false,
            configurable: true,
            writable: true,
            value: value
          });
          addInternalIfNeeded(this, uid, true);
        }
      };
      defineProperty(ObjectProto, uid, descriptor);
      return source[uid] = defineProperty(Object(uid), 'constructor', sourceConstructor);
    },
        _Symbol = function _Symbol2(description) {
      if (this && this !== G) {
        throw new TypeError('Symbol is not a constructor');
      }
      return setAndGetSymbol(prefix.concat(description || '', random, ++id));
    },
        source = create(null),
        sourceConstructor = { value: _Symbol },
        sourceMap = function sourceMap(uid) {
      return source[uid];
    },
        $defineProperty = function defineProp(o, key, descriptor) {
      var uid = '' + key;
      if (onlySymbols(uid)) {
        setDescriptor(o, uid, descriptor.enumerable ? copyAsNonEnumerable(descriptor) : descriptor);
        addInternalIfNeeded(o, uid, !!descriptor.enumerable);
      } else {
        defineProperty(o, key, descriptor);
      }
      return o;
    },
        $getOwnPropertySymbols = function getOwnPropertySymbols(o) {
      var cof = toString.call(o);
      o = cof === '[object String]' ? o.split('') : Object(o);
      return gOPN(o).filter(onlySymbols).map(sourceMap);
    };

    descriptor.value = $defineProperty;
    defineProperty(Object, DP, descriptor);

    descriptor.value = $getOwnPropertySymbols;
    defineProperty(Object, GOPS, descriptor);

    var cachedWindowNames = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' ? Object.getOwnPropertyNames(window) : [];
    var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
    descriptor.value = function getOwnPropertyNames(o) {
      if (toString.call(o) === '[object Window]') {
        try {
          return originalObjectGetOwnPropertyNames(o);
        } catch (e) {
          return [].concat([], cachedWindowNames);
        }
      }
      return gOPN(o).filter(onlyNonSymbols);
    };
    defineProperty(Object, GOPN, descriptor);

    descriptor.value = function defineProperties(o, descriptors) {
      var symbols = $getOwnPropertySymbols(descriptors);
      if (symbols.length) {
        keys(descriptors).concat(symbols).forEach(function (uid) {
          if (propertyIsEnumerable.call(descriptors, uid)) {
            $defineProperty(o, uid, descriptors[uid]);
          }
        });
      } else {
        $defineProperties(o, descriptors);
      }
      return o;
    };
    defineProperty(Object, DPies, descriptor);

    descriptor.value = propertyIsEnumerable;
    defineProperty(ObjectProto, PIE, descriptor);

    descriptor.value = _Symbol;
    defineProperty(G, 'Symbol', descriptor);

    descriptor.value = function (key) {
      var uid = prefix.concat(prefix, key, random);
      return uid in ObjectProto ? source[uid] : setAndGetSymbol(uid);
    };
    defineProperty(_Symbol, 'for', descriptor);

    descriptor.value = function (symbol) {
      return hOP.call(source, symbol) ? symbol.slice(prefixLength * 2, -random.length) : void 0;
    };
    defineProperty(_Symbol, 'keyFor', descriptor);

    descriptor.value = function getOwnPropertyDescriptor(o, key) {
      var descriptor = gOPD(o, key);
      if (descriptor && onlySymbols(key)) {
        descriptor.enumerable = propertyIsEnumerable.call(o, key);
      }
      return descriptor;
    };
    defineProperty(Object, GOPD, descriptor);

    descriptor.value = function (proto, descriptors) {
      return arguments.length === 1 ? create(proto) : createWithSymbols(proto, descriptors);
    };
    defineProperty(Object, 'create', descriptor);

    descriptor.value = function () {
      var str = toString.call(this);
      return str === '[object String]' && onlySymbols(this) ? '[object Symbol]' : str;
    };
    defineProperty(ObjectProto, 'toString', descriptor);

    try {
      setDescriptor = create(defineProperty({}, prefix, {
        get: function get() {
          return defineProperty(this, prefix, { value: false })[prefix];
        }
      }))[prefix] || defineProperty;
    } catch (o_O) {
      setDescriptor = function setDescriptor(o, key, descriptor) {
        var protoDescriptor = gOPD(ObjectProto, key);
        delete ObjectProto[key];
        defineProperty(o, key, descriptor);
        defineProperty(ObjectProto, key, protoDescriptor);
      };
    }
  })(Object, 'getOwnPropertySymbols');

  (function (O, S) {
    var dP = O.defineProperty,
        ObjectProto = O.prototype,
        toString = ObjectProto.toString,
        toStringTag = 'toStringTag',
        descriptor;
    ['iterator', 'match', 'replace', 'search', 'split', 'hasInstance', 'isConcatSpreadable', 'unscopables', 'species', 'toPrimitive', toStringTag].forEach(function (name) {
      if (!(name in Symbol)) {
        dP(Symbol, name, { value: Symbol(name) });
        switch (name) {
          case toStringTag:
            descriptor = O.getOwnPropertyDescriptor(ObjectProto, 'toString');
            descriptor.value = function () {
              var str = toString.call(this),
                  tst = typeof this === 'undefined' || this === null ? undefined : this[Symbol.toStringTag];
              return typeof tst === 'undefined' ? str : '[object ' + tst + ']';
            };
            dP(ObjectProto, 'toString', descriptor);
            break;
        }
      }
    });
  })(Object, Symbol);

  (function (Si, AP, SP) {

    function returnThis() {
      return this;
    }

    if (!AP[Si]) AP[Si] = function () {
      var i = 0,
          self = this,
          iterator = {
        next: function next() {
          var done = self.length <= i;
          return done ? { done: done } : { done: done, value: self[i++] };
        }
      };
      iterator[Si] = returnThis;
      return iterator;
    };

    if (!SP[Si]) SP[Si] = function () {
      var fromCodePoint = String.fromCodePoint,
          self = this,
          i = 0,
          length = self.length,
          iterator = {
        next: function next() {
          var done = length <= i,
              c = done ? '' : fromCodePoint(self.codePointAt(i));
          i += c.length;
          return done ? { done: done } : { done: done, value: c };
        }
      };
      iterator[Si] = returnThis;
      return iterator;
    };
  })(Symbol.iterator, Array.prototype, String.prototype);
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  Number.isNaN = Number.isNaN || function (value) {
    return value !== value;
  };

  Number.isFinite = Number.isFinite || function (value) {
    return typeof value === "number" && isFinite(value);
  };
}

if (!String.prototype.endsWith || function () {
  try {
    return !"ab".endsWith("a", 1);
  } catch (e) {
    return true;
  }
}()) {
  String.prototype.endsWith = function (searchString, position) {
    var subjectString = this.toString();
    if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
      position = subjectString.length;
    }
    position -= searchString.length;
    var lastIndex = subjectString.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
}

if (!String.prototype.startsWith || function () {
  try {
    return !"ab".startsWith("b", 1);
  } catch (e) {
    return true;
  }
}()) {
  String.prototype.startsWith = function (searchString, position) {
    position = position || 0;
    return this.substr(position, searchString.length) === searchString;
  };
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  if (!Array.from) {
    Array.from = function () {
      var toInteger = function toInteger(it) {
        return isNaN(it = +it) ? 0 : (it > 0 ? Math.floor : Math.ceil)(it);
      };
      var toLength = function toLength(it) {
        return it > 0 ? Math.min(toInteger(it), 0x1fffffffffffff) : 0;
      };
      var iterCall = function iterCall(iter, fn, val, index) {
        try {
          return fn(val, index);
        } catch (E) {
          if (typeof iter.return == 'function') iter.return();
          throw E;
        }
      };

      return function from(arrayLike) {
        var O = Object(arrayLike),
            C = typeof this == 'function' ? this : Array,
            aLen = arguments.length,
            mapfn = aLen > 1 ? arguments[1] : undefined,
            mapping = mapfn !== undefined,
            index = 0,
            iterFn = O[Symbol.iterator],
            length,
            result,
            step,
            iterator;
        if (mapping) mapfn = mapfn.bind(aLen > 2 ? arguments[2] : undefined);
        if (iterFn != undefined && !Array.isArray(arrayLike)) {
          for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
            result[index] = mapping ? iterCall(iterator, mapfn, step.value, index) : step.value;
          }
        } else {
          length = toLength(O.length);
          for (result = new C(length); length > index; index++) {
            result[index] = mapping ? mapfn(O[index], index) : O[index];
          }
        }
        result.length = index;
        return result;
      };
    }();
  }

  if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: function value(predicate) {
        if (this === null) {
          throw new TypeError('Array.prototype.find called on null or undefined');
        }
        if (typeof predicate !== 'function') {
          throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
          value = list[i];
          if (predicate.call(thisArg, value, i, list)) {
            return value;
          }
        }
        return undefined;
      }
    });
  }

  if (!Array.prototype.findIndex) {
    Object.defineProperty(Array.prototype, 'findIndex', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: function value(predicate) {
        if (this === null) {
          throw new TypeError('Array.prototype.findIndex called on null or undefined');
        }
        if (typeof predicate !== 'function') {
          throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
          value = list[i];
          if (predicate.call(thisArg, value, i, list)) {
            return i;
          }
        }
        return -1;
      }
    });
  }
}

if (typeof FEATURE_NO_ES2016 === 'undefined' && !Array.prototype.includes) {
  Object.defineProperty(Array.prototype, 'includes', {
    configurable: true,
    writable: true,
    enumerable: false,
    value: function value(searchElement) {
      var O = Object(this);
      var len = parseInt(O.length) || 0;
      if (len === 0) {
        return false;
      }
      var n = parseInt(arguments[1]) || 0;
      var k;
      if (n >= 0) {
        k = n;
      } else {
        k = len + n;
        if (k < 0) {
          k = 0;
        }
      }
      var currentElement;
      while (k < len) {
        currentElement = O[k];
        if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
          return true;
        }
        k++;
      }
      return false;
    }
  });
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  (function () {
    var needsFix = false;

    try {
      var s = Object.keys('a');
      needsFix = s.length !== 1 || s[0] !== '0';
    } catch (e) {
      needsFix = true;
    }

    if (needsFix) {
      Object.keys = function () {
        var hasOwnProperty = Object.prototype.hasOwnProperty,
            hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),
            dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
            dontEnumsLength = dontEnums.length;

        return function (obj) {
          if (obj === undefined || obj === null) {
            throw TypeError('Cannot convert undefined or null to object');
          }

          obj = Object(obj);

          var result = [],
              prop,
              i;

          for (prop in obj) {
            if (hasOwnProperty.call(obj, prop)) {
              result.push(prop);
            }
          }

          if (hasDontEnumBug) {
            for (i = 0; i < dontEnumsLength; i++) {
              if (hasOwnProperty.call(obj, dontEnums[i])) {
                result.push(dontEnums[i]);
              }
            }
          }

          return result;
        };
      }();
    }
  })();

  (function (O) {
    if ('assign' in O) {
      return;
    }

    O.defineProperty(O, 'assign', {
      configurable: true,
      writable: true,
      value: function () {
        var gOPS = O.getOwnPropertySymbols,
            pIE = O.propertyIsEnumerable,
            filterOS = gOPS ? function (self) {
          return gOPS(self).filter(pIE, self);
        } : function () {
          return Array.prototype;
        };

        return function assign(where) {
          if (gOPS && !(where instanceof O)) {
            console.warn('problematic Symbols', where);
          }

          function set(keyOrSymbol) {
            where[keyOrSymbol] = arg[keyOrSymbol];
          }

          for (var i = 1, ii = arguments.length; i < ii; ++i) {
            var arg = arguments[i];

            if (arg === null || arg === undefined) {
              continue;
            }

            O.keys(arg).concat(filterOS(arg)).forEach(set);
          }

          return where;
        };
      }()
    });
  })(Object);

  if (!Object.is) {
    Object.is = function (x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    };
  }
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  (function (global) {
    var i;

    var defineProperty = Object.defineProperty,
        is = function is(a, b) {
      return a === b || a !== a && b !== b;
    };

    if (typeof WeakMap == 'undefined') {
      global.WeakMap = createCollection({
        'delete': sharedDelete,

        clear: sharedClear,

        get: sharedGet,

        has: mapHas,

        set: sharedSet
      }, true);
    }

    if (typeof Map == 'undefined' || typeof new Map().values !== 'function' || !new Map().values().next) {
      var _createCollection;

      global.Map = createCollection((_createCollection = {
        'delete': sharedDelete,

        has: mapHas,

        get: sharedGet,

        set: sharedSet,

        keys: sharedKeys,

        values: sharedValues,

        entries: mapEntries,

        forEach: sharedForEach,

        clear: sharedClear
      }, _createCollection[Symbol.iterator] = mapEntries, _createCollection));
    }

    if (typeof Set == 'undefined' || typeof new Set().values !== 'function' || !new Set().values().next) {
      var _createCollection2;

      global.Set = createCollection((_createCollection2 = {
        has: setHas,

        add: sharedAdd,

        'delete': sharedDelete,

        clear: sharedClear,

        keys: sharedValues,
        values: sharedValues,

        entries: setEntries,

        forEach: sharedForEach
      }, _createCollection2[Symbol.iterator] = sharedValues, _createCollection2));
    }

    if (typeof WeakSet == 'undefined') {
      global.WeakSet = createCollection({
        'delete': sharedDelete,

        add: sharedAdd,

        clear: sharedClear,

        has: setHas
      }, true);
    }

    function createCollection(proto, objectOnly) {
      function Collection(a) {
        if (!this || this.constructor !== Collection) return new Collection(a);
        this._keys = [];
        this._values = [];
        this._itp = [];
        this.objectOnly = objectOnly;

        if (a) init.call(this, a);
      }

      if (!objectOnly) {
        defineProperty(proto, 'size', {
          get: sharedSize
        });
      }

      proto.constructor = Collection;
      Collection.prototype = proto;

      return Collection;
    }

    function init(a) {
      var i;

      if (this.add) a.forEach(this.add, this);else a.forEach(function (a) {
          this.set(a[0], a[1]);
        }, this);
    }

    function sharedDelete(key) {
      if (this.has(key)) {
        this._keys.splice(i, 1);
        this._values.splice(i, 1);

        this._itp.forEach(function (p) {
          if (i < p[0]) p[0]--;
        });
      }

      return -1 < i;
    };

    function sharedGet(key) {
      return this.has(key) ? this._values[i] : undefined;
    }

    function has(list, key) {
      if (this.objectOnly && key !== Object(key)) throw new TypeError("Invalid value used as weak collection key");

      if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} else i = list.indexOf(key);
      return -1 < i;
    }

    function setHas(value) {
      return has.call(this, this._values, value);
    }

    function mapHas(value) {
      return has.call(this, this._keys, value);
    }

    function sharedSet(key, value) {
      this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;
      return this;
    }

    function sharedAdd(value) {
      if (!this.has(value)) this._values.push(value);
      return this;
    }

    function sharedClear() {
      (this._keys || 0).length = this._values.length = 0;
    }

    function sharedKeys() {
      return sharedIterator(this._itp, this._keys);
    }

    function sharedValues() {
      return sharedIterator(this._itp, this._values);
    }

    function mapEntries() {
      return sharedIterator(this._itp, this._keys, this._values);
    }

    function setEntries() {
      return sharedIterator(this._itp, this._values, this._values);
    }

    function sharedIterator(itp, array, array2) {
      var _ref;

      var p = [0],
          done = false;
      itp.push(p);
      return _ref = {}, _ref[Symbol.iterator] = function () {
        return this;
      }, _ref.next = function next() {
        var v,
            k = p[0];
        if (!done && k < array.length) {
          v = array2 ? [array[k], array2[k]] : array[k];
          p[0]++;
        } else {
          done = true;
          itp.splice(itp.indexOf(p), 1);
        }
        return { done: done, value: v };
      }, _ref;
    }

    function sharedSize() {
      return this._values.length;
    }

    function sharedForEach(callback, context) {
      var it = this.entries();
      for (;;) {
        var r = it.next();
        if (r.done) break;
        callback.call(context, r.value[1], r.value[0], this);
      }
    }
  })(_aureliaPal.PLATFORM.global);
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {
  (function () {

    var bind = Function.prototype.bind;

    if (typeof _aureliaPal.PLATFORM.global.Reflect === 'undefined') {
      _aureliaPal.PLATFORM.global.Reflect = {};
    }

    if (typeof Reflect.defineProperty !== 'function') {
      Reflect.defineProperty = function (target, propertyKey, descriptor) {
        if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' ? target === null : typeof target !== 'function') {
          throw new TypeError('Reflect.defineProperty called on non-object');
        }
        try {
          Object.defineProperty(target, propertyKey, descriptor);
          return true;
        } catch (e) {
          return false;
        }
      };
    }

    if (typeof Reflect.construct !== 'function') {
      Reflect.construct = function (Target, args) {
        if (args) {
          switch (args.length) {
            case 0:
              return new Target();
            case 1:
              return new Target(args[0]);
            case 2:
              return new Target(args[0], args[1]);
            case 3:
              return new Target(args[0], args[1], args[2]);
            case 4:
              return new Target(args[0], args[1], args[2], args[3]);
          }
        }

        var a = [null];
        a.push.apply(a, args);
        return new (bind.apply(Target, a))();
      };
    }

    if (typeof Reflect.ownKeys !== 'function') {
      Reflect.ownKeys = function (o) {
        return Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o));
      };
    }
  })();
}

if (typeof FEATURE_NO_ESNEXT === 'undefined') {
  (function () {

    var emptyMetadata = Object.freeze({});
    var metadataContainerKey = '__metadata__';

    if (typeof Reflect.getOwnMetadata !== 'function') {
      Reflect.getOwnMetadata = function (metadataKey, target, targetKey) {
        if (target.hasOwnProperty(metadataContainerKey)) {
          return (target[metadataContainerKey][targetKey] || emptyMetadata)[metadataKey];
        }
      };
    }

    if (typeof Reflect.defineMetadata !== 'function') {
      Reflect.defineMetadata = function (metadataKey, metadataValue, target, targetKey) {
        var metadataContainer = target.hasOwnProperty(metadataContainerKey) ? target[metadataContainerKey] : target[metadataContainerKey] = {};
        var targetContainer = metadataContainer[targetKey] || (metadataContainer[targetKey] = {});
        targetContainer[metadataKey] = metadataValue;
      };
    }

    if (typeof Reflect.metadata !== 'function') {
      Reflect.metadata = function (metadataKey, metadataValue) {
        return function (target, targetKey) {
          Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
        };
      };
    }
  })();
}
});

define('aurelia-route-recognizer/dist/commonjs/aurelia-route-recognizer',['require','exports','module','aurelia-path'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RouteRecognizer = exports.EpsilonSegment = exports.StarSegment = exports.DynamicSegment = exports.StaticSegment = exports.State = undefined;

var _aureliaPath = require('aurelia-path');



var State = exports.State = function () {
  function State(charSpec) {
    

    this.charSpec = charSpec;
    this.nextStates = [];
  }

  State.prototype.get = function get(charSpec) {
    for (var _iterator = this.nextStates, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var child = _ref;

      var isEqual = child.charSpec.validChars === charSpec.validChars && child.charSpec.invalidChars === charSpec.invalidChars;

      if (isEqual) {
        return child;
      }
    }

    return undefined;
  };

  State.prototype.put = function put(charSpec) {
    var state = this.get(charSpec);

    if (state) {
      return state;
    }

    state = new State(charSpec);

    this.nextStates.push(state);

    if (charSpec.repeat) {
      state.nextStates.push(state);
    }

    return state;
  };

  State.prototype.match = function match(ch) {
    var nextStates = this.nextStates;
    var results = [];

    for (var i = 0, l = nextStates.length; i < l; i++) {
      var child = nextStates[i];
      var charSpec = child.charSpec;

      if (charSpec.validChars !== undefined) {
        if (charSpec.validChars.indexOf(ch) !== -1) {
          results.push(child);
        }
      } else if (charSpec.invalidChars !== undefined) {
        if (charSpec.invalidChars.indexOf(ch) === -1) {
          results.push(child);
        }
      }
    }

    return results;
  };

  return State;
}();

var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];

var escapeRegex = new RegExp('(\\' + specials.join('|\\') + ')', 'g');

var StaticSegment = exports.StaticSegment = function () {
  function StaticSegment(string, caseSensitive) {
    

    this.string = string;
    this.caseSensitive = caseSensitive;
  }

  StaticSegment.prototype.eachChar = function eachChar(callback) {
    var s = this.string;
    for (var i = 0, ii = s.length; i < ii; ++i) {
      var ch = s[i];
      callback({ validChars: this.caseSensitive ? ch : ch.toUpperCase() + ch.toLowerCase() });
    }
  };

  StaticSegment.prototype.regex = function regex() {
    return this.string.replace(escapeRegex, '\\$1');
  };

  StaticSegment.prototype.generate = function generate() {
    return this.string;
  };

  return StaticSegment;
}();

var DynamicSegment = exports.DynamicSegment = function () {
  function DynamicSegment(name, optional) {
    

    this.name = name;
    this.optional = optional;
  }

  DynamicSegment.prototype.eachChar = function eachChar(callback) {
    callback({ invalidChars: '/', repeat: true });
  };

  DynamicSegment.prototype.regex = function regex() {
    return this.optional ? '([^/]+)?' : '([^/]+)';
  };

  DynamicSegment.prototype.generate = function generate(params, consumed) {
    consumed[this.name] = true;
    return params[this.name];
  };

  return DynamicSegment;
}();

var StarSegment = exports.StarSegment = function () {
  function StarSegment(name) {
    

    this.name = name;
  }

  StarSegment.prototype.eachChar = function eachChar(callback) {
    callback({ invalidChars: '', repeat: true });
  };

  StarSegment.prototype.regex = function regex() {
    return '(.+)';
  };

  StarSegment.prototype.generate = function generate(params, consumed) {
    consumed[this.name] = true;
    return params[this.name];
  };

  return StarSegment;
}();

var EpsilonSegment = exports.EpsilonSegment = function () {
  function EpsilonSegment() {
    
  }

  EpsilonSegment.prototype.eachChar = function eachChar() {};

  EpsilonSegment.prototype.regex = function regex() {
    return '';
  };

  EpsilonSegment.prototype.generate = function generate() {
    return '';
  };

  return EpsilonSegment;
}();

var RouteRecognizer = exports.RouteRecognizer = function () {
  function RouteRecognizer() {
    

    this.rootState = new State();
    this.names = {};
  }

  RouteRecognizer.prototype.add = function add(route) {
    var _this = this;

    if (Array.isArray(route)) {
      route.forEach(function (r) {
        return _this.add(r);
      });
      return undefined;
    }

    var currentState = this.rootState;
    var regex = '^';
    var types = { statics: 0, dynamics: 0, stars: 0 };
    var names = [];
    var routeName = route.handler.name;
    var isEmpty = true;
    var isAllOptional = true;
    var segments = parse(route.path, names, types, route.caseSensitive);

    for (var i = 0, ii = segments.length; i < ii; i++) {
      var segment = segments[i];
      if (segment instanceof EpsilonSegment) {
        continue;
      }

      isEmpty = false;
      isAllOptional = isAllOptional && segment.optional;

      currentState = addSegment(currentState, segment);
      regex += segment.optional ? '/?' : '/';
      regex += segment.regex();
    }

    if (isAllOptional) {
      if (isEmpty) {
        currentState = currentState.put({ validChars: '/' });
        regex += '/';
      } else {
        var finalState = this.rootState.put({ validChars: '/' });
        currentState.epsilon = [finalState];
        currentState = finalState;
      }
    }

    var handlers = [{ handler: route.handler, names: names }];

    if (routeName) {
      var routeNames = Array.isArray(routeName) ? routeName : [routeName];
      for (var _i2 = 0; _i2 < routeNames.length; _i2++) {
        this.names[routeNames[_i2]] = {
          segments: segments,
          handlers: handlers
        };
      }
    }

    currentState.handlers = handlers;
    currentState.regex = new RegExp(regex + '$', route.caseSensitive ? '' : 'i');
    currentState.types = types;

    return currentState;
  };

  RouteRecognizer.prototype.handlersFor = function handlersFor(name) {
    var route = this.names[name];
    if (!route) {
      throw new Error('There is no route named ' + name);
    }

    return [].concat(route.handlers);
  };

  RouteRecognizer.prototype.hasRoute = function hasRoute(name) {
    return !!this.names[name];
  };

  RouteRecognizer.prototype.generate = function generate(name, params) {
    var route = this.names[name];
    if (!route) {
      throw new Error('There is no route named ' + name);
    }

    var handler = route.handlers[0].handler;
    if (handler.generationUsesHref) {
      return handler.href;
    }

    var routeParams = Object.assign({}, params);
    var segments = route.segments;
    var consumed = {};
    var output = '';

    for (var i = 0, l = segments.length; i < l; i++) {
      var segment = segments[i];

      if (segment instanceof EpsilonSegment) {
        continue;
      }

      var segmentValue = segment.generate(routeParams, consumed);
      if (segmentValue === null || segmentValue === undefined) {
        if (!segment.optional) {
          throw new Error('A value is required for route parameter \'' + segment.name + '\' in route \'' + name + '\'.');
        }
      } else {
        output += '/';
        output += segmentValue;
      }
    }

    if (output.charAt(0) !== '/') {
      output = '/' + output;
    }

    for (var param in consumed) {
      delete routeParams[param];
    }

    var queryString = (0, _aureliaPath.buildQueryString)(routeParams);
    output += queryString ? '?' + queryString : '';

    return output;
  };

  RouteRecognizer.prototype.recognize = function recognize(path) {
    var states = [this.rootState];
    var queryParams = {};
    var isSlashDropped = false;
    var normalizedPath = path;

    var queryStart = normalizedPath.indexOf('?');
    if (queryStart !== -1) {
      var queryString = normalizedPath.substr(queryStart + 1, normalizedPath.length);
      normalizedPath = normalizedPath.substr(0, queryStart);
      queryParams = (0, _aureliaPath.parseQueryString)(queryString);
    }

    normalizedPath = decodeURI(normalizedPath);

    if (normalizedPath.charAt(0) !== '/') {
      normalizedPath = '/' + normalizedPath;
    }

    var pathLen = normalizedPath.length;
    if (pathLen > 1 && normalizedPath.charAt(pathLen - 1) === '/') {
      normalizedPath = normalizedPath.substr(0, pathLen - 1);
      isSlashDropped = true;
    }

    for (var i = 0, l = normalizedPath.length; i < l; i++) {
      states = recognizeChar(states, normalizedPath.charAt(i));
      if (!states.length) {
        break;
      }
    }

    var solutions = [];
    for (var _i3 = 0, _l = states.length; _i3 < _l; _i3++) {
      if (states[_i3].handlers) {
        solutions.push(states[_i3]);
      }
    }

    states = sortSolutions(solutions);

    var state = solutions[0];
    if (state && state.handlers) {
      if (isSlashDropped && state.regex.source.slice(-5) === '(.+)$') {
        normalizedPath = normalizedPath + '/';
      }

      return findHandler(state, normalizedPath, queryParams);
    }
  };

  return RouteRecognizer;
}();

var RecognizeResults = function RecognizeResults(queryParams) {
  

  this.splice = Array.prototype.splice;
  this.slice = Array.prototype.slice;
  this.push = Array.prototype.push;
  this.length = 0;
  this.queryParams = queryParams || {};
};

function parse(route, names, types, caseSensitive) {
  var normalizedRoute = route;
  if (route.charAt(0) === '/') {
    normalizedRoute = route.substr(1);
  }

  var results = [];

  var splitRoute = normalizedRoute.split('/');
  for (var i = 0, ii = splitRoute.length; i < ii; ++i) {
    var segment = splitRoute[i];

    var match = segment.match(/^:([^?]+)(\?)?$/);
    if (match) {
      var _match = match,
          _name = _match[1],
          optional = _match[2];

      if (_name.indexOf('=') !== -1) {
        throw new Error('Parameter ' + _name + ' in route ' + route + ' has a default value, which is not supported.');
      }
      results.push(new DynamicSegment(_name, !!optional));
      names.push(_name);
      types.dynamics++;
      continue;
    }

    match = segment.match(/^\*(.+)$/);
    if (match) {
      results.push(new StarSegment(match[1]));
      names.push(match[1]);
      types.stars++;
    } else if (segment === '') {
      results.push(new EpsilonSegment());
    } else {
      results.push(new StaticSegment(segment, caseSensitive));
      types.statics++;
    }
  }

  return results;
}

function sortSolutions(states) {
  return states.sort(function (a, b) {
    if (a.types.stars !== b.types.stars) {
      return a.types.stars - b.types.stars;
    }

    if (a.types.stars) {
      if (a.types.statics !== b.types.statics) {
        return b.types.statics - a.types.statics;
      }
      if (a.types.dynamics !== b.types.dynamics) {
        return b.types.dynamics - a.types.dynamics;
      }
    }

    if (a.types.dynamics !== b.types.dynamics) {
      return a.types.dynamics - b.types.dynamics;
    }

    if (a.types.statics !== b.types.statics) {
      return b.types.statics - a.types.statics;
    }

    return 0;
  });
}

function recognizeChar(states, ch) {
  var nextStates = [];

  for (var i = 0, l = states.length; i < l; i++) {
    var state = states[i];
    nextStates.push.apply(nextStates, state.match(ch));
  }

  var skippableStates = nextStates.filter(function (s) {
    return s.epsilon;
  });

  var _loop = function _loop() {
    var newStates = [];
    skippableStates.forEach(function (s) {
      nextStates.push.apply(nextStates, s.epsilon);
      newStates.push.apply(newStates, s.epsilon);
    });
    skippableStates = newStates.filter(function (s) {
      return s.epsilon;
    });
  };

  while (skippableStates.length > 0) {
    _loop();
  }

  return nextStates;
}

function findHandler(state, path, queryParams) {
  var handlers = state.handlers;
  var regex = state.regex;
  var captures = path.match(regex);
  var currentCapture = 1;
  var result = new RecognizeResults(queryParams);

  for (var i = 0, l = handlers.length; i < l; i++) {
    var _handler = handlers[i];
    var _names = _handler.names;
    var _params = {};

    for (var j = 0, m = _names.length; j < m; j++) {
      _params[_names[j]] = captures[currentCapture++];
    }

    result.push({ handler: _handler.handler, params: _params, isDynamic: !!_names.length });
  }

  return result;
}

function addSegment(currentState, segment) {
  var state = currentState.put({ validChars: '/' });
  segment.eachChar(function (ch) {
    state = state.put(ch);
  });

  if (segment.optional) {
    currentState.epsilon = currentState.epsilon || [];
    currentState.epsilon.push(state);
  }

  return state;
}
});

define('aurelia-router/dist/commonjs/aurelia-router',['require','exports','module','aurelia-logging','aurelia-route-recognizer','aurelia-dependency-injection','aurelia-history','aurelia-event-aggregator'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AppRouter = exports.PipelineProvider = exports.LoadRouteStep = exports.RouteLoader = exports.ActivateNextStep = exports.DeactivatePreviousStep = exports.CanActivateNextStep = exports.CanDeactivatePreviousStep = exports.Router = exports.BuildNavigationPlanStep = exports.activationStrategy = exports.RouterConfiguration = exports.RedirectToRoute = exports.Redirect = exports.NavModel = exports.NavigationInstruction = exports.CommitChangesStep = exports.Pipeline = exports.pipelineStatus = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports._normalizeAbsolutePath = _normalizeAbsolutePath;
exports._createRootedPath = _createRootedPath;
exports._resolveUrl = _resolveUrl;
exports.isNavigationCommand = isNavigationCommand;
exports._buildNavigationPlan = _buildNavigationPlan;

var _aureliaLogging = require('aurelia-logging');

var LogManager = _interopRequireWildcard(_aureliaLogging);

var _aureliaRouteRecognizer = require('aurelia-route-recognizer');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaHistory = require('aurelia-history');

var _aureliaEventAggregator = require('aurelia-event-aggregator');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



function _normalizeAbsolutePath(path, hasPushState) {
  var absolute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!hasPushState && path[0] !== '#') {
    path = '#' + path;
  }

  if (hasPushState && absolute) {
    path = path.substring(1, path.length);
  }

  return path;
}

function _createRootedPath(fragment, baseUrl, hasPushState, absolute) {
  if (isAbsoluteUrl.test(fragment)) {
    return fragment;
  }

  var path = '';

  if (baseUrl.length && baseUrl[0] !== '/') {
    path += '/';
  }

  path += baseUrl;

  if ((!path.length || path[path.length - 1] !== '/') && fragment[0] !== '/') {
    path += '/';
  }

  if (path.length && path[path.length - 1] === '/' && fragment[0] === '/') {
    path = path.substring(0, path.length - 1);
  }

  return _normalizeAbsolutePath(path + fragment, hasPushState, absolute);
}

function _resolveUrl(fragment, baseUrl, hasPushState) {
  if (isRootedPath.test(fragment)) {
    return _normalizeAbsolutePath(fragment, hasPushState);
  }

  return _createRootedPath(fragment, baseUrl, hasPushState);
}

var isRootedPath = /^#?\//;
var isAbsoluteUrl = /^([a-z][a-z0-9+\-.]*:)?\/\//i;

var pipelineStatus = exports.pipelineStatus = {
  completed: 'completed',
  canceled: 'canceled',
  rejected: 'rejected',
  running: 'running'
};

var Pipeline = exports.Pipeline = function () {
  function Pipeline() {
    

    this.steps = [];
  }

  Pipeline.prototype.addStep = function addStep(step) {
    var run = void 0;

    if (typeof step === 'function') {
      run = step;
    } else if (typeof step.getSteps === 'function') {
      var steps = step.getSteps();
      for (var i = 0, l = steps.length; i < l; i++) {
        this.addStep(steps[i]);
      }

      return this;
    } else {
      run = step.run.bind(step);
    }

    this.steps.push(run);

    return this;
  };

  Pipeline.prototype.run = function run(instruction) {
    var index = -1;
    var steps = this.steps;

    function next() {
      index++;

      if (index < steps.length) {
        var currentStep = steps[index];

        try {
          return currentStep(instruction, next);
        } catch (e) {
          return next.reject(e);
        }
      } else {
        return next.complete();
      }
    }

    next.complete = createCompletionHandler(next, pipelineStatus.completed);
    next.cancel = createCompletionHandler(next, pipelineStatus.canceled);
    next.reject = createCompletionHandler(next, pipelineStatus.rejected);

    return next();
  };

  return Pipeline;
}();

function createCompletionHandler(next, status) {
  return function (output) {
    return Promise.resolve({ status: status, output: output, completed: status === pipelineStatus.completed });
  };
}

var CommitChangesStep = exports.CommitChangesStep = function () {
  function CommitChangesStep() {
    
  }

  CommitChangesStep.prototype.run = function run(navigationInstruction, next) {
    return navigationInstruction._commitChanges(true).then(function () {
      navigationInstruction._updateTitle();
      return next();
    });
  };

  return CommitChangesStep;
}();

var NavigationInstruction = exports.NavigationInstruction = function () {
  function NavigationInstruction(init) {
    

    this.plan = null;
    this.options = {};

    Object.assign(this, init);

    this.params = this.params || {};
    this.viewPortInstructions = {};

    var ancestorParams = [];
    var current = this;
    do {
      var currentParams = Object.assign({}, current.params);
      if (current.config && current.config.hasChildRouter) {
        delete currentParams[current.getWildCardName()];
      }

      ancestorParams.unshift(currentParams);
      current = current.parentInstruction;
    } while (current);

    var allParams = Object.assign.apply(Object, [{}, this.queryParams].concat(ancestorParams));
    this.lifecycleArgs = [allParams, this.config, this];
  }

  NavigationInstruction.prototype.getAllInstructions = function getAllInstructions() {
    var instructions = [this];
    for (var key in this.viewPortInstructions) {
      var childInstruction = this.viewPortInstructions[key].childNavigationInstruction;
      if (childInstruction) {
        instructions.push.apply(instructions, childInstruction.getAllInstructions());
      }
    }

    return instructions;
  };

  NavigationInstruction.prototype.getAllPreviousInstructions = function getAllPreviousInstructions() {
    return this.getAllInstructions().map(function (c) {
      return c.previousInstruction;
    }).filter(function (c) {
      return c;
    });
  };

  NavigationInstruction.prototype.addViewPortInstruction = function addViewPortInstruction(viewPortName, strategy, moduleId, component) {
    var config = Object.assign({}, this.lifecycleArgs[1], { currentViewPort: viewPortName });
    var viewportInstruction = this.viewPortInstructions[viewPortName] = {
      name: viewPortName,
      strategy: strategy,
      moduleId: moduleId,
      component: component,
      childRouter: component.childRouter,
      lifecycleArgs: [].concat(this.lifecycleArgs[0], config, this.lifecycleArgs[2])
    };

    return viewportInstruction;
  };

  NavigationInstruction.prototype.getWildCardName = function getWildCardName() {
    var wildcardIndex = this.config.route.lastIndexOf('*');
    return this.config.route.substr(wildcardIndex + 1);
  };

  NavigationInstruction.prototype.getWildcardPath = function getWildcardPath() {
    var wildcardName = this.getWildCardName();
    var path = this.params[wildcardName] || '';

    if (this.queryString) {
      path += '?' + this.queryString;
    }

    return path;
  };

  NavigationInstruction.prototype.getBaseUrl = function getBaseUrl() {
    var _this = this;

    var fragment = decodeURI(this.fragment);

    if (fragment === '') {
      var nonEmptyRoute = this.router.routes.find(function (route) {
        return route.name === _this.config.name && route.route !== '';
      });
      if (nonEmptyRoute) {
        fragment = nonEmptyRoute.route;
      }
    }

    if (!this.params) {
      return encodeURI(fragment);
    }

    var wildcardName = this.getWildCardName();
    var path = this.params[wildcardName] || '';

    if (!path) {
      return encodeURI(fragment);
    }

    return encodeURI(fragment.substr(0, fragment.lastIndexOf(path)));
  };

  NavigationInstruction.prototype._commitChanges = function _commitChanges(waitToSwap) {
    var _this2 = this;

    var router = this.router;
    router.currentInstruction = this;

    if (this.previousInstruction) {
      this.previousInstruction.config.navModel.isActive = false;
    }

    this.config.navModel.isActive = true;

    router._refreshBaseUrl();
    router.refreshNavigation();

    var loads = [];
    var delaySwaps = [];

    var _loop = function _loop(viewPortName) {
      var viewPortInstruction = _this2.viewPortInstructions[viewPortName];
      var viewPort = router.viewPorts[viewPortName];

      if (!viewPort) {
        throw new Error('There was no router-view found in the view for ' + viewPortInstruction.moduleId + '.');
      }

      if (viewPortInstruction.strategy === activationStrategy.replace) {
        if (viewPortInstruction.childNavigationInstruction && viewPortInstruction.childNavigationInstruction.parentCatchHandler) {
          loads.push(viewPortInstruction.childNavigationInstruction._commitChanges(waitToSwap));
        } else {
          if (waitToSwap) {
            delaySwaps.push({ viewPort: viewPort, viewPortInstruction: viewPortInstruction });
          }
          loads.push(viewPort.process(viewPortInstruction, waitToSwap).then(function (x) {
            if (viewPortInstruction.childNavigationInstruction) {
              return viewPortInstruction.childNavigationInstruction._commitChanges(waitToSwap);
            }
          }));
        }
      } else {
        if (viewPortInstruction.childNavigationInstruction) {
          loads.push(viewPortInstruction.childNavigationInstruction._commitChanges(waitToSwap));
        }
      }
    };

    for (var viewPortName in this.viewPortInstructions) {
      _loop(viewPortName);
    }

    return Promise.all(loads).then(function () {
      delaySwaps.forEach(function (x) {
        return x.viewPort.swap(x.viewPortInstruction);
      });
      return null;
    }).then(function () {
      return prune(_this2);
    });
  };

  NavigationInstruction.prototype._updateTitle = function _updateTitle() {
    var title = this._buildTitle();
    if (title) {
      this.router.history.setTitle(title);
    }
  };

  NavigationInstruction.prototype._buildTitle = function _buildTitle() {
    var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ' | ';

    var title = '';
    var childTitles = [];

    if (this.config.navModel.title) {
      title = this.router.transformTitle(this.config.navModel.title);
    }

    for (var viewPortName in this.viewPortInstructions) {
      var _viewPortInstruction = this.viewPortInstructions[viewPortName];

      if (_viewPortInstruction.childNavigationInstruction) {
        var childTitle = _viewPortInstruction.childNavigationInstruction._buildTitle(separator);
        if (childTitle) {
          childTitles.push(childTitle);
        }
      }
    }

    if (childTitles.length) {
      title = childTitles.join(separator) + (title ? separator : '') + title;
    }

    if (this.router.title) {
      title += (title ? separator : '') + this.router.transformTitle(this.router.title);
    }

    return title;
  };

  return NavigationInstruction;
}();

function prune(instruction) {
  instruction.previousInstruction = null;
  instruction.plan = null;
}

var NavModel = exports.NavModel = function () {
  function NavModel(router, relativeHref) {
    

    this.isActive = false;
    this.title = null;
    this.href = null;
    this.relativeHref = null;
    this.settings = {};
    this.config = null;

    this.router = router;
    this.relativeHref = relativeHref;
  }

  NavModel.prototype.setTitle = function setTitle(title) {
    this.title = title;

    if (this.isActive) {
      this.router.updateTitle();
    }
  };

  return NavModel;
}();

function isNavigationCommand(obj) {
  return obj && typeof obj.navigate === 'function';
}

var Redirect = exports.Redirect = function () {
  function Redirect(url) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    

    this.url = url;
    this.options = Object.assign({ trigger: true, replace: true }, options);
    this.shouldContinueProcessing = false;
  }

  Redirect.prototype.setRouter = function setRouter(router) {
    this.router = router;
  };

  Redirect.prototype.navigate = function navigate(appRouter) {
    var navigatingRouter = this.options.useAppRouter ? appRouter : this.router || appRouter;
    navigatingRouter.navigate(this.url, this.options);
  };

  return Redirect;
}();

var RedirectToRoute = exports.RedirectToRoute = function () {
  function RedirectToRoute(route) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    

    this.route = route;
    this.params = params;
    this.options = Object.assign({ trigger: true, replace: true }, options);
    this.shouldContinueProcessing = false;
  }

  RedirectToRoute.prototype.setRouter = function setRouter(router) {
    this.router = router;
  };

  RedirectToRoute.prototype.navigate = function navigate(appRouter) {
    var navigatingRouter = this.options.useAppRouter ? appRouter : this.router || appRouter;
    navigatingRouter.navigateToRoute(this.route, this.params, this.options);
  };

  return RedirectToRoute;
}();

var RouterConfiguration = exports.RouterConfiguration = function () {
  function RouterConfiguration() {
    

    this.instructions = [];
    this.options = {};
    this.pipelineSteps = [];
  }

  RouterConfiguration.prototype.addPipelineStep = function addPipelineStep(name, step) {
    this.pipelineSteps.push({ name: name, step: step });
    return this;
  };

  RouterConfiguration.prototype.addAuthorizeStep = function addAuthorizeStep(step) {
    return this.addPipelineStep('authorize', step);
  };

  RouterConfiguration.prototype.addPreActivateStep = function addPreActivateStep(step) {
    return this.addPipelineStep('preActivate', step);
  };

  RouterConfiguration.prototype.addPreRenderStep = function addPreRenderStep(step) {
    return this.addPipelineStep('preRender', step);
  };

  RouterConfiguration.prototype.addPostRenderStep = function addPostRenderStep(step) {
    return this.addPipelineStep('postRender', step);
  };

  RouterConfiguration.prototype.fallbackRoute = function fallbackRoute(fragment) {
    this._fallbackRoute = fragment;
    return this;
  };

  RouterConfiguration.prototype.map = function map(route) {
    if (Array.isArray(route)) {
      route.forEach(this.map.bind(this));
      return this;
    }

    return this.mapRoute(route);
  };

  RouterConfiguration.prototype.useViewPortDefaults = function useViewPortDefaults(viewPortConfig) {
    this.viewPortDefaults = viewPortConfig;
    return this;
  };

  RouterConfiguration.prototype.mapRoute = function mapRoute(config) {
    this.instructions.push(function (router) {
      var routeConfigs = [];

      if (Array.isArray(config.route)) {
        for (var i = 0, ii = config.route.length; i < ii; ++i) {
          var _current = Object.assign({}, config);
          _current.route = config.route[i];
          routeConfigs.push(_current);
        }
      } else {
        routeConfigs.push(Object.assign({}, config));
      }

      var navModel = void 0;
      for (var _i = 0, _ii = routeConfigs.length; _i < _ii; ++_i) {
        var _routeConfig = routeConfigs[_i];
        _routeConfig.settings = _routeConfig.settings || {};
        if (!navModel) {
          navModel = router.createNavModel(_routeConfig);
        }

        router.addRoute(_routeConfig, navModel);
      }
    });

    return this;
  };

  RouterConfiguration.prototype.mapUnknownRoutes = function mapUnknownRoutes(config) {
    this.unknownRouteConfig = config;
    return this;
  };

  RouterConfiguration.prototype.exportToRouter = function exportToRouter(router) {
    var instructions = this.instructions;
    for (var i = 0, ii = instructions.length; i < ii; ++i) {
      instructions[i](router);
    }

    if (this.title) {
      router.title = this.title;
    }

    if (this.unknownRouteConfig) {
      router.handleUnknownRoutes(this.unknownRouteConfig);
    }

    if (this._fallbackRoute) {
      router.fallbackRoute = this._fallbackRoute;
    }

    if (this.viewPortDefaults) {
      router.useViewPortDefaults(this.viewPortDefaults);
    }

    router.options = this.options;

    var pipelineSteps = this.pipelineSteps;
    if (pipelineSteps.length) {
      if (!router.isRoot) {
        throw new Error('Pipeline steps can only be added to the root router');
      }

      var pipelineProvider = router.pipelineProvider;
      for (var _i2 = 0, _ii2 = pipelineSteps.length; _i2 < _ii2; ++_i2) {
        var _pipelineSteps$_i = pipelineSteps[_i2],
            _name = _pipelineSteps$_i.name,
            step = _pipelineSteps$_i.step;

        pipelineProvider.addStep(_name, step);
      }
    }
  };

  return RouterConfiguration;
}();

var activationStrategy = exports.activationStrategy = {
  noChange: 'no-change',
  invokeLifecycle: 'invoke-lifecycle',
  replace: 'replace'
};

var BuildNavigationPlanStep = exports.BuildNavigationPlanStep = function () {
  function BuildNavigationPlanStep() {
    
  }

  BuildNavigationPlanStep.prototype.run = function run(navigationInstruction, next) {
    return _buildNavigationPlan(navigationInstruction).then(function (plan) {
      navigationInstruction.plan = plan;
      return next();
    }).catch(next.cancel);
  };

  return BuildNavigationPlanStep;
}();

function _buildNavigationPlan(instruction, forceLifecycleMinimum) {
  var config = instruction.config;

  if ('redirect' in config) {
    var redirectLocation = _resolveUrl(config.redirect, getInstructionBaseUrl(instruction));
    if (instruction.queryString) {
      redirectLocation += '?' + instruction.queryString;
    }

    return Promise.reject(new Redirect(redirectLocation));
  }

  var prev = instruction.previousInstruction;
  var plan = {};
  var defaults = instruction.router.viewPortDefaults;

  if (prev) {
    var newParams = hasDifferentParameterValues(prev, instruction);
    var pending = [];

    var _loop2 = function _loop2(viewPortName) {
      var prevViewPortInstruction = prev.viewPortInstructions[viewPortName];
      var nextViewPortConfig = viewPortName in config.viewPorts ? config.viewPorts[viewPortName] : prevViewPortInstruction;
      if (nextViewPortConfig.moduleId === null && viewPortName in instruction.router.viewPortDefaults) {
        nextViewPortConfig = defaults[viewPortName];
      }

      var viewPortPlan = plan[viewPortName] = {
        name: viewPortName,
        config: nextViewPortConfig,
        prevComponent: prevViewPortInstruction.component,
        prevModuleId: prevViewPortInstruction.moduleId
      };

      if (prevViewPortInstruction.moduleId !== nextViewPortConfig.moduleId) {
        viewPortPlan.strategy = activationStrategy.replace;
      } else if ('determineActivationStrategy' in prevViewPortInstruction.component.viewModel) {
        var _prevViewPortInstruct;

        viewPortPlan.strategy = (_prevViewPortInstruct = prevViewPortInstruction.component.viewModel).determineActivationStrategy.apply(_prevViewPortInstruct, instruction.lifecycleArgs);
      } else if (config.activationStrategy) {
        viewPortPlan.strategy = config.activationStrategy;
      } else if (newParams || forceLifecycleMinimum) {
        viewPortPlan.strategy = activationStrategy.invokeLifecycle;
      } else {
        viewPortPlan.strategy = activationStrategy.noChange;
      }

      if (viewPortPlan.strategy !== activationStrategy.replace && prevViewPortInstruction.childRouter) {
        var path = instruction.getWildcardPath();
        var task = prevViewPortInstruction.childRouter._createNavigationInstruction(path, instruction).then(function (childInstruction) {
          viewPortPlan.childNavigationInstruction = childInstruction;

          return _buildNavigationPlan(childInstruction, viewPortPlan.strategy === activationStrategy.invokeLifecycle).then(function (childPlan) {
            childInstruction.plan = childPlan;
          });
        });

        pending.push(task);
      }
    };

    for (var viewPortName in prev.viewPortInstructions) {
      _loop2(viewPortName);
    }

    return Promise.all(pending).then(function () {
      return plan;
    });
  }

  for (var viewPortName in config.viewPorts) {
    var viewPortConfig = config.viewPorts[viewPortName];
    if (viewPortConfig.moduleId === null && viewPortName in instruction.router.viewPortDefaults) {
      viewPortConfig = defaults[viewPortName];
    }
    plan[viewPortName] = {
      name: viewPortName,
      strategy: activationStrategy.replace,
      config: viewPortConfig
    };
  }

  return Promise.resolve(plan);
}

function hasDifferentParameterValues(prev, next) {
  var prevParams = prev.params;
  var nextParams = next.params;
  var nextWildCardName = next.config.hasChildRouter ? next.getWildCardName() : null;

  for (var key in nextParams) {
    if (key === nextWildCardName) {
      continue;
    }

    if (prevParams[key] !== nextParams[key]) {
      return true;
    }
  }

  for (var _key in prevParams) {
    if (_key === nextWildCardName) {
      continue;
    }

    if (prevParams[_key] !== nextParams[_key]) {
      return true;
    }
  }

  if (!next.options.compareQueryParams) {
    return false;
  }

  var prevQueryParams = prev.queryParams;
  var nextQueryParams = next.queryParams;
  for (var _key2 in nextQueryParams) {
    if (prevQueryParams[_key2] !== nextQueryParams[_key2]) {
      return true;
    }
  }

  for (var _key3 in prevQueryParams) {
    if (prevQueryParams[_key3] !== nextQueryParams[_key3]) {
      return true;
    }
  }

  return false;
}

function getInstructionBaseUrl(instruction) {
  var instructionBaseUrlParts = [];
  instruction = instruction.parentInstruction;

  while (instruction) {
    instructionBaseUrlParts.unshift(instruction.getBaseUrl());
    instruction = instruction.parentInstruction;
  }

  instructionBaseUrlParts.unshift('/');
  return instructionBaseUrlParts.join('');
}

var Router = exports.Router = function () {
  function Router(container, history) {
    var _this3 = this;

    

    this.parent = null;
    this.options = {};
    this.viewPortDefaults = {};

    this.transformTitle = function (title) {
      if (_this3.parent) {
        return _this3.parent.transformTitle(title);
      }
      return title;
    };

    this.container = container;
    this.history = history;
    this.reset();
  }

  Router.prototype.reset = function reset() {
    var _this4 = this;

    this.viewPorts = {};
    this.routes = [];
    this.baseUrl = '';
    this.isConfigured = false;
    this.isNavigating = false;
    this.isExplicitNavigation = false;
    this.isExplicitNavigationBack = false;
    this.isNavigatingFirst = false;
    this.isNavigatingNew = false;
    this.isNavigatingRefresh = false;
    this.isNavigatingForward = false;
    this.isNavigatingBack = false;
    this.navigation = [];
    this.currentInstruction = null;
    this.viewPortDefaults = {};
    this._fallbackOrder = 100;
    this._recognizer = new _aureliaRouteRecognizer.RouteRecognizer();
    this._childRecognizer = new _aureliaRouteRecognizer.RouteRecognizer();
    this._configuredPromise = new Promise(function (resolve) {
      _this4._resolveConfiguredPromise = resolve;
    });
  };

  Router.prototype.registerViewPort = function registerViewPort(viewPort, name) {
    name = name || 'default';
    this.viewPorts[name] = viewPort;
  };

  Router.prototype.ensureConfigured = function ensureConfigured() {
    return this._configuredPromise;
  };

  Router.prototype.configure = function configure(callbackOrConfig) {
    var _this5 = this;

    this.isConfigured = true;

    var result = callbackOrConfig;
    var config = void 0;
    if (typeof callbackOrConfig === 'function') {
      config = new RouterConfiguration();
      result = callbackOrConfig(config);
    }

    return Promise.resolve(result).then(function (c) {
      if (c && c.exportToRouter) {
        config = c;
      }

      config.exportToRouter(_this5);
      _this5.isConfigured = true;
      _this5._resolveConfiguredPromise();
    });
  };

  Router.prototype.navigate = function navigate(fragment, options) {
    if (!this.isConfigured && this.parent) {
      return this.parent.navigate(fragment, options);
    }

    this.isExplicitNavigation = true;
    return this.history.navigate(_resolveUrl(fragment, this.baseUrl, this.history._hasPushState), options);
  };

  Router.prototype.navigateToRoute = function navigateToRoute(route, params, options) {
    var path = this.generate(route, params);
    return this.navigate(path, options);
  };

  Router.prototype.navigateBack = function navigateBack() {
    this.isExplicitNavigationBack = true;
    this.history.navigateBack();
  };

  Router.prototype.createChild = function createChild(container) {
    var childRouter = new Router(container || this.container.createChild(), this.history);
    childRouter.parent = this;
    return childRouter;
  };

  Router.prototype.generate = function generate(name, params) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var hasRoute = this._recognizer.hasRoute(name);
    if ((!this.isConfigured || !hasRoute) && this.parent) {
      return this.parent.generate(name, params);
    }

    if (!hasRoute) {
      throw new Error('A route with name \'' + name + '\' could not be found. Check that `name: \'' + name + '\'` was specified in the route\'s config.');
    }

    var path = this._recognizer.generate(name, params);
    var rootedPath = _createRootedPath(path, this.baseUrl, this.history._hasPushState, options.absolute);
    return options.absolute ? '' + this.history.getAbsoluteRoot() + rootedPath : rootedPath;
  };

  Router.prototype.createNavModel = function createNavModel(config) {
    var navModel = new NavModel(this, 'href' in config ? config.href : config.route);
    navModel.title = config.title;
    navModel.order = config.nav;
    navModel.href = config.href;
    navModel.settings = config.settings;
    navModel.config = config;

    return navModel;
  };

  Router.prototype.addRoute = function addRoute(config, navModel) {
    validateRouteConfig(config, this.routes);

    if (!('viewPorts' in config) && !config.navigationStrategy) {
      config.viewPorts = {
        'default': {
          moduleId: config.moduleId,
          view: config.view
        }
      };
    }

    if (!navModel) {
      navModel = this.createNavModel(config);
    }

    this.routes.push(config);

    var path = config.route;
    if (path.charAt(0) === '/') {
      path = path.substr(1);
    }
    var caseSensitive = config.caseSensitive === true;
    var state = this._recognizer.add({ path: path, handler: config, caseSensitive: caseSensitive });

    if (path) {
      var _settings = config.settings;
      delete config.settings;
      var withChild = JSON.parse(JSON.stringify(config));
      config.settings = _settings;
      withChild.route = path + '/*childRoute';
      withChild.hasChildRouter = true;
      this._childRecognizer.add({
        path: withChild.route,
        handler: withChild,
        caseSensitive: caseSensitive
      });

      withChild.navModel = navModel;
      withChild.settings = config.settings;
      withChild.navigationStrategy = config.navigationStrategy;
    }

    config.navModel = navModel;

    if ((navModel.order || navModel.order === 0) && this.navigation.indexOf(navModel) === -1) {
      if (!navModel.href && navModel.href !== '' && (state.types.dynamics || state.types.stars)) {
        throw new Error('Invalid route config for "' + config.route + '" : dynamic routes must specify an "href:" to be included in the navigation model.');
      }

      if (typeof navModel.order !== 'number') {
        navModel.order = ++this._fallbackOrder;
      }

      this.navigation.push(navModel);
      this.navigation = this.navigation.sort(function (a, b) {
        return a.order - b.order;
      });
    }
  };

  Router.prototype.hasRoute = function hasRoute(name) {
    return !!(this._recognizer.hasRoute(name) || this.parent && this.parent.hasRoute(name));
  };

  Router.prototype.hasOwnRoute = function hasOwnRoute(name) {
    return this._recognizer.hasRoute(name);
  };

  Router.prototype.handleUnknownRoutes = function handleUnknownRoutes(config) {
    var _this6 = this;

    if (!config) {
      throw new Error('Invalid unknown route handler');
    }

    this.catchAllHandler = function (instruction) {
      return _this6._createRouteConfig(config, instruction).then(function (c) {
        instruction.config = c;
        return instruction;
      });
    };
  };

  Router.prototype.updateTitle = function updateTitle() {
    if (this.parent) {
      return this.parent.updateTitle();
    }

    if (this.currentInstruction) {
      this.currentInstruction._updateTitle();
    }
    return undefined;
  };

  Router.prototype.refreshNavigation = function refreshNavigation() {
    var nav = this.navigation;

    for (var i = 0, length = nav.length; i < length; i++) {
      var _current2 = nav[i];
      if (!_current2.config.href) {
        _current2.href = _createRootedPath(_current2.relativeHref, this.baseUrl, this.history._hasPushState);
      } else {
        _current2.href = _normalizeAbsolutePath(_current2.config.href, this.history._hasPushState);
      }
    }
  };

  Router.prototype.useViewPortDefaults = function useViewPortDefaults(viewPortDefaults) {
    for (var viewPortName in viewPortDefaults) {
      var viewPortConfig = viewPortDefaults[viewPortName];
      this.viewPortDefaults[viewPortName] = {
        moduleId: viewPortConfig.moduleId
      };
    }
  };

  Router.prototype._refreshBaseUrl = function _refreshBaseUrl() {
    if (this.parent) {
      var baseUrl = this.parent.currentInstruction.getBaseUrl();
      this.baseUrl = this.parent.baseUrl + baseUrl;
    }
  };

  Router.prototype._createNavigationInstruction = function _createNavigationInstruction() {
    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var parentInstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    var fragment = url;
    var queryString = '';

    var queryIndex = url.indexOf('?');
    if (queryIndex !== -1) {
      fragment = url.substr(0, queryIndex);
      queryString = url.substr(queryIndex + 1);
    }

    var results = this._recognizer.recognize(url);
    if (!results || !results.length) {
      results = this._childRecognizer.recognize(url);
    }

    var instructionInit = {
      fragment: fragment,
      queryString: queryString,
      config: null,
      parentInstruction: parentInstruction,
      previousInstruction: this.currentInstruction,
      router: this,
      options: {
        compareQueryParams: this.options.compareQueryParams
      }
    };

    if (results && results.length) {
      var first = results[0];
      var _instruction = new NavigationInstruction(Object.assign({}, instructionInit, {
        params: first.params,
        queryParams: first.queryParams || results.queryParams,
        config: first.config || first.handler
      }));

      if (typeof first.handler === 'function') {
        return evaluateNavigationStrategy(_instruction, first.handler, first);
      } else if (first.handler && typeof first.handler.navigationStrategy === 'function') {
        return evaluateNavigationStrategy(_instruction, first.handler.navigationStrategy, first.handler);
      }

      return Promise.resolve(_instruction);
    } else if (this.catchAllHandler) {
      var _instruction2 = new NavigationInstruction(Object.assign({}, instructionInit, {
        params: { path: fragment },
        queryParams: results ? results.queryParams : {},
        config: null }));

      return evaluateNavigationStrategy(_instruction2, this.catchAllHandler);
    } else if (this.parent) {
      var _router = this._parentCatchAllHandler(this.parent);

      if (_router) {
        var newParentInstruction = this._findParentInstructionFromRouter(_router, parentInstruction);

        var _instruction3 = new NavigationInstruction(Object.assign({}, instructionInit, {
          params: { path: fragment },
          queryParams: results ? results.queryParams : {},
          router: _router,
          parentInstruction: newParentInstruction,
          parentCatchHandler: true,
          config: null }));

        return evaluateNavigationStrategy(_instruction3, _router.catchAllHandler);
      }
    }

    return Promise.reject(new Error('Route not found: ' + url));
  };

  Router.prototype._findParentInstructionFromRouter = function _findParentInstructionFromRouter(router, instruction) {
    if (instruction.router === router) {
      instruction.fragment = router.baseUrl;
      return instruction;
    } else if (instruction.parentInstruction) {
      return this._findParentInstructionFromRouter(router, instruction.parentInstruction);
    }
    return undefined;
  };

  Router.prototype._parentCatchAllHandler = function _parentCatchAllHandler(router) {
    if (router.catchAllHandler) {
      return router;
    } else if (router.parent) {
      return this._parentCatchAllHandler(router.parent);
    }
    return false;
  };

  Router.prototype._createRouteConfig = function _createRouteConfig(config, instruction) {
    var _this7 = this;

    return Promise.resolve(config).then(function (c) {
      if (typeof c === 'string') {
        return { moduleId: c };
      } else if (typeof c === 'function') {
        return c(instruction);
      }

      return c;
    }).then(function (c) {
      return typeof c === 'string' ? { moduleId: c } : c;
    }).then(function (c) {
      c.route = instruction.params.path;
      validateRouteConfig(c, _this7.routes);

      if (!c.navModel) {
        c.navModel = _this7.createNavModel(c);
      }

      return c;
    });
  };

  _createClass(Router, [{
    key: 'isRoot',
    get: function get() {
      return !this.parent;
    }
  }]);

  return Router;
}();

function validateRouteConfig(config, routes) {
  if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) !== 'object') {
    throw new Error('Invalid Route Config');
  }

  if (typeof config.route !== 'string') {
    var _name2 = config.name || '(no name)';
    throw new Error('Invalid Route Config for "' + _name2 + '": You must specify a "route:" pattern.');
  }

  if (!('redirect' in config || config.moduleId || config.navigationStrategy || config.viewPorts)) {
    throw new Error('Invalid Route Config for "' + config.route + '": You must specify a "moduleId:", "redirect:", "navigationStrategy:", or "viewPorts:".');
  }
}

function evaluateNavigationStrategy(instruction, evaluator, context) {
  return Promise.resolve(evaluator.call(context, instruction)).then(function () {
    if (!('viewPorts' in instruction.config)) {
      instruction.config.viewPorts = {
        'default': {
          moduleId: instruction.config.moduleId
        }
      };
    }

    return instruction;
  });
}

var CanDeactivatePreviousStep = exports.CanDeactivatePreviousStep = function () {
  function CanDeactivatePreviousStep() {
    
  }

  CanDeactivatePreviousStep.prototype.run = function run(navigationInstruction, next) {
    return processDeactivatable(navigationInstruction, 'canDeactivate', next);
  };

  return CanDeactivatePreviousStep;
}();

var CanActivateNextStep = exports.CanActivateNextStep = function () {
  function CanActivateNextStep() {
    
  }

  CanActivateNextStep.prototype.run = function run(navigationInstruction, next) {
    return processActivatable(navigationInstruction, 'canActivate', next);
  };

  return CanActivateNextStep;
}();

var DeactivatePreviousStep = exports.DeactivatePreviousStep = function () {
  function DeactivatePreviousStep() {
    
  }

  DeactivatePreviousStep.prototype.run = function run(navigationInstruction, next) {
    return processDeactivatable(navigationInstruction, 'deactivate', next, true);
  };

  return DeactivatePreviousStep;
}();

var ActivateNextStep = exports.ActivateNextStep = function () {
  function ActivateNextStep() {
    
  }

  ActivateNextStep.prototype.run = function run(navigationInstruction, next) {
    return processActivatable(navigationInstruction, 'activate', next, true);
  };

  return ActivateNextStep;
}();

function processDeactivatable(navigationInstruction, callbackName, next, ignoreResult) {
  var plan = navigationInstruction.plan;
  var infos = findDeactivatable(plan, callbackName);
  var i = infos.length;

  function inspect(val) {
    if (ignoreResult || shouldContinue(val)) {
      return iterate();
    }

    return next.cancel(val);
  }

  function iterate() {
    if (i--) {
      try {
        var viewModel = infos[i];
        var _result = viewModel[callbackName](navigationInstruction);
        return processPotential(_result, inspect, next.cancel);
      } catch (error) {
        return next.cancel(error);
      }
    }

    return next();
  }

  return iterate();
}

function findDeactivatable(plan, callbackName) {
  var list = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  for (var viewPortName in plan) {
    var _viewPortPlan = plan[viewPortName];
    var prevComponent = _viewPortPlan.prevComponent;

    if ((_viewPortPlan.strategy === activationStrategy.invokeLifecycle || _viewPortPlan.strategy === activationStrategy.replace) && prevComponent) {
      var viewModel = prevComponent.viewModel;

      if (callbackName in viewModel) {
        list.push(viewModel);
      }
    }

    if (_viewPortPlan.strategy === activationStrategy.replace && prevComponent) {
      addPreviousDeactivatable(prevComponent, callbackName, list);
    } else if (_viewPortPlan.childNavigationInstruction) {
      findDeactivatable(_viewPortPlan.childNavigationInstruction.plan, callbackName, list);
    }
  }

  return list;
}

function addPreviousDeactivatable(component, callbackName, list) {
  var childRouter = component.childRouter;

  if (childRouter && childRouter.currentInstruction) {
    var viewPortInstructions = childRouter.currentInstruction.viewPortInstructions;

    for (var viewPortName in viewPortInstructions) {
      var _viewPortInstruction2 = viewPortInstructions[viewPortName];
      var prevComponent = _viewPortInstruction2.component;
      var prevViewModel = prevComponent.viewModel;

      if (callbackName in prevViewModel) {
        list.push(prevViewModel);
      }

      addPreviousDeactivatable(prevComponent, callbackName, list);
    }
  }
}

function processActivatable(navigationInstruction, callbackName, next, ignoreResult) {
  var infos = findActivatable(navigationInstruction, callbackName);
  var length = infos.length;
  var i = -1;

  function inspect(val, router) {
    if (ignoreResult || shouldContinue(val, router)) {
      return iterate();
    }

    return next.cancel(val);
  }

  function iterate() {
    i++;

    if (i < length) {
      try {
        var _current3$viewModel;

        var _current3 = infos[i];
        var _result2 = (_current3$viewModel = _current3.viewModel)[callbackName].apply(_current3$viewModel, _current3.lifecycleArgs);
        return processPotential(_result2, function (val) {
          return inspect(val, _current3.router);
        }, next.cancel);
      } catch (error) {
        return next.cancel(error);
      }
    }

    return next();
  }

  return iterate();
}

function findActivatable(navigationInstruction, callbackName) {
  var list = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var router = arguments[3];

  var plan = navigationInstruction.plan;

  Object.keys(plan).filter(function (viewPortName) {
    var viewPortPlan = plan[viewPortName];
    var viewPortInstruction = navigationInstruction.viewPortInstructions[viewPortName];
    var viewModel = viewPortInstruction.component.viewModel;

    if ((viewPortPlan.strategy === activationStrategy.invokeLifecycle || viewPortPlan.strategy === activationStrategy.replace) && callbackName in viewModel) {
      list.push({
        viewModel: viewModel,
        lifecycleArgs: viewPortInstruction.lifecycleArgs,
        router: router
      });
    }

    if (viewPortPlan.childNavigationInstruction) {
      findActivatable(viewPortPlan.childNavigationInstruction, callbackName, list, viewPortInstruction.component.childRouter || router);
    }
  });

  return list;
}

function shouldContinue(output, router) {
  if (output instanceof Error) {
    return false;
  }

  if (isNavigationCommand(output)) {
    if (typeof output.setRouter === 'function') {
      output.setRouter(router);
    }

    return !!output.shouldContinueProcessing;
  }

  if (output === undefined) {
    return true;
  }

  return output;
}

var SafeSubscription = function () {
  function SafeSubscription(subscriptionFunc) {
    

    this._subscribed = true;
    this._subscription = subscriptionFunc(this);

    if (!this._subscribed) this.unsubscribe();
  }

  SafeSubscription.prototype.unsubscribe = function unsubscribe() {
    if (this._subscribed && this._subscription) this._subscription.unsubscribe();

    this._subscribed = false;
  };

  _createClass(SafeSubscription, [{
    key: 'subscribed',
    get: function get() {
      return this._subscribed;
    }
  }]);

  return SafeSubscription;
}();

function processPotential(obj, resolve, reject) {
  if (obj && typeof obj.then === 'function') {
    return Promise.resolve(obj).then(resolve).catch(reject);
  }

  if (obj && typeof obj.subscribe === 'function') {
    var obs = obj;
    return new SafeSubscription(function (sub) {
      return obs.subscribe({
        next: function next() {
          if (sub.subscribed) {
            sub.unsubscribe();
            resolve(obj);
          }
        },
        error: function error(_error) {
          if (sub.subscribed) {
            sub.unsubscribe();
            reject(_error);
          }
        },
        complete: function complete() {
          if (sub.subscribed) {
            sub.unsubscribe();
            resolve(obj);
          }
        }
      });
    });
  }

  try {
    return resolve(obj);
  } catch (error) {
    return reject(error);
  }
}

var RouteLoader = exports.RouteLoader = function () {
  function RouteLoader() {
    
  }

  RouteLoader.prototype.loadRoute = function loadRoute(router, config, navigationInstruction) {
    throw Error('Route loaders must implement "loadRoute(router, config, navigationInstruction)".');
  };

  return RouteLoader;
}();

var LoadRouteStep = exports.LoadRouteStep = function () {
  LoadRouteStep.inject = function inject() {
    return [RouteLoader];
  };

  function LoadRouteStep(routeLoader) {
    

    this.routeLoader = routeLoader;
  }

  LoadRouteStep.prototype.run = function run(navigationInstruction, next) {
    return loadNewRoute(this.routeLoader, navigationInstruction).then(next).catch(next.cancel);
  };

  return LoadRouteStep;
}();

function loadNewRoute(routeLoader, navigationInstruction) {
  var toLoad = determineWhatToLoad(navigationInstruction);
  var loadPromises = toLoad.map(function (current) {
    return loadRoute(routeLoader, current.navigationInstruction, current.viewPortPlan);
  });

  return Promise.all(loadPromises);
}

function determineWhatToLoad(navigationInstruction) {
  var toLoad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var plan = navigationInstruction.plan;

  for (var viewPortName in plan) {
    var _viewPortPlan2 = plan[viewPortName];

    if (_viewPortPlan2.strategy === activationStrategy.replace) {
      toLoad.push({ viewPortPlan: _viewPortPlan2, navigationInstruction: navigationInstruction });

      if (_viewPortPlan2.childNavigationInstruction) {
        determineWhatToLoad(_viewPortPlan2.childNavigationInstruction, toLoad);
      }
    } else {
      var _viewPortInstruction3 = navigationInstruction.addViewPortInstruction(viewPortName, _viewPortPlan2.strategy, _viewPortPlan2.prevModuleId, _viewPortPlan2.prevComponent);

      if (_viewPortPlan2.childNavigationInstruction) {
        _viewPortInstruction3.childNavigationInstruction = _viewPortPlan2.childNavigationInstruction;
        determineWhatToLoad(_viewPortPlan2.childNavigationInstruction, toLoad);
      }
    }
  }

  return toLoad;
}

function loadRoute(routeLoader, navigationInstruction, viewPortPlan) {
  var moduleId = viewPortPlan.config ? viewPortPlan.config.moduleId : null;

  return loadComponent(routeLoader, navigationInstruction, viewPortPlan.config).then(function (component) {
    var viewPortInstruction = navigationInstruction.addViewPortInstruction(viewPortPlan.name, viewPortPlan.strategy, moduleId, component);

    var childRouter = component.childRouter;
    if (childRouter) {
      var path = navigationInstruction.getWildcardPath();

      return childRouter._createNavigationInstruction(path, navigationInstruction).then(function (childInstruction) {
        viewPortPlan.childNavigationInstruction = childInstruction;

        return _buildNavigationPlan(childInstruction).then(function (childPlan) {
          childInstruction.plan = childPlan;
          viewPortInstruction.childNavigationInstruction = childInstruction;

          return loadNewRoute(routeLoader, childInstruction);
        });
      });
    }

    return undefined;
  });
}

function loadComponent(routeLoader, navigationInstruction, config) {
  var router = navigationInstruction.router;
  var lifecycleArgs = navigationInstruction.lifecycleArgs;

  return routeLoader.loadRoute(router, config, navigationInstruction).then(function (component) {
    var viewModel = component.viewModel,
        childContainer = component.childContainer;

    component.router = router;
    component.config = config;

    if ('configureRouter' in viewModel) {
      var childRouter = childContainer.getChildRouter();
      component.childRouter = childRouter;

      return childRouter.configure(function (c) {
        return viewModel.configureRouter.apply(viewModel, [c, childRouter].concat(lifecycleArgs));
      }).then(function () {
        return component;
      });
    }

    return component;
  });
}

var PipelineSlot = function () {
  function PipelineSlot(container, name, alias) {
    

    this.steps = [];

    this.container = container;
    this.slotName = name;
    this.slotAlias = alias;
  }

  PipelineSlot.prototype.getSteps = function getSteps() {
    var _this8 = this;

    return this.steps.map(function (x) {
      return _this8.container.get(x);
    });
  };

  return PipelineSlot;
}();

var PipelineProvider = exports.PipelineProvider = function () {
  PipelineProvider.inject = function inject() {
    return [_aureliaDependencyInjection.Container];
  };

  function PipelineProvider(container) {
    

    this.container = container;
    this.steps = [BuildNavigationPlanStep, CanDeactivatePreviousStep, LoadRouteStep, this._createPipelineSlot('authorize'), CanActivateNextStep, this._createPipelineSlot('preActivate', 'modelbind'), DeactivatePreviousStep, ActivateNextStep, this._createPipelineSlot('preRender', 'precommit'), CommitChangesStep, this._createPipelineSlot('postRender', 'postcomplete')];
  }

  PipelineProvider.prototype.createPipeline = function createPipeline() {
    var _this9 = this;

    var pipeline = new Pipeline();
    this.steps.forEach(function (step) {
      return pipeline.addStep(_this9.container.get(step));
    });
    return pipeline;
  };

  PipelineProvider.prototype._findStep = function _findStep(name) {
    return this.steps.find(function (x) {
      return x.slotName === name || x.slotAlias === name;
    });
  };

  PipelineProvider.prototype.addStep = function addStep(name, step) {
    var found = this._findStep(name);
    if (found) {
      if (!found.steps.includes(step)) {
        found.steps.push(step);
      }
    } else {
      throw new Error('Invalid pipeline slot name: ' + name + '.');
    }
  };

  PipelineProvider.prototype.removeStep = function removeStep(name, step) {
    var slot = this._findStep(name);
    if (slot) {
      slot.steps.splice(slot.steps.indexOf(step), 1);
    }
  };

  PipelineProvider.prototype._clearSteps = function _clearSteps() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    var slot = this._findStep(name);
    if (slot) {
      slot.steps = [];
    }
  };

  PipelineProvider.prototype.reset = function reset() {
    this._clearSteps('authorize');
    this._clearSteps('preActivate');
    this._clearSteps('preRender');
    this._clearSteps('postRender');
  };

  PipelineProvider.prototype._createPipelineSlot = function _createPipelineSlot(name, alias) {
    return new PipelineSlot(this.container, name, alias);
  };

  return PipelineProvider;
}();

var logger = LogManager.getLogger('app-router');

var AppRouter = exports.AppRouter = function (_Router) {
  _inherits(AppRouter, _Router);

  AppRouter.inject = function inject() {
    return [_aureliaDependencyInjection.Container, _aureliaHistory.History, PipelineProvider, _aureliaEventAggregator.EventAggregator];
  };

  function AppRouter(container, history, pipelineProvider, events) {
    

    var _this10 = _possibleConstructorReturn(this, _Router.call(this, container, history));

    _this10.pipelineProvider = pipelineProvider;
    _this10.events = events;
    return _this10;
  }

  AppRouter.prototype.reset = function reset() {
    _Router.prototype.reset.call(this);
    this.maxInstructionCount = 10;
    if (!this._queue) {
      this._queue = [];
    } else {
      this._queue.length = 0;
    }
  };

  AppRouter.prototype.loadUrl = function loadUrl(url) {
    var _this11 = this;

    return this._createNavigationInstruction(url).then(function (instruction) {
      return _this11._queueInstruction(instruction);
    }).catch(function (error) {
      logger.error(error);
      restorePreviousLocation(_this11);
    });
  };

  AppRouter.prototype.registerViewPort = function registerViewPort(viewPort, name) {
    var _this12 = this;

    _Router.prototype.registerViewPort.call(this, viewPort, name);

    if (!this.isActive) {
      var viewModel = this._findViewModel(viewPort);
      if ('configureRouter' in viewModel) {
        if (!this.isConfigured) {
          var resolveConfiguredPromise = this._resolveConfiguredPromise;
          this._resolveConfiguredPromise = function () {};
          return this.configure(function (config) {
            return viewModel.configureRouter(config, _this12);
          }).then(function () {
            _this12.activate();
            resolveConfiguredPromise();
          });
        }
      } else {
        this.activate();
      }
    } else {
      this._dequeueInstruction();
    }

    return Promise.resolve();
  };

  AppRouter.prototype.activate = function activate(options) {
    if (this.isActive) {
      return;
    }

    this.isActive = true;
    this.options = Object.assign({ routeHandler: this.loadUrl.bind(this) }, this.options, options);
    this.history.activate(this.options);
    this._dequeueInstruction();
  };

  AppRouter.prototype.deactivate = function deactivate() {
    this.isActive = false;
    this.history.deactivate();
  };

  AppRouter.prototype._queueInstruction = function _queueInstruction(instruction) {
    var _this13 = this;

    return new Promise(function (resolve) {
      instruction.resolve = resolve;
      _this13._queue.unshift(instruction);
      _this13._dequeueInstruction();
    });
  };

  AppRouter.prototype._dequeueInstruction = function _dequeueInstruction() {
    var _this14 = this;

    var instructionCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    return Promise.resolve().then(function () {
      if (_this14.isNavigating && !instructionCount) {
        return undefined;
      }

      var instruction = _this14._queue.shift();
      _this14._queue.length = 0;

      if (!instruction) {
        return undefined;
      }

      _this14.isNavigating = true;

      var navtracker = _this14.history.getState('NavigationTracker');
      if (!navtracker && !_this14.currentNavigationTracker) {
        _this14.isNavigatingFirst = true;
        _this14.isNavigatingNew = true;
      } else if (!navtracker) {
        _this14.isNavigatingNew = true;
      } else if (!_this14.currentNavigationTracker) {
        _this14.isNavigatingRefresh = true;
      } else if (_this14.currentNavigationTracker < navtracker) {
        _this14.isNavigatingForward = true;
      } else if (_this14.currentNavigationTracker > navtracker) {
        _this14.isNavigatingBack = true;
      }if (!navtracker) {
        navtracker = Date.now();
        _this14.history.setState('NavigationTracker', navtracker);
      }
      _this14.currentNavigationTracker = navtracker;

      instruction.previousInstruction = _this14.currentInstruction;

      if (!instructionCount) {
        _this14.events.publish('router:navigation:processing', { instruction: instruction });
      } else if (instructionCount === _this14.maxInstructionCount - 1) {
        logger.error(instructionCount + 1 + ' navigation instructions have been attempted without success. Restoring last known good location.');
        restorePreviousLocation(_this14);
        return _this14._dequeueInstruction(instructionCount + 1);
      } else if (instructionCount > _this14.maxInstructionCount) {
        throw new Error('Maximum navigation attempts exceeded. Giving up.');
      }

      var pipeline = _this14.pipelineProvider.createPipeline();

      return pipeline.run(instruction).then(function (result) {
        return processResult(instruction, result, instructionCount, _this14);
      }).catch(function (error) {
        return { output: error instanceof Error ? error : new Error(error) };
      }).then(function (result) {
        return resolveInstruction(instruction, result, !!instructionCount, _this14);
      });
    });
  };

  AppRouter.prototype._findViewModel = function _findViewModel(viewPort) {
    if (this.container.viewModel) {
      return this.container.viewModel;
    }

    if (viewPort.container) {
      var container = viewPort.container;

      while (container) {
        if (container.viewModel) {
          this.container.viewModel = container.viewModel;
          return container.viewModel;
        }

        container = container.parent;
      }
    }

    return undefined;
  };

  return AppRouter;
}(Router);

function processResult(instruction, result, instructionCount, router) {
  if (!(result && 'completed' in result && 'output' in result)) {
    result = result || {};
    result.output = new Error('Expected router pipeline to return a navigation result, but got [' + JSON.stringify(result) + '] instead.');
  }

  var finalResult = null;
  if (isNavigationCommand(result.output)) {
    result.output.navigate(router);
  } else {
    finalResult = result;

    if (!result.completed) {
      if (result.output instanceof Error) {
        logger.error(result.output);
      }

      restorePreviousLocation(router);
    }
  }

  return router._dequeueInstruction(instructionCount + 1).then(function (innerResult) {
    return finalResult || innerResult || result;
  });
}

function resolveInstruction(instruction, result, isInnerInstruction, router) {
  instruction.resolve(result);

  var eventArgs = { instruction: instruction, result: result };
  if (!isInnerInstruction) {
    router.isNavigating = false;
    router.isExplicitNavigation = false;
    router.isExplicitNavigationBack = false;
    router.isNavigatingFirst = false;
    router.isNavigatingNew = false;
    router.isNavigatingRefresh = false;
    router.isNavigatingForward = false;
    router.isNavigatingBack = false;

    var eventName = void 0;

    if (result.output instanceof Error) {
      eventName = 'error';
    } else if (!result.completed) {
      eventName = 'canceled';
    } else {
      var _queryString = instruction.queryString ? '?' + instruction.queryString : '';
      router.history.previousLocation = instruction.fragment + _queryString;
      eventName = 'success';
    }

    router.events.publish('router:navigation:' + eventName, eventArgs);
    router.events.publish('router:navigation:complete', eventArgs);
  } else {
    router.events.publish('router:navigation:child:complete', eventArgs);
  }

  return result;
}

function restorePreviousLocation(router) {
  var previousLocation = router.history.previousLocation;
  if (previousLocation) {
    router.navigate(router.history.previousLocation, { trigger: false, replace: true });
  } else if (router.fallbackRoute) {
    router.navigate(router.fallbackRoute, { trigger: true, replace: true });
  } else {
    logger.error('Router navigation failed, and no previous location or fallbackRoute could be restored.');
  }
}
});

define('aurelia-task-queue/dist/commonjs/aurelia-task-queue',['require','exports','module','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TaskQueue = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _aureliaPal = require('aurelia-pal');



var hasSetImmediate = typeof setImmediate === 'function';
var stackSeparator = '\nEnqueued in TaskQueue by:\n';
var microStackSeparator = '\nEnqueued in MicroTaskQueue by:\n';

function makeRequestFlushFromMutationObserver(flush) {
  var toggle = 1;
  var observer = _aureliaPal.DOM.createMutationObserver(flush);
  var node = _aureliaPal.DOM.createTextNode('');
  observer.observe(node, { characterData: true });
  return function requestFlush() {
    toggle = -toggle;
    node.data = toggle;
  };
}

function makeRequestFlushFromTimer(flush) {
  return function requestFlush() {
    var timeoutHandle = setTimeout(handleFlushTimer, 0);

    var intervalHandle = setInterval(handleFlushTimer, 50);
    function handleFlushTimer() {
      clearTimeout(timeoutHandle);
      clearInterval(intervalHandle);
      flush();
    }
  };
}

function onError(error, task, longStacks) {
  if (longStacks && task.stack && (typeof error === 'undefined' ? 'undefined' : _typeof(error)) === 'object' && error !== null) {
    error.stack = filterFlushStack(error.stack) + task.stack;
  }

  if ('onError' in task) {
    task.onError(error);
  } else if (hasSetImmediate) {
    setImmediate(function () {
      throw error;
    });
  } else {
    setTimeout(function () {
      throw error;
    }, 0);
  }
}

var TaskQueue = exports.TaskQueue = function () {
  function TaskQueue() {
    var _this = this;

    

    this.flushing = false;
    this.longStacks = false;

    this.microTaskQueue = [];
    this.microTaskQueueCapacity = 1024;
    this.taskQueue = [];

    if (_aureliaPal.FEATURE.mutationObserver) {
      this.requestFlushMicroTaskQueue = makeRequestFlushFromMutationObserver(function () {
        return _this.flushMicroTaskQueue();
      });
    } else {
      this.requestFlushMicroTaskQueue = makeRequestFlushFromTimer(function () {
        return _this.flushMicroTaskQueue();
      });
    }

    this.requestFlushTaskQueue = makeRequestFlushFromTimer(function () {
      return _this.flushTaskQueue();
    });
  }

  TaskQueue.prototype._flushQueue = function _flushQueue(queue, capacity) {
    var index = 0;
    var task = void 0;

    try {
      this.flushing = true;
      while (index < queue.length) {
        task = queue[index];
        if (this.longStacks) {
          this.stack = typeof task.stack === 'string' ? task.stack : undefined;
        }
        task.call();
        index++;

        if (index > capacity) {
          for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
            queue[scan] = queue[scan + index];
          }

          queue.length -= index;
          index = 0;
        }
      }
    } catch (error) {
      onError(error, task, this.longStacks);
    } finally {
      this.flushing = false;
    }
  };

  TaskQueue.prototype.queueMicroTask = function queueMicroTask(task) {
    if (this.microTaskQueue.length < 1) {
      this.requestFlushMicroTaskQueue();
    }

    if (this.longStacks) {
      task.stack = this.prepareQueueStack(microStackSeparator);
    }

    this.microTaskQueue.push(task);
  };

  TaskQueue.prototype.queueTask = function queueTask(task) {
    if (this.taskQueue.length < 1) {
      this.requestFlushTaskQueue();
    }

    if (this.longStacks) {
      task.stack = this.prepareQueueStack(stackSeparator);
    }

    this.taskQueue.push(task);
  };

  TaskQueue.prototype.flushTaskQueue = function flushTaskQueue() {
    var queue = this.taskQueue;
    this.taskQueue = [];
    this._flushQueue(queue, Number.MAX_VALUE);
  };

  TaskQueue.prototype.flushMicroTaskQueue = function flushMicroTaskQueue() {
    var queue = this.microTaskQueue;
    this._flushQueue(queue, this.microTaskQueueCapacity);
    queue.length = 0;
  };

  TaskQueue.prototype.prepareQueueStack = function prepareQueueStack(separator) {
    var stack = separator + filterQueueStack(captureStack());

    if (typeof this.stack === 'string') {
      stack = filterFlushStack(stack) + this.stack;
    }

    return stack;
  };

  return TaskQueue;
}();

function captureStack() {
  var error = new Error();

  if (error.stack) {
    return error.stack;
  }

  try {
    throw error;
  } catch (e) {
    return e.stack;
  }
}

function filterQueueStack(stack) {
  return stack.replace(/^[\s\S]*?\bqueue(Micro)?Task\b[^\n]*\n/, '');
}

function filterFlushStack(stack) {
  var index = stack.lastIndexOf('flushMicroTaskQueue');

  if (index < 0) {
    index = stack.lastIndexOf('flushTaskQueue');
    if (index < 0) {
      return stack;
    }
  }

  index = stack.lastIndexOf('\n', index);

  return index < 0 ? stack : stack.substr(0, index);
}
});

define('aurelia-templating-binding/dist/commonjs/aurelia-templating-binding',['require','exports','module','aurelia-logging','aurelia-binding','aurelia-templating'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TemplatingBindingLanguage = exports.SyntaxInterpreter = exports.ChildInterpolationBinding = exports.InterpolationBinding = exports.InterpolationBindingExpression = exports.AttributeMap = undefined;

var _class, _temp, _dec, _class2, _class3, _temp2, _class4, _temp3;

exports.configure = configure;

var _aureliaLogging = require('aurelia-logging');

var LogManager = _interopRequireWildcard(_aureliaLogging);

var _aureliaBinding = require('aurelia-binding');

var _aureliaTemplating = require('aurelia-templating');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var AttributeMap = exports.AttributeMap = (_temp = _class = function () {
  function AttributeMap(svg) {
    

    this.elements = Object.create(null);
    this.allElements = Object.create(null);

    this.svg = svg;

    this.registerUniversal('accesskey', 'accessKey');
    this.registerUniversal('contenteditable', 'contentEditable');
    this.registerUniversal('tabindex', 'tabIndex');
    this.registerUniversal('textcontent', 'textContent');
    this.registerUniversal('innerhtml', 'innerHTML');
    this.registerUniversal('scrolltop', 'scrollTop');
    this.registerUniversal('scrollleft', 'scrollLeft');
    this.registerUniversal('readonly', 'readOnly');

    this.register('label', 'for', 'htmlFor');

    this.register('img', 'usemap', 'useMap');

    this.register('input', 'maxlength', 'maxLength');
    this.register('input', 'minlength', 'minLength');
    this.register('input', 'formaction', 'formAction');
    this.register('input', 'formenctype', 'formEncType');
    this.register('input', 'formmethod', 'formMethod');
    this.register('input', 'formnovalidate', 'formNoValidate');
    this.register('input', 'formtarget', 'formTarget');

    this.register('textarea', 'maxlength', 'maxLength');

    this.register('td', 'rowspan', 'rowSpan');
    this.register('td', 'colspan', 'colSpan');
    this.register('th', 'rowspan', 'rowSpan');
    this.register('th', 'colspan', 'colSpan');
  }

  AttributeMap.prototype.register = function register(elementName, attributeName, propertyName) {
    elementName = elementName.toLowerCase();
    attributeName = attributeName.toLowerCase();
    var element = this.elements[elementName] = this.elements[elementName] || Object.create(null);
    element[attributeName] = propertyName;
  };

  AttributeMap.prototype.registerUniversal = function registerUniversal(attributeName, propertyName) {
    attributeName = attributeName.toLowerCase();
    this.allElements[attributeName] = propertyName;
  };

  AttributeMap.prototype.map = function map(elementName, attributeName) {
    if (this.svg.isStandardSvgAttribute(elementName, attributeName)) {
      return attributeName;
    }
    elementName = elementName.toLowerCase();
    attributeName = attributeName.toLowerCase();
    var element = this.elements[elementName];
    if (element !== undefined && attributeName in element) {
      return element[attributeName];
    }
    if (attributeName in this.allElements) {
      return this.allElements[attributeName];
    }

    if (/(?:^data-)|(?:^aria-)|:/.test(attributeName)) {
      return attributeName;
    }
    return (0, _aureliaBinding.camelCase)(attributeName);
  };

  return AttributeMap;
}(), _class.inject = [_aureliaBinding.SVGAnalyzer], _temp);

var InterpolationBindingExpression = exports.InterpolationBindingExpression = function () {
  function InterpolationBindingExpression(observerLocator, targetProperty, parts, mode, lookupFunctions, attribute) {
    

    this.observerLocator = observerLocator;
    this.targetProperty = targetProperty;
    this.parts = parts;
    this.mode = mode;
    this.lookupFunctions = lookupFunctions;
    this.attribute = this.attrToRemove = attribute;
    this.discrete = false;
  }

  InterpolationBindingExpression.prototype.createBinding = function createBinding(target) {
    if (this.parts.length === 3) {
      return new ChildInterpolationBinding(target, this.observerLocator, this.parts[1], this.mode, this.lookupFunctions, this.targetProperty, this.parts[0], this.parts[2]);
    }
    return new InterpolationBinding(this.observerLocator, this.parts, target, this.targetProperty, this.mode, this.lookupFunctions);
  };

  return InterpolationBindingExpression;
}();

function validateTarget(target, propertyName) {
  if (propertyName === 'style') {
    LogManager.getLogger('templating-binding').info('Internet Explorer does not support interpolation in "style" attributes.  Use the style attribute\'s alias, "css" instead.');
  } else if (target.parentElement && target.parentElement.nodeName === 'TEXTAREA' && propertyName === 'textContent') {
    throw new Error('Interpolation binding cannot be used in the content of a textarea element.  Use <textarea value.bind="expression"></textarea> instead.');
  }
}

var InterpolationBinding = exports.InterpolationBinding = function () {
  function InterpolationBinding(observerLocator, parts, target, targetProperty, mode, lookupFunctions) {
    

    validateTarget(target, targetProperty);
    this.observerLocator = observerLocator;
    this.parts = parts;
    this.target = target;
    this.targetProperty = targetProperty;
    this.targetAccessor = observerLocator.getAccessor(target, targetProperty);
    this.mode = mode;
    this.lookupFunctions = lookupFunctions;
  }

  InterpolationBinding.prototype.interpolate = function interpolate() {
    if (this.isBound) {
      var value = '';
      var parts = this.parts;
      for (var i = 0, ii = parts.length; i < ii; i++) {
        value += i % 2 === 0 ? parts[i] : this['childBinding' + i].value;
      }
      this.targetAccessor.setValue(value, this.target, this.targetProperty);
    }
  };

  InterpolationBinding.prototype.updateOneTimeBindings = function updateOneTimeBindings() {
    for (var i = 1, ii = this.parts.length; i < ii; i += 2) {
      var child = this['childBinding' + i];
      if (child.mode === _aureliaBinding.bindingMode.oneTime) {
        child.call();
      }
    }
  };

  InterpolationBinding.prototype.bind = function bind(source) {
    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.source = source;

    var parts = this.parts;
    for (var i = 1, ii = parts.length; i < ii; i += 2) {
      var binding = new ChildInterpolationBinding(this, this.observerLocator, parts[i], this.mode, this.lookupFunctions);
      binding.bind(source);
      this['childBinding' + i] = binding;
    }

    this.isBound = true;
    this.interpolate();
  };

  InterpolationBinding.prototype.unbind = function unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    this.source = null;
    var parts = this.parts;
    for (var i = 1, ii = parts.length; i < ii; i += 2) {
      var name = 'childBinding' + i;
      this[name].unbind();
    }
  };

  return InterpolationBinding;
}();

var ChildInterpolationBinding = exports.ChildInterpolationBinding = (_dec = (0, _aureliaBinding.connectable)(), _dec(_class2 = function () {
  function ChildInterpolationBinding(target, observerLocator, sourceExpression, mode, lookupFunctions, targetProperty, left, right) {
    

    if (target instanceof InterpolationBinding) {
      this.parent = target;
    } else {
      validateTarget(target, targetProperty);
      this.target = target;
      this.targetProperty = targetProperty;
      this.targetAccessor = observerLocator.getAccessor(target, targetProperty);
    }
    this.observerLocator = observerLocator;
    this.sourceExpression = sourceExpression;
    this.mode = mode;
    this.lookupFunctions = lookupFunctions;
    this.left = left;
    this.right = right;
  }

  ChildInterpolationBinding.prototype.updateTarget = function updateTarget(value) {
    value = value === null || value === undefined ? '' : value.toString();
    if (value !== this.value) {
      this.value = value;
      if (this.parent) {
        this.parent.interpolate();
      } else {
        this.targetAccessor.setValue(this.left + value + this.right, this.target, this.targetProperty);
      }
    }
  };

  ChildInterpolationBinding.prototype.call = function call() {
    if (!this.isBound) {
      return;
    }

    this.rawValue = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
    this.updateTarget(this.rawValue);

    if (this.mode !== _aureliaBinding.bindingMode.oneTime) {
      this._version++;
      this.sourceExpression.connect(this, this.source);
      if (this.rawValue instanceof Array) {
        this.observeArray(this.rawValue);
      }
      this.unobserve(false);
    }
  };

  ChildInterpolationBinding.prototype.bind = function bind(source) {
    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this.source = source;

    var sourceExpression = this.sourceExpression;
    if (sourceExpression.bind) {
      sourceExpression.bind(this, source, this.lookupFunctions);
    }

    this.rawValue = sourceExpression.evaluate(source, this.lookupFunctions);
    this.updateTarget(this.rawValue);

    if (this.mode === _aureliaBinding.bindingMode.oneWay) {
      (0, _aureliaBinding.enqueueBindingConnect)(this);
    }
  };

  ChildInterpolationBinding.prototype.unbind = function unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    var sourceExpression = this.sourceExpression;
    if (sourceExpression.unbind) {
      sourceExpression.unbind(this, this.source);
    }
    this.source = null;
    this.value = null;
    this.rawValue = null;
    this.unobserve(true);
  };

  ChildInterpolationBinding.prototype.connect = function connect(evaluate) {
    if (!this.isBound) {
      return;
    }
    if (evaluate) {
      this.rawValue = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
      this.updateTarget(this.rawValue);
    }
    this.sourceExpression.connect(this, this.source);
    if (this.rawValue instanceof Array) {
      this.observeArray(this.rawValue);
    }
  };

  return ChildInterpolationBinding;
}()) || _class2);
var SyntaxInterpreter = exports.SyntaxInterpreter = (_temp2 = _class3 = function () {
  function SyntaxInterpreter(parser, observerLocator, eventManager, attributeMap) {
    

    this.parser = parser;
    this.observerLocator = observerLocator;
    this.eventManager = eventManager;
    this.attributeMap = attributeMap;
  }

  SyntaxInterpreter.prototype.interpret = function interpret(resources, element, info, existingInstruction, context) {
    if (info.command in this) {
      return this[info.command](resources, element, info, existingInstruction, context);
    }

    return this.handleUnknownCommand(resources, element, info, existingInstruction, context);
  };

  SyntaxInterpreter.prototype.handleUnknownCommand = function handleUnknownCommand(resources, element, info, existingInstruction, context) {
    LogManager.getLogger('templating-binding').warn('Unknown binding command.', info);
    return existingInstruction;
  };

  SyntaxInterpreter.prototype.determineDefaultBindingMode = function determineDefaultBindingMode(element, attrName, context) {
    var tagName = element.tagName.toLowerCase();

    if (tagName === 'input' && (attrName === 'value' || attrName === 'files') && element.type !== 'checkbox' && element.type !== 'radio' || tagName === 'input' && attrName === 'checked' && (element.type === 'checkbox' || element.type === 'radio') || (tagName === 'textarea' || tagName === 'select') && attrName === 'value' || (attrName === 'textcontent' || attrName === 'innerhtml') && element.contentEditable === 'true' || attrName === 'scrolltop' || attrName === 'scrollleft') {
      return _aureliaBinding.bindingMode.twoWay;
    }

    if (context && attrName in context.attributes && context.attributes[attrName] && context.attributes[attrName].defaultBindingMode >= _aureliaBinding.bindingMode.oneTime) {
      return context.attributes[attrName].defaultBindingMode;
    }

    return _aureliaBinding.bindingMode.oneWay;
  };

  SyntaxInterpreter.prototype.bind = function bind(resources, element, info, existingInstruction, context) {
    var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

    instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), info.defaultBindingMode === undefined || info.defaultBindingMode === null ? this.determineDefaultBindingMode(element, info.attrName, context) : info.defaultBindingMode, resources.lookupFunctions);

    return instruction;
  };

  SyntaxInterpreter.prototype.trigger = function trigger(resources, element, info) {
    return new _aureliaBinding.ListenerExpression(this.eventManager, info.attrName, this.parser.parse(info.attrValue), _aureliaBinding.delegationStrategy.none, true, resources.lookupFunctions);
  };

  SyntaxInterpreter.prototype.capture = function capture(resources, element, info) {
    return new _aureliaBinding.ListenerExpression(this.eventManager, info.attrName, this.parser.parse(info.attrValue), _aureliaBinding.delegationStrategy.capturing, true, resources.lookupFunctions);
  };

  SyntaxInterpreter.prototype.delegate = function delegate(resources, element, info) {
    return new _aureliaBinding.ListenerExpression(this.eventManager, info.attrName, this.parser.parse(info.attrValue), _aureliaBinding.delegationStrategy.bubbling, true, resources.lookupFunctions);
  };

  SyntaxInterpreter.prototype.call = function call(resources, element, info, existingInstruction) {
    var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

    instruction.attributes[info.attrName] = new _aureliaBinding.CallExpression(this.observerLocator, info.attrName, this.parser.parse(info.attrValue), resources.lookupFunctions);

    return instruction;
  };

  SyntaxInterpreter.prototype.options = function options(resources, element, info, existingInstruction, context) {
    var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);
    var attrValue = info.attrValue;
    var language = this.language;
    var name = null;
    var target = '';
    var current = void 0;
    var i = void 0;
    var ii = void 0;
    var inString = false;
    var inEscape = false;
    var foundName = false;

    for (i = 0, ii = attrValue.length; i < ii; ++i) {
      current = attrValue[i];

      if (current === ';' && !inString) {
        if (!foundName) {
          name = this._getPrimaryPropertyName(resources, context);
        }
        info = language.inspectAttribute(resources, '?', name, target.trim());
        language.createAttributeInstruction(resources, element, info, instruction, context);

        if (!instruction.attributes[info.attrName]) {
          instruction.attributes[info.attrName] = info.attrValue;
        }

        target = '';
        name = null;
      } else if (current === ':' && name === null) {
        foundName = true;
        name = target.trim();
        target = '';
      } else if (current === '\\') {
        target += current;
        inEscape = true;
        continue;
      } else {
        target += current;

        if (name !== null && inEscape === false && current === '\'') {
          inString = !inString;
        }
      }

      inEscape = false;
    }

    if (!foundName) {
      name = this._getPrimaryPropertyName(resources, context);
    }

    if (name !== null) {
      info = language.inspectAttribute(resources, '?', name, target.trim());
      language.createAttributeInstruction(resources, element, info, instruction, context);

      if (!instruction.attributes[info.attrName]) {
        instruction.attributes[info.attrName] = info.attrValue;
      }
    }

    return instruction;
  };

  SyntaxInterpreter.prototype._getPrimaryPropertyName = function _getPrimaryPropertyName(resources, context) {
    var type = resources.getAttribute(context.attributeName);
    if (type && type.primaryProperty) {
      return type.primaryProperty.attribute;
    }
    return null;
  };

  SyntaxInterpreter.prototype['for'] = function _for(resources, element, info, existingInstruction) {
    var parts = void 0;
    var keyValue = void 0;
    var instruction = void 0;
    var attrValue = void 0;
    var isDestructuring = void 0;

    attrValue = info.attrValue;
    isDestructuring = attrValue.match(/^ *[[].+[\]]/);
    parts = isDestructuring ? attrValue.split('of ') : attrValue.split(' of ');

    if (parts.length !== 2) {
      throw new Error('Incorrect syntax for "for". The form is: "$local of $items" or "[$key, $value] of $items".');
    }

    instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

    if (isDestructuring) {
      keyValue = parts[0].replace(/[[\]]/g, '').replace(/,/g, ' ').replace(/\s+/g, ' ').trim().split(' ');
      instruction.attributes.key = keyValue[0];
      instruction.attributes.value = keyValue[1];
    } else {
      instruction.attributes.local = parts[0];
    }

    instruction.attributes.items = new _aureliaBinding.BindingExpression(this.observerLocator, 'items', this.parser.parse(parts[1]), _aureliaBinding.bindingMode.oneWay, resources.lookupFunctions);

    return instruction;
  };

  SyntaxInterpreter.prototype['two-way'] = function twoWay(resources, element, info, existingInstruction) {
    var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

    instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.twoWay, resources.lookupFunctions);

    return instruction;
  };

  SyntaxInterpreter.prototype['to-view'] = function toView(resources, element, info, existingInstruction) {
    var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

    instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.toView, resources.lookupFunctions);

    return instruction;
  };

  SyntaxInterpreter.prototype['from-view'] = function fromView(resources, element, info, existingInstruction) {
    var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

    instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.fromView, resources.lookupFunctions);

    return instruction;
  };

  SyntaxInterpreter.prototype['one-time'] = function oneTime(resources, element, info, existingInstruction) {
    var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

    instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.oneTime, resources.lookupFunctions);

    return instruction;
  };

  return SyntaxInterpreter;
}(), _class3.inject = [_aureliaBinding.Parser, _aureliaBinding.ObserverLocator, _aureliaBinding.EventManager, AttributeMap], _temp2);


SyntaxInterpreter.prototype['one-way'] = SyntaxInterpreter.prototype['to-view'];

var info = {};

var TemplatingBindingLanguage = exports.TemplatingBindingLanguage = (_temp3 = _class4 = function (_BindingLanguage) {
  _inherits(TemplatingBindingLanguage, _BindingLanguage);

  function TemplatingBindingLanguage(parser, observerLocator, syntaxInterpreter, attributeMap) {
    

    var _this = _possibleConstructorReturn(this, _BindingLanguage.call(this));

    _this.parser = parser;
    _this.observerLocator = observerLocator;
    _this.syntaxInterpreter = syntaxInterpreter;
    _this.emptyStringExpression = _this.parser.parse('\'\'');
    syntaxInterpreter.language = _this;
    _this.attributeMap = attributeMap;
    return _this;
  }

  TemplatingBindingLanguage.prototype.inspectAttribute = function inspectAttribute(resources, elementName, attrName, attrValue) {
    var parts = attrName.split('.');

    info.defaultBindingMode = null;

    if (parts.length === 2) {
      info.attrName = parts[0].trim();
      info.attrValue = attrValue;
      info.command = parts[1].trim();

      if (info.command === 'ref') {
        info.expression = new _aureliaBinding.NameExpression(this.parser.parse(attrValue), info.attrName, resources.lookupFunctions);
        info.command = null;
        info.attrName = 'ref';
      } else {
        info.expression = null;
      }
    } else if (attrName === 'ref') {
      info.attrName = attrName;
      info.attrValue = attrValue;
      info.command = null;
      info.expression = new _aureliaBinding.NameExpression(this.parser.parse(attrValue), 'element', resources.lookupFunctions);
    } else {
      info.attrName = attrName;
      info.attrValue = attrValue;
      info.command = null;
      var interpolationParts = this.parseInterpolation(resources, attrValue);
      if (interpolationParts === null) {
        info.expression = null;
      } else {
        info.expression = new InterpolationBindingExpression(this.observerLocator, this.attributeMap.map(elementName, attrName), interpolationParts, _aureliaBinding.bindingMode.oneWay, resources.lookupFunctions, attrName);
      }
    }

    return info;
  };

  TemplatingBindingLanguage.prototype.createAttributeInstruction = function createAttributeInstruction(resources, element, theInfo, existingInstruction, context) {
    var instruction = void 0;

    if (theInfo.expression) {
      if (theInfo.attrName === 'ref') {
        return theInfo.expression;
      }

      instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(theInfo.attrName);
      instruction.attributes[theInfo.attrName] = theInfo.expression;
    } else if (theInfo.command) {
      instruction = this.syntaxInterpreter.interpret(resources, element, theInfo, existingInstruction, context);
    }

    return instruction;
  };

  TemplatingBindingLanguage.prototype.inspectTextContent = function inspectTextContent(resources, value) {
    var parts = this.parseInterpolation(resources, value);
    if (parts === null) {
      return null;
    }
    return new InterpolationBindingExpression(this.observerLocator, 'textContent', parts, _aureliaBinding.bindingMode.oneWay, resources.lookupFunctions, 'textContent');
  };

  TemplatingBindingLanguage.prototype.parseInterpolation = function parseInterpolation(resources, value) {
    var i = value.indexOf('${', 0);
    var ii = value.length;
    var char = void 0;
    var pos = 0;
    var open = 0;
    var quote = null;
    var interpolationStart = void 0;
    var parts = void 0;
    var partIndex = 0;

    while (i >= 0 && i < ii - 2) {
      open = 1;
      interpolationStart = i;
      i += 2;

      do {
        char = value[i];
        i++;

        if (char === "'" || char === '"') {
          if (quote === null) {
            quote = char;
          } else if (quote === char) {
            quote = null;
          }
          continue;
        }

        if (char === '\\') {
          i++;
          continue;
        }

        if (quote !== null) {
          continue;
        }

        if (char === '{') {
          open++;
        } else if (char === '}') {
          open--;
        }
      } while (open > 0 && i < ii);

      if (open === 0) {
        parts = parts || [];
        if (value[interpolationStart - 1] === '\\' && value[interpolationStart - 2] !== '\\') {
          parts[partIndex] = value.substring(pos, interpolationStart - 1) + value.substring(interpolationStart, i);
          partIndex++;
          parts[partIndex] = this.emptyStringExpression;
          partIndex++;
        } else {
          parts[partIndex] = value.substring(pos, interpolationStart);
          partIndex++;
          parts[partIndex] = this.parser.parse(value.substring(interpolationStart + 2, i - 1));
          partIndex++;
        }
        pos = i;
        i = value.indexOf('${', i);
      } else {
        break;
      }
    }

    if (partIndex === 0) {
      return null;
    }

    parts[partIndex] = value.substr(pos);
    return parts;
  };

  return TemplatingBindingLanguage;
}(_aureliaTemplating.BindingLanguage), _class4.inject = [_aureliaBinding.Parser, _aureliaBinding.ObserverLocator, SyntaxInterpreter, AttributeMap], _temp3);
function configure(config) {
  config.container.registerSingleton(_aureliaTemplating.BindingLanguage, TemplatingBindingLanguage);
  config.container.registerAlias(_aureliaTemplating.BindingLanguage, TemplatingBindingLanguage);
}
});

define('aurelia-templating-resources/dist/commonjs/abstract-repeater',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});



var AbstractRepeater = exports.AbstractRepeater = function () {
  function AbstractRepeater(options) {
    

    Object.assign(this, {
      local: 'items',
      viewsRequireLifecycle: true
    }, options);
  }

  AbstractRepeater.prototype.viewCount = function viewCount() {
    throw new Error('subclass must implement `viewCount`');
  };

  AbstractRepeater.prototype.views = function views() {
    throw new Error('subclass must implement `views`');
  };

  AbstractRepeater.prototype.view = function view(index) {
    throw new Error('subclass must implement `view`');
  };

  AbstractRepeater.prototype.matcher = function matcher() {
    throw new Error('subclass must implement `matcher`');
  };

  AbstractRepeater.prototype.addView = function addView(bindingContext, overrideContext) {
    throw new Error('subclass must implement `addView`');
  };

  AbstractRepeater.prototype.insertView = function insertView(index, bindingContext, overrideContext) {
    throw new Error('subclass must implement `insertView`');
  };

  AbstractRepeater.prototype.moveView = function moveView(sourceIndex, targetIndex) {
    throw new Error('subclass must implement `moveView`');
  };

  AbstractRepeater.prototype.removeAllViews = function removeAllViews(returnToCache, skipAnimation) {
    throw new Error('subclass must implement `removeAllViews`');
  };

  AbstractRepeater.prototype.removeViews = function removeViews(viewsToRemove, returnToCache, skipAnimation) {
    throw new Error('subclass must implement `removeView`');
  };

  AbstractRepeater.prototype.removeView = function removeView(index, returnToCache, skipAnimation) {
    throw new Error('subclass must implement `removeView`');
  };

  AbstractRepeater.prototype.updateBindings = function updateBindings(view) {
    throw new Error('subclass must implement `updateBindings`');
  };

  return AbstractRepeater;
}();
});

define('aurelia-templating-resources/dist/commonjs/analyze-view-factory',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.viewsRequireLifecycle = viewsRequireLifecycle;
var lifecycleOptionalBehaviors = exports.lifecycleOptionalBehaviors = ['focus', 'if', 'else', 'repeat', 'show', 'hide', 'with'];

function behaviorRequiresLifecycle(instruction) {
  var t = instruction.type;
  var name = t.elementName !== null ? t.elementName : t.attributeName;
  return lifecycleOptionalBehaviors.indexOf(name) === -1 && (t.handlesAttached || t.handlesBind || t.handlesCreated || t.handlesDetached || t.handlesUnbind) || t.viewFactory && viewsRequireLifecycle(t.viewFactory) || instruction.viewFactory && viewsRequireLifecycle(instruction.viewFactory);
}

function targetRequiresLifecycle(instruction) {
  var behaviors = instruction.behaviorInstructions;
  if (behaviors) {
    var i = behaviors.length;
    while (i--) {
      if (behaviorRequiresLifecycle(behaviors[i])) {
        return true;
      }
    }
  }

  return instruction.viewFactory && viewsRequireLifecycle(instruction.viewFactory);
}

function viewsRequireLifecycle(viewFactory) {
  if ('_viewsRequireLifecycle' in viewFactory) {
    return viewFactory._viewsRequireLifecycle;
  }

  viewFactory._viewsRequireLifecycle = false;

  if (viewFactory.viewFactory) {
    viewFactory._viewsRequireLifecycle = viewsRequireLifecycle(viewFactory.viewFactory);
    return viewFactory._viewsRequireLifecycle;
  }

  if (viewFactory.template.querySelector('.au-animate')) {
    viewFactory._viewsRequireLifecycle = true;
    return true;
  }

  for (var id in viewFactory.instructions) {
    if (targetRequiresLifecycle(viewFactory.instructions[id])) {
      viewFactory._viewsRequireLifecycle = true;
      return true;
    }
  }

  viewFactory._viewsRequireLifecycle = false;
  return false;
}
});

define('aurelia-templating-resources/dist/commonjs/array-repeat-strategy',['require','exports','module','./repeat-utilities','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayRepeatStrategy = undefined;

var _repeatUtilities = require('./repeat-utilities');

var _aureliaBinding = require('aurelia-binding');



var ArrayRepeatStrategy = exports.ArrayRepeatStrategy = function () {
  function ArrayRepeatStrategy() {
    
  }

  ArrayRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {
    return observerLocator.getArrayObserver(items);
  };

  ArrayRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
    var _this = this;

    var itemsLength = items.length;

    if (!items || itemsLength === 0) {
      repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
      return;
    }

    var children = repeat.views();
    var viewsLength = children.length;

    if (viewsLength === 0) {
      this._standardProcessInstanceChanged(repeat, items);
      return;
    }

    if (repeat.viewsRequireLifecycle) {
      var childrenSnapshot = children.slice(0);
      var itemNameInBindingContext = repeat.local;
      var matcher = repeat.matcher();

      var itemsPreviouslyInViews = [];
      var viewsToRemove = [];

      for (var index = 0; index < viewsLength; index++) {
        var view = childrenSnapshot[index];
        var oldItem = view.bindingContext[itemNameInBindingContext];

        if ((0, _repeatUtilities.indexOf)(items, oldItem, matcher) === -1) {
          viewsToRemove.push(view);
        } else {
          itemsPreviouslyInViews.push(oldItem);
        }
      }

      var updateViews = void 0;
      var removePromise = void 0;

      if (itemsPreviouslyInViews.length > 0) {
        removePromise = repeat.removeViews(viewsToRemove, true, !repeat.viewsRequireLifecycle);
        updateViews = function updateViews() {
          for (var _index = 0; _index < itemsLength; _index++) {
            var item = items[_index];
            var indexOfView = (0, _repeatUtilities.indexOf)(itemsPreviouslyInViews, item, matcher, _index);
            var _view = void 0;

            if (indexOfView === -1) {
              var overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, items[_index], _index, itemsLength);
              repeat.insertView(_index, overrideContext.bindingContext, overrideContext);

              itemsPreviouslyInViews.splice(_index, 0, undefined);
            } else if (indexOfView === _index) {
              _view = children[indexOfView];
              itemsPreviouslyInViews[indexOfView] = undefined;
            } else {
              _view = children[indexOfView];
              repeat.moveView(indexOfView, _index);
              itemsPreviouslyInViews.splice(indexOfView, 1);
              itemsPreviouslyInViews.splice(_index, 0, undefined);
            }

            if (_view) {
              (0, _repeatUtilities.updateOverrideContext)(_view.overrideContext, _index, itemsLength);
            }
          }

          _this._inPlaceProcessItems(repeat, items);
        };
      } else {
        removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
        updateViews = function updateViews() {
          return _this._standardProcessInstanceChanged(repeat, items);
        };
      }

      if (removePromise instanceof Promise) {
        removePromise.then(updateViews);
      } else {
        updateViews();
      }
    } else {
      this._inPlaceProcessItems(repeat, items);
    }
  };

  ArrayRepeatStrategy.prototype._standardProcessInstanceChanged = function _standardProcessInstanceChanged(repeat, items) {
    for (var i = 0, ii = items.length; i < ii; i++) {
      var overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, items[i], i, ii);
      repeat.addView(overrideContext.bindingContext, overrideContext);
    }
  };

  ArrayRepeatStrategy.prototype._inPlaceProcessItems = function _inPlaceProcessItems(repeat, items) {
    var itemsLength = items.length;
    var viewsLength = repeat.viewCount();

    while (viewsLength > itemsLength) {
      viewsLength--;
      repeat.removeView(viewsLength, true, !repeat.viewsRequireLifecycle);
    }

    var local = repeat.local;

    for (var i = 0; i < viewsLength; i++) {
      var view = repeat.view(i);
      var last = i === itemsLength - 1;
      var middle = i !== 0 && !last;

      if (view.bindingContext[local] === items[i] && view.overrideContext.$middle === middle && view.overrideContext.$last === last) {
        continue;
      }

      view.bindingContext[local] = items[i];
      view.overrideContext.$middle = middle;
      view.overrideContext.$last = last;
      repeat.updateBindings(view);
    }

    for (var _i = viewsLength; _i < itemsLength; _i++) {
      var overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, items[_i], _i, itemsLength);
      repeat.addView(overrideContext.bindingContext, overrideContext);
    }
  };

  ArrayRepeatStrategy.prototype.instanceMutated = function instanceMutated(repeat, array, splices) {
    var _this2 = this;

    if (repeat.__queuedSplices) {
      for (var i = 0, ii = splices.length; i < ii; ++i) {
        var _splices$i = splices[i],
            index = _splices$i.index,
            removed = _splices$i.removed,
            addedCount = _splices$i.addedCount;

        (0, _aureliaBinding.mergeSplice)(repeat.__queuedSplices, index, removed, addedCount);
      }

      repeat.__array = array.slice(0);
      return;
    }

    var maybePromise = this._runSplices(repeat, array.slice(0), splices);
    if (maybePromise instanceof Promise) {
      var queuedSplices = repeat.__queuedSplices = [];

      var runQueuedSplices = function runQueuedSplices() {
        if (!queuedSplices.length) {
          repeat.__queuedSplices = undefined;
          repeat.__array = undefined;
          return;
        }

        var nextPromise = _this2._runSplices(repeat, repeat.__array, queuedSplices) || Promise.resolve();
        queuedSplices = repeat.__queuedSplices = [];
        nextPromise.then(runQueuedSplices);
      };

      maybePromise.then(runQueuedSplices);
    }
  };

  ArrayRepeatStrategy.prototype._runSplices = function _runSplices(repeat, array, splices) {
    var _this3 = this;

    var removeDelta = 0;
    var rmPromises = [];

    for (var i = 0, ii = splices.length; i < ii; ++i) {
      var splice = splices[i];
      var removed = splice.removed;

      for (var j = 0, jj = removed.length; j < jj; ++j) {
        var viewOrPromise = repeat.removeView(splice.index + removeDelta + rmPromises.length, true);
        if (viewOrPromise instanceof Promise) {
          rmPromises.push(viewOrPromise);
        }
      }
      removeDelta -= splice.addedCount;
    }

    if (rmPromises.length > 0) {
      return Promise.all(rmPromises).then(function () {
        var spliceIndexLow = _this3._handleAddedSplices(repeat, array, splices);
        (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), spliceIndexLow);
      });
    }

    var spliceIndexLow = this._handleAddedSplices(repeat, array, splices);
    (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), spliceIndexLow);

    return undefined;
  };

  ArrayRepeatStrategy.prototype._handleAddedSplices = function _handleAddedSplices(repeat, array, splices) {
    var spliceIndex = void 0;
    var spliceIndexLow = void 0;
    var arrayLength = array.length;
    for (var i = 0, ii = splices.length; i < ii; ++i) {
      var splice = splices[i];
      var addIndex = spliceIndex = splice.index;
      var end = splice.index + splice.addedCount;

      if (typeof spliceIndexLow === 'undefined' || spliceIndexLow === null || spliceIndexLow > splice.index) {
        spliceIndexLow = spliceIndex;
      }

      for (; addIndex < end; ++addIndex) {
        var overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, array[addIndex], addIndex, arrayLength);
        repeat.insertView(addIndex, overrideContext.bindingContext, overrideContext);
      }
    }

    return spliceIndexLow;
  };

  return ArrayRepeatStrategy;
}();
});

define('aurelia-templating-resources/dist/commonjs/attr-binding-behavior',['require','exports','module','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AttrBindingBehavior = undefined;

var _aureliaBinding = require('aurelia-binding');



var AttrBindingBehavior = exports.AttrBindingBehavior = function () {
  function AttrBindingBehavior() {
    
  }

  AttrBindingBehavior.prototype.bind = function bind(binding, source) {
    binding.targetObserver = new _aureliaBinding.DataAttributeObserver(binding.target, binding.targetProperty);
  };

  AttrBindingBehavior.prototype.unbind = function unbind(binding, source) {};

  return AttrBindingBehavior;
}();
});

define('aurelia-templating-resources/dist/commonjs/aurelia-hide-style',['require','exports','module','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.aureliaHideClassName = undefined;
exports.injectAureliaHideStyleAtHead = injectAureliaHideStyleAtHead;
exports.injectAureliaHideStyleAtBoundary = injectAureliaHideStyleAtBoundary;

var _aureliaPal = require('aurelia-pal');

var aureliaHideClassName = exports.aureliaHideClassName = 'aurelia-hide';

var aureliaHideClass = '.' + aureliaHideClassName + ' { display:none !important; }';

function injectAureliaHideStyleAtHead() {
  _aureliaPal.DOM.injectStyles(aureliaHideClass);
}

function injectAureliaHideStyleAtBoundary(domBoundary) {
  if (_aureliaPal.FEATURE.shadowDOM && domBoundary && !domBoundary.hasAureliaHideStyle) {
    domBoundary.hasAureliaHideStyle = true;
    _aureliaPal.DOM.injectStyles(aureliaHideClass, domBoundary);
  }
}
});

define('aurelia-templating-resources/dist/commonjs/aurelia-templating-resources',['require','exports','module','aurelia-pal','./compose','./if','./else','./with','./repeat','./show','./hide','./sanitize-html','./replaceable','./focus','aurelia-templating','./css-resource','./html-sanitizer','./attr-binding-behavior','./binding-mode-behaviors','./throttle-binding-behavior','./debounce-binding-behavior','./self-binding-behavior','./signal-binding-behavior','./binding-signaler','./update-trigger-binding-behavior','./abstract-repeater','./repeat-strategy-locator','./html-resource-plugin','./null-repeat-strategy','./array-repeat-strategy','./map-repeat-strategy','./set-repeat-strategy','./number-repeat-strategy','./repeat-utilities','./analyze-view-factory','./aurelia-hide-style'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.viewsRequireLifecycle = exports.unwrapExpression = exports.updateOneTimeBinding = exports.isOneTime = exports.getItemsSourceExpression = exports.updateOverrideContext = exports.createFullOverrideContext = exports.NumberRepeatStrategy = exports.SetRepeatStrategy = exports.MapRepeatStrategy = exports.ArrayRepeatStrategy = exports.NullRepeatStrategy = exports.RepeatStrategyLocator = exports.AbstractRepeater = exports.UpdateTriggerBindingBehavior = exports.BindingSignaler = exports.SignalBindingBehavior = exports.SelfBindingBehavior = exports.DebounceBindingBehavior = exports.ThrottleBindingBehavior = exports.TwoWayBindingBehavior = exports.OneWayBindingBehavior = exports.OneTimeBindingBehavior = exports.AttrBindingBehavior = exports.configure = exports.Focus = exports.Replaceable = exports.SanitizeHTMLValueConverter = exports.HTMLSanitizer = exports.Hide = exports.Show = exports.Repeat = exports.With = exports.Else = exports.If = exports.Compose = undefined;

var _aureliaPal = require('aurelia-pal');

var _compose = require('./compose');

var _if = require('./if');

var _else = require('./else');

var _with = require('./with');

var _repeat = require('./repeat');

var _show = require('./show');

var _hide = require('./hide');

var _sanitizeHtml = require('./sanitize-html');

var _replaceable = require('./replaceable');

var _focus = require('./focus');

var _aureliaTemplating = require('aurelia-templating');

var _cssResource = require('./css-resource');

var _htmlSanitizer = require('./html-sanitizer');

var _attrBindingBehavior = require('./attr-binding-behavior');

var _bindingModeBehaviors = require('./binding-mode-behaviors');

var _throttleBindingBehavior = require('./throttle-binding-behavior');

var _debounceBindingBehavior = require('./debounce-binding-behavior');

var _selfBindingBehavior = require('./self-binding-behavior');

var _signalBindingBehavior = require('./signal-binding-behavior');

var _bindingSignaler = require('./binding-signaler');

var _updateTriggerBindingBehavior = require('./update-trigger-binding-behavior');

var _abstractRepeater = require('./abstract-repeater');

var _repeatStrategyLocator = require('./repeat-strategy-locator');

var _htmlResourcePlugin = require('./html-resource-plugin');

var _nullRepeatStrategy = require('./null-repeat-strategy');

var _arrayRepeatStrategy = require('./array-repeat-strategy');

var _mapRepeatStrategy = require('./map-repeat-strategy');

var _setRepeatStrategy = require('./set-repeat-strategy');

var _numberRepeatStrategy = require('./number-repeat-strategy');

var _repeatUtilities = require('./repeat-utilities');

var _analyzeViewFactory = require('./analyze-view-factory');

var _aureliaHideStyle = require('./aurelia-hide-style');

function configure(config) {
  (0, _aureliaHideStyle.injectAureliaHideStyleAtHead)();

  config.globalResources(_aureliaPal.PLATFORM.moduleName('./compose'), _aureliaPal.PLATFORM.moduleName('./if'), _aureliaPal.PLATFORM.moduleName('./else'), _aureliaPal.PLATFORM.moduleName('./with'), _aureliaPal.PLATFORM.moduleName('./repeat'), _aureliaPal.PLATFORM.moduleName('./show'), _aureliaPal.PLATFORM.moduleName('./hide'), _aureliaPal.PLATFORM.moduleName('./replaceable'), _aureliaPal.PLATFORM.moduleName('./sanitize-html'), _aureliaPal.PLATFORM.moduleName('./focus'), _aureliaPal.PLATFORM.moduleName('./binding-mode-behaviors'), _aureliaPal.PLATFORM.moduleName('./self-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./throttle-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./debounce-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./signal-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./update-trigger-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./attr-binding-behavior'));

  (0, _htmlResourcePlugin.configure)(config);

  var viewEngine = config.container.get(_aureliaTemplating.ViewEngine);
  var styleResourcePlugin = {
    fetch: function fetch(address) {
      var _ref;

      return _ref = {}, _ref[address] = (0, _cssResource._createCSSResource)(address), _ref;
    }
  };
  ['.css', '.less', '.sass', '.scss', '.styl'].forEach(function (ext) {
    return viewEngine.addResourcePlugin(ext, styleResourcePlugin);
  });
}

exports.Compose = _compose.Compose;
exports.If = _if.If;
exports.Else = _else.Else;
exports.With = _with.With;
exports.Repeat = _repeat.Repeat;
exports.Show = _show.Show;
exports.Hide = _hide.Hide;
exports.HTMLSanitizer = _htmlSanitizer.HTMLSanitizer;
exports.SanitizeHTMLValueConverter = _sanitizeHtml.SanitizeHTMLValueConverter;
exports.Replaceable = _replaceable.Replaceable;
exports.Focus = _focus.Focus;
exports.configure = configure;
exports.AttrBindingBehavior = _attrBindingBehavior.AttrBindingBehavior;
exports.OneTimeBindingBehavior = _bindingModeBehaviors.OneTimeBindingBehavior;
exports.OneWayBindingBehavior = _bindingModeBehaviors.OneWayBindingBehavior;
exports.TwoWayBindingBehavior = _bindingModeBehaviors.TwoWayBindingBehavior;
exports.ThrottleBindingBehavior = _throttleBindingBehavior.ThrottleBindingBehavior;
exports.DebounceBindingBehavior = _debounceBindingBehavior.DebounceBindingBehavior;
exports.SelfBindingBehavior = _selfBindingBehavior.SelfBindingBehavior;
exports.SignalBindingBehavior = _signalBindingBehavior.SignalBindingBehavior;
exports.BindingSignaler = _bindingSignaler.BindingSignaler;
exports.UpdateTriggerBindingBehavior = _updateTriggerBindingBehavior.UpdateTriggerBindingBehavior;
exports.AbstractRepeater = _abstractRepeater.AbstractRepeater;
exports.RepeatStrategyLocator = _repeatStrategyLocator.RepeatStrategyLocator;
exports.NullRepeatStrategy = _nullRepeatStrategy.NullRepeatStrategy;
exports.ArrayRepeatStrategy = _arrayRepeatStrategy.ArrayRepeatStrategy;
exports.MapRepeatStrategy = _mapRepeatStrategy.MapRepeatStrategy;
exports.SetRepeatStrategy = _setRepeatStrategy.SetRepeatStrategy;
exports.NumberRepeatStrategy = _numberRepeatStrategy.NumberRepeatStrategy;
exports.createFullOverrideContext = _repeatUtilities.createFullOverrideContext;
exports.updateOverrideContext = _repeatUtilities.updateOverrideContext;
exports.getItemsSourceExpression = _repeatUtilities.getItemsSourceExpression;
exports.isOneTime = _repeatUtilities.isOneTime;
exports.updateOneTimeBinding = _repeatUtilities.updateOneTimeBinding;
exports.unwrapExpression = _repeatUtilities.unwrapExpression;
exports.viewsRequireLifecycle = _analyzeViewFactory.viewsRequireLifecycle;
});

define('aurelia-templating-resources/dist/commonjs/binding-mode-behaviors',['require','exports','module','aurelia-binding','aurelia-metadata'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TwoWayBindingBehavior = exports.OneWayBindingBehavior = exports.OneTimeBindingBehavior = undefined;

var _dec, _class, _dec2, _class2, _dec3, _class3;

var _aureliaBinding = require('aurelia-binding');

var _aureliaMetadata = require('aurelia-metadata');



var modeBindingBehavior = {
  bind: function bind(binding, source, lookupFunctions) {
    binding.originalMode = binding.mode;
    binding.mode = this.mode;
  },
  unbind: function unbind(binding, source) {
    binding.mode = binding.originalMode;
    binding.originalMode = null;
  }
};

var OneTimeBindingBehavior = exports.OneTimeBindingBehavior = (_dec = (0, _aureliaMetadata.mixin)(modeBindingBehavior), _dec(_class = function OneTimeBindingBehavior() {
  

  this.mode = _aureliaBinding.bindingMode.oneTime;
}) || _class);
var OneWayBindingBehavior = exports.OneWayBindingBehavior = (_dec2 = (0, _aureliaMetadata.mixin)(modeBindingBehavior), _dec2(_class2 = function OneWayBindingBehavior() {
  

  this.mode = _aureliaBinding.bindingMode.oneWay;
}) || _class2);
var TwoWayBindingBehavior = exports.TwoWayBindingBehavior = (_dec3 = (0, _aureliaMetadata.mixin)(modeBindingBehavior), _dec3(_class3 = function TwoWayBindingBehavior() {
  

  this.mode = _aureliaBinding.bindingMode.twoWay;
}) || _class3);
});

define('aurelia-templating-resources/dist/commonjs/binding-signaler',['require','exports','module','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BindingSignaler = undefined;

var _aureliaBinding = require('aurelia-binding');



var BindingSignaler = exports.BindingSignaler = function () {
  function BindingSignaler() {
    

    this.signals = {};
  }

  BindingSignaler.prototype.signal = function signal(name) {
    var bindings = this.signals[name];
    if (!bindings) {
      return;
    }
    var i = bindings.length;
    while (i--) {
      bindings[i].call(_aureliaBinding.sourceContext);
    }
  };

  return BindingSignaler;
}();
});

define('aurelia-templating-resources/dist/commonjs/compose',['require','exports','module','aurelia-dependency-injection','aurelia-logging','aurelia-task-queue','aurelia-templating','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Compose = undefined;

var _dec, _dec2, _class, _desc, _value, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaLogging = require('aurelia-logging');

var LogManager = _interopRequireWildcard(_aureliaLogging);

var _aureliaTaskQueue = require('aurelia-task-queue');

var _aureliaTemplating = require('aurelia-templating');

var _aureliaPal = require('aurelia-pal');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}



function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var logger = LogManager.getLogger('templating-resources');

var Compose = exports.Compose = (_dec = (0, _aureliaTemplating.customElement)('compose'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element, _aureliaDependencyInjection.Container, _aureliaTemplating.CompositionEngine, _aureliaTemplating.ViewSlot, _aureliaTemplating.ViewResources, _aureliaTaskQueue.TaskQueue), _dec(_class = (0, _aureliaTemplating.noView)(_class = _dec2(_class = (_class2 = function () {
  function Compose(element, container, compositionEngine, viewSlot, viewResources, taskQueue) {
    

    _initDefineProp(this, 'model', _descriptor, this);

    _initDefineProp(this, 'view', _descriptor2, this);

    _initDefineProp(this, 'viewModel', _descriptor3, this);

    _initDefineProp(this, 'swapOrder', _descriptor4, this);

    this.element = element;
    this.container = container;
    this.compositionEngine = compositionEngine;
    this.viewSlot = viewSlot;
    this.viewResources = viewResources;
    this.taskQueue = taskQueue;
    this.currentController = null;
    this.currentViewModel = null;
    this.changes = Object.create(null);
  }

  Compose.prototype.created = function created(owningView) {
    this.owningView = owningView;
  };

  Compose.prototype.bind = function bind(bindingContext, overrideContext) {
    this.bindingContext = bindingContext;
    this.overrideContext = overrideContext;
    this.changes.view = this.view;
    this.changes.viewModel = this.viewModel;
    this.changes.model = this.model;
    processChanges(this);
  };

  Compose.prototype.unbind = function unbind() {
    this.changes = Object.create(null);
    this.pendingTask = null;
    this.bindingContext = null;
    this.overrideContext = null;
    var returnToCache = true;
    var skipAnimation = true;
    this.viewSlot.removeAll(returnToCache, skipAnimation);
  };

  Compose.prototype.modelChanged = function modelChanged(newValue, oldValue) {
    this.changes.model = newValue;
    requestUpdate(this);
  };

  Compose.prototype.viewChanged = function viewChanged(newValue, oldValue) {
    this.changes.view = newValue;
    requestUpdate(this);
  };

  Compose.prototype.viewModelChanged = function viewModelChanged(newValue, oldValue) {
    this.changes.viewModel = newValue;
    requestUpdate(this);
  };

  return Compose;
}(), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'model', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'view', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, 'viewModel', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, 'swapOrder', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
})), _class2)) || _class) || _class) || _class);


function isEmpty(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
}

function tryActivateViewModel(vm, model) {
  if (vm && typeof vm.activate === 'function') {
    return Promise.resolve(vm.activate(model));
  }
}

function createInstruction(composer, instruction) {
  return Object.assign(instruction, {
    bindingContext: composer.bindingContext,
    overrideContext: composer.overrideContext,
    owningView: composer.owningView,
    container: composer.container,
    viewSlot: composer.viewSlot,
    viewResources: composer.viewResources,
    currentController: composer.currentController,
    host: composer.element,
    swapOrder: composer.swapOrder
  });
}

function processChanges(composer) {
  var changes = composer.changes;
  composer.changes = Object.create(null);

  if (!('view' in changes) && !('viewModel' in changes) && 'model' in changes) {
    composer.pendingTask = tryActivateViewModel(composer.currentViewModel, changes.model);
    if (!composer.pendingTask) {
      return;
    }
  } else {
    var instruction = {
      view: composer.view,
      viewModel: composer.currentViewModel || composer.viewModel,
      model: composer.model
    };

    instruction = Object.assign(instruction, changes);

    instruction = createInstruction(composer, instruction);
    composer.pendingTask = composer.compositionEngine.compose(instruction).then(function (controller) {
      composer.currentController = controller;
      composer.currentViewModel = controller ? controller.viewModel : null;
    });
  }

  composer.pendingTask = composer.pendingTask.catch(function (e) {
    logger.error(e);
  }).then(function () {
    if (!composer.pendingTask) {
      return;
    }

    composer.pendingTask = null;
    if (!isEmpty(composer.changes)) {
      processChanges(composer);
    }
  });
}

function requestUpdate(composer) {
  if (composer.pendingTask || composer.updateRequested) {
    return;
  }
  composer.updateRequested = true;
  composer.taskQueue.queueMicroTask(function () {
    composer.updateRequested = false;
    processChanges(composer);
  });
}
});

define('aurelia-templating-resources/dist/commonjs/css-resource',['require','exports','module','aurelia-templating','aurelia-loader','aurelia-dependency-injection','aurelia-path','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._createCSSResource = _createCSSResource;

var _aureliaTemplating = require('aurelia-templating');

var _aureliaLoader = require('aurelia-loader');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaPath = require('aurelia-path');

var _aureliaPal = require('aurelia-pal');

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var cssUrlMatcher = /url\((?!['"]data)([^)]+)\)/gi;

function fixupCSSUrls(address, css) {
  if (typeof css !== 'string') {
    throw new Error('Failed loading required CSS file: ' + address);
  }
  return css.replace(cssUrlMatcher, function (match, p1) {
    var quote = p1.charAt(0);
    if (quote === '\'' || quote === '"') {
      p1 = p1.substr(1, p1.length - 2);
    }
    return 'url(\'' + (0, _aureliaPath.relativeToFile)(p1, address) + '\')';
  });
}

var CSSResource = function () {
  function CSSResource(address) {
    

    this.address = address;
    this._scoped = null;
    this._global = false;
    this._alreadyGloballyInjected = false;
  }

  CSSResource.prototype.initialize = function initialize(container, target) {
    this._scoped = new target(this);
  };

  CSSResource.prototype.register = function register(registry, name) {
    if (name === 'scoped') {
      registry.registerViewEngineHooks(this._scoped);
    } else {
      this._global = true;
    }
  };

  CSSResource.prototype.load = function load(container) {
    var _this = this;

    return container.get(_aureliaLoader.Loader).loadText(this.address).catch(function (err) {
      return null;
    }).then(function (text) {
      text = fixupCSSUrls(_this.address, text);
      _this._scoped.css = text;
      if (_this._global) {
        _this._alreadyGloballyInjected = true;
        _aureliaPal.DOM.injectStyles(text);
      }
    });
  };

  return CSSResource;
}();

var CSSViewEngineHooks = function () {
  function CSSViewEngineHooks(owner) {
    

    this.owner = owner;
    this.css = null;
  }

  CSSViewEngineHooks.prototype.beforeCompile = function beforeCompile(content, resources, instruction) {
    if (instruction.targetShadowDOM) {
      _aureliaPal.DOM.injectStyles(this.css, content, true);
    } else if (_aureliaPal.FEATURE.scopedCSS) {
      var styleNode = _aureliaPal.DOM.injectStyles(this.css, content, true);
      styleNode.setAttribute('scoped', 'scoped');
    } else if (this._global && !this.owner._alreadyGloballyInjected) {
      _aureliaPal.DOM.injectStyles(this.css);
      this.owner._alreadyGloballyInjected = true;
    }
  };

  return CSSViewEngineHooks;
}();

function _createCSSResource(address) {
  var _dec, _class;

  var ViewCSS = (_dec = (0, _aureliaTemplating.resource)(new CSSResource(address)), _dec(_class = function (_CSSViewEngineHooks) {
    _inherits(ViewCSS, _CSSViewEngineHooks);

    function ViewCSS() {
      

      return _possibleConstructorReturn(this, _CSSViewEngineHooks.apply(this, arguments));
    }

    return ViewCSS;
  }(CSSViewEngineHooks)) || _class);

  return ViewCSS;
}
});

define('aurelia-templating-resources/dist/commonjs/debounce-binding-behavior',['require','exports','module','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebounceBindingBehavior = undefined;

var _aureliaBinding = require('aurelia-binding');



var unset = {};

function debounceCallSource(event) {
  var _this = this;

  var state = this.debounceState;
  clearTimeout(state.timeoutId);
  state.timeoutId = setTimeout(function () {
    return _this.debouncedMethod(event);
  }, state.delay);
}

function debounceCall(context, newValue, oldValue) {
  var _this2 = this;

  var state = this.debounceState;
  clearTimeout(state.timeoutId);
  if (context !== state.callContextToDebounce) {
    state.oldValue = unset;
    this.debouncedMethod(context, newValue, oldValue);
    return;
  }
  if (state.oldValue === unset) {
    state.oldValue = oldValue;
  }
  state.timeoutId = setTimeout(function () {
    var ov = state.oldValue;
    state.oldValue = unset;
    _this2.debouncedMethod(context, newValue, ov);
  }, state.delay);
}

var DebounceBindingBehavior = exports.DebounceBindingBehavior = function () {
  function DebounceBindingBehavior() {
    
  }

  DebounceBindingBehavior.prototype.bind = function bind(binding, source) {
    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;

    var isCallSource = binding.callSource !== undefined;
    var methodToDebounce = isCallSource ? 'callSource' : 'call';
    var debouncer = isCallSource ? debounceCallSource : debounceCall;
    var mode = binding.mode;
    var callContextToDebounce = mode === _aureliaBinding.bindingMode.twoWay || mode === _aureliaBinding.bindingMode.fromView ? _aureliaBinding.targetContext : _aureliaBinding.sourceContext;

    binding.debouncedMethod = binding[methodToDebounce];
    binding.debouncedMethod.originalName = methodToDebounce;

    binding[methodToDebounce] = debouncer;

    binding.debounceState = {
      callContextToDebounce: callContextToDebounce,
      delay: delay,
      timeoutId: 0,
      oldValue: unset
    };
  };

  DebounceBindingBehavior.prototype.unbind = function unbind(binding, source) {
    var methodToRestore = binding.debouncedMethod.originalName;
    binding[methodToRestore] = binding.debouncedMethod;
    binding.debouncedMethod = null;
    clearTimeout(binding.debounceState.timeoutId);
    binding.debounceState = null;
  };

  return DebounceBindingBehavior;
}();
});

define('aurelia-templating-resources/dist/commonjs/dynamic-element',['require','exports','module','aurelia-templating'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._createDynamicElement = _createDynamicElement;

var _aureliaTemplating = require('aurelia-templating');



function _createDynamicElement(name, viewUrl, bindableNames) {
  var _dec, _dec2, _class;

  var DynamicElement = (_dec = (0, _aureliaTemplating.customElement)(name), _dec2 = (0, _aureliaTemplating.useView)(viewUrl), _dec(_class = _dec2(_class = function () {
    function DynamicElement() {
      
    }

    DynamicElement.prototype.bind = function bind(bindingContext) {
      this.$parent = bindingContext;
    };

    return DynamicElement;
  }()) || _class) || _class);

  for (var i = 0, ii = bindableNames.length; i < ii; ++i) {
    (0, _aureliaTemplating.bindable)(bindableNames[i])(DynamicElement);
  }
  return DynamicElement;
}
});

define('aurelia-templating-resources/dist/commonjs/else',['require','exports','module','aurelia-templating','aurelia-dependency-injection','./if-core'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Else = undefined;

var _dec, _dec2, _class;

var _aureliaTemplating = require('aurelia-templating');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _ifCore = require('./if-core');



function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Else = exports.Else = (_dec = (0, _aureliaTemplating.customAttribute)('else'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = function (_IfCore) {
  _inherits(Else, _IfCore);

  function Else(viewFactory, viewSlot) {
    

    var _this = _possibleConstructorReturn(this, _IfCore.call(this, viewFactory, viewSlot));

    _this._registerInIf();
    return _this;
  }

  Else.prototype.bind = function bind(bindingContext, overrideContext) {
    _IfCore.prototype.bind.call(this, bindingContext, overrideContext);

    if (this.ifVm.condition) {
      this._hide();
    } else {
      this._show();
    }
  };

  Else.prototype._registerInIf = function _registerInIf() {
    var previous = this.viewSlot.anchor.previousSibling;
    while (previous && !previous.au) {
      previous = previous.previousSibling;
    }
    if (!previous || !previous.au.if) {
      throw new Error("Can't find matching If for Else custom attribute.");
    }
    this.ifVm = previous.au.if.viewModel;
    this.ifVm.elseVm = this;
  };

  return Else;
}(_ifCore.IfCore)) || _class) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/focus',['require','exports','module','aurelia-templating','aurelia-binding','aurelia-dependency-injection','aurelia-task-queue','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Focus = undefined;

var _dec, _dec2, _class;

var _aureliaTemplating = require('aurelia-templating');

var _aureliaBinding = require('aurelia-binding');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaTaskQueue = require('aurelia-task-queue');

var _aureliaPal = require('aurelia-pal');



var Focus = exports.Focus = (_dec = (0, _aureliaTemplating.customAttribute)('focus', _aureliaBinding.bindingMode.twoWay), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element, _aureliaTaskQueue.TaskQueue), _dec(_class = _dec2(_class = function () {
  function Focus(element, taskQueue) {
    

    this.element = element;
    this.taskQueue = taskQueue;
    this.isAttached = false;
    this.needsApply = false;
  }

  Focus.prototype.valueChanged = function valueChanged(newValue) {
    if (this.isAttached) {
      this._apply();
    } else {
      this.needsApply = true;
    }
  };

  Focus.prototype._apply = function _apply() {
    var _this = this;

    if (this.value) {
      this.taskQueue.queueMicroTask(function () {
        if (_this.value) {
          _this.element.focus();
        }
      });
    } else {
      this.element.blur();
    }
  };

  Focus.prototype.attached = function attached() {
    this.isAttached = true;
    if (this.needsApply) {
      this.needsApply = false;
      this._apply();
    }
    this.element.addEventListener('focus', this);
    this.element.addEventListener('blur', this);
  };

  Focus.prototype.detached = function detached() {
    this.isAttached = false;
    this.element.removeEventListener('focus', this);
    this.element.removeEventListener('blur', this);
  };

  Focus.prototype.handleEvent = function handleEvent(e) {
    if (e.type === 'focus') {
      this.value = true;
    } else if (_aureliaPal.DOM.activeElement !== this.element) {
      this.value = false;
    }
  };

  return Focus;
}()) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/hide',['require','exports','module','aurelia-dependency-injection','aurelia-templating','aurelia-pal','./aurelia-hide-style'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Hide = undefined;

var _dec, _dec2, _class;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaTemplating = require('aurelia-templating');

var _aureliaPal = require('aurelia-pal');

var _aureliaHideStyle = require('./aurelia-hide-style');



var Hide = exports.Hide = (_dec = (0, _aureliaTemplating.customAttribute)('hide'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element, _aureliaTemplating.Animator, _aureliaDependencyInjection.Optional.of(_aureliaPal.DOM.boundary, true)), _dec(_class = _dec2(_class = function () {
  function Hide(element, animator, domBoundary) {
    

    this.element = element;
    this.animator = animator;
    this.domBoundary = domBoundary;
  }

  Hide.prototype.created = function created() {
    (0, _aureliaHideStyle.injectAureliaHideStyleAtBoundary)(this.domBoundary);
  };

  Hide.prototype.valueChanged = function valueChanged(newValue) {
    if (newValue) {
      this.animator.addClass(this.element, _aureliaHideStyle.aureliaHideClassName);
    } else {
      this.animator.removeClass(this.element, _aureliaHideStyle.aureliaHideClassName);
    }
  };

  Hide.prototype.bind = function bind(bindingContext) {
    this.valueChanged(this.value);
  };

  return Hide;
}()) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/html-resource-plugin',['require','exports','module','aurelia-templating','./dynamic-element'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getElementName = getElementName;
exports.configure = configure;

var _aureliaTemplating = require('aurelia-templating');

var _dynamicElement = require('./dynamic-element');

function getElementName(address) {
  return (/([^\/^\?]+)\.html/i.exec(address)[1].toLowerCase()
  );
}

function configure(config) {
  var viewEngine = config.container.get(_aureliaTemplating.ViewEngine);
  var loader = config.aurelia.loader;

  viewEngine.addResourcePlugin('.html', {
    'fetch': function fetch(address) {
      return loader.loadTemplate(address).then(function (registryEntry) {
        var _ref;

        var bindable = registryEntry.template.getAttribute('bindable');
        var elementName = getElementName(address);

        if (bindable) {
          bindable = bindable.split(',').map(function (x) {
            return x.trim();
          });
          registryEntry.template.removeAttribute('bindable');
        } else {
          bindable = [];
        }

        return _ref = {}, _ref[elementName] = (0, _dynamicElement._createDynamicElement)(elementName, address, bindable), _ref;
      });
    }
  });
}
});

define('aurelia-templating-resources/dist/commonjs/html-sanitizer',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});



var SCRIPT_REGEX = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;

var HTMLSanitizer = exports.HTMLSanitizer = function () {
  function HTMLSanitizer() {
    
  }

  HTMLSanitizer.prototype.sanitize = function sanitize(input) {
    return input.replace(SCRIPT_REGEX, '');
  };

  return HTMLSanitizer;
}();
});

define('aurelia-templating-resources/dist/commonjs/if',['require','exports','module','aurelia-templating','aurelia-dependency-injection','./if-core'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.If = undefined;

var _dec, _dec2, _dec3, _class, _desc, _value, _class2, _descriptor, _descriptor2;

var _aureliaTemplating = require('aurelia-templating');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _ifCore = require('./if-core');

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}



function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var If = exports.If = (_dec = (0, _aureliaTemplating.customAttribute)('if'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot), _dec3 = (0, _aureliaTemplating.bindable)({ primaryProperty: true }), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = (_class2 = function (_IfCore) {
  _inherits(If, _IfCore);

  function If() {
    var _temp, _this, _ret;

    

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _IfCore.call.apply(_IfCore, [this].concat(args))), _this), _initDefineProp(_this, 'condition', _descriptor, _this), _initDefineProp(_this, 'swapOrder', _descriptor2, _this), _temp), _possibleConstructorReturn(_this, _ret);
  }

  If.prototype.bind = function bind(bindingContext, overrideContext) {
    _IfCore.prototype.bind.call(this, bindingContext, overrideContext);
    if (this.condition) {
      this._show();
    } else {
      this._hide();
    }
  };

  If.prototype.conditionChanged = function conditionChanged(newValue) {
    this._update(newValue);
  };

  If.prototype._update = function _update(show) {
    var _this2 = this;

    if (this.animating) {
      return;
    }

    var promise = void 0;
    if (this.elseVm) {
      promise = show ? this._swap(this.elseVm, this) : this._swap(this, this.elseVm);
    } else {
      promise = show ? this._show() : this._hide();
    }

    if (promise) {
      this.animating = true;
      promise.then(function () {
        _this2.animating = false;
        if (_this2.condition !== _this2.showing) {
          _this2._update(_this2.condition);
        }
      });
    }
  };

  If.prototype._swap = function _swap(remove, add) {
    switch (this.swapOrder) {
      case 'before':
        return Promise.resolve(add._show()).then(function () {
          return remove._hide();
        });
      case 'with':
        return Promise.all([remove._hide(), add._show()]);
      default:
        var promise = remove._hide();
        return promise ? promise.then(function () {
          return add._show();
        }) : add._show();
    }
  };

  return If;
}(_ifCore.IfCore), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'condition', [_dec3], {
  enumerable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'swapOrder', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
})), _class2)) || _class) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/if-core',['require','exports','module'],function (require, exports, module) {"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});



var IfCore = exports.IfCore = function () {
  function IfCore(viewFactory, viewSlot) {
    

    this.viewFactory = viewFactory;
    this.viewSlot = viewSlot;
    this.view = null;
    this.bindingContext = null;
    this.overrideContext = null;

    this.showing = false;
  }

  IfCore.prototype.bind = function bind(bindingContext, overrideContext) {
    this.bindingContext = bindingContext;
    this.overrideContext = overrideContext;
  };

  IfCore.prototype.unbind = function unbind() {
    if (this.view === null) {
      return;
    }

    this.view.unbind();

    if (!this.viewFactory.isCaching) {
      return;
    }

    if (this.showing) {
      this.showing = false;
      this.viewSlot.remove(this.view, true, true);
    } else {
      this.view.returnToCache();
    }

    this.view = null;
  };

  IfCore.prototype._show = function _show() {
    if (this.showing) {
      if (!this.view.isBound) {
        this.view.bind(this.bindingContext, this.overrideContext);
      }
      return;
    }

    if (this.view === null) {
      this.view = this.viewFactory.create();
    }

    if (!this.view.isBound) {
      this.view.bind(this.bindingContext, this.overrideContext);
    }

    this.showing = true;
    return this.viewSlot.add(this.view);
  };

  IfCore.prototype._hide = function _hide() {
    var _this = this;

    if (!this.showing) {
      return;
    }

    this.showing = false;
    var removed = this.viewSlot.remove(this.view);

    if (removed instanceof Promise) {
      return removed.then(function () {
        return _this.view.unbind();
      });
    }

    this.view.unbind();
  };

  return IfCore;
}();
});

define('aurelia-templating-resources/dist/commonjs/map-repeat-strategy',['require','exports','module','./repeat-utilities'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MapRepeatStrategy = undefined;

var _repeatUtilities = require('./repeat-utilities');



var MapRepeatStrategy = exports.MapRepeatStrategy = function () {
  function MapRepeatStrategy() {
    
  }

  MapRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {
    return observerLocator.getMapObserver(items);
  };

  MapRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
    var _this = this;

    var removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
    if (removePromise instanceof Promise) {
      removePromise.then(function () {
        return _this._standardProcessItems(repeat, items);
      });
      return;
    }
    this._standardProcessItems(repeat, items);
  };

  MapRepeatStrategy.prototype._standardProcessItems = function _standardProcessItems(repeat, items) {
    var index = 0;
    var overrideContext = void 0;

    items.forEach(function (value, key) {
      overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, value, index, items.size, key);
      repeat.addView(overrideContext.bindingContext, overrideContext);
      ++index;
    });
  };

  MapRepeatStrategy.prototype.instanceMutated = function instanceMutated(repeat, map, records) {
    var key = void 0;
    var i = void 0;
    var ii = void 0;
    var overrideContext = void 0;
    var removeIndex = void 0;
    var addIndex = void 0;
    var record = void 0;
    var rmPromises = [];
    var viewOrPromise = void 0;

    for (i = 0, ii = records.length; i < ii; ++i) {
      record = records[i];
      key = record.key;
      switch (record.type) {
        case 'update':
          removeIndex = this._getViewIndexByKey(repeat, key);
          viewOrPromise = repeat.removeView(removeIndex, true, !repeat.viewsRequireLifecycle);
          if (viewOrPromise instanceof Promise) {
            rmPromises.push(viewOrPromise);
          }
          overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, map.get(key), removeIndex, map.size, key);
          repeat.insertView(removeIndex, overrideContext.bindingContext, overrideContext);
          break;
        case 'add':
          addIndex = repeat.viewCount() <= map.size - 1 ? repeat.viewCount() : map.size - 1;
          overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, map.get(key), addIndex, map.size, key);
          repeat.insertView(map.size - 1, overrideContext.bindingContext, overrideContext);
          break;
        case 'delete':
          if (record.oldValue === undefined) {
            return;
          }
          removeIndex = this._getViewIndexByKey(repeat, key);
          viewOrPromise = repeat.removeView(removeIndex, true, !repeat.viewsRequireLifecycle);
          if (viewOrPromise instanceof Promise) {
            rmPromises.push(viewOrPromise);
          }
          break;
        case 'clear':
          repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
          break;
        default:
          continue;
      }
    }

    if (rmPromises.length > 0) {
      Promise.all(rmPromises).then(function () {
        (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
      });
    } else {
      (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
    }
  };

  MapRepeatStrategy.prototype._getViewIndexByKey = function _getViewIndexByKey(repeat, key) {
    var i = void 0;
    var ii = void 0;
    var child = void 0;

    for (i = 0, ii = repeat.viewCount(); i < ii; ++i) {
      child = repeat.view(i);
      if (child.bindingContext[repeat.key] === key) {
        return i;
      }
    }

    return undefined;
  };

  return MapRepeatStrategy;
}();
});

define('aurelia-templating-resources/dist/commonjs/null-repeat-strategy',['require','exports','module'],function (require, exports, module) {"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});



var NullRepeatStrategy = exports.NullRepeatStrategy = function () {
  function NullRepeatStrategy() {
    
  }

  NullRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
    repeat.removeAllViews(true);
  };

  NullRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {};

  return NullRepeatStrategy;
}();
});

define('aurelia-templating-resources/dist/commonjs/number-repeat-strategy',['require','exports','module','./repeat-utilities'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NumberRepeatStrategy = undefined;

var _repeatUtilities = require('./repeat-utilities');



var NumberRepeatStrategy = exports.NumberRepeatStrategy = function () {
  function NumberRepeatStrategy() {
    
  }

  NumberRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver() {
    return null;
  };

  NumberRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, value) {
    var _this = this;

    var removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
    if (removePromise instanceof Promise) {
      removePromise.then(function () {
        return _this._standardProcessItems(repeat, value);
      });
      return;
    }
    this._standardProcessItems(repeat, value);
  };

  NumberRepeatStrategy.prototype._standardProcessItems = function _standardProcessItems(repeat, value) {
    var childrenLength = repeat.viewCount();
    var i = void 0;
    var ii = void 0;
    var overrideContext = void 0;
    var viewsToRemove = void 0;

    value = Math.floor(value);
    viewsToRemove = childrenLength - value;

    if (viewsToRemove > 0) {
      if (viewsToRemove > childrenLength) {
        viewsToRemove = childrenLength;
      }

      for (i = 0, ii = viewsToRemove; i < ii; ++i) {
        repeat.removeView(childrenLength - (i + 1), true, !repeat.viewsRequireLifecycle);
      }

      return;
    }

    for (i = childrenLength, ii = value; i < ii; ++i) {
      overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, i, i, ii);
      repeat.addView(overrideContext.bindingContext, overrideContext);
    }

    (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
  };

  return NumberRepeatStrategy;
}();
});

define('aurelia-templating-resources/dist/commonjs/repeat',['require','exports','module','aurelia-dependency-injection','aurelia-binding','aurelia-templating','./repeat-strategy-locator','./repeat-utilities','./analyze-view-factory','./abstract-repeater'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Repeat = undefined;

var _dec, _dec2, _class, _desc, _value, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaBinding = require('aurelia-binding');

var _aureliaTemplating = require('aurelia-templating');

var _repeatStrategyLocator = require('./repeat-strategy-locator');

var _repeatUtilities = require('./repeat-utilities');

var _analyzeViewFactory = require('./analyze-view-factory');

var _abstractRepeater = require('./abstract-repeater');

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}



function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var Repeat = exports.Repeat = (_dec = (0, _aureliaTemplating.customAttribute)('repeat'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.TargetInstruction, _aureliaTemplating.ViewSlot, _aureliaTemplating.ViewResources, _aureliaBinding.ObserverLocator, _repeatStrategyLocator.RepeatStrategyLocator), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = (_class2 = function (_AbstractRepeater) {
  _inherits(Repeat, _AbstractRepeater);

  function Repeat(viewFactory, instruction, viewSlot, viewResources, observerLocator, strategyLocator) {
    

    var _this = _possibleConstructorReturn(this, _AbstractRepeater.call(this, {
      local: 'item',
      viewsRequireLifecycle: (0, _analyzeViewFactory.viewsRequireLifecycle)(viewFactory)
    }));

    _initDefineProp(_this, 'items', _descriptor, _this);

    _initDefineProp(_this, 'local', _descriptor2, _this);

    _initDefineProp(_this, 'key', _descriptor3, _this);

    _initDefineProp(_this, 'value', _descriptor4, _this);

    _this.viewFactory = viewFactory;
    _this.instruction = instruction;
    _this.viewSlot = viewSlot;
    _this.lookupFunctions = viewResources.lookupFunctions;
    _this.observerLocator = observerLocator;
    _this.key = 'key';
    _this.value = 'value';
    _this.strategyLocator = strategyLocator;
    _this.ignoreMutation = false;
    _this.sourceExpression = (0, _repeatUtilities.getItemsSourceExpression)(_this.instruction, 'repeat.for');
    _this.isOneTime = (0, _repeatUtilities.isOneTime)(_this.sourceExpression);
    _this.viewsRequireLifecycle = (0, _analyzeViewFactory.viewsRequireLifecycle)(viewFactory);
    return _this;
  }

  Repeat.prototype.call = function call(context, changes) {
    this[context](this.items, changes);
  };

  Repeat.prototype.bind = function bind(bindingContext, overrideContext) {
    this.scope = { bindingContext: bindingContext, overrideContext: overrideContext };
    this.matcherBinding = this._captureAndRemoveMatcherBinding();
    this.itemsChanged();
  };

  Repeat.prototype.unbind = function unbind() {
    this.scope = null;
    this.items = null;
    this.matcherBinding = null;
    this.viewSlot.removeAll(true, true);
    this._unsubscribeCollection();
  };

  Repeat.prototype._unsubscribeCollection = function _unsubscribeCollection() {
    if (this.collectionObserver) {
      this.collectionObserver.unsubscribe(this.callContext, this);
      this.collectionObserver = null;
      this.callContext = null;
    }
  };

  Repeat.prototype.itemsChanged = function itemsChanged() {
    this._unsubscribeCollection();

    if (!this.scope) {
      return;
    }

    var items = this.items;
    this.strategy = this.strategyLocator.getStrategy(items);
    if (!this.strategy) {
      throw new Error('Value for \'' + this.sourceExpression + '\' is non-repeatable');
    }

    if (!this.isOneTime && !this._observeInnerCollection()) {
      this._observeCollection();
    }
    this.strategy.instanceChanged(this, items);
  };

  Repeat.prototype._getInnerCollection = function _getInnerCollection() {
    var expression = (0, _repeatUtilities.unwrapExpression)(this.sourceExpression);
    if (!expression) {
      return null;
    }
    return expression.evaluate(this.scope, null);
  };

  Repeat.prototype.handleCollectionMutated = function handleCollectionMutated(collection, changes) {
    if (!this.collectionObserver) {
      return;
    }
    this.strategy.instanceMutated(this, collection, changes);
  };

  Repeat.prototype.handleInnerCollectionMutated = function handleInnerCollectionMutated(collection, changes) {
    var _this2 = this;

    if (!this.collectionObserver) {
      return;
    }

    if (this.ignoreMutation) {
      return;
    }
    this.ignoreMutation = true;
    var newItems = this.sourceExpression.evaluate(this.scope, this.lookupFunctions);
    this.observerLocator.taskQueue.queueMicroTask(function () {
      return _this2.ignoreMutation = false;
    });

    if (newItems === this.items) {
      this.itemsChanged();
    } else {
      this.items = newItems;
    }
  };

  Repeat.prototype._observeInnerCollection = function _observeInnerCollection() {
    var items = this._getInnerCollection();
    var strategy = this.strategyLocator.getStrategy(items);
    if (!strategy) {
      return false;
    }
    this.collectionObserver = strategy.getCollectionObserver(this.observerLocator, items);
    if (!this.collectionObserver) {
      return false;
    }
    this.callContext = 'handleInnerCollectionMutated';
    this.collectionObserver.subscribe(this.callContext, this);
    return true;
  };

  Repeat.prototype._observeCollection = function _observeCollection() {
    var items = this.items;
    this.collectionObserver = this.strategy.getCollectionObserver(this.observerLocator, items);
    if (this.collectionObserver) {
      this.callContext = 'handleCollectionMutated';
      this.collectionObserver.subscribe(this.callContext, this);
    }
  };

  Repeat.prototype._captureAndRemoveMatcherBinding = function _captureAndRemoveMatcherBinding() {
    if (this.viewFactory.viewFactory) {
      var instructions = this.viewFactory.viewFactory.instructions;
      var instructionIds = Object.keys(instructions);
      for (var i = 0; i < instructionIds.length; i++) {
        var expressions = instructions[instructionIds[i]].expressions;
        if (expressions) {
          for (var ii = 0; i < expressions.length; i++) {
            if (expressions[ii].targetProperty === 'matcher') {
              var matcherBinding = expressions[ii];
              expressions.splice(ii, 1);
              return matcherBinding;
            }
          }
        }
      }
    }

    return undefined;
  };

  Repeat.prototype.viewCount = function viewCount() {
    return this.viewSlot.children.length;
  };

  Repeat.prototype.views = function views() {
    return this.viewSlot.children;
  };

  Repeat.prototype.view = function view(index) {
    return this.viewSlot.children[index];
  };

  Repeat.prototype.matcher = function matcher() {
    return this.matcherBinding ? this.matcherBinding.sourceExpression.evaluate(this.scope, this.matcherBinding.lookupFunctions) : null;
  };

  Repeat.prototype.addView = function addView(bindingContext, overrideContext) {
    var view = this.viewFactory.create();
    view.bind(bindingContext, overrideContext);
    this.viewSlot.add(view);
  };

  Repeat.prototype.insertView = function insertView(index, bindingContext, overrideContext) {
    var view = this.viewFactory.create();
    view.bind(bindingContext, overrideContext);
    this.viewSlot.insert(index, view);
  };

  Repeat.prototype.moveView = function moveView(sourceIndex, targetIndex) {
    this.viewSlot.move(sourceIndex, targetIndex);
  };

  Repeat.prototype.removeAllViews = function removeAllViews(returnToCache, skipAnimation) {
    return this.viewSlot.removeAll(returnToCache, skipAnimation);
  };

  Repeat.prototype.removeViews = function removeViews(viewsToRemove, returnToCache, skipAnimation) {
    return this.viewSlot.removeMany(viewsToRemove, returnToCache, skipAnimation);
  };

  Repeat.prototype.removeView = function removeView(index, returnToCache, skipAnimation) {
    return this.viewSlot.removeAt(index, returnToCache, skipAnimation);
  };

  Repeat.prototype.updateBindings = function updateBindings(view) {
    var j = view.bindings.length;
    while (j--) {
      (0, _repeatUtilities.updateOneTimeBinding)(view.bindings[j]);
    }
    j = view.controllers.length;
    while (j--) {
      var k = view.controllers[j].boundProperties.length;
      while (k--) {
        var binding = view.controllers[j].boundProperties[k].binding;
        (0, _repeatUtilities.updateOneTimeBinding)(binding);
      }
    }
  };

  return Repeat;
}(_abstractRepeater.AbstractRepeater), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'items', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'local', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, 'key', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, 'value', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
})), _class2)) || _class) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/repeat-strategy-locator',['require','exports','module','./null-repeat-strategy','./array-repeat-strategy','./map-repeat-strategy','./set-repeat-strategy','./number-repeat-strategy'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RepeatStrategyLocator = undefined;

var _nullRepeatStrategy = require('./null-repeat-strategy');

var _arrayRepeatStrategy = require('./array-repeat-strategy');

var _mapRepeatStrategy = require('./map-repeat-strategy');

var _setRepeatStrategy = require('./set-repeat-strategy');

var _numberRepeatStrategy = require('./number-repeat-strategy');



var RepeatStrategyLocator = exports.RepeatStrategyLocator = function () {
  function RepeatStrategyLocator() {
    

    this.matchers = [];
    this.strategies = [];

    this.addStrategy(function (items) {
      return items === null || items === undefined;
    }, new _nullRepeatStrategy.NullRepeatStrategy());
    this.addStrategy(function (items) {
      return items instanceof Array;
    }, new _arrayRepeatStrategy.ArrayRepeatStrategy());
    this.addStrategy(function (items) {
      return items instanceof Map;
    }, new _mapRepeatStrategy.MapRepeatStrategy());
    this.addStrategy(function (items) {
      return items instanceof Set;
    }, new _setRepeatStrategy.SetRepeatStrategy());
    this.addStrategy(function (items) {
      return typeof items === 'number';
    }, new _numberRepeatStrategy.NumberRepeatStrategy());
  }

  RepeatStrategyLocator.prototype.addStrategy = function addStrategy(matcher, strategy) {
    this.matchers.push(matcher);
    this.strategies.push(strategy);
  };

  RepeatStrategyLocator.prototype.getStrategy = function getStrategy(items) {
    var matchers = this.matchers;

    for (var i = 0, ii = matchers.length; i < ii; ++i) {
      if (matchers[i](items)) {
        return this.strategies[i];
      }
    }

    return null;
  };

  return RepeatStrategyLocator;
}();
});

define('aurelia-templating-resources/dist/commonjs/repeat-utilities',['require','exports','module','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateOverrideContexts = updateOverrideContexts;
exports.createFullOverrideContext = createFullOverrideContext;
exports.updateOverrideContext = updateOverrideContext;
exports.getItemsSourceExpression = getItemsSourceExpression;
exports.unwrapExpression = unwrapExpression;
exports.isOneTime = isOneTime;
exports.updateOneTimeBinding = updateOneTimeBinding;
exports.indexOf = indexOf;

var _aureliaBinding = require('aurelia-binding');

var oneTime = _aureliaBinding.bindingMode.oneTime;

function updateOverrideContexts(views, startIndex) {
  var length = views.length;

  if (startIndex > 0) {
    startIndex = startIndex - 1;
  }

  for (; startIndex < length; ++startIndex) {
    updateOverrideContext(views[startIndex].overrideContext, startIndex, length);
  }
}

function createFullOverrideContext(repeat, data, index, length, key) {
  var bindingContext = {};
  var overrideContext = (0, _aureliaBinding.createOverrideContext)(bindingContext, repeat.scope.overrideContext);

  if (typeof key !== 'undefined') {
    bindingContext[repeat.key] = key;
    bindingContext[repeat.value] = data;
  } else {
    bindingContext[repeat.local] = data;
  }
  updateOverrideContext(overrideContext, index, length);
  return overrideContext;
}

function updateOverrideContext(overrideContext, index, length) {
  var first = index === 0;
  var last = index === length - 1;
  var even = index % 2 === 0;

  overrideContext.$index = index;
  overrideContext.$first = first;
  overrideContext.$last = last;
  overrideContext.$middle = !(first || last);
  overrideContext.$odd = !even;
  overrideContext.$even = even;
}

function getItemsSourceExpression(instruction, attrName) {
  return instruction.behaviorInstructions.filter(function (bi) {
    return bi.originalAttrName === attrName;
  })[0].attributes.items.sourceExpression;
}

function unwrapExpression(expression) {
  var unwrapped = false;
  while (expression instanceof _aureliaBinding.BindingBehavior) {
    expression = expression.expression;
  }
  while (expression instanceof _aureliaBinding.ValueConverter) {
    expression = expression.expression;
    unwrapped = true;
  }
  return unwrapped ? expression : null;
}

function isOneTime(expression) {
  while (expression instanceof _aureliaBinding.BindingBehavior) {
    if (expression.name === 'oneTime') {
      return true;
    }
    expression = expression.expression;
  }
  return false;
}

function updateOneTimeBinding(binding) {
  if (binding.call && binding.mode === oneTime) {
    binding.call(_aureliaBinding.sourceContext);
  } else if (binding.updateOneTimeBindings) {
    binding.updateOneTimeBindings();
  }
}

function indexOf(array, item, matcher, startIndex) {
  if (!matcher) {
    return array.indexOf(item);
  }
  var length = array.length;
  for (var index = startIndex || 0; index < length; index++) {
    if (matcher(array[index], item)) {
      return index;
    }
  }
  return -1;
}
});

define('aurelia-templating-resources/dist/commonjs/replaceable',['require','exports','module','aurelia-dependency-injection','aurelia-templating'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Replaceable = undefined;

var _dec, _dec2, _class;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaTemplating = require('aurelia-templating');



var Replaceable = exports.Replaceable = (_dec = (0, _aureliaTemplating.customAttribute)('replaceable'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = function () {
  function Replaceable(viewFactory, viewSlot) {
    

    this.viewFactory = viewFactory;
    this.viewSlot = viewSlot;
    this.view = null;
  }

  Replaceable.prototype.bind = function bind(bindingContext, overrideContext) {
    if (this.view === null) {
      this.view = this.viewFactory.create();
      this.viewSlot.add(this.view);
    }

    this.view.bind(bindingContext, overrideContext);
  };

  Replaceable.prototype.unbind = function unbind() {
    this.view.unbind();
  };

  return Replaceable;
}()) || _class) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/sanitize-html',['require','exports','module','aurelia-binding','aurelia-dependency-injection','./html-sanitizer'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SanitizeHTMLValueConverter = undefined;

var _dec, _dec2, _class;

var _aureliaBinding = require('aurelia-binding');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _htmlSanitizer = require('./html-sanitizer');



var SanitizeHTMLValueConverter = exports.SanitizeHTMLValueConverter = (_dec = (0, _aureliaBinding.valueConverter)('sanitizeHTML'), _dec2 = (0, _aureliaDependencyInjection.inject)(_htmlSanitizer.HTMLSanitizer), _dec(_class = _dec2(_class = function () {
  function SanitizeHTMLValueConverter(sanitizer) {
    

    this.sanitizer = sanitizer;
  }

  SanitizeHTMLValueConverter.prototype.toView = function toView(untrustedMarkup) {
    if (untrustedMarkup === null || untrustedMarkup === undefined) {
      return null;
    }

    return this.sanitizer.sanitize(untrustedMarkup);
  };

  return SanitizeHTMLValueConverter;
}()) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/self-binding-behavior',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});



function findOriginalEventTarget(event) {
  return event.path && event.path[0] || event.deepPath && event.deepPath[0] || event.target;
}

function handleSelfEvent(event) {
  var target = findOriginalEventTarget(event);
  if (this.target !== target) return;
  this.selfEventCallSource(event);
}

var SelfBindingBehavior = exports.SelfBindingBehavior = function () {
  function SelfBindingBehavior() {
    
  }

  SelfBindingBehavior.prototype.bind = function bind(binding, source) {
    if (!binding.callSource || !binding.targetEvent) throw new Error('Self binding behavior only supports event.');
    binding.selfEventCallSource = binding.callSource;
    binding.callSource = handleSelfEvent;
  };

  SelfBindingBehavior.prototype.unbind = function unbind(binding, source) {
    binding.callSource = binding.selfEventCallSource;
    binding.selfEventCallSource = null;
  };

  return SelfBindingBehavior;
}();
});

define('aurelia-templating-resources/dist/commonjs/set-repeat-strategy',['require','exports','module','./repeat-utilities'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SetRepeatStrategy = undefined;

var _repeatUtilities = require('./repeat-utilities');



var SetRepeatStrategy = exports.SetRepeatStrategy = function () {
  function SetRepeatStrategy() {
    
  }

  SetRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {
    return observerLocator.getSetObserver(items);
  };

  SetRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
    var _this = this;

    var removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
    if (removePromise instanceof Promise) {
      removePromise.then(function () {
        return _this._standardProcessItems(repeat, items);
      });
      return;
    }
    this._standardProcessItems(repeat, items);
  };

  SetRepeatStrategy.prototype._standardProcessItems = function _standardProcessItems(repeat, items) {
    var index = 0;
    var overrideContext = void 0;

    items.forEach(function (value) {
      overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, value, index, items.size);
      repeat.addView(overrideContext.bindingContext, overrideContext);
      ++index;
    });
  };

  SetRepeatStrategy.prototype.instanceMutated = function instanceMutated(repeat, set, records) {
    var value = void 0;
    var i = void 0;
    var ii = void 0;
    var overrideContext = void 0;
    var removeIndex = void 0;
    var record = void 0;
    var rmPromises = [];
    var viewOrPromise = void 0;

    for (i = 0, ii = records.length; i < ii; ++i) {
      record = records[i];
      value = record.value;
      switch (record.type) {
        case 'add':
          var size = Math.max(set.size - 1, 0);
          overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, value, size, set.size);
          repeat.insertView(size, overrideContext.bindingContext, overrideContext);
          break;
        case 'delete':
          removeIndex = this._getViewIndexByValue(repeat, value);
          viewOrPromise = repeat.removeView(removeIndex, true, !repeat.viewsRequireLifecycle);
          if (viewOrPromise instanceof Promise) {
            rmPromises.push(viewOrPromise);
          }
          break;
        case 'clear':
          repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
          break;
        default:
          continue;
      }
    }

    if (rmPromises.length > 0) {
      Promise.all(rmPromises).then(function () {
        (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
      });
    } else {
      (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
    }
  };

  SetRepeatStrategy.prototype._getViewIndexByValue = function _getViewIndexByValue(repeat, value) {
    var i = void 0;
    var ii = void 0;
    var child = void 0;

    for (i = 0, ii = repeat.viewCount(); i < ii; ++i) {
      child = repeat.view(i);
      if (child.bindingContext[repeat.local] === value) {
        return i;
      }
    }

    return undefined;
  };

  return SetRepeatStrategy;
}();
});

define('aurelia-templating-resources/dist/commonjs/show',['require','exports','module','aurelia-dependency-injection','aurelia-templating','aurelia-pal','./aurelia-hide-style'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Show = undefined;

var _dec, _dec2, _class;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaTemplating = require('aurelia-templating');

var _aureliaPal = require('aurelia-pal');

var _aureliaHideStyle = require('./aurelia-hide-style');



var Show = exports.Show = (_dec = (0, _aureliaTemplating.customAttribute)('show'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element, _aureliaTemplating.Animator, _aureliaDependencyInjection.Optional.of(_aureliaPal.DOM.boundary, true)), _dec(_class = _dec2(_class = function () {
  function Show(element, animator, domBoundary) {
    

    this.element = element;
    this.animator = animator;
    this.domBoundary = domBoundary;
  }

  Show.prototype.created = function created() {
    (0, _aureliaHideStyle.injectAureliaHideStyleAtBoundary)(this.domBoundary);
  };

  Show.prototype.valueChanged = function valueChanged(newValue) {
    if (newValue) {
      this.animator.removeClass(this.element, _aureliaHideStyle.aureliaHideClassName);
    } else {
      this.animator.addClass(this.element, _aureliaHideStyle.aureliaHideClassName);
    }
  };

  Show.prototype.bind = function bind(bindingContext) {
    this.valueChanged(this.value);
  };

  return Show;
}()) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/signal-binding-behavior',['require','exports','module','./binding-signaler'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SignalBindingBehavior = undefined;

var _bindingSignaler = require('./binding-signaler');



var SignalBindingBehavior = exports.SignalBindingBehavior = function () {
  SignalBindingBehavior.inject = function inject() {
    return [_bindingSignaler.BindingSignaler];
  };

  function SignalBindingBehavior(bindingSignaler) {
    

    this.signals = bindingSignaler.signals;
  }

  SignalBindingBehavior.prototype.bind = function bind(binding, source) {
    if (!binding.updateTarget) {
      throw new Error('Only property bindings and string interpolation bindings can be signaled.  Trigger, delegate and call bindings cannot be signaled.');
    }
    if (arguments.length === 3) {
      var name = arguments[2];
      var bindings = this.signals[name] || (this.signals[name] = []);
      bindings.push(binding);
      binding.signalName = name;
    } else if (arguments.length > 3) {
      var names = Array.prototype.slice.call(arguments, 2);
      var i = names.length;
      while (i--) {
        var _name = names[i];
        var _bindings = this.signals[_name] || (this.signals[_name] = []);
        _bindings.push(binding);
      }
      binding.signalName = names;
    } else {
      throw new Error('Signal name is required.');
    }
  };

  SignalBindingBehavior.prototype.unbind = function unbind(binding, source) {
    var name = binding.signalName;
    binding.signalName = null;
    if (Array.isArray(name)) {
      var names = name;
      var i = names.length;
      while (i--) {
        var n = names[i];
        var bindings = this.signals[n];
        bindings.splice(bindings.indexOf(binding), 1);
      }
    } else {
      var _bindings2 = this.signals[name];
      _bindings2.splice(_bindings2.indexOf(binding), 1);
    }
  };

  return SignalBindingBehavior;
}();
});

define('aurelia-templating-resources/dist/commonjs/throttle-binding-behavior',['require','exports','module','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThrottleBindingBehavior = undefined;

var _aureliaBinding = require('aurelia-binding');



function throttle(newValue) {
  var _this = this;

  var state = this.throttleState;
  var elapsed = +new Date() - state.last;
  if (elapsed >= state.delay) {
    clearTimeout(state.timeoutId);
    state.timeoutId = null;
    state.last = +new Date();
    this.throttledMethod(newValue);
    return;
  }
  state.newValue = newValue;
  if (state.timeoutId === null) {
    state.timeoutId = setTimeout(function () {
      state.timeoutId = null;
      state.last = +new Date();
      _this.throttledMethod(state.newValue);
    }, state.delay - elapsed);
  }
}

var ThrottleBindingBehavior = exports.ThrottleBindingBehavior = function () {
  function ThrottleBindingBehavior() {
    
  }

  ThrottleBindingBehavior.prototype.bind = function bind(binding, source) {
    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;

    var methodToThrottle = 'updateTarget';
    if (binding.callSource) {
      methodToThrottle = 'callSource';
    } else if (binding.updateSource && binding.mode === _aureliaBinding.bindingMode.twoWay) {
      methodToThrottle = 'updateSource';
    }

    binding.throttledMethod = binding[methodToThrottle];
    binding.throttledMethod.originalName = methodToThrottle;

    binding[methodToThrottle] = throttle;

    binding.throttleState = {
      delay: delay,
      last: 0,
      timeoutId: null
    };
  };

  ThrottleBindingBehavior.prototype.unbind = function unbind(binding, source) {
    var methodToRestore = binding.throttledMethod.originalName;
    binding[methodToRestore] = binding.throttledMethod;
    binding.throttledMethod = null;
    clearTimeout(binding.throttleState.timeoutId);
    binding.throttleState = null;
  };

  return ThrottleBindingBehavior;
}();
});

define('aurelia-templating-resources/dist/commonjs/update-trigger-binding-behavior',['require','exports','module','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UpdateTriggerBindingBehavior = undefined;

var _aureliaBinding = require('aurelia-binding');



var eventNamesRequired = 'The updateTrigger binding behavior requires at least one event name argument: eg <input value.bind="firstName & updateTrigger:\'blur\'">';
var notApplicableMessage = 'The updateTrigger binding behavior can only be applied to two-way/ from-view bindings on input/select elements.';

var UpdateTriggerBindingBehavior = exports.UpdateTriggerBindingBehavior = function () {
  function UpdateTriggerBindingBehavior() {
    
  }

  UpdateTriggerBindingBehavior.prototype.bind = function bind(binding, source) {
    for (var _len = arguments.length, events = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      events[_key - 2] = arguments[_key];
    }

    if (events.length === 0) {
      throw new Error(eventNamesRequired);
    }
    if (binding.mode !== _aureliaBinding.bindingMode.twoWay && binding.mode !== _aureliaBinding.bindingMode.fromView) {
      throw new Error(notApplicableMessage);
    }

    var targetObserver = binding.observerLocator.getObserver(binding.target, binding.targetProperty);
    if (!targetObserver.handler) {
      throw new Error(notApplicableMessage);
    }
    binding.targetObserver = targetObserver;

    targetObserver.originalHandler = binding.targetObserver.handler;

    var handler = new _aureliaBinding.EventSubscriber(events);
    targetObserver.handler = handler;
  };

  UpdateTriggerBindingBehavior.prototype.unbind = function unbind(binding, source) {
    binding.targetObserver.handler.dispose();
    binding.targetObserver.handler = binding.targetObserver.originalHandler;
    binding.targetObserver.originalHandler = null;
  };

  return UpdateTriggerBindingBehavior;
}();
});

define('aurelia-templating-resources/dist/commonjs/with',['require','exports','module','aurelia-dependency-injection','aurelia-templating','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.With = undefined;

var _dec, _dec2, _class;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaTemplating = require('aurelia-templating');

var _aureliaBinding = require('aurelia-binding');



var With = exports.With = (_dec = (0, _aureliaTemplating.customAttribute)('with'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = function () {
  function With(viewFactory, viewSlot) {
    

    this.viewFactory = viewFactory;
    this.viewSlot = viewSlot;
    this.parentOverrideContext = null;
    this.view = null;
  }

  With.prototype.bind = function bind(bindingContext, overrideContext) {
    this.parentOverrideContext = overrideContext;
    this.valueChanged(this.value);
  };

  With.prototype.valueChanged = function valueChanged(newValue) {
    var overrideContext = (0, _aureliaBinding.createOverrideContext)(newValue, this.parentOverrideContext);
    if (!this.view) {
      this.view = this.viewFactory.create();
      this.view.bind(newValue, overrideContext);
      this.viewSlot.add(this.view);
    } else {
      this.view.bind(newValue, overrideContext);
    }
  };

  With.prototype.unbind = function unbind() {
    this.parentOverrideContext = null;

    if (this.view) {
      this.view.unbind();
    }
  };

  return With;
}()) || _class) || _class) || _class);
});

define('aurelia-templating-router/dist/commonjs/aurelia-templating-router',['require','exports','module','aurelia-pal','aurelia-router','./route-loader','./router-view','./route-href'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configure = exports.RouteHref = exports.RouterView = exports.TemplatingRouteLoader = undefined;

var _aureliaPal = require('aurelia-pal');

var _aureliaRouter = require('aurelia-router');

var _routeLoader = require('./route-loader');

var _routerView = require('./router-view');

var _routeHref = require('./route-href');

function configure(config) {
  config.singleton(_aureliaRouter.RouteLoader, _routeLoader.TemplatingRouteLoader).singleton(_aureliaRouter.Router, _aureliaRouter.AppRouter).globalResources(_aureliaPal.PLATFORM.moduleName('./router-view'), _aureliaPal.PLATFORM.moduleName('./route-href'));

  config.container.registerAlias(_aureliaRouter.Router, _aureliaRouter.AppRouter);
}

exports.TemplatingRouteLoader = _routeLoader.TemplatingRouteLoader;
exports.RouterView = _routerView.RouterView;
exports.RouteHref = _routeHref.RouteHref;
exports.configure = configure;
});

define('aurelia-templating-router/dist/commonjs/route-href',['require','exports','module','aurelia-templating','aurelia-dependency-injection','aurelia-router','aurelia-pal','aurelia-logging'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RouteHref = undefined;

var _dec, _dec2, _dec3, _dec4, _dec5, _class;

var _aureliaTemplating = require('aurelia-templating');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaRouter = require('aurelia-router');

var _aureliaPal = require('aurelia-pal');

var _aureliaLogging = require('aurelia-logging');

var LogManager = _interopRequireWildcard(_aureliaLogging);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }



var logger = LogManager.getLogger('route-href');

var RouteHref = exports.RouteHref = (_dec = (0, _aureliaTemplating.customAttribute)('route-href'), _dec2 = (0, _aureliaTemplating.bindable)({ name: 'route', changeHandler: 'processChange', primaryProperty: true }), _dec3 = (0, _aureliaTemplating.bindable)({ name: 'params', changeHandler: 'processChange' }), _dec4 = (0, _aureliaTemplating.bindable)({ name: 'attribute', defaultValue: 'href' }), _dec5 = (0, _aureliaDependencyInjection.inject)(_aureliaRouter.Router, _aureliaPal.DOM.Element), _dec(_class = _dec2(_class = _dec3(_class = _dec4(_class = _dec5(_class = function () {
  function RouteHref(router, element) {
    

    this.router = router;
    this.element = element;
  }

  RouteHref.prototype.bind = function bind() {
    this.isActive = true;
    this.processChange();
  };

  RouteHref.prototype.unbind = function unbind() {
    this.isActive = false;
  };

  RouteHref.prototype.attributeChanged = function attributeChanged(value, previous) {
    if (previous) {
      this.element.removeAttribute(previous);
    }

    this.processChange();
  };

  RouteHref.prototype.processChange = function processChange() {
    var _this = this;

    return this.router.ensureConfigured().then(function () {
      if (!_this.isActive) {
        return null;
      }

      var href = _this.router.generate(_this.route, _this.params);

      if (_this.element.au.controller) {
        _this.element.au.controller.viewModel[_this.attribute] = href;
      } else {
        _this.element.setAttribute(_this.attribute, href);
      }

      return null;
    }).catch(function (reason) {
      logger.error(reason);
    });
  };

  return RouteHref;
}()) || _class) || _class) || _class) || _class) || _class);
});

define('aurelia-templating-router/dist/commonjs/route-loader',['require','exports','module','aurelia-dependency-injection','aurelia-templating','aurelia-router','aurelia-path','aurelia-metadata','./router-view'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TemplatingRouteLoader = undefined;

var _dec, _class, _dec2, _class2;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaTemplating = require('aurelia-templating');

var _aureliaRouter = require('aurelia-router');

var _aureliaPath = require('aurelia-path');

var _aureliaMetadata = require('aurelia-metadata');

var _routerView = require('./router-view');

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var EmptyClass = (_dec = (0, _aureliaTemplating.inlineView)('<template></template>'), _dec(_class = function EmptyClass() {
  
}) || _class);
var TemplatingRouteLoader = exports.TemplatingRouteLoader = (_dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.CompositionEngine), _dec2(_class2 = function (_RouteLoader) {
  _inherits(TemplatingRouteLoader, _RouteLoader);

  function TemplatingRouteLoader(compositionEngine) {
    

    var _this = _possibleConstructorReturn(this, _RouteLoader.call(this));

    _this.compositionEngine = compositionEngine;
    return _this;
  }

  TemplatingRouteLoader.prototype.loadRoute = function loadRoute(router, config) {
    var childContainer = router.container.createChild();

    var viewModel = void 0;
    if (config.moduleId === null) {
      viewModel = EmptyClass;
    } else if (/\.html/i.test(config.moduleId)) {
      viewModel = createDynamicClass(config.moduleId);
    } else {
      viewModel = (0, _aureliaPath.relativeToFile)(config.moduleId, _aureliaMetadata.Origin.get(router.container.viewModel.constructor).moduleId);
    }

    config = config || {};

    var instruction = {
      viewModel: viewModel,
      childContainer: childContainer,
      view: config.view || config.viewStrategy,
      router: router
    };

    childContainer.registerSingleton(_routerView.RouterViewLocator);

    childContainer.getChildRouter = function () {
      var childRouter = void 0;

      childContainer.registerHandler(_aureliaRouter.Router, function (c) {
        return childRouter || (childRouter = router.createChild(childContainer));
      });

      return childContainer.get(_aureliaRouter.Router);
    };

    return this.compositionEngine.ensureViewModel(instruction);
  };

  return TemplatingRouteLoader;
}(_aureliaRouter.RouteLoader)) || _class2);


function createDynamicClass(moduleId) {
  var _dec3, _dec4, _class3;

  var name = /([^\/^\?]+)\.html/i.exec(moduleId)[1];

  var DynamicClass = (_dec3 = (0, _aureliaTemplating.customElement)(name), _dec4 = (0, _aureliaTemplating.useView)(moduleId), _dec3(_class3 = _dec4(_class3 = function () {
    function DynamicClass() {
      
    }

    DynamicClass.prototype.bind = function bind(bindingContext) {
      this.$parent = bindingContext;
    };

    return DynamicClass;
  }()) || _class3) || _class3);


  return DynamicClass;
}
});

define('aurelia-templating-router/dist/commonjs/router-view',['require','exports','module','aurelia-dependency-injection','aurelia-binding','aurelia-templating','aurelia-router','aurelia-metadata','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RouterViewLocator = exports.RouterView = undefined;

var _dec, _dec2, _class, _desc, _value, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaBinding = require('aurelia-binding');

var _aureliaTemplating = require('aurelia-templating');

var _aureliaRouter = require('aurelia-router');

var _aureliaMetadata = require('aurelia-metadata');

var _aureliaPal = require('aurelia-pal');

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}



function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var RouterView = exports.RouterView = (_dec = (0, _aureliaTemplating.customElement)('router-view'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element, _aureliaDependencyInjection.Container, _aureliaTemplating.ViewSlot, _aureliaRouter.Router, _aureliaTemplating.ViewLocator, _aureliaTemplating.CompositionTransaction, _aureliaTemplating.CompositionEngine), _dec(_class = (0, _aureliaTemplating.noView)(_class = _dec2(_class = (_class2 = function () {
  function RouterView(element, container, viewSlot, router, viewLocator, compositionTransaction, compositionEngine) {
    

    _initDefineProp(this, 'swapOrder', _descriptor, this);

    _initDefineProp(this, 'layoutView', _descriptor2, this);

    _initDefineProp(this, 'layoutViewModel', _descriptor3, this);

    _initDefineProp(this, 'layoutModel', _descriptor4, this);

    this.element = element;
    this.container = container;
    this.viewSlot = viewSlot;
    this.router = router;
    this.viewLocator = viewLocator;
    this.compositionTransaction = compositionTransaction;
    this.compositionEngine = compositionEngine;
    this.router.registerViewPort(this, this.element.getAttribute('name'));

    if (!('initialComposition' in compositionTransaction)) {
      compositionTransaction.initialComposition = true;
      this.compositionTransactionNotifier = compositionTransaction.enlist();
    }
  }

  RouterView.prototype.created = function created(owningView) {
    this.owningView = owningView;
  };

  RouterView.prototype.bind = function bind(bindingContext, overrideContext) {
    this.container.viewModel = bindingContext;
    this.overrideContext = overrideContext;
  };

  RouterView.prototype.process = function process(viewPortInstruction, waitToSwap) {
    var _this = this;

    var component = viewPortInstruction.component;
    var childContainer = component.childContainer;
    var viewModel = component.viewModel;
    var viewModelResource = component.viewModelResource;
    var metadata = viewModelResource.metadata;
    var config = component.router.currentInstruction.config;
    var viewPort = config.viewPorts ? config.viewPorts[viewPortInstruction.name] || {} : {};

    childContainer.get(RouterViewLocator)._notify(this);

    var layoutInstruction = {
      viewModel: viewPort.layoutViewModel || config.layoutViewModel || this.layoutViewModel,
      view: viewPort.layoutView || config.layoutView || this.layoutView,
      model: viewPort.layoutModel || config.layoutModel || this.layoutModel,
      router: viewPortInstruction.component.router,
      childContainer: childContainer,
      viewSlot: this.viewSlot
    };

    var viewStrategy = this.viewLocator.getViewStrategy(component.view || viewModel);
    if (viewStrategy && component.view) {
      viewStrategy.makeRelativeTo(_aureliaMetadata.Origin.get(component.router.container.viewModel.constructor).moduleId);
    }

    return metadata.load(childContainer, viewModelResource.value, null, viewStrategy, true).then(function (viewFactory) {
      if (!_this.compositionTransactionNotifier) {
        _this.compositionTransactionOwnershipToken = _this.compositionTransaction.tryCapture();
      }

      if (layoutInstruction.viewModel || layoutInstruction.view) {
        viewPortInstruction.layoutInstruction = layoutInstruction;
      }

      viewPortInstruction.controller = metadata.create(childContainer, _aureliaTemplating.BehaviorInstruction.dynamic(_this.element, viewModel, viewFactory));

      if (waitToSwap) {
        return null;
      }

      _this.swap(viewPortInstruction);
    });
  };

  RouterView.prototype.swap = function swap(viewPortInstruction) {
    var _this2 = this;

    var layoutInstruction = viewPortInstruction.layoutInstruction;
    var previousView = this.view;

    var work = function work() {
      var swapStrategy = _aureliaTemplating.SwapStrategies[_this2.swapOrder] || _aureliaTemplating.SwapStrategies.after;
      var viewSlot = _this2.viewSlot;

      swapStrategy(viewSlot, previousView, function () {
        return Promise.resolve(viewSlot.add(_this2.view));
      }).then(function () {
        _this2._notify();
      });
    };

    var ready = function ready(owningView) {
      viewPortInstruction.controller.automate(_this2.overrideContext, owningView);
      if (_this2.compositionTransactionOwnershipToken) {
        return _this2.compositionTransactionOwnershipToken.waitForCompositionComplete().then(function () {
          _this2.compositionTransactionOwnershipToken = null;
          return work();
        });
      }

      return work();
    };

    if (layoutInstruction) {
      if (!layoutInstruction.viewModel) {
        layoutInstruction.viewModel = {};
      }

      return this.compositionEngine.createController(layoutInstruction).then(function (controller) {
        _aureliaTemplating.ShadowDOM.distributeView(viewPortInstruction.controller.view, controller.slots || controller.view.slots);
        controller.automate((0, _aureliaBinding.createOverrideContext)(layoutInstruction.viewModel), _this2.owningView);
        controller.view.children.push(viewPortInstruction.controller.view);
        return controller.view || controller;
      }).then(function (newView) {
        _this2.view = newView;
        return ready(newView);
      });
    }

    this.view = viewPortInstruction.controller.view;

    return ready(this.owningView);
  };

  RouterView.prototype._notify = function _notify() {
    if (this.compositionTransactionNotifier) {
      this.compositionTransactionNotifier.done();
      this.compositionTransactionNotifier = null;
    }
  };

  return RouterView;
}(), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'swapOrder', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'layoutView', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, 'layoutViewModel', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, 'layoutModel', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
})), _class2)) || _class) || _class) || _class);

var RouterViewLocator = exports.RouterViewLocator = function () {
  function RouterViewLocator() {
    var _this3 = this;

    

    this.promise = new Promise(function (resolve) {
      return _this3.resolve = resolve;
    });
  }

  RouterViewLocator.prototype.findNearest = function findNearest() {
    return this.promise;
  };

  RouterViewLocator.prototype._notify = function _notify(routerView) {
    this.resolve(routerView);
  };

  return RouterViewLocator;
}();
});

define('aurelia-templating/dist/commonjs/aurelia-templating',['require','exports','module','aurelia-logging','aurelia-metadata','aurelia-pal','aurelia-path','aurelia-loader','aurelia-dependency-injection','aurelia-binding','aurelia-task-queue'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TemplatingEngine = exports.ElementConfigResource = exports.CompositionEngine = exports.SwapStrategies = exports.HtmlBehaviorResource = exports.BindableProperty = exports.BehaviorPropertyObserver = exports.Controller = exports.ViewEngine = exports.ModuleAnalyzer = exports.ResourceDescription = exports.ResourceModule = exports.ViewCompiler = exports.ViewFactory = exports.BoundViewFactory = exports.ViewSlot = exports.View = exports.ViewResources = exports.ShadowDOM = exports.ShadowSlot = exports.PassThroughSlot = exports.SlotCustomAttribute = exports.BindingLanguage = exports.ViewLocator = exports.InlineViewStrategy = exports.TemplateRegistryViewStrategy = exports.NoViewStrategy = exports.ConventionalViewStrategy = exports.RelativeViewStrategy = exports.viewStrategy = exports.TargetInstruction = exports.BehaviorInstruction = exports.ViewCompileInstruction = exports.ResourceLoadContext = exports.ElementEvents = exports.ViewEngineHooksResource = exports.CompositionTransaction = exports.CompositionTransactionOwnershipToken = exports.CompositionTransactionNotifier = exports.Animator = exports.animationEvent = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp, _dec, _class2, _dec2, _class3, _dec3, _class4, _dec4, _class5, _dec5, _class6, _class7, _temp2, _dec6, _class8, _class9, _temp3, _class11, _dec7, _class13, _dec8, _class14, _class15, _temp4, _dec9, _class16, _dec10, _class17, _dec11, _class18;

exports._hyphenate = _hyphenate;
exports._isAllWhitespace = _isAllWhitespace;
exports.viewEngineHooks = viewEngineHooks;
exports.children = children;
exports.child = child;
exports.resource = resource;
exports.behavior = behavior;
exports.customElement = customElement;
exports.customAttribute = customAttribute;
exports.templateController = templateController;
exports.bindable = bindable;
exports.dynamicOptions = dynamicOptions;
exports.useShadowDOM = useShadowDOM;
exports.processAttributes = processAttributes;
exports.processContent = processContent;
exports.containerless = containerless;
exports.useViewStrategy = useViewStrategy;
exports.useView = useView;
exports.inlineView = inlineView;
exports.noView = noView;
exports.elementConfig = elementConfig;
exports.viewResources = viewResources;

var _aureliaLogging = require('aurelia-logging');

var LogManager = _interopRequireWildcard(_aureliaLogging);

var _aureliaMetadata = require('aurelia-metadata');

var _aureliaPal = require('aurelia-pal');

var _aureliaPath = require('aurelia-path');

var _aureliaLoader = require('aurelia-loader');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaBinding = require('aurelia-binding');

var _aureliaTaskQueue = require('aurelia-task-queue');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }



var animationEvent = exports.animationEvent = {
  enterBegin: 'animation:enter:begin',
  enterActive: 'animation:enter:active',
  enterDone: 'animation:enter:done',
  enterTimeout: 'animation:enter:timeout',

  leaveBegin: 'animation:leave:begin',
  leaveActive: 'animation:leave:active',
  leaveDone: 'animation:leave:done',
  leaveTimeout: 'animation:leave:timeout',

  staggerNext: 'animation:stagger:next',

  removeClassBegin: 'animation:remove-class:begin',
  removeClassActive: 'animation:remove-class:active',
  removeClassDone: 'animation:remove-class:done',
  removeClassTimeout: 'animation:remove-class:timeout',

  addClassBegin: 'animation:add-class:begin',
  addClassActive: 'animation:add-class:active',
  addClassDone: 'animation:add-class:done',
  addClassTimeout: 'animation:add-class:timeout',

  animateBegin: 'animation:animate:begin',
  animateActive: 'animation:animate:active',
  animateDone: 'animation:animate:done',
  animateTimeout: 'animation:animate:timeout',

  sequenceBegin: 'animation:sequence:begin',
  sequenceDone: 'animation:sequence:done'
};

var Animator = exports.Animator = function () {
  function Animator() {
    
  }

  Animator.prototype.enter = function enter(element) {
    return Promise.resolve(false);
  };

  Animator.prototype.leave = function leave(element) {
    return Promise.resolve(false);
  };

  Animator.prototype.removeClass = function removeClass(element, className) {
    element.classList.remove(className);
    return Promise.resolve(false);
  };

  Animator.prototype.addClass = function addClass(element, className) {
    element.classList.add(className);
    return Promise.resolve(false);
  };

  Animator.prototype.animate = function animate(element, className) {
    return Promise.resolve(false);
  };

  Animator.prototype.runSequence = function runSequence(animations) {};

  Animator.prototype.registerEffect = function registerEffect(effectName, properties) {};

  Animator.prototype.unregisterEffect = function unregisterEffect(effectName) {};

  return Animator;
}();

var CompositionTransactionNotifier = exports.CompositionTransactionNotifier = function () {
  function CompositionTransactionNotifier(owner) {
    

    this.owner = owner;
    this.owner._compositionCount++;
  }

  CompositionTransactionNotifier.prototype.done = function done() {
    this.owner._compositionCount--;
    this.owner._tryCompleteTransaction();
  };

  return CompositionTransactionNotifier;
}();

var CompositionTransactionOwnershipToken = exports.CompositionTransactionOwnershipToken = function () {
  function CompositionTransactionOwnershipToken(owner) {
    

    this.owner = owner;
    this.owner._ownershipToken = this;
    this.thenable = this._createThenable();
  }

  CompositionTransactionOwnershipToken.prototype.waitForCompositionComplete = function waitForCompositionComplete() {
    this.owner._tryCompleteTransaction();
    return this.thenable;
  };

  CompositionTransactionOwnershipToken.prototype.resolve = function resolve() {
    this._resolveCallback();
  };

  CompositionTransactionOwnershipToken.prototype._createThenable = function _createThenable() {
    var _this = this;

    return new Promise(function (resolve, reject) {
      _this._resolveCallback = resolve;
    });
  };

  return CompositionTransactionOwnershipToken;
}();

var CompositionTransaction = exports.CompositionTransaction = function () {
  function CompositionTransaction() {
    

    this._ownershipToken = null;
    this._compositionCount = 0;
  }

  CompositionTransaction.prototype.tryCapture = function tryCapture() {
    return this._ownershipToken === null ? new CompositionTransactionOwnershipToken(this) : null;
  };

  CompositionTransaction.prototype.enlist = function enlist() {
    return new CompositionTransactionNotifier(this);
  };

  CompositionTransaction.prototype._tryCompleteTransaction = function _tryCompleteTransaction() {
    if (this._compositionCount <= 0) {
      this._compositionCount = 0;

      if (this._ownershipToken !== null) {
        var token = this._ownershipToken;
        this._ownershipToken = null;
        token.resolve();
      }
    }
  };

  return CompositionTransaction;
}();

var capitalMatcher = /([A-Z])/g;

function addHyphenAndLower(char) {
  return '-' + char.toLowerCase();
}

function _hyphenate(name) {
  return (name.charAt(0).toLowerCase() + name.slice(1)).replace(capitalMatcher, addHyphenAndLower);
}

function _isAllWhitespace(node) {
  return !(node.auInterpolationTarget || /[^\t\n\r ]/.test(node.textContent));
}

var ViewEngineHooksResource = exports.ViewEngineHooksResource = function () {
  function ViewEngineHooksResource() {
    
  }

  ViewEngineHooksResource.prototype.initialize = function initialize(container, target) {
    this.instance = container.get(target);
  };

  ViewEngineHooksResource.prototype.register = function register(registry, name) {
    registry.registerViewEngineHooks(this.instance);
  };

  ViewEngineHooksResource.prototype.load = function load(container, target) {};

  ViewEngineHooksResource.convention = function convention(name) {
    if (name.endsWith('ViewEngineHooks')) {
      return new ViewEngineHooksResource();
    }
  };

  return ViewEngineHooksResource;
}();

function viewEngineHooks(target) {
  var deco = function deco(t) {
    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ViewEngineHooksResource(), t);
  };

  return target ? deco(target) : deco;
}

var ElementEvents = exports.ElementEvents = function () {
  function ElementEvents(element) {
    

    this.element = element;
    this.subscriptions = {};
  }

  ElementEvents.prototype._enqueueHandler = function _enqueueHandler(handler) {
    this.subscriptions[handler.eventName] = this.subscriptions[handler.eventName] || [];
    this.subscriptions[handler.eventName].push(handler);
  };

  ElementEvents.prototype._dequeueHandler = function _dequeueHandler(handler) {
    var index = void 0;
    var subscriptions = this.subscriptions[handler.eventName];
    if (subscriptions) {
      index = subscriptions.indexOf(handler);
      if (index > -1) {
        subscriptions.splice(index, 1);
      }
    }
    return handler;
  };

  ElementEvents.prototype.publish = function publish(eventName) {
    var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var bubbles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var cancelable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    var event = _aureliaPal.DOM.createCustomEvent(eventName, { cancelable: cancelable, bubbles: bubbles, detail: detail });
    this.element.dispatchEvent(event);
  };

  ElementEvents.prototype.subscribe = function subscribe(eventName, handler) {
    var captureOrOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (typeof handler === 'function') {
      var eventHandler = new EventHandlerImpl(this, eventName, handler, captureOrOptions, false);
      return eventHandler;
    }

    return undefined;
  };

  ElementEvents.prototype.subscribeOnce = function subscribeOnce(eventName, handler) {
    var captureOrOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (typeof handler === 'function') {
      var eventHandler = new EventHandlerImpl(this, eventName, handler, captureOrOptions, true);
      return eventHandler;
    }

    return undefined;
  };

  ElementEvents.prototype.dispose = function dispose(eventName) {
    if (eventName && typeof eventName === 'string') {
      var subscriptions = this.subscriptions[eventName];
      if (subscriptions) {
        while (subscriptions.length) {
          var subscription = subscriptions.pop();
          if (subscription) {
            subscription.dispose();
          }
        }
      }
    } else {
      this.disposeAll();
    }
  };

  ElementEvents.prototype.disposeAll = function disposeAll() {
    for (var key in this.subscriptions) {
      this.dispose(key);
    }
  };

  return ElementEvents;
}();

var EventHandlerImpl = function () {
  function EventHandlerImpl(owner, eventName, handler, captureOrOptions, once) {
    

    this.owner = owner;
    this.eventName = eventName;
    this.handler = handler;

    this.capture = typeof captureOrOptions === 'boolean' ? captureOrOptions : captureOrOptions.capture;
    this.bubbles = !this.capture;
    this.captureOrOptions = captureOrOptions;
    this.once = once;
    owner.element.addEventListener(eventName, this, captureOrOptions);
    owner._enqueueHandler(this);
  }

  EventHandlerImpl.prototype.handleEvent = function handleEvent(e) {
    var fn = this.handler;
    fn(e);
    if (this.once) {
      this.dispose();
    }
  };

  EventHandlerImpl.prototype.dispose = function dispose() {
    this.owner.element.removeEventListener(this.eventName, this, this.captureOrOptions);
    this.owner._dequeueHandler(this);
    this.owner = this.handler = null;
  };

  return EventHandlerImpl;
}();

var ResourceLoadContext = exports.ResourceLoadContext = function () {
  function ResourceLoadContext() {
    

    this.dependencies = {};
  }

  ResourceLoadContext.prototype.addDependency = function addDependency(url) {
    this.dependencies[url] = true;
  };

  ResourceLoadContext.prototype.hasDependency = function hasDependency(url) {
    return url in this.dependencies;
  };

  return ResourceLoadContext;
}();

var ViewCompileInstruction = exports.ViewCompileInstruction = function ViewCompileInstruction() {
  var targetShadowDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var compileSurrogate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  

  this.targetShadowDOM = targetShadowDOM;
  this.compileSurrogate = compileSurrogate;
  this.associatedModuleId = null;
};

ViewCompileInstruction.normal = new ViewCompileInstruction();

var BehaviorInstruction = exports.BehaviorInstruction = function () {
  BehaviorInstruction.enhance = function enhance() {
    var instruction = new BehaviorInstruction();
    instruction.enhance = true;
    return instruction;
  };

  BehaviorInstruction.unitTest = function unitTest(type, attributes) {
    var instruction = new BehaviorInstruction();
    instruction.type = type;
    instruction.attributes = attributes || {};
    return instruction;
  };

  BehaviorInstruction.element = function element(node, type) {
    var instruction = new BehaviorInstruction();
    instruction.type = type;
    instruction.attributes = {};
    instruction.anchorIsContainer = !(node.hasAttribute('containerless') || type.containerless);
    instruction.initiatedByBehavior = true;
    return instruction;
  };

  BehaviorInstruction.attribute = function attribute(attrName, type) {
    var instruction = new BehaviorInstruction();
    instruction.attrName = attrName;
    instruction.type = type || null;
    instruction.attributes = {};
    return instruction;
  };

  BehaviorInstruction.dynamic = function dynamic(host, viewModel, viewFactory) {
    var instruction = new BehaviorInstruction();
    instruction.host = host;
    instruction.viewModel = viewModel;
    instruction.viewFactory = viewFactory;
    instruction.inheritBindingContext = true;
    return instruction;
  };

  function BehaviorInstruction() {
    

    this.initiatedByBehavior = false;
    this.enhance = false;
    this.partReplacements = null;
    this.viewFactory = null;
    this.originalAttrName = null;
    this.skipContentProcessing = false;
    this.contentFactory = null;
    this.viewModel = null;
    this.anchorIsContainer = false;
    this.host = null;
    this.attributes = null;
    this.type = null;
    this.attrName = null;
    this.inheritBindingContext = false;
  }

  return BehaviorInstruction;
}();

BehaviorInstruction.normal = new BehaviorInstruction();

var TargetInstruction = exports.TargetInstruction = (_temp = _class = function () {
  TargetInstruction.shadowSlot = function shadowSlot(parentInjectorId) {
    var instruction = new TargetInstruction();
    instruction.parentInjectorId = parentInjectorId;
    instruction.shadowSlot = true;
    return instruction;
  };

  TargetInstruction.contentExpression = function contentExpression(expression) {
    var instruction = new TargetInstruction();
    instruction.contentExpression = expression;
    return instruction;
  };

  TargetInstruction.lifting = function lifting(parentInjectorId, liftingInstruction) {
    var instruction = new TargetInstruction();
    instruction.parentInjectorId = parentInjectorId;
    instruction.expressions = TargetInstruction.noExpressions;
    instruction.behaviorInstructions = [liftingInstruction];
    instruction.viewFactory = liftingInstruction.viewFactory;
    instruction.providers = [liftingInstruction.type.target];
    instruction.lifting = true;
    return instruction;
  };

  TargetInstruction.normal = function normal(injectorId, parentInjectorId, providers, behaviorInstructions, expressions, elementInstruction) {
    var instruction = new TargetInstruction();
    instruction.injectorId = injectorId;
    instruction.parentInjectorId = parentInjectorId;
    instruction.providers = providers;
    instruction.behaviorInstructions = behaviorInstructions;
    instruction.expressions = expressions;
    instruction.anchorIsContainer = elementInstruction ? elementInstruction.anchorIsContainer : true;
    instruction.elementInstruction = elementInstruction;
    return instruction;
  };

  TargetInstruction.surrogate = function surrogate(providers, behaviorInstructions, expressions, values) {
    var instruction = new TargetInstruction();
    instruction.expressions = expressions;
    instruction.behaviorInstructions = behaviorInstructions;
    instruction.providers = providers;
    instruction.values = values;
    return instruction;
  };

  function TargetInstruction() {
    

    this.injectorId = null;
    this.parentInjectorId = null;

    this.shadowSlot = false;
    this.slotName = null;
    this.slotFallbackFactory = null;

    this.contentExpression = null;

    this.expressions = null;
    this.behaviorInstructions = null;
    this.providers = null;

    this.viewFactory = null;

    this.anchorIsContainer = false;
    this.elementInstruction = null;
    this.lifting = false;

    this.values = null;
  }

  return TargetInstruction;
}(), _class.noExpressions = Object.freeze([]), _temp);
var viewStrategy = exports.viewStrategy = _aureliaMetadata.protocol.create('aurelia:view-strategy', {
  validate: function validate(target) {
    if (!(typeof target.loadViewFactory === 'function')) {
      return 'View strategies must implement: loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewFactory>';
    }

    return true;
  },
  compose: function compose(target) {
    if (!(typeof target.makeRelativeTo === 'function')) {
      target.makeRelativeTo = _aureliaPal.PLATFORM.noop;
    }
  }
});

var RelativeViewStrategy = exports.RelativeViewStrategy = (_dec = viewStrategy(), _dec(_class2 = function () {
  function RelativeViewStrategy(path) {
    

    this.path = path;
    this.absolutePath = null;
  }

  RelativeViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
    if (this.absolutePath === null && this.moduleId) {
      this.absolutePath = (0, _aureliaPath.relativeToFile)(this.path, this.moduleId);
    }

    compileInstruction.associatedModuleId = this.moduleId;
    return viewEngine.loadViewFactory(this.absolutePath || this.path, compileInstruction, loadContext, target);
  };

  RelativeViewStrategy.prototype.makeRelativeTo = function makeRelativeTo(file) {
    if (this.absolutePath === null) {
      this.absolutePath = (0, _aureliaPath.relativeToFile)(this.path, file);
    }
  };

  return RelativeViewStrategy;
}()) || _class2);
var ConventionalViewStrategy = exports.ConventionalViewStrategy = (_dec2 = viewStrategy(), _dec2(_class3 = function () {
  function ConventionalViewStrategy(viewLocator, origin) {
    

    this.moduleId = origin.moduleId;
    this.viewUrl = viewLocator.convertOriginToViewUrl(origin);
  }

  ConventionalViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
    compileInstruction.associatedModuleId = this.moduleId;
    return viewEngine.loadViewFactory(this.viewUrl, compileInstruction, loadContext, target);
  };

  return ConventionalViewStrategy;
}()) || _class3);
var NoViewStrategy = exports.NoViewStrategy = (_dec3 = viewStrategy(), _dec3(_class4 = function () {
  function NoViewStrategy(dependencies, dependencyBaseUrl) {
    

    this.dependencies = dependencies || null;
    this.dependencyBaseUrl = dependencyBaseUrl || '';
  }

  NoViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
    var entry = this.entry;
    var dependencies = this.dependencies;

    if (entry && entry.factoryIsReady) {
      return Promise.resolve(null);
    }

    this.entry = entry = new _aureliaLoader.TemplateRegistryEntry(this.moduleId || this.dependencyBaseUrl);

    entry.dependencies = [];
    entry.templateIsLoaded = true;

    if (dependencies !== null) {
      for (var i = 0, ii = dependencies.length; i < ii; ++i) {
        var current = dependencies[i];

        if (typeof current === 'string' || typeof current === 'function') {
          entry.addDependency(current);
        } else {
          entry.addDependency(current.from, current.as);
        }
      }
    }

    compileInstruction.associatedModuleId = this.moduleId;

    return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
  };

  return NoViewStrategy;
}()) || _class4);
var TemplateRegistryViewStrategy = exports.TemplateRegistryViewStrategy = (_dec4 = viewStrategy(), _dec4(_class5 = function () {
  function TemplateRegistryViewStrategy(moduleId, entry) {
    

    this.moduleId = moduleId;
    this.entry = entry;
  }

  TemplateRegistryViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
    var entry = this.entry;

    if (entry.factoryIsReady) {
      return Promise.resolve(entry.factory);
    }

    compileInstruction.associatedModuleId = this.moduleId;
    return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
  };

  return TemplateRegistryViewStrategy;
}()) || _class5);
var InlineViewStrategy = exports.InlineViewStrategy = (_dec5 = viewStrategy(), _dec5(_class6 = function () {
  function InlineViewStrategy(markup, dependencies, dependencyBaseUrl) {
    

    this.markup = markup;
    this.dependencies = dependencies || null;
    this.dependencyBaseUrl = dependencyBaseUrl || '';
  }

  InlineViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
    var entry = this.entry;
    var dependencies = this.dependencies;

    if (entry && entry.factoryIsReady) {
      return Promise.resolve(entry.factory);
    }

    this.entry = entry = new _aureliaLoader.TemplateRegistryEntry(this.moduleId || this.dependencyBaseUrl);
    entry.template = _aureliaPal.DOM.createTemplateFromMarkup(this.markup);

    if (dependencies !== null) {
      for (var i = 0, ii = dependencies.length; i < ii; ++i) {
        var current = dependencies[i];

        if (typeof current === 'string' || typeof current === 'function') {
          entry.addDependency(current);
        } else {
          entry.addDependency(current.from, current.as);
        }
      }
    }

    compileInstruction.associatedModuleId = this.moduleId;
    return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
  };

  return InlineViewStrategy;
}()) || _class6);
var ViewLocator = exports.ViewLocator = (_temp2 = _class7 = function () {
  function ViewLocator() {
    
  }

  ViewLocator.prototype.getViewStrategy = function getViewStrategy(value) {
    if (!value) {
      return null;
    }

    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && 'getViewStrategy' in value) {
      var _origin = _aureliaMetadata.Origin.get(value.constructor);

      value = value.getViewStrategy();

      if (typeof value === 'string') {
        value = new RelativeViewStrategy(value);
      }

      viewStrategy.assert(value);

      if (_origin.moduleId) {
        value.makeRelativeTo(_origin.moduleId);
      }

      return value;
    }

    if (typeof value === 'string') {
      value = new RelativeViewStrategy(value);
    }

    if (viewStrategy.validate(value)) {
      return value;
    }

    if (typeof value !== 'function') {
      value = value.constructor;
    }

    var origin = _aureliaMetadata.Origin.get(value);
    var strategy = _aureliaMetadata.metadata.get(ViewLocator.viewStrategyMetadataKey, value);

    if (!strategy) {
      if (!origin.moduleId) {
        throw new Error('Cannot determine default view strategy for object.', value);
      }

      strategy = this.createFallbackViewStrategy(origin);
    } else if (origin.moduleId) {
      strategy.moduleId = origin.moduleId;
    }

    return strategy;
  };

  ViewLocator.prototype.createFallbackViewStrategy = function createFallbackViewStrategy(origin) {
    return new ConventionalViewStrategy(this, origin);
  };

  ViewLocator.prototype.convertOriginToViewUrl = function convertOriginToViewUrl(origin) {
    var moduleId = origin.moduleId;
    var id = moduleId.endsWith('.js') || moduleId.endsWith('.ts') ? moduleId.substring(0, moduleId.length - 3) : moduleId;
    return id + '.html';
  };

  return ViewLocator;
}(), _class7.viewStrategyMetadataKey = 'aurelia:view-strategy', _temp2);


function mi(name) {
  throw new Error('BindingLanguage must implement ' + name + '().');
}

var BindingLanguage = exports.BindingLanguage = function () {
  function BindingLanguage() {
    
  }

  BindingLanguage.prototype.inspectAttribute = function inspectAttribute(resources, elementName, attrName, attrValue) {
    mi('inspectAttribute');
  };

  BindingLanguage.prototype.createAttributeInstruction = function createAttributeInstruction(resources, element, info, existingInstruction) {
    mi('createAttributeInstruction');
  };

  BindingLanguage.prototype.inspectTextContent = function inspectTextContent(resources, value) {
    mi('inspectTextContent');
  };

  return BindingLanguage;
}();

var noNodes = Object.freeze([]);

var SlotCustomAttribute = exports.SlotCustomAttribute = (_dec6 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element), _dec6(_class8 = function () {
  function SlotCustomAttribute(element) {
    

    this.element = element;
    this.element.auSlotAttribute = this;
  }

  SlotCustomAttribute.prototype.valueChanged = function valueChanged(newValue, oldValue) {};

  return SlotCustomAttribute;
}()) || _class8);

var PassThroughSlot = exports.PassThroughSlot = function () {
  function PassThroughSlot(anchor, name, destinationName, fallbackFactory) {
    

    this.anchor = anchor;
    this.anchor.viewSlot = this;
    this.name = name;
    this.destinationName = destinationName;
    this.fallbackFactory = fallbackFactory;
    this.destinationSlot = null;
    this.projections = 0;
    this.contentView = null;

    var attr = new SlotCustomAttribute(this.anchor);
    attr.value = this.destinationName;
  }

  PassThroughSlot.prototype.renderFallbackContent = function renderFallbackContent(view, nodes, projectionSource, index) {
    if (this.contentView === null) {
      this.contentView = this.fallbackFactory.create(this.ownerView.container);
      this.contentView.bind(this.ownerView.bindingContext, this.ownerView.overrideContext);

      var slots = Object.create(null);
      slots[this.destinationSlot.name] = this.destinationSlot;

      ShadowDOM.distributeView(this.contentView, slots, projectionSource, index, this.destinationSlot.name);
    }
  };

  PassThroughSlot.prototype.passThroughTo = function passThroughTo(destinationSlot) {
    this.destinationSlot = destinationSlot;
  };

  PassThroughSlot.prototype.addNode = function addNode(view, node, projectionSource, index) {
    if (this.contentView !== null) {
      this.contentView.removeNodes();
      this.contentView.detached();
      this.contentView.unbind();
      this.contentView = null;
    }

    if (node.viewSlot instanceof PassThroughSlot) {
      node.viewSlot.passThroughTo(this);
      return;
    }

    this.projections++;
    this.destinationSlot.addNode(view, node, projectionSource, index);
  };

  PassThroughSlot.prototype.removeView = function removeView(view, projectionSource) {
    this.projections--;
    this.destinationSlot.removeView(view, projectionSource);

    if (this.needsFallbackRendering) {
      this.renderFallbackContent(null, noNodes, projectionSource);
    }
  };

  PassThroughSlot.prototype.removeAll = function removeAll(projectionSource) {
    this.projections = 0;
    this.destinationSlot.removeAll(projectionSource);

    if (this.needsFallbackRendering) {
      this.renderFallbackContent(null, noNodes, projectionSource);
    }
  };

  PassThroughSlot.prototype.projectFrom = function projectFrom(view, projectionSource) {
    this.destinationSlot.projectFrom(view, projectionSource);
  };

  PassThroughSlot.prototype.created = function created(ownerView) {
    this.ownerView = ownerView;
  };

  PassThroughSlot.prototype.bind = function bind(view) {
    if (this.contentView) {
      this.contentView.bind(view.bindingContext, view.overrideContext);
    }
  };

  PassThroughSlot.prototype.attached = function attached() {
    if (this.contentView) {
      this.contentView.attached();
    }
  };

  PassThroughSlot.prototype.detached = function detached() {
    if (this.contentView) {
      this.contentView.detached();
    }
  };

  PassThroughSlot.prototype.unbind = function unbind() {
    if (this.contentView) {
      this.contentView.unbind();
    }
  };

  _createClass(PassThroughSlot, [{
    key: 'needsFallbackRendering',
    get: function get() {
      return this.fallbackFactory && this.projections === 0;
    }
  }]);

  return PassThroughSlot;
}();

var ShadowSlot = exports.ShadowSlot = function () {
  function ShadowSlot(anchor, name, fallbackFactory) {
    

    this.anchor = anchor;
    this.anchor.isContentProjectionSource = true;
    this.anchor.viewSlot = this;
    this.name = name;
    this.fallbackFactory = fallbackFactory;
    this.contentView = null;
    this.projections = 0;
    this.children = [];
    this.projectFromAnchors = null;
    this.destinationSlots = null;
  }

  ShadowSlot.prototype.addNode = function addNode(view, node, projectionSource, index, destination) {
    if (this.contentView !== null) {
      this.contentView.removeNodes();
      this.contentView.detached();
      this.contentView.unbind();
      this.contentView = null;
    }

    if (node.viewSlot instanceof PassThroughSlot) {
      node.viewSlot.passThroughTo(this);
      return;
    }

    if (this.destinationSlots !== null) {
      ShadowDOM.distributeNodes(view, [node], this.destinationSlots, this, index);
    } else {
      node.auOwnerView = view;
      node.auProjectionSource = projectionSource;
      node.auAssignedSlot = this;

      var anchor = this._findAnchor(view, node, projectionSource, index);
      var parent = anchor.parentNode;

      parent.insertBefore(node, anchor);
      this.children.push(node);
      this.projections++;
    }
  };

  ShadowSlot.prototype.removeView = function removeView(view, projectionSource) {
    if (this.destinationSlots !== null) {
      ShadowDOM.undistributeView(view, this.destinationSlots, this);
    } else if (this.contentView && this.contentView.hasSlots) {
      ShadowDOM.undistributeView(view, this.contentView.slots, projectionSource);
    } else {
      var found = this.children.find(function (x) {
        return x.auSlotProjectFrom === projectionSource;
      });
      if (found) {
        var _children = found.auProjectionChildren;

        for (var i = 0, ii = _children.length; i < ii; ++i) {
          var _child = _children[i];

          if (_child.auOwnerView === view) {
            _children.splice(i, 1);
            view.fragment.appendChild(_child);
            i--;ii--;
            this.projections--;
          }
        }

        if (this.needsFallbackRendering) {
          this.renderFallbackContent(view, noNodes, projectionSource);
        }
      }
    }
  };

  ShadowSlot.prototype.removeAll = function removeAll(projectionSource) {
    if (this.destinationSlots !== null) {
      ShadowDOM.undistributeAll(this.destinationSlots, this);
    } else if (this.contentView && this.contentView.hasSlots) {
      ShadowDOM.undistributeAll(this.contentView.slots, projectionSource);
    } else {
      var found = this.children.find(function (x) {
        return x.auSlotProjectFrom === projectionSource;
      });

      if (found) {
        var _children2 = found.auProjectionChildren;
        for (var i = 0, ii = _children2.length; i < ii; ++i) {
          var _child2 = _children2[i];
          _child2.auOwnerView.fragment.appendChild(_child2);
          this.projections--;
        }

        found.auProjectionChildren = [];

        if (this.needsFallbackRendering) {
          this.renderFallbackContent(null, noNodes, projectionSource);
        }
      }
    }
  };

  ShadowSlot.prototype._findAnchor = function _findAnchor(view, node, projectionSource, index) {
    if (projectionSource) {
      var found = this.children.find(function (x) {
        return x.auSlotProjectFrom === projectionSource;
      });
      if (found) {
        if (index !== undefined) {
          var _children3 = found.auProjectionChildren;
          var viewIndex = -1;
          var lastView = void 0;

          for (var i = 0, ii = _children3.length; i < ii; ++i) {
            var current = _children3[i];

            if (current.auOwnerView !== lastView) {
              viewIndex++;
              lastView = current.auOwnerView;

              if (viewIndex >= index && lastView !== view) {
                _children3.splice(i, 0, node);
                return current;
              }
            }
          }
        }

        found.auProjectionChildren.push(node);
        return found;
      }
    }

    return this.anchor;
  };

  ShadowSlot.prototype.projectTo = function projectTo(slots) {
    this.destinationSlots = slots;
  };

  ShadowSlot.prototype.projectFrom = function projectFrom(view, projectionSource) {
    var anchor = _aureliaPal.DOM.createComment('anchor');
    var parent = this.anchor.parentNode;
    anchor.auSlotProjectFrom = projectionSource;
    anchor.auOwnerView = view;
    anchor.auProjectionChildren = [];
    parent.insertBefore(anchor, this.anchor);
    this.children.push(anchor);

    if (this.projectFromAnchors === null) {
      this.projectFromAnchors = [];
    }

    this.projectFromAnchors.push(anchor);
  };

  ShadowSlot.prototype.renderFallbackContent = function renderFallbackContent(view, nodes, projectionSource, index) {
    if (this.contentView === null) {
      this.contentView = this.fallbackFactory.create(this.ownerView.container);
      this.contentView.bind(this.ownerView.bindingContext, this.ownerView.overrideContext);
      this.contentView.insertNodesBefore(this.anchor);
    }

    if (this.contentView.hasSlots) {
      var slots = this.contentView.slots;
      var projectFromAnchors = this.projectFromAnchors;

      if (projectFromAnchors !== null) {
        for (var slotName in slots) {
          var slot = slots[slotName];

          for (var i = 0, ii = projectFromAnchors.length; i < ii; ++i) {
            var anchor = projectFromAnchors[i];
            slot.projectFrom(anchor.auOwnerView, anchor.auSlotProjectFrom);
          }
        }
      }

      this.fallbackSlots = slots;
      ShadowDOM.distributeNodes(view, nodes, slots, projectionSource, index);
    }
  };

  ShadowSlot.prototype.created = function created(ownerView) {
    this.ownerView = ownerView;
  };

  ShadowSlot.prototype.bind = function bind(view) {
    if (this.contentView) {
      this.contentView.bind(view.bindingContext, view.overrideContext);
    }
  };

  ShadowSlot.prototype.attached = function attached() {
    if (this.contentView) {
      this.contentView.attached();
    }
  };

  ShadowSlot.prototype.detached = function detached() {
    if (this.contentView) {
      this.contentView.detached();
    }
  };

  ShadowSlot.prototype.unbind = function unbind() {
    if (this.contentView) {
      this.contentView.unbind();
    }
  };

  _createClass(ShadowSlot, [{
    key: 'needsFallbackRendering',
    get: function get() {
      return this.fallbackFactory && this.projections === 0;
    }
  }]);

  return ShadowSlot;
}();

var ShadowDOM = exports.ShadowDOM = (_temp3 = _class9 = function () {
  function ShadowDOM() {
    
  }

  ShadowDOM.getSlotName = function getSlotName(node) {
    if (node.auSlotAttribute === undefined) {
      return ShadowDOM.defaultSlotKey;
    }

    return node.auSlotAttribute.value;
  };

  ShadowDOM.distributeView = function distributeView(view, slots, projectionSource, index, destinationOverride) {
    var nodes = void 0;

    if (view === null) {
      nodes = noNodes;
    } else {
      var childNodes = view.fragment.childNodes;
      var ii = childNodes.length;
      nodes = new Array(ii);

      for (var i = 0; i < ii; ++i) {
        nodes[i] = childNodes[i];
      }
    }

    ShadowDOM.distributeNodes(view, nodes, slots, projectionSource, index, destinationOverride);
  };

  ShadowDOM.undistributeView = function undistributeView(view, slots, projectionSource) {
    for (var slotName in slots) {
      slots[slotName].removeView(view, projectionSource);
    }
  };

  ShadowDOM.undistributeAll = function undistributeAll(slots, projectionSource) {
    for (var slotName in slots) {
      slots[slotName].removeAll(projectionSource);
    }
  };

  ShadowDOM.distributeNodes = function distributeNodes(view, nodes, slots, projectionSource, index, destinationOverride) {
    for (var i = 0, ii = nodes.length; i < ii; ++i) {
      var currentNode = nodes[i];
      var nodeType = currentNode.nodeType;

      if (currentNode.isContentProjectionSource) {
        currentNode.viewSlot.projectTo(slots);

        for (var slotName in slots) {
          slots[slotName].projectFrom(view, currentNode.viewSlot);
        }

        nodes.splice(i, 1);
        ii--;i--;
      } else if (nodeType === 1 || nodeType === 3 || currentNode.viewSlot instanceof PassThroughSlot) {
        if (nodeType === 3 && _isAllWhitespace(currentNode)) {
          nodes.splice(i, 1);
          ii--;i--;
        } else {
          var found = slots[destinationOverride || ShadowDOM.getSlotName(currentNode)];

          if (found) {
            found.addNode(view, currentNode, projectionSource, index);
            nodes.splice(i, 1);
            ii--;i--;
          }
        }
      } else {
        nodes.splice(i, 1);
        ii--;i--;
      }
    }

    for (var _slotName in slots) {
      var slot = slots[_slotName];

      if (slot.needsFallbackRendering) {
        slot.renderFallbackContent(view, nodes, projectionSource, index);
      }
    }
  };

  return ShadowDOM;
}(), _class9.defaultSlotKey = '__au-default-slot-key__', _temp3);


function register(lookup, name, resource, type) {
  if (!name) {
    return;
  }

  var existing = lookup[name];
  if (existing) {
    if (existing !== resource) {
      throw new Error('Attempted to register ' + type + ' when one with the same name already exists. Name: ' + name + '.');
    }

    return;
  }

  lookup[name] = resource;
}

var ViewResources = exports.ViewResources = function () {
  function ViewResources(parent, viewUrl) {
    

    this.bindingLanguage = null;

    this.parent = parent || null;
    this.hasParent = this.parent !== null;
    this.viewUrl = viewUrl || '';
    this.lookupFunctions = {
      valueConverters: this.getValueConverter.bind(this),
      bindingBehaviors: this.getBindingBehavior.bind(this)
    };
    this.attributes = Object.create(null);
    this.elements = Object.create(null);
    this.valueConverters = Object.create(null);
    this.bindingBehaviors = Object.create(null);
    this.attributeMap = Object.create(null);
    this.values = Object.create(null);
    this.beforeCompile = this.afterCompile = this.beforeCreate = this.afterCreate = this.beforeBind = this.beforeUnbind = false;
  }

  ViewResources.prototype._tryAddHook = function _tryAddHook(obj, name) {
    if (typeof obj[name] === 'function') {
      var func = obj[name].bind(obj);
      var counter = 1;
      var callbackName = void 0;

      while (this[callbackName = name + counter.toString()] !== undefined) {
        counter++;
      }

      this[name] = true;
      this[callbackName] = func;
    }
  };

  ViewResources.prototype._invokeHook = function _invokeHook(name, one, two, three, four) {
    if (this.hasParent) {
      this.parent._invokeHook(name, one, two, three, four);
    }

    if (this[name]) {
      this[name + '1'](one, two, three, four);

      var callbackName = name + '2';
      if (this[callbackName]) {
        this[callbackName](one, two, three, four);

        callbackName = name + '3';
        if (this[callbackName]) {
          this[callbackName](one, two, three, four);

          var counter = 4;

          while (this[callbackName = name + counter.toString()] !== undefined) {
            this[callbackName](one, two, three, four);
            counter++;
          }
        }
      }
    }
  };

  ViewResources.prototype.registerViewEngineHooks = function registerViewEngineHooks(hooks) {
    this._tryAddHook(hooks, 'beforeCompile');
    this._tryAddHook(hooks, 'afterCompile');
    this._tryAddHook(hooks, 'beforeCreate');
    this._tryAddHook(hooks, 'afterCreate');
    this._tryAddHook(hooks, 'beforeBind');
    this._tryAddHook(hooks, 'beforeUnbind');
  };

  ViewResources.prototype.getBindingLanguage = function getBindingLanguage(bindingLanguageFallback) {
    return this.bindingLanguage || (this.bindingLanguage = bindingLanguageFallback);
  };

  ViewResources.prototype.patchInParent = function patchInParent(newParent) {
    var originalParent = this.parent;

    this.parent = newParent || null;
    this.hasParent = this.parent !== null;

    if (newParent.parent === null) {
      newParent.parent = originalParent;
      newParent.hasParent = originalParent !== null;
    }
  };

  ViewResources.prototype.relativeToView = function relativeToView(path) {
    return (0, _aureliaPath.relativeToFile)(path, this.viewUrl);
  };

  ViewResources.prototype.registerElement = function registerElement(tagName, behavior) {
    register(this.elements, tagName, behavior, 'an Element');
  };

  ViewResources.prototype.getElement = function getElement(tagName) {
    return this.elements[tagName] || (this.hasParent ? this.parent.getElement(tagName) : null);
  };

  ViewResources.prototype.mapAttribute = function mapAttribute(attribute) {
    return this.attributeMap[attribute] || (this.hasParent ? this.parent.mapAttribute(attribute) : null);
  };

  ViewResources.prototype.registerAttribute = function registerAttribute(attribute, behavior, knownAttribute) {
    this.attributeMap[attribute] = knownAttribute;
    register(this.attributes, attribute, behavior, 'an Attribute');
  };

  ViewResources.prototype.getAttribute = function getAttribute(attribute) {
    return this.attributes[attribute] || (this.hasParent ? this.parent.getAttribute(attribute) : null);
  };

  ViewResources.prototype.registerValueConverter = function registerValueConverter(name, valueConverter) {
    register(this.valueConverters, name, valueConverter, 'a ValueConverter');
  };

  ViewResources.prototype.getValueConverter = function getValueConverter(name) {
    return this.valueConverters[name] || (this.hasParent ? this.parent.getValueConverter(name) : null);
  };

  ViewResources.prototype.registerBindingBehavior = function registerBindingBehavior(name, bindingBehavior) {
    register(this.bindingBehaviors, name, bindingBehavior, 'a BindingBehavior');
  };

  ViewResources.prototype.getBindingBehavior = function getBindingBehavior(name) {
    return this.bindingBehaviors[name] || (this.hasParent ? this.parent.getBindingBehavior(name) : null);
  };

  ViewResources.prototype.registerValue = function registerValue(name, value) {
    register(this.values, name, value, 'a value');
  };

  ViewResources.prototype.getValue = function getValue(name) {
    return this.values[name] || (this.hasParent ? this.parent.getValue(name) : null);
  };

  return ViewResources;
}();

var View = exports.View = function () {
  function View(container, viewFactory, fragment, controllers, bindings, children, slots) {
    

    this.container = container;
    this.viewFactory = viewFactory;
    this.resources = viewFactory.resources;
    this.fragment = fragment;
    this.firstChild = fragment.firstChild;
    this.lastChild = fragment.lastChild;
    this.controllers = controllers;
    this.bindings = bindings;
    this.children = children;
    this.slots = slots;
    this.hasSlots = false;
    this.fromCache = false;
    this.isBound = false;
    this.isAttached = false;
    this.bindingContext = null;
    this.overrideContext = null;
    this.controller = null;
    this.viewModelScope = null;
    this.animatableElement = undefined;
    this._isUserControlled = false;
    this.contentView = null;

    for (var key in slots) {
      this.hasSlots = true;
      break;
    }
  }

  View.prototype.returnToCache = function returnToCache() {
    this.viewFactory.returnViewToCache(this);
  };

  View.prototype.created = function created() {
    var i = void 0;
    var ii = void 0;
    var controllers = this.controllers;

    for (i = 0, ii = controllers.length; i < ii; ++i) {
      controllers[i].created(this);
    }
  };

  View.prototype.bind = function bind(bindingContext, overrideContext, _systemUpdate) {
    var controllers = void 0;
    var bindings = void 0;
    var children = void 0;
    var i = void 0;
    var ii = void 0;

    if (_systemUpdate && this._isUserControlled) {
      return;
    }

    if (this.isBound) {
      if (this.bindingContext === bindingContext) {
        return;
      }

      this.unbind();
    }

    this.isBound = true;
    this.bindingContext = bindingContext;
    this.overrideContext = overrideContext || (0, _aureliaBinding.createOverrideContext)(bindingContext);

    this.resources._invokeHook('beforeBind', this);

    bindings = this.bindings;
    for (i = 0, ii = bindings.length; i < ii; ++i) {
      bindings[i].bind(this);
    }

    if (this.viewModelScope !== null) {
      bindingContext.bind(this.viewModelScope.bindingContext, this.viewModelScope.overrideContext);
      this.viewModelScope = null;
    }

    controllers = this.controllers;
    for (i = 0, ii = controllers.length; i < ii; ++i) {
      controllers[i].bind(this);
    }

    children = this.children;
    for (i = 0, ii = children.length; i < ii; ++i) {
      children[i].bind(bindingContext, overrideContext, true);
    }

    if (this.hasSlots) {
      ShadowDOM.distributeView(this.contentView, this.slots);
    }
  };

  View.prototype.addBinding = function addBinding(binding) {
    this.bindings.push(binding);

    if (this.isBound) {
      binding.bind(this);
    }
  };

  View.prototype.unbind = function unbind() {
    var controllers = void 0;
    var bindings = void 0;
    var children = void 0;
    var i = void 0;
    var ii = void 0;

    if (this.isBound) {
      this.isBound = false;
      this.resources._invokeHook('beforeUnbind', this);

      if (this.controller !== null) {
        this.controller.unbind();
      }

      bindings = this.bindings;
      for (i = 0, ii = bindings.length; i < ii; ++i) {
        bindings[i].unbind();
      }

      controllers = this.controllers;
      for (i = 0, ii = controllers.length; i < ii; ++i) {
        controllers[i].unbind();
      }

      children = this.children;
      for (i = 0, ii = children.length; i < ii; ++i) {
        children[i].unbind();
      }

      this.bindingContext = null;
      this.overrideContext = null;
    }
  };

  View.prototype.insertNodesBefore = function insertNodesBefore(refNode) {
    refNode.parentNode.insertBefore(this.fragment, refNode);
  };

  View.prototype.appendNodesTo = function appendNodesTo(parent) {
    parent.appendChild(this.fragment);
  };

  View.prototype.removeNodes = function removeNodes() {
    var fragment = this.fragment;
    var current = this.firstChild;
    var end = this.lastChild;
    var next = void 0;

    while (current) {
      next = current.nextSibling;
      fragment.appendChild(current);

      if (current === end) {
        break;
      }

      current = next;
    }
  };

  View.prototype.attached = function attached() {
    var controllers = void 0;
    var children = void 0;
    var i = void 0;
    var ii = void 0;

    if (this.isAttached) {
      return;
    }

    this.isAttached = true;

    if (this.controller !== null) {
      this.controller.attached();
    }

    controllers = this.controllers;
    for (i = 0, ii = controllers.length; i < ii; ++i) {
      controllers[i].attached();
    }

    children = this.children;
    for (i = 0, ii = children.length; i < ii; ++i) {
      children[i].attached();
    }
  };

  View.prototype.detached = function detached() {
    var controllers = void 0;
    var children = void 0;
    var i = void 0;
    var ii = void 0;

    if (this.isAttached) {
      this.isAttached = false;

      if (this.controller !== null) {
        this.controller.detached();
      }

      controllers = this.controllers;
      for (i = 0, ii = controllers.length; i < ii; ++i) {
        controllers[i].detached();
      }

      children = this.children;
      for (i = 0, ii = children.length; i < ii; ++i) {
        children[i].detached();
      }
    }
  };

  return View;
}();

function getAnimatableElement(view) {
  if (view.animatableElement !== undefined) {
    return view.animatableElement;
  }

  var current = view.firstChild;

  while (current && current.nodeType !== 1) {
    current = current.nextSibling;
  }

  if (current && current.nodeType === 1) {
    return view.animatableElement = current.classList.contains('au-animate') ? current : null;
  }

  return view.animatableElement = null;
}

var ViewSlot = exports.ViewSlot = function () {
  function ViewSlot(anchor, anchorIsContainer) {
    var animator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Animator.instance;

    

    this.anchor = anchor;
    this.anchorIsContainer = anchorIsContainer;
    this.bindingContext = null;
    this.overrideContext = null;
    this.animator = animator;
    this.children = [];
    this.isBound = false;
    this.isAttached = false;
    this.contentSelectors = null;
    anchor.viewSlot = this;
    anchor.isContentProjectionSource = false;
  }

  ViewSlot.prototype.animateView = function animateView(view) {
    var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'enter';

    var animatableElement = getAnimatableElement(view);

    if (animatableElement !== null) {
      switch (direction) {
        case 'enter':
          return this.animator.enter(animatableElement);
        case 'leave':
          return this.animator.leave(animatableElement);
        default:
          throw new Error('Invalid animation direction: ' + direction);
      }
    }
  };

  ViewSlot.prototype.transformChildNodesIntoView = function transformChildNodesIntoView() {
    var parent = this.anchor;

    this.children.push({
      fragment: parent,
      firstChild: parent.firstChild,
      lastChild: parent.lastChild,
      returnToCache: function returnToCache() {},
      removeNodes: function removeNodes() {
        var last = void 0;

        while (last = parent.lastChild) {
          parent.removeChild(last);
        }
      },
      created: function created() {},
      bind: function bind() {},
      unbind: function unbind() {},
      attached: function attached() {},
      detached: function detached() {}
    });
  };

  ViewSlot.prototype.bind = function bind(bindingContext, overrideContext) {
    var i = void 0;
    var ii = void 0;
    var children = void 0;

    if (this.isBound) {
      if (this.bindingContext === bindingContext) {
        return;
      }

      this.unbind();
    }

    this.isBound = true;
    this.bindingContext = bindingContext = bindingContext || this.bindingContext;
    this.overrideContext = overrideContext = overrideContext || this.overrideContext;

    children = this.children;
    for (i = 0, ii = children.length; i < ii; ++i) {
      children[i].bind(bindingContext, overrideContext, true);
    }
  };

  ViewSlot.prototype.unbind = function unbind() {
    if (this.isBound) {
      var i = void 0;
      var ii = void 0;
      var _children4 = this.children;

      this.isBound = false;
      this.bindingContext = null;
      this.overrideContext = null;

      for (i = 0, ii = _children4.length; i < ii; ++i) {
        _children4[i].unbind();
      }
    }
  };

  ViewSlot.prototype.add = function add(view) {
    if (this.anchorIsContainer) {
      view.appendNodesTo(this.anchor);
    } else {
      view.insertNodesBefore(this.anchor);
    }

    this.children.push(view);

    if (this.isAttached) {
      view.attached();
      return this.animateView(view, 'enter');
    }
  };

  ViewSlot.prototype.insert = function insert(index, view) {
    var children = this.children;
    var length = children.length;

    if (index === 0 && length === 0 || index >= length) {
      return this.add(view);
    }

    view.insertNodesBefore(children[index].firstChild);
    children.splice(index, 0, view);

    if (this.isAttached) {
      view.attached();
      return this.animateView(view, 'enter');
    }
  };

  ViewSlot.prototype.move = function move(sourceIndex, targetIndex) {
    if (sourceIndex === targetIndex) {
      return;
    }

    var children = this.children;
    var view = children[sourceIndex];

    view.removeNodes();
    view.insertNodesBefore(children[targetIndex].firstChild);
    children.splice(sourceIndex, 1);
    children.splice(targetIndex, 0, view);
  };

  ViewSlot.prototype.remove = function remove(view, returnToCache, skipAnimation) {
    return this.removeAt(this.children.indexOf(view), returnToCache, skipAnimation);
  };

  ViewSlot.prototype.removeMany = function removeMany(viewsToRemove, returnToCache, skipAnimation) {
    var _this2 = this;

    var children = this.children;
    var ii = viewsToRemove.length;
    var i = void 0;
    var rmPromises = [];

    viewsToRemove.forEach(function (child) {
      if (skipAnimation) {
        child.removeNodes();
        return;
      }

      var animation = _this2.animateView(child, 'leave');
      if (animation) {
        rmPromises.push(animation.then(function () {
          return child.removeNodes();
        }));
      } else {
        child.removeNodes();
      }
    });

    var removeAction = function removeAction() {
      if (_this2.isAttached) {
        for (i = 0; i < ii; ++i) {
          viewsToRemove[i].detached();
        }
      }

      if (returnToCache) {
        for (i = 0; i < ii; ++i) {
          viewsToRemove[i].returnToCache();
        }
      }

      for (i = 0; i < ii; ++i) {
        var index = children.indexOf(viewsToRemove[i]);
        if (index >= 0) {
          children.splice(index, 1);
        }
      }
    };

    if (rmPromises.length > 0) {
      return Promise.all(rmPromises).then(function () {
        return removeAction();
      });
    }

    return removeAction();
  };

  ViewSlot.prototype.removeAt = function removeAt(index, returnToCache, skipAnimation) {
    var _this3 = this;

    var view = this.children[index];

    var removeAction = function removeAction() {
      index = _this3.children.indexOf(view);
      view.removeNodes();
      _this3.children.splice(index, 1);

      if (_this3.isAttached) {
        view.detached();
      }

      if (returnToCache) {
        view.returnToCache();
      }

      return view;
    };

    if (!skipAnimation) {
      var animation = this.animateView(view, 'leave');
      if (animation) {
        return animation.then(function () {
          return removeAction();
        });
      }
    }

    return removeAction();
  };

  ViewSlot.prototype.removeAll = function removeAll(returnToCache, skipAnimation) {
    var _this4 = this;

    var children = this.children;
    var ii = children.length;
    var i = void 0;
    var rmPromises = [];

    children.forEach(function (child) {
      if (skipAnimation) {
        child.removeNodes();
        return;
      }

      var animation = _this4.animateView(child, 'leave');
      if (animation) {
        rmPromises.push(animation.then(function () {
          return child.removeNodes();
        }));
      } else {
        child.removeNodes();
      }
    });

    var removeAction = function removeAction() {
      if (_this4.isAttached) {
        for (i = 0; i < ii; ++i) {
          children[i].detached();
        }
      }

      if (returnToCache) {
        for (i = 0; i < ii; ++i) {
          var _child3 = children[i];

          if (_child3) {
            _child3.returnToCache();
          }
        }
      }

      _this4.children = [];
    };

    if (rmPromises.length > 0) {
      return Promise.all(rmPromises).then(function () {
        return removeAction();
      });
    }

    return removeAction();
  };

  ViewSlot.prototype.attached = function attached() {
    var i = void 0;
    var ii = void 0;
    var children = void 0;
    var child = void 0;

    if (this.isAttached) {
      return;
    }

    this.isAttached = true;

    children = this.children;
    for (i = 0, ii = children.length; i < ii; ++i) {
      child = children[i];
      child.attached();
      this.animateView(child, 'enter');
    }
  };

  ViewSlot.prototype.detached = function detached() {
    var i = void 0;
    var ii = void 0;
    var children = void 0;

    if (this.isAttached) {
      this.isAttached = false;
      children = this.children;
      for (i = 0, ii = children.length; i < ii; ++i) {
        children[i].detached();
      }
    }
  };

  ViewSlot.prototype.projectTo = function projectTo(slots) {
    var _this5 = this;

    this.projectToSlots = slots;
    this.add = this._projectionAdd;
    this.insert = this._projectionInsert;
    this.move = this._projectionMove;
    this.remove = this._projectionRemove;
    this.removeAt = this._projectionRemoveAt;
    this.removeMany = this._projectionRemoveMany;
    this.removeAll = this._projectionRemoveAll;
    this.children.forEach(function (view) {
      return ShadowDOM.distributeView(view, slots, _this5);
    });
  };

  ViewSlot.prototype._projectionAdd = function _projectionAdd(view) {
    ShadowDOM.distributeView(view, this.projectToSlots, this);

    this.children.push(view);

    if (this.isAttached) {
      view.attached();
    }
  };

  ViewSlot.prototype._projectionInsert = function _projectionInsert(index, view) {
    if (index === 0 && !this.children.length || index >= this.children.length) {
      this.add(view);
    } else {
      ShadowDOM.distributeView(view, this.projectToSlots, this, index);

      this.children.splice(index, 0, view);

      if (this.isAttached) {
        view.attached();
      }
    }
  };

  ViewSlot.prototype._projectionMove = function _projectionMove(sourceIndex, targetIndex) {
    if (sourceIndex === targetIndex) {
      return;
    }

    var children = this.children;
    var view = children[sourceIndex];

    ShadowDOM.undistributeView(view, this.projectToSlots, this);
    ShadowDOM.distributeView(view, this.projectToSlots, this, targetIndex);

    children.splice(sourceIndex, 1);
    children.splice(targetIndex, 0, view);
  };

  ViewSlot.prototype._projectionRemove = function _projectionRemove(view, returnToCache) {
    ShadowDOM.undistributeView(view, this.projectToSlots, this);
    this.children.splice(this.children.indexOf(view), 1);

    if (this.isAttached) {
      view.detached();
    }
  };

  ViewSlot.prototype._projectionRemoveAt = function _projectionRemoveAt(index, returnToCache) {
    var view = this.children[index];

    ShadowDOM.undistributeView(view, this.projectToSlots, this);
    this.children.splice(index, 1);

    if (this.isAttached) {
      view.detached();
    }
  };

  ViewSlot.prototype._projectionRemoveMany = function _projectionRemoveMany(viewsToRemove, returnToCache) {
    var _this6 = this;

    viewsToRemove.forEach(function (view) {
      return _this6.remove(view, returnToCache);
    });
  };

  ViewSlot.prototype._projectionRemoveAll = function _projectionRemoveAll(returnToCache) {
    ShadowDOM.undistributeAll(this.projectToSlots, this);

    var children = this.children;

    if (this.isAttached) {
      for (var i = 0, ii = children.length; i < ii; ++i) {
        children[i].detached();
      }
    }

    this.children = [];
  };

  return ViewSlot;
}();

var ProviderResolver = (0, _aureliaDependencyInjection.resolver)(_class11 = function () {
  function ProviderResolver() {
    
  }

  ProviderResolver.prototype.get = function get(container, key) {
    var id = key.__providerId__;
    return id in container ? container[id] : container[id] = container.invoke(key);
  };

  return ProviderResolver;
}()) || _class11;

var providerResolverInstance = new ProviderResolver();

function elementContainerGet(key) {
  if (key === _aureliaPal.DOM.Element) {
    return this.element;
  }

  if (key === BoundViewFactory) {
    if (this.boundViewFactory) {
      return this.boundViewFactory;
    }

    var factory = this.instruction.viewFactory;
    var _partReplacements = this.partReplacements;

    if (_partReplacements) {
      factory = _partReplacements[factory.part] || factory;
    }

    this.boundViewFactory = new BoundViewFactory(this, factory, _partReplacements);
    return this.boundViewFactory;
  }

  if (key === ViewSlot) {
    if (this.viewSlot === undefined) {
      this.viewSlot = new ViewSlot(this.element, this.instruction.anchorIsContainer);
      this.element.isContentProjectionSource = this.instruction.lifting;
      this.children.push(this.viewSlot);
    }

    return this.viewSlot;
  }

  if (key === ElementEvents) {
    return this.elementEvents || (this.elementEvents = new ElementEvents(this.element));
  }

  if (key === CompositionTransaction) {
    return this.compositionTransaction || (this.compositionTransaction = this.parent.get(key));
  }

  if (key === ViewResources) {
    return this.viewResources;
  }

  if (key === TargetInstruction) {
    return this.instruction;
  }

  return this.superGet(key);
}

function createElementContainer(parent, element, instruction, children, partReplacements, resources) {
  var container = parent.createChild();
  var providers = void 0;
  var i = void 0;

  container.element = element;
  container.instruction = instruction;
  container.children = children;
  container.viewResources = resources;
  container.partReplacements = partReplacements;

  providers = instruction.providers;
  i = providers.length;

  while (i--) {
    container._resolvers.set(providers[i], providerResolverInstance);
  }

  container.superGet = container.get;
  container.get = elementContainerGet;

  return container;
}

function hasAttribute(name) {
  return this._element.hasAttribute(name);
}

function getAttribute(name) {
  return this._element.getAttribute(name);
}

function setAttribute(name, value) {
  this._element.setAttribute(name, value);
}

function makeElementIntoAnchor(element, elementInstruction) {
  var anchor = _aureliaPal.DOM.createComment('anchor');

  if (elementInstruction) {
    var firstChild = element.firstChild;

    if (firstChild && firstChild.tagName === 'AU-CONTENT') {
      anchor.contentElement = firstChild;
    }

    anchor._element = element;

    anchor.hasAttribute = hasAttribute;
    anchor.getAttribute = getAttribute;
    anchor.setAttribute = setAttribute;
  }

  _aureliaPal.DOM.replaceNode(anchor, element);

  return anchor;
}

function applyInstructions(containers, element, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources) {
  var behaviorInstructions = instruction.behaviorInstructions;
  var expressions = instruction.expressions;
  var elementContainer = void 0;
  var i = void 0;
  var ii = void 0;
  var current = void 0;
  var instance = void 0;

  if (instruction.contentExpression) {
    bindings.push(instruction.contentExpression.createBinding(element.nextSibling));
    element.nextSibling.auInterpolationTarget = true;
    element.parentNode.removeChild(element);
    return;
  }

  if (instruction.shadowSlot) {
    var commentAnchor = _aureliaPal.DOM.createComment('slot');
    var slot = void 0;

    if (instruction.slotDestination) {
      slot = new PassThroughSlot(commentAnchor, instruction.slotName, instruction.slotDestination, instruction.slotFallbackFactory);
    } else {
      slot = new ShadowSlot(commentAnchor, instruction.slotName, instruction.slotFallbackFactory);
    }

    _aureliaPal.DOM.replaceNode(commentAnchor, element);
    shadowSlots[instruction.slotName] = slot;
    controllers.push(slot);
    return;
  }

  if (behaviorInstructions.length) {
    if (!instruction.anchorIsContainer) {
      element = makeElementIntoAnchor(element, instruction.elementInstruction);
    }

    containers[instruction.injectorId] = elementContainer = createElementContainer(containers[instruction.parentInjectorId], element, instruction, children, partReplacements, resources);

    for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
      current = behaviorInstructions[i];
      instance = current.type.create(elementContainer, current, element, bindings);
      controllers.push(instance);
    }
  }

  for (i = 0, ii = expressions.length; i < ii; ++i) {
    bindings.push(expressions[i].createBinding(element));
  }
}

function styleStringToObject(style, target) {
  var attributes = style.split(';');
  var firstIndexOfColon = void 0;
  var i = void 0;
  var current = void 0;
  var key = void 0;
  var value = void 0;

  target = target || {};

  for (i = 0; i < attributes.length; i++) {
    current = attributes[i];
    firstIndexOfColon = current.indexOf(':');
    key = current.substring(0, firstIndexOfColon).trim();
    value = current.substring(firstIndexOfColon + 1).trim();
    target[key] = value;
  }

  return target;
}

function styleObjectToString(obj) {
  var result = '';

  for (var key in obj) {
    result += key + ':' + obj[key] + ';';
  }

  return result;
}

function applySurrogateInstruction(container, element, instruction, controllers, bindings, children) {
  var behaviorInstructions = instruction.behaviorInstructions;
  var expressions = instruction.expressions;
  var providers = instruction.providers;
  var values = instruction.values;
  var i = void 0;
  var ii = void 0;
  var current = void 0;
  var instance = void 0;
  var currentAttributeValue = void 0;

  i = providers.length;
  while (i--) {
    container._resolvers.set(providers[i], providerResolverInstance);
  }

  for (var key in values) {
    currentAttributeValue = element.getAttribute(key);

    if (currentAttributeValue) {
      if (key === 'class') {
        element.setAttribute('class', currentAttributeValue + ' ' + values[key]);
      } else if (key === 'style') {
        var styleObject = styleStringToObject(values[key]);
        styleStringToObject(currentAttributeValue, styleObject);
        element.setAttribute('style', styleObjectToString(styleObject));
      }
    } else {
      element.setAttribute(key, values[key]);
    }
  }

  if (behaviorInstructions.length) {
    for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
      current = behaviorInstructions[i];
      instance = current.type.create(container, current, element, bindings);

      if (instance.contentView) {
        children.push(instance.contentView);
      }

      controllers.push(instance);
    }
  }

  for (i = 0, ii = expressions.length; i < ii; ++i) {
    bindings.push(expressions[i].createBinding(element));
  }
}

var BoundViewFactory = exports.BoundViewFactory = function () {
  function BoundViewFactory(parentContainer, viewFactory, partReplacements) {
    

    this.parentContainer = parentContainer;
    this.viewFactory = viewFactory;
    this.factoryCreateInstruction = { partReplacements: partReplacements };
  }

  BoundViewFactory.prototype.create = function create() {
    var view = this.viewFactory.create(this.parentContainer.createChild(), this.factoryCreateInstruction);
    view._isUserControlled = true;
    return view;
  };

  BoundViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
    this.viewFactory.setCacheSize(size, doNotOverrideIfAlreadySet);
  };

  BoundViewFactory.prototype.getCachedView = function getCachedView() {
    return this.viewFactory.getCachedView();
  };

  BoundViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
    this.viewFactory.returnViewToCache(view);
  };

  _createClass(BoundViewFactory, [{
    key: 'isCaching',
    get: function get() {
      return this.viewFactory.isCaching;
    }
  }]);

  return BoundViewFactory;
}();

var ViewFactory = exports.ViewFactory = function () {
  function ViewFactory(template, instructions, resources) {
    

    this.isCaching = false;

    this.template = template;
    this.instructions = instructions;
    this.resources = resources;
    this.cacheSize = -1;
    this.cache = null;
  }

  ViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
    if (size) {
      if (size === '*') {
        size = Number.MAX_VALUE;
      } else if (typeof size === 'string') {
        size = parseInt(size, 10);
      }
    }

    if (this.cacheSize === -1 || !doNotOverrideIfAlreadySet) {
      this.cacheSize = size;
    }

    if (this.cacheSize > 0) {
      this.cache = [];
    } else {
      this.cache = null;
    }

    this.isCaching = this.cacheSize > 0;
  };

  ViewFactory.prototype.getCachedView = function getCachedView() {
    return this.cache !== null ? this.cache.pop() || null : null;
  };

  ViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
    if (view.isAttached) {
      view.detached();
    }

    if (view.isBound) {
      view.unbind();
    }

    if (this.cache !== null && this.cache.length < this.cacheSize) {
      view.fromCache = true;
      this.cache.push(view);
    }
  };

  ViewFactory.prototype.create = function create(container, createInstruction, element) {
    createInstruction = createInstruction || BehaviorInstruction.normal;

    var cachedView = this.getCachedView();
    if (cachedView !== null) {
      return cachedView;
    }

    var fragment = createInstruction.enhance ? this.template : this.template.cloneNode(true);
    var instructables = fragment.querySelectorAll('.au-target');
    var instructions = this.instructions;
    var resources = this.resources;
    var controllers = [];
    var bindings = [];
    var children = [];
    var shadowSlots = Object.create(null);
    var containers = { root: container };
    var partReplacements = createInstruction.partReplacements;
    var i = void 0;
    var ii = void 0;
    var view = void 0;
    var instructable = void 0;
    var instruction = void 0;

    this.resources._invokeHook('beforeCreate', this, container, fragment, createInstruction);

    if (element && this.surrogateInstruction !== null) {
      applySurrogateInstruction(container, element, this.surrogateInstruction, controllers, bindings, children);
    }

    if (createInstruction.enhance && fragment.hasAttribute('au-target-id')) {
      instructable = fragment;
      instruction = instructions[instructable.getAttribute('au-target-id')];
      applyInstructions(containers, instructable, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources);
    }

    for (i = 0, ii = instructables.length; i < ii; ++i) {
      instructable = instructables[i];
      instruction = instructions[instructable.getAttribute('au-target-id')];
      applyInstructions(containers, instructable, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources);
    }

    view = new View(container, this, fragment, controllers, bindings, children, shadowSlots);

    if (!createInstruction.initiatedByBehavior) {
      view.created();
    }

    this.resources._invokeHook('afterCreate', view);

    return view;
  };

  return ViewFactory;
}();

var nextInjectorId = 0;
function getNextInjectorId() {
  return ++nextInjectorId;
}

var lastAUTargetID = 0;
function getNextAUTargetID() {
  return (++lastAUTargetID).toString();
}

function makeIntoInstructionTarget(element) {
  var value = element.getAttribute('class');
  var auTargetID = getNextAUTargetID();

  element.setAttribute('class', value ? value + ' au-target' : 'au-target');
  element.setAttribute('au-target-id', auTargetID);

  return auTargetID;
}

function makeShadowSlot(compiler, resources, node, instructions, parentInjectorId) {
  var auShadowSlot = _aureliaPal.DOM.createElement('au-shadow-slot');
  _aureliaPal.DOM.replaceNode(auShadowSlot, node);

  var auTargetID = makeIntoInstructionTarget(auShadowSlot);
  var instruction = TargetInstruction.shadowSlot(parentInjectorId);

  instruction.slotName = node.getAttribute('name') || ShadowDOM.defaultSlotKey;
  instruction.slotDestination = node.getAttribute('slot');

  if (node.innerHTML.trim()) {
    var fragment = _aureliaPal.DOM.createDocumentFragment();
    var _child4 = void 0;

    while (_child4 = node.firstChild) {
      fragment.appendChild(_child4);
    }

    instruction.slotFallbackFactory = compiler.compile(fragment, resources);
  }

  instructions[auTargetID] = instruction;

  return auShadowSlot;
}

var ViewCompiler = exports.ViewCompiler = (_dec7 = (0, _aureliaDependencyInjection.inject)(BindingLanguage, ViewResources), _dec7(_class13 = function () {
  function ViewCompiler(bindingLanguage, resources) {
    

    this.bindingLanguage = bindingLanguage;
    this.resources = resources;
  }

  ViewCompiler.prototype.compile = function compile(source, resources, compileInstruction) {
    resources = resources || this.resources;
    compileInstruction = compileInstruction || ViewCompileInstruction.normal;
    source = typeof source === 'string' ? _aureliaPal.DOM.createTemplateFromMarkup(source) : source;

    var content = void 0;
    var part = void 0;
    var cacheSize = void 0;

    if (source.content) {
      part = source.getAttribute('part');
      cacheSize = source.getAttribute('view-cache');
      content = _aureliaPal.DOM.adoptNode(source.content);
    } else {
      content = source;
    }

    compileInstruction.targetShadowDOM = compileInstruction.targetShadowDOM && _aureliaPal.FEATURE.shadowDOM;
    resources._invokeHook('beforeCompile', content, resources, compileInstruction);

    var instructions = {};
    this._compileNode(content, resources, instructions, source, 'root', !compileInstruction.targetShadowDOM);

    var firstChild = content.firstChild;
    if (firstChild && firstChild.nodeType === 1) {
      var targetId = firstChild.getAttribute('au-target-id');
      if (targetId) {
        var ins = instructions[targetId];

        if (ins.shadowSlot || ins.lifting || ins.elementInstruction && !ins.elementInstruction.anchorIsContainer) {
          content.insertBefore(_aureliaPal.DOM.createComment('view'), firstChild);
        }
      }
    }

    var factory = new ViewFactory(content, instructions, resources);

    factory.surrogateInstruction = compileInstruction.compileSurrogate ? this._compileSurrogate(source, resources) : null;
    factory.part = part;

    if (cacheSize) {
      factory.setCacheSize(cacheSize);
    }

    resources._invokeHook('afterCompile', factory);

    return factory;
  };

  ViewCompiler.prototype._compileNode = function _compileNode(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM) {
    switch (node.nodeType) {
      case 1:
        return this._compileElement(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM);
      case 3:
        var expression = resources.getBindingLanguage(this.bindingLanguage).inspectTextContent(resources, node.wholeText);
        if (expression) {
          var marker = _aureliaPal.DOM.createElement('au-marker');
          var auTargetID = makeIntoInstructionTarget(marker);
          (node.parentNode || parentNode).insertBefore(marker, node);
          node.textContent = ' ';
          instructions[auTargetID] = TargetInstruction.contentExpression(expression);

          while (node.nextSibling && node.nextSibling.nodeType === 3) {
            (node.parentNode || parentNode).removeChild(node.nextSibling);
          }
        } else {
          while (node.nextSibling && node.nextSibling.nodeType === 3) {
            node = node.nextSibling;
          }
        }
        return node.nextSibling;
      case 11:
        var currentChild = node.firstChild;
        while (currentChild) {
          currentChild = this._compileNode(currentChild, resources, instructions, node, parentInjectorId, targetLightDOM);
        }
        break;
      default:
        break;
    }

    return node.nextSibling;
  };

  ViewCompiler.prototype._compileSurrogate = function _compileSurrogate(node, resources) {
    var tagName = node.tagName.toLowerCase();
    var attributes = node.attributes;
    var bindingLanguage = resources.getBindingLanguage(this.bindingLanguage);
    var knownAttribute = void 0;
    var property = void 0;
    var instruction = void 0;
    var i = void 0;
    var ii = void 0;
    var attr = void 0;
    var attrName = void 0;
    var attrValue = void 0;
    var info = void 0;
    var type = void 0;
    var expressions = [];
    var expression = void 0;
    var behaviorInstructions = [];
    var values = {};
    var hasValues = false;
    var providers = [];

    for (i = 0, ii = attributes.length; i < ii; ++i) {
      attr = attributes[i];
      attrName = attr.name;
      attrValue = attr.value;

      info = bindingLanguage.inspectAttribute(resources, tagName, attrName, attrValue);
      type = resources.getAttribute(info.attrName);

      if (type) {
        knownAttribute = resources.mapAttribute(info.attrName);
        if (knownAttribute) {
          property = type.attributes[knownAttribute];

          if (property) {
            info.defaultBindingMode = property.defaultBindingMode;

            if (!info.command && !info.expression) {
              info.command = property.hasOptions ? 'options' : null;
            }

            if (info.command && info.command !== 'options' && type.primaryProperty) {
              var primaryProperty = type.primaryProperty;
              attrName = info.attrName = primaryProperty.attribute;

              info.defaultBindingMode = primaryProperty.defaultBindingMode;
            }
          }
        }
      }

      instruction = bindingLanguage.createAttributeInstruction(resources, node, info, undefined, type);

      if (instruction) {
        if (instruction.alteredAttr) {
          type = resources.getAttribute(instruction.attrName);
        }

        if (instruction.discrete) {
          expressions.push(instruction);
        } else {
          if (type) {
            instruction.type = type;
            this._configureProperties(instruction, resources);

            if (type.liftsContent) {
              throw new Error('You cannot place a template controller on a surrogate element.');
            } else {
              behaviorInstructions.push(instruction);
            }
          } else {
            expressions.push(instruction.attributes[instruction.attrName]);
          }
        }
      } else {
        if (type) {
          instruction = BehaviorInstruction.attribute(attrName, type);
          instruction.attributes[resources.mapAttribute(attrName)] = attrValue;

          if (type.liftsContent) {
            throw new Error('You cannot place a template controller on a surrogate element.');
          } else {
            behaviorInstructions.push(instruction);
          }
        } else if (attrName !== 'id' && attrName !== 'part' && attrName !== 'replace-part') {
          hasValues = true;
          values[attrName] = attrValue;
        }
      }
    }

    if (expressions.length || behaviorInstructions.length || hasValues) {
      for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
        instruction = behaviorInstructions[i];
        instruction.type.compile(this, resources, node, instruction);
        providers.push(instruction.type.target);
      }

      for (i = 0, ii = expressions.length; i < ii; ++i) {
        expression = expressions[i];
        if (expression.attrToRemove !== undefined) {
          node.removeAttribute(expression.attrToRemove);
        }
      }

      return TargetInstruction.surrogate(providers, behaviorInstructions, expressions, values);
    }

    return null;
  };

  ViewCompiler.prototype._compileElement = function _compileElement(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM) {
    var tagName = node.tagName.toLowerCase();
    var attributes = node.attributes;
    var expressions = [];
    var expression = void 0;
    var behaviorInstructions = [];
    var providers = [];
    var bindingLanguage = resources.getBindingLanguage(this.bindingLanguage);
    var liftingInstruction = void 0;
    var viewFactory = void 0;
    var type = void 0;
    var elementInstruction = void 0;
    var elementProperty = void 0;
    var i = void 0;
    var ii = void 0;
    var attr = void 0;
    var attrName = void 0;
    var attrValue = void 0;
    var originalAttrName = void 0;
    var instruction = void 0;
    var info = void 0;
    var property = void 0;
    var knownAttribute = void 0;
    var auTargetID = void 0;
    var injectorId = void 0;

    if (tagName === 'slot') {
      if (targetLightDOM) {
        node = makeShadowSlot(this, resources, node, instructions, parentInjectorId);
      }
      return node.nextSibling;
    } else if (tagName === 'template') {
      if (!('content' in node)) {
        throw new Error('You cannot place a template element within ' + node.namespaceURI + ' namespace');
      }
      viewFactory = this.compile(node, resources);
      viewFactory.part = node.getAttribute('part');
    } else {
      type = resources.getElement(node.getAttribute('as-element') || tagName);
      if (type) {
        elementInstruction = BehaviorInstruction.element(node, type);
        type.processAttributes(this, resources, node, attributes, elementInstruction);
        behaviorInstructions.push(elementInstruction);
      }
    }

    for (i = 0, ii = attributes.length; i < ii; ++i) {
      attr = attributes[i];
      originalAttrName = attrName = attr.name;
      attrValue = attr.value;
      info = bindingLanguage.inspectAttribute(resources, tagName, attrName, attrValue);

      if (targetLightDOM && info.attrName === 'slot') {
        info.attrName = attrName = 'au-slot';
      }

      type = resources.getAttribute(info.attrName);
      elementProperty = null;

      if (type) {
        knownAttribute = resources.mapAttribute(info.attrName);
        if (knownAttribute) {
          property = type.attributes[knownAttribute];

          if (property) {
            info.defaultBindingMode = property.defaultBindingMode;

            if (!info.command && !info.expression) {
              info.command = property.hasOptions ? 'options' : null;
            }

            if (info.command && info.command !== 'options' && type.primaryProperty) {
              var primaryProperty = type.primaryProperty;
              attrName = info.attrName = primaryProperty.attribute;

              info.defaultBindingMode = primaryProperty.defaultBindingMode;
            }
          }
        }
      } else if (elementInstruction) {
        elementProperty = elementInstruction.type.attributes[info.attrName];
        if (elementProperty) {
          info.defaultBindingMode = elementProperty.defaultBindingMode;
        }
      }

      if (elementProperty) {
        instruction = bindingLanguage.createAttributeInstruction(resources, node, info, elementInstruction);
      } else {
        instruction = bindingLanguage.createAttributeInstruction(resources, node, info, undefined, type);
      }

      if (instruction) {
        if (instruction.alteredAttr) {
          type = resources.getAttribute(instruction.attrName);
        }

        if (instruction.discrete) {
          expressions.push(instruction);
        } else {
          if (type) {
            instruction.type = type;
            this._configureProperties(instruction, resources);

            if (type.liftsContent) {
              instruction.originalAttrName = originalAttrName;
              liftingInstruction = instruction;
              break;
            } else {
              behaviorInstructions.push(instruction);
            }
          } else if (elementProperty) {
            elementInstruction.attributes[info.attrName].targetProperty = elementProperty.name;
          } else {
            expressions.push(instruction.attributes[instruction.attrName]);
          }
        }
      } else {
        if (type) {
          instruction = BehaviorInstruction.attribute(attrName, type);
          instruction.attributes[resources.mapAttribute(attrName)] = attrValue;

          if (type.liftsContent) {
            instruction.originalAttrName = originalAttrName;
            liftingInstruction = instruction;
            break;
          } else {
            behaviorInstructions.push(instruction);
          }
        } else if (elementProperty) {
          elementInstruction.attributes[attrName] = attrValue;
        }
      }
    }

    if (liftingInstruction) {
      liftingInstruction.viewFactory = viewFactory;
      node = liftingInstruction.type.compile(this, resources, node, liftingInstruction, parentNode);
      auTargetID = makeIntoInstructionTarget(node);
      instructions[auTargetID] = TargetInstruction.lifting(parentInjectorId, liftingInstruction);
    } else {
      var skipContentProcessing = false;

      if (expressions.length || behaviorInstructions.length) {
        injectorId = behaviorInstructions.length ? getNextInjectorId() : false;

        for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
          instruction = behaviorInstructions[i];
          instruction.type.compile(this, resources, node, instruction, parentNode);
          providers.push(instruction.type.target);
          skipContentProcessing = skipContentProcessing || instruction.skipContentProcessing;
        }

        for (i = 0, ii = expressions.length; i < ii; ++i) {
          expression = expressions[i];
          if (expression.attrToRemove !== undefined) {
            node.removeAttribute(expression.attrToRemove);
          }
        }

        auTargetID = makeIntoInstructionTarget(node);
        instructions[auTargetID] = TargetInstruction.normal(injectorId, parentInjectorId, providers, behaviorInstructions, expressions, elementInstruction);
      }

      if (skipContentProcessing) {
        return node.nextSibling;
      }

      var currentChild = node.firstChild;
      while (currentChild) {
        currentChild = this._compileNode(currentChild, resources, instructions, node, injectorId || parentInjectorId, targetLightDOM);
      }
    }

    return node.nextSibling;
  };

  ViewCompiler.prototype._configureProperties = function _configureProperties(instruction, resources) {
    var type = instruction.type;
    var attrName = instruction.attrName;
    var attributes = instruction.attributes;
    var property = void 0;
    var key = void 0;
    var value = void 0;

    var knownAttribute = resources.mapAttribute(attrName);
    if (knownAttribute && attrName in attributes && knownAttribute !== attrName) {
      attributes[knownAttribute] = attributes[attrName];
      delete attributes[attrName];
    }

    for (key in attributes) {
      value = attributes[key];

      if (value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
        property = type.attributes[key];

        if (property !== undefined) {
          value.targetProperty = property.name;
        } else {
          value.targetProperty = key;
        }
      }
    }
  };

  return ViewCompiler;
}()) || _class13);

var ResourceModule = exports.ResourceModule = function () {
  function ResourceModule(moduleId) {
    

    this.id = moduleId;
    this.moduleInstance = null;
    this.mainResource = null;
    this.resources = null;
    this.viewStrategy = null;
    this.isInitialized = false;
    this.onLoaded = null;
    this.loadContext = null;
  }

  ResourceModule.prototype.initialize = function initialize(container) {
    var current = this.mainResource;
    var resources = this.resources;
    var vs = this.viewStrategy;

    if (this.isInitialized) {
      return;
    }

    this.isInitialized = true;

    if (current !== undefined) {
      current.metadata.viewStrategy = vs;
      current.initialize(container);
    }

    for (var i = 0, ii = resources.length; i < ii; ++i) {
      current = resources[i];
      current.metadata.viewStrategy = vs;
      current.initialize(container);
    }
  };

  ResourceModule.prototype.register = function register(registry, name) {
    var main = this.mainResource;
    var resources = this.resources;

    if (main !== undefined) {
      main.register(registry, name);
      name = null;
    }

    for (var i = 0, ii = resources.length; i < ii; ++i) {
      resources[i].register(registry, name);
      name = null;
    }
  };

  ResourceModule.prototype.load = function load(container, loadContext) {
    if (this.onLoaded !== null) {
      return this.loadContext === loadContext ? Promise.resolve() : this.onLoaded;
    }

    var main = this.mainResource;
    var resources = this.resources;
    var loads = void 0;

    if (main !== undefined) {
      loads = new Array(resources.length + 1);
      loads[0] = main.load(container, loadContext);
      for (var i = 0, ii = resources.length; i < ii; ++i) {
        loads[i + 1] = resources[i].load(container, loadContext);
      }
    } else {
      loads = new Array(resources.length);
      for (var _i = 0, _ii = resources.length; _i < _ii; ++_i) {
        loads[_i] = resources[_i].load(container, loadContext);
      }
    }

    this.loadContext = loadContext;
    this.onLoaded = Promise.all(loads);
    return this.onLoaded;
  };

  return ResourceModule;
}();

var ResourceDescription = exports.ResourceDescription = function () {
  function ResourceDescription(key, exportedValue, resourceTypeMeta) {
    

    if (!resourceTypeMeta) {
      resourceTypeMeta = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.resource, exportedValue);

      if (!resourceTypeMeta) {
        resourceTypeMeta = new HtmlBehaviorResource();
        resourceTypeMeta.elementName = _hyphenate(key);
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, resourceTypeMeta, exportedValue);
      }
    }

    if (resourceTypeMeta instanceof HtmlBehaviorResource) {
      if (resourceTypeMeta.elementName === undefined) {
        resourceTypeMeta.elementName = _hyphenate(key);
      } else if (resourceTypeMeta.attributeName === undefined) {
        resourceTypeMeta.attributeName = _hyphenate(key);
      } else if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
        HtmlBehaviorResource.convention(key, resourceTypeMeta);
      }
    } else if (!resourceTypeMeta.name) {
      resourceTypeMeta.name = _hyphenate(key);
    }

    this.metadata = resourceTypeMeta;
    this.value = exportedValue;
  }

  ResourceDescription.prototype.initialize = function initialize(container) {
    this.metadata.initialize(container, this.value);
  };

  ResourceDescription.prototype.register = function register(registry, name) {
    this.metadata.register(registry, name);
  };

  ResourceDescription.prototype.load = function load(container, loadContext) {
    return this.metadata.load(container, this.value, loadContext);
  };

  return ResourceDescription;
}();

var ModuleAnalyzer = exports.ModuleAnalyzer = function () {
  function ModuleAnalyzer() {
    

    this.cache = Object.create(null);
  }

  ModuleAnalyzer.prototype.getAnalysis = function getAnalysis(moduleId) {
    return this.cache[moduleId];
  };

  ModuleAnalyzer.prototype.analyze = function analyze(moduleId, moduleInstance, mainResourceKey) {
    var mainResource = void 0;
    var fallbackValue = void 0;
    var fallbackKey = void 0;
    var resourceTypeMeta = void 0;
    var key = void 0;
    var exportedValue = void 0;
    var resources = [];
    var conventional = void 0;
    var vs = void 0;
    var resourceModule = void 0;

    resourceModule = this.cache[moduleId];
    if (resourceModule) {
      return resourceModule;
    }

    resourceModule = new ResourceModule(moduleId);
    this.cache[moduleId] = resourceModule;

    if (typeof moduleInstance === 'function') {
      moduleInstance = { 'default': moduleInstance };
    }

    if (mainResourceKey) {
      mainResource = new ResourceDescription(mainResourceKey, moduleInstance[mainResourceKey]);
    }

    for (key in moduleInstance) {
      exportedValue = moduleInstance[key];

      if (key === mainResourceKey || typeof exportedValue !== 'function') {
        continue;
      }

      resourceTypeMeta = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.resource, exportedValue);

      if (resourceTypeMeta) {
        if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
          HtmlBehaviorResource.convention(key, resourceTypeMeta);
        }

        if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
          resourceTypeMeta.elementName = _hyphenate(key);
        }

        if (!mainResource && resourceTypeMeta instanceof HtmlBehaviorResource && resourceTypeMeta.elementName !== null) {
          mainResource = new ResourceDescription(key, exportedValue, resourceTypeMeta);
        } else {
          resources.push(new ResourceDescription(key, exportedValue, resourceTypeMeta));
        }
      } else if (viewStrategy.decorates(exportedValue)) {
        vs = exportedValue;
      } else if (exportedValue instanceof _aureliaLoader.TemplateRegistryEntry) {
        vs = new TemplateRegistryViewStrategy(moduleId, exportedValue);
      } else {
        if (conventional = HtmlBehaviorResource.convention(key)) {
          if (conventional.elementName !== null && !mainResource) {
            mainResource = new ResourceDescription(key, exportedValue, conventional);
          } else {
            resources.push(new ResourceDescription(key, exportedValue, conventional));
          }

          _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, conventional, exportedValue);
        } else if (conventional = _aureliaBinding.ValueConverterResource.convention(key) || _aureliaBinding.BindingBehaviorResource.convention(key) || ViewEngineHooksResource.convention(key)) {
          resources.push(new ResourceDescription(key, exportedValue, conventional));
          _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, conventional, exportedValue);
        } else if (!fallbackValue) {
          fallbackValue = exportedValue;
          fallbackKey = key;
        }
      }
    }

    if (!mainResource && fallbackValue) {
      mainResource = new ResourceDescription(fallbackKey, fallbackValue);
    }

    resourceModule.moduleInstance = moduleInstance;
    resourceModule.mainResource = mainResource;
    resourceModule.resources = resources;
    resourceModule.viewStrategy = vs;

    return resourceModule;
  };

  return ModuleAnalyzer;
}();

var logger = LogManager.getLogger('templating');

function ensureRegistryEntry(loader, urlOrRegistryEntry) {
  if (urlOrRegistryEntry instanceof _aureliaLoader.TemplateRegistryEntry) {
    return Promise.resolve(urlOrRegistryEntry);
  }

  return loader.loadTemplate(urlOrRegistryEntry);
}

var ProxyViewFactory = function () {
  function ProxyViewFactory(promise) {
    var _this7 = this;

    

    promise.then(function (x) {
      return _this7.viewFactory = x;
    });
  }

  ProxyViewFactory.prototype.create = function create(container, bindingContext, createInstruction, element) {
    return this.viewFactory.create(container, bindingContext, createInstruction, element);
  };

  ProxyViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
    this.viewFactory.setCacheSize(size, doNotOverrideIfAlreadySet);
  };

  ProxyViewFactory.prototype.getCachedView = function getCachedView() {
    return this.viewFactory.getCachedView();
  };

  ProxyViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
    this.viewFactory.returnViewToCache(view);
  };

  _createClass(ProxyViewFactory, [{
    key: 'isCaching',
    get: function get() {
      return this.viewFactory.isCaching;
    }
  }]);

  return ProxyViewFactory;
}();

var auSlotBehavior = null;

var ViewEngine = exports.ViewEngine = (_dec8 = (0, _aureliaDependencyInjection.inject)(_aureliaLoader.Loader, _aureliaDependencyInjection.Container, ViewCompiler, ModuleAnalyzer, ViewResources), _dec8(_class14 = (_temp4 = _class15 = function () {
  function ViewEngine(loader, container, viewCompiler, moduleAnalyzer, appResources) {
    

    this.loader = loader;
    this.container = container;
    this.viewCompiler = viewCompiler;
    this.moduleAnalyzer = moduleAnalyzer;
    this.appResources = appResources;
    this._pluginMap = {};

    if (auSlotBehavior === null) {
      auSlotBehavior = new HtmlBehaviorResource();
      auSlotBehavior.attributeName = 'au-slot';
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, auSlotBehavior, SlotCustomAttribute);
    }

    auSlotBehavior.initialize(container, SlotCustomAttribute);
    auSlotBehavior.register(appResources);
  }

  ViewEngine.prototype.addResourcePlugin = function addResourcePlugin(extension, implementation) {
    var name = extension.replace('.', '') + '-resource-plugin';
    this._pluginMap[extension] = name;
    this.loader.addPlugin(name, implementation);
  };

  ViewEngine.prototype.loadViewFactory = function loadViewFactory(urlOrRegistryEntry, compileInstruction, loadContext, target) {
    var _this8 = this;

    loadContext = loadContext || new ResourceLoadContext();

    return ensureRegistryEntry(this.loader, urlOrRegistryEntry).then(function (registryEntry) {
      var url = registryEntry.address;

      if (registryEntry.onReady) {
        if (!loadContext.hasDependency(url)) {
          loadContext.addDependency(url);
          return registryEntry.onReady;
        }

        if (registryEntry.template === null) {
          return registryEntry.onReady;
        }

        return Promise.resolve(new ProxyViewFactory(registryEntry.onReady));
      }

      loadContext.addDependency(url);

      registryEntry.onReady = _this8.loadTemplateResources(registryEntry, compileInstruction, loadContext, target).then(function (resources) {
        registryEntry.resources = resources;

        if (registryEntry.template === null) {
          return registryEntry.factory = null;
        }

        var viewFactory = _this8.viewCompiler.compile(registryEntry.template, resources, compileInstruction);
        return registryEntry.factory = viewFactory;
      });

      return registryEntry.onReady;
    });
  };

  ViewEngine.prototype.loadTemplateResources = function loadTemplateResources(registryEntry, compileInstruction, loadContext, target) {
    var resources = new ViewResources(this.appResources, registryEntry.address);
    var dependencies = registryEntry.dependencies;
    var importIds = void 0;
    var names = void 0;

    compileInstruction = compileInstruction || ViewCompileInstruction.normal;

    if (dependencies.length === 0 && !compileInstruction.associatedModuleId) {
      return Promise.resolve(resources);
    }

    importIds = dependencies.map(function (x) {
      return x.src;
    });
    names = dependencies.map(function (x) {
      return x.name;
    });
    logger.debug('importing resources for ' + registryEntry.address, importIds);

    if (target) {
      var viewModelRequires = _aureliaMetadata.metadata.get(ViewEngine.viewModelRequireMetadataKey, target);
      if (viewModelRequires) {
        var templateImportCount = importIds.length;
        for (var i = 0, ii = viewModelRequires.length; i < ii; ++i) {
          var req = viewModelRequires[i];
          var importId = typeof req === 'function' ? _aureliaMetadata.Origin.get(req).moduleId : (0, _aureliaPath.relativeToFile)(req.src || req, registryEntry.address);

          if (importIds.indexOf(importId) === -1) {
            importIds.push(importId);
            names.push(req.as);
          }
        }
        logger.debug('importing ViewModel resources for ' + compileInstruction.associatedModuleId, importIds.slice(templateImportCount));
      }
    }

    return this.importViewResources(importIds, names, resources, compileInstruction, loadContext);
  };

  ViewEngine.prototype.importViewModelResource = function importViewModelResource(moduleImport, moduleMember) {
    var _this9 = this;

    return this.loader.loadModule(moduleImport).then(function (viewModelModule) {
      var normalizedId = _aureliaMetadata.Origin.get(viewModelModule).moduleId;
      var resourceModule = _this9.moduleAnalyzer.analyze(normalizedId, viewModelModule, moduleMember);

      if (!resourceModule.mainResource) {
        throw new Error('No view model found in module "' + moduleImport + '".');
      }

      resourceModule.initialize(_this9.container);

      return resourceModule.mainResource;
    });
  };

  ViewEngine.prototype.importViewResources = function importViewResources(moduleIds, names, resources, compileInstruction, loadContext) {
    var _this10 = this;

    loadContext = loadContext || new ResourceLoadContext();
    compileInstruction = compileInstruction || ViewCompileInstruction.normal;

    moduleIds = moduleIds.map(function (x) {
      return _this10._applyLoaderPlugin(x);
    });

    return this.loader.loadAllModules(moduleIds).then(function (imports) {
      var i = void 0;
      var ii = void 0;
      var analysis = void 0;
      var normalizedId = void 0;
      var current = void 0;
      var associatedModule = void 0;
      var container = _this10.container;
      var moduleAnalyzer = _this10.moduleAnalyzer;
      var allAnalysis = new Array(imports.length);

      for (i = 0, ii = imports.length; i < ii; ++i) {
        current = imports[i];
        normalizedId = _aureliaMetadata.Origin.get(current).moduleId;

        analysis = moduleAnalyzer.analyze(normalizedId, current);
        analysis.initialize(container);
        analysis.register(resources, names[i]);

        allAnalysis[i] = analysis;
      }

      if (compileInstruction.associatedModuleId) {
        associatedModule = moduleAnalyzer.getAnalysis(compileInstruction.associatedModuleId);

        if (associatedModule) {
          associatedModule.register(resources);
        }
      }

      for (i = 0, ii = allAnalysis.length; i < ii; ++i) {
        allAnalysis[i] = allAnalysis[i].load(container, loadContext);
      }

      return Promise.all(allAnalysis).then(function () {
        return resources;
      });
    });
  };

  ViewEngine.prototype._applyLoaderPlugin = function _applyLoaderPlugin(id) {
    var index = id.lastIndexOf('.');
    if (index !== -1) {
      var ext = id.substring(index);
      var pluginName = this._pluginMap[ext];

      if (pluginName === undefined) {
        return id;
      }

      return this.loader.applyPluginToUrl(id, pluginName);
    }

    return id;
  };

  return ViewEngine;
}(), _class15.viewModelRequireMetadataKey = 'aurelia:view-model-require', _temp4)) || _class14);

var Controller = exports.Controller = function () {
  function Controller(behavior, instruction, viewModel, container) {
    

    this.behavior = behavior;
    this.instruction = instruction;
    this.viewModel = viewModel;
    this.isAttached = false;
    this.view = null;
    this.isBound = false;
    this.scope = null;
    this.container = container;
    this.elementEvents = container.elementEvents || null;

    var observerLookup = behavior.observerLocator.getOrCreateObserversLookup(viewModel);
    var handlesBind = behavior.handlesBind;
    var attributes = instruction.attributes;
    var boundProperties = this.boundProperties = [];
    var properties = behavior.properties;
    var i = void 0;
    var ii = void 0;

    behavior._ensurePropertiesDefined(viewModel, observerLookup);

    for (i = 0, ii = properties.length; i < ii; ++i) {
      properties[i]._initialize(viewModel, observerLookup, attributes, handlesBind, boundProperties);
    }
  }

  Controller.prototype.created = function created(owningView) {
    if (this.behavior.handlesCreated) {
      this.viewModel.created(owningView, this.view);
    }
  };

  Controller.prototype.automate = function automate(overrideContext, owningView) {
    this.view.bindingContext = this.viewModel;
    this.view.overrideContext = overrideContext || (0, _aureliaBinding.createOverrideContext)(this.viewModel);
    this.view._isUserControlled = true;

    if (this.behavior.handlesCreated) {
      this.viewModel.created(owningView || null, this.view);
    }

    this.bind(this.view);
  };

  Controller.prototype.bind = function bind(scope) {
    var skipSelfSubscriber = this.behavior.handlesBind;
    var boundProperties = this.boundProperties;
    var i = void 0;
    var ii = void 0;
    var x = void 0;
    var observer = void 0;
    var selfSubscriber = void 0;

    if (this.isBound) {
      if (this.scope === scope) {
        return;
      }

      this.unbind();
    }

    this.isBound = true;
    this.scope = scope;

    for (i = 0, ii = boundProperties.length; i < ii; ++i) {
      x = boundProperties[i];
      observer = x.observer;
      selfSubscriber = observer.selfSubscriber;
      observer.publishing = false;

      if (skipSelfSubscriber) {
        observer.selfSubscriber = null;
      }

      x.binding.bind(scope);
      observer.call();

      observer.publishing = true;
      observer.selfSubscriber = selfSubscriber;
    }

    var overrideContext = void 0;
    if (this.view !== null) {
      if (skipSelfSubscriber) {
        this.view.viewModelScope = scope;
      }

      if (this.viewModel === scope.overrideContext.bindingContext) {
        overrideContext = scope.overrideContext;
      } else if (this.instruction.inheritBindingContext) {
        overrideContext = (0, _aureliaBinding.createOverrideContext)(this.viewModel, scope.overrideContext);
      } else {
        overrideContext = (0, _aureliaBinding.createOverrideContext)(this.viewModel);
        overrideContext.__parentOverrideContext = scope.overrideContext;
      }

      this.view.bind(this.viewModel, overrideContext);
    } else if (skipSelfSubscriber) {
      overrideContext = scope.overrideContext;

      if (scope.overrideContext.__parentOverrideContext !== undefined && this.viewModel.viewFactory && this.viewModel.viewFactory.factoryCreateInstruction.partReplacements) {
        overrideContext = Object.assign({}, scope.overrideContext);
        overrideContext.parentOverrideContext = scope.overrideContext.__parentOverrideContext;
      }
      this.viewModel.bind(scope.bindingContext, overrideContext);
    }
  };

  Controller.prototype.unbind = function unbind() {
    if (this.isBound) {
      var _boundProperties = this.boundProperties;
      var _i2 = void 0;
      var _ii2 = void 0;

      this.isBound = false;
      this.scope = null;

      if (this.view !== null) {
        this.view.unbind();
      }

      if (this.behavior.handlesUnbind) {
        this.viewModel.unbind();
      }

      if (this.elementEvents !== null) {
        this.elementEvents.disposeAll();
      }

      for (_i2 = 0, _ii2 = _boundProperties.length; _i2 < _ii2; ++_i2) {
        _boundProperties[_i2].binding.unbind();
      }
    }
  };

  Controller.prototype.attached = function attached() {
    if (this.isAttached) {
      return;
    }

    this.isAttached = true;

    if (this.behavior.handlesAttached) {
      this.viewModel.attached();
    }

    if (this.view !== null) {
      this.view.attached();
    }
  };

  Controller.prototype.detached = function detached() {
    if (this.isAttached) {
      this.isAttached = false;

      if (this.view !== null) {
        this.view.detached();
      }

      if (this.behavior.handlesDetached) {
        this.viewModel.detached();
      }
    }
  };

  return Controller;
}();

var BehaviorPropertyObserver = exports.BehaviorPropertyObserver = (_dec9 = (0, _aureliaBinding.subscriberCollection)(), _dec9(_class16 = function () {
  function BehaviorPropertyObserver(taskQueue, obj, propertyName, selfSubscriber, initialValue) {
    

    this.taskQueue = taskQueue;
    this.obj = obj;
    this.propertyName = propertyName;
    this.notqueued = true;
    this.publishing = false;
    this.selfSubscriber = selfSubscriber;
    this.currentValue = this.oldValue = initialValue;
  }

  BehaviorPropertyObserver.prototype.getValue = function getValue() {
    return this.currentValue;
  };

  BehaviorPropertyObserver.prototype.setValue = function setValue(newValue) {
    var oldValue = this.currentValue;

    if (oldValue !== newValue) {
      this.oldValue = oldValue;
      this.currentValue = newValue;

      if (this.publishing && this.notqueued) {
        if (this.taskQueue.flushing) {
          this.call();
        } else {
          this.notqueued = false;
          this.taskQueue.queueMicroTask(this);
        }
      }
    }
  };

  BehaviorPropertyObserver.prototype.call = function call() {
    var oldValue = this.oldValue;
    var newValue = this.currentValue;

    this.notqueued = true;

    if (newValue === oldValue) {
      return;
    }

    if (this.selfSubscriber) {
      this.selfSubscriber(newValue, oldValue);
    }

    this.callSubscribers(newValue, oldValue);
    this.oldValue = newValue;
  };

  BehaviorPropertyObserver.prototype.subscribe = function subscribe(context, callable) {
    this.addSubscriber(context, callable);
  };

  BehaviorPropertyObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    this.removeSubscriber(context, callable);
  };

  return BehaviorPropertyObserver;
}()) || _class16);


function getObserver(instance, name) {
  var lookup = instance.__observers__;

  if (lookup === undefined) {
    var ctor = Object.getPrototypeOf(instance).constructor;
    var _behavior = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.resource, ctor);
    if (!_behavior.isInitialized) {
      _behavior.initialize(_aureliaDependencyInjection.Container.instance || new _aureliaDependencyInjection.Container(), instance.constructor);
    }

    lookup = _behavior.observerLocator.getOrCreateObserversLookup(instance);
    _behavior._ensurePropertiesDefined(instance, lookup);
  }

  return lookup[name];
}

var BindableProperty = exports.BindableProperty = function () {
  function BindableProperty(nameOrConfig) {
    

    if (typeof nameOrConfig === 'string') {
      this.name = nameOrConfig;
    } else {
      Object.assign(this, nameOrConfig);
    }

    this.attribute = this.attribute || _hyphenate(this.name);
    if (this.defaultBindingMode === null || this.defaultBindingMode === undefined) {
      this.defaultBindingMode = _aureliaBinding.bindingMode.oneWay;
    }
    this.changeHandler = this.changeHandler || null;
    this.owner = null;
    this.descriptor = null;
  }

  BindableProperty.prototype.registerWith = function registerWith(target, behavior, descriptor) {
    behavior.properties.push(this);
    behavior.attributes[this.attribute] = this;
    this.owner = behavior;

    if (descriptor) {
      this.descriptor = descriptor;
      return this._configureDescriptor(descriptor);
    }

    return undefined;
  };

  BindableProperty.prototype._configureDescriptor = function _configureDescriptor(descriptor) {
    var name = this.name;

    descriptor.configurable = true;
    descriptor.enumerable = true;

    if ('initializer' in descriptor) {
      this.defaultValue = descriptor.initializer;
      delete descriptor.initializer;
      delete descriptor.writable;
    }

    if ('value' in descriptor) {
      this.defaultValue = descriptor.value;
      delete descriptor.value;
      delete descriptor.writable;
    }

    descriptor.get = function () {
      return getObserver(this, name).getValue();
    };

    descriptor.set = function (value) {
      getObserver(this, name).setValue(value);
    };

    descriptor.get.getObserver = function (obj) {
      return getObserver(obj, name);
    };

    return descriptor;
  };

  BindableProperty.prototype.defineOn = function defineOn(target, behavior) {
    var name = this.name;
    var handlerName = void 0;

    if (this.changeHandler === null) {
      handlerName = name + 'Changed';
      if (handlerName in target.prototype) {
        this.changeHandler = handlerName;
      }
    }

    if (this.descriptor === null) {
      Object.defineProperty(target.prototype, name, this._configureDescriptor(behavior, {}));
    }
  };

  BindableProperty.prototype.createObserver = function createObserver(viewModel) {
    var selfSubscriber = null;
    var defaultValue = this.defaultValue;
    var changeHandlerName = this.changeHandler;
    var name = this.name;
    var initialValue = void 0;

    if (this.hasOptions) {
      return undefined;
    }

    if (changeHandlerName in viewModel) {
      if ('propertyChanged' in viewModel) {
        selfSubscriber = function selfSubscriber(newValue, oldValue) {
          viewModel[changeHandlerName](newValue, oldValue);
          viewModel.propertyChanged(name, newValue, oldValue);
        };
      } else {
        selfSubscriber = function selfSubscriber(newValue, oldValue) {
          return viewModel[changeHandlerName](newValue, oldValue);
        };
      }
    } else if ('propertyChanged' in viewModel) {
      selfSubscriber = function selfSubscriber(newValue, oldValue) {
        return viewModel.propertyChanged(name, newValue, oldValue);
      };
    } else if (changeHandlerName !== null) {
      throw new Error('Change handler ' + changeHandlerName + ' was specified but not declared on the class.');
    }

    if (defaultValue !== undefined) {
      initialValue = typeof defaultValue === 'function' ? defaultValue.call(viewModel) : defaultValue;
    }

    return new BehaviorPropertyObserver(this.owner.taskQueue, viewModel, this.name, selfSubscriber, initialValue);
  };

  BindableProperty.prototype._initialize = function _initialize(viewModel, observerLookup, attributes, behaviorHandlesBind, boundProperties) {
    var selfSubscriber = void 0;
    var observer = void 0;
    var attribute = void 0;
    var defaultValue = this.defaultValue;

    if (this.isDynamic) {
      for (var key in attributes) {
        this._createDynamicProperty(viewModel, observerLookup, behaviorHandlesBind, key, attributes[key], boundProperties);
      }
    } else if (!this.hasOptions) {
      observer = observerLookup[this.name];

      if (attributes !== null) {
        selfSubscriber = observer.selfSubscriber;
        attribute = attributes[this.attribute];

        if (behaviorHandlesBind) {
          observer.selfSubscriber = null;
        }

        if (typeof attribute === 'string') {
          viewModel[this.name] = attribute;
          observer.call();
        } else if (attribute) {
          boundProperties.push({ observer: observer, binding: attribute.createBinding(viewModel) });
        } else if (defaultValue !== undefined) {
          observer.call();
        }

        observer.selfSubscriber = selfSubscriber;
      }

      observer.publishing = true;
    }
  };

  BindableProperty.prototype._createDynamicProperty = function _createDynamicProperty(viewModel, observerLookup, behaviorHandlesBind, name, attribute, boundProperties) {
    var changeHandlerName = name + 'Changed';
    var selfSubscriber = null;
    var observer = void 0;
    var info = void 0;

    if (changeHandlerName in viewModel) {
      if ('propertyChanged' in viewModel) {
        selfSubscriber = function selfSubscriber(newValue, oldValue) {
          viewModel[changeHandlerName](newValue, oldValue);
          viewModel.propertyChanged(name, newValue, oldValue);
        };
      } else {
        selfSubscriber = function selfSubscriber(newValue, oldValue) {
          return viewModel[changeHandlerName](newValue, oldValue);
        };
      }
    } else if ('propertyChanged' in viewModel) {
      selfSubscriber = function selfSubscriber(newValue, oldValue) {
        return viewModel.propertyChanged(name, newValue, oldValue);
      };
    }

    observer = observerLookup[name] = new BehaviorPropertyObserver(this.owner.taskQueue, viewModel, name, selfSubscriber);

    Object.defineProperty(viewModel, name, {
      configurable: true,
      enumerable: true,
      get: observer.getValue.bind(observer),
      set: observer.setValue.bind(observer)
    });

    if (behaviorHandlesBind) {
      observer.selfSubscriber = null;
    }

    if (typeof attribute === 'string') {
      viewModel[name] = attribute;
      observer.call();
    } else if (attribute) {
      info = { observer: observer, binding: attribute.createBinding(viewModel) };
      boundProperties.push(info);
    }

    observer.publishing = true;
    observer.selfSubscriber = selfSubscriber;
  };

  return BindableProperty;
}();

var lastProviderId = 0;

function nextProviderId() {
  return ++lastProviderId;
}

function doProcessContent() {
  return true;
}
function doProcessAttributes() {}

var HtmlBehaviorResource = exports.HtmlBehaviorResource = function () {
  function HtmlBehaviorResource() {
    

    this.elementName = null;
    this.attributeName = null;
    this.attributeDefaultBindingMode = undefined;
    this.liftsContent = false;
    this.targetShadowDOM = false;
    this.shadowDOMOptions = null;
    this.processAttributes = doProcessAttributes;
    this.processContent = doProcessContent;
    this.usesShadowDOM = false;
    this.childBindings = null;
    this.hasDynamicOptions = false;
    this.containerless = false;
    this.properties = [];
    this.attributes = {};
    this.isInitialized = false;
    this.primaryProperty = null;
  }

  HtmlBehaviorResource.convention = function convention(name, existing) {
    var behavior = void 0;

    if (name.endsWith('CustomAttribute')) {
      behavior = existing || new HtmlBehaviorResource();
      behavior.attributeName = _hyphenate(name.substring(0, name.length - 15));
    }

    if (name.endsWith('CustomElement')) {
      behavior = existing || new HtmlBehaviorResource();
      behavior.elementName = _hyphenate(name.substring(0, name.length - 13));
    }

    return behavior;
  };

  HtmlBehaviorResource.prototype.addChildBinding = function addChildBinding(behavior) {
    if (this.childBindings === null) {
      this.childBindings = [];
    }

    this.childBindings.push(behavior);
  };

  HtmlBehaviorResource.prototype.initialize = function initialize(container, target) {
    var proto = target.prototype;
    var properties = this.properties;
    var attributeName = this.attributeName;
    var attributeDefaultBindingMode = this.attributeDefaultBindingMode;
    var i = void 0;
    var ii = void 0;
    var current = void 0;

    if (this.isInitialized) {
      return;
    }

    this.isInitialized = true;
    target.__providerId__ = nextProviderId();

    this.observerLocator = container.get(_aureliaBinding.ObserverLocator);
    this.taskQueue = container.get(_aureliaTaskQueue.TaskQueue);

    this.target = target;
    this.usesShadowDOM = this.targetShadowDOM && _aureliaPal.FEATURE.shadowDOM;
    this.handlesCreated = 'created' in proto;
    this.handlesBind = 'bind' in proto;
    this.handlesUnbind = 'unbind' in proto;
    this.handlesAttached = 'attached' in proto;
    this.handlesDetached = 'detached' in proto;
    this.htmlName = this.elementName || this.attributeName;

    if (attributeName !== null) {
      if (properties.length === 0) {
        new BindableProperty({
          name: 'value',
          changeHandler: 'valueChanged' in proto ? 'valueChanged' : null,
          attribute: attributeName,
          defaultBindingMode: attributeDefaultBindingMode
        }).registerWith(target, this);
      }

      current = properties[0];

      if (properties.length === 1 && current.name === 'value') {
        current.isDynamic = current.hasOptions = this.hasDynamicOptions;
        current.defineOn(target, this);
      } else {
        for (i = 0, ii = properties.length; i < ii; ++i) {
          properties[i].defineOn(target, this);
          if (properties[i].primaryProperty) {
            if (this.primaryProperty) {
              throw new Error('Only one bindable property on a custom element can be defined as the default');
            }
            this.primaryProperty = properties[i];
          }
        }

        current = new BindableProperty({
          name: 'value',
          changeHandler: 'valueChanged' in proto ? 'valueChanged' : null,
          attribute: attributeName,
          defaultBindingMode: attributeDefaultBindingMode
        });

        current.hasOptions = true;
        current.registerWith(target, this);
      }
    } else {
      for (i = 0, ii = properties.length; i < ii; ++i) {
        properties[i].defineOn(target, this);
      }

      this._copyInheritedProperties(container, target);
    }
  };

  HtmlBehaviorResource.prototype.register = function register(registry, name) {
    var _this11 = this;

    if (this.attributeName !== null) {
      registry.registerAttribute(name || this.attributeName, this, this.attributeName);

      if (Array.isArray(this.aliases)) {
        this.aliases.forEach(function (alias) {
          registry.registerAttribute(alias, _this11, _this11.attributeName);
        });
      }
    }

    if (this.elementName !== null) {
      registry.registerElement(name || this.elementName, this);
    }
  };

  HtmlBehaviorResource.prototype.load = function load(container, target, loadContext, viewStrategy, transientView) {
    var _this12 = this;

    var options = void 0;

    if (this.elementName !== null) {
      viewStrategy = container.get(ViewLocator).getViewStrategy(viewStrategy || this.viewStrategy || target);
      options = new ViewCompileInstruction(this.targetShadowDOM, true);

      if (!viewStrategy.moduleId) {
        viewStrategy.moduleId = _aureliaMetadata.Origin.get(target).moduleId;
      }

      return viewStrategy.loadViewFactory(container.get(ViewEngine), options, loadContext, target).then(function (viewFactory) {
        if (!transientView || !_this12.viewFactory) {
          _this12.viewFactory = viewFactory;
        }

        return viewFactory;
      });
    }

    return Promise.resolve(this);
  };

  HtmlBehaviorResource.prototype.compile = function compile(compiler, resources, node, instruction, parentNode) {
    if (this.liftsContent) {
      if (!instruction.viewFactory) {
        var template = _aureliaPal.DOM.createElement('template');
        var fragment = _aureliaPal.DOM.createDocumentFragment();
        var cacheSize = node.getAttribute('view-cache');
        var part = node.getAttribute('part');

        node.removeAttribute(instruction.originalAttrName);
        _aureliaPal.DOM.replaceNode(template, node, parentNode);
        fragment.appendChild(node);
        instruction.viewFactory = compiler.compile(fragment, resources);

        if (part) {
          instruction.viewFactory.part = part;
          node.removeAttribute('part');
        }

        if (cacheSize) {
          instruction.viewFactory.setCacheSize(cacheSize);
          node.removeAttribute('view-cache');
        }

        node = template;
      }
    } else if (this.elementName !== null) {
      var _partReplacements2 = {};

      if (this.processContent(compiler, resources, node, instruction) && node.hasChildNodes()) {
        var currentChild = node.firstChild;
        var contentElement = this.usesShadowDOM ? null : _aureliaPal.DOM.createElement('au-content');
        var nextSibling = void 0;
        var toReplace = void 0;

        while (currentChild) {
          nextSibling = currentChild.nextSibling;

          if (currentChild.tagName === 'TEMPLATE' && (toReplace = currentChild.getAttribute('replace-part'))) {
            _partReplacements2[toReplace] = compiler.compile(currentChild, resources);
            _aureliaPal.DOM.removeNode(currentChild, parentNode);
            instruction.partReplacements = _partReplacements2;
          } else if (contentElement !== null) {
            if (currentChild.nodeType === 3 && _isAllWhitespace(currentChild)) {
              _aureliaPal.DOM.removeNode(currentChild, parentNode);
            } else {
              contentElement.appendChild(currentChild);
            }
          }

          currentChild = nextSibling;
        }

        if (contentElement !== null && contentElement.hasChildNodes()) {
          node.appendChild(contentElement);
        }

        instruction.skipContentProcessing = false;
      } else {
        instruction.skipContentProcessing = true;
      }
    } else if (!this.processContent(compiler, resources, node, instruction)) {
      instruction.skipContentProcessing = true;
    }

    return node;
  };

  HtmlBehaviorResource.prototype.create = function create(container, instruction, element, bindings) {
    var viewHost = void 0;
    var au = null;

    instruction = instruction || BehaviorInstruction.normal;
    element = element || null;
    bindings = bindings || null;

    if (this.elementName !== null && element) {
      if (this.usesShadowDOM) {
        viewHost = element.attachShadow(this.shadowDOMOptions);
        container.registerInstance(_aureliaPal.DOM.boundary, viewHost);
      } else {
        viewHost = element;
        if (this.targetShadowDOM) {
          container.registerInstance(_aureliaPal.DOM.boundary, viewHost);
        }
      }
    }

    if (element !== null) {
      element.au = au = element.au || {};
    }

    var viewModel = instruction.viewModel || container.get(this.target);
    var controller = new Controller(this, instruction, viewModel, container);
    var childBindings = this.childBindings;
    var viewFactory = void 0;

    if (this.liftsContent) {
      au.controller = controller;
    } else if (this.elementName !== null) {
      viewFactory = instruction.viewFactory || this.viewFactory;
      container.viewModel = viewModel;

      if (viewFactory) {
        controller.view = viewFactory.create(container, instruction, element);
      }

      if (element !== null) {
        au.controller = controller;

        if (controller.view) {
          if (!this.usesShadowDOM && (element.childNodes.length === 1 || element.contentElement)) {
            var contentElement = element.childNodes[0] || element.contentElement;
            controller.view.contentView = { fragment: contentElement };
            contentElement.parentNode && _aureliaPal.DOM.removeNode(contentElement);
          }

          if (instruction.anchorIsContainer) {
            if (childBindings !== null) {
              for (var _i3 = 0, _ii3 = childBindings.length; _i3 < _ii3; ++_i3) {
                controller.view.addBinding(childBindings[_i3].create(element, viewModel, controller));
              }
            }

            controller.view.appendNodesTo(viewHost);
          } else {
            controller.view.insertNodesBefore(viewHost);
          }
        } else if (childBindings !== null) {
          for (var _i4 = 0, _ii4 = childBindings.length; _i4 < _ii4; ++_i4) {
            bindings.push(childBindings[_i4].create(element, viewModel, controller));
          }
        }
      } else if (controller.view) {
        controller.view.controller = controller;

        if (childBindings !== null) {
          for (var _i5 = 0, _ii5 = childBindings.length; _i5 < _ii5; ++_i5) {
            controller.view.addBinding(childBindings[_i5].create(instruction.host, viewModel, controller));
          }
        }
      } else if (childBindings !== null) {
        for (var _i6 = 0, _ii6 = childBindings.length; _i6 < _ii6; ++_i6) {
          bindings.push(childBindings[_i6].create(instruction.host, viewModel, controller));
        }
      }
    } else if (childBindings !== null) {
      for (var _i7 = 0, _ii7 = childBindings.length; _i7 < _ii7; ++_i7) {
        bindings.push(childBindings[_i7].create(element, viewModel, controller));
      }
    }

    if (au !== null) {
      au[this.htmlName] = controller;
    }

    if (instruction.initiatedByBehavior && viewFactory) {
      controller.view.created();
    }

    return controller;
  };

  HtmlBehaviorResource.prototype._ensurePropertiesDefined = function _ensurePropertiesDefined(instance, lookup) {
    var properties = void 0;
    var i = void 0;
    var ii = void 0;
    var observer = void 0;

    if ('__propertiesDefined__' in lookup) {
      return;
    }

    lookup.__propertiesDefined__ = true;
    properties = this.properties;

    for (i = 0, ii = properties.length; i < ii; ++i) {
      observer = properties[i].createObserver(instance);

      if (observer !== undefined) {
        lookup[observer.propertyName] = observer;
      }
    }
  };

  HtmlBehaviorResource.prototype._copyInheritedProperties = function _copyInheritedProperties(container, target) {
    var _this13 = this;

    var behavior = void 0;
    var derived = target;

    while (true) {
      var proto = Object.getPrototypeOf(target.prototype);
      target = proto && proto.constructor;
      if (!target) {
        return;
      }
      behavior = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.resource, target);
      if (behavior) {
        break;
      }
    }
    behavior.initialize(container, target);

    var _loop = function _loop(_i8, _ii8) {
      var prop = behavior.properties[_i8];

      if (_this13.properties.some(function (p) {
        return p.name === prop.name;
      })) {
        return 'continue';
      }

      new BindableProperty(prop).registerWith(derived, _this13);
    };

    for (var _i8 = 0, _ii8 = behavior.properties.length; _i8 < _ii8; ++_i8) {
      var _ret = _loop(_i8, _ii8);

      if (_ret === 'continue') continue;
    }
  };

  return HtmlBehaviorResource;
}();

function createChildObserverDecorator(selectorOrConfig, all) {
  return function (target, key, descriptor) {
    var actualTarget = typeof key === 'string' ? target.constructor : target;
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, actualTarget);

    if (typeof selectorOrConfig === 'string') {
      selectorOrConfig = {
        selector: selectorOrConfig,
        name: key
      };
    }

    if (descriptor) {
      descriptor.writable = true;
      descriptor.configurable = true;
    }

    selectorOrConfig.all = all;
    r.addChildBinding(new ChildObserver(selectorOrConfig));
  };
}

function children(selectorOrConfig) {
  return createChildObserverDecorator(selectorOrConfig, true);
}

function child(selectorOrConfig) {
  return createChildObserverDecorator(selectorOrConfig, false);
}

var ChildObserver = function () {
  function ChildObserver(config) {
    

    this.name = config.name;
    this.changeHandler = config.changeHandler || this.name + 'Changed';
    this.selector = config.selector;
    this.all = config.all;
  }

  ChildObserver.prototype.create = function create(viewHost, viewModel, controller) {
    return new ChildObserverBinder(this.selector, viewHost, this.name, viewModel, controller, this.changeHandler, this.all);
  };

  return ChildObserver;
}();

var noMutations = [];

function trackMutation(groupedMutations, binder, record) {
  var mutations = groupedMutations.get(binder);

  if (!mutations) {
    mutations = [];
    groupedMutations.set(binder, mutations);
  }

  mutations.push(record);
}

function onChildChange(mutations, observer) {
  var binders = observer.binders;
  var bindersLength = binders.length;
  var groupedMutations = new Map();

  for (var _i9 = 0, _ii9 = mutations.length; _i9 < _ii9; ++_i9) {
    var record = mutations[_i9];
    var added = record.addedNodes;
    var removed = record.removedNodes;

    for (var j = 0, jj = removed.length; j < jj; ++j) {
      var node = removed[j];
      if (node.nodeType === 1) {
        for (var k = 0; k < bindersLength; ++k) {
          var binder = binders[k];
          if (binder.onRemove(node)) {
            trackMutation(groupedMutations, binder, record);
          }
        }
      }
    }

    for (var _j = 0, _jj = added.length; _j < _jj; ++_j) {
      var _node = added[_j];
      if (_node.nodeType === 1) {
        for (var _k = 0; _k < bindersLength; ++_k) {
          var _binder = binders[_k];
          if (_binder.onAdd(_node)) {
            trackMutation(groupedMutations, _binder, record);
          }
        }
      }
    }
  }

  groupedMutations.forEach(function (value, key) {
    if (key.changeHandler !== null) {
      key.viewModel[key.changeHandler](value);
    }
  });
}

var ChildObserverBinder = function () {
  function ChildObserverBinder(selector, viewHost, property, viewModel, controller, changeHandler, all) {
    

    this.selector = selector;
    this.viewHost = viewHost;
    this.property = property;
    this.viewModel = viewModel;
    this.controller = controller;
    this.changeHandler = changeHandler in viewModel ? changeHandler : null;
    this.usesShadowDOM = controller.behavior.usesShadowDOM;
    this.all = all;

    if (!this.usesShadowDOM && controller.view && controller.view.contentView) {
      this.contentView = controller.view.contentView;
    } else {
      this.contentView = null;
    }
  }

  ChildObserverBinder.prototype.matches = function matches(element) {
    if (element.matches(this.selector)) {
      if (this.contentView === null) {
        return true;
      }

      var contentView = this.contentView;
      var assignedSlot = element.auAssignedSlot;

      if (assignedSlot && assignedSlot.projectFromAnchors) {
        var anchors = assignedSlot.projectFromAnchors;

        for (var _i10 = 0, _ii10 = anchors.length; _i10 < _ii10; ++_i10) {
          if (anchors[_i10].auOwnerView === contentView) {
            return true;
          }
        }

        return false;
      }

      return element.auOwnerView === contentView;
    }

    return false;
  };

  ChildObserverBinder.prototype.bind = function bind(source) {
    var viewHost = this.viewHost;
    var viewModel = this.viewModel;
    var observer = viewHost.__childObserver__;

    if (!observer) {
      observer = viewHost.__childObserver__ = _aureliaPal.DOM.createMutationObserver(onChildChange);

      var options = {
        childList: true,
        subtree: !this.usesShadowDOM
      };

      observer.observe(viewHost, options);
      observer.binders = [];
    }

    observer.binders.push(this);

    if (this.usesShadowDOM) {
      var current = viewHost.firstElementChild;

      if (this.all) {
        var items = viewModel[this.property];
        if (!items) {
          items = viewModel[this.property] = [];
        } else {
          items.length = 0;
        }

        while (current) {
          if (this.matches(current)) {
            items.push(current.au && current.au.controller ? current.au.controller.viewModel : current);
          }

          current = current.nextElementSibling;
        }

        if (this.changeHandler !== null) {
          this.viewModel[this.changeHandler](noMutations);
        }
      } else {
        while (current) {
          if (this.matches(current)) {
            var value = current.au && current.au.controller ? current.au.controller.viewModel : current;
            this.viewModel[this.property] = value;

            if (this.changeHandler !== null) {
              this.viewModel[this.changeHandler](value);
            }

            break;
          }

          current = current.nextElementSibling;
        }
      }
    }
  };

  ChildObserverBinder.prototype.onRemove = function onRemove(element) {
    if (this.matches(element)) {
      var value = element.au && element.au.controller ? element.au.controller.viewModel : element;

      if (this.all) {
        var items = this.viewModel[this.property] || (this.viewModel[this.property] = []);
        var index = items.indexOf(value);

        if (index !== -1) {
          items.splice(index, 1);
        }

        return true;
      }

      return false;
    }

    return false;
  };

  ChildObserverBinder.prototype.onAdd = function onAdd(element) {
    if (this.matches(element)) {
      var value = element.au && element.au.controller ? element.au.controller.viewModel : element;

      if (this.all) {
        var items = this.viewModel[this.property] || (this.viewModel[this.property] = []);

        if (this.selector === '*') {
          items.push(value);
          return true;
        }

        var index = 0;
        var prev = element.previousElementSibling;

        while (prev) {
          if (this.matches(prev)) {
            index++;
          }

          prev = prev.previousElementSibling;
        }

        items.splice(index, 0, value);
        return true;
      }

      this.viewModel[this.property] = value;

      if (this.changeHandler !== null) {
        this.viewModel[this.changeHandler](value);
      }
    }

    return false;
  };

  ChildObserverBinder.prototype.unbind = function unbind() {
    if (this.viewHost.__childObserver__) {
      this.viewHost.__childObserver__.disconnect();
      this.viewHost.__childObserver__ = null;
    }
  };

  return ChildObserverBinder;
}();

function remove(viewSlot, previous) {
  return Array.isArray(previous) ? viewSlot.removeMany(previous, true) : viewSlot.remove(previous, true);
}

var SwapStrategies = exports.SwapStrategies = {
  before: function before(viewSlot, previous, callback) {
    return previous === undefined ? callback() : callback().then(function () {
      return remove(viewSlot, previous);
    });
  },
  with: function _with(viewSlot, previous, callback) {
    return previous === undefined ? callback() : Promise.all([remove(viewSlot, previous), callback()]);
  },
  after: function after(viewSlot, previous, callback) {
    return Promise.resolve(viewSlot.removeAll(true)).then(callback);
  }
};

function tryActivateViewModel(context) {
  if (context.skipActivation || typeof context.viewModel.activate !== 'function') {
    return Promise.resolve();
  }

  return context.viewModel.activate(context.model) || Promise.resolve();
}

var CompositionEngine = exports.CompositionEngine = (_dec10 = (0, _aureliaDependencyInjection.inject)(ViewEngine, ViewLocator), _dec10(_class17 = function () {
  function CompositionEngine(viewEngine, viewLocator) {
    

    this.viewEngine = viewEngine;
    this.viewLocator = viewLocator;
  }

  CompositionEngine.prototype._swap = function _swap(context, view) {
    var swapStrategy = SwapStrategies[context.swapOrder] || SwapStrategies.after;
    var previousViews = context.viewSlot.children.slice();

    return swapStrategy(context.viewSlot, previousViews, function () {
      return Promise.resolve(context.viewSlot.add(view)).then(function () {
        if (context.currentController) {
          context.currentController.unbind();
        }
      });
    }).then(function () {
      if (context.compositionTransactionNotifier) {
        context.compositionTransactionNotifier.done();
      }
    });
  };

  CompositionEngine.prototype._createControllerAndSwap = function _createControllerAndSwap(context) {
    var _this14 = this;

    return this.createController(context).then(function (controller) {
      controller.automate(context.overrideContext, context.owningView);

      if (context.compositionTransactionOwnershipToken) {
        return context.compositionTransactionOwnershipToken.waitForCompositionComplete().then(function () {
          return _this14._swap(context, controller.view);
        }).then(function () {
          return controller;
        });
      }

      return _this14._swap(context, controller.view).then(function () {
        return controller;
      });
    });
  };

  CompositionEngine.prototype.createController = function createController(context) {
    var _this15 = this;

    var childContainer = void 0;
    var viewModel = void 0;
    var viewModelResource = void 0;
    var m = void 0;

    return this.ensureViewModel(context).then(tryActivateViewModel).then(function () {
      childContainer = context.childContainer;
      viewModel = context.viewModel;
      viewModelResource = context.viewModelResource;
      m = viewModelResource.metadata;

      var viewStrategy = _this15.viewLocator.getViewStrategy(context.view || viewModel);

      if (context.viewResources) {
        viewStrategy.makeRelativeTo(context.viewResources.viewUrl);
      }

      return m.load(childContainer, viewModelResource.value, null, viewStrategy, true);
    }).then(function (viewFactory) {
      return m.create(childContainer, BehaviorInstruction.dynamic(context.host, viewModel, viewFactory));
    });
  };

  CompositionEngine.prototype.ensureViewModel = function ensureViewModel(context) {
    var childContainer = context.childContainer = context.childContainer || context.container.createChild();

    if (typeof context.viewModel === 'string') {
      context.viewModel = context.viewResources ? context.viewResources.relativeToView(context.viewModel) : context.viewModel;

      return this.viewEngine.importViewModelResource(context.viewModel).then(function (viewModelResource) {
        childContainer.autoRegister(viewModelResource.value);

        if (context.host) {
          childContainer.registerInstance(_aureliaPal.DOM.Element, context.host);
        }

        context.viewModel = childContainer.viewModel = childContainer.get(viewModelResource.value);
        context.viewModelResource = viewModelResource;
        return context;
      });
    }

    var m = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, context.viewModel.constructor);
    m.elementName = m.elementName || 'dynamic-element';
    m.initialize(context.container || childContainer, context.viewModel.constructor);
    context.viewModelResource = { metadata: m, value: context.viewModel.constructor };
    childContainer.viewModel = context.viewModel;
    return Promise.resolve(context);
  };

  CompositionEngine.prototype.compose = function compose(context) {
    var _this16 = this;

    context.childContainer = context.childContainer || context.container.createChild();
    context.view = this.viewLocator.getViewStrategy(context.view);

    var transaction = context.childContainer.get(CompositionTransaction);
    var compositionTransactionOwnershipToken = transaction.tryCapture();

    if (compositionTransactionOwnershipToken) {
      context.compositionTransactionOwnershipToken = compositionTransactionOwnershipToken;
    } else {
      context.compositionTransactionNotifier = transaction.enlist();
    }

    if (context.viewModel) {
      return this._createControllerAndSwap(context);
    } else if (context.view) {
      if (context.viewResources) {
        context.view.makeRelativeTo(context.viewResources.viewUrl);
      }

      return context.view.loadViewFactory(this.viewEngine, new ViewCompileInstruction()).then(function (viewFactory) {
        var result = viewFactory.create(context.childContainer);
        result.bind(context.bindingContext, context.overrideContext);

        if (context.compositionTransactionOwnershipToken) {
          return context.compositionTransactionOwnershipToken.waitForCompositionComplete().then(function () {
            return _this16._swap(context, result);
          }).then(function () {
            return result;
          });
        }

        return _this16._swap(context, result).then(function () {
          return result;
        });
      });
    } else if (context.viewSlot) {
      context.viewSlot.removeAll();

      if (context.compositionTransactionNotifier) {
        context.compositionTransactionNotifier.done();
      }

      return Promise.resolve(null);
    }

    return Promise.resolve(null);
  };

  return CompositionEngine;
}()) || _class17);

var ElementConfigResource = exports.ElementConfigResource = function () {
  function ElementConfigResource() {
    
  }

  ElementConfigResource.prototype.initialize = function initialize(container, target) {};

  ElementConfigResource.prototype.register = function register(registry, name) {};

  ElementConfigResource.prototype.load = function load(container, target) {
    var config = new target();
    var eventManager = container.get(_aureliaBinding.EventManager);
    eventManager.registerElementConfig(config);
  };

  return ElementConfigResource;
}();

function validateBehaviorName(name, type) {
  if (/[A-Z]/.test(name)) {
    var newName = _hyphenate(name);
    LogManager.getLogger('templating').warn('\'' + name + '\' is not a valid ' + type + ' name and has been converted to \'' + newName + '\'. Upper-case letters are not allowed because the DOM is not case-sensitive.');
    return newName;
  }
  return name;
}

function resource(instance) {
  return function (target) {
    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, instance, target);
  };
}

function behavior(override) {
  return function (target) {
    if (override instanceof HtmlBehaviorResource) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, override, target);
    } else {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
      Object.assign(r, override);
    }
  };
}

function customElement(name) {
  return function (target) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
    r.elementName = validateBehaviorName(name, 'custom element');
  };
}

function customAttribute(name, defaultBindingMode, aliases) {
  return function (target) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
    r.attributeName = validateBehaviorName(name, 'custom attribute');
    r.attributeDefaultBindingMode = defaultBindingMode;
    r.aliases = aliases;
  };
}

function templateController(target) {
  var deco = function deco(t) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
    r.liftsContent = true;
  };

  return target ? deco(target) : deco;
}

function bindable(nameOrConfigOrTarget, key, descriptor) {
  var deco = function deco(target, key2, descriptor2) {
    var actualTarget = key2 ? target.constructor : target;
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, actualTarget);
    var prop = void 0;

    if (key2) {
      nameOrConfigOrTarget = nameOrConfigOrTarget || {};
      nameOrConfigOrTarget.name = key2;
    }

    prop = new BindableProperty(nameOrConfigOrTarget);
    return prop.registerWith(actualTarget, r, descriptor2);
  };

  if (!nameOrConfigOrTarget) {
    return deco;
  }

  if (key) {
    var _target = nameOrConfigOrTarget;
    nameOrConfigOrTarget = null;
    return deco(_target, key, descriptor);
  }

  return deco;
}

function dynamicOptions(target) {
  var deco = function deco(t) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
    r.hasDynamicOptions = true;
  };

  return target ? deco(target) : deco;
}

var defaultShadowDOMOptions = { mode: 'open' };
function useShadowDOM(targetOrOptions) {
  var options = typeof targetOrOptions === 'function' || !targetOrOptions ? defaultShadowDOMOptions : targetOrOptions;

  var deco = function deco(t) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
    r.targetShadowDOM = true;
    r.shadowDOMOptions = options;
  };

  return typeof targetOrOptions === 'function' ? deco(targetOrOptions) : deco;
}

function processAttributes(processor) {
  return function (t) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
    r.processAttributes = function (compiler, resources, node, attributes, elementInstruction) {
      try {
        processor(compiler, resources, node, attributes, elementInstruction);
      } catch (error) {
        LogManager.getLogger('templating').error(error);
      }
    };
  };
}

function doNotProcessContent() {
  return false;
}

function processContent(processor) {
  return function (t) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
    r.processContent = processor ? function (compiler, resources, node, instruction) {
      try {
        return processor(compiler, resources, node, instruction);
      } catch (error) {
        LogManager.getLogger('templating').error(error);
        return false;
      }
    } : doNotProcessContent;
  };
}

function containerless(target) {
  var deco = function deco(t) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
    r.containerless = true;
  };

  return target ? deco(target) : deco;
}

function useViewStrategy(strategy) {
  return function (target) {
    _aureliaMetadata.metadata.define(ViewLocator.viewStrategyMetadataKey, strategy, target);
  };
}

function useView(path) {
  return useViewStrategy(new RelativeViewStrategy(path));
}

function inlineView(markup, dependencies, dependencyBaseUrl) {
  return useViewStrategy(new InlineViewStrategy(markup, dependencies, dependencyBaseUrl));
}

function noView(targetOrDependencies, dependencyBaseUrl) {
  var target = void 0;
  var dependencies = void 0;
  if (typeof targetOrDependencies === 'function') {
    target = targetOrDependencies;
  } else {
    dependencies = targetOrDependencies;
    target = undefined;
  }

  var deco = function deco(t) {
    _aureliaMetadata.metadata.define(ViewLocator.viewStrategyMetadataKey, new NoViewStrategy(dependencies, dependencyBaseUrl), t);
  };

  return target ? deco(target) : deco;
}

function elementConfig(target) {
  var deco = function deco(t) {
    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ElementConfigResource(), t);
  };

  return target ? deco(target) : deco;
}

function viewResources() {
  for (var _len = arguments.length, resources = Array(_len), _key = 0; _key < _len; _key++) {
    resources[_key] = arguments[_key];
  }

  return function (target) {
    _aureliaMetadata.metadata.define(ViewEngine.viewModelRequireMetadataKey, resources, target);
  };
}

var TemplatingEngine = exports.TemplatingEngine = (_dec11 = (0, _aureliaDependencyInjection.inject)(_aureliaDependencyInjection.Container, ModuleAnalyzer, ViewCompiler, CompositionEngine), _dec11(_class18 = function () {
  function TemplatingEngine(container, moduleAnalyzer, viewCompiler, compositionEngine) {
    

    this._container = container;
    this._moduleAnalyzer = moduleAnalyzer;
    this._viewCompiler = viewCompiler;
    this._compositionEngine = compositionEngine;
    container.registerInstance(Animator, Animator.instance = new Animator());
  }

  TemplatingEngine.prototype.configureAnimator = function configureAnimator(animator) {
    this._container.unregister(Animator);
    this._container.registerInstance(Animator, Animator.instance = animator);
  };

  TemplatingEngine.prototype.compose = function compose(context) {
    return this._compositionEngine.compose(context);
  };

  TemplatingEngine.prototype.enhance = function enhance(instruction) {
    if (instruction instanceof _aureliaPal.DOM.Element) {
      instruction = { element: instruction };
    }

    var compilerInstructions = {};
    var resources = instruction.resources || this._container.get(ViewResources);

    this._viewCompiler._compileNode(instruction.element, resources, compilerInstructions, instruction.element.parentNode, 'root', true);

    var factory = new ViewFactory(instruction.element, compilerInstructions, resources);
    var container = instruction.container || this._container.createChild();
    var view = factory.create(container, BehaviorInstruction.enhance());

    view.bind(instruction.bindingContext || {}, instruction.overrideContext);

    view.firstChild = view.lastChild = view.fragment;
    view.fragment = _aureliaPal.DOM.createDocumentFragment();
    view.attached();

    return view;
  };

  return TemplatingEngine;
}()) || _class18);
});

define('aurelia-testing/dist/commonjs/aurelia-testing',['require','exports','module','./compile-spy','./view-spy','./component-tester','./wait'],function (require, exports, module) {"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./compile-spy"));
__export(require("./view-spy"));
__export(require("./component-tester"));
__export(require("./wait"));
function configure(config) {
    config.globalResources([
        './compile-spy',
        './view-spy'
    ]);
}
exports.configure = configure;

});

define('aurelia-testing/dist/commonjs/compile-spy',['require','exports','module','aurelia-templating','aurelia-dependency-injection','aurelia-logging','aurelia-pal'],function (require, exports, module) {"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var aurelia_templating_1 = require("aurelia-templating");
var aurelia_dependency_injection_1 = require("aurelia-dependency-injection");
var aurelia_logging_1 = require("aurelia-logging");
var aurelia_pal_1 = require("aurelia-pal");
/**
 * Attribute to be placed on any element to have it emit the View Compiler's
 * TargetInstruction into the debug console, giving you insight into all the
 * parsed bindings, behaviors and event handers for the targeted element.
 */
var CompileSpy = /** @class */ (function () {
    /**
     * Creates and instanse of CompileSpy.
     * @param element target element on where attribute is placed on.
     * @param instruction instructions for how the target element should be enhanced.
     */
    function CompileSpy(element, instruction) {
        aurelia_logging_1.getLogger('compile-spy').info(element.toString(), instruction);
    }
    CompileSpy = __decorate([
        aurelia_templating_1.customAttribute('compile-spy'),
        aurelia_dependency_injection_1.inject(aurelia_pal_1.DOM.Element, aurelia_templating_1.TargetInstruction)
    ], CompileSpy);
    return CompileSpy;
}());
exports.CompileSpy = CompileSpy;

});

define('aurelia-testing/dist/commonjs/component-tester',['require','exports','module','aurelia-templating','./wait'],function (require, exports, module) {"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var aurelia_templating_1 = require("aurelia-templating");
var wait_1 = require("./wait");
var StageComponent = /** @class */ (function () {
    function StageComponent() {
    }
    StageComponent.withResources = function (resources) {
        if (resources === void 0) { resources = []; }
        return new ComponentTester().withResources(resources);
    };
    return StageComponent;
}());
exports.StageComponent = StageComponent;
var ComponentTester = /** @class */ (function () {
    function ComponentTester() {
        this.resources = [];
    }
    ComponentTester.prototype.configure = function (aurelia) {
        return aurelia.use.standardConfiguration();
    };
    ComponentTester.prototype.bootstrap = function (configure) {
        this.configure = configure;
    };
    ComponentTester.prototype.withResources = function (resources) {
        this.resources = resources;
        return this;
    };
    ComponentTester.prototype.inView = function (html) {
        this.html = html;
        return this;
    };
    ComponentTester.prototype.boundTo = function (bindingContext) {
        this.bindingContext = bindingContext;
        return this;
    };
    ComponentTester.prototype.manuallyHandleLifecycle = function () {
        this._prepareLifecycle();
        return this;
    };
    ComponentTester.prototype.create = function (bootstrap) {
        var _this = this;
        return bootstrap(function (aurelia) {
            return Promise.resolve(_this.configure(aurelia)).then(function () {
                if (_this.resources) {
                    aurelia.use.globalResources(_this.resources);
                }
                return aurelia.start().then(function () {
                    _this.host = document.createElement('div');
                    _this.host.innerHTML = _this.html;
                    document.body.appendChild(_this.host);
                    return aurelia.enhance(_this.bindingContext, _this.host).then(function () {
                        _this.rootView = aurelia.root;
                        _this.element = _this.host.firstElementChild;
                        if (aurelia.root.controllers.length) {
                            _this.viewModel = aurelia.root.controllers[0].viewModel;
                        }
                        return new Promise(function (resolve) { return setTimeout(function () { return resolve(); }, 0); });
                    });
                });
            });
        });
    };
    ComponentTester.prototype.dispose = function () {
        if (this.host === undefined || this.rootView === undefined) {
            throw new Error('Cannot call ComponentTester.dispose() before ComponentTester.create()');
        }
        this.rootView.detached();
        this.rootView.unbind();
        return this.host.parentNode.removeChild(this.host);
    };
    ComponentTester.prototype._prepareLifecycle = function () {
        var _this = this;
        // bind
        var bindPrototype = aurelia_templating_1.View.prototype.bind;
        // tslint:disable-next-line:no-empty
        aurelia_templating_1.View.prototype.bind = function () { };
        this.bind = function (bindingContext) { return new Promise(function (resolve) {
            aurelia_templating_1.View.prototype.bind = bindPrototype;
            if (bindingContext !== undefined) {
                _this.bindingContext = bindingContext;
            }
            _this.rootView.bind(_this.bindingContext);
            setTimeout(function () { return resolve(); }, 0);
        }); };
        // attached
        var attachedPrototype = aurelia_templating_1.View.prototype.attached;
        // tslint:disable-next-line:no-empty
        aurelia_templating_1.View.prototype.attached = function () { };
        this.attached = function () { return new Promise(function (resolve) {
            aurelia_templating_1.View.prototype.attached = attachedPrototype;
            _this.rootView.attached();
            setTimeout(function () { return resolve(); }, 0);
        }); };
        // detached
        this.detached = function () { return new Promise(function (resolve) {
            _this.rootView.detached();
            setTimeout(function () { return resolve(); }, 0);
        }); };
        // unbind
        this.unbind = function () { return new Promise(function (resolve) {
            _this.rootView.unbind();
            setTimeout(function () { return resolve(); }, 0);
        }); };
    };
    ComponentTester.prototype.waitForElement = function (selector, options) {
        var _this = this;
        return wait_1.waitFor(function () { return _this.element.querySelector(selector); }, options);
    };
    ComponentTester.prototype.waitForElements = function (selector, options) {
        var _this = this;
        return wait_1.waitFor(function () { return _this.element.querySelectorAll(selector); }, options);
    };
    return ComponentTester;
}());
exports.ComponentTester = ComponentTester;

});

define('aurelia-testing/dist/commonjs/view-spy',['require','exports','module','aurelia-templating','aurelia-logging'],function (require, exports, module) {"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var aurelia_templating_1 = require("aurelia-templating");
var aurelia_logging_1 = require("aurelia-logging");
/**
 * Attribute to be placed on any HTML element in a view to emit the View instance
 * to the debug console, giving you insight into the live View instance, including
 * all child views, live bindings, behaviors and more.
 */
var ViewSpy = /** @class */ (function () {
    /**
     * Creates a new instance of ViewSpy.
     */
    function ViewSpy() {
        this.logger = aurelia_logging_1.getLogger('view-spy');
    }
    ViewSpy.prototype._log = function (lifecycleName, context) {
        if (!this.value && lifecycleName === 'created') {
            this.logger.info(lifecycleName, this.view);
        }
        else if (this.value && this.value.indexOf(lifecycleName) !== -1) {
            this.logger.info(lifecycleName, this.view, context);
        }
    };
    /**
     * Invoked when the target view is created.
     * @param view The target view.
     */
    ViewSpy.prototype.created = function (view) {
        this.view = view;
        this._log('created');
    };
    /**
     * Invoked when the target view is bound.
     * @param bindingContext The target view's binding context.
     */
    ViewSpy.prototype.bind = function (bindingContext) {
        this._log('bind', bindingContext);
    };
    /**
     * Invoked when the target element is attached to the DOM.
     */
    ViewSpy.prototype.attached = function () {
        this._log('attached');
    };
    /**
     * Invoked when the target element is detached from the DOM.
     */
    ViewSpy.prototype.detached = function () {
        this._log('detached');
    };
    /**
     * Invoked when the target element is unbound.
     */
    ViewSpy.prototype.unbind = function () {
        this._log('unbind');
    };
    ViewSpy = __decorate([
        aurelia_templating_1.customAttribute('view-spy')
    ], ViewSpy);
    return ViewSpy;
}());
exports.ViewSpy = ViewSpy;

});

define('aurelia-testing/dist/commonjs/wait',['require','exports','module'],function (require, exports, module) {"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Generic function to wait for something to happen. Uses polling
 * @param getter: a getter function that returns anything else than `null` or an
 *                empty array or an empty jQuery object when the
 *                condition is met
 * @param options: lookup options, defaults to
 *                 `{present: true, interval: 50, timeout: 5000}`
 */
function waitFor(getter, options) {
    if (options === void 0) { options = { present: true, interval: 50, timeout: 5000 }; }
    // prevents infinite recursion if the request times out
    var timedOut = false;
    options = __assign({ present: true, interval: 50, timeout: 5000 }, options);
    function wait() {
        var element = getter();
        // boolean is needed here, hence the length > 0
        var found = element !== null && (!(element instanceof NodeList) &&
            !element.jquery || element.length > 0);
        if (!options.present === !found || timedOut) {
            return Promise.resolve(element);
        }
        return new Promise(function (rs) { return setTimeout(rs, options.interval); }).then(wait);
    }
    return Promise.race([
        new Promise(function (_, rj) { return setTimeout(function () {
            timedOut = true;
            rj(options.present ? 'Element not found' : 'Element not removed');
        }, options.timeout); }),
        wait()
    ]);
}
exports.waitFor = waitFor;
function waitForDocumentElement(selector, options) {
    return waitFor(function () { return document.querySelector(selector); }, options);
}
exports.waitForDocumentElement = waitForDocumentElement;
function waitForDocumentElements(selector, options) {
    return waitFor(function () { return document.querySelectorAll(selector); }, options);
}
exports.waitForDocumentElements = waitForDocumentElements;

});

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("aurelia-event-aggregator")):"function"==typeof define&&define.amd?define('bcx-aurelia-dnd/dist/index',["exports","aurelia-event-aggregator"],t):t(e.BcxAureliaDnd={},e.AureliaEventAggregator)}(this,function(e,t){"use strict";var n="undefined"!=typeof self?self:"undefined"!=typeof global?global:new Function("return this")();function i(e){if("TR"===e.tagName&&e.parentNode&&e.parentNode.parentNode&&"TABLE"===e.parentNode.parentNode.tagName){for(var t=e.cloneNode(!0),i=e.childElementCount,r=0;r<i-1;r++){var s=n.getComputedStyle(e.children[r]);t.children[r].style.width=s.width,t.children[r].style.height=s.height}var o=e.parentNode,a=o.cloneNode();a.appendChild(t);var d=o.parentNode,h=d.cloneNode();h.appendChild(a);var l=n.getComputedStyle(d);return h.style.width=l.width,h}}function r(e){if("LI"===e.tagName&&e.parentNode&&("UL"===e.parentNode.tagName||"OL"===e.parentNode.tagName)){var t=e.cloneNode(!0),i=n.getComputedStyle(e);t.style.width=i.width,t.style.height=i.height,t.style.flex="0 0 auto";var r=e.parentNode.cloneNode();return r.appendChild(t),r.style.width="auto",r.style.height="auto",r.style.listStyleType="none",r}}function s(e){var t=e.cloneNode(!0),i=n.getComputedStyle(e);return t.style.width=i.width,t.style.height=i.height,t}var o=function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")},a=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),d=n.document,h=d&&d.documentElement,l="\n/* bcx-aurelia-dnd styles */\n\n/*\nbcx-aurelia-dnd relies on html/body margin 0.\nYour css stack should have done this.\nAdded here as safe guard.\n*/\nhtml, body {\n  margin: 0;\n}\n\n.bcx-dnd-preview {\n  position: absolute !important;\n  margin: 0 !important;\n  z-index: 9999 !important;\n  opacity: 0.8;\n  box-shadow: 0 0 16px gray;\n}\n\n.bcx-dnd-preview .bcx-dnd-preview-hide {\n  visibility: hidden !important;\n}\n\n.bcx-dnd-hide {\n  display: none !important;\n}\n\n.bcx-dnd-hide-cursor .bcx-dnd-preview {\n  cursor: none !important;\n}\n\n.bcx-dnd-unselectable {\n  -webkit-user-select: none !important;\n  -moz-user-select: none !important;\n  -ms-user-select: none !important;\n  user-select: none !important;\n}\n",u=!1;var c=function(){var e={},t="(?:^|\\s)",n="(?:\\s|$)";function i(i){var r=e[i];return r?r.lastIndex=0:e[i]=r=new RegExp(t+i+n,"g"),r}return{add:function(e,t){var n=e.className;n.length?i(t).test(n)||(e.className+=" "+t):e.className=t},rm:function(e,t){e.className=e.className.replace(i(t)," ").trim()}}}();function v(e){if(void 0!==e.touches)return e.touches.length;if(void 0!==e.which&&0!==e.which)return e.which;if(void 0!==e.buttons)return e.buttons;var t=e.button;return void 0!==t?1&t?1:2&t?3:4&t?2:0:void 0}function g(e){var t=e.getBoundingClientRect();return{x:t.left+f("scrollLeft","pageXOffset"),y:t.top+f("scrollTop","pageYOffset"),width:m(t),height:p(t)}}function f(e,t){return void 0!==window[t]?window[t]:h.clientHeight?h[e]:d.body[e]}function m(e){return e.width||e.right-e.left}function p(e){return e.height||e.bottom-e.top}function _(e){return e.parentNode===d?null:e.parentNode}function w(e){return"INPUT"===e.tagName||"TEXTAREA"===e.tagName||"SELECT"===e.tagName||function e(t){if(!t)return!1;if("false"===t.contentEditable)return!1;if("true"===t.contentEditable)return!0;return e(_(t))}(e)}function b(e,t){var n=function(e){return e.targetTouches&&e.targetTouches.length?e.targetTouches[0]:e.changedTouches&&e.changedTouches.length?e.changedTouches[0]:e}(t),i={pageX:"clientX",pageY:"clientY"};return e in i&&!(e in n)&&i[e]in n&&(e=i[e]),n[e]}function y(e,t){for(var i=t instanceof n.Element?function(e){return e.element===t}:function(e){return e.delegate===t},r=e.length,s=0;s<r;s+=1)if(i(e[s]))return s;return-1}var E=function(){function e(t){o(this,e),this.dndSources=[],this.dndTargets=[],this.previewDrawers=[],this.ea=t,function(){if(!u){u=!0;var e=d.createElement("style");e.innerHTML=l,e.type="text/css",d.head.childNodes.length>0?d.head.insertBefore(e,d.head.childNodes[0]):d.head.appendChild(e)}}(),this.addPreviewDrawer(s),this.addPreviewDrawer(r),this.addPreviewDrawer(i),this._grab=this._grab.bind(this),this._release=this._release.bind(this),this._startBecauseMouseMoved=this._startBecauseMouseMoved.bind(this),this._preventGrabbed=this._preventGrabbed.bind(this),this._drag=this._drag.bind(this),h.addEventListener("mousedown",this._grab,{passive:!1}),h.addEventListener("touchstart",this._grab,{passive:!1}),h.addEventListener("mouseup",this._release,{passive:!1})}return a(e,[{key:"addPreviewDrawer",value:function(e){this.previewDrawers.unshift(e)}},{key:"addSource",value:function(e,t){this.dndSources.push(new function e(t){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(o(this,e),!t)throw new Error("Missing delegate for dnd source.");if("function"!=typeof t.dndModel)throw new Error("Missing dndModel() method on dnd source delegate.");if(this.delegate=t,i.element?this.element=i.element:this.element=t.dndElement,i.handler){if(!(i.handler instanceof n.Element))throw new Error("specified handler is not a DOM element");this.handler=i.handler}else this.handler=this.element;if(!(this.element instanceof n.Element))throw new Error("Missing dndElement or options.element on dnd source delegate.");i.noPreview&&(this.noPreview=!0),i.hideCursor&&(this.hideCursor=!0),i.centerPreviewToMousePosition&&(this.centerPreviewToMousePosition=!0)}(e,t))}},{key:"removeSource",value:function(e){var t=y(this.dndSources,e);t>=0&&this.dndSources.splice(t,1)}},{key:"addTarget",value:function(e,t){e.dnd={};var i=new function e(t){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(o(this,e),!t)throw new Error("Missing delegate for dnd target.");if("function"!=typeof t.dndCanDrop)throw new Error("Missing dndCanDrop() method on delegate.");if("function"!=typeof t.dndDrop)throw new Error("Missing dndDrop() method on dnd target delegate.");if(this.delegate=t,i.element?this.element=i.element:this.element=t.dndElement,!(this.element instanceof n.Element))throw new Error("Missing dndElement or options.element on dnd target delegate.");"function"==typeof t.dndHover&&(this.dndHover=t.dndHover.bind(t))}(e,t);if(this.isProcessing){var r=i.delegate.dndCanDrop(this.model),s=i.delegate.dnd;s.canDrop=r,s.isProcessing=!0,s.model=this.model}this.dndTargets.push(i)}},{key:"removeTarget",value:function(e){var t=y(this.dndTargets,e);t>=0&&(this.dndTargets[t].delegate.dnd=null,this.dndTargets.splice(t,1))}},{key:"_sourceOf",value:function(e){var t=function(e,t){for(var n=e.length,i=0;i<n;i+=1)if(e[i].handler===t)return i;return-1}(this.dndSources,e);return t>=0?this.dndSources[t]:void 0}},{key:"_startListeningEventualMovements",value:function(){h.addEventListener("mousemove",this._startBecauseMouseMoved,{passive:!1}),this._element&&this._element.addEventListener("touchmove",this._startBecauseMouseMoved,{passive:!1}),this._element&&this._element.addEventListener("touchend",this._release,{passive:!1})}},{key:"_stopListeningEventualMovements",value:function(){h.removeEventListener("mousemove",this._startBecauseMouseMoved),this._element&&this._element.removeEventListener("touchmove",this._startBecauseMouseMoved)}},{key:"_startListeningMovements",value:function(){h.addEventListener("selectstart",this._preventGrabbed),h.addEventListener("click",this._preventGrabbed),h.addEventListener("mousemove",this._drag,{passive:!1}),this._element&&this._element.addEventListener("touchmove",this._drag,{passive:!1})}},{key:"_stopListeningMovements",value:function(){h.removeEventListener("selectstart",this._preventGrabbed),h.removeEventListener("click",this._preventGrabbed),h.removeEventListener("mousemove",this._drag),this._element&&this._element.removeEventListener("touchmove",this._drag),this._element&&this._element.removeEventListener("touchend",this._release)}},{key:"_preventGrabbed",value:function(e){this._grabbed&&e.preventDefault()}},{key:"_grab",value:function(e){if(this._moveX=e.clientX,this._moveY=e.clientY,!(1!==v(e)||e.metaKey||e.ctrlKey)){var t=e.target;this._element=t;var n=this._startingSource(t);n&&(this._grabbed=n,this._startListeningEventualMovements(),"mousedown"===e.type&&w(t)?t.focus():e.preventDefault())}}},{key:"_ungrab",value:function(){this._grabbed=void 0,this._stopListeningEventualMovements(),this._stopListeningMovements(),this._element=void 0}},{key:"_release",value:function(e){if(this._ungrab(),this.isProcessing){this.ea&&this.ea.publish("dnd:willEnd");var t=this._landingTargets(e).shallowTarget;t&&t.delegate.dndDrop(this._locationInfo(t.element,e)),this._cleanup(),this.ea&&this.ea.publish("dnd:didEnd")}}},{key:"_startingSource",value:function(e){if(!this.isProcessing){for(var t=this._sourceOf(e);!t&&e&&(e=_(e));)t=this._sourceOf(e);return t}}},{key:"_startBecauseMouseMoved",value:function(e){if(this._grabbed)if(0!==v(e)){if(void 0===e.clientX||e.clientX!==this._moveX||void 0===e.clientY||e.clientY!==this._moveY){var t=b("clientX",e),n=b("clientY",e);if(!w(d.elementFromPoint(t,n))){var i=this._grabbed;this._stopListeningEventualMovements(),this._startListeningMovements(),this.isProcessing&&this._cleanup(),this._start(i),this._sourceElementRect=g(this._sourceElement),this._offsetX=b("pageX",e)-this._sourceElementRect.x,this._offsetY=b("pageY",e)-this._sourceElementRect.y,this._renderPreviewImage(),this._drag(e)}}}else this._cleanup()}},{key:"_start",value:function(e){var t=this;this.ea&&this.ea.publish("dnd:willStart"),this.isProcessing=!0,this.model=e.delegate.dndModel(),this._sourceElement=e.element,e.noPreview?this._noPreview=!0:e.delegate.dndPreview&&(this._sourcePreview=e.delegate.dndPreview(this.model)),this._noPreview||(e.hideCursor&&(this._hideCursor=!0),e.centerPreviewToMousePosition&&(this._centerPreviewToMousePosition=!0)),this.dndTargets.forEach(function(e){var n=e.delegate.dndCanDrop(t.model),i=e.delegate.dnd;i.canDrop=n,i.isProcessing=!0,i.model=t.model}),this.ea&&this.ea.publish("dnd:didStart")}},{key:"_cleanup",value:function(){this._ungrab(),this._removePreviewImage(),this.isProcessing=void 0,this.model=void 0,this._sourceElement=void 0,this._noPreview=void 0,this._hideCursor=void 0,this._centerPreviewToMousePosition=void 0,this._sourcePreview=void 0,this._sourceElementRect=void 0,this._offsetX=0,this._offsetY=0,this.dndTargets.forEach(function(e){var t=e.delegate.dnd;t.canDrop=void 0,t.isProcessing=void 0,t.isHoveringShallowly=void 0,t.isHovering=void 0,t.model=void 0})}},{key:"_landingTargets",value:function(e){if(!this.isProcessing)return{shallowTarget:null,possibleTargets:[]};for(var t,n,i,r,s,o,a,h=b("clientX",e),l=b("clientY",e),u=this.dndTargets.filter(function(e){if(e.delegate.dnd.canDrop){var t=e.element.getBoundingClientRect();return t.left<=h&&t.right>=h&&t.top<=l&&t.bottom>=l}}),c=void 0,v=(t=this._preview,n=h,i=l,o=(s=t||{}).className,s.className+=" bcx-dnd-hide",r=d.elementFromPoint(n,i),s.className=o,r);!c&&v;){var g=y(u,v);g>=0?c=u[g]:v=_(v)}if(c)u.splice(u.indexOf(c),1);else if(u.length>0){var f=(a=u,Array.isArray(a)?a:Array.from(a));c=f[0],u=f.slice(1)}return{shallowTarget:c,possibleTargets:u}}},{key:"_drag",value:function(e){var t=this;if(this.isProcessing){e.preventDefault(),this._updatePreviewLocation(e);var n=this._landingTargets(e),i=n.shallowTarget,r=n.possibleTargets;this.dndTargets.forEach(function(n){var s=n.delegate.dnd;s.isProcessing&&(n===i?(s.isHoveringShallowly=!0,s.isHovering=!0,n.dndHover&&n.dndHover(t._locationInfo(n.element,e))):r.indexOf(n)>=0?(s.isHoveringShallowly=!1,s.isHovering=!0,n.dndHover&&n.dndHover(t._locationInfo(n.element,e))):(s.isHoveringShallowly=!1,s.isHovering=!1))})}}},{key:"_updatePreviewLocation",value:function(e){if(this._preview){var t=b("pageX",e),n=b("pageY",e);if(this._centerPreviewToMousePosition){var i=this._preview.getBoundingClientRect(),r=m(i),s=p(i);this._preview.style.left=t-Math.floor(r/2)+"px",this._preview.style.top=n-Math.floor(s/2)+"px"}else this._preview.style.left=t-this._offsetX+"px",this._preview.style.top=n-this._offsetY+"px"}}},{key:"_locationInfo",value:function(e,t){var n={x:this._sourceElementRect.x+this._offsetX,y:this._sourceElementRect.y+this._offsetY},i=b("pageX",t),r=b("pageY",t),s={x:i,y:r},o=g(e),a=void 0;return a=this._preview?g(this._preview):{x:i-this._offsetX,y:r-this._offsetY,width:this._sourceElementRect.width,height:this._sourceElementRect.height},{mouseStartAt:n,mouseEndAt:s,sourceElementRect:this._sourceElementRect,targetElementRect:o,previewElementRect:a}}},{key:"_renderPreviewImage",value:function(){if(!this._preview&&!this._noPreview){var e=!!this._sourcePreview;if(e)this._preview=this._sourcePreview,this._sourcePreview=void 0;else{var t=this._sourceElement;if(!t)return;for(var i=0;i<this.previewDrawers.length&&(this._preview=this.previewDrawers[i](t),!this._preview);i++);if(!this._preview)return}c.add(this._preview,"bcx-dnd-preview"),d.body.appendChild(this._preview),c.add(d.body,"bcx-dnd-unselectable"),e||"rgba(0, 0, 0, 0)"!==n.getComputedStyle(this._preview).backgroundColor||(this._preview.style.backgroundColor="white"),this._hideCursor&&c.add(d.body,"bcx-dnd-hide-cursor")}}},{key:"_removePreviewImage",value:function(){this._preview&&(c.rm(d.body,"bcx-dnd-unselectable"),c.rm(d.body,"bcx-dnd-hide-cursor"),_(this._preview).removeChild(this._preview),this._preview=null)}}]),e}();E.inject=[t.EventAggregator],e.DndService=E,Object.defineProperty(e,"__esModule",{value:!0})});

define('bcx-aurelia-reorderable-repeat/dist/index',['require','exports','module','aurelia-pal','./reorderable-repeat','./reorderable-direction','./reorderable-dnd-preview','./reorderable-dnd-handler-selector','./reorderable-after-reordering'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.ReorderableAfterReordering = exports.ReorderableDndHandlerSelector = exports.ReorderableDndPreview = exports.ReorderableDirection = exports.ReorderableRepeat = undefined;
exports.configure = configure;

var _aureliaPal = require('aurelia-pal');

var _reorderableRepeat = require('./reorderable-repeat');

var _reorderableDirection = require('./reorderable-direction');

var _reorderableDndPreview = require('./reorderable-dnd-preview');

var _reorderableDndHandlerSelector = require('./reorderable-dnd-handler-selector');

var _reorderableAfterReordering = require('./reorderable-after-reordering');

var css = '\n.reorderable-repeat-dragging-me {\n  visibility: hidden;\n}\n';

function configure(config) {
  _aureliaPal.DOM.injectStyles(css);

  config.globalResources([_aureliaPal.PLATFORM.moduleName('./reorderable-repeat'), _aureliaPal.PLATFORM.moduleName('./reorderable-direction'), _aureliaPal.PLATFORM.moduleName('./reorderable-dnd-preview'), _aureliaPal.PLATFORM.moduleName('./reorderable-dnd-handler-selector'), _aureliaPal.PLATFORM.moduleName('./reorderable-after-reordering')]);
}

exports.ReorderableRepeat = _reorderableRepeat.ReorderableRepeat;
exports.ReorderableDirection = _reorderableDirection.ReorderableDirection;
exports.ReorderableDndPreview = _reorderableDndPreview.ReorderableDndPreview;
exports.ReorderableDndHandlerSelector = _reorderableDndHandlerSelector.ReorderableDndHandlerSelector;
exports.ReorderableAfterReordering = _reorderableAfterReordering.ReorderableAfterReordering;
});

define('bcx-aurelia-reorderable-repeat/dist/reorderable-after-reordering',['require','exports','module','aurelia-templating'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.ReorderableAfterReordering = undefined;

var _dec, _class;

var _aureliaTemplating = require('aurelia-templating');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReorderableAfterReordering = exports.ReorderableAfterReordering = (_dec = (0, _aureliaTemplating.customAttribute)('reorderable-after-reordering'), _dec(_class = function () {
  function ReorderableAfterReordering() {
    _classCallCheck(this, ReorderableAfterReordering);
  }

  ReorderableAfterReordering.prototype.attached = function attached() {};

  ReorderableAfterReordering.prototype.bind = function bind(bindingContext, overrideContext) {
    this.scope = { bindingContext: bindingContext, overrideContext: overrideContext };
  };

  return ReorderableAfterReordering;
}()) || _class);
});

define('bcx-aurelia-reorderable-repeat/dist/reorderable-direction',['require','exports','module','aurelia-templating'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.ReorderableDirection = undefined;

var _dec, _class;

var _aureliaTemplating = require('aurelia-templating');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReorderableDirection = exports.ReorderableDirection = (_dec = (0, _aureliaTemplating.customAttribute)('reorderable-direction'), _dec(_class = function () {
  function ReorderableDirection() {
    _classCallCheck(this, ReorderableDirection);
  }

  ReorderableDirection.prototype.attached = function attached() {};

  ReorderableDirection.prototype.bind = function bind(bindingContext, overrideContext) {
    this.scope = { bindingContext: bindingContext, overrideContext: overrideContext };
  };

  return ReorderableDirection;
}()) || _class);
});

define('bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-handler-selector',['require','exports','module','aurelia-templating'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.ReorderableDndHandlerSelector = undefined;

var _dec, _class;

var _aureliaTemplating = require('aurelia-templating');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReorderableDndHandlerSelector = exports.ReorderableDndHandlerSelector = (_dec = (0, _aureliaTemplating.customAttribute)('reorderable-dnd-handler-selector'), _dec(_class = function () {
  function ReorderableDndHandlerSelector() {
    _classCallCheck(this, ReorderableDndHandlerSelector);
  }

  ReorderableDndHandlerSelector.prototype.attached = function attached() {};

  ReorderableDndHandlerSelector.prototype.bind = function bind(bindingContext, overrideContext) {
    this.scope = { bindingContext: bindingContext, overrideContext: overrideContext };
  };

  return ReorderableDndHandlerSelector;
}()) || _class);
});

define('bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-preview',['require','exports','module','aurelia-templating'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.ReorderableDndPreview = undefined;

var _dec, _class;

var _aureliaTemplating = require('aurelia-templating');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReorderableDndPreview = exports.ReorderableDndPreview = (_dec = (0, _aureliaTemplating.customAttribute)('reorderable-dnd-preview'), _dec(_class = function () {
  function ReorderableDndPreview() {
    _classCallCheck(this, ReorderableDndPreview);
  }

  ReorderableDndPreview.prototype.attached = function attached() {};

  ReorderableDndPreview.prototype.bind = function bind(bindingContext, overrideContext) {
    this.scope = { bindingContext: bindingContext, overrideContext: overrideContext };
  };

  return ReorderableDndPreview;
}()) || _class);
});

define('bcx-aurelia-reorderable-repeat/dist/reorderable-repeat',['require','exports','module','aurelia-dependency-injection','aurelia-binding','aurelia-templating','aurelia-templating-resources','./reorderable-repeat-strategy-locator','bcx-aurelia-dnd','aurelia-event-aggregator','aurelia-task-queue'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.ReorderableRepeat = undefined;

var _dec, _dec2, _class, _desc, _value, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaBinding = require('aurelia-binding');

var _aureliaTemplating = require('aurelia-templating');

var _aureliaTemplatingResources = require('aurelia-templating-resources');

var _reorderableRepeatStrategyLocator = require('./reorderable-repeat-strategy-locator');

var _bcxAureliaDnd = require('bcx-aurelia-dnd');

var _aureliaEventAggregator = require('aurelia-event-aggregator');

var _aureliaTaskQueue = require('aurelia-task-queue');

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var seed = 0;

var classes = function () {
  var cache = {};
  var start = '(?:^|\\s)';
  var end = '(?:\\s|$)';

  function lookupClass(className) {
    var cached = cache[className];
    if (cached) {
      cached.lastIndex = 0;
    } else {
      cache[className] = cached = new RegExp(start + className + end, 'g');
    }
    return cached;
  }

  function addClass(el, className) {
    var current = el.className;
    if (!current.length) {
      el.className = className;
    } else if (!lookupClass(className).test(current)) {
      el.className += ' ' + className;
    }
  }

  function rmClass(el, className) {
    el.className = el.className.replace(lookupClass(className), ' ').trim();
  }
  return { add: addClass, rm: rmClass };
}();

var ReorderableRepeat = exports.ReorderableRepeat = (_dec = (0, _aureliaTemplating.customAttribute)('reorderable-repeat'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaEventAggregator.EventAggregator, _aureliaTaskQueue.TaskQueue, _aureliaBinding.BindingEngine, _bcxAureliaDnd.DndService, _aureliaTemplating.BoundViewFactory, _aureliaTemplating.TargetInstruction, _aureliaTemplating.ViewSlot, _aureliaTemplating.ViewResources, _aureliaBinding.ObserverLocator, _reorderableRepeatStrategyLocator.ReorderableRepeatStrategyLocator), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = (_class2 = function (_AbstractRepeater) {
  _inherits(ReorderableRepeat, _AbstractRepeater);

  function ReorderableRepeat(ea, taskQueue, bindingEngine, dndService, viewFactory, instruction, viewSlot, viewResources, observerLocator, strategyLocator) {
    _classCallCheck(this, ReorderableRepeat);

    var _this = _possibleConstructorReturn(this, _AbstractRepeater.call(this, {
      local: 'item',
      viewsRequireLifecycle: (0, _aureliaTemplatingResources.viewsRequireLifecycle)(viewFactory)
    }));

    _initDefineProp(_this, 'items', _descriptor, _this);

    _initDefineProp(_this, 'local', _descriptor2, _this);

    _initDefineProp(_this, 'intention', _descriptor3, _this);

    _initDefineProp(_this, 'patchedItems', _descriptor4, _this);

    _this.type = 'reorder-' + seed;
    seed += 1;

    _this.ea = ea;
    _this.taskQueue = taskQueue;
    _this.bindingEngine = bindingEngine;
    _this.dndService = dndService;
    _this.viewFactory = viewFactory;
    _this.instruction = instruction;
    _this.viewSlot = viewSlot;
    _this.lookupFunctions = viewResources.lookupFunctions;
    _this.observerLocator = observerLocator;
    _this.strategyLocator = strategyLocator;
    _this.ignoreMutation = false;
    _this.sourceExpression = (0, _aureliaTemplatingResources.getItemsSourceExpression)(_this.instruction, 'reorderable-repeat.for');
    if (_this.sourceExpression instanceof _aureliaBinding.BindingBehavior) {
      throw new Error('BindingBehavior is not supported in reorderable-repeat');
    }
    if (_this.sourceExpression instanceof _aureliaBinding.ValueConverter) {
      throw new Error('ValueConverter is not supported in reorderable-repeat');
    }
    if ((0, _aureliaTemplatingResources.isOneTime)(_this.sourceExpression)) {
      throw new Error('oneTime binding is not supported in reorderable-repeat');
    }
    _this.viewsRequireLifecycle = (0, _aureliaTemplatingResources.viewsRequireLifecycle)(viewFactory);
    return _this;
  }

  ReorderableRepeat.prototype.call = function call(context, changes) {
    this[context](this.items, changes);
  };

  ReorderableRepeat.prototype.bind = function bind(bindingContext, overrideContext) {
    var _this2 = this;

    this.scope = { bindingContext: bindingContext, overrideContext: overrideContext };
    this.matcherBinding = this._captureAndRemoveMatcherBinding();
    this.arrayObserver = this.bindingEngine.collectionObserver(this.items).subscribe(this._itemsMutated.bind(this));
    this._subsribers = [this.ea.subscribe('dnd:willStart', function () {
      _this2.intention = null;
      _this2.views().forEach(function (v) {
        classes.rm(v.firstChild, 'reorderable-repeat-reordering');
        classes.rm(v.firstChild, 'reorderable-repeat-dragging-me');
      });
    }), this.ea.subscribe('dnd:didEnd', function () {
      _this2.views().forEach(function (v) {
        classes.rm(v.firstChild, 'reorderable-repeat-reordering');
        classes.rm(v.firstChild, 'reorderable-repeat-dragging-me');
      });

      if (!_this2.intention) return;
      var _intention = _this2.intention,
          fromIndex = _intention.fromIndex,
          toIndex = _intention.toIndex;

      _this2.intention = null;

      if (fromIndex === toIndex) return;

      var item = _this2.items[fromIndex];
      _this2.items.splice(fromIndex, 1);
      _this2.items.splice(toIndex, 0, item);

      var afterReordering = _this2._reorderableAfterReorderingFunc();
      if (afterReordering) afterReordering(_this2.items);
    })];
    this.patchedItems = [].concat(this.items);
    this.patchedItemsChanged();
  };

  ReorderableRepeat.prototype.unbind = function unbind() {
    this.scope = null;
    this.items = null;
    this.matcherBinding = null;
    this.viewSlot.removeAll(true);
    if (this.arrayObserver) {
      this.arrayObserver.dispose();
      this.arrayObserver = null;
    }
    this._subsribers.forEach(function (s) {
      return s.dispose();
    });
    this._subsribers = [];
  };

  ReorderableRepeat.prototype.intentionChanged = function intentionChanged(newIntention) {
    if (newIntention) {
      var fromIndex = newIntention.fromIndex,
          toIndex = newIntention.toIndex;

      var patched = [].concat(this.items);
      var item = this.items[fromIndex];
      patched.splice(fromIndex, 1);
      patched.splice(toIndex, 0, item);
      this.patchedItems = patched;
    }
  };

  ReorderableRepeat.prototype.itemsChanged = function itemsChanged(newVal, oldVal) {
    if (!this.scope) {
      return;
    }

    if (this.arrayObserver) {
      this.arrayObserver.dispose();
      this.arrayObserver = null;
    }

    this.arrayObserver = this.bindingEngine.collectionObserver(this.items).subscribe(this._itemsMutated.bind(this));

    if (this.intention === null) {
      this.patchedItems = [].concat(this.items);
    } else {
      this.intention = null;
    }
  };

  ReorderableRepeat.prototype._itemsMutated = function _itemsMutated() {
    if (this.intention === null) {
      this.patchedItems = [].concat(this.items);
    } else {
      this.intention = null;
    }
  };

  ReorderableRepeat.prototype.patchedItemsChanged = function patchedItemsChanged() {
    if (!this.scope) {
      return;
    }

    this.strategy = this.strategyLocator.getStrategy(this.patchedItems);
    if (!this.strategy) {
      throw new Error('Value for \'' + this.sourceExpression + '\' is non-repeatable');
    }

    this.strategy.instanceChanged(this, this.patchedItems);
  };

  ReorderableRepeat.prototype._captureAndRemoveMatcherBinding = function _captureAndRemoveMatcherBinding() {
    if (this.viewFactory.viewFactory) {
      var instructions = this.viewFactory.viewFactory.instructions;
      var instructionIds = Object.keys(instructions);
      for (var i = 0; i < instructionIds.length; i++) {
        var expressions = instructions[instructionIds[i]].expressions;
        if (expressions) {
          for (var ii = 0; i < expressions.length; i++) {
            if (expressions[ii].targetProperty === 'matcher') {
              var matcherBinding = expressions[ii];
              expressions.splice(ii, 1);
              return matcherBinding;
            }
          }
        }
      }
    }

    return undefined;
  };

  ReorderableRepeat.prototype.viewCount = function viewCount() {
    return this.viewSlot.children.length;
  };

  ReorderableRepeat.prototype.views = function views() {
    return this.viewSlot.children;
  };

  ReorderableRepeat.prototype.view = function view(index) {
    return this.viewSlot.children[index];
  };

  ReorderableRepeat.prototype.matcher = function matcher() {
    return this.matcherBinding ? this.matcherBinding.sourceExpression.evaluate(this.scope, this.matcherBinding.lookupFunctions) : null;
  };

  ReorderableRepeat.prototype.addView = function addView(bindingContext, overrideContext) {
    var view = this.viewFactory.create();
    window.ttview = view;
    view.bind(bindingContext, overrideContext);
    this.viewSlot.add(view);
    window.ttview = view;
    this._registerDnd(view);
  };

  ReorderableRepeat.prototype.insertView = function insertView(index, bindingContext, overrideContext) {
    var view = this.viewFactory.create();
    view.bind(bindingContext, overrideContext);
    this.viewSlot.insert(index, view);
    this._registerDnd(view);
  };

  ReorderableRepeat.prototype.moveView = function moveView(sourceIndex, targetIndex) {
    this.viewSlot.move(sourceIndex, targetIndex);
  };

  ReorderableRepeat.prototype.removeAllViews = function removeAllViews(returnToCache, skipAnimation) {
    var _this3 = this;

    this.views().forEach(function (view) {
      return _this3._unRegisterDnd(view);
    });
    return this.viewSlot.removeAll(returnToCache, skipAnimation);
  };

  ReorderableRepeat.prototype.removeViews = function removeViews(viewsToRemove, returnToCache, skipAnimation) {
    var _this4 = this;

    viewsToRemove.forEach(function (view) {
      return _this4._unRegisterDnd(view);
    });
    return this.viewSlot.removeMany(viewsToRemove, returnToCache, skipAnimation);
  };

  ReorderableRepeat.prototype.removeView = function removeView(index, returnToCache, skipAnimation) {
    this._unRegisterDnd(this.view(index));
    return this.viewSlot.removeAt(index, returnToCache, skipAnimation);
  };

  ReorderableRepeat.prototype.updateBindings = function updateBindings(view) {
    this._unRegisterDnd(view);

    var j = view.bindings.length;
    while (j--) {
      (0, _aureliaTemplatingResources.updateOneTimeBinding)(view.bindings[j]);
    }
    j = view.controllers.length;
    while (j--) {
      var k = view.controllers[j].boundProperties.length;
      while (k--) {
        var binding = view.controllers[j].boundProperties[k].binding;
        (0, _aureliaTemplatingResources.updateOneTimeBinding)(binding);
      }
    }

    this._registerDnd(view);
  };

  ReorderableRepeat.prototype._additionalAttribute = function _additionalAttribute(view, attribute) {
    return view && view.firstChild && view.firstChild.au && view.firstChild.au[attribute] ? view.firstChild.au[attribute].instruction.attributes[attribute] : undefined;
  };

  ReorderableRepeat.prototype._reorderableDirection = function _reorderableDirection(view) {
    var attr = this._additionalAttribute(view, 'reorderable-direction');
    if (attr && attr.sourceExpression) {
      attr = attr.sourceExpression.evaluate(this.scope);
    }

    if (typeof attr === 'string') {
      return attr.toLowerCase() || 'down';
    }
    return 'down';
  };

  ReorderableRepeat.prototype._dndHandlerSelector = function _dndHandlerSelector(view) {
    var attr = this._additionalAttribute(view, 'reorderable-dnd-handler-selector');
    if (attr && attr.sourceExpression) {
      attr = attr.sourceExpression.evaluate(this.scope);
    }

    if (typeof attr === 'string') {
      return attr;
    }
  };

  ReorderableRepeat.prototype._dndPreviewFunc = function _dndPreviewFunc(view) {
    var func = this._additionalAttribute(view, 'reorderable-dnd-preview');

    if (!func) {
      return null;
    } else if (typeof func === 'string') {
      var funcCall = this.scope.overrideContext.bindingContext[func];

      if (typeof funcCall === 'function') {
        return funcCall.bind(this.scope.overrideContext.bindingContext);
      }
      throw new Error("'reorderable-dnd-preview' must be a function or evaluate to one");
    } else if (func.sourceExpression) {
      return function (item, scope) {
        return func.sourceExpression.evaluate(scope);
      };
    } else {
      throw new Error("'reorderable-dnd-preview' must be a function or evaluate to one");
    }
  };

  ReorderableRepeat.prototype._reorderableAfterReorderingFunc = function _reorderableAfterReorderingFunc() {
    var _this5 = this;

    var func = this._additionalAttribute(this.view(0), 'reorderable-after-reordering');

    if (!func) {
      return null;
    } else if (typeof func === 'string') {
      var funcCall = this.scope.overrideContext.bindingContext[func];

      if (typeof funcCall === 'function') {
        return funcCall.bind(this.scope.overrideContext.bindingContext);
      }
      throw new Error("'reorderable-after-reordering' must be a function or evaluate to one");
    } else if (func.sourceExpression) {
      return function () {
        return func.sourceExpression.evaluate(_this5.scope);
      };
    } else {
      throw new Error("'reorderable-after-reordering' must be a function or evaluate to one");
    }
  };

  ReorderableRepeat.prototype._dndHover = function _dndHover(location, index, direction) {
    var mouseEndAt = location.mouseEndAt,
        targetElementRect = location.targetElementRect;

    var x = mouseEndAt.x - targetElementRect.x;
    var y = mouseEndAt.y - targetElementRect.y;

    var inLeastHalf = void 0;

    if (direction === 'left') {
      inLeastHalf = x > targetElementRect.width / 2;
    } else if (direction === 'right') {
      inLeastHalf = x < targetElementRect.width / 2;
    } else if (direction === 'up') {
      inLeastHalf = y > targetElementRect.height / 2;
    } else {
        inLeastHalf = y < targetElementRect.height / 2;
      }

    if (inLeastHalf) {
      this._updateIntention(index, true);
    } else {
      this._updateIntention(index, false);
    }
  };

  ReorderableRepeat.prototype._registerDnd = function _registerDnd(view) {
    var _this6 = this;

    var local = this.local;

    var el = view.firstChild;
    var item = view.bindingContext[local];
    var index = view.overrideContext.$index;
    var handlerSelector = this._dndHandlerSelector(view);
    var handler = void 0;
    if (handlerSelector) {
      handler = view.firstChild.querySelector(handlerSelector);
    }
    var direction = this._reorderableDirection(view);
    var _previewFunc = this._dndPreviewFunc(view);

    this.dndService.addSource({
      dndModel: function dndModel() {
        return { type: _this6.type, index: index };
      },
      dndPreview: _previewFunc && function () {
        return _previewFunc(item, view);
      },
      dndElement: el
    }, handler && { handler: handler });

    this.dndService.addTarget({
      dndElement: el,
      dndCanDrop: function dndCanDrop(model) {
        var canDrop = model.type === _this6.type && (_this6.intention ? _this6.intention.toIndex !== index : model.index !== index);

        if (model.type === _this6.type) {
          _this6.taskQueue.queueMicroTask(function () {
            classes.add(el, 'reorderable-repeat-reordering');
          });
        }

        if (model.type === _this6.type && !canDrop) {
          _this6.taskQueue.queueMicroTask(function () {
            classes.add(el, 'reorderable-repeat-dragging-me');
          });
        }
        return canDrop;
      },
      dndHover: function dndHover(location) {
        _this6._dndHover(location, index, direction);
      },
      dndDrop: function dndDrop() {}
    });
  };

  ReorderableRepeat.prototype._unRegisterDnd = function _unRegisterDnd(view) {
    classes.rm(view.firstChild, 'reorderable-repeat-reordering');
    classes.rm(view.firstChild, 'reorderable-repeat-dragging-me');
    this.dndService.removeSource(view.firstChild);
    this.dndService.removeTarget(view.firstChild);
  };

  ReorderableRepeat.prototype._updateIntention = function _updateIntention(targetIndex, beforeTarget) {
    var _dndService = this.dndService,
        isProcessing = _dndService.isProcessing,
        model = _dndService.model;

    if (!isProcessing) return;
    if (model.type !== this.type) return;

    if (targetIndex < 0) return;

    var originalIndex = void 0;
    var currentIndex = void 0;
    var nextIndex = void 0;
    if (this.intention) {
      originalIndex = this.intention.fromIndex;
      currentIndex = this.intention.toIndex;
    } else {
      originalIndex = model.index;
      if (originalIndex < 0) return;
      currentIndex = originalIndex;
    }

    if (currentIndex < targetIndex) {
      if (beforeTarget) {
        nextIndex = targetIndex - 1;
      } else {
        nextIndex = targetIndex;
      }
    } else {
        if (beforeTarget) {
          nextIndex = targetIndex;
        } else {
          nextIndex = targetIndex + 1;
        }
      }

    if (!this.intention || this.intention.fromIndex !== originalIndex || this.intention.toIndex !== nextIndex) {
      this.intention = {
        fromIndex: originalIndex,
        toIndex: nextIndex
      };
    }
  };

  return ReorderableRepeat;
}(_aureliaTemplatingResources.AbstractRepeater), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'items', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'local', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, 'intention', [_aureliaBinding.observable], {
  enumerable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, 'patchedItems', [_aureliaBinding.observable], {
  enumerable: true,
  initializer: null
})), _class2)) || _class) || _class) || _class);
});

define('bcx-aurelia-reorderable-repeat/dist/reorderable-repeat-strategy-locator',['require','exports','module','./simple-array-repeat-strategy'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.ReorderableRepeatStrategyLocator = undefined;

var _simpleArrayRepeatStrategy = require('./simple-array-repeat-strategy');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReorderableRepeatStrategyLocator = exports.ReorderableRepeatStrategyLocator = function () {
  function ReorderableRepeatStrategyLocator() {
    _classCallCheck(this, ReorderableRepeatStrategyLocator);

    this.matchers = [];
    this.strategies = [];
    this.addStrategy(function (items) {
      return items instanceof Array;
    }, new _simpleArrayRepeatStrategy.SimpleArrayRepeatStrategy());
  }

  ReorderableRepeatStrategyLocator.prototype.addStrategy = function addStrategy(matcher, strategy) {
    this.matchers.push(matcher);
    this.strategies.push(strategy);
  };

  ReorderableRepeatStrategyLocator.prototype.getStrategy = function getStrategy(items) {
    var matchers = this.matchers;

    for (var i = 0, ii = matchers.length; i < ii; ++i) {
      if (matchers[i](items)) {
        return this.strategies[i];
      }
    }

    return null;
  };

  return ReorderableRepeatStrategyLocator;
}();
});

define('bcx-aurelia-reorderable-repeat/dist/simple-array-repeat-strategy',['require','exports','module','aurelia-templating-resources'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.SimpleArrayRepeatStrategy = undefined;

var _aureliaTemplatingResources = require('aurelia-templating-resources');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SimpleArrayRepeatStrategy = exports.SimpleArrayRepeatStrategy = function () {
  function SimpleArrayRepeatStrategy() {
    _classCallCheck(this, SimpleArrayRepeatStrategy);
  }

  SimpleArrayRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {
    return observerLocator.getArrayObserver(items);
  };

  SimpleArrayRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
    repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);

    var itemsLength = items.length;
    if (items && itemsLength > 0) {
      this._standardProcessInstanceChanged(repeat, items);
    }
  };

  SimpleArrayRepeatStrategy.prototype._standardProcessInstanceChanged = function _standardProcessInstanceChanged(repeat, items) {
    for (var i = 0, ii = items.length; i < ii; i++) {
      var overrideContext = (0, _aureliaTemplatingResources.createFullOverrideContext)(repeat, items[i], i, ii);
      repeat.addView(overrideContext.bindingContext, overrideContext);
    }
  };

  return SimpleArrayRepeatStrategy;
}();
});

define('bcx-doc-base/dist/binding-behaviors/left-click',['require','exports','module'],function (require, exports, module) {'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function handleLeftClickEvent(event) {
  if (event.button != 0) return;

  this.leftClickEventCallSource(event);
}

var LeftClickBindingBehavior = exports.LeftClickBindingBehavior = function () {
  function LeftClickBindingBehavior() {
    _classCallCheck(this, LeftClickBindingBehavior);
  }

  LeftClickBindingBehavior.prototype.bind = function bind(binding) {
    if (!binding.callSource || !binding.targetEvent) throw new Error('leftClick binding behavior only supports event.');
    binding.leftClickEventCallSource = binding.callSource;
    binding.callSource = handleLeftClickEvent;
  };

  LeftClickBindingBehavior.prototype.unbind = function unbind(binding) {
    binding.callSource = binding.leftClickEventCallSource;
    binding.leftClickEventCallSource = null;
  };

  return LeftClickBindingBehavior;
}();
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJpbmRpbmctYmVoYXZpb3JzL2xlZnQtY2xpY2suanMiXSwibmFtZXMiOlsiaGFuZGxlTGVmdENsaWNrRXZlbnQiLCJldmVudCIsImJ1dHRvbiIsImxlZnRDbGlja0V2ZW50Q2FsbFNvdXJjZSIsIkxlZnRDbGlja0JpbmRpbmdCZWhhdmlvciIsImJpbmQiLCJiaW5kaW5nIiwiY2FsbFNvdXJjZSIsInRhcmdldEV2ZW50IiwiRXJyb3IiLCJ1bmJpbmQiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLFNBQVNBLG9CQUFULENBQThCQyxLQUE5QixFQUFxQztBQUNuQyxNQUFJQSxNQUFNQyxNQUFOLElBQWdCLENBQXBCLEVBQXVCOztBQUV2QixPQUFLQyx3QkFBTCxDQUE4QkYsS0FBOUI7QUFDRDs7SUFFWUcsd0IsV0FBQUEsd0I7Ozs7O3FDQUNYQyxJLGlCQUFLQyxPLEVBQVM7QUFDWixRQUFJLENBQUNBLFFBQVFDLFVBQVQsSUFBdUIsQ0FBQ0QsUUFBUUUsV0FBcEMsRUFBaUQsTUFBTSxJQUFJQyxLQUFKLENBQVUsaURBQVYsQ0FBTjtBQUNqREgsWUFBUUgsd0JBQVIsR0FBbUNHLFFBQVFDLFVBQTNDO0FBQ0FELFlBQVFDLFVBQVIsR0FBcUJQLG9CQUFyQjtBQUNELEc7O3FDQUVEVSxNLG1CQUFPSixPLEVBQVM7QUFDZEEsWUFBUUMsVUFBUixHQUFxQkQsUUFBUUgsd0JBQTdCO0FBQ0FHLFlBQVFILHdCQUFSLEdBQW1DLElBQW5DO0FBQ0QsRyIsImZpbGUiOiJiaW5kaW5nLWJlaGF2aW9ycy9sZWZ0LWNsaWNrLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaGFuZGxlTGVmdENsaWNrRXZlbnQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmJ1dHRvbiAhPSAwKSByZXR1cm47XG4gIC8vIG9ubHkgY2FsbCByZWFsIGNhbGxiYWNrIHdoZW4gaXQgaXMgZWl0aGVyIGxlZnQgbW91c2UgY2xpY2sgb3IgdG91Y2ggZXZlbnQuXG4gIHRoaXMubGVmdENsaWNrRXZlbnRDYWxsU291cmNlKGV2ZW50KTtcbn1cblxuZXhwb3J0IGNsYXNzIExlZnRDbGlja0JpbmRpbmdCZWhhdmlvciB7XG4gIGJpbmQoYmluZGluZykge1xuICAgIGlmICghYmluZGluZy5jYWxsU291cmNlIHx8ICFiaW5kaW5nLnRhcmdldEV2ZW50KSB0aHJvdyBuZXcgRXJyb3IoJ2xlZnRDbGljayBiaW5kaW5nIGJlaGF2aW9yIG9ubHkgc3VwcG9ydHMgZXZlbnQuJyk7XG4gICAgYmluZGluZy5sZWZ0Q2xpY2tFdmVudENhbGxTb3VyY2UgPSBiaW5kaW5nLmNhbGxTb3VyY2U7XG4gICAgYmluZGluZy5jYWxsU291cmNlID0gaGFuZGxlTGVmdENsaWNrRXZlbnQ7XG4gIH1cblxuICB1bmJpbmQoYmluZGluZykge1xuICAgIGJpbmRpbmcuY2FsbFNvdXJjZSA9IGJpbmRpbmcubGVmdENsaWNrRXZlbnRDYWxsU291cmNlO1xuICAgIGJpbmRpbmcubGVmdENsaWNrRXZlbnRDYWxsU291cmNlID0gbnVsbDtcbiAgfVxufVxuIl19

});

define('text!bcx-doc-base/dist/css/doc.css', ['module'], function(module) { module.exports = "/*! normalize.css v8.0.0 | MIT License | github.com/necolas/normalize.css */\n/* Document\n   ========================================================================== */\n/**\n * 1. Correct the line height in all browsers.\n * 2. Prevent adjustments of font size after orientation changes in iOS.\n */\nhtml {\n  line-height: 1.15;\n  /* 1 */\n  -webkit-text-size-adjust: 100%;\n  /* 2 */ }\n\n/* Sections\n   ========================================================================== */\n/**\n * Remove the margin in all browsers.\n */\nbody {\n  margin: 0; }\n\n/**\n * Correct the font size and margin on `h1` elements within `section` and\n * `article` contexts in Chrome, Firefox, and Safari.\n */\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0; }\n\n/* Grouping content\n   ========================================================================== */\n/**\n * 1. Add the correct box sizing in Firefox.\n * 2. Show the overflow in Edge and IE.\n */\nhr {\n  box-sizing: content-box;\n  /* 1 */\n  height: 0;\n  /* 1 */\n  overflow: visible;\n  /* 2 */ }\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\npre {\n  font-family: monospace, monospace;\n  /* 1 */\n  font-size: 1em;\n  /* 2 */ }\n\n/* Text-level semantics\n   ========================================================================== */\n/**\n * Remove the gray background on active links in IE 10.\n */\na {\n  background-color: transparent; }\n\n/**\n * 1. Remove the bottom border in Chrome 57-\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n */\nabbr[title] {\n  border-bottom: none;\n  /* 1 */\n  text-decoration: underline;\n  /* 2 */\n  -webkit-text-decoration: underline dotted;\n          text-decoration: underline dotted;\n  /* 2 */ }\n\n/**\n * Add the correct font weight in Chrome, Edge, and Safari.\n */\nb,\nstrong {\n  font-weight: bolder; }\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\ncode,\nkbd,\nsamp {\n  font-family: monospace, monospace;\n  /* 1 */\n  font-size: 1em;\n  /* 2 */ }\n\n/**\n * Add the correct font size in all browsers.\n */\nsmall {\n  font-size: 80%; }\n\n/**\n * Prevent `sub` and `sup` elements from affecting the line height in\n * all browsers.\n */\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline; }\n\nsub {\n  bottom: -0.25em; }\n\nsup {\n  top: -0.5em; }\n\n/* Embedded content\n   ========================================================================== */\n/**\n * Remove the border on images inside links in IE 10.\n */\nimg {\n  border-style: none; }\n\n/* Forms\n   ========================================================================== */\n/**\n * 1. Change the font styles in all browsers.\n * 2. Remove the margin in Firefox and Safari.\n */\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit;\n  /* 1 */\n  font-size: 100%;\n  /* 1 */\n  line-height: 1.15;\n  /* 1 */\n  margin: 0;\n  /* 2 */ }\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\nbutton,\ninput {\n  /* 1 */\n  overflow: visible; }\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\nbutton,\nselect {\n  /* 1 */\n  text-transform: none; }\n\n/**\n * Correct the inability to style clickable types in iOS and Safari.\n */\nbutton,\n[type=\"button\"],\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button; }\n\n/**\n * Remove the inner border and padding in Firefox.\n */\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0; }\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText; }\n\n/**\n * Correct the padding in Firefox.\n */\nfieldset {\n  padding: 0.35em 0.75em 0.625em; }\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\nlegend {\n  box-sizing: border-box;\n  /* 1 */\n  color: inherit;\n  /* 2 */\n  display: table;\n  /* 1 */\n  max-width: 100%;\n  /* 1 */\n  padding: 0;\n  /* 3 */\n  white-space: normal;\n  /* 1 */ }\n\n/**\n * Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\nprogress {\n  vertical-align: baseline; }\n\n/**\n * Remove the default vertical scrollbar in IE 10+.\n */\ntextarea {\n  overflow: auto; }\n\n/**\n * 1. Add the correct box sizing in IE 10.\n * 2. Remove the padding in IE 10.\n */\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box;\n  /* 1 */\n  padding: 0;\n  /* 2 */ }\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto; }\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n[type=\"search\"] {\n  -webkit-appearance: textfield;\n  /* 1 */\n  outline-offset: -2px;\n  /* 2 */ }\n\n/**\n * Remove the inner padding in Chrome and Safari on macOS.\n */\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none; }\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n::-webkit-file-upload-button {\n  -webkit-appearance: button;\n  /* 1 */\n  font: inherit;\n  /* 2 */ }\n\n/* Interactive\n   ========================================================================== */\n/*\n * Add the correct display in Edge, IE 10+, and Firefox.\n */\ndetails {\n  display: block; }\n\n/*\n * Add the correct display in all browsers.\n */\nsummary {\n  display: list-item; }\n\n/* Misc\n   ========================================================================== */\n/**\n * Add the correct display in IE 10+.\n */\ntemplate {\n  display: none; }\n\n/**\n * Add the correct display in IE 10.\n */\n[hidden] {\n  display: none; }\n\n@font-face {\n  font-family: 'Font Awesome 5 Brands';\n  font-style: normal;\n  font-weight: normal;\n  src: url(\"data:application/font-woff;base64,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\") format(\"woff\"); }\n\n.fab {\n  font-family: 'Font Awesome 5 Brands'; }\n\n@font-face {\n  font-family: 'Font Awesome 5 Pro';\n  font-style: normal;\n  font-weight: 300;\n  src: url(\"data:application/font-woff;base64,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\") format(\"woff\"); }\n\n.fal {\n  font-family: 'Font Awesome 5 Pro';\n  font-weight: 300; }\n\n@font-face {\n  font-family: 'Font Awesome 5 Pro';\n  font-style: normal;\n  font-weight: 400;\n  src: url(\"data:application/font-woff;base64,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\") format(\"woff\"); }\n\n.far {\n  font-family: 'Font Awesome 5 Pro';\n  font-weight: 400; }\n\n@font-face {\n  font-family: 'Font Awesome 5 Pro';\n  font-style: normal;\n  font-weight: 900;\n  src: url(\"data:application/font-woff;base64,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\") format(\"woff\"); }\n\n.fa,\n.fas {\n  font-family: 'Font Awesome 5 Pro';\n  font-weight: 900; }\n\n/*!\n * Font Awesome Pro 5.0.7 by @fontawesome - https://fontawesome.com\n * License - https://fontawesome.com/license (Commercial License)\n */\n.fa,\n.fas,\n.far,\n.fal,\n.fab {\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  display: inline-block;\n  font-style: normal;\n  font-variant: normal;\n  text-rendering: auto;\n  line-height: 1; }\n\n.fa-lg {\n  font-size: 1.33333em;\n  line-height: 0.75em;\n  vertical-align: -.0667em; }\n\n.fa-xs {\n  font-size: .75em; }\n\n.fa-sm {\n  font-size: .875em; }\n\n.fa-1x {\n  font-size: 1em; }\n\n.fa-2x {\n  font-size: 2em; }\n\n.fa-3x {\n  font-size: 3em; }\n\n.fa-4x {\n  font-size: 4em; }\n\n.fa-5x {\n  font-size: 5em; }\n\n.fa-6x {\n  font-size: 6em; }\n\n.fa-7x {\n  font-size: 7em; }\n\n.fa-8x {\n  font-size: 8em; }\n\n.fa-9x {\n  font-size: 9em; }\n\n.fa-10x {\n  font-size: 10em; }\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em; }\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: 2.5em;\n  padding-left: 0; }\n  .fa-ul > li {\n    position: relative; }\n\n.fa-li {\n  left: -2em;\n  position: absolute;\n  text-align: center;\n  width: 2em;\n  line-height: inherit; }\n\n.fa-border {\n  border: solid 0.08em #eee;\n  border-radius: .1em;\n  padding: .2em .25em .15em; }\n\n.fa-pull-left {\n  float: left; }\n\n.fa-pull-right {\n  float: right; }\n\n.fa.fa-pull-left,\n.fas.fa-pull-left,\n.far.fa-pull-left,\n.fal.fa-pull-left,\n.fab.fa-pull-left {\n  margin-right: .3em; }\n\n.fa.fa-pull-right,\n.fas.fa-pull-right,\n.far.fa-pull-right,\n.fal.fa-pull-right,\n.fab.fa-pull-right {\n  margin-left: .3em; }\n\n.fa-spin {\n  -webkit-animation: fa-spin 2s infinite linear;\n          animation: fa-spin 2s infinite linear; }\n\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n          animation: fa-spin 1s infinite steps(8); }\n\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n.fa-rotate-90 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\";\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg); }\n\n.fa-rotate-180 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)\";\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg); }\n\n.fa-rotate-270 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)\";\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg); }\n\n.fa-flip-horizontal {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)\";\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1); }\n\n.fa-flip-vertical {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\";\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1); }\n\n.fa-flip-horizontal.fa-flip-vertical {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\";\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1); }\n\n:root .fa-rotate-90,\n:root .fa-rotate-180,\n:root .fa-rotate-270,\n:root .fa-flip-horizontal,\n:root .fa-flip-vertical {\n  -webkit-filter: none;\n          filter: none; }\n\n.fa-stack {\n  display: inline-block;\n  height: 2em;\n  line-height: 2em;\n  position: relative;\n  vertical-align: middle;\n  width: 2em; }\n\n.fa-stack-1x,\n.fa-stack-2x {\n  left: 0;\n  position: absolute;\n  text-align: center;\n  width: 100%; }\n\n.fa-stack-1x {\n  line-height: inherit; }\n\n.fa-stack-2x {\n  font-size: 2em; }\n\n.fa-inverse {\n  color: #fff; }\n\n/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen\nreaders do not read off random characters that represent icons */\n.fa-500px:before {\n  content: \"\\f26e\"; }\n\n.fa-accessible-icon:before {\n  content: \"\\f368\"; }\n\n.fa-accusoft:before {\n  content: \"\\f369\"; }\n\n.fa-address-book:before {\n  content: \"\\f2b9\"; }\n\n.fa-address-card:before {\n  content: \"\\f2bb\"; }\n\n.fa-adjust:before {\n  content: \"\\f042\"; }\n\n.fa-adn:before {\n  content: \"\\f170\"; }\n\n.fa-adversal:before {\n  content: \"\\f36a\"; }\n\n.fa-affiliatetheme:before {\n  content: \"\\f36b\"; }\n\n.fa-alarm-clock:before {\n  content: \"\\f34e\"; }\n\n.fa-algolia:before {\n  content: \"\\f36c\"; }\n\n.fa-align-center:before {\n  content: \"\\f037\"; }\n\n.fa-align-justify:before {\n  content: \"\\f039\"; }\n\n.fa-align-left:before {\n  content: \"\\f036\"; }\n\n.fa-align-right:before {\n  content: \"\\f038\"; }\n\n.fa-allergies:before {\n  content: \"\\f461\"; }\n\n.fa-amazon:before {\n  content: \"\\f270\"; }\n\n.fa-amazon-pay:before {\n  content: \"\\f42c\"; }\n\n.fa-ambulance:before {\n  content: \"\\f0f9\"; }\n\n.fa-american-sign-language-interpreting:before {\n  content: \"\\f2a3\"; }\n\n.fa-amilia:before {\n  content: \"\\f36d\"; }\n\n.fa-anchor:before {\n  content: \"\\f13d\"; }\n\n.fa-android:before {\n  content: \"\\f17b\"; }\n\n.fa-angellist:before {\n  content: \"\\f209\"; }\n\n.fa-angle-double-down:before {\n  content: \"\\f103\"; }\n\n.fa-angle-double-left:before {\n  content: \"\\f100\"; }\n\n.fa-angle-double-right:before {\n  content: \"\\f101\"; }\n\n.fa-angle-double-up:before {\n  content: \"\\f102\"; }\n\n.fa-angle-down:before {\n  content: \"\\f107\"; }\n\n.fa-angle-left:before {\n  content: \"\\f104\"; }\n\n.fa-angle-right:before {\n  content: \"\\f105\"; }\n\n.fa-angle-up:before {\n  content: \"\\f106\"; }\n\n.fa-angrycreative:before {\n  content: \"\\f36e\"; }\n\n.fa-angular:before {\n  content: \"\\f420\"; }\n\n.fa-app-store:before {\n  content: \"\\f36f\"; }\n\n.fa-app-store-ios:before {\n  content: \"\\f370\"; }\n\n.fa-apper:before {\n  content: \"\\f371\"; }\n\n.fa-apple:before {\n  content: \"\\f179\"; }\n\n.fa-apple-pay:before {\n  content: \"\\f415\"; }\n\n.fa-archive:before {\n  content: \"\\f187\"; }\n\n.fa-arrow-alt-circle-down:before {\n  content: \"\\f358\"; }\n\n.fa-arrow-alt-circle-left:before {\n  content: \"\\f359\"; }\n\n.fa-arrow-alt-circle-right:before {\n  content: \"\\f35a\"; }\n\n.fa-arrow-alt-circle-up:before {\n  content: \"\\f35b\"; }\n\n.fa-arrow-alt-down:before {\n  content: \"\\f354\"; }\n\n.fa-arrow-alt-from-bottom:before {\n  content: \"\\f346\"; }\n\n.fa-arrow-alt-from-left:before {\n  content: \"\\f347\"; }\n\n.fa-arrow-alt-from-right:before {\n  content: \"\\f348\"; }\n\n.fa-arrow-alt-from-top:before {\n  content: \"\\f349\"; }\n\n.fa-arrow-alt-left:before {\n  content: \"\\f355\"; }\n\n.fa-arrow-alt-right:before {\n  content: \"\\f356\"; }\n\n.fa-arrow-alt-square-down:before {\n  content: \"\\f350\"; }\n\n.fa-arrow-alt-square-left:before {\n  content: \"\\f351\"; }\n\n.fa-arrow-alt-square-right:before {\n  content: \"\\f352\"; }\n\n.fa-arrow-alt-square-up:before {\n  content: \"\\f353\"; }\n\n.fa-arrow-alt-to-bottom:before {\n  content: \"\\f34a\"; }\n\n.fa-arrow-alt-to-left:before {\n  content: \"\\f34b\"; }\n\n.fa-arrow-alt-to-right:before {\n  content: \"\\f34c\"; }\n\n.fa-arrow-alt-to-top:before {\n  content: \"\\f34d\"; }\n\n.fa-arrow-alt-up:before {\n  content: \"\\f357\"; }\n\n.fa-arrow-circle-down:before {\n  content: \"\\f0ab\"; }\n\n.fa-arrow-circle-left:before {\n  content: \"\\f0a8\"; }\n\n.fa-arrow-circle-right:before {\n  content: \"\\f0a9\"; }\n\n.fa-arrow-circle-up:before {\n  content: \"\\f0aa\"; }\n\n.fa-arrow-down:before {\n  content: \"\\f063\"; }\n\n.fa-arrow-from-bottom:before {\n  content: \"\\f342\"; }\n\n.fa-arrow-from-left:before {\n  content: \"\\f343\"; }\n\n.fa-arrow-from-right:before {\n  content: \"\\f344\"; }\n\n.fa-arrow-from-top:before {\n  content: \"\\f345\"; }\n\n.fa-arrow-left:before {\n  content: \"\\f060\"; }\n\n.fa-arrow-right:before {\n  content: \"\\f061\"; }\n\n.fa-arrow-square-down:before {\n  content: \"\\f339\"; }\n\n.fa-arrow-square-left:before {\n  content: \"\\f33a\"; }\n\n.fa-arrow-square-right:before {\n  content: \"\\f33b\"; }\n\n.fa-arrow-square-up:before {\n  content: \"\\f33c\"; }\n\n.fa-arrow-to-bottom:before {\n  content: \"\\f33d\"; }\n\n.fa-arrow-to-left:before {\n  content: \"\\f33e\"; }\n\n.fa-arrow-to-right:before {\n  content: \"\\f340\"; }\n\n.fa-arrow-to-top:before {\n  content: \"\\f341\"; }\n\n.fa-arrow-up:before {\n  content: \"\\f062\"; }\n\n.fa-arrows:before {\n  content: \"\\f047\"; }\n\n.fa-arrows-alt:before {\n  content: \"\\f0b2\"; }\n\n.fa-arrows-alt-h:before {\n  content: \"\\f337\"; }\n\n.fa-arrows-alt-v:before {\n  content: \"\\f338\"; }\n\n.fa-arrows-h:before {\n  content: \"\\f07e\"; }\n\n.fa-arrows-v:before {\n  content: \"\\f07d\"; }\n\n.fa-assistive-listening-systems:before {\n  content: \"\\f2a2\"; }\n\n.fa-asterisk:before {\n  content: \"\\f069\"; }\n\n.fa-asymmetrik:before {\n  content: \"\\f372\"; }\n\n.fa-at:before {\n  content: \"\\f1fa\"; }\n\n.fa-audible:before {\n  content: \"\\f373\"; }\n\n.fa-audio-description:before {\n  content: \"\\f29e\"; }\n\n.fa-autoprefixer:before {\n  content: \"\\f41c\"; }\n\n.fa-avianex:before {\n  content: \"\\f374\"; }\n\n.fa-aviato:before {\n  content: \"\\f421\"; }\n\n.fa-aws:before {\n  content: \"\\f375\"; }\n\n.fa-backward:before {\n  content: \"\\f04a\"; }\n\n.fa-badge:before {\n  content: \"\\f335\"; }\n\n.fa-badge-check:before {\n  content: \"\\f336\"; }\n\n.fa-balance-scale:before {\n  content: \"\\f24e\"; }\n\n.fa-ban:before {\n  content: \"\\f05e\"; }\n\n.fa-band-aid:before {\n  content: \"\\f462\"; }\n\n.fa-bandcamp:before {\n  content: \"\\f2d5\"; }\n\n.fa-barcode:before {\n  content: \"\\f02a\"; }\n\n.fa-barcode-alt:before {\n  content: \"\\f463\"; }\n\n.fa-barcode-read:before {\n  content: \"\\f464\"; }\n\n.fa-barcode-scan:before {\n  content: \"\\f465\"; }\n\n.fa-bars:before {\n  content: \"\\f0c9\"; }\n\n.fa-baseball:before {\n  content: \"\\f432\"; }\n\n.fa-baseball-ball:before {\n  content: \"\\f433\"; }\n\n.fa-basketball-ball:before {\n  content: \"\\f434\"; }\n\n.fa-basketball-hoop:before {\n  content: \"\\f435\"; }\n\n.fa-bath:before {\n  content: \"\\f2cd\"; }\n\n.fa-battery-bolt:before {\n  content: \"\\f376\"; }\n\n.fa-battery-empty:before {\n  content: \"\\f244\"; }\n\n.fa-battery-full:before {\n  content: \"\\f240\"; }\n\n.fa-battery-half:before {\n  content: \"\\f242\"; }\n\n.fa-battery-quarter:before {\n  content: \"\\f243\"; }\n\n.fa-battery-slash:before {\n  content: \"\\f377\"; }\n\n.fa-battery-three-quarters:before {\n  content: \"\\f241\"; }\n\n.fa-bed:before {\n  content: \"\\f236\"; }\n\n.fa-beer:before {\n  content: \"\\f0fc\"; }\n\n.fa-behance:before {\n  content: \"\\f1b4\"; }\n\n.fa-behance-square:before {\n  content: \"\\f1b5\"; }\n\n.fa-bell:before {\n  content: \"\\f0f3\"; }\n\n.fa-bell-slash:before {\n  content: \"\\f1f6\"; }\n\n.fa-bicycle:before {\n  content: \"\\f206\"; }\n\n.fa-bimobject:before {\n  content: \"\\f378\"; }\n\n.fa-binoculars:before {\n  content: \"\\f1e5\"; }\n\n.fa-birthday-cake:before {\n  content: \"\\f1fd\"; }\n\n.fa-bitbucket:before {\n  content: \"\\f171\"; }\n\n.fa-bitcoin:before {\n  content: \"\\f379\"; }\n\n.fa-bity:before {\n  content: \"\\f37a\"; }\n\n.fa-black-tie:before {\n  content: \"\\f27e\"; }\n\n.fa-blackberry:before {\n  content: \"\\f37b\"; }\n\n.fa-blind:before {\n  content: \"\\f29d\"; }\n\n.fa-blogger:before {\n  content: \"\\f37c\"; }\n\n.fa-blogger-b:before {\n  content: \"\\f37d\"; }\n\n.fa-bluetooth:before {\n  content: \"\\f293\"; }\n\n.fa-bluetooth-b:before {\n  content: \"\\f294\"; }\n\n.fa-bold:before {\n  content: \"\\f032\"; }\n\n.fa-bolt:before {\n  content: \"\\f0e7\"; }\n\n.fa-bomb:before {\n  content: \"\\f1e2\"; }\n\n.fa-book:before {\n  content: \"\\f02d\"; }\n\n.fa-bookmark:before {\n  content: \"\\f02e\"; }\n\n.fa-bowling-ball:before {\n  content: \"\\f436\"; }\n\n.fa-bowling-pins:before {\n  content: \"\\f437\"; }\n\n.fa-box:before {\n  content: \"\\f466\"; }\n\n.fa-box-check:before {\n  content: \"\\f467\"; }\n\n.fa-boxes:before {\n  content: \"\\f468\"; }\n\n.fa-boxing-glove:before {\n  content: \"\\f438\"; }\n\n.fa-braille:before {\n  content: \"\\f2a1\"; }\n\n.fa-briefcase:before {\n  content: \"\\f0b1\"; }\n\n.fa-briefcase-medical:before {\n  content: \"\\f469\"; }\n\n.fa-browser:before {\n  content: \"\\f37e\"; }\n\n.fa-btc:before {\n  content: \"\\f15a\"; }\n\n.fa-bug:before {\n  content: \"\\f188\"; }\n\n.fa-building:before {\n  content: \"\\f1ad\"; }\n\n.fa-bullhorn:before {\n  content: \"\\f0a1\"; }\n\n.fa-bullseye:before {\n  content: \"\\f140\"; }\n\n.fa-burn:before {\n  content: \"\\f46a\"; }\n\n.fa-buromobelexperte:before {\n  content: \"\\f37f\"; }\n\n.fa-bus:before {\n  content: \"\\f207\"; }\n\n.fa-buysellads:before {\n  content: \"\\f20d\"; }\n\n.fa-calculator:before {\n  content: \"\\f1ec\"; }\n\n.fa-calendar:before {\n  content: \"\\f133\"; }\n\n.fa-calendar-alt:before {\n  content: \"\\f073\"; }\n\n.fa-calendar-check:before {\n  content: \"\\f274\"; }\n\n.fa-calendar-edit:before {\n  content: \"\\f333\"; }\n\n.fa-calendar-exclamation:before {\n  content: \"\\f334\"; }\n\n.fa-calendar-minus:before {\n  content: \"\\f272\"; }\n\n.fa-calendar-plus:before {\n  content: \"\\f271\"; }\n\n.fa-calendar-times:before {\n  content: \"\\f273\"; }\n\n.fa-camera:before {\n  content: \"\\f030\"; }\n\n.fa-camera-alt:before {\n  content: \"\\f332\"; }\n\n.fa-camera-retro:before {\n  content: \"\\f083\"; }\n\n.fa-capsules:before {\n  content: \"\\f46b\"; }\n\n.fa-car:before {\n  content: \"\\f1b9\"; }\n\n.fa-caret-circle-down:before {\n  content: \"\\f32d\"; }\n\n.fa-caret-circle-left:before {\n  content: \"\\f32e\"; }\n\n.fa-caret-circle-right:before {\n  content: \"\\f330\"; }\n\n.fa-caret-circle-up:before {\n  content: \"\\f331\"; }\n\n.fa-caret-down:before {\n  content: \"\\f0d7\"; }\n\n.fa-caret-left:before {\n  content: \"\\f0d9\"; }\n\n.fa-caret-right:before {\n  content: \"\\f0da\"; }\n\n.fa-caret-square-down:before {\n  content: \"\\f150\"; }\n\n.fa-caret-square-left:before {\n  content: \"\\f191\"; }\n\n.fa-caret-square-right:before {\n  content: \"\\f152\"; }\n\n.fa-caret-square-up:before {\n  content: \"\\f151\"; }\n\n.fa-caret-up:before {\n  content: \"\\f0d8\"; }\n\n.fa-cart-arrow-down:before {\n  content: \"\\f218\"; }\n\n.fa-cart-plus:before {\n  content: \"\\f217\"; }\n\n.fa-cc-amazon-pay:before {\n  content: \"\\f42d\"; }\n\n.fa-cc-amex:before {\n  content: \"\\f1f3\"; }\n\n.fa-cc-apple-pay:before {\n  content: \"\\f416\"; }\n\n.fa-cc-diners-club:before {\n  content: \"\\f24c\"; }\n\n.fa-cc-discover:before {\n  content: \"\\f1f2\"; }\n\n.fa-cc-jcb:before {\n  content: \"\\f24b\"; }\n\n.fa-cc-mastercard:before {\n  content: \"\\f1f1\"; }\n\n.fa-cc-paypal:before {\n  content: \"\\f1f4\"; }\n\n.fa-cc-stripe:before {\n  content: \"\\f1f5\"; }\n\n.fa-cc-visa:before {\n  content: \"\\f1f0\"; }\n\n.fa-centercode:before {\n  content: \"\\f380\"; }\n\n.fa-certificate:before {\n  content: \"\\f0a3\"; }\n\n.fa-chart-area:before {\n  content: \"\\f1fe\"; }\n\n.fa-chart-bar:before {\n  content: \"\\f080\"; }\n\n.fa-chart-line:before {\n  content: \"\\f201\"; }\n\n.fa-chart-pie:before {\n  content: \"\\f200\"; }\n\n.fa-check:before {\n  content: \"\\f00c\"; }\n\n.fa-check-circle:before {\n  content: \"\\f058\"; }\n\n.fa-check-square:before {\n  content: \"\\f14a\"; }\n\n.fa-chess:before {\n  content: \"\\f439\"; }\n\n.fa-chess-bishop:before {\n  content: \"\\f43a\"; }\n\n.fa-chess-bishop-alt:before {\n  content: \"\\f43b\"; }\n\n.fa-chess-board:before {\n  content: \"\\f43c\"; }\n\n.fa-chess-clock:before {\n  content: \"\\f43d\"; }\n\n.fa-chess-clock-alt:before {\n  content: \"\\f43e\"; }\n\n.fa-chess-king:before {\n  content: \"\\f43f\"; }\n\n.fa-chess-king-alt:before {\n  content: \"\\f440\"; }\n\n.fa-chess-knight:before {\n  content: \"\\f441\"; }\n\n.fa-chess-knight-alt:before {\n  content: \"\\f442\"; }\n\n.fa-chess-pawn:before {\n  content: \"\\f443\"; }\n\n.fa-chess-pawn-alt:before {\n  content: \"\\f444\"; }\n\n.fa-chess-queen:before {\n  content: \"\\f445\"; }\n\n.fa-chess-queen-alt:before {\n  content: \"\\f446\"; }\n\n.fa-chess-rook:before {\n  content: \"\\f447\"; }\n\n.fa-chess-rook-alt:before {\n  content: \"\\f448\"; }\n\n.fa-chevron-circle-down:before {\n  content: \"\\f13a\"; }\n\n.fa-chevron-circle-left:before {\n  content: \"\\f137\"; }\n\n.fa-chevron-circle-right:before {\n  content: \"\\f138\"; }\n\n.fa-chevron-circle-up:before {\n  content: \"\\f139\"; }\n\n.fa-chevron-double-down:before {\n  content: \"\\f322\"; }\n\n.fa-chevron-double-left:before {\n  content: \"\\f323\"; }\n\n.fa-chevron-double-right:before {\n  content: \"\\f324\"; }\n\n.fa-chevron-double-up:before {\n  content: \"\\f325\"; }\n\n.fa-chevron-down:before {\n  content: \"\\f078\"; }\n\n.fa-chevron-left:before {\n  content: \"\\f053\"; }\n\n.fa-chevron-right:before {\n  content: \"\\f054\"; }\n\n.fa-chevron-square-down:before {\n  content: \"\\f329\"; }\n\n.fa-chevron-square-left:before {\n  content: \"\\f32a\"; }\n\n.fa-chevron-square-right:before {\n  content: \"\\f32b\"; }\n\n.fa-chevron-square-up:before {\n  content: \"\\f32c\"; }\n\n.fa-chevron-up:before {\n  content: \"\\f077\"; }\n\n.fa-child:before {\n  content: \"\\f1ae\"; }\n\n.fa-chrome:before {\n  content: \"\\f268\"; }\n\n.fa-circle:before {\n  content: \"\\f111\"; }\n\n.fa-circle-notch:before {\n  content: \"\\f1ce\"; }\n\n.fa-clipboard:before {\n  content: \"\\f328\"; }\n\n.fa-clipboard-check:before {\n  content: \"\\f46c\"; }\n\n.fa-clipboard-list:before {\n  content: \"\\f46d\"; }\n\n.fa-clock:before {\n  content: \"\\f017\"; }\n\n.fa-clone:before {\n  content: \"\\f24d\"; }\n\n.fa-closed-captioning:before {\n  content: \"\\f20a\"; }\n\n.fa-cloud:before {\n  content: \"\\f0c2\"; }\n\n.fa-cloud-download:before {\n  content: \"\\f0ed\"; }\n\n.fa-cloud-download-alt:before {\n  content: \"\\f381\"; }\n\n.fa-cloud-upload:before {\n  content: \"\\f0ee\"; }\n\n.fa-cloud-upload-alt:before {\n  content: \"\\f382\"; }\n\n.fa-cloudscale:before {\n  content: \"\\f383\"; }\n\n.fa-cloudsmith:before {\n  content: \"\\f384\"; }\n\n.fa-cloudversify:before {\n  content: \"\\f385\"; }\n\n.fa-club:before {\n  content: \"\\f327\"; }\n\n.fa-code:before {\n  content: \"\\f121\"; }\n\n.fa-code-branch:before {\n  content: \"\\f126\"; }\n\n.fa-code-commit:before {\n  content: \"\\f386\"; }\n\n.fa-code-merge:before {\n  content: \"\\f387\"; }\n\n.fa-codepen:before {\n  content: \"\\f1cb\"; }\n\n.fa-codiepie:before {\n  content: \"\\f284\"; }\n\n.fa-coffee:before {\n  content: \"\\f0f4\"; }\n\n.fa-cog:before {\n  content: \"\\f013\"; }\n\n.fa-cogs:before {\n  content: \"\\f085\"; }\n\n.fa-columns:before {\n  content: \"\\f0db\"; }\n\n.fa-comment:before {\n  content: \"\\f075\"; }\n\n.fa-comment-alt:before {\n  content: \"\\f27a\"; }\n\n.fa-comments:before {\n  content: \"\\f086\"; }\n\n.fa-compass:before {\n  content: \"\\f14e\"; }\n\n.fa-compress:before {\n  content: \"\\f066\"; }\n\n.fa-compress-alt:before {\n  content: \"\\f422\"; }\n\n.fa-compress-wide:before {\n  content: \"\\f326\"; }\n\n.fa-connectdevelop:before {\n  content: \"\\f20e\"; }\n\n.fa-contao:before {\n  content: \"\\f26d\"; }\n\n.fa-conveyor-belt:before {\n  content: \"\\f46e\"; }\n\n.fa-conveyor-belt-alt:before {\n  content: \"\\f46f\"; }\n\n.fa-copy:before {\n  content: \"\\f0c5\"; }\n\n.fa-copyright:before {\n  content: \"\\f1f9\"; }\n\n.fa-cpanel:before {\n  content: \"\\f388\"; }\n\n.fa-creative-commons:before {\n  content: \"\\f25e\"; }\n\n.fa-credit-card:before {\n  content: \"\\f09d\"; }\n\n.fa-credit-card-blank:before {\n  content: \"\\f389\"; }\n\n.fa-credit-card-front:before {\n  content: \"\\f38a\"; }\n\n.fa-cricket:before {\n  content: \"\\f449\"; }\n\n.fa-crop:before {\n  content: \"\\f125\"; }\n\n.fa-crosshairs:before {\n  content: \"\\f05b\"; }\n\n.fa-css3:before {\n  content: \"\\f13c\"; }\n\n.fa-css3-alt:before {\n  content: \"\\f38b\"; }\n\n.fa-cube:before {\n  content: \"\\f1b2\"; }\n\n.fa-cubes:before {\n  content: \"\\f1b3\"; }\n\n.fa-curling:before {\n  content: \"\\f44a\"; }\n\n.fa-cut:before {\n  content: \"\\f0c4\"; }\n\n.fa-cuttlefish:before {\n  content: \"\\f38c\"; }\n\n.fa-d-and-d:before {\n  content: \"\\f38d\"; }\n\n.fa-dashcube:before {\n  content: \"\\f210\"; }\n\n.fa-database:before {\n  content: \"\\f1c0\"; }\n\n.fa-deaf:before {\n  content: \"\\f2a4\"; }\n\n.fa-delicious:before {\n  content: \"\\f1a5\"; }\n\n.fa-deploydog:before {\n  content: \"\\f38e\"; }\n\n.fa-deskpro:before {\n  content: \"\\f38f\"; }\n\n.fa-desktop:before {\n  content: \"\\f108\"; }\n\n.fa-desktop-alt:before {\n  content: \"\\f390\"; }\n\n.fa-deviantart:before {\n  content: \"\\f1bd\"; }\n\n.fa-diagnoses:before {\n  content: \"\\f470\"; }\n\n.fa-diamond:before {\n  content: \"\\f219\"; }\n\n.fa-digg:before {\n  content: \"\\f1a6\"; }\n\n.fa-digital-ocean:before {\n  content: \"\\f391\"; }\n\n.fa-discord:before {\n  content: \"\\f392\"; }\n\n.fa-discourse:before {\n  content: \"\\f393\"; }\n\n.fa-dna:before {\n  content: \"\\f471\"; }\n\n.fa-dochub:before {\n  content: \"\\f394\"; }\n\n.fa-docker:before {\n  content: \"\\f395\"; }\n\n.fa-dollar-sign:before {\n  content: \"\\f155\"; }\n\n.fa-dolly:before {\n  content: \"\\f472\"; }\n\n.fa-dolly-empty:before {\n  content: \"\\f473\"; }\n\n.fa-dolly-flatbed:before {\n  content: \"\\f474\"; }\n\n.fa-dolly-flatbed-alt:before {\n  content: \"\\f475\"; }\n\n.fa-dolly-flatbed-empty:before {\n  content: \"\\f476\"; }\n\n.fa-dot-circle:before {\n  content: \"\\f192\"; }\n\n.fa-download:before {\n  content: \"\\f019\"; }\n\n.fa-draft2digital:before {\n  content: \"\\f396\"; }\n\n.fa-dribbble:before {\n  content: \"\\f17d\"; }\n\n.fa-dribbble-square:before {\n  content: \"\\f397\"; }\n\n.fa-dropbox:before {\n  content: \"\\f16b\"; }\n\n.fa-drupal:before {\n  content: \"\\f1a9\"; }\n\n.fa-dumbbell:before {\n  content: \"\\f44b\"; }\n\n.fa-dyalog:before {\n  content: \"\\f399\"; }\n\n.fa-earlybirds:before {\n  content: \"\\f39a\"; }\n\n.fa-edge:before {\n  content: \"\\f282\"; }\n\n.fa-edit:before {\n  content: \"\\f044\"; }\n\n.fa-eject:before {\n  content: \"\\f052\"; }\n\n.fa-elementor:before {\n  content: \"\\f430\"; }\n\n.fa-ellipsis-h:before {\n  content: \"\\f141\"; }\n\n.fa-ellipsis-h-alt:before {\n  content: \"\\f39b\"; }\n\n.fa-ellipsis-v:before {\n  content: \"\\f142\"; }\n\n.fa-ellipsis-v-alt:before {\n  content: \"\\f39c\"; }\n\n.fa-ember:before {\n  content: \"\\f423\"; }\n\n.fa-empire:before {\n  content: \"\\f1d1\"; }\n\n.fa-envelope:before {\n  content: \"\\f0e0\"; }\n\n.fa-envelope-open:before {\n  content: \"\\f2b6\"; }\n\n.fa-envelope-square:before {\n  content: \"\\f199\"; }\n\n.fa-envira:before {\n  content: \"\\f299\"; }\n\n.fa-eraser:before {\n  content: \"\\f12d\"; }\n\n.fa-erlang:before {\n  content: \"\\f39d\"; }\n\n.fa-ethereum:before {\n  content: \"\\f42e\"; }\n\n.fa-etsy:before {\n  content: \"\\f2d7\"; }\n\n.fa-euro-sign:before {\n  content: \"\\f153\"; }\n\n.fa-exchange:before {\n  content: \"\\f0ec\"; }\n\n.fa-exchange-alt:before {\n  content: \"\\f362\"; }\n\n.fa-exclamation:before {\n  content: \"\\f12a\"; }\n\n.fa-exclamation-circle:before {\n  content: \"\\f06a\"; }\n\n.fa-exclamation-square:before {\n  content: \"\\f321\"; }\n\n.fa-exclamation-triangle:before {\n  content: \"\\f071\"; }\n\n.fa-expand:before {\n  content: \"\\f065\"; }\n\n.fa-expand-alt:before {\n  content: \"\\f424\"; }\n\n.fa-expand-arrows:before {\n  content: \"\\f31d\"; }\n\n.fa-expand-arrows-alt:before {\n  content: \"\\f31e\"; }\n\n.fa-expand-wide:before {\n  content: \"\\f320\"; }\n\n.fa-expeditedssl:before {\n  content: \"\\f23e\"; }\n\n.fa-external-link:before {\n  content: \"\\f08e\"; }\n\n.fa-external-link-alt:before {\n  content: \"\\f35d\"; }\n\n.fa-external-link-square:before {\n  content: \"\\f14c\"; }\n\n.fa-external-link-square-alt:before {\n  content: \"\\f360\"; }\n\n.fa-eye:before {\n  content: \"\\f06e\"; }\n\n.fa-eye-dropper:before {\n  content: \"\\f1fb\"; }\n\n.fa-eye-slash:before {\n  content: \"\\f070\"; }\n\n.fa-facebook:before {\n  content: \"\\f09a\"; }\n\n.fa-facebook-f:before {\n  content: \"\\f39e\"; }\n\n.fa-facebook-messenger:before {\n  content: \"\\f39f\"; }\n\n.fa-facebook-square:before {\n  content: \"\\f082\"; }\n\n.fa-fast-backward:before {\n  content: \"\\f049\"; }\n\n.fa-fast-forward:before {\n  content: \"\\f050\"; }\n\n.fa-fax:before {\n  content: \"\\f1ac\"; }\n\n.fa-female:before {\n  content: \"\\f182\"; }\n\n.fa-field-hockey:before {\n  content: \"\\f44c\"; }\n\n.fa-fighter-jet:before {\n  content: \"\\f0fb\"; }\n\n.fa-file:before {\n  content: \"\\f15b\"; }\n\n.fa-file-alt:before {\n  content: \"\\f15c\"; }\n\n.fa-file-archive:before {\n  content: \"\\f1c6\"; }\n\n.fa-file-audio:before {\n  content: \"\\f1c7\"; }\n\n.fa-file-check:before {\n  content: \"\\f316\"; }\n\n.fa-file-code:before {\n  content: \"\\f1c9\"; }\n\n.fa-file-edit:before {\n  content: \"\\f31c\"; }\n\n.fa-file-excel:before {\n  content: \"\\f1c3\"; }\n\n.fa-file-exclamation:before {\n  content: \"\\f31a\"; }\n\n.fa-file-image:before {\n  content: \"\\f1c5\"; }\n\n.fa-file-medical:before {\n  content: \"\\f477\"; }\n\n.fa-file-medical-alt:before {\n  content: \"\\f478\"; }\n\n.fa-file-minus:before {\n  content: \"\\f318\"; }\n\n.fa-file-pdf:before {\n  content: \"\\f1c1\"; }\n\n.fa-file-plus:before {\n  content: \"\\f319\"; }\n\n.fa-file-powerpoint:before {\n  content: \"\\f1c4\"; }\n\n.fa-file-times:before {\n  content: \"\\f317\"; }\n\n.fa-file-video:before {\n  content: \"\\f1c8\"; }\n\n.fa-file-word:before {\n  content: \"\\f1c2\"; }\n\n.fa-film:before {\n  content: \"\\f008\"; }\n\n.fa-film-alt:before {\n  content: \"\\f3a0\"; }\n\n.fa-filter:before {\n  content: \"\\f0b0\"; }\n\n.fa-fire:before {\n  content: \"\\f06d\"; }\n\n.fa-fire-extinguisher:before {\n  content: \"\\f134\"; }\n\n.fa-firefox:before {\n  content: \"\\f269\"; }\n\n.fa-first-aid:before {\n  content: \"\\f479\"; }\n\n.fa-first-order:before {\n  content: \"\\f2b0\"; }\n\n.fa-firstdraft:before {\n  content: \"\\f3a1\"; }\n\n.fa-flag:before {\n  content: \"\\f024\"; }\n\n.fa-flag-checkered:before {\n  content: \"\\f11e\"; }\n\n.fa-flask:before {\n  content: \"\\f0c3\"; }\n\n.fa-flickr:before {\n  content: \"\\f16e\"; }\n\n.fa-flipboard:before {\n  content: \"\\f44d\"; }\n\n.fa-fly:before {\n  content: \"\\f417\"; }\n\n.fa-folder:before {\n  content: \"\\f07b\"; }\n\n.fa-folder-open:before {\n  content: \"\\f07c\"; }\n\n.fa-font:before {\n  content: \"\\f031\"; }\n\n.fa-font-awesome:before {\n  content: \"\\f2b4\"; }\n\n.fa-font-awesome-alt:before {\n  content: \"\\f35c\"; }\n\n.fa-font-awesome-flag:before {\n  content: \"\\f425\"; }\n\n.fa-fonticons:before {\n  content: \"\\f280\"; }\n\n.fa-fonticons-fi:before {\n  content: \"\\f3a2\"; }\n\n.fa-football-ball:before {\n  content: \"\\f44e\"; }\n\n.fa-football-helmet:before {\n  content: \"\\f44f\"; }\n\n.fa-forklift:before {\n  content: \"\\f47a\"; }\n\n.fa-fort-awesome:before {\n  content: \"\\f286\"; }\n\n.fa-fort-awesome-alt:before {\n  content: \"\\f3a3\"; }\n\n.fa-forumbee:before {\n  content: \"\\f211\"; }\n\n.fa-forward:before {\n  content: \"\\f04e\"; }\n\n.fa-foursquare:before {\n  content: \"\\f180\"; }\n\n.fa-free-code-camp:before {\n  content: \"\\f2c5\"; }\n\n.fa-freebsd:before {\n  content: \"\\f3a4\"; }\n\n.fa-frown:before {\n  content: \"\\f119\"; }\n\n.fa-futbol:before {\n  content: \"\\f1e3\"; }\n\n.fa-gamepad:before {\n  content: \"\\f11b\"; }\n\n.fa-gavel:before {\n  content: \"\\f0e3\"; }\n\n.fa-gem:before {\n  content: \"\\f3a5\"; }\n\n.fa-genderless:before {\n  content: \"\\f22d\"; }\n\n.fa-get-pocket:before {\n  content: \"\\f265\"; }\n\n.fa-gg:before {\n  content: \"\\f260\"; }\n\n.fa-gg-circle:before {\n  content: \"\\f261\"; }\n\n.fa-gift:before {\n  content: \"\\f06b\"; }\n\n.fa-git:before {\n  content: \"\\f1d3\"; }\n\n.fa-git-square:before {\n  content: \"\\f1d2\"; }\n\n.fa-github:before {\n  content: \"\\f09b\"; }\n\n.fa-github-alt:before {\n  content: \"\\f113\"; }\n\n.fa-github-square:before {\n  content: \"\\f092\"; }\n\n.fa-gitkraken:before {\n  content: \"\\f3a6\"; }\n\n.fa-gitlab:before {\n  content: \"\\f296\"; }\n\n.fa-gitter:before {\n  content: \"\\f426\"; }\n\n.fa-glass-martini:before {\n  content: \"\\f000\"; }\n\n.fa-glide:before {\n  content: \"\\f2a5\"; }\n\n.fa-glide-g:before {\n  content: \"\\f2a6\"; }\n\n.fa-globe:before {\n  content: \"\\f0ac\"; }\n\n.fa-gofore:before {\n  content: \"\\f3a7\"; }\n\n.fa-golf-ball:before {\n  content: \"\\f450\"; }\n\n.fa-golf-club:before {\n  content: \"\\f451\"; }\n\n.fa-goodreads:before {\n  content: \"\\f3a8\"; }\n\n.fa-goodreads-g:before {\n  content: \"\\f3a9\"; }\n\n.fa-google:before {\n  content: \"\\f1a0\"; }\n\n.fa-google-drive:before {\n  content: \"\\f3aa\"; }\n\n.fa-google-play:before {\n  content: \"\\f3ab\"; }\n\n.fa-google-plus:before {\n  content: \"\\f2b3\"; }\n\n.fa-google-plus-g:before {\n  content: \"\\f0d5\"; }\n\n.fa-google-plus-square:before {\n  content: \"\\f0d4\"; }\n\n.fa-google-wallet:before {\n  content: \"\\f1ee\"; }\n\n.fa-graduation-cap:before {\n  content: \"\\f19d\"; }\n\n.fa-gratipay:before {\n  content: \"\\f184\"; }\n\n.fa-grav:before {\n  content: \"\\f2d6\"; }\n\n.fa-gripfire:before {\n  content: \"\\f3ac\"; }\n\n.fa-grunt:before {\n  content: \"\\f3ad\"; }\n\n.fa-gulp:before {\n  content: \"\\f3ae\"; }\n\n.fa-h-square:before {\n  content: \"\\f0fd\"; }\n\n.fa-h1:before {\n  content: \"\\f313\"; }\n\n.fa-h2:before {\n  content: \"\\f314\"; }\n\n.fa-h3:before {\n  content: \"\\f315\"; }\n\n.fa-hacker-news:before {\n  content: \"\\f1d4\"; }\n\n.fa-hacker-news-square:before {\n  content: \"\\f3af\"; }\n\n.fa-hand-holding-box:before {\n  content: \"\\f47b\"; }\n\n.fa-hand-lizard:before {\n  content: \"\\f258\"; }\n\n.fa-hand-paper:before {\n  content: \"\\f256\"; }\n\n.fa-hand-peace:before {\n  content: \"\\f25b\"; }\n\n.fa-hand-point-down:before {\n  content: \"\\f0a7\"; }\n\n.fa-hand-point-left:before {\n  content: \"\\f0a5\"; }\n\n.fa-hand-point-right:before {\n  content: \"\\f0a4\"; }\n\n.fa-hand-point-up:before {\n  content: \"\\f0a6\"; }\n\n.fa-hand-pointer:before {\n  content: \"\\f25a\"; }\n\n.fa-hand-receiving:before {\n  content: \"\\f47c\"; }\n\n.fa-hand-rock:before {\n  content: \"\\f255\"; }\n\n.fa-hand-scissors:before {\n  content: \"\\f257\"; }\n\n.fa-hand-spock:before {\n  content: \"\\f259\"; }\n\n.fa-handshake:before {\n  content: \"\\f2b5\"; }\n\n.fa-hashtag:before {\n  content: \"\\f292\"; }\n\n.fa-hdd:before {\n  content: \"\\f0a0\"; }\n\n.fa-heading:before {\n  content: \"\\f1dc\"; }\n\n.fa-headphones:before {\n  content: \"\\f025\"; }\n\n.fa-heart:before {\n  content: \"\\f004\"; }\n\n.fa-heartbeat:before {\n  content: \"\\f21e\"; }\n\n.fa-hexagon:before {\n  content: \"\\f312\"; }\n\n.fa-hips:before {\n  content: \"\\f452\"; }\n\n.fa-hire-a-helper:before {\n  content: \"\\f3b0\"; }\n\n.fa-history:before {\n  content: \"\\f1da\"; }\n\n.fa-hockey-puck:before {\n  content: \"\\f453\"; }\n\n.fa-hockey-sticks:before {\n  content: \"\\f454\"; }\n\n.fa-home:before {\n  content: \"\\f015\"; }\n\n.fa-hooli:before {\n  content: \"\\f427\"; }\n\n.fa-hospital:before {\n  content: \"\\f0f8\"; }\n\n.fa-hospital-alt:before {\n  content: \"\\f47d\"; }\n\n.fa-hospital-symbol:before {\n  content: \"\\f47e\"; }\n\n.fa-hotjar:before {\n  content: \"\\f3b1\"; }\n\n.fa-hourglass:before {\n  content: \"\\f254\"; }\n\n.fa-hourglass-end:before {\n  content: \"\\f253\"; }\n\n.fa-hourglass-half:before {\n  content: \"\\f252\"; }\n\n.fa-hourglass-start:before {\n  content: \"\\f251\"; }\n\n.fa-houzz:before {\n  content: \"\\f27c\"; }\n\n.fa-html5:before {\n  content: \"\\f13b\"; }\n\n.fa-hubspot:before {\n  content: \"\\f3b2\"; }\n\n.fa-i-cursor:before {\n  content: \"\\f246\"; }\n\n.fa-id-badge:before {\n  content: \"\\f2c1\"; }\n\n.fa-id-card:before {\n  content: \"\\f2c2\"; }\n\n.fa-id-card-alt:before {\n  content: \"\\f47f\"; }\n\n.fa-image:before {\n  content: \"\\f03e\"; }\n\n.fa-images:before {\n  content: \"\\f302\"; }\n\n.fa-imdb:before {\n  content: \"\\f2d8\"; }\n\n.fa-inbox:before {\n  content: \"\\f01c\"; }\n\n.fa-inbox-in:before {\n  content: \"\\f310\"; }\n\n.fa-inbox-out:before {\n  content: \"\\f311\"; }\n\n.fa-indent:before {\n  content: \"\\f03c\"; }\n\n.fa-industry:before {\n  content: \"\\f275\"; }\n\n.fa-industry-alt:before {\n  content: \"\\f3b3\"; }\n\n.fa-info:before {\n  content: \"\\f129\"; }\n\n.fa-info-circle:before {\n  content: \"\\f05a\"; }\n\n.fa-info-square:before {\n  content: \"\\f30f\"; }\n\n.fa-instagram:before {\n  content: \"\\f16d\"; }\n\n.fa-internet-explorer:before {\n  content: \"\\f26b\"; }\n\n.fa-inventory:before {\n  content: \"\\f480\"; }\n\n.fa-ioxhost:before {\n  content: \"\\f208\"; }\n\n.fa-italic:before {\n  content: \"\\f033\"; }\n\n.fa-itunes:before {\n  content: \"\\f3b4\"; }\n\n.fa-itunes-note:before {\n  content: \"\\f3b5\"; }\n\n.fa-jack-o-lantern:before {\n  content: \"\\f30e\"; }\n\n.fa-jenkins:before {\n  content: \"\\f3b6\"; }\n\n.fa-joget:before {\n  content: \"\\f3b7\"; }\n\n.fa-joomla:before {\n  content: \"\\f1aa\"; }\n\n.fa-js:before {\n  content: \"\\f3b8\"; }\n\n.fa-js-square:before {\n  content: \"\\f3b9\"; }\n\n.fa-jsfiddle:before {\n  content: \"\\f1cc\"; }\n\n.fa-key:before {\n  content: \"\\f084\"; }\n\n.fa-keyboard:before {\n  content: \"\\f11c\"; }\n\n.fa-keycdn:before {\n  content: \"\\f3ba\"; }\n\n.fa-kickstarter:before {\n  content: \"\\f3bb\"; }\n\n.fa-kickstarter-k:before {\n  content: \"\\f3bc\"; }\n\n.fa-korvue:before {\n  content: \"\\f42f\"; }\n\n.fa-language:before {\n  content: \"\\f1ab\"; }\n\n.fa-laptop:before {\n  content: \"\\f109\"; }\n\n.fa-laravel:before {\n  content: \"\\f3bd\"; }\n\n.fa-lastfm:before {\n  content: \"\\f202\"; }\n\n.fa-lastfm-square:before {\n  content: \"\\f203\"; }\n\n.fa-leaf:before {\n  content: \"\\f06c\"; }\n\n.fa-leanpub:before {\n  content: \"\\f212\"; }\n\n.fa-lemon:before {\n  content: \"\\f094\"; }\n\n.fa-less:before {\n  content: \"\\f41d\"; }\n\n.fa-level-down:before {\n  content: \"\\f149\"; }\n\n.fa-level-down-alt:before {\n  content: \"\\f3be\"; }\n\n.fa-level-up:before {\n  content: \"\\f148\"; }\n\n.fa-level-up-alt:before {\n  content: \"\\f3bf\"; }\n\n.fa-life-ring:before {\n  content: \"\\f1cd\"; }\n\n.fa-lightbulb:before {\n  content: \"\\f0eb\"; }\n\n.fa-line:before {\n  content: \"\\f3c0\"; }\n\n.fa-link:before {\n  content: \"\\f0c1\"; }\n\n.fa-linkedin:before {\n  content: \"\\f08c\"; }\n\n.fa-linkedin-in:before {\n  content: \"\\f0e1\"; }\n\n.fa-linode:before {\n  content: \"\\f2b8\"; }\n\n.fa-linux:before {\n  content: \"\\f17c\"; }\n\n.fa-lira-sign:before {\n  content: \"\\f195\"; }\n\n.fa-list:before {\n  content: \"\\f03a\"; }\n\n.fa-list-alt:before {\n  content: \"\\f022\"; }\n\n.fa-list-ol:before {\n  content: \"\\f0cb\"; }\n\n.fa-list-ul:before {\n  content: \"\\f0ca\"; }\n\n.fa-location-arrow:before {\n  content: \"\\f124\"; }\n\n.fa-lock:before {\n  content: \"\\f023\"; }\n\n.fa-lock-alt:before {\n  content: \"\\f30d\"; }\n\n.fa-lock-open:before {\n  content: \"\\f3c1\"; }\n\n.fa-lock-open-alt:before {\n  content: \"\\f3c2\"; }\n\n.fa-long-arrow-alt-down:before {\n  content: \"\\f309\"; }\n\n.fa-long-arrow-alt-left:before {\n  content: \"\\f30a\"; }\n\n.fa-long-arrow-alt-right:before {\n  content: \"\\f30b\"; }\n\n.fa-long-arrow-alt-up:before {\n  content: \"\\f30c\"; }\n\n.fa-long-arrow-down:before {\n  content: \"\\f175\"; }\n\n.fa-long-arrow-left:before {\n  content: \"\\f177\"; }\n\n.fa-long-arrow-right:before {\n  content: \"\\f178\"; }\n\n.fa-long-arrow-up:before {\n  content: \"\\f176\"; }\n\n.fa-low-vision:before {\n  content: \"\\f2a8\"; }\n\n.fa-luchador:before {\n  content: \"\\f455\"; }\n\n.fa-lyft:before {\n  content: \"\\f3c3\"; }\n\n.fa-magento:before {\n  content: \"\\f3c4\"; }\n\n.fa-magic:before {\n  content: \"\\f0d0\"; }\n\n.fa-magnet:before {\n  content: \"\\f076\"; }\n\n.fa-male:before {\n  content: \"\\f183\"; }\n\n.fa-map:before {\n  content: \"\\f279\"; }\n\n.fa-map-marker:before {\n  content: \"\\f041\"; }\n\n.fa-map-marker-alt:before {\n  content: \"\\f3c5\"; }\n\n.fa-map-pin:before {\n  content: \"\\f276\"; }\n\n.fa-map-signs:before {\n  content: \"\\f277\"; }\n\n.fa-mars:before {\n  content: \"\\f222\"; }\n\n.fa-mars-double:before {\n  content: \"\\f227\"; }\n\n.fa-mars-stroke:before {\n  content: \"\\f229\"; }\n\n.fa-mars-stroke-h:before {\n  content: \"\\f22b\"; }\n\n.fa-mars-stroke-v:before {\n  content: \"\\f22a\"; }\n\n.fa-maxcdn:before {\n  content: \"\\f136\"; }\n\n.fa-medapps:before {\n  content: \"\\f3c6\"; }\n\n.fa-medium:before {\n  content: \"\\f23a\"; }\n\n.fa-medium-m:before {\n  content: \"\\f3c7\"; }\n\n.fa-medkit:before {\n  content: \"\\f0fa\"; }\n\n.fa-medrt:before {\n  content: \"\\f3c8\"; }\n\n.fa-meetup:before {\n  content: \"\\f2e0\"; }\n\n.fa-meh:before {\n  content: \"\\f11a\"; }\n\n.fa-mercury:before {\n  content: \"\\f223\"; }\n\n.fa-microchip:before {\n  content: \"\\f2db\"; }\n\n.fa-microphone:before {\n  content: \"\\f130\"; }\n\n.fa-microphone-alt:before {\n  content: \"\\f3c9\"; }\n\n.fa-microphone-slash:before {\n  content: \"\\f131\"; }\n\n.fa-microsoft:before {\n  content: \"\\f3ca\"; }\n\n.fa-minus:before {\n  content: \"\\f068\"; }\n\n.fa-minus-circle:before {\n  content: \"\\f056\"; }\n\n.fa-minus-hexagon:before {\n  content: \"\\f307\"; }\n\n.fa-minus-octagon:before {\n  content: \"\\f308\"; }\n\n.fa-minus-square:before {\n  content: \"\\f146\"; }\n\n.fa-mix:before {\n  content: \"\\f3cb\"; }\n\n.fa-mixcloud:before {\n  content: \"\\f289\"; }\n\n.fa-mizuni:before {\n  content: \"\\f3cc\"; }\n\n.fa-mobile:before {\n  content: \"\\f10b\"; }\n\n.fa-mobile-alt:before {\n  content: \"\\f3cd\"; }\n\n.fa-mobile-android:before {\n  content: \"\\f3ce\"; }\n\n.fa-mobile-android-alt:before {\n  content: \"\\f3cf\"; }\n\n.fa-modx:before {\n  content: \"\\f285\"; }\n\n.fa-monero:before {\n  content: \"\\f3d0\"; }\n\n.fa-money-bill:before {\n  content: \"\\f0d6\"; }\n\n.fa-money-bill-alt:before {\n  content: \"\\f3d1\"; }\n\n.fa-moon:before {\n  content: \"\\f186\"; }\n\n.fa-motorcycle:before {\n  content: \"\\f21c\"; }\n\n.fa-mouse-pointer:before {\n  content: \"\\f245\"; }\n\n.fa-music:before {\n  content: \"\\f001\"; }\n\n.fa-napster:before {\n  content: \"\\f3d2\"; }\n\n.fa-neuter:before {\n  content: \"\\f22c\"; }\n\n.fa-newspaper:before {\n  content: \"\\f1ea\"; }\n\n.fa-nintendo-switch:before {\n  content: \"\\f418\"; }\n\n.fa-node:before {\n  content: \"\\f419\"; }\n\n.fa-node-js:before {\n  content: \"\\f3d3\"; }\n\n.fa-notes-medical:before {\n  content: \"\\f481\"; }\n\n.fa-npm:before {\n  content: \"\\f3d4\"; }\n\n.fa-ns8:before {\n  content: \"\\f3d5\"; }\n\n.fa-nutritionix:before {\n  content: \"\\f3d6\"; }\n\n.fa-object-group:before {\n  content: \"\\f247\"; }\n\n.fa-object-ungroup:before {\n  content: \"\\f248\"; }\n\n.fa-octagon:before {\n  content: \"\\f306\"; }\n\n.fa-odnoklassniki:before {\n  content: \"\\f263\"; }\n\n.fa-odnoklassniki-square:before {\n  content: \"\\f264\"; }\n\n.fa-opencart:before {\n  content: \"\\f23d\"; }\n\n.fa-openid:before {\n  content: \"\\f19b\"; }\n\n.fa-opera:before {\n  content: \"\\f26a\"; }\n\n.fa-optin-monster:before {\n  content: \"\\f23c\"; }\n\n.fa-osi:before {\n  content: \"\\f41a\"; }\n\n.fa-outdent:before {\n  content: \"\\f03b\"; }\n\n.fa-page4:before {\n  content: \"\\f3d7\"; }\n\n.fa-pagelines:before {\n  content: \"\\f18c\"; }\n\n.fa-paint-brush:before {\n  content: \"\\f1fc\"; }\n\n.fa-palfed:before {\n  content: \"\\f3d8\"; }\n\n.fa-pallet:before {\n  content: \"\\f482\"; }\n\n.fa-pallet-alt:before {\n  content: \"\\f483\"; }\n\n.fa-paper-plane:before {\n  content: \"\\f1d8\"; }\n\n.fa-paperclip:before {\n  content: \"\\f0c6\"; }\n\n.fa-paragraph:before {\n  content: \"\\f1dd\"; }\n\n.fa-paste:before {\n  content: \"\\f0ea\"; }\n\n.fa-patreon:before {\n  content: \"\\f3d9\"; }\n\n.fa-pause:before {\n  content: \"\\f04c\"; }\n\n.fa-pause-circle:before {\n  content: \"\\f28b\"; }\n\n.fa-paw:before {\n  content: \"\\f1b0\"; }\n\n.fa-paypal:before {\n  content: \"\\f1ed\"; }\n\n.fa-pen:before {\n  content: \"\\f304\"; }\n\n.fa-pen-alt:before {\n  content: \"\\f305\"; }\n\n.fa-pen-square:before {\n  content: \"\\f14b\"; }\n\n.fa-pencil:before {\n  content: \"\\f040\"; }\n\n.fa-pencil-alt:before {\n  content: \"\\f303\"; }\n\n.fa-pennant:before {\n  content: \"\\f456\"; }\n\n.fa-percent:before {\n  content: \"\\f295\"; }\n\n.fa-periscope:before {\n  content: \"\\f3da\"; }\n\n.fa-phabricator:before {\n  content: \"\\f3db\"; }\n\n.fa-phoenix-framework:before {\n  content: \"\\f3dc\"; }\n\n.fa-phone:before {\n  content: \"\\f095\"; }\n\n.fa-phone-slash:before {\n  content: \"\\f3dd\"; }\n\n.fa-phone-square:before {\n  content: \"\\f098\"; }\n\n.fa-phone-volume:before {\n  content: \"\\f2a0\"; }\n\n.fa-php:before {\n  content: \"\\f457\"; }\n\n.fa-pied-piper:before {\n  content: \"\\f2ae\"; }\n\n.fa-pied-piper-alt:before {\n  content: \"\\f1a8\"; }\n\n.fa-pied-piper-pp:before {\n  content: \"\\f1a7\"; }\n\n.fa-pills:before {\n  content: \"\\f484\"; }\n\n.fa-pinterest:before {\n  content: \"\\f0d2\"; }\n\n.fa-pinterest-p:before {\n  content: \"\\f231\"; }\n\n.fa-pinterest-square:before {\n  content: \"\\f0d3\"; }\n\n.fa-plane:before {\n  content: \"\\f072\"; }\n\n.fa-plane-alt:before {\n  content: \"\\f3de\"; }\n\n.fa-play:before {\n  content: \"\\f04b\"; }\n\n.fa-play-circle:before {\n  content: \"\\f144\"; }\n\n.fa-playstation:before {\n  content: \"\\f3df\"; }\n\n.fa-plug:before {\n  content: \"\\f1e6\"; }\n\n.fa-plus:before {\n  content: \"\\f067\"; }\n\n.fa-plus-circle:before {\n  content: \"\\f055\"; }\n\n.fa-plus-hexagon:before {\n  content: \"\\f300\"; }\n\n.fa-plus-octagon:before {\n  content: \"\\f301\"; }\n\n.fa-plus-square:before {\n  content: \"\\f0fe\"; }\n\n.fa-podcast:before {\n  content: \"\\f2ce\"; }\n\n.fa-poo:before {\n  content: \"\\f2fe\"; }\n\n.fa-portrait:before {\n  content: \"\\f3e0\"; }\n\n.fa-pound-sign:before {\n  content: \"\\f154\"; }\n\n.fa-power-off:before {\n  content: \"\\f011\"; }\n\n.fa-prescription-bottle:before {\n  content: \"\\f485\"; }\n\n.fa-prescription-bottle-alt:before {\n  content: \"\\f486\"; }\n\n.fa-print:before {\n  content: \"\\f02f\"; }\n\n.fa-procedures:before {\n  content: \"\\f487\"; }\n\n.fa-product-hunt:before {\n  content: \"\\f288\"; }\n\n.fa-pushed:before {\n  content: \"\\f3e1\"; }\n\n.fa-puzzle-piece:before {\n  content: \"\\f12e\"; }\n\n.fa-python:before {\n  content: \"\\f3e2\"; }\n\n.fa-qq:before {\n  content: \"\\f1d6\"; }\n\n.fa-qrcode:before {\n  content: \"\\f029\"; }\n\n.fa-question:before {\n  content: \"\\f128\"; }\n\n.fa-question-circle:before {\n  content: \"\\f059\"; }\n\n.fa-question-square:before {\n  content: \"\\f2fd\"; }\n\n.fa-quidditch:before {\n  content: \"\\f458\"; }\n\n.fa-quinscape:before {\n  content: \"\\f459\"; }\n\n.fa-quora:before {\n  content: \"\\f2c4\"; }\n\n.fa-quote-left:before {\n  content: \"\\f10d\"; }\n\n.fa-quote-right:before {\n  content: \"\\f10e\"; }\n\n.fa-racquet:before {\n  content: \"\\f45a\"; }\n\n.fa-random:before {\n  content: \"\\f074\"; }\n\n.fa-ravelry:before {\n  content: \"\\f2d9\"; }\n\n.fa-react:before {\n  content: \"\\f41b\"; }\n\n.fa-rebel:before {\n  content: \"\\f1d0\"; }\n\n.fa-rectangle-landscape:before {\n  content: \"\\f2fa\"; }\n\n.fa-rectangle-portrait:before {\n  content: \"\\f2fb\"; }\n\n.fa-rectangle-wide:before {\n  content: \"\\f2fc\"; }\n\n.fa-recycle:before {\n  content: \"\\f1b8\"; }\n\n.fa-red-river:before {\n  content: \"\\f3e3\"; }\n\n.fa-reddit:before {\n  content: \"\\f1a1\"; }\n\n.fa-reddit-alien:before {\n  content: \"\\f281\"; }\n\n.fa-reddit-square:before {\n  content: \"\\f1a2\"; }\n\n.fa-redo:before {\n  content: \"\\f01e\"; }\n\n.fa-redo-alt:before {\n  content: \"\\f2f9\"; }\n\n.fa-registered:before {\n  content: \"\\f25d\"; }\n\n.fa-rendact:before {\n  content: \"\\f3e4\"; }\n\n.fa-renren:before {\n  content: \"\\f18b\"; }\n\n.fa-repeat:before {\n  content: \"\\f363\"; }\n\n.fa-repeat-1:before {\n  content: \"\\f365\"; }\n\n.fa-repeat-1-alt:before {\n  content: \"\\f366\"; }\n\n.fa-repeat-alt:before {\n  content: \"\\f364\"; }\n\n.fa-reply:before {\n  content: \"\\f3e5\"; }\n\n.fa-reply-all:before {\n  content: \"\\f122\"; }\n\n.fa-replyd:before {\n  content: \"\\f3e6\"; }\n\n.fa-resolving:before {\n  content: \"\\f3e7\"; }\n\n.fa-retweet:before {\n  content: \"\\f079\"; }\n\n.fa-retweet-alt:before {\n  content: \"\\f361\"; }\n\n.fa-road:before {\n  content: \"\\f018\"; }\n\n.fa-rocket:before {\n  content: \"\\f135\"; }\n\n.fa-rocketchat:before {\n  content: \"\\f3e8\"; }\n\n.fa-rockrms:before {\n  content: \"\\f3e9\"; }\n\n.fa-rss:before {\n  content: \"\\f09e\"; }\n\n.fa-rss-square:before {\n  content: \"\\f143\"; }\n\n.fa-ruble-sign:before {\n  content: \"\\f158\"; }\n\n.fa-rupee-sign:before {\n  content: \"\\f156\"; }\n\n.fa-safari:before {\n  content: \"\\f267\"; }\n\n.fa-sass:before {\n  content: \"\\f41e\"; }\n\n.fa-save:before {\n  content: \"\\f0c7\"; }\n\n.fa-scanner:before {\n  content: \"\\f488\"; }\n\n.fa-scanner-keyboard:before {\n  content: \"\\f489\"; }\n\n.fa-scanner-touchscreen:before {\n  content: \"\\f48a\"; }\n\n.fa-schlix:before {\n  content: \"\\f3ea\"; }\n\n.fa-scribd:before {\n  content: \"\\f28a\"; }\n\n.fa-scrubber:before {\n  content: \"\\f2f8\"; }\n\n.fa-search:before {\n  content: \"\\f002\"; }\n\n.fa-search-minus:before {\n  content: \"\\f010\"; }\n\n.fa-search-plus:before {\n  content: \"\\f00e\"; }\n\n.fa-searchengin:before {\n  content: \"\\f3eb\"; }\n\n.fa-sellcast:before {\n  content: \"\\f2da\"; }\n\n.fa-sellsy:before {\n  content: \"\\f213\"; }\n\n.fa-server:before {\n  content: \"\\f233\"; }\n\n.fa-servicestack:before {\n  content: \"\\f3ec\"; }\n\n.fa-share:before {\n  content: \"\\f064\"; }\n\n.fa-share-all:before {\n  content: \"\\f367\"; }\n\n.fa-share-alt:before {\n  content: \"\\f1e0\"; }\n\n.fa-share-alt-square:before {\n  content: \"\\f1e1\"; }\n\n.fa-share-square:before {\n  content: \"\\f14d\"; }\n\n.fa-shekel-sign:before {\n  content: \"\\f20b\"; }\n\n.fa-shield:before {\n  content: \"\\f132\"; }\n\n.fa-shield-alt:before {\n  content: \"\\f3ed\"; }\n\n.fa-shield-check:before {\n  content: \"\\f2f7\"; }\n\n.fa-ship:before {\n  content: \"\\f21a\"; }\n\n.fa-shipping-fast:before {\n  content: \"\\f48b\"; }\n\n.fa-shipping-timed:before {\n  content: \"\\f48c\"; }\n\n.fa-shirtsinbulk:before {\n  content: \"\\f214\"; }\n\n.fa-shopping-bag:before {\n  content: \"\\f290\"; }\n\n.fa-shopping-basket:before {\n  content: \"\\f291\"; }\n\n.fa-shopping-cart:before {\n  content: \"\\f07a\"; }\n\n.fa-shower:before {\n  content: \"\\f2cc\"; }\n\n.fa-shuttlecock:before {\n  content: \"\\f45b\"; }\n\n.fa-sign-in:before {\n  content: \"\\f090\"; }\n\n.fa-sign-in-alt:before {\n  content: \"\\f2f6\"; }\n\n.fa-sign-language:before {\n  content: \"\\f2a7\"; }\n\n.fa-sign-out:before {\n  content: \"\\f08b\"; }\n\n.fa-sign-out-alt:before {\n  content: \"\\f2f5\"; }\n\n.fa-signal:before {\n  content: \"\\f012\"; }\n\n.fa-simplybuilt:before {\n  content: \"\\f215\"; }\n\n.fa-sistrix:before {\n  content: \"\\f3ee\"; }\n\n.fa-sitemap:before {\n  content: \"\\f0e8\"; }\n\n.fa-skyatlas:before {\n  content: \"\\f216\"; }\n\n.fa-skype:before {\n  content: \"\\f17e\"; }\n\n.fa-slack:before {\n  content: \"\\f198\"; }\n\n.fa-slack-hash:before {\n  content: \"\\f3ef\"; }\n\n.fa-sliders-h:before {\n  content: \"\\f1de\"; }\n\n.fa-sliders-h-square:before {\n  content: \"\\f3f0\"; }\n\n.fa-sliders-v:before {\n  content: \"\\f3f1\"; }\n\n.fa-sliders-v-square:before {\n  content: \"\\f3f2\"; }\n\n.fa-slideshare:before {\n  content: \"\\f1e7\"; }\n\n.fa-smile:before {\n  content: \"\\f118\"; }\n\n.fa-smoking:before {\n  content: \"\\f48d\"; }\n\n.fa-snapchat:before {\n  content: \"\\f2ab\"; }\n\n.fa-snapchat-ghost:before {\n  content: \"\\f2ac\"; }\n\n.fa-snapchat-square:before {\n  content: \"\\f2ad\"; }\n\n.fa-snowflake:before {\n  content: \"\\f2dc\"; }\n\n.fa-sort:before {\n  content: \"\\f0dc\"; }\n\n.fa-sort-alpha-down:before {\n  content: \"\\f15d\"; }\n\n.fa-sort-alpha-up:before {\n  content: \"\\f15e\"; }\n\n.fa-sort-amount-down:before {\n  content: \"\\f160\"; }\n\n.fa-sort-amount-up:before {\n  content: \"\\f161\"; }\n\n.fa-sort-down:before {\n  content: \"\\f0dd\"; }\n\n.fa-sort-numeric-down:before {\n  content: \"\\f162\"; }\n\n.fa-sort-numeric-up:before {\n  content: \"\\f163\"; }\n\n.fa-sort-up:before {\n  content: \"\\f0de\"; }\n\n.fa-soundcloud:before {\n  content: \"\\f1be\"; }\n\n.fa-space-shuttle:before {\n  content: \"\\f197\"; }\n\n.fa-spade:before {\n  content: \"\\f2f4\"; }\n\n.fa-speakap:before {\n  content: \"\\f3f3\"; }\n\n.fa-spinner:before {\n  content: \"\\f110\"; }\n\n.fa-spinner-third:before {\n  content: \"\\f3f4\"; }\n\n.fa-spotify:before {\n  content: \"\\f1bc\"; }\n\n.fa-square:before {\n  content: \"\\f0c8\"; }\n\n.fa-square-full:before {\n  content: \"\\f45c\"; }\n\n.fa-stack-exchange:before {\n  content: \"\\f18d\"; }\n\n.fa-stack-overflow:before {\n  content: \"\\f16c\"; }\n\n.fa-star:before {\n  content: \"\\f005\"; }\n\n.fa-star-exclamation:before {\n  content: \"\\f2f3\"; }\n\n.fa-star-half:before {\n  content: \"\\f089\"; }\n\n.fa-staylinked:before {\n  content: \"\\f3f5\"; }\n\n.fa-steam:before {\n  content: \"\\f1b6\"; }\n\n.fa-steam-square:before {\n  content: \"\\f1b7\"; }\n\n.fa-steam-symbol:before {\n  content: \"\\f3f6\"; }\n\n.fa-step-backward:before {\n  content: \"\\f048\"; }\n\n.fa-step-forward:before {\n  content: \"\\f051\"; }\n\n.fa-stethoscope:before {\n  content: \"\\f0f1\"; }\n\n.fa-sticker-mule:before {\n  content: \"\\f3f7\"; }\n\n.fa-sticky-note:before {\n  content: \"\\f249\"; }\n\n.fa-stop:before {\n  content: \"\\f04d\"; }\n\n.fa-stop-circle:before {\n  content: \"\\f28d\"; }\n\n.fa-stopwatch:before {\n  content: \"\\f2f2\"; }\n\n.fa-strava:before {\n  content: \"\\f428\"; }\n\n.fa-street-view:before {\n  content: \"\\f21d\"; }\n\n.fa-strikethrough:before {\n  content: \"\\f0cc\"; }\n\n.fa-stripe:before {\n  content: \"\\f429\"; }\n\n.fa-stripe-s:before {\n  content: \"\\f42a\"; }\n\n.fa-studiovinari:before {\n  content: \"\\f3f8\"; }\n\n.fa-stumbleupon:before {\n  content: \"\\f1a4\"; }\n\n.fa-stumbleupon-circle:before {\n  content: \"\\f1a3\"; }\n\n.fa-subscript:before {\n  content: \"\\f12c\"; }\n\n.fa-subway:before {\n  content: \"\\f239\"; }\n\n.fa-suitcase:before {\n  content: \"\\f0f2\"; }\n\n.fa-sun:before {\n  content: \"\\f185\"; }\n\n.fa-superpowers:before {\n  content: \"\\f2dd\"; }\n\n.fa-superscript:before {\n  content: \"\\f12b\"; }\n\n.fa-supple:before {\n  content: \"\\f3f9\"; }\n\n.fa-sync:before {\n  content: \"\\f021\"; }\n\n.fa-sync-alt:before {\n  content: \"\\f2f1\"; }\n\n.fa-syringe:before {\n  content: \"\\f48e\"; }\n\n.fa-table:before {\n  content: \"\\f0ce\"; }\n\n.fa-table-tennis:before {\n  content: \"\\f45d\"; }\n\n.fa-tablet:before {\n  content: \"\\f10a\"; }\n\n.fa-tablet-alt:before {\n  content: \"\\f3fa\"; }\n\n.fa-tablet-android:before {\n  content: \"\\f3fb\"; }\n\n.fa-tablet-android-alt:before {\n  content: \"\\f3fc\"; }\n\n.fa-tablet-rugged:before {\n  content: \"\\f48f\"; }\n\n.fa-tablets:before {\n  content: \"\\f490\"; }\n\n.fa-tachometer:before {\n  content: \"\\f0e4\"; }\n\n.fa-tachometer-alt:before {\n  content: \"\\f3fd\"; }\n\n.fa-tag:before {\n  content: \"\\f02b\"; }\n\n.fa-tags:before {\n  content: \"\\f02c\"; }\n\n.fa-tasks:before {\n  content: \"\\f0ae\"; }\n\n.fa-taxi:before {\n  content: \"\\f1ba\"; }\n\n.fa-telegram:before {\n  content: \"\\f2c6\"; }\n\n.fa-telegram-plane:before {\n  content: \"\\f3fe\"; }\n\n.fa-tencent-weibo:before {\n  content: \"\\f1d5\"; }\n\n.fa-tennis-ball:before {\n  content: \"\\f45e\"; }\n\n.fa-terminal:before {\n  content: \"\\f120\"; }\n\n.fa-text-height:before {\n  content: \"\\f034\"; }\n\n.fa-text-width:before {\n  content: \"\\f035\"; }\n\n.fa-th:before {\n  content: \"\\f00a\"; }\n\n.fa-th-large:before {\n  content: \"\\f009\"; }\n\n.fa-th-list:before {\n  content: \"\\f00b\"; }\n\n.fa-themeisle:before {\n  content: \"\\f2b2\"; }\n\n.fa-thermometer:before {\n  content: \"\\f491\"; }\n\n.fa-thermometer-empty:before {\n  content: \"\\f2cb\"; }\n\n.fa-thermometer-full:before {\n  content: \"\\f2c7\"; }\n\n.fa-thermometer-half:before {\n  content: \"\\f2c9\"; }\n\n.fa-thermometer-quarter:before {\n  content: \"\\f2ca\"; }\n\n.fa-thermometer-three-quarters:before {\n  content: \"\\f2c8\"; }\n\n.fa-thumbs-down:before {\n  content: \"\\f165\"; }\n\n.fa-thumbs-up:before {\n  content: \"\\f164\"; }\n\n.fa-thumbtack:before {\n  content: \"\\f08d\"; }\n\n.fa-ticket:before {\n  content: \"\\f145\"; }\n\n.fa-ticket-alt:before {\n  content: \"\\f3ff\"; }\n\n.fa-times:before {\n  content: \"\\f00d\"; }\n\n.fa-times-circle:before {\n  content: \"\\f057\"; }\n\n.fa-times-hexagon:before {\n  content: \"\\f2ee\"; }\n\n.fa-times-octagon:before {\n  content: \"\\f2f0\"; }\n\n.fa-times-square:before {\n  content: \"\\f2d3\"; }\n\n.fa-tint:before {\n  content: \"\\f043\"; }\n\n.fa-toggle-off:before {\n  content: \"\\f204\"; }\n\n.fa-toggle-on:before {\n  content: \"\\f205\"; }\n\n.fa-trademark:before {\n  content: \"\\f25c\"; }\n\n.fa-train:before {\n  content: \"\\f238\"; }\n\n.fa-transgender:before {\n  content: \"\\f224\"; }\n\n.fa-transgender-alt:before {\n  content: \"\\f225\"; }\n\n.fa-trash:before {\n  content: \"\\f1f8\"; }\n\n.fa-trash-alt:before {\n  content: \"\\f2ed\"; }\n\n.fa-tree:before {\n  content: \"\\f1bb\"; }\n\n.fa-tree-alt:before {\n  content: \"\\f400\"; }\n\n.fa-trello:before {\n  content: \"\\f181\"; }\n\n.fa-triangle:before {\n  content: \"\\f2ec\"; }\n\n.fa-tripadvisor:before {\n  content: \"\\f262\"; }\n\n.fa-trophy:before {\n  content: \"\\f091\"; }\n\n.fa-trophy-alt:before {\n  content: \"\\f2eb\"; }\n\n.fa-truck:before {\n  content: \"\\f0d1\"; }\n\n.fa-tty:before {\n  content: \"\\f1e4\"; }\n\n.fa-tumblr:before {\n  content: \"\\f173\"; }\n\n.fa-tumblr-square:before {\n  content: \"\\f174\"; }\n\n.fa-tv:before {\n  content: \"\\f26c\"; }\n\n.fa-tv-retro:before {\n  content: \"\\f401\"; }\n\n.fa-twitch:before {\n  content: \"\\f1e8\"; }\n\n.fa-twitter:before {\n  content: \"\\f099\"; }\n\n.fa-twitter-square:before {\n  content: \"\\f081\"; }\n\n.fa-typo3:before {\n  content: \"\\f42b\"; }\n\n.fa-uber:before {\n  content: \"\\f402\"; }\n\n.fa-uikit:before {\n  content: \"\\f403\"; }\n\n.fa-umbrella:before {\n  content: \"\\f0e9\"; }\n\n.fa-underline:before {\n  content: \"\\f0cd\"; }\n\n.fa-undo:before {\n  content: \"\\f0e2\"; }\n\n.fa-undo-alt:before {\n  content: \"\\f2ea\"; }\n\n.fa-uniregistry:before {\n  content: \"\\f404\"; }\n\n.fa-universal-access:before {\n  content: \"\\f29a\"; }\n\n.fa-university:before {\n  content: \"\\f19c\"; }\n\n.fa-unlink:before {\n  content: \"\\f127\"; }\n\n.fa-unlock:before {\n  content: \"\\f09c\"; }\n\n.fa-unlock-alt:before {\n  content: \"\\f13e\"; }\n\n.fa-untappd:before {\n  content: \"\\f405\"; }\n\n.fa-upload:before {\n  content: \"\\f093\"; }\n\n.fa-usb:before {\n  content: \"\\f287\"; }\n\n.fa-usd-circle:before {\n  content: \"\\f2e8\"; }\n\n.fa-usd-square:before {\n  content: \"\\f2e9\"; }\n\n.fa-user:before {\n  content: \"\\f007\"; }\n\n.fa-user-alt:before {\n  content: \"\\f406\"; }\n\n.fa-user-circle:before {\n  content: \"\\f2bd\"; }\n\n.fa-user-md:before {\n  content: \"\\f0f0\"; }\n\n.fa-user-plus:before {\n  content: \"\\f234\"; }\n\n.fa-user-secret:before {\n  content: \"\\f21b\"; }\n\n.fa-user-times:before {\n  content: \"\\f235\"; }\n\n.fa-users:before {\n  content: \"\\f0c0\"; }\n\n.fa-ussunnah:before {\n  content: \"\\f407\"; }\n\n.fa-utensil-fork:before {\n  content: \"\\f2e3\"; }\n\n.fa-utensil-knife:before {\n  content: \"\\f2e4\"; }\n\n.fa-utensil-spoon:before {\n  content: \"\\f2e5\"; }\n\n.fa-utensils:before {\n  content: \"\\f2e7\"; }\n\n.fa-utensils-alt:before {\n  content: \"\\f2e6\"; }\n\n.fa-vaadin:before {\n  content: \"\\f408\"; }\n\n.fa-venus:before {\n  content: \"\\f221\"; }\n\n.fa-venus-double:before {\n  content: \"\\f226\"; }\n\n.fa-venus-mars:before {\n  content: \"\\f228\"; }\n\n.fa-viacoin:before {\n  content: \"\\f237\"; }\n\n.fa-viadeo:before {\n  content: \"\\f2a9\"; }\n\n.fa-viadeo-square:before {\n  content: \"\\f2aa\"; }\n\n.fa-vial:before {\n  content: \"\\f492\"; }\n\n.fa-vials:before {\n  content: \"\\f493\"; }\n\n.fa-viber:before {\n  content: \"\\f409\"; }\n\n.fa-video:before {\n  content: \"\\f03d\"; }\n\n.fa-vimeo:before {\n  content: \"\\f40a\"; }\n\n.fa-vimeo-square:before {\n  content: \"\\f194\"; }\n\n.fa-vimeo-v:before {\n  content: \"\\f27d\"; }\n\n.fa-vine:before {\n  content: \"\\f1ca\"; }\n\n.fa-vk:before {\n  content: \"\\f189\"; }\n\n.fa-vnv:before {\n  content: \"\\f40b\"; }\n\n.fa-volleyball-ball:before {\n  content: \"\\f45f\"; }\n\n.fa-volume-down:before {\n  content: \"\\f027\"; }\n\n.fa-volume-mute:before {\n  content: \"\\f2e2\"; }\n\n.fa-volume-off:before {\n  content: \"\\f026\"; }\n\n.fa-volume-up:before {\n  content: \"\\f028\"; }\n\n.fa-vuejs:before {\n  content: \"\\f41f\"; }\n\n.fa-warehouse:before {\n  content: \"\\f494\"; }\n\n.fa-warehouse-alt:before {\n  content: \"\\f495\"; }\n\n.fa-watch:before {\n  content: \"\\f2e1\"; }\n\n.fa-weibo:before {\n  content: \"\\f18a\"; }\n\n.fa-weight:before {\n  content: \"\\f496\"; }\n\n.fa-weixin:before {\n  content: \"\\f1d7\"; }\n\n.fa-whatsapp:before {\n  content: \"\\f232\"; }\n\n.fa-whatsapp-square:before {\n  content: \"\\f40c\"; }\n\n.fa-wheelchair:before {\n  content: \"\\f193\"; }\n\n.fa-whistle:before {\n  content: \"\\f460\"; }\n\n.fa-whmcs:before {\n  content: \"\\f40d\"; }\n\n.fa-wifi:before {\n  content: \"\\f1eb\"; }\n\n.fa-wikipedia-w:before {\n  content: \"\\f266\"; }\n\n.fa-window:before {\n  content: \"\\f40e\"; }\n\n.fa-window-alt:before {\n  content: \"\\f40f\"; }\n\n.fa-window-close:before {\n  content: \"\\f410\"; }\n\n.fa-window-maximize:before {\n  content: \"\\f2d0\"; }\n\n.fa-window-minimize:before {\n  content: \"\\f2d1\"; }\n\n.fa-window-restore:before {\n  content: \"\\f2d2\"; }\n\n.fa-windows:before {\n  content: \"\\f17a\"; }\n\n.fa-won-sign:before {\n  content: \"\\f159\"; }\n\n.fa-wordpress:before {\n  content: \"\\f19a\"; }\n\n.fa-wordpress-simple:before {\n  content: \"\\f411\"; }\n\n.fa-wpbeginner:before {\n  content: \"\\f297\"; }\n\n.fa-wpexplorer:before {\n  content: \"\\f2de\"; }\n\n.fa-wpforms:before {\n  content: \"\\f298\"; }\n\n.fa-wrench:before {\n  content: \"\\f0ad\"; }\n\n.fa-x-ray:before {\n  content: \"\\f497\"; }\n\n.fa-xbox:before {\n  content: \"\\f412\"; }\n\n.fa-xing:before {\n  content: \"\\f168\"; }\n\n.fa-xing-square:before {\n  content: \"\\f169\"; }\n\n.fa-y-combinator:before {\n  content: \"\\f23b\"; }\n\n.fa-yahoo:before {\n  content: \"\\f19e\"; }\n\n.fa-yandex:before {\n  content: \"\\f413\"; }\n\n.fa-yandex-international:before {\n  content: \"\\f414\"; }\n\n.fa-yelp:before {\n  content: \"\\f1e9\"; }\n\n.fa-yen-sign:before {\n  content: \"\\f157\"; }\n\n.fa-yoast:before {\n  content: \"\\f2b1\"; }\n\n.fa-youtube:before {\n  content: \"\\f167\"; }\n\n.fa-youtube-square:before {\n  content: \"\\f431\"; }\n\n.sr-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px; }\n\n.sr-only-focusable:active, .sr-only-focusable:focus {\n  clip: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  position: static;\n  width: auto; }\n\nblockquote {\n  margin: 0;\n  padding: 0; }\n  blockquote p {\n    border: 1px solid #e8e8e8;\n    border-left: 0.5rem solid #e8e8e8;\n    margin: .5rem 0;\n    padding: .5rem 1rem .5rem 1.5rem; }\n\npre, code {\n  border-radius: .25em;\n  background-color: #f8f8f8; }\n\npre {\n  overflow-x: auto;\n  font-size: .9rem;\n  padding: 1rem;\n  white-space: pre-wrap; }\n  pre code {\n    padding: 0; }\n\ncode {\n  padding: .2em .5em; }\n\nhtml {\n  font-family: -apple-system, BlinkMacSystemFont, Helvetica, Arial;\n  font-size: 16px;\n  line-height: 1.5;\n  color: #2B2D33; }\n\nbody {\n  height: 100%; }\n\n* {\n  box-sizing: border-box; }\n\n.bcx-doc-nav {\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  width: 300px;\n  overflow-x: hidden;\n  overflow-y: auto;\n  background-color: #f2f2f2;\n  padding: .5rem;\n  transition: left ease 200ms;\n  border-right: 1px solid #e8e8e8; }\n  .bcx-doc-nav h1, .bcx-doc-nav h2, .bcx-doc-nav h3, .bcx-doc-nav h4, .bcx-doc-nav h5, .bcx-doc-nav h6 {\n    margin: .8em 0 .4em; }\n  .bcx-doc-nav .close-menu {\n    display: none; }\n\n.bcx-doc-nav-backdrop {\n  display: none; }\n\na.nav-link, a.nav-link:visited {\n  display: inline-block;\n  padding: .3rem .5rem;\n  color: #fff;\n  text-decoration: none;\n  border-radius: 3px;\n  cursor: pointer; }\n  a.nav-link:hover, a.nav-link:visited:hover {\n    background-color: #fff;\n    color: #5D99BD; }\n\n.nav-disabled {\n  display: inline-block;\n  padding: .3rem .5rem;\n  color: rgba(255, 255, 255, 0.4);\n  cursor: not-allowed; }\n\na.link {\n  display: block;\n  text-decoration: none;\n  font-size: .85rem; }\n  a.link.remote-link {\n    font-size: .75rem;\n    margin: 4px 0; }\n  a.link.deprecated, a.link.deprecated:visited {\n    text-decoration: line-through;\n    color: #666; }\n  a.link, a.link:visited {\n    color: #2B2D33;\n    padding: 4px 5px 4px 10px;\n    margin: 2px 0; }\n  a.link.active, a.link.active.deprecated, a.link.active:visited, a.link.active:visited.deprecated {\n    background-color: #5D99BD;\n    color: #fff; }\n  a.link:hover, a.link:hover.deprecated, a.link:hover:visited, a.link:hover:visited.deprecated {\n    background-color: #666;\n    color: #fff; }\n    a.link:hover.active, a.link:hover.deprecated.active, a.link:hover:visited.active, a.link:hover:visited.deprecated.active {\n      background-color: #5D99BD;\n      color: #fff; }\n\n.bcx-doc-main {\n  z-index: 1;\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 300px;\n  bottom: 0;\n  right: 0;\n  padding: 1rem;\n  transition: left ease 200ms;\n  overflow-x: hidden;\n  overflow-y: auto; }\n\n.bcx-overlay-spinner {\n  color: #30A1C1;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  color: #5D99BD; }\n\n.bcx-doc-demo {\n  display: flex;\n  flex-wrap: nowrap;\n  align-items: stretch; }\n  .bcx-doc-main > .bcx-doc-demo {\n    flex-direction: column;\n    position: absolute;\n    top: 2.4rem;\n    left: 0;\n    right: 0;\n    bottom: 0; }\n  compose > .bcx-doc-demo {\n    flex-direction: row;\n    box-shadow: 0 0 1rem #e8e8e8;\n    margin: 1rem -1rem; }\n  .bcx-doc-demo .demo-app {\n    margin: 1rem;\n    flex-grow: 0; }\n  .bcx-doc-demo .demo-code {\n    position: relative;\n    flex-grow: 1;\n    display: flex;\n    align-items: stretch;\n    flex-direction: column; }\n    .bcx-doc-demo .demo-code .bcx-select {\n      flex-grow: 0;\n      flex-shrink: 0; }\n    .bcx-doc-demo .demo-code display-source {\n      flex: 1 1 0;\n      position: relative; }\n\n.display-source {\n  display: block;\n  position: relative; }\n\nselect.bcx-select {\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  border-radius: 0;\n  border: 0;\n  color: #fff;\n  padding: .25rem .5rem .25rem 1.5rem;\n  font-size: .85rem;\n  background: #6d90a3 url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'%3E%3Cpath fill='white' d='M2 0L0 2h4zm0 5L0 3h4z'/%3E%3C/svg%3E\") no-repeat left 0.5rem center;\n  background-size: 8px 10px; }\n\n.bcx-open-menu {\n  display: block;\n  position: absolute;\n  z-index: 2;\n  top: 0;\n  left: 0;\n  max-width: 100%;\n  padding: .4rem .6rem .4rem .5rem;\n  color: #fff;\n  background-color: #5D99BD;\n  border-bottom-right-radius: .6rem;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  cursor: default; }\n  .bcx-open-menu .fa-bars {\n    margin-right: .25rem; }\n\n.text-muted {\n  color: #666; }\n\n@media screen and (min-width: 720px) {\n  .bcx-doc-main > .bcx-doc-demo .demo-app {\n    min-height: 100px; }\n  compose > .bcx-doc-demo .demo-app {\n    min-width: 300px; }\n  compose > .bcx-doc-demo .demo-code {\n    min-height: 300px; }\n  .CodeMirror-fullscreen {\n    left: 300px; }\n  .bcx-open-menu {\n    left: 300px;\n    max-width: calc(100% - 300px); }\n    .bcx-open-menu .fa-bars {\n      display: none; } }\n\n@media screen and (max-width: 1020px) {\n  compose > .bcx-doc-demo {\n    flex-direction: column; } }\n\n@media screen and (max-width: 720px) {\n  compose > .bcx-doc-demo .demo-code {\n    min-height: 200px; }\n  .bcx-doc-nav {\n    z-index: 4;\n    left: -300px; }\n    .bcx-doc-nav.menu-open {\n      left: 0;\n      box-shadow: 0 0 2rem rgba(0, 0, 0, 0.3); }\n      .bcx-doc-nav.menu-open .open-menu {\n        display: none; }\n    .bcx-doc-nav .close-menu {\n      display: block;\n      position: absolute;\n      z-index: 2;\n      top: 0;\n      right: 0;\n      font-size: 1.1rem;\n      padding: .4rem .5rem .4rem .6rem;\n      color: #666;\n      background-color: #e8e8e8;\n      border-bottom-left-radius: .6rem; }\n  .bcx-doc-nav-backdrop {\n    z-index: 3;\n    display: block;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background-color: rgba(102, 102, 102, 0.6); }\n  .bcx-doc-main {\n    left: 0; } }\n\n/*# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3MiLCJjc3MvZG9jLmNzcyIsImNzcy9fZmEtZm9udC5zY3NzIiwiLi4vLi4vZmE1L3Njc3MvZm9udGF3ZXNvbWUuc2NzcyIsIi4uLy4uL2ZhNS9zY3NzL19jb3JlLnNjc3MiLCIuLi8uLi9mYTUvc2Nzcy9fbGFyZ2VyLnNjc3MiLCIuLi8uLi9mYTUvc2Nzcy9fZml4ZWQtd2lkdGguc2NzcyIsIi4uLy4uL2ZhNS9zY3NzL19saXN0LnNjc3MiLCIuLi8uLi9mYTUvc2Nzcy9fdmFyaWFibGVzLnNjc3MiLCIuLi8uLi9mYTUvc2Nzcy9fYm9yZGVyZWQtcHVsbGVkLnNjc3MiLCIuLi8uLi9mYTUvc2Nzcy9fYW5pbWF0ZWQuc2NzcyIsIi4uLy4uL2ZhNS9zY3NzL19yb3RhdGVkLWZsaXBwZWQuc2NzcyIsIi4uLy4uL2ZhNS9zY3NzL19taXhpbnMuc2NzcyIsIi4uLy4uL2ZhNS9zY3NzL19zdGFja2VkLnNjc3MiLCIuLi8uLi9mYTUvc2Nzcy9faWNvbnMuc2NzcyIsIi4uLy4uL2ZhNS9zY3NzL19zY3JlZW4tcmVhZGVyLnNjc3MiLCJjc3MvX21hcmstZG93bi5zY3NzIiwiY3NzL19jb2xvcnMuc2NzcyIsImNzcy9kb2Muc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw0RUFBNEU7QUFFNUU7Z0ZBQ2dGO0FBRWhGOzs7R0FHRztBQUVIO0VBQ0Usa0JBQWlCO0VBQUUsT0FBTztFQUMxQiwrQkFBOEI7RUFBRSxPQUFPLEVBQ3hDOztBQUVEO2dGQUNnRjtBQUVoRjs7R0FFRztBQUVIO0VBQ0UsVUFBUyxFQUNWOztBQUVEOzs7R0FHRztBQUVIO0VBQ0UsZUFBYztFQUNkLGlCQUFnQixFQUNqQjs7QUFFRDtnRkFDZ0Y7QUFFaEY7OztHQUdHO0FBRUg7RUFDRSx3QkFBdUI7RUFBRSxPQUFPO0VBQ2hDLFVBQVM7RUFBRSxPQUFPO0VBQ2xCLGtCQUFpQjtFQUFFLE9BQU8sRUFDM0I7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QUFDNUY7RUFBcUMsaUJOUUEsRU1SeUM7O0FBQzlFO0VBQXlDLGlCTk9KLEVNUGlEOztBQUN0RjtFQUF5QyxpQk5NSixFTU5pRDs7QUFDdEY7RUFBbUMsaUJOS0UsRU1McUM7O0FBQzFFO0VBQWdDLGlCTklLLEVNSitCOztBQUNwRTtFQUFxQyxpQk5HQSxFTUh5Qzs7QUFDOUU7RUFBMkMsaUJORU4sRU1GcUQ7O0FBQzFGO0VBQXdDLGlCTkNILEVNRCtDOztBQUNwRjtFQUFvQyxpQk5BQyxFTUF1Qzs7QUFDNUU7RUFBeUMsaUJOREosRU1DaUQ7O0FBQ3RGO0VBQTBDLGlCTkZMLEVNRW1EOztBQUN4RjtFQUF1QyxpQk5IRixFTUc2Qzs7QUFDbEY7RUFBd0MsaUJOSkgsRU1JK0M7O0FBQ3BGO0VBQXNDLGlCTkxELEVNSzJDOztBQUNoRjtFQUFtQyxpQk5ORSxFTU1xQzs7QUFDMUU7RUFBdUMsaUJOUEYsRU1PNkM7O0FBQ2xGO0VBQXNDLGlCTlJELEVNUTJDOztBQUNoRjtFQUFnRSxpQk5UM0IsRU1TK0Y7O0FBQ3BJO0VBQW1DLGlCTlZFLEVNVXFDOztBQUMxRTtFQUFtQyxpQk5YRSxFTVdxQzs7QUFDMUU7RUFBb0MsaUJOWkMsRU1ZdUM7O0FBQzVFO0VBQXNDLGlCTmJELEVNYTJDOztBQUNoRjtFQUE4QyxpQk5kVCxFTWMyRDs7QUFDaEc7RUFBOEMsaUJOZlQsRU1lMkQ7O0FBQ2hHO0VBQStDLGlCTmhCVixFTWdCNkQ7O0FBQ2xHO0VBQTRDLGlCTmpCUCxFTWlCdUQ7O0FBQzVGO0VBQXVDLGlCTmxCRixFTWtCNkM7O0FBQ2xGO0VBQXVDLGlCTm5CRixFTW1CNkM7O0FBQ2xGO0VBQXdDLGlCTnBCSCxFTW9CK0M7O0FBQ3BGO0VBQXFDLGlCTnJCQSxFTXFCeUM7O0FBQzlFO0VBQTBDLGlCTnRCTCxFTXNCbUQ7O0FBQ3hGO0VBQW9DLGlCTnZCQyxFTXVCdUM7O0FBQzVFO0VBQXNDLGlCTnhCRCxFTXdCMkM7O0FBQ2hGO0VBQTBDLGlCTnpCTCxFTXlCbUQ7O0FBQ3hGO0VBQWtDLGlCTjFCRyxFTTBCbUM7O0FBQ3hFO0VBQWtDLGlCTjNCRyxFTTJCbUM7O0FBQ3hFO0VBQXNDLGlCTjVCRCxFTTRCMkM7O0FBQ2hGO0VBQW9DLGlCTjdCQyxFTTZCdUM7O0FBQzVFO0VBQWtELGlCTjlCYixFTThCbUU7O0FBQ3hHO0VBQWtELGlCTi9CYixFTStCbUU7O0FBQ3hHO0VBQW1ELGlCTmhDZCxFTWdDcUU7O0FBQzFHO0VBQWdELGlCTmpDWCxFTWlDK0Q7O0FBQ3BHO0VBQTJDLGlCTmxDTixFTWtDcUQ7O0FBQzFGO0VBQWtELGlCTm5DYixFTW1DbUU7O0FBQ3hHO0VBQWdELGlCTnBDWCxFTW9DK0Q7O0FBQ3BHO0VBQWlELGlCTnJDWixFTXFDaUU7O0FBQ3RHO0VBQStDLGlCTnRDVixFTXNDNkQ7O0FBQ2xHO0VBQTJDLGlCTnZDTixFTXVDcUQ7O0FBQzFGO0VBQTRDLGlCTnhDUCxFTXdDdUQ7O0FBQzVGO0VBQWtELGlCTnpDYixFTXlDbUU7O0FBQ3hHO0VBQWtELGlCTjFDYixFTTBDbUU7O0FBQ3hHO0VBQW1ELGlCTjNDZCxFTTJDcUU7O0FBQzFHO0VBQWdELGlCTjVDWCxFTTRDK0Q7O0FBQ3BHO0VBQWdELGlCTjdDWCxFTTZDK0Q7O0FBQ3BHO0VBQThDLGlCTjlDVCxFTThDMkQ7O0FBQ2hHO0VBQStDLGlCTi9DVixFTStDNkQ7O0FBQ2xHO0VBQTZDLGlCTmhEUixFTWdEeUQ7O0FBQzlGO0VBQXlDLGlCTmpESixFTWlEaUQ7O0FBQ3RGO0VBQThDLGlCTmxEVCxFTWtEMkQ7O0FBQ2hHO0VBQThDLGlCTm5EVCxFTW1EMkQ7O0FBQ2hHO0VBQStDLGlCTnBEVixFTW9ENkQ7O0FBQ2xHO0VBQTRDLGlCTnJEUCxFTXFEdUQ7O0FBQzVGO0VBQXVDLGlCTnRERixFTXNENkM7O0FBQ2xGO0VBQThDLGlCTnZEVCxFTXVEMkQ7O0FBQ2hHO0VBQTRDLGlCTnhEUCxFTXdEdUQ7O0FBQzVGO0VBQTZDLGlCTnpEUixFTXlEeUQ7O0FBQzlGO0VBQTJDLGlCTjFETixFTTBEcUQ7O0FBQzFGO0VBQXVDLGlCTjNERixFTTJENkM7O0FBQ2xGO0VBQXdDLGlCTjVESCxFTTREK0M7O0FBQ3BGO0VBQThDLGlCTjdEVCxFTTZEMkQ7O0FBQ2hHO0VBQThDLGlCTjlEVCxFTThEMkQ7O0FBQ2hHO0VBQStDLGlCTi9EVixFTStENkQ7O0FBQ2xHO0VBQTRDLGlCTmhFUCxFTWdFdUQ7O0FBQzVGO0VBQTRDLGlCTmpFUCxFTWlFdUQ7O0FBQzVGO0VBQTBDLGlCTmxFTCxFTWtFbUQ7O0FBQ3hGO0VBQTJDLGlCTm5FTixFTW1FcUQ7O0FBQzFGO0VBQXlDLGlCTnBFSixFTW9FaUQ7O0FBQ3RGO0VBQXFDLGlCTnJFQSxFTXFFeUM7O0FBQzlFO0VBQW1DLGlCTnRFRSxFTXNFcUM7O0FBQzFFO0VBQXVDLGlCTnZFRixFTXVFNkM7O0FBQ2xGO0VBQXlDLGlCTnhFSixFTXdFaUQ7O0FBQ3RGO0VBQXlDLGlCTnpFSixFTXlFaUQ7O0FBQ3RGO0VBQXFDLGlCTjFFQSxFTTBFeUM7O0FBQzlFO0VBQXFDLGlCTjNFQSxFTTJFeUM7O0FBQzlFO0VBQXdELGlCTjVFbkIsRU00RStFOztBQUNwSDtFQUFxQyxpQk43RUEsRU02RXlDOztBQUM5RTtFQUF1QyxpQk45RUYsRU04RTZDOztBQUNsRjtFQUErQixpQk4vRU0sRU0rRTZCOztBQUNsRTtFQUFvQyxpQk5oRkMsRU1nRnVDOztBQUM1RTtFQUE4QyxpQk5qRlQsRU1pRjJEOztBQUNoRztFQUF5QyxpQk5sRkosRU1rRmlEOztBQUN0RjtFQUFvQyxpQk5uRkMsRU1tRnVDOztBQUM1RTtFQUFtQyxpQk5wRkUsRU1vRnFDOztBQUMxRTtFQUFnQyxpQk5yRkssRU1xRitCOztBQUNwRTtFQUFxQyxpQk50RkEsRU1zRnlDOztBQUM5RTtFQUFrQyxpQk52RkcsRU11Rm1DOztBQUN4RTtFQUF3QyxpQk54RkgsRU13RitDOztBQUNwRjtFQUEwQyxpQk56RkwsRU15Rm1EOztBQUN4RjtFQUFnQyxpQk4xRkssRU0wRitCOztBQUNwRTtFQUFxQyxpQk4zRkEsRU0yRnlDOztBQUM5RTtFQUFxQyxpQk41RkEsRU00RnlDOztBQUM5RTtFQUFvQyxpQk43RkMsRU02RnVDOztBQUM1RTtFQUF3QyxpQk45RkgsRU04RitDOztBQUNwRjtFQUF5QyxpQk4vRkosRU0rRmlEOztBQUN0RjtFQUF5QyxpQk5oR0osRU1nR2lEOztBQUN0RjtFQUFpQyxpQk5qR0ksRU1pR2lDOztBQUN0RTtFQUFxQyxpQk5sR0EsRU1rR3lDOztBQUM5RTtFQUEwQyxpQk5uR0wsRU1tR21EOztBQUN4RjtFQUE0QyxpQk5wR1AsRU1vR3VEOztBQUM1RjtFQUE0QyxpQk5yR1AsRU1xR3VEOztBQUM1RjtFQUFpQyxpQk50R0ksRU1zR2lDOztBQUN0RTtFQUF5QyxpQk52R0osRU11R2lEOztBQUN0RjtFQUEwQyxpQk54R0wsRU13R21EOztBQUN4RjtFQUF5QyxpQk56R0osRU15R2lEOztBQUN0RjtFQUF5QyxpQk4xR0osRU0wR2lEOztBQUN0RjtFQUE0QyxpQk4zR1AsRU0yR3VEOztBQUM1RjtFQUEwQyxpQk41R0wsRU00R21EOztBQUN4RjtFQUFtRCxpQk43R2QsRU02R3FFOztBQUMxRztFQUFnQyxpQk45R0ssRU04RytCOztBQUNwRTtFQUFpQyxpQk4vR0ksRU0rR2lDOztBQUN0RTtFQUFvQyxpQk5oSEMsRU1nSHVDOztBQUM1RTtFQUEyQyxpQk5qSE4sRU1pSHFEOztBQUMxRjtFQUFpQyxpQk5sSEksRU1rSGlDOztBQUN0RTtFQUF1QyxpQk5uSEYsRU1tSDZDOztBQUNsRjtFQUFvQyxpQk5wSEMsRU1vSHVDOztBQUM1RTtFQUFzQyxpQk5ySEQsRU1xSDJDOztBQUNoRjtFQUF1QyxpQk50SEYsRU1zSDZDOztBQUNsRjtFQUEwQyxpQk52SEwsRU11SG1EOztBQUN4RjtFQUFzQyxpQk54SEQsRU13SDJDOztBQUNoRjtFQUFvQyxpQk56SEMsRU15SHVDOztBQUM1RTtFQUFpQyxpQk4xSEksRU0wSGlDOztBQUN0RTtFQUFzQyxpQk4zSEQsRU0ySDJDOztBQUNoRjtFQUF1QyxpQk41SEYsRU00SDZDOztBQUNsRjtFQUFrQyxpQk43SEcsRU02SG1DOztBQUN4RTtFQUFvQyxpQk45SEMsRU04SHVDOztBQUM1RTtFQUFzQyxpQk4vSEQsRU0rSDJDOztBQUNoRjtFQUFzQyxpQk5oSUQsRU1nSTJDOztBQUNoRjtFQUF3QyxpQk5qSUgsRU1pSStDOztBQUNwRjtFQUFpQyxpQk5sSUksRU1rSWlDOztBQUN0RTtFQUFpQyxpQk5uSUksRU1tSWlDOztBQUN0RTtFQUFpQyxpQk5wSUksRU1vSWlDOztBQUN0RTtFQUFpQyxpQk5ySUksRU1xSWlDOztBQUN0RTtFQUFxQyxpQk50SUEsRU1zSXlDOztBQUM5RTtFQUF5QyxpQk52SUosRU11SWlEOztBQUN0RjtFQUF5QyxpQk54SUosRU13SWlEOztBQUN0RjtFQUFnQyxpQk56SUssRU15SStCOztBQUNwRTtFQUFzQyxpQk4xSUQsRU0wSTJDOztBQUNoRjtFQUFrQyxpQk4zSUcsRU0ySW1DOztBQUN4RTtFQUF5QyxpQk41SUosRU00SWlEOztBQUN0RjtFQUFvQyxpQk43SUMsRU02SXVDOztBQUM1RTtFQUFzQyxpQk45SUQsRU04STJDOztBQUNoRjtFQUE4QyxpQk4vSVQsRU0rSTJEOztBQUNoRztFQUFvQyxpQk5oSkMsRU1nSnVDOztBQUM1RTtFQUFnQyxpQk5qSkssRU1pSitCOztBQUNwRTtFQUFnQyxpQk5sSkssRU1rSitCOztBQUNwRTtFQUFxQyxpQk5uSkEsRU1tSnlDOztBQUM5RTtFQUFxQyxpQk5wSkEsRU1vSnlDOztBQUM5RTtFQUFxQyxpQk5ySkEsRU1xSnlDOztBQUM5RTtFQUFpQyxpQk50SkksRU1zSmlDOztBQUN0RTtFQUE2QyxpQk52SlIsRU11SnlEOztBQUM5RjtFQUFnQyxpQk54SkssRU13SitCOztBQUNwRTtFQUF1QyxpQk56SkYsRU15SjZDOztBQUNsRjtFQUF1QyxpQk4xSkYsRU0wSjZDOztBQUNsRjtFQUFxQyxpQk4zSkEsRU0ySnlDOztBQUM5RTtFQUF5QyxpQk41SkosRU00SmlEOztBQUN0RjtFQUEyQyxpQk43Sk4sRU02SnFEOztBQUMxRjtFQUEwQyxpQk45SkwsRU04Sm1EOztBQUN4RjtFQUFpRCxpQk4vSlosRU0rSmlFOztBQUN0RztFQUEyQyxpQk5oS04sRU1nS3FEOztBQUMxRjtFQUEwQyxpQk5qS0wsRU1pS21EOztBQUN4RjtFQUEyQyxpQk5sS04sRU1rS3FEOztBQUMxRjtFQUFtQyxpQk5uS0UsRU1tS3FDOztBQUMxRTtFQUF1QyxpQk5wS0YsRU1vSzZDOztBQUNsRjtFQUF5QyxpQk5yS0osRU1xS2lEOztBQUN0RjtFQUFxQyxpQk50S0EsRU1zS3lDOztBQUM5RTtFQUFnQyxpQk52S0ssRU11SytCOztBQUNwRTtFQUE4QyxpQk54S1QsRU13SzJEOztBQUNoRztFQUE4QyxpQk56S1QsRU15SzJEOztBQUNoRztFQUErQyxpQk4xS1YsRU0wSzZEOztBQUNsRztFQUE0QyxpQk4zS1AsRU0yS3VEOztBQUM1RjtFQUF1QyxpQk41S0YsRU00SzZDOztBQUNsRjtFQUF1QyxpQk43S0YsRU02SzZDOztBQUNsRjtFQUF3QyxpQk45S0gsRU04SytDOztBQUNwRjtFQUE4QyxpQk4vS1QsRU0rSzJEOztBQUNoRztFQUE4QyxpQk5oTFQsRU1nTDJEOztBQUNoRztFQUErQyxpQk5qTFYsRU1pTDZEOztBQUNsRztFQUE0QyxpQk5sTFAsRU1rTHVEOztBQUM1RjtFQUFxQyxpQk5uTEEsRU1tTHlDOztBQUM5RTtFQUE0QyxpQk5wTFAsRU1vTHVEOztBQUM1RjtFQUFzQyxpQk5yTEQsRU1xTDJDOztBQUNoRjtFQUEwQyxpQk50TEwsRU1zTG1EOztBQUN4RjtFQUFvQyxpQk52TEMsRU11THVDOztBQUM1RTtFQUF5QyxpQk54TEosRU13TGlEOztBQUN0RjtFQUEyQyxpQk56TE4sRU15THFEOztBQUMxRjtFQUF3QyxpQk4xTEgsRU0wTCtDOztBQUNwRjtFQUFtQyxpQk4zTEUsRU0yTHFDOztBQUMxRTtFQUEwQyxpQk41TEwsRU00TG1EOztBQUN4RjtFQUFzQyxpQk43TEQsRU02TDJDOztBQUNoRjtFQUFzQyxpQk45TEQsRU04TDJDOztBQUNoRjtFQUFvQyxpQk4vTEMsRU0rTHVDOztBQUM1RTtFQUF1QyxpQk5oTUYsRU1nTTZDOztBQUNsRjtFQUF3QyxpQk5qTUgsRU1pTStDOztBQUNwRjtFQUF1QyxpQk5sTUYsRU1rTTZDOztBQUNsRjtFQUFzQyxpQk5uTUQsRU1tTTJDOztBQUNoRjtFQUF1QyxpQk5wTUYsRU1vTTZDOztBQUNsRjtFQUFzQyxpQk5yTUQsRU1xTTJDOztBQUNoRjtFQUFrQyxpQk50TUcsRU1zTW1DOztBQUN4RTtFQUF5QyxpQk52TUosRU11TWlEOztBQUN0RjtFQUF5QyxpQk54TUosRU13TWlEOztBQUN0RjtFQUFrQyxpQk56TUcsRU15TW1DOztBQUN4RTtFQUF5QyxpQk4xTUosRU0wTWlEOztBQUN0RjtFQUE2QyxpQk4zTVIsRU0yTXlEOztBQUM5RjtFQUF3QyxpQk41TUgsRU00TStDOztBQUNwRjtFQUF3QyxpQk43TUgsRU02TStDOztBQUNwRjtFQUE0QyxpQk45TVAsRU04TXVEOztBQUM1RjtFQUF1QyxpQk4vTUYsRU0rTTZDOztBQUNsRjtFQUEyQyxpQk5oTk4sRU1nTnFEOztBQUMxRjtFQUF5QyxpQk5qTkosRU1pTmlEOztBQUN0RjtFQUE2QyxpQk5sTlIsRU1rTnlEOztBQUM5RjtFQUF1QyxpQk5uTkYsRU1tTjZDOztBQUNsRjtFQUEyQyxpQk5wTk4sRU1vTnFEOztBQUMxRjtFQUF3QyxpQk5yTkgsRU1xTitDOztBQUNwRjtFQUE0QyxpQk50TlAsRU1zTnVEOztBQUM1RjtFQUF1QyxpQk52TkYsRU11TjZDOztBQUNsRjtFQUEyQyxpQk54Tk4sRU13TnFEOztBQUMxRjtFQUFnRCxpQk56TlgsRU15TitEOztBQUNwRztFQUFnRCxpQk4xTlgsRU0wTitEOztBQUNwRztFQUFpRCxpQk4zTlosRU0yTmlFOztBQUN0RztFQUE4QyxpQk41TlQsRU00TjJEOztBQUNoRztFQUFnRCxpQk43TlgsRU02TitEOztBQUNwRztFQUFnRCxpQk45TlgsRU04TitEOztBQUNwRztFQUFpRCxpQk4vTlosRU0rTmlFOztBQUN0RztFQUE4QyxpQk5oT1QsRU1nTzJEOztBQUNoRztFQUF5QyxpQk5qT0osRU1pT2lEOztBQUN0RjtFQUF5QyxpQk5sT0osRU1rT2lEOztBQUN0RjtFQUEwQyxpQk5uT0wsRU1tT21EOztBQUN4RjtFQUFnRCxpQk5wT1gsRU1vTytEOztBQUNwRztFQUFnRCxpQk5yT1gsRU1xTytEOztBQUNwRztFQUFpRCxpQk50T1osRU1zT2lFOztBQUN0RztFQUE4QyxpQk52T1QsRU11TzJEOztBQUNoRztFQUF1QyxpQk54T0YsRU13TzZDOztBQUNsRjtFQUFrQyxpQk56T0csRU15T21DOztBQUN4RTtFQUFtQyxpQk4xT0UsRU0wT3FDOztBQUMxRTtFQUFtQyxpQk4zT0UsRU0yT3FDOztBQUMxRTtFQUF5QyxpQk41T0osRU00T2lEOztBQUN0RjtFQUFzQyxpQk43T0QsRU02TzJDOztBQUNoRjtFQUE0QyxpQk45T1AsRU04T3VEOztBQUM1RjtFQUEyQyxpQk4vT04sRU0rT3FEOztBQUMxRjtFQUFrQyxpQk5oUEcsRU1nUG1DOztBQUN4RTtFQUFrQyxpQk5qUEcsRU1pUG1DOztBQUN4RTtFQUE4QyxpQk5sUFQsRU1rUDJEOztBQUNoRztFQUFrQyxpQk5uUEcsRU1tUG1DOztBQUN4RTtFQUEyQyxpQk5wUE4sRU1vUHFEOztBQUMxRjtFQUErQyxpQk5yUFYsRU1xUDZEOztBQUNsRztFQUF5QyxpQk50UEosRU1zUGlEOztBQUN0RjtFQUE2QyxpQk52UFIsRU11UHlEOztBQUM5RjtFQUF1QyxpQk54UEYsRU13UDZDOztBQUNsRjtFQUF1QyxpQk56UEYsRU15UDZDOztBQUNsRjtFQUF5QyxpQk4xUEosRU0wUGlEOztBQUN0RjtFQUFpQyxpQk4zUEksRU0yUGlDOztBQUN0RTtFQUFpQyxpQk41UEksRU00UGlDOztBQUN0RTtFQUF3QyxpQk43UEgsRU02UCtDOztBQUNwRjtFQUF3QyxpQk45UEgsRU04UCtDOztBQUNwRjtFQUF1QyxpQk4vUEYsRU0rUDZDOztBQUNsRjtFQUFvQyxpQk5oUUMsRU1nUXVDOztBQUM1RTtFQUFxQyxpQk5qUUEsRU1pUXlDOztBQUM5RTtFQUFtQyxpQk5sUUUsRU1rUXFDOztBQUMxRTtFQUFnQyxpQk5uUUssRU1tUStCOztBQUNwRTtFQUFpQyxpQk5wUUksRU1vUWlDOztBQUN0RTtFQUFvQyxpQk5yUUMsRU1xUXVDOztBQUM1RTtFQUFvQyxpQk50UUMsRU1zUXVDOztBQUM1RTtFQUF3QyxpQk52UUgsRU11UStDOztBQUNwRjtFQUFxQyxpQk54UUEsRU13UXlDOztBQUM5RTtFQUFvQyxpQk56UUMsRU15UXVDOztBQUM1RTtFQUFxQyxpQk4xUUEsRU0wUXlDOztBQUM5RTtFQUF5QyxpQk4zUUosRU0yUWlEOztBQUN0RjtFQUEwQyxpQk41UUwsRU00UW1EOztBQUN4RjtFQUEyQyxpQk43UU4sRU02UXFEOztBQUMxRjtFQUFtQyxpQk45UUUsRU04UXFDOztBQUMxRTtFQUEwQyxpQk4vUUwsRU0rUW1EOztBQUN4RjtFQUE4QyxpQk5oUlQsRU1nUjJEOztBQUNoRztFQUFpQyxpQk5qUkksRU1pUmlDOztBQUN0RTtFQUFzQyxpQk5sUkQsRU1rUjJDOztBQUNoRjtFQUFtQyxpQk5uUkUsRU1tUnFDOztBQUMxRTtFQUE2QyxpQk5wUlIsRU1vUnlEOztBQUM5RjtFQUF3QyxpQk5yUkgsRU1xUitDOztBQUNwRjtFQUE4QyxpQk50UlQsRU1zUjJEOztBQUNoRztFQUE4QyxpQk52UlQsRU11UjJEOztBQUNoRztFQUFvQyxpQk54UkMsRU13UnVDOztBQUM1RTtFQUFpQyxpQk56UkksRU15UmlDOztBQUN0RTtFQUF1QyxpQk4xUkYsRU0wUjZDOztBQUNsRjtFQUFpQyxpQk4zUkksRU0yUmlDOztBQUN0RTtFQUFxQyxpQk41UkEsRU00UnlDOztBQUM5RTtFQUFpQyxpQk43UkksRU02UmlDOztBQUN0RTtFQUFrQyxpQk45UkcsRU04Um1DOztBQUN4RTtFQUFvQyxpQk4vUkMsRU0rUnVDOztBQUM1RTtFQUFnQyxpQk5oU0ssRU1nUytCOztBQUNwRTtFQUF1QyxpQk5qU0YsRU1pUzZDOztBQUNsRjtFQUFvQyxpQk5sU0MsRU1rU3VDOztBQUM1RTtFQUFxQyxpQk5uU0EsRU1tU3lDOztBQUM5RTtFQUFxQyxpQk5wU0EsRU1vU3lDOztBQUM5RTtFQUFpQyxpQk5yU0ksRU1xU2lDOztBQUN0RTtFQUFzQyxpQk50U0QsRU1zUzJDOztBQUNoRjtFQUFzQyxpQk52U0QsRU11UzJDOztBQUNoRjtFQUFvQyxpQk54U0MsRU13U3VDOztBQUM1RTtFQUFvQyxpQk56U0MsRU15U3VDOztBQUM1RTtFQUF3QyxpQk4xU0gsRU0wUytDOztBQUNwRjtFQUF1QyxpQk4zU0YsRU0yUzZDOztBQUNsRjtFQUFzQyxpQk41U0QsRU00UzJDOztBQUNoRjtFQUFvQyxpQk43U0MsRU02U3VDOztBQUM1RTtFQUFpQyxpQk45U0ksRU04U2lDOztBQUN0RTtFQUEwQyxpQk4vU0wsRU0rU21EOztBQUN4RjtFQUFvQyxpQk5oVEMsRU1nVHVDOztBQUM1RTtFQUFzQyxpQk5qVEQsRU1pVDJDOztBQUNoRjtFQUFnQyxpQk5sVEssRU1rVCtCOztBQUNwRTtFQUFtQyxpQk5uVEUsRU1tVHFDOztBQUMxRTtFQUFtQyxpQk5wVEUsRU1vVHFDOztBQUMxRTtFQUF3QyxpQk5yVEgsRU1xVCtDOztBQUNwRjtFQUFrQyxpQk50VEcsRU1zVG1DOztBQUN4RTtFQUF3QyxpQk52VEgsRU11VCtDOztBQUNwRjtFQUEwQyxpQk54VEwsRU13VG1EOztBQUN4RjtFQUE4QyxpQk56VFQsRU15VDJEOztBQUNoRztFQUFnRCxpQk4xVFgsRU0wVCtEOztBQUNwRztFQUF1QyxpQk4zVEYsRU0yVDZDOztBQUNsRjtFQUFxQyxpQk41VEEsRU00VHlDOztBQUM5RTtFQUEwQyxpQk43VEwsRU02VG1EOztBQUN4RjtFQUFxQyxpQk45VEEsRU04VHlDOztBQUM5RTtFQUE0QyxpQk4vVFAsRU0rVHVEOztBQUM1RjtFQUFvQyxpQk5oVUMsRU1nVXVDOztBQUM1RTtFQUFtQyxpQk5qVUUsRU1pVXFDOztBQUMxRTtFQUFxQyxpQk5sVUEsRU1rVXlDOztBQUM5RTtFQUFtQyxpQk5uVUUsRU1tVXFDOztBQUMxRTtFQUF1QyxpQk5wVUYsRU1vVTZDOztBQUNsRjtFQUFpQyxpQk5yVUksRU1xVWlDOztBQUN0RTtFQUFpQyxpQk50VUksRU1zVWlDOztBQUN0RTtFQUFrQyxpQk52VUcsRU11VW1DOztBQUN4RTtFQUFzQyxpQk54VUQsRU13VTJDOztBQUNoRjtFQUF1QyxpQk56VUYsRU15VTZDOztBQUNsRjtFQUEyQyxpQk4xVU4sRU0wVXFEOztBQUMxRjtFQUF1QyxpQk4zVUYsRU0yVTZDOztBQUNsRjtFQUEyQyxpQk41VU4sRU00VXFEOztBQUMxRjtFQUFrQyxpQk43VUcsRU02VW1DOztBQUN4RTtFQUFtQyxpQk45VUUsRU04VXFDOztBQUMxRTtFQUFxQyxpQk4vVUEsRU0rVXlDOztBQUM5RTtFQUEwQyxpQk5oVkwsRU1nVm1EOztBQUN4RjtFQUE0QyxpQk5qVlAsRU1pVnVEOztBQUM1RjtFQUFtQyxpQk5sVkUsRU1rVnFDOztBQUMxRTtFQUFtQyxpQk5uVkUsRU1tVnFDOztBQUMxRTtFQUFtQyxpQk5wVkUsRU1vVnFDOztBQUMxRTtFQUFxQyxpQk5yVkEsRU1xVnlDOztBQUM5RTtFQUFpQyxpQk50VkksRU1zVmlDOztBQUN0RTtFQUFzQyxpQk52VkQsRU11VjJDOztBQUNoRjtFQUFxQyxpQk54VkEsRU13VnlDOztBQUM5RTtFQUF5QyxpQk56VkosRU15VmlEOztBQUN0RjtFQUF3QyxpQk4xVkgsRU0wVitDOztBQUNwRjtFQUErQyxpQk4zVlYsRU0yVjZEOztBQUNsRztFQUErQyxpQk41VlYsRU00VjZEOztBQUNsRztFQUFpRCxpQk43VlosRU02VmlFOztBQUN0RztFQUFtQyxpQk45VkUsRU04VnFDOztBQUMxRTtFQUF1QyxpQk4vVkYsRU0rVjZDOztBQUNsRjtFQUEwQyxpQk5oV0wsRU1nV21EOztBQUN4RjtFQUE4QyxpQk5qV1QsRU1pVzJEOztBQUNoRztFQUF3QyxpQk5sV0gsRU1rVytDOztBQUNwRjtFQUF5QyxpQk5uV0osRU1tV2lEOztBQUN0RjtFQUEwQyxpQk5wV0wsRU1vV21EOztBQUN4RjtFQUE4QyxpQk5yV1QsRU1xVzJEOztBQUNoRztFQUFpRCxpQk50V1osRU1zV2lFOztBQUN0RztFQUFxRCxpQk52V2hCLEVNdVd5RTs7QUFDOUc7RUFBZ0MsaUJOeFdLLEVNd1crQjs7QUFDcEU7RUFBd0MsaUJOeldILEVNeVcrQzs7QUFDcEY7RUFBc0MsaUJOMVdELEVNMFcyQzs7QUFDaEY7RUFBcUMsaUJOM1dBLEVNMld5Qzs7QUFDOUU7RUFBdUMsaUJONVdGLEVNNFc2Qzs7QUFDbEY7RUFBK0MsaUJON1dWLEVNNlc2RDs7QUFDbEc7RUFBNEMsaUJOOVdQLEVNOFd1RDs7QUFDNUY7RUFBMEMsaUJOL1dMLEVNK1dtRDs7QUFDeEY7RUFBeUMsaUJOaFhKLEVNZ1hpRDs7QUFDdEY7RUFBZ0MsaUJOalhLLEVNaVgrQjs7QUFDcEU7RUFBbUMsaUJObFhFLEVNa1hxQzs7QUFDMUU7RUFBeUMsaUJOblhKLEVNbVhpRDs7QUFDdEY7RUFBd0MsaUJOcFhILEVNb1grQzs7QUFDcEY7RUFBaUMsaUJOclhJLEVNcVhpQzs7QUFDdEU7RUFBcUMsaUJOdFhBLEVNc1h5Qzs7QUFDOUU7RUFBeUMsaUJOdlhKLEVNdVhpRDs7QUFDdEY7RUFBdUMsaUJOeFhGLEVNd1g2Qzs7QUFDbEY7RUFBdUMsaUJOelhGLEVNeVg2Qzs7QUFDbEY7RUFBc0MsaUJOMVhELEVNMFgyQzs7QUFDaEY7RUFBc0MsaUJOM1hELEVNMlgyQzs7QUFDaEY7RUFBdUMsaUJONVhGLEVNNFg2Qzs7QUFDbEY7RUFBNkMsaUJON1hSLEVNNlh5RDs7QUFDOUY7RUFBdUMsaUJOOVhGLEVNOFg2Qzs7QUFDbEY7RUFBeUMsaUJOL1hKLEVNK1hpRDs7QUFDdEY7RUFBNkMsaUJOaFlSLEVNZ1l5RDs7QUFDOUY7RUFBdUMsaUJOallGLEVNaVk2Qzs7QUFDbEY7RUFBcUMsaUJObFlBLEVNa1l5Qzs7QUFDOUU7RUFBc0MsaUJObllELEVNbVkyQzs7QUFDaEY7RUFBNEMsaUJOcFlQLEVNb1l1RDs7QUFDNUY7RUFBdUMsaUJOcllGLEVNcVk2Qzs7QUFDbEY7RUFBdUMsaUJOdFlGLEVNc1k2Qzs7QUFDbEY7RUFBc0MsaUJOdllELEVNdVkyQzs7QUFDaEY7RUFBaUMsaUJOeFlJLEVNd1lpQzs7QUFDdEU7RUFBcUMsaUJOellBLEVNeVl5Qzs7QUFDOUU7RUFBbUMsaUJOMVlFLEVNMFlxQzs7QUFDMUU7RUFBaUMsaUJOM1lJLEVNMllpQzs7QUFDdEU7RUFBOEMsaUJONVlULEVNNFkyRDs7QUFDaEc7RUFBb0MsaUJON1lDLEVNNll1Qzs7QUFDNUU7RUFBc0MsaUJOOVlELEVNOFkyQzs7QUFDaEY7RUFBd0MsaUJOL1lILEVNK1krQzs7QUFDcEY7RUFBdUMsaUJOaFpGLEVNZ1o2Qzs7QUFDbEY7RUFBaUMsaUJOalpJLEVNaVppQzs7QUFDdEU7RUFBMkMsaUJObFpOLEVNa1pxRDs7QUFDMUY7RUFBa0MsaUJOblpHLEVNbVptQzs7QUFDeEU7RUFBbUMsaUJOcFpFLEVNb1pxQzs7QUFDMUU7RUFBc0MsaUJOclpELEVNcVoyQzs7QUFDaEY7RUFBZ0MsaUJOdFpLLEVNc1orQjs7QUFDcEU7RUFBbUMsaUJOdlpFLEVNdVpxQzs7QUFDMUU7RUFBd0MsaUJOeFpILEVNd1orQzs7QUFDcEY7RUFBaUMsaUJOelpJLEVNeVppQzs7QUFDdEU7RUFBeUMsaUJOMVpKLEVNMFppRDs7QUFDdEY7RUFBNkMsaUJOM1pSLEVNMlp5RDs7QUFDOUY7RUFBOEMsaUJONVpULEVNNFoyRDs7QUFDaEc7RUFBc0MsaUJON1pELEVNNloyQzs7QUFDaEY7RUFBeUMsaUJOOVpKLEVNOFppRDs7QUFDdEY7RUFBMEMsaUJOL1pMLEVNK1ptRDs7QUFDeEY7RUFBNEMsaUJOaGFQLEVNZ2F1RDs7QUFDNUY7RUFBcUMsaUJOamFBLEVNaWF5Qzs7QUFDOUU7RUFBeUMsaUJObGFKLEVNa2FpRDs7QUFDdEY7RUFBNkMsaUJObmFSLEVNbWF5RDs7QUFDOUY7RUFBcUMsaUJOcGFBLEVNb2F5Qzs7QUFDOUU7RUFBb0MsaUJOcmFDLEVNcWF1Qzs7QUFDNUU7RUFBdUMsaUJOdGFGLEVNc2E2Qzs7QUFDbEY7RUFBMkMsaUJOdmFOLEVNdWFxRDs7QUFDMUY7RUFBb0MsaUJOeGFDLEVNd2F1Qzs7QUFDNUU7RUFBa0MsaUJOemFHLEVNeWFtQzs7QUFDeEU7RUFBbUMsaUJOMWFFLEVNMGFxQzs7QUFDMUU7RUFBb0MsaUJOM2FDLEVNMmF1Qzs7QUFDNUU7RUFBa0MsaUJONWFHLEVNNGFtQzs7QUFDeEU7RUFBZ0MsaUJON2FLLEVNNmErQjs7QUFDcEU7RUFBdUMsaUJOOWFGLEVNOGE2Qzs7QUFDbEY7RUFBdUMsaUJOL2FGLEVNK2E2Qzs7QUFDbEY7RUFBK0IsaUJOaGJNLEVNZ2I2Qjs7QUFDbEU7RUFBc0MsaUJOamJELEVNaWIyQzs7QUFDaEY7RUFBaUMsaUJObGJJLEVNa2JpQzs7QUFDdEU7RUFBZ0MsaUJObmJLLEVNbWIrQjs7QUFDcEU7RUFBdUMsaUJOcGJGLEVNb2I2Qzs7QUFDbEY7RUFBbUMsaUJOcmJFLEVNcWJxQzs7QUFDMUU7RUFBdUMsaUJOdGJGLEVNc2I2Qzs7QUFDbEY7RUFBMEMsaUJOdmJMLEVNdWJtRDs7QUFDeEY7RUFBc0MsaUJOeGJELEVNd2IyQzs7QUFDaEY7RUFBbUMsaUJOemJFLEVNeWJxQzs7QUFDMUU7RUFBbUMsaUJOMWJFLEVNMGJxQzs7QUFDMUU7RUFBMEMsaUJOM2JMLEVNMmJtRDs7QUFDeEY7RUFBa0MsaUJONWJHLEVNNGJtQzs7QUFDeEU7RUFBb0MsaUJON2JDLEVNNmJ1Qzs7QUFDNUU7RUFBa0MsaUJOOWJHLEVNOGJtQzs7QUFDeEU7RUFBbUMsaUJOL2JFLEVNK2JxQzs7QUFDMUU7RUFBc0MsaUJOaGNELEVNZ2MyQzs7QUFDaEY7RUFBc0MsaUJOamNELEVNaWMyQzs7QUFDaEY7RUFBc0MsaUJObGNELEVNa2MyQzs7QUFDaEY7RUFBd0MsaUJObmNILEVNbWMrQzs7QUFDcEY7RUFBbUMsaUJOcGNFLEVNb2NxQzs7QUFDMUU7RUFBeUMsaUJOcmNKLEVNcWNpRDs7QUFDdEY7RUFBd0MsaUJOdGNILEVNc2MrQzs7QUFDcEY7RUFBd0MsaUJOdmNILEVNdWMrQzs7QUFDcEY7RUFBMEMsaUJOeGNMLEVNd2NtRDs7QUFDeEY7RUFBK0MsaUJOemNWLEVNeWM2RDs7QUFDbEc7RUFBMEMsaUJOMWNMLEVNMGNtRDs7QUFDeEY7RUFBMkMsaUJOM2NOLEVNMmNxRDs7QUFDMUY7RUFBcUMsaUJONWNBLEVNNGN5Qzs7QUFDOUU7RUFBaUMsaUJON2NJLEVNNmNpQzs7QUFDdEU7RUFBcUMsaUJOOWNBLEVNOGN5Qzs7QUFDOUU7RUFBa0MsaUJOL2NHLEVNK2NtQzs7QUFDeEU7RUFBaUMsaUJOaGRJLEVNZ2RpQzs7QUFDdEU7RUFBcUMsaUJOamRBLEVNaWR5Qzs7QUFDOUU7RUFBK0IsaUJObGRNLEVNa2Q2Qjs7QUFDbEU7RUFBK0IsaUJObmRNLEVNbWQ2Qjs7QUFDbEU7RUFBK0IsaUJOcGRNLEVNb2Q2Qjs7QUFDbEU7RUFBd0MsaUJOcmRILEVNcWQrQzs7QUFDcEY7RUFBK0MsaUJOdGRWLEVNc2Q2RDs7QUFDbEc7RUFBNkMsaUJOdmRSLEVNdWR5RDs7QUFDOUY7RUFBd0MsaUJOeGRILEVNd2QrQzs7QUFDcEY7RUFBdUMsaUJOemRGLEVNeWQ2Qzs7QUFDbEY7RUFBdUMsaUJOMWRGLEVNMGQ2Qzs7QUFDbEY7RUFBNEMsaUJOM2RQLEVNMmR1RDs7QUFDNUY7RUFBNEMsaUJONWRQLEVNNGR1RDs7QUFDNUY7RUFBNkMsaUJON2RSLEVNNmR5RDs7QUFDOUY7RUFBMEMsaUJOOWRMLEVNOGRtRDs7QUFDeEY7RUFBeUMsaUJOL2RKLEVNK2RpRDs7QUFDdEY7RUFBMkMsaUJOaGVOLEVNZ2VxRDs7QUFDMUY7RUFBc0MsaUJOamVELEVNaWUyQzs7QUFDaEY7RUFBMEMsaUJObGVMLEVNa2VtRDs7QUFDeEY7RUFBdUMsaUJObmVGLEVNbWU2Qzs7QUFDbEY7RUFBc0MsaUJOcGVELEVNb2UyQzs7QUFDaEY7RUFBb0MsaUJOcmVDLEVNcWV1Qzs7QUFDNUU7RUFBZ0MsaUJOdGVLLEVNc2UrQjs7QUFDcEU7RUFBb0MsaUJOdmVDLEVNdWV1Qzs7QUFDNUU7RUFBdUMsaUJOeGVGLEVNd2U2Qzs7QUFDbEY7RUFBa0MsaUJOemVHLEVNeWVtQzs7QUFDeEU7RUFBc0MsaUJOMWVELEVNMGUyQzs7QUFDaEY7RUFBb0MsaUJOM2VDLEVNMmV1Qzs7QUFDNUU7RUFBaUMsaUJONWVJLEVNNGVpQzs7QUFDdEU7RUFBMEMsaUJON2VMLEVNNmVtRDs7QUFDeEY7RUFBb0MsaUJOOWVDLEVNOGV1Qzs7QUFDNUU7RUFBd0MsaUJOL2VILEVNK2UrQzs7QUFDcEY7RUFBMEMsaUJOaGZMLEVNZ2ZtRDs7QUFDeEY7RUFBaUMsaUJOamZJLEVNaWZpQzs7QUFDdEU7RUFBa0MsaUJObGZHLEVNa2ZtQzs7QUFDeEU7RUFBcUMsaUJObmZBLEVNbWZ5Qzs7QUFDOUU7RUFBeUMsaUJOcGZKLEVNb2ZpRDs7QUFDdEY7RUFBNEMsaUJOcmZQLEVNcWZ1RDs7QUFDNUY7RUFBbUMsaUJOdGZFLEVNc2ZxQzs7QUFDMUU7RUFBc0MsaUJOdmZELEVNdWYyQzs7QUFDaEY7RUFBMEMsaUJOeGZMLEVNd2ZtRDs7QUFDeEY7RUFBMkMsaUJOemZOLEVNeWZxRDs7QUFDMUY7RUFBNEMsaUJOMWZQLEVNMGZ1RDs7QUFDNUY7RUFBa0MsaUJOM2ZHLEVNMmZtQzs7QUFDeEU7RUFBa0MsaUJONWZHLEVNNGZtQzs7QUFDeEU7RUFBb0MsaUJON2ZDLEVNNmZ1Qzs7QUFDNUU7RUFBcUMsaUJOOWZBLEVNOGZ5Qzs7QUFDOUU7RUFBcUMsaUJOL2ZBLEVNK2Z5Qzs7QUFDOUU7RUFBb0MsaUJOaGdCQyxFTWdnQnVDOztBQUM1RTtFQUF3QyxpQk5qZ0JILEVNaWdCK0M7O0FBQ3BGO0VBQWtDLGlCTmxnQkcsRU1rZ0JtQzs7QUFDeEU7RUFBbUMsaUJObmdCRSxFTW1nQnFDOztBQUMxRTtFQUFpQyxpQk5wZ0JJLEVNb2dCaUM7O0FBQ3RFO0VBQWtDLGlCTnJnQkcsRU1xZ0JtQzs7QUFDeEU7RUFBcUMsaUJOdGdCQSxFTXNnQnlDOztBQUM5RTtFQUFzQyxpQk52Z0JELEVNdWdCMkM7O0FBQ2hGO0VBQW1DLGlCTnhnQkUsRU13Z0JxQzs7QUFDMUU7RUFBcUMsaUJOemdCQSxFTXlnQnlDOztBQUM5RTtFQUF5QyxpQk4xZ0JKLEVNMGdCaUQ7O0FBQ3RGO0VBQWlDLGlCTjNnQkksRU0yZ0JpQzs7QUFDdEU7RUFBd0MsaUJONWdCSCxFTTRnQitDOztBQUNwRjtFQUF3QyxpQk43Z0JILEVNNmdCK0M7O0FBQ3BGO0VBQXNDLGlCTjlnQkQsRU04Z0IyQzs7QUFDaEY7RUFBOEMsaUJOL2dCVCxFTStnQjJEOztBQUNoRztFQUFzQyxpQk5oaEJELEVNZ2hCMkM7O0FBQ2hGO0VBQW9DLGlCTmpoQkMsRU1paEJ1Qzs7QUFDNUU7RUFBbUMsaUJObGhCRSxFTWtoQnFDOztBQUMxRTtFQUFtQyxpQk5uaEJFLEVNbWhCcUM7O0FBQzFFO0VBQXdDLGlCTnBoQkgsRU1vaEIrQzs7QUFDcEY7RUFBMkMsaUJOcmhCTixFTXFoQnFEOztBQUMxRjtFQUFvQyxpQk50aEJDLEVNc2hCdUM7O0FBQzVFO0VBQWtDLGlCTnZoQkcsRU11aEJtQzs7QUFDeEU7RUFBbUMsaUJOeGhCRSxFTXdoQnFDOztBQUMxRTtFQUErQixpQk56aEJNLEVNeWhCNkI7O0FBQ2xFO0VBQXNDLGlCTjFoQkQsRU0waEIyQzs7QUFDaEY7RUFBcUMsaUJOM2hCQSxFTTJoQnlDOztBQUM5RTtFQUFnQyxpQk41aEJLLEVNNGhCK0I7O0FBQ3BFO0VBQXFDLGlCTjdoQkEsRU02aEJ5Qzs7QUFDOUU7RUFBbUMsaUJOOWhCRSxFTThoQnFDOztBQUMxRTtFQUF3QyxpQk4vaEJILEVNK2hCK0M7O0FBQ3BGO0VBQTBDLGlCTmhpQkwsRU1naUJtRDs7QUFDeEY7RUFBbUMsaUJOamlCRSxFTWlpQnFDOztBQUMxRTtFQUFxQyxpQk5saUJBLEVNa2lCeUM7O0FBQzlFO0VBQW1DLGlCTm5pQkUsRU1taUJxQzs7QUFDMUU7RUFBb0MsaUJOcGlCQyxFTW9pQnVDOztBQUM1RTtFQUFtQyxpQk5yaUJFLEVNcWlCcUM7O0FBQzFFO0VBQTBDLGlCTnRpQkwsRU1zaUJtRDs7QUFDeEY7RUFBaUMsaUJOdmlCSSxFTXVpQmlDOztBQUN0RTtFQUFvQyxpQk54aUJDLEVNd2lCdUM7O0FBQzVFO0VBQWtDLGlCTnppQkcsRU15aUJtQzs7QUFDeEU7RUFBaUMsaUJOMWlCSSxFTTBpQmlDOztBQUN0RTtFQUF1QyxpQk4zaUJGLEVNMmlCNkM7O0FBQ2xGO0VBQTJDLGlCTjVpQk4sRU00aUJxRDs7QUFDMUY7RUFBcUMsaUJON2lCQSxFTTZpQnlDOztBQUM5RTtFQUF5QyxpQk45aUJKLEVNOGlCaUQ7O0FBQ3RGO0VBQXNDLGlCTi9pQkQsRU0raUIyQzs7QUFDaEY7RUFBc0MsaUJOaGpCRCxFTWdqQjJDOztBQUNoRjtFQUFpQyxpQk5qakJJLEVNaWpCaUM7O0FBQ3RFO0VBQWlDLGlCTmxqQkksRU1rakJpQzs7QUFDdEU7RUFBcUMsaUJObmpCQSxFTW1qQnlDOztBQUM5RTtFQUF3QyxpQk5wakJILEVNb2pCK0M7O0FBQ3BGO0VBQW1DLGlCTnJqQkUsRU1xakJxQzs7QUFDMUU7RUFBa0MsaUJOdGpCRyxFTXNqQm1DOztBQUN4RTtFQUFzQyxpQk52akJELEVNdWpCMkM7O0FBQ2hGO0VBQWlDLGlCTnhqQkksRU13akJpQzs7QUFDdEU7RUFBcUMsaUJOempCQSxFTXlqQnlDOztBQUM5RTtFQUFvQyxpQk4xakJDLEVNMGpCdUM7O0FBQzVFO0VBQW9DLGlCTjNqQkMsRU0yakJ1Qzs7QUFDNUU7RUFBMkMsaUJONWpCTixFTTRqQnFEOztBQUMxRjtFQUFpQyxpQk43akJJLEVNNmpCaUM7O0FBQ3RFO0VBQXFDLGlCTjlqQkEsRU04akJ5Qzs7QUFDOUU7RUFBc0MsaUJOL2pCRCxFTStqQjJDOztBQUNoRjtFQUEwQyxpQk5oa0JMLEVNZ2tCbUQ7O0FBQ3hGO0VBQWdELGlCTmprQlgsRU1pa0IrRDs7QUFDcEc7RUFBZ0QsaUJObGtCWCxFTWtrQitEOztBQUNwRztFQUFpRCxpQk5ua0JaLEVNbWtCaUU7O0FBQ3RHO0VBQThDLGlCTnBrQlQsRU1va0IyRDs7QUFDaEc7RUFBNEMsaUJOcmtCUCxFTXFrQnVEOztBQUM1RjtFQUE0QyxpQk50a0JQLEVNc2tCdUQ7O0FBQzVGO0VBQTZDLGlCTnZrQlIsRU11a0J5RDs7QUFDOUY7RUFBMEMsaUJOeGtCTCxFTXdrQm1EOztBQUN4RjtFQUF1QyxpQk56a0JGLEVNeWtCNkM7O0FBQ2xGO0VBQXFDLGlCTjFrQkEsRU0wa0J5Qzs7QUFDOUU7RUFBaUMsaUJOM2tCSSxFTTJrQmlDOztBQUN0RTtFQUFvQyxpQk41a0JDLEVNNGtCdUM7O0FBQzVFO0VBQWtDLGlCTjdrQkcsRU02a0JtQzs7QUFDeEU7RUFBbUMsaUJOOWtCRSxFTThrQnFDOztBQUMxRTtFQUFpQyxpQk4va0JJLEVNK2tCaUM7O0FBQ3RFO0VBQWdDLGlCTmhsQkssRU1nbEIrQjs7QUFDcEU7RUFBdUMsaUJOamxCRixFTWlsQjZDOztBQUNsRjtFQUEyQyxpQk5sbEJOLEVNa2xCcUQ7O0FBQzFGO0VBQW9DLGlCTm5sQkMsRU1tbEJ1Qzs7QUFDNUU7RUFBc0MsaUJOcGxCRCxFTW9sQjJDOztBQUNoRjtFQUFpQyxpQk5ybEJJLEVNcWxCaUM7O0FBQ3RFO0VBQXdDLGlCTnRsQkgsRU1zbEIrQzs7QUFDcEY7RUFBd0MsaUJOdmxCSCxFTXVsQitDOztBQUNwRjtFQUEwQyxpQk54bEJMLEVNd2xCbUQ7O0FBQ3hGO0VBQTBDLGlCTnpsQkwsRU15bEJtRDs7QUFDeEY7RUFBbUMsaUJOMWxCRSxFTTBsQnFDOztBQUMxRTtFQUFvQyxpQk4zbEJDLEVNMmxCdUM7O0FBQzVFO0VBQW1DLGlCTjVsQkUsRU00bEJxQzs7QUFDMUU7RUFBcUMsaUJON2xCQSxFTTZsQnlDOztBQUM5RTtFQUFtQyxpQk45bEJFLEVNOGxCcUM7O0FBQzFFO0VBQWtDLGlCTi9sQkcsRU0rbEJtQzs7QUFDeEU7RUFBbUMsaUJOaG1CRSxFTWdtQnFDOztBQUMxRTtFQUFnQyxpQk5qbUJLLEVNaW1CK0I7O0FBQ3BFO0VBQW9DLGlCTmxtQkMsRU1rbUJ1Qzs7QUFDNUU7RUFBc0MsaUJObm1CRCxFTW1tQjJDOztBQUNoRjtFQUF1QyxpQk5wbUJGLEVNb21CNkM7O0FBQ2xGO0VBQTJDLGlCTnJtQk4sRU1xbUJxRDs7QUFDMUY7RUFBNkMsaUJOdG1CUixFTXNtQnlEOztBQUM5RjtFQUFzQyxpQk52bUJELEVNdW1CMkM7O0FBQ2hGO0VBQWtDLGlCTnhtQkcsRU13bUJtQzs7QUFDeEU7RUFBeUMsaUJOem1CSixFTXltQmlEOztBQUN0RjtFQUEwQyxpQk4xbUJMLEVNMG1CbUQ7O0FBQ3hGO0VBQTBDLGlCTjNtQkwsRU0ybUJtRDs7QUFDeEY7RUFBeUMsaUJONW1CSixFTTRtQmlEOztBQUN0RjtFQUFnQyxpQk43bUJLLEVNNm1CK0I7O0FBQ3BFO0VBQXFDLGlCTjltQkEsRU04bUJ5Qzs7QUFDOUU7RUFBbUMsaUJOL21CRSxFTSttQnFDOztBQUMxRTtFQUFtQyxpQk5obkJFLEVNZ25CcUM7O0FBQzFFO0VBQXVDLGlCTmpuQkYsRU1pbkI2Qzs7QUFDbEY7RUFBMkMsaUJObG5CTixFTWtuQnFEOztBQUMxRjtFQUErQyxpQk5ubkJWLEVNbW5CNkQ7O0FBQ2xHO0VBQWlDLGlCTnBuQkksRU1vbkJpQzs7QUFDdEU7RUFBbUMsaUJOcm5CRSxFTXFuQnFDOztBQUMxRTtFQUF1QyxpQk50bkJGLEVNc25CNkM7O0FBQ2xGO0VBQTJDLGlCTnZuQk4sRU11bkJxRDs7QUFDMUY7RUFBaUMsaUJOeG5CSSxFTXduQmlDOztBQUN0RTtFQUF1QyxpQk56bkJGLEVNeW5CNkM7O0FBQ2xGO0VBQTBDLGlCTjFuQkwsRU0wbkJtRDs7QUFDeEY7RUFBa0MsaUJOM25CRyxFTTJuQm1DOztBQUN4RTtFQUFvQyxpQk41bkJDLEVNNG5CdUM7O0FBQzVFO0VBQW1DLGlCTjduQkUsRU02bkJxQzs7QUFDMUU7RUFBc0MsaUJOOW5CRCxFTThuQjJDOztBQUNoRjtFQUE0QyxpQk4vbkJQLEVNK25CdUQ7O0FBQzVGO0VBQWlDLGlCTmhvQkksRU1nb0JpQzs7QUFDdEU7RUFBb0MsaUJOam9CQyxFTWlvQnVDOztBQUM1RTtFQUEwQyxpQk5sb0JMLEVNa29CbUQ7O0FBQ3hGO0VBQWdDLGlCTm5vQkssRU1tb0IrQjs7QUFDcEU7RUFBZ0MsaUJOcG9CSyxFTW9vQitCOztBQUNwRTtFQUF3QyxpQk5yb0JILEVNcW9CK0M7O0FBQ3BGO0VBQXlDLGlCTnRvQkosRU1zb0JpRDs7QUFDdEY7RUFBMkMsaUJOdm9CTixFTXVvQnFEOztBQUMxRjtFQUFvQyxpQk54b0JDLEVNd29CdUM7O0FBQzVFO0VBQTBDLGlCTnpvQkwsRU15b0JtRDs7QUFDeEY7RUFBaUQsaUJOMW9CWixFTTBvQmlFOztBQUN0RztFQUFxQyxpQk4zb0JBLEVNMm9CeUM7O0FBQzlFO0VBQW1DLGlCTjVvQkUsRU00b0JxQzs7QUFDMUU7RUFBa0MsaUJON29CRyxFTTZvQm1DOztBQUN4RTtFQUEwQyxpQk45b0JMLEVNOG9CbUQ7O0FBQ3hGO0VBQWdDLGlCTi9vQkssRU0rb0IrQjs7QUFDcEU7RUFBb0MsaUJOaHBCQyxFTWdwQnVDOztBQUM1RTtFQUFrQyxpQk5qcEJHLEVNaXBCbUM7O0FBQ3hFO0VBQXNDLGlCTmxwQkQsRU1rcEIyQzs7QUFDaEY7RUFBd0MsaUJObnBCSCxFTW1wQitDOztBQUNwRjtFQUFtQyxpQk5wcEJFLEVNb3BCcUM7O0FBQzFFO0VBQW1DLGlCTnJwQkUsRU1xcEJxQzs7QUFDMUU7RUFBdUMsaUJOdHBCRixFTXNwQjZDOztBQUNsRjtFQUF3QyxpQk52cEJILEVNdXBCK0M7O0FBQ3BGO0VBQXNDLGlCTnhwQkQsRU13cEIyQzs7QUFDaEY7RUFBc0MsaUJOenBCRCxFTXlwQjJDOztBQUNoRjtFQUFrQyxpQk4xcEJHLEVNMHBCbUM7O0FBQ3hFO0VBQW9DLGlCTjNwQkMsRU0ycEJ1Qzs7QUFDNUU7RUFBa0MsaUJONXBCRyxFTTRwQm1DOztBQUN4RTtFQUF5QyxpQk43cEJKLEVNNnBCaUQ7O0FBQ3RGO0VBQWdDLGlCTjlwQkssRU04cEIrQjs7QUFDcEU7RUFBbUMsaUJOL3BCRSxFTStwQnFDOztBQUMxRTtFQUFnQyxpQk5ocUJLLEVNZ3FCK0I7O0FBQ3BFO0VBQW9DLGlCTmpxQkMsRU1pcUJ1Qzs7QUFDNUU7RUFBdUMsaUJObHFCRixFTWtxQjZDOztBQUNsRjtFQUFtQyxpQk5ucUJFLEVNbXFCcUM7O0FBQzFFO0VBQXVDLGlCTnBxQkYsRU1vcUI2Qzs7QUFDbEY7RUFBb0MsaUJOcnFCQyxFTXFxQnVDOztBQUM1RTtFQUFvQyxpQk50cUJDLEVNc3FCdUM7O0FBQzVFO0VBQXNDLGlCTnZxQkQsRU11cUIyQzs7QUFDaEY7RUFBd0MsaUJOeHFCSCxFTXdxQitDOztBQUNwRjtFQUE4QyxpQk56cUJULEVNeXFCMkQ7O0FBQ2hHO0VBQWtDLGlCTjFxQkcsRU0wcUJtQzs7QUFDeEU7RUFBd0MsaUJOM3FCSCxFTTJxQitDOztBQUNwRjtFQUF5QyxpQk41cUJKLEVNNHFCaUQ7O0FBQ3RGO0VBQXlDLGlCTjdxQkosRU02cUJpRDs7QUFDdEY7RUFBZ0MsaUJOOXFCSyxFTThxQitCOztBQUNwRTtFQUF1QyxpQk4vcUJGLEVNK3FCNkM7O0FBQ2xGO0VBQTJDLGlCTmhyQk4sRU1nckJxRDs7QUFDMUY7RUFBMEMsaUJOanJCTCxFTWlyQm1EOztBQUN4RjtFQUFrQyxpQk5sckJHLEVNa3JCbUM7O0FBQ3hFO0VBQXNDLGlCTm5yQkQsRU1tckIyQzs7QUFDaEY7RUFBd0MsaUJOcHJCSCxFTW9yQitDOztBQUNwRjtFQUE2QyxpQk5yckJSLEVNcXJCeUQ7O0FBQzlGO0VBQWtDLGlCTnRyQkcsRU1zckJtQzs7QUFDeEU7RUFBc0MsaUJOdnJCRCxFTXVyQjJDOztBQUNoRjtFQUFpQyxpQk54ckJJLEVNd3JCaUM7O0FBQ3RFO0VBQXdDLGlCTnpyQkgsRU15ckIrQzs7QUFDcEY7RUFBd0MsaUJOMXJCSCxFTTByQitDOztBQUNwRjtFQUFpQyxpQk4zckJJLEVNMnJCaUM7O0FBQ3RFO0VBQWlDLGlCTjVyQkksRU00ckJpQzs7QUFDdEU7RUFBd0MsaUJON3JCSCxFTTZyQitDOztBQUNwRjtFQUF5QyxpQk45ckJKLEVNOHJCaUQ7O0FBQ3RGO0VBQXlDLGlCTi9yQkosRU0rckJpRDs7QUFDdEY7RUFBd0MsaUJOaHNCSCxFTWdzQitDOztBQUNwRjtFQUFvQyxpQk5qc0JDLEVNaXNCdUM7O0FBQzVFO0VBQWdDLGlCTmxzQkssRU1rc0IrQjs7QUFDcEU7RUFBcUMsaUJObnNCQSxFTW1zQnlDOztBQUM5RTtFQUF1QyxpQk5wc0JGLEVNb3NCNkM7O0FBQ2xGO0VBQXNDLGlCTnJzQkQsRU1xc0IyQzs7QUFDaEY7RUFBZ0QsaUJOdHNCWCxFTXNzQitEOztBQUNwRztFQUFvRCxpQk52c0JmLEVNdXNCdUU7O0FBQzVHO0VBQWtDLGlCTnhzQkcsRU13c0JtQzs7QUFDeEU7RUFBdUMsaUJOenNCRixFTXlzQjZDOztBQUNsRjtFQUF5QyxpQk4xc0JKLEVNMHNCaUQ7O0FBQ3RGO0VBQW1DLGlCTjNzQkUsRU0yc0JxQzs7QUFDMUU7RUFBeUMsaUJONXNCSixFTTRzQmlEOztBQUN0RjtFQUFtQyxpQk43c0JFLEVNNnNCcUM7O0FBQzFFO0VBQStCLGlCTjlzQk0sRU04c0I2Qjs7QUFDbEU7RUFBbUMsaUJOL3NCRSxFTStzQnFDOztBQUMxRTtFQUFxQyxpQk5odEJBLEVNZ3RCeUM7O0FBQzlFO0VBQTRDLGlCTmp0QlAsRU1pdEJ1RDs7QUFDNUY7RUFBNEMsaUJObHRCUCxFTWt0QnVEOztBQUM1RjtFQUFzQyxpQk5udEJELEVNbXRCMkM7O0FBQ2hGO0VBQXNDLGlCTnB0QkQsRU1vdEIyQzs7QUFDaEY7RUFBa0MsaUJOcnRCRyxFTXF0Qm1DOztBQUN4RTtFQUF1QyxpQk50dEJGLEVNc3RCNkM7O0FBQ2xGO0VBQXdDLGlCTnZ0QkgsRU11dEIrQzs7QUFDcEY7RUFBb0MsaUJOeHRCQyxFTXd0QnVDOztBQUM1RTtFQUFtQyxpQk56dEJFLEVNeXRCcUM7O0FBQzFFO0VBQW9DLGlCTjF0QkMsRU0wdEJ1Qzs7QUFDNUU7RUFBa0MsaUJOM3RCRyxFTTJ0Qm1DOztBQUN4RTtFQUFrQyxpQk41dEJHLEVNNHRCbUM7O0FBQ3hFO0VBQWdELGlCTjd0QlgsRU02dEIrRDs7QUFDcEc7RUFBK0MsaUJOOXRCVixFTTh0QjZEOztBQUNsRztFQUEyQyxpQk4vdEJOLEVNK3RCcUQ7O0FBQzFGO0VBQW9DLGlCTmh1QkMsRU1ndUJ1Qzs7QUFDNUU7RUFBc0MsaUJOanVCRCxFTWl1QjJDOztBQUNoRjtFQUFtQyxpQk5sdUJFLEVNa3VCcUM7O0FBQzFFO0VBQXlDLGlCTm51QkosRU1tdUJpRDs7QUFDdEY7RUFBMEMsaUJOcHVCTCxFTW91Qm1EOztBQUN4RjtFQUFpQyxpQk5ydUJJLEVNcXVCaUM7O0FBQ3RFO0VBQXFDLGlCTnR1QkEsRU1zdUJ5Qzs7QUFDOUU7RUFBdUMsaUJOdnVCRixFTXV1QjZDOztBQUNsRjtFQUFvQyxpQk54dUJDLEVNd3VCdUM7O0FBQzVFO0VBQW1DLGlCTnp1QkUsRU15dUJxQzs7QUFDMUU7RUFBbUMsaUJOMXVCRSxFTTB1QnFDOztBQUMxRTtFQUFxQyxpQk4zdUJBLEVNMnVCeUM7O0FBQzlFO0VBQXlDLGlCTjV1QkosRU00dUJpRDs7QUFDdEY7RUFBdUMsaUJON3VCRixFTTZ1QjZDOztBQUNsRjtFQUFrQyxpQk45dUJHLEVNOHVCbUM7O0FBQ3hFO0VBQXNDLGlCTi91QkQsRU0rdUIyQzs7QUFDaEY7RUFBbUMsaUJOaHZCRSxFTWd2QnFDOztBQUMxRTtFQUFzQyxpQk5qdkJELEVNaXZCMkM7O0FBQ2hGO0VBQW9DLGlCTmx2QkMsRU1rdkJ1Qzs7QUFDNUU7RUFBd0MsaUJObnZCSCxFTW12QitDOztBQUNwRjtFQUFpQyxpQk5wdkJJLEVNb3ZCaUM7O0FBQ3RFO0VBQW1DLGlCTnJ2QkUsRU1xdkJxQzs7QUFDMUU7RUFBdUMsaUJOdHZCRixFTXN2QjZDOztBQUNsRjtFQUFvQyxpQk52dkJDLEVNdXZCdUM7O0FBQzVFO0VBQWdDLGlCTnh2QkssRU13dkIrQjs7QUFDcEU7RUFBdUMsaUJOenZCRixFTXl2QjZDOztBQUNsRjtFQUF1QyxpQk4xdkJGLEVNMHZCNkM7O0FBQ2xGO0VBQXVDLGlCTjN2QkYsRU0ydkI2Qzs7QUFDbEY7RUFBbUMsaUJONXZCRSxFTTR2QnFDOztBQUMxRTtFQUFpQyxpQk43dkJJLEVNNnZCaUM7O0FBQ3RFO0VBQWlDLGlCTjl2QkksRU04dkJpQzs7QUFDdEU7RUFBb0MsaUJOL3ZCQyxFTSt2QnVDOztBQUM1RTtFQUE2QyxpQk5od0JSLEVNZ3dCeUQ7O0FBQzlGO0VBQWdELGlCTmp3QlgsRU1pd0IrRDs7QUFDcEc7RUFBbUMsaUJObHdCRSxFTWt3QnFDOztBQUMxRTtFQUFtQyxpQk5ud0JFLEVNbXdCcUM7O0FBQzFFO0VBQXFDLGlCTnB3QkEsRU1vd0J5Qzs7QUFDOUU7RUFBbUMsaUJOcndCRSxFTXF3QnFDOztBQUMxRTtFQUF5QyxpQk50d0JKLEVNc3dCaUQ7O0FBQ3RGO0VBQXdDLGlCTnZ3QkgsRU11d0IrQzs7QUFDcEY7RUFBd0MsaUJOeHdCSCxFTXd3QitDOztBQUNwRjtFQUFxQyxpQk56d0JBLEVNeXdCeUM7O0FBQzlFO0VBQW1DLGlCTjF3QkUsRU0wd0JxQzs7QUFDMUU7RUFBbUMsaUJOM3dCRSxFTTJ3QnFDOztBQUMxRTtFQUF5QyxpQk41d0JKLEVNNHdCaUQ7O0FBQ3RGO0VBQWtDLGlCTjd3QkcsRU02d0JtQzs7QUFDeEU7RUFBc0MsaUJOOXdCRCxFTTh3QjJDOztBQUNoRjtFQUFzQyxpQk4vd0JELEVNK3dCMkM7O0FBQ2hGO0VBQTZDLGlCTmh4QlIsRU1neEJ5RDs7QUFDOUY7RUFBeUMsaUJOanhCSixFTWl4QmlEOztBQUN0RjtFQUF3QyxpQk5seEJILEVNa3hCK0M7O0FBQ3BGO0VBQW1DLGlCTm54QkUsRU1teEJxQzs7QUFDMUU7RUFBdUMsaUJOcHhCRixFTW94QjZDOztBQUNsRjtFQUF5QyxpQk5yeEJKLEVNcXhCaUQ7O0FBQ3RGO0VBQWlDLGlCTnR4QkksRU1zeEJpQzs7QUFDdEU7RUFBMEMsaUJOdnhCTCxFTXV4Qm1EOztBQUN4RjtFQUEyQyxpQk54eEJOLEVNd3hCcUQ7O0FBQzFGO0VBQXlDLGlCTnp4QkosRU15eEJpRDs7QUFDdEY7RUFBeUMsaUJOMXhCSixFTTB4QmlEOztBQUN0RjtFQUE0QyxpQk4zeEJQLEVNMnhCdUQ7O0FBQzVGO0VBQTBDLGlCTjV4QkwsRU00eEJtRDs7QUFDeEY7RUFBbUMsaUJON3hCRSxFTTZ4QnFDOztBQUMxRTtFQUF3QyxpQk45eEJILEVNOHhCK0M7O0FBQ3BGO0VBQW9DLGlCTi94QkMsRU0reEJ1Qzs7QUFDNUU7RUFBd0MsaUJOaHlCSCxFTWd5QitDOztBQUNwRjtFQUEwQyxpQk5qeUJMLEVNaXlCbUQ7O0FBQ3hGO0VBQXFDLGlCTmx5QkEsRU1reUJ5Qzs7QUFDOUU7RUFBeUMsaUJObnlCSixFTW15QmlEOztBQUN0RjtFQUFtQyxpQk5weUJFLEVNb3lCcUM7O0FBQzFFO0VBQXdDLGlCTnJ5QkgsRU1xeUIrQzs7QUFDcEY7RUFBb0MsaUJOdHlCQyxFTXN5QnVDOztBQUM1RTtFQUFvQyxpQk52eUJDLEVNdXlCdUM7O0FBQzVFO0VBQXFDLGlCTnh5QkEsRU13eUJ5Qzs7QUFDOUU7RUFBa0MsaUJOenlCRyxFTXl5Qm1DOztBQUN4RTtFQUFrQyxpQk4xeUJHLEVNMHlCbUM7O0FBQ3hFO0VBQXVDLGlCTjN5QkYsRU0yeUI2Qzs7QUFDbEY7RUFBc0MsaUJONXlCRCxFTTR5QjJDOztBQUNoRjtFQUE2QyxpQk43eUJSLEVNNnlCeUQ7O0FBQzlGO0VBQXNDLGlCTjl5QkQsRU04eUIyQzs7QUFDaEY7RUFBNkMsaUJOL3lCUixFTSt5QnlEOztBQUM5RjtFQUF1QyxpQk5oekJGLEVNZ3pCNkM7O0FBQ2xGO0VBQWtDLGlCTmp6QkcsRU1pekJtQzs7QUFDeEU7RUFBb0MsaUJObHpCQyxFTWt6QnVDOztBQUM1RTtFQUFxQyxpQk5uekJBLEVNbXpCeUM7O0FBQzlFO0VBQTJDLGlCTnB6Qk4sRU1vekJxRDs7QUFDMUY7RUFBNEMsaUJOcnpCUCxFTXF6QnVEOztBQUM1RjtFQUFzQyxpQk50ekJELEVNc3pCMkM7O0FBQ2hGO0VBQWlDLGlCTnZ6QkksRU11ekJpQzs7QUFDdEU7RUFBNEMsaUJOeHpCUCxFTXd6QnVEOztBQUM1RjtFQUEwQyxpQk56ekJMLEVNeXpCbUQ7O0FBQ3hGO0VBQTZDLGlCTjF6QlIsRU0wekJ5RDs7QUFDOUY7RUFBMkMsaUJOM3pCTixFTTJ6QnFEOztBQUMxRjtFQUFzQyxpQk41ekJELEVNNHpCMkM7O0FBQ2hGO0VBQThDLGlCTjd6QlQsRU02ekIyRDs7QUFDaEc7RUFBNEMsaUJOOXpCUCxFTTh6QnVEOztBQUM1RjtFQUFvQyxpQk4vekJDLEVNK3pCdUM7O0FBQzVFO0VBQXVDLGlCTmgwQkYsRU1nMEI2Qzs7QUFDbEY7RUFBMEMsaUJOajBCTCxFTWkwQm1EOztBQUN4RjtFQUFrQyxpQk5sMEJHLEVNazBCbUM7O0FBQ3hFO0VBQW9DLGlCTm4wQkMsRU1tMEJ1Qzs7QUFDNUU7RUFBb0MsaUJOcDBCQyxFTW8wQnVDOztBQUM1RTtFQUEwQyxpQk5yMEJMLEVNcTBCbUQ7O0FBQ3hGO0VBQW9DLGlCTnQwQkMsRU1zMEJ1Qzs7QUFDNUU7RUFBbUMsaUJOdjBCRSxFTXUwQnFDOztBQUMxRTtFQUF3QyxpQk54MEJILEVNdzBCK0M7O0FBQ3BGO0VBQTJDLGlCTnowQk4sRU15MEJxRDs7QUFDMUY7RUFBMkMsaUJOMTBCTixFTTAwQnFEOztBQUMxRjtFQUFpQyxpQk4zMEJJLEVNMjBCaUM7O0FBQ3RFO0VBQTZDLGlCTjUwQlIsRU00MEJ5RDs7QUFDOUY7RUFBc0MsaUJONzBCRCxFTTYwQjJDOztBQUNoRjtFQUF1QyxpQk45MEJGLEVNODBCNkM7O0FBQ2xGO0VBQWtDLGlCTi8wQkcsRU0rMEJtQzs7QUFDeEU7RUFBeUMsaUJOaDFCSixFTWcxQmlEOztBQUN0RjtFQUF5QyxpQk5qMUJKLEVNaTFCaUQ7O0FBQ3RGO0VBQTBDLGlCTmwxQkwsRU1rMUJtRDs7QUFDeEY7RUFBeUMsaUJObjFCSixFTW0xQmlEOztBQUN0RjtFQUF3QyxpQk5wMUJILEVNbzFCK0M7O0FBQ3BGO0VBQXlDLGlCTnIxQkosRU1xMUJpRDs7QUFDdEY7RUFBd0MsaUJOdDFCSCxFTXMxQitDOztBQUNwRjtFQUFpQyxpQk52MUJJLEVNdTFCaUM7O0FBQ3RFO0VBQXdDLGlCTngxQkgsRU13MUIrQzs7QUFDcEY7RUFBc0MsaUJOejFCRCxFTXkxQjJDOztBQUNoRjtFQUFtQyxpQk4xMUJFLEVNMDFCcUM7O0FBQzFFO0VBQXdDLGlCTjMxQkgsRU0yMUIrQzs7QUFDcEY7RUFBMEMsaUJONTFCTCxFTTQxQm1EOztBQUN4RjtFQUFtQyxpQk43MUJFLEVNNjFCcUM7O0FBQzFFO0VBQXFDLGlCTjkxQkEsRU04MUJ5Qzs7QUFDOUU7RUFBeUMsaUJOLzFCSixFTSsxQmlEOztBQUN0RjtFQUF3QyxpQk5oMkJILEVNZzJCK0M7O0FBQ3BGO0VBQStDLGlCTmoyQlYsRU1pMkI2RDs7QUFDbEc7RUFBc0MsaUJObDJCRCxFTWsyQjJDOztBQUNoRjtFQUFtQyxpQk5uMkJFLEVNbTJCcUM7O0FBQzFFO0VBQXFDLGlCTnAyQkEsRU1vMkJ5Qzs7QUFDOUU7RUFBZ0MsaUJOcjJCSyxFTXEyQitCOztBQUNwRTtFQUF3QyxpQk50MkJILEVNczJCK0M7O0FBQ3BGO0VBQXdDLGlCTnYyQkgsRU11MkIrQzs7QUFDcEY7RUFBbUMsaUJOeDJCRSxFTXcyQnFDOztBQUMxRTtFQUFpQyxpQk56MkJJLEVNeTJCaUM7O0FBQ3RFO0VBQXFDLGlCTjEyQkEsRU0wMkJ5Qzs7QUFDOUU7RUFBb0MsaUJOMzJCQyxFTTIyQnVDOztBQUM1RTtFQUFrQyxpQk41MkJHLEVNNDJCbUM7O0FBQ3hFO0VBQXlDLGlCTjcyQkosRU02MkJpRDs7QUFDdEY7RUFBbUMsaUJOOTJCRSxFTTgyQnFDOztBQUMxRTtFQUF1QyxpQk4vMkJGLEVNKzJCNkM7O0FBQ2xGO0VBQTJDLGlCTmgzQk4sRU1nM0JxRDs7QUFDMUY7RUFBK0MsaUJOajNCVixFTWkzQjZEOztBQUNsRztFQUEwQyxpQk5sM0JMLEVNazNCbUQ7O0FBQ3hGO0VBQW9DLGlCTm4zQkMsRU1tM0J1Qzs7QUFDNUU7RUFBdUMsaUJOcDNCRixFTW8zQjZDOztBQUNsRjtFQUEyQyxpQk5yM0JOLEVNcTNCcUQ7O0FBQzFGO0VBQWdDLGlCTnQzQkssRU1zM0IrQjs7QUFDcEU7RUFBaUMsaUJOdjNCSSxFTXUzQmlDOztBQUN0RTtFQUFrQyxpQk54M0JHLEVNdzNCbUM7O0FBQ3hFO0VBQWlDLGlCTnozQkksRU15M0JpQzs7QUFDdEU7RUFBcUMsaUJOMTNCQSxFTTAzQnlDOztBQUM5RTtFQUEyQyxpQk4zM0JOLEVNMjNCcUQ7O0FBQzFGO0VBQTBDLGlCTjUzQkwsRU00M0JtRDs7QUFDeEY7RUFBd0MsaUJONzNCSCxFTTYzQitDOztBQUNwRjtFQUFxQyxpQk45M0JBLEVNODNCeUM7O0FBQzlFO0VBQXdDLGlCTi8zQkgsRU0rM0IrQzs7QUFDcEY7RUFBdUMsaUJOaDRCRixFTWc0QjZDOztBQUNsRjtFQUErQixpQk5qNEJNLEVNaTRCNkI7O0FBQ2xFO0VBQXFDLGlCTmw0QkEsRU1rNEJ5Qzs7QUFDOUU7RUFBb0MsaUJObjRCQyxFTW00QnVDOztBQUM1RTtFQUFzQyxpQk5wNEJELEVNbzRCMkM7O0FBQ2hGO0VBQXdDLGlCTnI0QkgsRU1xNEIrQzs7QUFDcEY7RUFBOEMsaUJOdDRCVCxFTXM0QjJEOztBQUNoRztFQUE2QyxpQk52NEJSLEVNdTRCeUQ7O0FBQzlGO0VBQTZDLGlCTng0QlIsRU13NEJ5RDs7QUFDOUY7RUFBZ0QsaUJOejRCWCxFTXk0QitEOztBQUNwRztFQUF1RCxpQk4xNEJsQixFTTA0QjZFOztBQUNsSDtFQUF3QyxpQk4zNEJILEVNMjRCK0M7O0FBQ3BGO0VBQXNDLGlCTjU0QkQsRU00NEIyQzs7QUFDaEY7RUFBc0MsaUJONzRCRCxFTTY0QjJDOztBQUNoRjtFQUFtQyxpQk45NEJFLEVNODRCcUM7O0FBQzFFO0VBQXVDLGlCTi80QkYsRU0rNEI2Qzs7QUFDbEY7RUFBa0MsaUJOaDVCRyxFTWc1Qm1DOztBQUN4RTtFQUF5QyxpQk5qNUJKLEVNaTVCaUQ7O0FBQ3RGO0VBQTBDLGlCTmw1QkwsRU1rNUJtRDs7QUFDeEY7RUFBMEMsaUJObjVCTCxFTW01Qm1EOztBQUN4RjtFQUF5QyxpQk5wNUJKLEVNbzVCaUQ7O0FBQ3RGO0VBQWlDLGlCTnI1QkksRU1xNUJpQzs7QUFDdEU7RUFBdUMsaUJOdDVCRixFTXM1QjZDOztBQUNsRjtFQUFzQyxpQk52NUJELEVNdTVCMkM7O0FBQ2hGO0VBQXNDLGlCTng1QkQsRU13NUIyQzs7QUFDaEY7RUFBa0MsaUJOejVCRyxFTXk1Qm1DOztBQUN4RTtFQUF3QyxpQk4xNUJILEVNMDVCK0M7O0FBQ3BGO0VBQTRDLGlCTjM1QlAsRU0yNUJ1RDs7QUFDNUY7RUFBa0MsaUJONTVCRyxFTTQ1Qm1DOztBQUN4RTtFQUFzQyxpQk43NUJELEVNNjVCMkM7O0FBQ2hGO0VBQWlDLGlCTjk1QkksRU04NUJpQzs7QUFDdEU7RUFBcUMsaUJOLzVCQSxFTSs1QnlDOztBQUM5RTtFQUFtQyxpQk5oNkJFLEVNZzZCcUM7O0FBQzFFO0VBQXFDLGlCTmo2QkEsRU1pNkJ5Qzs7QUFDOUU7RUFBd0MsaUJObDZCSCxFTWs2QitDOztBQUNwRjtFQUFtQyxpQk5uNkJFLEVNbTZCcUM7O0FBQzFFO0VBQXVDLGlCTnA2QkYsRU1vNkI2Qzs7QUFDbEY7RUFBa0MsaUJOcjZCRyxFTXE2Qm1DOztBQUN4RTtFQUFnQyxpQk50NkJLLEVNczZCK0I7O0FBQ3BFO0VBQW1DLGlCTnY2QkUsRU11NkJxQzs7QUFDMUU7RUFBMEMsaUJOeDZCTCxFTXc2Qm1EOztBQUN4RjtFQUErQixpQk56NkJNLEVNeTZCNkI7O0FBQ2xFO0VBQXFDLGlCTjE2QkEsRU0wNkJ5Qzs7QUFDOUU7RUFBbUMsaUJOMzZCRSxFTTI2QnFDOztBQUMxRTtFQUFvQyxpQk41NkJDLEVNNDZCdUM7O0FBQzVFO0VBQTJDLGlCTjc2Qk4sRU02NkJxRDs7QUFDMUY7RUFBa0MsaUJOOTZCRyxFTTg2Qm1DOztBQUN4RTtFQUFpQyxpQk4vNkJJLEVNKzZCaUM7O0FBQ3RFO0VBQWtDLGlCTmg3QkcsRU1nN0JtQzs7QUFDeEU7RUFBcUMsaUJOajdCQSxFTWk3QnlDOztBQUM5RTtFQUFzQyxpQk5sN0JELEVNazdCMkM7O0FBQ2hGO0VBQWlDLGlCTm43QkksRU1tN0JpQzs7QUFDdEU7RUFBcUMsaUJOcDdCQSxFTW83QnlDOztBQUM5RTtFQUF3QyxpQk5yN0JILEVNcTdCK0M7O0FBQ3BGO0VBQTZDLGlCTnQ3QlIsRU1zN0J5RDs7QUFDOUY7RUFBdUMsaUJOdjdCRixFTXU3QjZDOztBQUNsRjtFQUFtQyxpQk54N0JFLEVNdzdCcUM7O0FBQzFFO0VBQW1DLGlCTno3QkUsRU15N0JxQzs7QUFDMUU7RUFBdUMsaUJOMTdCRixFTTA3QjZDOztBQUNsRjtFQUFvQyxpQk4zN0JDLEVNMjdCdUM7O0FBQzVFO0VBQW1DLGlCTjU3QkUsRU00N0JxQzs7QUFDMUU7RUFBZ0MsaUJONzdCSyxFTTY3QitCOztBQUNwRTtFQUF1QyxpQk45N0JGLEVNODdCNkM7O0FBQ2xGO0VBQXVDLGlCTi83QkYsRU0rN0I2Qzs7QUFDbEY7RUFBaUMsaUJOaDhCSSxFTWc4QmlDOztBQUN0RTtFQUFxQyxpQk5qOEJBLEVNaThCeUM7O0FBQzlFO0VBQXdDLGlCTmw4QkgsRU1rOEIrQzs7QUFDcEY7RUFBb0MsaUJObjhCQyxFTW04QnVDOztBQUM1RTtFQUFzQyxpQk5wOEJELEVNbzhCMkM7O0FBQ2hGO0VBQXdDLGlCTnI4QkgsRU1xOEIrQzs7QUFDcEY7RUFBdUMsaUJOdDhCRixFTXM4QjZDOztBQUNsRjtFQUFrQyxpQk52OEJHLEVNdThCbUM7O0FBQ3hFO0VBQXFDLGlCTng4QkEsRU13OEJ5Qzs7QUFDOUU7RUFBeUMsaUJOejhCSixFTXk4QmlEOztBQUN0RjtFQUEwQyxpQk4xOEJMLEVNMDhCbUQ7O0FBQ3hGO0VBQTBDLGlCTjM4QkwsRU0yOEJtRDs7QUFDeEY7RUFBcUMsaUJONThCQSxFTTQ4QnlDOztBQUM5RTtFQUF5QyxpQk43OEJKLEVNNjhCaUQ7O0FBQ3RGO0VBQW1DLGlCTjk4QkUsRU04OEJxQzs7QUFDMUU7RUFBa0MsaUJOLzhCRyxFTSs4Qm1DOztBQUN4RTtFQUF5QyxpQk5oOUJKLEVNZzlCaUQ7O0FBQ3RGO0VBQXVDLGlCTmo5QkYsRU1pOUI2Qzs7QUFDbEY7RUFBb0MsaUJObDlCQyxFTWs5QnVDOztBQUM1RTtFQUFtQyxpQk5uOUJFLEVNbTlCcUM7O0FBQzFFO0VBQTBDLGlCTnA5QkwsRU1vOUJtRDs7QUFDeEY7RUFBaUMsaUJOcjlCSSxFTXE5QmlDOztBQUN0RTtFQUFrQyxpQk50OUJHLEVNczlCbUM7O0FBQ3hFO0VBQWtDLGlCTnY5QkcsRU11OUJtQzs7QUFDeEU7RUFBa0MsaUJOeDlCRyxFTXc5Qm1DOztBQUN4RTtFQUFrQyxpQk56OUJHLEVNeTlCbUM7O0FBQ3hFO0VBQXlDLGlCTjE5QkosRU0wOUJpRDs7QUFDdEY7RUFBb0MsaUJOMzlCQyxFTTI5QnVDOztBQUM1RTtFQUFpQyxpQk41OUJJLEVNNDlCaUM7O0FBQ3RFO0VBQStCLGlCTjc5Qk0sRU02OUI2Qjs7QUFDbEU7RUFBZ0MsaUJOOTlCSyxFTTg5QitCOztBQUNwRTtFQUE0QyxpQk4vOUJQLEVNKzlCdUQ7O0FBQzVGO0VBQXdDLGlCTmgrQkgsRU1nK0IrQzs7QUFDcEY7RUFBd0MsaUJOaitCSCxFTWkrQitDOztBQUNwRjtFQUF1QyxpQk5sK0JGLEVNaytCNkM7O0FBQ2xGO0VBQXNDLGlCTm4rQkQsRU1tK0IyQzs7QUFDaEY7RUFBa0MsaUJOcCtCRyxFTW8rQm1DOztBQUN4RTtFQUFzQyxpQk5yK0JELEVNcStCMkM7O0FBQ2hGO0VBQTBDLGlCTnQrQkwsRU1zK0JtRDs7QUFDeEY7RUFBa0MsaUJOditCRyxFTXUrQm1DOztBQUN4RTtFQUFrQyxpQk54K0JHLEVNdytCbUM7O0FBQ3hFO0VBQW1DLGlCTnorQkUsRU15K0JxQzs7QUFDMUU7RUFBbUMsaUJOMStCRSxFTTArQnFDOztBQUMxRTtFQUFxQyxpQk4zK0JBLEVNMitCeUM7O0FBQzlFO0VBQTRDLGlCTjUrQlAsRU00K0J1RDs7QUFDNUY7RUFBdUMsaUJONytCRixFTTYrQjZDOztBQUNsRjtFQUFvQyxpQk45K0JDLEVNOCtCdUM7O0FBQzVFO0VBQWtDLGlCTi8rQkcsRU0rK0JtQzs7QUFDeEU7RUFBaUMsaUJOaC9CSSxFTWcvQmlDOztBQUN0RTtFQUF3QyxpQk5qL0JILEVNaS9CK0M7O0FBQ3BGO0VBQW1DLGlCTmwvQkUsRU1rL0JxQzs7QUFDMUU7RUFBdUMsaUJObi9CRixFTW0vQjZDOztBQUNsRjtFQUF5QyxpQk5wL0JKLEVNby9CaUQ7O0FBQ3RGO0VBQTRDLGlCTnIvQlAsRU1xL0J1RDs7QUFDNUY7RUFBNEMsaUJOdC9CUCxFTXMvQnVEOztBQUM1RjtFQUEyQyxpQk52L0JOLEVNdS9CcUQ7O0FBQzFGO0VBQW9DLGlCTngvQkMsRU13L0J1Qzs7QUFDNUU7RUFBcUMsaUJOei9CQSxFTXkvQnlDOztBQUM5RTtFQUFzQyxpQk4xL0JELEVNMC9CMkM7O0FBQ2hGO0VBQTZDLGlCTjMvQlIsRU0yL0J5RDs7QUFDOUY7RUFBdUMsaUJONS9CRixFTTQvQjZDOztBQUNsRjtFQUF1QyxpQk43L0JGLEVNNi9CNkM7O0FBQ2xGO0VBQW9DLGlC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LFlBMU9hLEVBMk9kO0VBRUQ7SUFDRSxZQTlPYTtJQStPYiw4QkFBcUMsRUFLdEM7SUFQRDtNQUtJLGNBQWEsRUFDZCxFQUFBOztBQUlMO0VBQ0U7SUFDRSx1QkFBc0IsRUFDdkIsRUFBQTs7QUFHSDtFQUNFO0lBRUksa0JBQWlCLEVBQ2xCO0VBR0g7SUFDRSxXQUFVO0lBQ1YsYUF0UWEsRUE2UmQ7SUF6QkQ7TUFLSSxRQUFPO01BQ1Asd0NENVFrQyxFQ2lSbkM7TUFYSDtRQVNNLGNBQWEsRUFDZDtJQVZMO01BY0ksZUFBYztNQUNkLG1CQUFrQjtNQUNsQixXQUFVO01BQ1YsT0FBTTtNQUNOLFNBQVE7TUFDUixrQkFBaUI7TUFDakIsaUNBQWdDO01BQ2hDLFlEL1JLO01DZ1NMLDBCRG5TYTtNQ29TYixpQ0FBZ0MsRUFDakM7RUFHSDtJQUNFLFdBQVU7SUFDVixlQUFjO0lBQ2QsZ0JBQWU7SUFDZixPQUFNO0lBQ04sUUFBTztJQUNQLFNBQVE7SUFDUixVQUFTO0lBQ1QsMkNBQTJDLEVBQzVDO0VBRUQ7SUFDRSxRQUFPLEVBQ1IsRUFBQSIsImZpbGUiOiJjc3MvZG9jLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBub3JtYWxpemUuY3NzIHY4LjAuMCB8IE1JVCBMaWNlbnNlIHwgZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MgKi9cblxuLyogRG9jdW1lbnRcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbi8qKlxuICogMS4gQ29ycmVjdCB0aGUgbGluZSBoZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxuICogMi4gUHJldmVudCBhZGp1c3RtZW50cyBvZiBmb250IHNpemUgYWZ0ZXIgb3JpZW50YXRpb24gY2hhbmdlcyBpbiBpT1MuXG4gKi9cblxuaHRtbCB7XG4gIGxpbmUtaGVpZ2h0OiAxLjE1OyAvKiAxICovXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMiAqL1xufVxuXG4vKiBTZWN0aW9uc1xuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLyoqXG4gKiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBhbGwgYnJvd3NlcnMuXG4gKi9cblxuYm9keSB7XG4gIG1hcmdpbjogMDtcbn1cblxuLyoqXG4gKiBDb3JyZWN0IHRoZSBmb250IHNpemUgYW5kIG1hcmdpbiBvbiBgaDFgIGVsZW1lbnRzIHdpdGhpbiBgc2VjdGlvbmAgYW5kXG4gKiBgYXJ0aWNsZWAgY29udGV4dHMgaW4gQ2hyb21lLCBGaXJlZm94LCBhbmQgU2FmYXJpLlxuICovXG5cbmgxIHtcbiAgZm9udC1zaXplOiAyZW07XG4gIG1hcmdpbjogMC42N2VtIDA7XG59XG5cbi8qIEdyb3VwaW5nIGNvbnRlbnRcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbi8qKlxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGJveCBzaXppbmcgaW4gRmlyZWZveC5cbiAqIDIuIFNob3cgdGhlIG92ZXJmbG93IGluIEVkZ2UgYW5kIElFLlxuICovXG5cbmhyIHtcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7IC8qIDEgKi9cbiAgaGVpZ2h0OiAwOyAvKiAxICovXG4gIG92ZXJmbG93OiB2aXNpYmxlOyAvKiAyICovXG59XG5cbi8qKlxuICogMS4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2UgYW5kIHNjYWxpbmcgb2YgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cbiAqIDIuIENvcnJlY3QgdGhlIG9kZCBgZW1gIGZvbnQgc2l6aW5nIGluIGFsbCBicm93c2Vycy5cbiAqL1xuXG5wcmUge1xuICBmb250LWZhbWlseTogbW9ub3NwYWNlLCBtb25vc3BhY2U7IC8qIDEgKi9cbiAgZm9udC1zaXplOiAxZW07IC8qIDIgKi9cbn1cblxuLyogVGV4dC1sZXZlbCBzZW1hbnRpY3NcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbi8qKlxuICogUmVtb3ZlIHRoZSBncmF5IGJhY2tncm91bmQgb24gYWN0aXZlIGxpbmtzIGluIElFIDEwLlxuICovXG5cbmEge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cblxuLyoqXG4gKiAxLiBSZW1vdmUgdGhlIGJvdHRvbSBib3JkZXIgaW4gQ2hyb21lIDU3LVxuICogMi4gQWRkIHRoZSBjb3JyZWN0IHRleHQgZGVjb3JhdGlvbiBpbiBDaHJvbWUsIEVkZ2UsIElFLCBPcGVyYSwgYW5kIFNhZmFyaS5cbiAqL1xuXG5hYmJyW3RpdGxlXSB7XG4gIGJvcmRlci1ib3R0b206IG5vbmU7IC8qIDEgKi9cbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7IC8qIDIgKi9cbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkOyAvKiAyICovXG59XG5cbi8qKlxuICogQWRkIHRoZSBjb3JyZWN0IGZvbnQgd2VpZ2h0IGluIENocm9tZSwgRWRnZSwgYW5kIFNhZmFyaS5cbiAqL1xuXG5iLFxuc3Ryb25nIHtcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcbn1cblxuLyoqXG4gKiAxLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBhbmQgc2NhbGluZyBvZiBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxuICogMi4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxuICovXG5cbmNvZGUsXG5rYmQsXG5zYW1wIHtcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZSwgbW9ub3NwYWNlOyAvKiAxICovXG4gIGZvbnQtc2l6ZTogMWVtOyAvKiAyICovXG59XG5cbi8qKlxuICogQWRkIHRoZSBjb3JyZWN0IGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXG4gKi9cblxuc21hbGwge1xuICBmb250LXNpemU6IDgwJTtcbn1cblxuLyoqXG4gKiBQcmV2ZW50IGBzdWJgIGFuZCBgc3VwYCBlbGVtZW50cyBmcm9tIGFmZmVjdGluZyB0aGUgbGluZSBoZWlnaHQgaW5cbiAqIGFsbCBicm93c2Vycy5cbiAqL1xuXG5zdWIsXG5zdXAge1xuICBmb250LXNpemU6IDc1JTtcbiAgbGluZS1oZWlnaHQ6IDA7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xufVxuXG5zdWIge1xuICBib3R0b206IC0wLjI1ZW07XG59XG5cbnN1cCB7XG4gIHRvcDogLTAuNWVtO1xufVxuXG4vKiBFbWJlZGRlZCBjb250ZW50XG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgYm9yZGVyIG9uIGltYWdlcyBpbnNpZGUgbGlua3MgaW4gSUUgMTAuXG4gKi9cblxuaW1nIHtcbiAgYm9yZGVyLXN0eWxlOiBub25lO1xufVxuXG4vKiBGb3Jtc1xuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLyoqXG4gKiAxLiBDaGFuZ2UgdGhlIGZvbnQgc3R5bGVzIGluIGFsbCBicm93c2Vycy5cbiAqIDIuIFJlbW92ZSB0aGUgbWFyZ2luIGluIEZpcmVmb3ggYW5kIFNhZmFyaS5cbiAqL1xuXG5idXR0b24sXG5pbnB1dCxcbm9wdGdyb3VwLFxuc2VsZWN0LFxudGV4dGFyZWEge1xuICBmb250LWZhbWlseTogaW5oZXJpdDsgLyogMSAqL1xuICBmb250LXNpemU6IDEwMCU7IC8qIDEgKi9cbiAgbGluZS1oZWlnaHQ6IDEuMTU7IC8qIDEgKi9cbiAgbWFyZ2luOiAwOyAvKiAyICovXG59XG5cbi8qKlxuICogU2hvdyB0aGUgb3ZlcmZsb3cgaW4gSUUuXG4gKiAxLiBTaG93IHRoZSBvdmVyZmxvdyBpbiBFZGdlLlxuICovXG5cbmJ1dHRvbixcbmlucHV0IHsgLyogMSAqL1xuICBvdmVyZmxvdzogdmlzaWJsZTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEVkZ2UsIEZpcmVmb3gsIGFuZCBJRS5cbiAqIDEuIFJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRmlyZWZveC5cbiAqL1xuXG5idXR0b24sXG5zZWxlY3QgeyAvKiAxICovXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xufVxuXG4vKipcbiAqIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXG4gKi9cblxuYnV0dG9uLFxuW3R5cGU9XCJidXR0b25cIl0sXG5bdHlwZT1cInJlc2V0XCJdLFxuW3R5cGU9XCJzdWJtaXRcIl0ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGlubmVyIGJvcmRlciBhbmQgcGFkZGluZyBpbiBGaXJlZm94LlxuICovXG5cbmJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcblt0eXBlPVwiYnV0dG9uXCJdOjotbW96LWZvY3VzLWlubmVyLFxuW3R5cGU9XCJyZXNldFwiXTo6LW1vei1mb2N1cy1pbm5lcixcblt0eXBlPVwic3VibWl0XCJdOjotbW96LWZvY3VzLWlubmVyIHtcbiAgYm9yZGVyLXN0eWxlOiBub25lO1xuICBwYWRkaW5nOiAwO1xufVxuXG4vKipcbiAqIFJlc3RvcmUgdGhlIGZvY3VzIHN0eWxlcyB1bnNldCBieSB0aGUgcHJldmlvdXMgcnVsZS5cbiAqL1xuXG5idXR0b246LW1vei1mb2N1c3JpbmcsXG5bdHlwZT1cImJ1dHRvblwiXTotbW96LWZvY3VzcmluZyxcblt0eXBlPVwicmVzZXRcIl06LW1vei1mb2N1c3JpbmcsXG5bdHlwZT1cInN1Ym1pdFwiXTotbW96LWZvY3VzcmluZyB7XG4gIG91dGxpbmU6IDFweCBkb3R0ZWQgQnV0dG9uVGV4dDtcbn1cblxuLyoqXG4gKiBDb3JyZWN0IHRoZSBwYWRkaW5nIGluIEZpcmVmb3guXG4gKi9cblxuZmllbGRzZXQge1xuICBwYWRkaW5nOiAwLjM1ZW0gMC43NWVtIDAuNjI1ZW07XG59XG5cbi8qKlxuICogMS4gQ29ycmVjdCB0aGUgdGV4dCB3cmFwcGluZyBpbiBFZGdlIGFuZCBJRS5cbiAqIDIuIENvcnJlY3QgdGhlIGNvbG9yIGluaGVyaXRhbmNlIGZyb20gYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBJRS5cbiAqIDMuIFJlbW92ZSB0aGUgcGFkZGluZyBzbyBkZXZlbG9wZXJzIGFyZSBub3QgY2F1Z2h0IG91dCB3aGVuIHRoZXkgemVybyBvdXRcbiAqICAgIGBmaWVsZHNldGAgZWxlbWVudHMgaW4gYWxsIGJyb3dzZXJzLlxuICovXG5cbmxlZ2VuZCB7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cbiAgY29sb3I6IGluaGVyaXQ7IC8qIDIgKi9cbiAgZGlzcGxheTogdGFibGU7IC8qIDEgKi9cbiAgbWF4LXdpZHRoOiAxMDAlOyAvKiAxICovXG4gIHBhZGRpbmc6IDA7IC8qIDMgKi9cbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDsgLyogMSAqL1xufVxuXG4vKipcbiAqIEFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lLCBGaXJlZm94LCBhbmQgT3BlcmEuXG4gKi9cblxucHJvZ3Jlc3Mge1xuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XG59XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBkZWZhdWx0IHZlcnRpY2FsIHNjcm9sbGJhciBpbiBJRSAxMCsuXG4gKi9cblxudGV4dGFyZWEge1xuICBvdmVyZmxvdzogYXV0bztcbn1cblxuLyoqXG4gKiAxLiBBZGQgdGhlIGNvcnJlY3QgYm94IHNpemluZyBpbiBJRSAxMC5cbiAqIDIuIFJlbW92ZSB0aGUgcGFkZGluZyBpbiBJRSAxMC5cbiAqL1xuXG5bdHlwZT1cImNoZWNrYm94XCJdLFxuW3R5cGU9XCJyYWRpb1wiXSB7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cbiAgcGFkZGluZzogMDsgLyogMiAqL1xufVxuXG4vKipcbiAqIENvcnJlY3QgdGhlIGN1cnNvciBzdHlsZSBvZiBpbmNyZW1lbnQgYW5kIGRlY3JlbWVudCBidXR0b25zIGluIENocm9tZS5cbiAqL1xuXG5bdHlwZT1cIm51bWJlclwiXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcblt0eXBlPVwibnVtYmVyXCJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcbiAgaGVpZ2h0OiBhdXRvO1xufVxuXG4vKipcbiAqIDEuIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLlxuICogMi4gQ29ycmVjdCB0aGUgb3V0bGluZSBzdHlsZSBpbiBTYWZhcmkuXG4gKi9cblxuW3R5cGU9XCJzZWFyY2hcIl0ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDsgLyogMSAqL1xuICBvdXRsaW5lLW9mZnNldDogLTJweDsgLyogMiAqL1xufVxuXG4vKipcbiAqIFJlbW92ZSB0aGUgaW5uZXIgcGFkZGluZyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cbiAqL1xuXG5bdHlwZT1cInNlYXJjaFwiXTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbn1cblxuLyoqXG4gKiAxLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxuICogMi4gQ2hhbmdlIGZvbnQgcHJvcGVydGllcyB0byBgaW5oZXJpdGAgaW4gU2FmYXJpLlxuICovXG5cbjo6LXdlYmtpdC1maWxlLXVwbG9hZC1idXR0b24ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xuICBmb250OiBpbmhlcml0OyAvKiAyICovXG59XG5cbi8qIEludGVyYWN0aXZlXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4vKlxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gRWRnZSwgSUUgMTArLCBhbmQgRmlyZWZveC5cbiAqL1xuXG5kZXRhaWxzIHtcbiAgZGlzcGxheTogYmxvY2s7XG59XG5cbi8qXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBhbGwgYnJvd3NlcnMuXG4gKi9cblxuc3VtbWFyeSB7XG4gIGRpc3BsYXk6IGxpc3QtaXRlbTtcbn1cblxuLyogTWlzY1xuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLyoqXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSAxMCsuXG4gKi9cblxudGVtcGxhdGUge1xuICBkaXNwbGF5OiBub25lO1xufVxuXG4vKipcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFIDEwLlxuICovXG5cbltoaWRkZW5dIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cbiIsIi8qISBub3JtYWxpemUuY3NzIHY4LjAuMCB8IE1JVCBMaWNlbnNlIHwgZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MgKi9cbi8qIERvY3VtZW50XG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuLyoqXG4gKiAxLiBDb3JyZWN0IHRoZSBsaW5lIGhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXG4gKiAyLiBQcmV2ZW50IGFkanVzdG1lbnRzIG9mIGZvbnQgc2l6ZSBhZnRlciBvcmllbnRhdGlvbiBjaGFuZ2VzIGluIGlPUy5cbiAqL1xuaHRtbCB7XG4gIGxpbmUtaGVpZ2h0OiAxLjE1O1xuICAvKiAxICovXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTtcbiAgLyogMiAqLyB9XG5cbi8qIFNlY3Rpb25zXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuLyoqXG4gKiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBhbGwgYnJvd3NlcnMuXG4gKi9cbmJvZHkge1xuICBtYXJnaW46IDA7IH1cblxuLyoqXG4gKiBDb3JyZWN0IHRoZSBmb250IHNpemUgYW5kIG1hcmdpbiBvbiBgaDFgIGVsZW1lbnRzIHdpdGhpbiBgc2VjdGlvbmAgYW5kXG4gKiBgYXJ0aWNsZWAgY29udGV4dHMgaW4gQ2hyb21lLCBGaXJlZm94LCBhbmQgU2FmYXJpLlxuICovXG5oMSB7XG4gIGZvbnQtc2l6ZTogMmVtO1xuICBtYXJnaW46IDAuNjdlbSAwOyB9XG5cbi8qIEdyb3VwaW5nIGNvbnRlbnRcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBib3ggc2l6aW5nIGluIEZpcmVmb3guXG4gKiAyLiBTaG93IHRoZSBvdmVyZmxvdyBpbiBFZGdlIGFuZCBJRS5cbiAqL1xuaHIge1xuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcbiAgLyogMSAqL1xuICBoZWlnaHQ6IDA7XG4gIC8qIDEgKi9cbiAgb3ZlcmZsb3c6IHZpc2libGU7XG4gIC8qIDIgKi8gfVxuXG4vKipcbiAqIDEuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIGFuZCBzY2FsaW5nIG9mIGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXG4gKiAyLiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXG4gKi9cbnByZSB7XG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2UsIG1vbm9zcGFjZTtcbiAgLyogMSAqL1xuICBmb250LXNpemU6IDFlbTtcbiAgLyogMiAqLyB9XG5cbi8qIFRleHQtbGV2ZWwgc2VtYW50aWNzXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuLyoqXG4gKiBSZW1vdmUgdGhlIGdyYXkgYmFja2dyb3VuZCBvbiBhY3RpdmUgbGlua3MgaW4gSUUgMTAuXG4gKi9cbmEge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxuXG4vKipcbiAqIDEuIFJlbW92ZSB0aGUgYm90dG9tIGJvcmRlciBpbiBDaHJvbWUgNTctXG4gKiAyLiBBZGQgdGhlIGNvcnJlY3QgdGV4dCBkZWNvcmF0aW9uIGluIENocm9tZSwgRWRnZSwgSUUsIE9wZXJhLCBhbmQgU2FmYXJpLlxuICovXG5hYmJyW3RpdGxlXSB7XG4gIGJvcmRlci1ib3R0b206IG5vbmU7XG4gIC8qIDEgKi9cbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gIC8qIDIgKi9cbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xuICAvKiAyICovIH1cblxuLyoqXG4gKiBBZGQgdGhlIGNvcnJlY3QgZm9udCB3ZWlnaHQgaW4gQ2hyb21lLCBFZGdlLCBhbmQgU2FmYXJpLlxuICovXG5iLFxuc3Ryb25nIHtcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjsgfVxuXG4vKipcbiAqIDEuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIGFuZCBzY2FsaW5nIG9mIGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXG4gKiAyLiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXG4gKi9cbmNvZGUsXG5rYmQsXG5zYW1wIHtcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZSwgbW9ub3NwYWNlO1xuICAvKiAxICovXG4gIGZvbnQtc2l6ZTogMWVtO1xuICAvKiAyICovIH1cblxuLyoqXG4gKiBBZGQgdGhlIGNvcnJlY3QgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cbiAqL1xuc21hbGwge1xuICBmb250LXNpemU6IDgwJTsgfVxuXG4vKipcbiAqIFByZXZlbnQgYHN1YmAgYW5kIGBzdXBgIGVsZW1lbnRzIGZyb20gYWZmZWN0aW5nIHRoZSBsaW5lIGhlaWdodCBpblxuICogYWxsIGJyb3dzZXJzLlxuICovXG5zdWIsXG5zdXAge1xuICBmb250LXNpemU6IDc1JTtcbiAgbGluZS1oZWlnaHQ6IDA7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lOyB9XG5cbnN1YiB7XG4gIGJvdHRvbTogLTAuMjVlbTsgfVxuXG5zdXAge1xuICB0b3A6IC0wLjVlbTsgfVxuXG4vKiBFbWJlZGRlZCBjb250ZW50XG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuLyoqXG4gKiBSZW1vdmUgdGhlIGJvcmRlciBvbiBpbWFnZXMgaW5zaWRlIGxpbmtzIGluIElFIDEwLlxuICovXG5pbWcge1xuICBib3JkZXItc3R5bGU6IG5vbmU7IH1cblxuLyogRm9ybXNcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIDEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzLlxuICogMi4gUmVtb3ZlIHRoZSBtYXJnaW4gaW4gRmlyZWZveCBhbmQgU2FmYXJpLlxuICovXG5idXR0b24sXG5pbnB1dCxcbm9wdGdyb3VwLFxuc2VsZWN0LFxudGV4dGFyZWEge1xuICBmb250LWZhbWlseTogaW5oZXJpdDtcbiAgLyogMSAqL1xuICBmb250LXNpemU6IDEwMCU7XG4gIC8qIDEgKi9cbiAgbGluZS1oZWlnaHQ6IDEuMTU7XG4gIC8qIDEgKi9cbiAgbWFyZ2luOiAwO1xuICAvKiAyICovIH1cblxuLyoqXG4gKiBTaG93IHRoZSBvdmVyZmxvdyBpbiBJRS5cbiAqIDEuIFNob3cgdGhlIG92ZXJmbG93IGluIEVkZ2UuXG4gKi9cbmJ1dHRvbixcbmlucHV0IHtcbiAgLyogMSAqL1xuICBvdmVyZmxvdzogdmlzaWJsZTsgfVxuXG4vKipcbiAqIFJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRWRnZSwgRmlyZWZveCwgYW5kIElFLlxuICogMS4gUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBGaXJlZm94LlxuICovXG5idXR0b24sXG5zZWxlY3Qge1xuICAvKiAxICovXG4gIHRleHQtdHJhbnNmb3JtOiBub25lOyB9XG5cbi8qKlxuICogQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cbiAqL1xuYnV0dG9uLFxuW3R5cGU9XCJidXR0b25cIl0sXG5bdHlwZT1cInJlc2V0XCJdLFxuW3R5cGU9XCJzdWJtaXRcIl0ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgfVxuXG4vKipcbiAqIFJlbW92ZSB0aGUgaW5uZXIgYm9yZGVyIGFuZCBwYWRkaW5nIGluIEZpcmVmb3guXG4gKi9cbmJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcblt0eXBlPVwiYnV0dG9uXCJdOjotbW96LWZvY3VzLWlubmVyLFxuW3R5cGU9XCJyZXNldFwiXTo6LW1vei1mb2N1cy1pbm5lcixcblt0eXBlPVwic3VibWl0XCJdOjotbW96LWZvY3VzLWlubmVyIHtcbiAgYm9yZGVyLXN0eWxlOiBub25lO1xuICBwYWRkaW5nOiAwOyB9XG5cbi8qKlxuICogUmVzdG9yZSB0aGUgZm9jdXMgc3R5bGVzIHVuc2V0IGJ5IHRoZSBwcmV2aW91cyBydWxlLlxuICovXG5idXR0b246LW1vei1mb2N1c3JpbmcsXG5bdHlwZT1cImJ1dHRvblwiXTotbW96LWZvY3VzcmluZyxcblt0eXBlPVwicmVzZXRcIl06LW1vei1mb2N1c3JpbmcsXG5bdHlwZT1cInN1Ym1pdFwiXTotbW96LWZvY3VzcmluZyB7XG4gIG91dGxpbmU6IDFweCBkb3R0ZWQgQnV0dG9uVGV4dDsgfVxuXG4vKipcbiAqIENvcnJlY3QgdGhlIHBhZGRpbmcgaW4gRmlyZWZveC5cbiAqL1xuZmllbGRzZXQge1xuICBwYWRkaW5nOiAwLjM1ZW0gMC43NWVtIDAuNjI1ZW07IH1cblxuLyoqXG4gKiAxLiBDb3JyZWN0IHRoZSB0ZXh0IHdyYXBwaW5nIGluIEVkZ2UgYW5kIElFLlxuICogMi4gQ29ycmVjdCB0aGUgY29sb3IgaW5oZXJpdGFuY2UgZnJvbSBgZmllbGRzZXRgIGVsZW1lbnRzIGluIElFLlxuICogMy4gUmVtb3ZlIHRoZSBwYWRkaW5nIHNvIGRldmVsb3BlcnMgYXJlIG5vdCBjYXVnaHQgb3V0IHdoZW4gdGhleSB6ZXJvIG91dFxuICogICAgYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBhbGwgYnJvd3NlcnMuXG4gKi9cbmxlZ2VuZCB7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIC8qIDEgKi9cbiAgY29sb3I6IGluaGVyaXQ7XG4gIC8qIDIgKi9cbiAgZGlzcGxheTogdGFibGU7XG4gIC8qIDEgKi9cbiAgbWF4LXdpZHRoOiAxMDAlO1xuICAvKiAxICovXG4gIHBhZGRpbmc6IDA7XG4gIC8qIDMgKi9cbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcbiAgLyogMSAqLyB9XG5cbi8qKlxuICogQWRkIHRoZSBjb3JyZWN0IHZlcnRpY2FsIGFsaWdubWVudCBpbiBDaHJvbWUsIEZpcmVmb3gsIGFuZCBPcGVyYS5cbiAqL1xucHJvZ3Jlc3Mge1xuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7IH1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGRlZmF1bHQgdmVydGljYWwgc2Nyb2xsYmFyIGluIElFIDEwKy5cbiAqL1xudGV4dGFyZWEge1xuICBvdmVyZmxvdzogYXV0bzsgfVxuXG4vKipcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBib3ggc2l6aW5nIGluIElFIDEwLlxuICogMi4gUmVtb3ZlIHRoZSBwYWRkaW5nIGluIElFIDEwLlxuICovXG5bdHlwZT1cImNoZWNrYm94XCJdLFxuW3R5cGU9XCJyYWRpb1wiXSB7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIC8qIDEgKi9cbiAgcGFkZGluZzogMDtcbiAgLyogMiAqLyB9XG5cbi8qKlxuICogQ29ycmVjdCB0aGUgY3Vyc29yIHN0eWxlIG9mIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGJ1dHRvbnMgaW4gQ2hyb21lLlxuICovXG5bdHlwZT1cIm51bWJlclwiXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcblt0eXBlPVwibnVtYmVyXCJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcbiAgaGVpZ2h0OiBhdXRvOyB9XG5cbi8qKlxuICogMS4gQ29ycmVjdCB0aGUgb2RkIGFwcGVhcmFuY2UgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXG4gKiAyLiBDb3JyZWN0IHRoZSBvdXRsaW5lIHN0eWxlIGluIFNhZmFyaS5cbiAqL1xuW3R5cGU9XCJzZWFyY2hcIl0ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDtcbiAgLyogMSAqL1xuICBvdXRsaW5lLW9mZnNldDogLTJweDtcbiAgLyogMiAqLyB9XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBpbm5lciBwYWRkaW5nIGluIENocm9tZSBhbmQgU2FmYXJpIG9uIG1hY09TLlxuICovXG5bdHlwZT1cInNlYXJjaFwiXTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTsgfVxuXG4vKipcbiAqIDEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXG4gKiAyLiBDaGFuZ2UgZm9udCBwcm9wZXJ0aWVzIHRvIGBpbmhlcml0YCBpbiBTYWZhcmkuXG4gKi9cbjo6LXdlYmtpdC1maWxlLXVwbG9hZC1idXR0b24ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcbiAgLyogMSAqL1xuICBmb250OiBpbmhlcml0O1xuICAvKiAyICovIH1cblxuLyogSW50ZXJhY3RpdmVcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKlxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gRWRnZSwgSUUgMTArLCBhbmQgRmlyZWZveC5cbiAqL1xuZGV0YWlscyB7XG4gIGRpc3BsYXk6IGJsb2NrOyB9XG5cbi8qXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBhbGwgYnJvd3NlcnMuXG4gKi9cbnN1bW1hcnkge1xuICBkaXNwbGF5OiBsaXN0LWl0ZW07IH1cblxuLyogTWlzY1xuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qKlxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgMTArLlxuICovXG50ZW1wbGF0ZSB7XG4gIGRpc3BsYXk6IG5vbmU7IH1cblxuLyoqXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSAxMC5cbiAqL1xuW2hpZGRlbl0ge1xuICBkaXNwbGF5OiBub25lOyB9XG5cbkBmb250LWZhY2Uge1xuICBmb250LWZhbWlseTogJ0ZvbnQgQXdlc29tZSA1IEJyYW5kcyc7XG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgc3JjOiB1cmwoXCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQVBqd0FBc0FBQUFCZ0dRQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJIVTFWQ0FBQUJDQUFBQURzQUFBQlVJSXNsZWs5VEx6SUFBQUZFQUFBQVF3QUFBRlpBT2xDNFkyMWhjQUFBQVlnQUFBb2VBQUFXTnY4NUZ5Sm5iSGxtQUFBTHFBQUEzZElBQVU1Y21JWk9BR2hsWVdRQUFPbDhBQUFBTUFBQUFEWVBESVlzYUdobFlRQUE2YXdBQUFBaEFBQUFKQVE4QTN0b2JYUjRBQURwMEFBQUFaSUFBQVVzY1p2L1lteHZZMkVBQU90a0FBQUNtQUFBQXBoZVpiQ0ViV0Y0Y0FBQTdmd0FBQUFmQUFBQUlBSjhBZjl1WVcxbEFBRHVIQUFBQVdVQUFBTXFYd3EwN25CdmMzUUFBTytFQUFBSmF3QUFEdm12N1pMM2VKeGpZR1JnWU9CaU1HQ3dZMkJ5Y2ZNSlllRExTU3pKWTVCaVlHR0FBSkE4TXBzeEp6TTlrWUVEeGdQS3NZQnBEaUJtZzRnQ0FDWTdCVWdBZUp4allHUjh3amlCZ1pXQmdYRWFZeG9EQTRNN2xQN0tJTW5Rd3NEQXhNREt6SUFWQktTNXBqQTRmR2o4RXNsNDRQOEJCajNHRXd6dVFHRkdrQndBRU40TmVBQjRuTlhZKy8rWDh4M0g4Y2ZybTA0SUhTVGtOSFBPSVp0c0ZUT3oyUngyc0lNNXJKbHRTR29obTZoVVlrbVlKS3JKT1FvTkN5Rm0wNXFsYlMwU3pTa3p0SkhQKy8yK3N0bUJQZC9mcHgvMkgyenJ1dDE3NjN2NzNxN3JmYjJ2NjNxOW55OUFSNkNEOUpPTm9OTUNRdjlGeDl2MTAyai9lUWMyYnYvNVJoM0g2Ti8zTTU1T0RHaE5iRTF0VFd2TmJxMXFyVTA5MDRBME9CMmZocVlSNmN3MEtvMUxFOUtrZEZtYW5xNU5zOU9jTkQ4OWtCNU55OVBxdEM2dFR4dHloOXcxYjVaNzUvM3pnZm5nZkZRZWtvZmxFWGxrSHBjbjVpbDVlcDZaNStZRmVXRmVsSmZtTmZuRi9ISTVzWnhUeHBieDVhSXl1VnhScmltenl2WGxsbkp2ZWFROFZwYVVKOHJ5c3FJOFgxNHFyNVkzeTl1bGxIZkxlMDNIcGx1elU3TnowNzg1dWptbU9iWTU3djMzb1RXaGZkNHpXeXMvbVBjZ3pmdlVOQ3lOVEdlbjBXbTg1bjFKKzd4bmFkNDNwSVZwY1ZxV1ZxVFgwMXVwbGR0eWw5d3RiNUg3YTk0RDg1R2E5MGw1dU9ZOUpvL1BrL0pWZVVhK05jL0xkMnZlUy9LcS9FTDd2RThyNTVZTHlvV2E5NlhseWpLelhGZHVMSFBMUXMzNzhiSzBMTk84VjJyZWE4dHJaYjNtdlVIemJtczZOOTAxNzEzK2M5Ny9oMzlDNzhxaTltTXh2L2pnV0tMakNYN0xDbGJ5UEMvcWVLMzllRVBIUDZNdE9zWEcwU2Y2eHZheGUrd1ovV0tmR0JpRGRSd1duOUZ4WWd6UmNYS2NFbWZGcURndnhzVEZjYm1PYWZIam1OTitMSXBmeEpKNFFzZUtlRDVlakZmaWpUYmFldWpvMWRhbnJhK08vWFFNYUR1MDdUQWRSK2s0cG0xSTJ6Z2RNM3hvMmp0d0VqOWhkT3pJdHpoUHMvd0RGM01SQ3ppWGhjemdFSGFMSStMUStDUmZpaTdNNUx2NmFyYVA3YUl2UFdNZ20zQVBYK1Jmakl4dG1CTDk0Nk84eWUraWMrek4rekdZWlhFWWwvQm4xa1dQNk1saGZKWm5XYzB4M0VCZnRvMU5kZStkT0R3Mml2MzRPRGRyVmI3Tzkva0JQNG8rckkwREFxM0s0VnEzeVh5RS9kaUh2ZWpQL3N4bkhyUFpsRDBZeEtmNEhuZndWOTdsNy95VE5YRmc3TUVEOFNtVzgydSt3YjdzemNHY3c2allWcy9nVjV3ZEh5ZHhBQ2Z6SkxNWXJPZlZsYXRqSDNiaUREMk5yektRUnhrUnUrb1pMYVpoVjNaaFRCd1VuK0E0TG1CYzdLWG4weUVpMm5pT2I4ZG5ZMnQreU9uY3pSODVNN1ppR3k3bFJLN2xWZDZKWG5Fd0QzSWFiYW9rSFZVN09xdWVkR01MTnFjN3ZkaVNyZGlhN2RpQkhma1FIMlpuZHVlakRPQkFQc1pCZklKUGNpaWY1ak44amlNNGtxTTRtcy96QmI3TVZ6aWVJWHlUN3pDTTRaekYrYXBMRTVuQWhVeGlLcGR4T1Zjd2plbGN3M1g4bURsY3owM2N5QzNNNVZadTV5N3U1YWZjMS82R1BzVERQTUxQZUt6OS9md2xTOXZmejkvekZFK3ppaGQ0aVpkNW5iL3dGdXQ1bXhhRkRmeU5mL0JlZEl5dXNVbDBpKzZ4WmZTT0Q4WE84ZUhZSlhiVHU5c3Y5bzM5WTBCOExBYkZJWHB6UDAwUFZkSlQrVG1QOHh2K1JHL3VKTWRIMkl3K0hNdFF4bkpWYkJaYnhPYXhFMTNZa3hPNGphL0Y1emlGSzNtR1YvUldkdnB2Zjg3L0EzODJyWDl0UHRuL2lDTnFOVGQ5czdRbW1yNWVXbE5OM3pHdGFjWm9qVE10ZHRRNHkvU1YwNXB0K3Q1cHJUUjkrYlNlTXRVQVdrK2JxZ0d0VmFhNlFHdXRxVUtRZXBwcUJXbUFxV3FRQnBucUIybXdxWktRampkMjAzaXExZnRLcDFrY3FuR29xZUtRaGhsZjBuaUdxUXFSaHB2cUVXbUVxVEtSUmxyZDJkT1p4dllhejdiWVR1TW9Vd1VqalRicWZaeG5xbXFrODAzMWpUVEdWT2xJWTAwMWp6VE9WUDFJNDQxNi9RbW1pa2lhWkV6UmVJbEZmNDFUVFBXU2RLbXBjcEttR3IvVGVKbEZaNDNUVFhXVmRLMmhYVExOc3FoclBOdFlwbkdPcWY2U2JqRHE5VzgwMVdUU1RjWTZqVGRiOU5CNGkwVmRrMXVOZXA2NXBpcE91czFVejBtM215bzdhWjZweHBQbUcvWDZDNDI2NXZjWjIycTgzMEp2ZW5yQVF1a3JMYlphQmRJanh1RWFIN1dvejNlWmFmY2dQV25hUjBqTGpYcFBLMHg3QytuM3BsMkd0TkswMzVDZU11MDhwS2VOSDJsY1pkcU5TTThZZXUvVGFvc0ROTDV1TlRpbU55enErN2JPb3M3NUxhTmVjNzFwVHlPMVRMc2JLUm4xWHJKcHh5TVYwOTVIYW96Ni9td3c3WWZrTnRQT1NPNWcyaVBKWFV5N0pibXIxWXFTdTVsMlVQSm1wcjJVdklWcFZ5VjNOKzJ2NUI2bW5aYmMwN1Rua251WmRsL3lscVo5bU56YnRDT1QreHRyTk81dmNhREdEMFNkdzBCRHp6NFBzcWh6R0d6YXpja0htZloxOHNHbUhaNThwR212Sng5bDJ2WEpRNHo2dXllWmtnRDVXNGErLzN5eUtSMlF2MjNLQ2VUdm1CSUQrYnVHYWtjK3haUWl5S2VhOGdUNU5GT3lJQTgxNnJsUE42VU44akJUN2lBUE4rcjlqYkQ2QXVXUlJuMVdZNHlyTlk0MUpSWHlPRk5tSVk4M3BSZnlCRk9PSVU4MEpScnlKS091OFVXbWxFTysyS2pYLzZFcCtaQW5teklRK1JKVEdpSlBNZVVpOGxWRy9mM3BwcXhFbm1IVXVWOWpVWi9idGFZa1JaNXB5bFRrVzAzcGlqelhxUGMzejBMdmZKNXZzYWZHT3l6cU8zNm5SVjIzdXl6cWQ3REFsTkhJZHh2MTJkNWpvZHFWN3pVbE9QSlBqYm9HQzQzNjNCWVo5UnhMVEVtUC9FdEQrMHBlYWtwLzVGV21IRWgreHBRSXlhdE4yWkQ4ckZIWDR6bFRYaVN2TWQ3UitJSkYvYlpldEtqdjhNdW1YRWs1MFpRd0tSOVExcVFNdGRyZGx0T3RkcnRsbUNtSlVzNHdaVkxLY0t2ZGJobGh5cW1VNzVrU0syV2tLYnRTempTbFdNcFpwanhMT2R1VWJDbWpUQm1YY280cDdWTE9OZVZleW1oVEFxYWNaOHJDbFBOTnFaZ3l4cFNQS1dOTlNabHlnU2t6VThhYjBqUGxRbE9PcGt3eUpXcktSYVpzVFpsc1N0bVVTMDE1bXpMVmxMd3BsNWt5T09WeVV4cW5YR0hLNVpRclRRbWRNczJVMVNsWG1WSTdaYm9wdjFPdU5pVjV5Z3hUcHFkY1kwcjNsSm1tbkUrWlpVcjhsT3RNMlo4eXg5UUZVSzQzOVFPVUcwMmRBZVVtb3o3em00MzZuRzh4Nm5PYmE5VDF2czJvYTNtN3FhdWd6RFAxRjVUNVJsM2pPNHk2eG5jYWRmM3VNdXI2TFREcSt2M0VxT3QzdDFIWDdCNmpydE85UmwyUGhVYTk3L3RNM1F6bGZxT3V3UU5HWFlORlJyM3ZCNDI2SGc4WjliNGZOdXA5THpiMVJKUkhqSHJmanhuMVBoNDM2cnlXbUhvbnlsS2p6dXRYUnAzWEUwYWR5ektqWHY5Sm8xNS91Vkd2dWNMVWdWRldHdlg2VDVtNk1zclRScjMrS2xPblJubkdxSE5aYmVyZUtNOGE5ZHpQbVRvNnlocWpudnNQUmozMzgwWTk5MHVtem8reTFxZy9lOFhVRFZMK2FPb0xLYSthT2tUS2E2WmVrZks2cVd1a3ZHSHFIeW5yVEowazVjK21ucEx5RjFOM1NYblQxR2RTMXBzNlRzcmJ4bnNhaTBXdGFSc3N0RmVXZHl5VTFjdGZMV29kKzV0RnJWZnZXdFFhOVo2Rk1rclRacUdhMDNTd1VKMXBOckpRL1drNldtaVBhenBicUg5cHVsaW9GalZkTGZwcDNOaENtYVRaeEVLNXA5blVRaldxNldhaHV0UjB0MUR1YVhwWUhLS3hwNFZxVHRQTDFGZlRiR25VMysxdDlmOW1ObHVadW02YVBxYittMlpyVXlkT3M0MnBKNmZaMXRTZDAvUTE2dm0yTTNYc05Oc2J5cVBORHFZdW5tWkhVejlQczVOUnI3bXpxY2VuMmNYVTdkUHNhdXI3YVhZelZDdWIzUzNxZWZhdzBMN1Q3R21oZmFmWnk2SmVwNTlSMTM1dm8vN3VQc1lKR3ZjMVZOZWEvWXl2YWV4dm9icmRIRzBvenpYSEdLcnB6YkdHdnJIbU9PT1Zmd043MVN4bUFBQjRuSlM5Q2JobFIxMHZ1cXJXcXFvMXo4T2V4N1AzT3ZPd3h6T2YwM1BTU1kvcGROS2ROSjEwUWlaQ0RBbUVNSVZPUXBCQkVDUVJOSUFOWGdZUk5ZaERtQk5GaVQ1UUZLLzNlWjg4QS9jNjhieWYra1JmbE1mcCs2OWErM1NmQkwzZmQwL3Z2ZllhYXRXcVZmVWZmditocWlWRmtpNCtpejZDZmxNNkpOMHN2Vlo2dnlRTjIrc29UdUtrdjQ0NmNSVGFLRzMzQmtsbk9PajMyZzFHR2EyaWVEQmNSNzFaM0lBakIvRVNhNmczV0VHZGNBb2xnK0VBYm85Q3hzOEhOQjRPb0xLNHN3NUg4QTlxQ09BdXZ0dHJVN2hTUVVPNFl4YWxJZFNiTEhRMkVKenNET1lRUCtud214cndSRVp2Snppa2l1cWlwYVBMclpVNjBjaDBtSjljREN4WlJxaDFRODBQdzlaOGY4RjNLSkpWemFiSy82dXF6Nk5XZCs1MHFaeU8zYlBRRzBjYTNidlJHRk5sZ3lpMTZkWjR2Wmo3enZpZysvS3h0dWs0U0pzY2Y4M3FyZ1daV2IrcElLSmdGUGdZRTRONHZrd043TU9CWWlwK2dPNHdWS2Fvc2YreTFuQnB2TnFOZE94WTJIVGE1VmJzQkhaL01XZlcvUG4rZkRzTUEwZERpb0lWOVFzS3F6NDJybXZOZEtLM09aMUdTUjZ0VTE4dVJHYUpxSVpjZFN6RTJOWXZqVnRtT1oxY0pUSWpHL016NDZhOW9GanNEbGxCQ29MbkkyUlJhSXRPWmI1dks3NHZTNUlFMzR0ZlJKOUN6MHFUVWxmYUswa3Q2UGIyQm1Jd0FKU2xBK2puWmdOK04xREs2Q3phUU91b2lpclFyekJJYVdjQUkwckRXRzdNb21GS296QWJqSlNpVDFxNFdrYjZoQnVIYVlrVVM1TnBPVzNPWGozVmRhcWF2WmVGMmp0TllpemZaUWU3bzBwbHNsTDVjRG8wNHZGNlBuZDRhbVlzTFR6em9jRHlnOWZqV3FzeWpOTHEwV0tsa05iVWsvbFp5NnhiYXhTVFkyck4zRU5SK0JQODVzbksxb2M3QjJ2cEpQUmFzNjNJNVhGZmtpLys4T0xmNDhmUWU2VlFtcExXNEwzYWM2ZzlCQm9iZERzeFVJcURhTm9lQWlXbC9BSlFJWTBUQW5TMmdRWnBTNUFsQlZKYVNIdUREZHhIMzVWZjkycU5LaDVlWGc1TTlrMUhmVUFqNmwwcks3ck90S1VWbC95TWhtUzA2cXEyOXBDcWJ6MnVLSnI2VDRSWjl5TlpPWFA2YXZuSkp3d1pJMFY3SVNEekNrSmVvVUNJWWh6VUVGNlVLVG9BQkVnT1Uvd2xCR1A5ajR5MFNvcU1HOWNnYVRRK1gwUC9pSjZXc09SSXNTUUZTYk1GUEFVOTNnUCtxaUNXc3U2d203eXc2eEcwdE9lK3Q5NjNSMnh1ZmZ6eFN1T1REWlMvUmQ4ek9yWG52cDkrL3ZsZUQrcWtVT2RmWUlRK0FqWHVrYTZWSHBEZXd2a1cxUnMwOHNLNFcrOE0rbDZ2VFdCc09RODJnUWFBWFlFTks4QmFMSW81MThXVWQ1dGcwYlFOL0NjS0RBY2twTTIwemhvZ0FwSnVCem83RHJ5dzJhRHBMR3BBajNLdWJmTnlVRmtmMmc4RklrNXY0Z0ZjWm9Ta3dSL1g3MEVKR0ltNGpHS0t2cnUxNHBtR2ozN0hOODJ0TDF2TkNwVXBReTREemsyMHRVM1B3ZkF5Q0dFcW0wMmlLR3BwVHk0djR5Z3lBM05Pc3hGR0hxTms2elVLWTRoUzhydS9TeWpJQWNXRFkwV1dpK3R4WHRYeXpBM3p0VEdzT1pyZDA4Ykd0Q1NuVnVxNmpiYSt4Zm5HMG5XdkVSTVp0ZEVGMDl0NnZXOFlBWHFMYjM1UjkxMkdFWmFwRGF4WUxiQmliRGZ5YXFyN050VUlQSlg2MlBHcWNXcFFXYVpZb2Y2ZnFERFlzZ3NiQlIzYStyWU5MVGN3ZGxndVA5M3B1SmFIbGVpQXJXUGsvRzNpT2tHMzQxbTZFNHhWdWxoaHRtSEJGcmhaa2ZNTlRodjQ0c1dMejBNRmowbW1WQWE1YStOMmIxMk9iZFNDdmRSR3JJSzZJRGI3dlF1RnhVNnAzRm5xbEZBSjdSKzcrYVlyclB6SmZ2dnV0WU52dXZKYnpRVTM2dS9iUCsvRnZmM0oyckZrdXJ1dzM1N3BIWHpvS25PYlZ0QXo2SUtrQWllTlNRTnB2M1FOVUNGbmU2aTduY0JZZyt6dWN0SVl2b1NBbUJEcE1JWkFGQ0Q1RyswK0d3NDZ3SHN3NUl3QytmU1NTMlFNSlAyWHJWN3ZZQS8xQ3l0SWxvTzZoczV1L1VhdTJjeWhnN0Q5cnFIT3FDWUkxZkVBNFdzMTZsSVZ5N3JETUZicFk0M2xSbU41SDk4Z0RhcUF6MklWb1QweUNsMzVENXE1eTlWY3E1cW02Z0NsVUlRaW5SQVZZK1pxTXRUaC9uMWplZTlLVmczdlczYnhJblR3cmVpODFBQWVPUzQ5SXIxWGVrcjZVMG5xRDZxQ1V1T01qQ3VJU3dxdTFacE02Q2RnaTZEUjVQSWpiVStoQm9XM2gwNFk5cmR2NEFWWVQ2aTRFSVJQQTRoOU9EOGxhb0dpUVBQQVpXWEVtWUJYeWg4MDRCcE4xTkhMNms5Q2ZnbFlpc3ZpVGtSQTkvSENOb3E3bkVteEVHYWNmVGdQQ2ZFR0RhbmlXRFIwRGpYZ09VbmNoZlpzNE1FVTUwdVpWVmYzMUt0ejg3blN0WWVKSmxPS0o1ZGE3WEl1YithS0UrbXhYY3FIZ2IwaUQwaWRHVVFtRVNpVVlxTU02Z2xwVnBXdW9IaEJKWXBXRHdMMERRVHF6S2NzRjNxbWpqd250RU9OWWpsd3BtSGNFREFkcDM3Tk1oTGtoeHJUS1V2c1BKeEhyaFVHT1JlRXBGd0liZW9pMVlTQ0JDTlY5aGwrQzdVS1dFbmdxU3NZYThSZ3FrcFVuUlVzS2g4QVJnb3BubjREVmR5S3h4UUd0K2wxS0VVVlZQRk4yRUlCWnBlWEthSUlXd1RVSC9rVFFxN0NNU09WSUY4T3F4Uk5BTHZKT2J0bFZUQklpNGVRUWpEVkdhWWdoUzI5QURVUTVsdGVyR3ZNUVFZaGQ2c0VhQWVqOHhoWjBGNGxpRlNrNEE5VEF1SmJNZUFMYndGdldpa1JrRXZ3QmtwU04zN0NIOXRQRlBwVGxNWUdsMVpFVitFU1ZQbFpxcENIZ040NGpub2VmUUZrOGpqbzRhdWttMEFldzJnSmxUb1l4c21RRHowd0d2OXB3RkJISENaMUZ6b3hsOGdjS29ITUJQSktCQ2syTWtyTUtIVW84QlNIVEJuNU9RZ3VyNE1PQng1WW05d2RoNXRyTG1zdnFUcFZkVE11SGErVmF3ZjF4TkNGV0xXTVpyNGMxOS9HL0dKdDZ1eGN1MUZ3Q1ZXVVFXTjE3ZW9UbERRMGszY1dTQ1dhT2tBaXhVSVplcnlNZzhydU5CZHIrWUl4dHNoMDNiTGU1M2l4NmJyT2ZKNVZUV3JaV25TdTdOZ284V3UyZ2I2dVdiN3BoRTR4REFpVmNkM0tJVFFPR0N6U0Zaa1lEclFkeGtBeFpWa3RnaGJrOHVnejBFOTlrRVFnaHdTWFJOc3dzTXM3cEl5b2tEQ0N6b0hTQVhvT293cE91akVYUzJsYjdvbSs0djhpMm9UZStJZUYyVzVibDJIQVRWS2NtRWxMZVFYdlBYaGtpc21xbWFzdE5HWW5xMENNK2ZheU9ydndPYXhZUVgyc21vNDNIQjFkc0p3aXRlV0N6bVRGdHgzUE0wcHR6WEdDTkJxamJsRDJFc3YwOHFEaWdTb1ptdGhvdHJlZXh0alRYV3BvaHZ5S25HOUlJeG43NTRDaFB5b1pVbE1hU3B2U2xkSkprT2VBd0lSd0hjQkxoU0FCb2pBZXJLSHU2S2NEbSthd0NacFNqUFNnazhBNE96Q3VhUWJLT29QaDlrNGl4RkRNNytpMVQ3czUzMDg4M1RmRFVyRmRMSVdtLzhJTC85b3NCNWloc0xDVUR4SERRYm54S2FwUitMeUtxb3lwOUt6aGVZbnZmLy9WTUlqbXF3M1gvYVRscmZtVzdhM0IxdkxYUE91emVyWHZORUdoTmcyaktjdEswK25uRkg0cmtJdjRXWFROKzBkM2o5NzVHZlErd0oxVFVrL2FEVHJscDZRUEFFcmpSZ0lBVGlFK0FUZEVBT3F6M3lTeWVRZUk0ZVE2RFFnY1Jqc0tIVFFIUFpRQXBNdVFhcHQxRW1FKzhKR2RoWUtEQlBZeWhORVpuUWFSU0lGZ09vTzAyK2tDYncweTVnRUlBNUtTQ3ZqUkZVWUhNQmROb1dxQUd6Zk01c0o4eVkyWVBHd2x5U1F4TmErcUZuTlRZK25jMHN6a25HYnRqVndEVU03YkRjMTBHc1FrbW9KbXNPWFpwa0dKRm5vVis4dlR1MmIyZUNwR3JqK3J5U0RDVE45bTBPQkV3VXpHNHdBRUxETlEyeXAyNkd4dW1wajF0T1BxTXRhTU4xSmIwNHkvZmFnYWxZYVYxWUI5dkp4VUg3QkkwMWREek1aS3JYMVJYQ3ljV1dwSHhmczNYZi9OTXYxWjFUU2NpWmNEMGFIWGZpSWZsZ3RnY0VUQnZFNmR6eS9NVFVTdTQyM29DbUhFUyt3NHJKYnNGY3kwdWhwR3ZrVWROVUpFS3pDS21HWURCR3BNbk1NeVlod0tTTWJGSDRKT2ZCZ2RsandwQXU0N0xwMldYZ1pXM3dla0Q0TnUvQ3lNbm9PSC9JUGdrdzZUSVFNN2dvQmdHSEp1M01aOTBKMWN5MjJnckRDVUVRVWRHUXFtYkJZeEc4ZGNNNEdnNHNVQm9nOVROZ2Vsb2FENHNMNm9LS3NHSGlOcVNtT1dNUDRvSmlTZ3FHdTRqcUdTbUk4cjI4Q01tekkyaHRyd2VibUptL0J0eUp2bVhDMVh0V29QbHF6UzF2Y0NwU1JyVmE4QStzTVB5akdNRHBMVEZwRjN5V040RExmZzN6Q3BhYkY4bFp6VGw1Vng5Vk5GSUFNN3hFN1ZLcTRnMDVGdG9zV1VSUjlTbmZmQjVkcFNycW9YMjdTczZMcWZiN2xRV2NFZ05TdXBUcEV5Y1hHajBPSlB4SnJtNWlac0pkK21mdzZtb083ZHExck1aZzE1QTFWQm9WRWpscC9OcVg5Y2tuMjVqRU5jVUY1MVAzNEFINzNtemVoQjlQYXhGaTQ3SVVLMVlpNklNS2duRTFleFhDZ29KZXpqb2h6SzBXdndqNTNFSlZMQ055Z09kdGV4RGlveXpBZllSMjBnMFJLQTE3VlZYelBiNDRjODJjZXZ4N2ZkZ1RkMjR3bms2eDZTYTZnbVk5UEVVN1A0eURTZW1ScXpVOXhLY1UyMm1ZWGt5WEVvZWdReGw2Sk53QUtxTHVjVUU0TzZSMzdaUSsxdCsrVjVkQUh3SXdZRTZZQlU2Nlo5RmlURFFHNm1UZFlNUG5WMSs1dTFwNTZxSFY0bzNGT2NmK1RYYm56UHdhMi9PM2NPaFZ2ZjM3MGJ0YVJMdXBGalVFZktTUjFwMzQvYUtzaEdzNEllaHNEckhIWU91WTREVWh1dUMydVY2NFZtQXRBNHN3S0hZSnpFSVVYdjJib1Fsa29odWdtMlcvK1g0dHBFY1hMT2c3L0JZV0ozVjZnb3RxdG9tdUk2aW5KeTNYRnVLSWNLZ1ZNSERVVTJWbnBRQ2wwb2haZnIyTHFnS3FyTDhtb1FtcDV4WDVPNXFzSWNoL0dUVHhTdHVzcVBIdzVpWDczTjhFeUp3SHM5aDE0QTJ5NFBLTE1QVXZBSXZObmxGck1YdlV2aWJML2tVRFIrQ3UxNG43UmhveEFrR3ZlcUFEN2NZUjhpU1ZNOG01RHJOcUFobjlOTVUrdnREZ214UFdWL1FQaUxPYm5QOWZscDhXNmVjcFVKSUtaeTJXaDhZdm1XMTl5NkxEYm9nTXVJNXFydkw0RldNKzhmVTEyd2NiN1hFT2Z5YkFyT05jU3BSOFBZMXo1MjJSaDlZWGxVd2ZJdGtpWU1sL1BRckpvMElXMkFwanNyM1FuMjU3dWtqd050d0NndGNDOFJaVnl2clVNbkNEQThiTnBJOUVXeTdYRVlkbG1YWHdZcEhuTHNEUUorSVdxQ3dnTWx3UVU3WEY5NHlmV211TTVWaVZDTklFRzRhZElVaC8ydXdGRE54aXdlOXJJR1JEc2VBY1ZHYW9udlRYcVdvdm9VdGJGQ3dpaVgwMU1Bc0E2b3h6RFZtUnFwNnVrMkFqenZSZ1lqaEdrNXgxSEdqNmtGRmJHQ3V0eEdESzdvcXJqaU9qSksrU1g0REFnemQrV3VWaE1HV0Q0TXdzUlc0SUNpbDdVeElwWUIwRlp1S2xTSEcvNklhb2tHUWs3WEZVYlV3TDA2TUZVdjllYUpRNmhOemthV3FyRndPbUc2WnU2L096S1I3a2VXZWVTbHB3MStOZzRpYXVScUlEVUEvV0VYYWlWV0l0QXoxWlRaME5BMGF0dTZZZ0puYTN0Zm05bEZQeERqdHhkR2NsNWFCcHE5VWJwTmVoQ1FHSGNGck9OdXpOdmY0S0lXWmVZTDE5alExUUtGRFlZTDNMcHZEN3Z0WWRUdGQvbHdOdGsyT2ZOaGc3T2krMFhYdy9qQXFNQm9nK2tJcGd3b2J5aXpnVUJzcE0yRWoxY2FkVjVEUFEyc0VoOU1PY01EaThKV3JZUlpsRGdhMVhRYXVpSFRWUXBnUzJNbVNwQjFzRHBSYm8yVkp4dGhISWVOajlvNWlrclZUZzBWc1d2WVRydFFLcFpOQjVVYTBYVkpUdXRYbTJpczJwVmxVOWRrMUZCVnBQcVc1dGNSVXhTS2JET3VsMk9McXZCSExOZFdtQlhrQWZyOTl1NnhwYkZDMkFwZlpodkp6VkUrSDJpR2FRTHNqOXBKWW1oZ0J4bVdmekFvUEhILy9lOVdEUjNsQkVzSVhQdTZFZjZYV3UwaHR3QnR0TjJUVVpqMTVSQzZFUUJPbC9jbEJ6WHBJRjNJZW5xSVZsQzN0T1FFUnR1TTZtNjU3M3EyNmdSQlBqYWlRaU1YMjdWNjNoeTNWYlJVbFAyMldWWmF0YzhPSytNRUVka0dhNnRTcms2bGszR3hIdVJCa0dzYW1tbTJnNWJ2ZjZ3MkRzWjViVnh1aVRaK0grOUNUd0JpVytWWWJUakl6RlRPcXNBbVhQT204aXpLb0xWb05ZMFQxaDNHUTlaTnVkQk5CeXdGNVF4bUNxWkxDSjA2ZHRPOXJ6eDkzWW5oZmIycmpyQjVOM2ovbCtzbHExeFpxSmNYVHBRbTBWaTk4Zks0UHBhOHJWN096OTUyWmVrVCtmcFkvYllqeFhldUxIV3VOTzBrNmM3WURsT05BK2U2cnZQZnRyN3J6QzlYNnZsSWQrWXJreE9GS2J2YlFFcXJyK29IN3ZGWEp2b1VYWGlEd0RGYzd2NGIwUEJiWWMrVmlvQkFwK0Z0SXRMcWt3MlFzRUI5M0J2RmhERXg1TWZwQ0xmd0hvZXJBNExQYnoyejlRemFmR2l1Zk1OZE41VFY2VmZlL3ZsaU5UL2p6cnFkNWM3Yk40OGV2dUxnQWxxWTJMWDNaeCtiaU5CM1hoZzg5OXpndWZPVnlVNW5rcmJjeWQxQlBpa25oY0lydXJwV3JlOUZsWTJ4MXBVYmNaenB1bTlDMjU0Q2hLeEx0dVNEUnBDNWc2K2J3b2FBOGQ5eWdJN1hQM0k0LzJEKzhEY21RRkhIK2lmRHJXOStVdjg1OU5SVzdkaXhkeno2NkZ6VlhWeDBxNXJ3RWYzZzR2T1lDRi9mWktZM21VeUYzaHdHZzdiTVVqREJBVjROd1o1TUFYQ0FGVlhCRHZ5aTM5bDZycnhBbGtpampCYXpuZXRxOStlOTJKL291Y3RtZUNyUWJpY040dHVZTnBXejZNSkVlZXZyNVltSk11cVZKN1krWnQvakdwdlcycnhidGFKSHl1UlZTbzBRMXljRnhvVklwZ01lUnVQd2pocTBLNEF4NkVoN3BTOUxYd1Vkd0ZIQk1FbFpOMG03Q2J3enlPWmgxT3czNFJjVUd3WVJQWElPY2s4U1VCM2pjUVFiaHhYY1djZDkxaGRZVHpoS01PODE3aDNOUERSUldzVXBOeU80eEFlNTA3KzhuOEora3dzaytNTDVlT2NSZjliT1EzRVQ2Rm00YVJobDloWHNENU5teWw0UjlBSnZmWDA5U00rc2V6TXpYdUQ4bGo5eDYxdDFQMWZLK2JxdUVVczJTNlpzZ21SeVZEdUlmRnRWYlQ4S2JQYXlVLytFMEs1ZG9EY0lRTzhjMUxMaEJ3azBtMUM4dVluUVA1MVNLQmRrNUNqZ2RoMzBTcGxTUW1sYk5ZZ0MveGdqYlVMZ1JCbUtHWXdxUjNseFJyOFJCajdDSDV1WWVQVFJjMU9yYjducHBqZS8rYzMzMzMrL2FYWnQzcUFnS2VVMFFoRWg4Rnd0WnhzQmJ4RGdFOUV1NHlZSzBoVDBBb0xueXJnQWxVd1VNRWcrRldFNGJldGdJK2lNUDBZallDMFFvakdRSlRsQXpYWUNNSkNaaEpoZ0ZqTWw0YWR5TWk4RXorS2xOSnJkZWYzVTFEaFF3Y1V0b0FlRTdwQm13YUs0UzNxZjlNdlM3M1AvQjBjOFU2akJNYzRBRUZzVmRZZmNaeXo4OThsb2Q3dE15aW9pT3NHOUpBTSsvTUlPcUFoUUtId0NJUlVDVmJqNDB3NkxNaGNhRjFXZGhLd0xQMWxtTHZMYXR5VWJGVWVoOEZieTJsaEdlajF4TGJ0RktMa04xQmxtcnNCWStOM0FCazlITllSZ1h5S2lNZ01wQk9BV1RtVlpOUmt1b1R6bWZpd0ZHVFl1WVVKTlJVWVRzcUxxVkVFL3IxRFE3VWltQ0N0RmN5cVN1UU5CY1FxQnJnRFdLRHFGbkJaWEN5WVV3YTVwZ3c3Qm9hb1o2SGJYbGVYWWo4RFloRzRHSEU1SXU1ckR1RWowdXFibUp6SEJTajE5L01nbXRSUlpaY2RPVGMvZGRBd3BGQ3RqVTlkY2J3ZWZBOFFDdDFHQ2JGVkhNdEhwV0VHQlp0ZzV0TmdvVHhORkpvL29DbUozM3dGb2hNd3RrMWRTc1BRZlk3Sk1lREVDejdOc2VhQlhWSGdyTEFOYXdVU2xzc0ZzbVh2UnNGS2JZM3FnenhIRFV5bENqaDdBaSsxaEJTOENndEFBSk10SXh0eVpqaDNMeUpVc1VMeEtyTmdlM091WitJTmFTOUdnOHhTNVFUQ3o1eEJHVEc3RVV3aTlER2xBNklxaUlEdE1BdWhTcU1mR1BPNkY4RWkzUG9mK0FYQzJDZkplQ25aaVpiazU3TDV3R2UwR3YzN3RyNk9uTDBQWHJjOS9FRERQSmZ1RGdVVG1YdkJ4YVNnZEJGa1ZUcUYrTjQ3UzNoU0t1cDB1eHkzdG9SZlNaaDBRaTljYmdKaU5HVWdOQnVUQW5SYWkySERiTVFPN0diRHRkL3RmcU0zTVZsaDVmS3J3Rm5qZkRmbVZPKzJLcHc0Zm52STl5MXE3NFV6Wmo5NC90akdlMWpwT1hmWTF6N3YxeVh3ZkZZL0hNNjVkK2RrZDVzeWJnb2VESW1HdVBmK001VXpWcGlZM0orWlUzZmVZOEwxQXAreENyNEczaWFXeVZJZTNXWU8zR2ZTNHk5cnJacUhhbEh0WE9Dd0R5UXQ3TGZoSmV0ekhJdnd3TzlxZWNzZEs4amZ6OVZMdkU1L3UxOVA2NTYvczUrTWoxMXh6N1NLYWVjOTdGbXZONWZacS9jRHFqYVYxVXZjcjljOTlEdGU2SmZ5dDVOYkkzL3BRdnRodHpOMHpIa2Z2UDllZCs4Zm10MWJTaWJIMTl1ckJrNjdmcUUzbksrV0NKUE00Qi9RLzEyRXowdWFQV24reWNJaFBjYkRFWVQ2WDFBTWU2c3M4UWR3L3lpOXV4NWpoRkxxd2RkNEtBZ3Z4N1NHcXhybHByK3B4TTNZVEFRTVZ2ZWtja09RbVZYT3pTUlFsc3prZzF3dUJkZm1tcll0bEo5RGhMMmorelZVQTUySEhLZEVrb0pvVEJhR2pzdUFTcHZ1QmFIY2dZaVpSVUVIYnFqY0ZBN2liTUcwdk1sVzBqMnBvTDhqWnAyOHZmUWhkME5qV09SWGtLcm9BVW1QcnY3eHZaQU4vRGYycm9PRWhvTzVEZ0ZoZUZBYmtNbStZTXZGbFNkd0V3Wmh3ckJYQ0VVdUcvQ3Rjd1FEQndCemlDcCtqU2NxMmQ5RUxsNm4rM1dBSmw0eWlFY04zQ0hZR2lGamdSVi9XUW10Z0ZNMEl2dTA0YnpqajVTVlNkc3JVWVdVN3A1Q2NsU00yeVJ2aE01Y1pxcFo0bGo1RHA4ZzBtN0hLUEFiZVJlZ0swQ20wYXMrd2FUSkRaMVNtbG1jaU5naFZ0SW9Zcy9iNGlPSUJvcFE3UjhuRi8rL2lmd0ViK1RuZzNCcFlIR3ZTRGRDVDZ6ekdEOVl2Q0hES3c5SkJEUDBKdHR1Z0xXUitzbzVUSVpodGJqL0VxVEFwTWc5b1B3aWpPTVBWZ0o3aFF1WWxCcExudmxGNmVQNk5heHR6akxqcXhDdnZubUFldVV1ekZIMTRxR3hqeTVPZCtxbHZyVjRMWU1PelpiTjhzS2ZMSnBqT21tYXFWNEI0YmwwYmVrUkdydHV1bnF1MlhSZTlhYnJxdW5QTXBlcDRxZGhteE51NlZZWmF2R04zRHpWVDBUZmVjTVlMYjNqdEd0aFhlditPSTU3c204ZXZvR0J5aVEyeWtOTDNLd1hMTFBrTHBxNENpcDNQQlVGdS9nRHNaN1NWeVNRWmNLS1VSM1ZQNW9QZlplaVpSOC9jdUxuNTlDWVErU1o2WnVzTHAwNDlmZktrc04weVF3UGREM2RFMEp0VDBnQXNjSkJqZ1dDUUlkaTY4WkNiWTV6L1FYbGQzdTFlM24xcGdaMGxnUVkvN2dUdEE5SGVzbTA4dE5mZjMvSWR3LzZidmRIKzFBYzk5WUc5d1FGK3h2bkk5cVVsMk5sdjJQOTFiN0EvOVd4azJ1aXEwSEpQMlViK2xHdUZVT0RSVTQ0WncrL29aekQ2ZmNlcEJYSGttcEdyMjhMUEJETGlMOUN6d0dzVDBvcmdEdTd1bStVVTBtOW5pU01pS0FDZk1CYUI3TTRvQk5CckNWT1RoK080UU9PWUlBRTlQb3ZYTWNjWHlVSk0wVmRrWFk0ZGpZRENIUyszMkdJdjlXc3pHbzg1RTJPbFlYekZubXZtd1RUZitoTHh4dW8yc1MzWnFjMVFVOVdlY1E2ZE1EWFFnbWJ3VUtBVFRmNk9UWGk4V0RHdHprVEZ3RWhtRnFpSDF1clZNMDZyeXpDQTZVTEwzTE41QllWU3JLenlTRkpKZTQ1SGpBelRBa1dyYVBtUlA0eS9xeXVpazNlQjdCWmdTSVFVbVhpSEJLaTBncnNDRVMzTW9tYkN6VEZXNTF3Q2ZlSDFSTHkrSnRBTmg3dGhGbGxzekdhZTllM2VvcVBPeW9JcmNNOUhGVDNKYyt5QVNiNEVxbmpQdUVkbFFEZTllWTBIekp5SnY4Q2xpQ1JieitlSUdWa3k3NkJpUU5DVnRPNGdEbUpPWW9vdFUxYmxmQkNUUmkxblJNVXNPTktLMkFOYU9YTGh2ZjkvQlZDUFQzanZldGREMXpIR28rVXVzTllqVVpXZkJ1VWVtQ1NCbHlKQkFVNndza0tvVm56a281L2h3WFZFbUZvdCtJdy9XNjNGZEhtK3BNVTFFUWVNM1lRZHkzeVN6NkFVUFNNWm9BRTlTUUpBR0kzRUpJalBmcFN3cjU3NXFaUFZ1Kyt1bnBRZlgrcDBPbCs4L1VOL2NMSjI5OTIxazcvN3hCOTBidjJEVG1mYkwva1Y5QkgwTERBVmtRcFNHelFUUzcxaE9nd3ZSZUY0WUtFcjlCQWJYbjRJYWsyaDZhbVBKOUZVNnczamM3bkM0dHpMVnR2VGNmTGhJMjg2V0R4enBuZ1F2eGxGVXllMy9uVnFhdmJXcFg0U2hrbC8rWmIzclBmajNIRGxsdXQvL0ROWEZxRFVsWjg2UDNxWDgvQXVzOUlTMEFKWTVXTDgrczJJd1pjMjAwaUVNZ1RjQlRhZFh4aFpNcU5nZE5yaHBpMlBSRGVqZm5lMGl3WnpWSzRYdXd2dEJidGZVY3VhTFdPZDVYVDlaaml6dTk2bVN1aDlGYk9wT0IxUEpsV2ptNStkSzNTL2tWc2VCd0Y0NUJBNmZBU2hIZ2hFOTg5TUdhUGx2WHYyN0ZYQ1hIODZuN3dhREJ4ak54Z09UOTRGOXNFVkpoVTVMdDRPV2NaZ1RMaTJUTUFtckVwTktRVXBOU2QxUWVldGdLeUM5L09nN1F4VS9QQWx2K1IvNC94NTlkNTd4eTl0dHE3NFh4eWpDK2ZQUDNpdmVtbnpnZi9GNFdWLzl6UEMzKzFMK1N4ZjV5V0kwRUJOTU9tVDU2ZE9JbU1uek50MTl2elpHKzdOb1lrTGY3M1RMLzBKTkxuMXB6ZUEybE41M1Jqa092QjlGWHJsaFBTd2RFSDZiZW03d1A4OVVGODdrd3BFM0xjREo1dHBHMVRnUzV2QXdpd0ZDckJBK3FQNUFDSnpJV0k3Y2c5R2tlYzUxUHdQRWhYU0xNOWhEV1VCNTM2VzUzQXBDNEswUjNFWlVVbWJSWmszcXpyeUZTMnNvL2J3VWhwRHlOTVlPS2FCMjhQdFBJWTNJWCtDRVVVdE9TNTZrcXF1ZzFCa2htQzV6a01YMWtSdlBSK1cvaEIxTUZZVk1DZW9BbVpwYkJCNVJRZ1AzR3BqSlpBZmtoMjc1WURsSU5zZ1pXeG1hR0ErMllRR3ZxMXB5TFpjMDJQMFhZcXY0TGljTXpXa0dublY4QnlRVVZBYlJ1K1V5YTRyWWlEN1ltR3BVeUN5TXRoYmEwWlJOVTVxMWJreFN2QXNzblhQRFVIeXlaRnZFTkRoc2c1b0JqSHNVUHd2cWp1SGtTbUhSazB2WUFOREtkam1zSXlvN3o2Mlk4aW5aZng2UW55Tnl6MFZCQmtLVlBaK01HL3V1a3RSYnZQQnNqT1JwaWczRU9xcFlBK0M0UVVXTmZmallXU29zU3dTSG93VHZ5SXJ5Z1lLS01tNVVjN25jaExyM0JyN080U0xHbGNvQ3JYenRrd3dtYytaVkZpWVJIZnlDbEZCbk1JQk5GeFdlTEtTWXpvSldJNGdaeFcveEgwM2djZzcyZ1YwK0RxZ3dNZWxKNlducGE5SzMrRVNGcW1vZ2xwb0FlMURWNkJUNkJ4Nk9ib2JaRktqQ2Zxa3p4M29YQ2kxT1UxRThHVWdkSUFSdXYwT2NDWDMvWEx2Ym1ZaFJSbTlyaUhoKytvbmdtKzUzQUpxSEoyQm1sTCthU3hBeGR2Vk1uR0s5VE15anhnM3M0Wnd2WUlpeHAzNFVDS3paK2pJYUJ0Q1BTSytISGVoVEppZDQ1QUJtS1hYQk4zYzdhZDk0UldDdGdxMHc0MmUzZ3E2ZEJ1UEtxY04vbkpSbUxXdUw3eFdJSHBGaUtzQmhaTXVzRTdVVGJkakNmQVkzb3dreTdMTVdzSmxObjhRL3pLUVZhUGJzL3FnZDRDZmlBQnFjSjYvQkp6cmlCN2szcWtoNkpXc0dyeXAwTVNoY1V3MWVvVHFhakduTzh1T2U4MXgxMTFJakJScEc1c0pSWDZrV2l6am5DSU5XSitVeWR2MDNVYkFEM3IyeExneHBkVnhNVERIcWM3eWo1cjJyRGFlWkN6MkJZQXZUR1loSmNpbG1vZmN0RWhOSXd5TjMrQUpjenF4QU0vWGFpNVBDdkhZNlNGYVROdnRZN1ZhUWFOd1JhdldEUXYybUhvZFZtd2dSMUFydVZLaDdPV3FEZHFrUWIzaDJvbHh3dk5TQmt5cisyNXE4andFYWtTUnNUb2NRbFV6T1NmSGkvcVZYS2tZaDhVM21RWUtiVFZrOVREYXZTZU0rcVZYK1JOalkrTzc4L2w1UFlyMFp6R3dCMUlvd0Fjd0tYei9qTzhuckZJb0FCemg1MDl6cHZ1NjR4andsODlybXVQRThZMUJFRVdheHUrb1ZLSm9jQTh2Y3haWjJIc0wxcGh0cWlTL3o2ZTZ4VnpYMW5VTHltR0ZPbG9CZUpHbjZlMnprVzJiNDA1c0VZd0pkUXhlUkZib3o4RWI2L3B3OSs3NStYMjludVBzR3krWisycXlDZ09ocS9sOU1qR29McnZNZ1NzMlZERGdmN0MvZS9mYzNMNXlxWFNicDhoSmt1eUw0MFpvMnZaY3NUU3Vla0luZkFkMHdrZGd6d2MwT0NrZGtVNUw5MHR2NGZZaDVlNEprVHdpc2tVWWZhbHZnc1FEanZSb01uOHBMcE9Pd2plTlVmYVpDTjd3bElzTkpNaFdSRzJTeXpHYXNnaE84R0pEZ0JiRFVXeUdVNms0aDJZZE81ZXpuWGxkTmV3ay9PNU9ZYjIxYVFhSWdpVzBUaFVOdVVqM21ja1VwaFBkSlNEZkRFdFhiQkRQVkxIa3QrWERibFFPQzZmQnNFVUJpTG13MEE0YzNWUEMyNkk4eXNkajBMY1VNZGVqZjJYWkEvdHFxbG9hZ09jdjdSQ3E3MEN4eFJUak9wbG9scS9iSUFCaFVIVE5UVUluQUFxVEEyTVE1dDQybDFjY3o3T282cWxJTGxxdXBycTNIRDE2QzdWZFpQdWoyRUdtZzAzbzc1dzB6ajBuSTQvU091WU9KYkRJQjhPa3p3T1B3VXY5RkUwQnNFZWV5MUdPK3ovTUg1dWJPM2IyMlB6ODBldHI0K08xbzlYeDhUKzczRW1sLzNwRDcxU3ZVTGkrZjBQdlRMRlVLdDJJN2hYRkVkL09iZjJ0dWJoL3lmem1OODJsL1l0bzVVWFI2SnU2MTNjWFo2WVhPbE16aTkyWlNaNzZDNjNlYnI4dUxPcHB3RmFyWUMvZElkMG5QUURTL0NlNVY0dGxoSlBFTFM3emV2K2VSNnVmZmFkQXNzR1lweXh6Z3dOUlFEOE0rNVIzUWlmcEEvUmdEZTZaRlE2bHpMMEtlaDRJcG9KQkFMZTMvV0h3R0NMd0FhdHpRazFINWlVbnR1UWFqZkVvTmRQUXh3bHhGbmNTME9NendCZmxtWk5OZGN5UDQxc0xyUUo4OWdZVlc0dGRKOUdjY3RBd3FhNFZJOTBHNjF0VnRaeW5KVlRkeUlkSkVwdEdBamI2eHdyRHE2NjY1U1I2TDlVS2dhTkZxb3ZqdjdOVU9tRE15ZWZ2MkVFL3o5cXg3ZHNuVGd5SGt6NS9Uc0YzRThvQ0hiazVWd3NZUzZaMHpTSU9zRGpnQW9YSnFxRml5OUIwMVZSTGZuTGNOcGFPTjkzaVdLbmxhdlRYbXJMd0ZSeXYxMGU1VU5tWUdJQjdVMEM2UjNuK1g2dmZhUzZJK0hXam1UU3lydUp4aHg5aDRtWXlNbDJqZUxnZ3pOcDAyR1lON25ybXNLNXZvM1lQb0dFZnVEWmQ0RzVJN2lVRDVrUlBUY2lVTVlyQ1BBNmpLTVJVVlc5NkVZTStzQVJLM1EyS2xVcDdJdUFXMksrT05TZHpwVXArb2xuUGRlcjFUdTdweUxQZDBIdndEWDd1NnpXa1dTb0ttendyVlB2OGpxNTdTNjFpK3I1VDBwQmhKTTU0UVVPT3Z4L3NmYTFrS1VrblVhelNLY3ZEMkRNdEQ1MzNvUTk0ZnZvbStqbVFhWjRVQTlhZGtIclNYc0M3TjBvUGdtVDdXZW5UMHVlazM1SCtSSHBlK2p2cEJTUWhDeFhRcEpCNFBFdWdFN2UyNHpMREJ1dTJrd2JsT1FHOU5vaTVpTTJCSk91eStlNGFWOGdBSTRLWGRtZkkwNmFIUEl3cG5KMEpZTk1VSURUanMxZmFBbWwwZ1k2NUp1K21vMThnNEN6Vmp1T1lIaEI2cjVNTTIxbjJaZ2dNRUErNktXMEFtQUdtYVhKMUhmRVVocDVBRVBFd3BXMG92RjF4bGFlemladWhPbjVwWjkyWGl5VXZPczg1QlM0a3ZYN0s2QUpnOFc3R2w4MW9JY05PUXhCTkFnWlJGdk9rY1BUZnFFN2hzL1Y3aFAvUVYya2dWbS9oc1NDZHNaZnp2RldlVTg5UjRjRVhVWVRVMm14Tk5zZnloV1p6RW5hZmIrVHpEZmplcmJyQW80cXF5bURjSTc2WlVZbWo2NjZpamhQWnNhaXN4Z1M3RHZ6bXhtUkZ0U3hWVmIyZzZLbDZUZ2ZsdWF4b0dQaFRzVUJFYXpuVEpRcXpkcXVLWTVpMm9qWmtYVnljVkVFZm1BNW9URzdheXdLeTBxeXBHQ21pWWMxQ2ZrdzByRTBZZzllQ2QrTy9DTUI5dGxmZ09ibVl2eGkvL2ZRT0lyMEFkeVhsa3lmTHVmYkdUeFdPSHk4V2p4Ky9uYWtNakk2V1p1cElPUHJFVDBzaGhtZFEwTmNBODVrTTBFS25tSnNkRkVBUHBoNHpET2Fac3BjWXFzTlVzQXE0MzFOcFJTckdJdkdEYVJZSUNVcElVUUdJQXhXMUFJakFkU2JqSk1qT3ZCa01HL1JHeEFlQmo4TjVCUUNNb3BDVDdZMTJVcjd1WkRscGJVb2dMYmJsQnRmOUZXa1c3T01iUWZmL3VQUnp3Q0cvemlYNWlCOEFKRWVNRDN1N251MWxycnlYVWo0WHlHRCtjUlRMa1RpUHVRMDRlRjdJMG1iNEVlVldIb2NDeldRNHp3TWFsOHhGVVBvaTAzMW5KZjkrSGRGMkhSeXhRblA0NGFDZmJ2UHM1MDFQQThWN0p3Rk56Uk0za0U5NFdNeWt5di94WXZRUU9PT0FRVEVLd0lKU2tDM0h1V3NEQlJST3diZVpRNURzS1ZqSGVHSlREbVJjTURCWWRURUs1UkIvWlB2R2FPZDlkQ3p2T2FCcXN0dG00U1pYOXBCeUVHU1paMnBmQnRIbVd1b0VMbEtmNEtLcU14azlzb042bnJSdGNodkdzbHlnS0dlcGVqR3dmVVprUmplUmZPNE1tSUZwVzFIV1VZbmVNeXBZM2xrT2pGVW9WMWZrTzJWWlhqQTkxWElCMk9rN3hqY0hXdnBxa1c5NURqVDFvOUk3TW1tWDltRjBmM1Fjcy96dmZxL0xkZkRJVHNteVlvV1dFRVBTWjBMQzlHa3FyQ3h1ZW5PMTBCZEpsM3lIUmNORVpEM0I2V0UvdmhTNHlxSS9mWjVJMjRWQmk3cTlObnFYQ2FBaE1qLzdvZ0ZhTnBtbnk4VDBQVGVJQ3laemRabmFYdVNIU1hGZnNSblZWWldaeFlOVUJlNnBqb0hjSWROajhQZUdjdWlZdU5xMHpNaHk3aTB1VkdyRkJDb280UDA5Wm96cHp6aGdyYkRnb3p2Ni90c2VjTHFNWllWcFBNUUMrcFVmRWMxc3FORmRWZlUrSjFMS2dOR3RiZ1Y0WHpmZWRDMzNEZGJmOUdsV1prY3JEVVA3dURxdXVWNjFQTllxVmV0YVdZMFd1RFd3VXk4ejBFbmNGM1ZBT2diOUhpZk40ZndHZmttdm82R1lBZEprTVk5VE41blFBNENRQnp4dlJDZ1NibDlTSHMxbWZJSmlBa3pwQ1BNVy9TbFI2aTRXTWIvTHZYZHFZeXIxWlhjVEpjSFkyL1BqK1Y5cmdLVmpHSzZ0VUMrb3ROR1lvVHVSQzNMRUsxWFRkOVdxTGxtZFZIdmt6NUo0aXVqdjJPbEErc2NuN3pwamdxZzBmdnpKSnpzRkR6cGNSUXpWV1huT0p4cGhxa3prcG9yS2hTZXRkeWZKeUlmMVZmUnY2SXRBZHlWQXVGS0xKeDd5dEVTWmc3akxjOEVTSGtrWlpnNUhlTDk0Z0s2VUovcDFDdDlUQjVZWGx6VDFxc1dWemRXN3FuV014NXF2djhlYWFlNWQ2RTk1aGU1UGZyWlFKNU84Nk5hL0tSUHBRL3MzWDE0c0tjcXUzbkRYRldzcnUzOXowSjlzbDRLSnp6MWdya2lTY3ZFaXRPZWYwZWRBNG9XQUJpWjVsb2hJell1VHRFMlRiZXpaWWp4eE1oNnVZOEluSTBJTGg3VDlsa1BOMjRaN2xqZnIzNWcrNkMvc1g0QVBXbmxuQ2VmdVBialozelMzM3Z1eThlRk5LeHVUaC83Nk5kUHo5ZFp1QTg4ZWFmSlNDd05XdjY3MVMwcXJldXNEeDU5ZVA3aDI1Mzd0VGVyRWkvSlJDOUtZdENDdGM3L3ZLRENhdEVYRFdGc0lzM1E0NE9hVWtNRWhlMUdTcHJ4ejZoTmExOUtaNWdvZ3AveDBmcXhZc0h3djhmSFZpblpLTVZYVjFJaStkdnZxNnUydjU1dTFxWU5UVXdkUDhnMXFxNDJ4dGFhaGxhWUwrUkQ1aWVmYjF4UDkxVUQ2Y0JmNTN1Z08yR3lkSDkwQ0d4RTcraG82QlAycGNnL2xKZFNVZGdZODJ3a094ZVF1akE1MTlpMHM3T3VjZ0tiTzdPOU43bHVZUHpDUFprcFo5L3dSYkRyN0p2cjdabWYzelFoZStRRytHejBxelFGMnZWYzZMNzFIdWdEakJOWUFuOERTR2MzUnZaUVZ3WnFVZFhoU1JoYVliV2J4T2JBQ0Vzb0RlZHo0VERteFpaT0JFMzZmbUcwRkpNZnhMYWM4SHNob1hvcnFaaGtlTHo1c0R2dVhEL2lEV0JUdWpBVEhUOUJqSy9sOWUzT2RWZ05VOXR5WTA2eU9OeXVUdWRoQUJkOHgxVkExNWhSQUFDaTA5cmJybFZTMVlrWUlpWFdmMUlwdVAxZTA5VktoWGNpVkR5ektTalZuOFdSTGxVMHZGNnBiNDFUWDZUalR0RGR4V0ZEaW0wZUlFaXRFYk81bFNvSFBQNFROZS9pY1BjZkxsMHRUMWMwRll5SVhFa1d6aW9WcHpRa2kxZEFZUEg4Y3VIU3BZakxhN3NSMkxSL0xqaGt0ZDIwVkcxYlNDRDBsYjVqYWZMVlpNL0pSR0RiYTVRblRjdDRGanhkdG9QcjRxQUd3eVcrM2dGeWZKMWtEUkZoUUJSNzdJa0NOcjRyYy9qendmVTNrT1V3QmJmTTVRM3g0cW9nbnQzQlhNTThZaTVpSVp2QThmL2l5dnZoRi8vSTkwL3llcm92dDl6NTk2T3owMlVQK2NQaGwySXNQSHo2OEtJNVE3WU9xK2tGcWZ0Q2syenUzMzkvZHVQMzJqZTVFcS9WQjJHMzNlcjFuczhOTGMyRC9UL1Mwb0ZlZUhkbUpoUnVzbjRqY1hzRklRaHBBYzdaajRxUGt2U2FQZ3dHOFFKK3dMZE0xQ3RmVmxsYXZFdUhwUFFlV0I4M1AvK3hhdUhsazcvajQzb214bFhpbGVtYTRldXNLV3IzMWdYUC9EQ053ODAvdkg1OFFnZXpXMks1WDNsTnR0TWYzSGRzN1hxODA1bnNydHo1NDY4cXlzRlgrRUhmUlo2UjkwaFdnb2ErVHpnRDl2eHpzNmJ1bFYwbXZrOTRFOXNyYnBYZEw3NVYrV3ZxUTlESHBVOUl2U1orUm5vWjNTTVZVbHpTYkZkL012bHhSZ3g1TlJOWnJsZHZKbzIxbjJNMitITGhsODErRUxVaFNnUDNwc0EvakFRTURiSmIwVTc3VFowT1NzSFRJUUZYeDBZRlBNNEM2UW5FeUhUWjViVENBR3lqaGFwNmxVZmJiVEVBOTlidGdORFdFNTVGUDVPZ3k3aU1kSnRta0RvYlRMbGJwSXRoNDVDNWlrN3NVVzBPTEdocndKTFFoWXFTM2ZlVVZpcVdoSG1Gb1NCamR1bWQ2ZWhyTmRKVkYxRlBrN2l6bWgvdFJjL1BjRjQxWXYrYm9OUWVQN0tWdnZFbEd5L2pjTlhlL2F1bmpyMVZNNWFySHV5YkMzY0hxNnBHSnNiSEo0OTRyR0tEK1cyNDREOWR1dnJGOUk0QzEwL2NUS3c0VmI5ZFFpWnF6NkErdlUyU3EzU1JqNFRXa2ZPcmh6WXFPYjBUQVNPaXNqSW1HVGlsd0VaaFlnWXY0Tk5JSWxzOGl6VkQvNkdwVm5qY0grQ1lBNjZkeFQ1OVRGT1NxemxXM29FL3N1ZTIzemVUa2lldXZQMzZnaFBZZzlISkZlZm4xRDcxdWJaV1F3UUFza0VHb3hodlhUdW50dGpsejByOGRMSXZUWndrNWU5WmsrTWExTlRYeTc3d1p4Ly9wQ05uT0NSRnpyeE93ODZXaGdHVkpNNE1SSzlsTVVqaUJta0RNV1FZdzBJUFF0VmtNZGdNTTBXN21UWnBCeU5LOTRsRTdETzNseUkzNE94bm9WMC9Yd3JkYlhsVDE4d1NVdXFuWmV0V3YyQVorTzFudlFkR2ZsSldOOG13RmxNNGI3VERJVjl2MWlRSU1XYjFiemhzMlZRTFRTNnJ2cUVTbXloUWFlNlhLN1d0WlVlNm5FTG5mRHlPZUF6VXZYU085UW5xZjlHRStvME9rMTFBTytPT0lUMXJnNmNBaS8wWWthVXloek9FRjhuK0tCK0FCUFBWNW5LbTl3WmwwTzM4UGlqT3hseGtIL0FMTkNnMjQwMzYwRDl3UmJ4ZHM4K0QyNVJUQTdDR1psN0l4ZWp5ZlhONGZwN0xwYytQTkFEUEN6TmNZS2JXYnN0RUtBSENZQmE5R2tVb016VkIwR2haZzk2dElYbVlhbGc4N25teGpTMXNLSFMrWWw3RktJa1ZwS3VqZVFoVXVxNEdzSUYwMnRkQ0RmU0NWNGhOZzk4cFhFc3pJSHJqVFVDSjd6dkg0RkZLMUwwTzFQQzZEY1ozdEd4UDNGcFg4OXhJakNJaGNHTStIMFYyUEdJbnZWTUtFVU52UmJpSjBIeUlHc3hPN3ArcTFta1dvU3ZhTjUrc3FrY2MxWnhOK3pyVXJXSWxBWGRyamxoczdoZ1pNUjNueTNNSEgrRlUzZUZIT1VDQzFoRmRKdXV4MkZIUGl4RHo3cENIRWpYRDE4c1FPdm1vR0Y1d1p6azlHVXk4RXFQblJrMGphYzErOTBhcmZ2N0g3dm5wejEzQjUvL0w4VEc4d096L3NuU2xWaG1lVzY0cWpOand2MHFwNkkycU1UMVJuZjc2bSs1Zk8xQ2NtcTdQbzZWMkx5L3V1V0JtdTcxNWMzcnZydmtaenBsSTZjK2VaVXFrek03K3llR2J3VVU4enBvTjg1UGpSK0pVVFkxNTQrVURhem9VNUQzaE00U3NrZUh4MmtZTzdmR1pnbDg4U0F3SFpUSnNmK2xEekFMbi94Nnh6dDlBRnVUOVFQcTY4OWcwVVhkaDZkYStIZnVMb1hPZW55dVdEYmN0Wm4rM01RWjFJMVBtOG1ITWtJWjVhMDJYSkJxb1ArVC8wL09aZlBCc2VWMS85MW1EcnN5NDZaR3o5cWdjMXZlZm8wYk1UMDlNM0grOGZGL2MvaDU2Q3ZpOEovRHhDZTNFeXlKUVNFbDRtbnNPUHJyY0dTL09sMHZ6U3dJcDNOYy8yTSszVVA5dmNGZjlrcmxxYVg1d3ZWWlBqemZhVTBFUlQ3ZWJ4a2Mvd0MzZ1MvVFpZL2JkTEg1RCtDdDJCWGlsSlFYdklIMEdUN2NsMmZBWWpTN05aUWxtMlZCSkdOSW5hS1FWUVJRUWE0d3N6OEdrVjJhb1g3UTNjcHl5cm9FdWJJbk9heXlqTzFEd0hubGZMUkhCWHpLdmhJaW1iQTBBWlo5WTAyNlhjQ21vUEwwMlVuK1ZHVHl6bW4vTmp1RCtNWXNCcmMySUdVL1pKK1UxeHRCQ1AwbEpZeEUrMEIwTWgrellRVGJ0OE1sL2FiZ0VZVE5yRFVRZzV6VUlYZ3lHWXJ0a1pjYnVvc1MxV2c0bjVraVVNYk9Cb01JUTJaTUZwa2Y0QURlOXdtYkxCMDRLNlF4c0J5bVNwd0tyd0dpbDNBZklPQUp5Um1UbXNtZVhCOEJhMXI4RTJrcldHZ3JCR1RTZUtGbTNtYUdia1lnVmpFK09vYXJqQWt6WERZaEZHZitvbFlRaG12UXhDaUNtR1RpMUFkbGhSSmwyRTdMaGFzdmlzdlltRzVuQzAyV3VCeWxRTnArai9EMDkzc1YvdzNWcERWY3ZZTW5VRDZhMGlpQnFrVERpV29jbUs0MmtJSStwVm1sTlhUS05QTVk5WVZKTk5ONWFoSVl6cVRIWXNYVnZSRE1DTFdEYXRRQUZMMlZKNUdrMUg1MTR3MzFVTXJDRTJYd0hqc0pqRDlaeWpNV1ByTkhVVFR5Zk1WZTJBNnBpNWNwWlpDemRvZ2VaUy9sQy9ERzhQR2xBMm9JOThCeU5kWTdKbnlhR2lxM0NGdWFGTFhaV25GQ3N5ZzNJMTAxUUNCS3JGcVJwYWtndUtzdWxZbnA3VUtsdzhlcG9qNjdGRENYb0lCSytLemxSOFM1M0lHWXo3MW1TRldDdVZWdUJHRGliUXU0a2JJOE12eUNnT1pIZXNWQWliYi9EQXNPWFJkc0xFckhSZEpaakh6OHN6VUxYbFFkT2QvQ3hTVEFBUk04dDh6ajdoeWZPL2JHdVdYUEdOd1ZpMUNtZGtJM2Jka2h4RmlqdzVaZEM4Vzk2SWRGTlhFOHRsMWtsNUhtT2VtVmhVZWU0V3dWWmRwNkNHUTZRdThEaTlxcHR3MmxkZGFsQk5WMnhqUXJPWXIvbEZocXc2WTdVS0lRNWpIZzdObGxmNlRVTkh4STljZzZnR2xIZDBMSHNoZ2EyTTg0SG1hdzRvRk9UNlJZV0J6US9kcEVYVUt6c0lLYnBzT0MyS1lwN1RwQ2xjN2NBOUFWRVY3TVBMYXo2ZmlJbUk2aWFZeGlZRFNrU0VHb3BXZElDL29YbGdIQktaeGFhRnZFeDJQb04rQ1QwaldWeFNiUnRpd2lQbkNVc3AwN0ZsbERUUmdUOXI5L3Z0Lzk3dWIvMFBlT1hBZXBjVmRKOUgxdy9iZjlXYW4yK2hYOXk2S2JCKzBnb0QrdzM5eTNPYW5nVVpXdUV6Yk5Dc1BDZTNtMWxNYk1UaW84aVlMRUtWVFdHdFJWMzBGUjVRVldTZFVNcjlHQmhyc21aUXlyMFpOWTA5OVF6L29qZGlxbEpaSmdqem9CZWxwcXFvTXVJK0Q3YjFNMHg3NWluNGNzd0NmNEMzSGdhN3BnQ3Q2QU5PdnhiYTBnWHJJWnNCME12azVLVUlWdm9mWHdLN0k5cnA5V205ZEJicVE3MmVIWWQrbUV0Q1AwaWNUYjhjQktYZzRXN1hUZ0kvekNjUjZDWjNGNXlDRDlyTGs0bTNVNHEzemhmYTdRTGlXN1Q0RDVFbnk2clduazgxRmN2dXNoMkVoVEI4NHQ4Ly9hWEF1aWlKU21CYmF4Y3VTcUltMklvY3RZdGJGNytDdm9OK1MyUWo3ZVBabmlQZDBPK0JlZ3l6dEJ4aG56ZlpNT0xwQ3NMdXBpTmNPa3FURlFzbmNlUVFjd09FMjFvc0diVHBIMVFUT3djSXVuaEUxNUp5dzdoUURCenJWL3lyRDlaWTNRVmUxSFhnUjJiZTRDVmxQOFpVcHRkWVZrN1gzUk5YMUpMSE5sbHViTE9OcUZsd0RCblh1cmtZNEEvNnBNYWM2dk8vTUN3NUxnV2IxYlk5VTdmaTh2aC9Oa0RrVWIxTUNhRkZiNlo2YXlXdTRFeFBQNE0yZ1g0RDdvVkpZUEFjM093UDAyYS91d0YyMmVZNWRzTkhyR250ekJsMjhvUDJsSFlPM2ZKWi9jMzZDZTNNcjJubnRSTmlLcEk2eW91OVNTS1NKdXhmbmhQZmtnQmJCQ0lsZytkcXRMSThDNUZEeHJMZEpuOWFLdmFqNXZIamozV3JWVFNSL2Y0ZC9QRGZONEFoMjBQaHIvemdqODlNL0VwcDR2dHZQZk5XMkU2YytlTnUvbGNFUG5zT1UvUzdsM0xkSk5MbkdDd1ZxVkEyV0xpQ0FvWFhneS9FRkhWNUZKRC9JcWx6MUhFRFk2YlM2OHl1M25UbTRPSGppOWY0K1dMKzRhTm56NTQ5ZVBEZyt2cmlUYXR6QzczS2pCRzR6dEhPMFlmaG9uL040dkhEQjg5ODVlekJIMThiNGNObmdEK2ZGWEcycG5UblRsL1F0amUrNVlrbFozWTRPbVh1WHViNUFzMzVCYTdVazRWWnNSNFluNGJNTWd6QmJkaHM2dWN3VzdFbWd3R0MySklzOFJaTk9MRURuOWNhZk9zZ09WK2REdXl0YjBmVmFvU3VqNnBYK2tCU1JVdVRpNUZPcG0rYmNaaHUraUUyTEN0d2RZUHFDdWhIeXdzODIxUXBNUm9UTStPT3JURFZCTER1V1laS3YyRjZYczZGdnh6Ly9laFdQeTZOKy9QVkdKMk9xOVd0RjdxRG91Y3hXZEVzU3ZJNFVLRmxHcFVSSnN5TThxVjBqQjhyTEZKVWJrYUN4dlNJVGhsUlNjaDRjdG5sL091UFNDYVhtendEb0N4V1d4S3V2WlFOMi8xTDNyM3ZydDIrL3QzVjIxWlhiMXN2NTQvRlRtTmwvMHFqc1lJdXJMeDg5Yit2M2Y3ZzdXdGJGOHp3cWxLOXlVL0ROV2xiTHI5WDVKWkdYQzczRStHNzhvUkxYL3l1SWZUdWQ4OHZMcDA5Nnp1ZS82VXZmUXZWZnVMVGozUTY2QmcrSVc5SnY4V1hsWkgwaXo4QWUvUDhpM0lyTCtkVFNpMFJ5SSs2UExsSkpHUHhTRHhnSDQ3dmJKU0FxTnRPQXVFaVlnTzFSbVdHby9Mb1pidmg3L0R1M1I4VVd4UVpVd0VaczNWYnNjUFMxaUZxbU1YRmV4NzRoWW1pWDNXMEgzNWZGTW8rZjdMeTNyVVRLNCt1cnE2T3E0bzhWdFR0ZURVMjB1blordTQ3YndFKzkxb3IvTy9SMVcxLzYvUG9GNkF2RXFrbVhjVmo0MGxMU0xGMmVna3RpdW1uMi9TYlJNM0J5RE85dlRaU1J5UWhjT2UxWUNoT3B3NnFSME4wMzl6V1oyNGU1QmtObkVyaU9KUXFvRlNzOXVrTkt3QnFzMzcvaGtQTkhLTTVyenpjZFVYZFZodkZYTDBZb1lBRnJaeE1Jck91WFhtdGpJNitKd0dTdW1OM3RWcWNOOEhvY3pST25uR3k5NVkvMTNrdDFuL2FkZjM2MUd5YTk4Mjg3ZlNTem1RakY5Wmw2c3BnRzlyRlJ0alNyemtsYng2WFJubWVvelczdU5aS3hieUhROUpwa2VjOUZJdjVaSUFhWHBGeEpKcnlNMktiUm1HU2FhMTFNVjBWdW1jZy9LZThkMzRra1FPSTlaSlAralFiTHhmeUU5UDVieFkyNjZXa0dwdWZyQnlzcTFGYUtWNm5zS2x1S1dqNmxmcUJnT1VxeEhRcmM1U1VHNkdGS3N6TzFYNTdaOTdKNW1WWDg1OVh1MVp6eWxEd3dkaGxyU2tqMEg4djBleUZvWjFQVG1pMlNRREU5c1lyK1NMdHpicnpKUVVyMDZiTjBjeDhTek1pYStmcURGKzk3UFVXODdHZUE3djJjOEI3Zk9XRUtXbFoyaU5kRFZ6eW9sVVFZSlQ1NEF2SHNYaDkySXVaNkwzbU9tSzlQaGRFNHBETmlsVW4rUUdmZDgwN3pFYmNzdDJleFhKemtrTnhxVCtqYVF2dDBOS0M1dnpZVlBmV3IweU9yZTlyRmZYMVE5WEp3M3QwTnV6T0ZRdmw0LzdrM0ZyTjZ0My8rMlo1Y3JiZ3MvbWRFOHJ1SysxcEtUS2hjUmpXdk5SMnk5NmVKVE9QbDNaNVZGNDQvQ2xabGxubys4NWtlNjU4NVp0YnpmSHdta094VlRwd2xER1pUaDhjNVJkalY4U2tqSkhPNC9NK2hwN3d3WElIWGNLUStwYVgvcUdycnoxeEFqNG50aDYvOXRvVFg0VWRmclROV3grQittcFNEempyUG83VHVFbEZMNG55MFNwVW1YT0E4NU04V3ZXdmUybDFwVUdjRGtUQ2JqdGJuMnEwcUNmM0xRZ1duRVhiNmIrRDdYVDRSQ1NWaVJXYm9LODNqU25EcVlHWm9MbDUwL0ZMWGxJcW5McnR1bnd4ZG9zQUFHYVR2Q1VUUWxUZGNnQmhnTUJZb25sZFpUeVNMNU1BZ0FJZ2Q2d1k2cTBnb25XTDZhQVZ2RmJVeUFmSUQ2dGhhRVlXaFhPc3luaGtYazNRSVJZeW5ROGxzeTNLL0VKdHF0T2ZudXpNVFV3UE9qTzFvcnYxVmQzQU1vQm12djRtV0FteXVpQXpEeXdhbWZDa1dNSXRFQW8zZ3lWblVSV0JyWkZRM2JPNlFheFRSMVBBQUlrVVdwdXVqdndJdkgvTFdlNTZ0aVpGTmw4dFMzNGE1VVkxTjE4eG5CeWZEcU4wYXZrWGYvSFFjcjljcWxVYVp4YlJoZGNPYy9HVng1cnRPTDlaci9hNlM5TkhLODJtOE5uLzRPTHZvcjhVZkpBRHhESXAvYnIwZTlLM3BYK0JNY3htU1BHMUdGSkIwTUtpNWRiL3RsNXZidThRS3FKM1RHaG9udi9IMXhvUjY0T3g0U2dKVzhScitKS1BJRjdiZmNZM2ZNR3hJWjlyd3NrQUNDWmJYNHpuYW1lemJhQklENDQyUmduZTdXekpzVkc5SThPZFQrRG1pYmhRZXliQ3M3a0xRbHhuazA3V2NaSlZONVV0NmRYSnB1M3dNODMySmNwTTRtejV5UlF0b2NRQzYwd3hZMU9odjJmbExZWGh2RTFWODArb3JsdWE5bkdtOGR3THRFZ2pPOUUzZTdtNDROYVF5djFtcmtMQm9KSVpHTHFJYVc1Y3FRY05zSzlNQjF0QXpMWmk2YmhjVnZnOHJJMjVWVFZ2eDVhdE44QWFZekpQUHpFTmJ2MHBTc21iSEp0aGZLNnJDWGpWNW1Ib3dXVER6WUhSRHdVTUUweHlCVGxsMWQ3NmY1Q3BoVVl4VWsyZE9CcHBlNkdwZFJIR2ZOSXVYM21PWWwzaldhUHZVU3cxUWdVejBBeEZNVUt2VFZWWGxpbDZMMUFaVDhTVmVab3FuSUJ0QkhxTHNGZHF0bmJwOC9PdWpNMHVYNXlIcDZMcXpNYVU4U1FkaC9FbE5KRkMrZHdhVXdQN1NsT1pRVFRHTklvMTFVVFlkV1Z6WmM3Q2NzM1ZZMFBYZElNQkEySExKRHcxQlVWOEtwU21Hc3pDQk5BV1FYd2xPREFiMUFBd0ZDR21oZjFROXdJOTBPMG5JbDBWNlVTeVB6dXA4RGUwWnFlZ294VSszVW1KQ01PeWRoMmZ1UU9GVkQxeTRwd05oYkF5RWVmMFVhenlyNEhHWmJEZHBPSDhFaUk4c0M1eXlibXJLZlA1QUtrTHo0endiMjFMcFg0bXA5SjZBWDI5WExsamMwOXZ2bEpTeDdyckI3eklUVURUUEtYb3pGcXUxdERlWHRxWm1rN3psUnVuNWtwVmhKYi8zRDBBdG1pMTNKdGY3ZFg0K2k2cUVlYkhDcUhuRm1jVzlnek9oWTZoTzNmR0lXVzU0b3hZVStMUy9MUExzMWQrZEpVaW5yVzluVG9KWC9TcHJiczF5OUxRNDdEZCtzYzB2ZkNnK0VNWExPM3lsYTB2ZmUxcjZUajhqWjRqZlBDdmsvNWVlZ0ZSbEJONWIrMlVMMmNyMXBKc2kyZ2RXQ21EOWtpRWkxNFliaS9Xd1M5R0hBdU00QkUvTXh6NXdrYmludDhpdUxjM2kwWXdLUlc1SDl4L0FCaEwxTlFFV3NycTdtOHZiRGthRTVBSmxDMkk3TU9FKy9LNmd3ME1YTG91ZkhoZHhsZGVTN3JiUnlJeFpRTVBMbnNLRjVMdDVUVVhvZ29XcFViUkR5alc2cTJMWlk5WWErVGZoT2N0aUdVUEcybC90TUlZbHlweGQ3VEdIMTgxSUJZejJRQUVFeDRZRjFNZCtQS1JUS3hGaWZsaW9MWmJnQ1BiMVcxc2FMYXVvREl6YmU1RUF2YXlWYjZHbmVVQ2U3RFlZd1QreVlReHh1ZDJLQVpUc0FYNlM3QzFTb2pNTFY3Z1hzN0FZSllnejgvSjJEQzVjNTRha2FtYmpJcFovMXlSR0o3aWFvNWg2UzdtSzdEb2pNL3RCLzVRQ1FXK1ZrU1dtOElORTFXRGNkRU1jeXh2OGJVZUREc08rSFFQQThSRXdsUE9LWTl1cUxMOHd5OFp0a0pCSFNJVHkxd255cEZoSURkUkE0MnZOa21velNpMDh3aTNjaGhuUktReFFwNWxmTlVKcEZJdEFiN2pZUkxYWTFBNEtaaTZBZEpGSnFyaHBpS2xCb1VwTkI1cmh1RVlJTE1VME5kZUhKV1Rxc29YZVhUQ2FINFpoSVBEV0M1blVCbDZMNHdBelZuUXJYeTJDWEY5ak1QSTVEUDQ5SUVCUGNYZE41VHBodU02cXVwWkFlVWRvR0tDZkpNaHNNMVU2SVlvNXhJNVgxUzUxTkYxSjNBTEpiNkNHY2dId2xmQ2xaR3FFNW1xQ3VQVFd3ZzBGcVNudWtzM1ZZTTNIVTRnSjFRVkVsajRqWlRDTUJqT1pPUzd3M2RFR0lRcm1Jc2hYOElUN0Vhb0VEcmFoSHNNQ3pTOGxLMVRjbW5kQUk3Q2U5SXU2YkIwQTlqSjd3WGViamY3UU1nQUt2bG4yTzV4YjNIS1YzdG9KOWs1dU5wdnBESmZXR1hRN1hNTk8rQjZFb3lxYUowdmx6MTgwZnp0blZBOEJRM0o0cEM3blpOQkQ0U2NxS09YRGtYRlF3QlljRVZVRlVLNVpNaExkNGFvNXZyTE4xZGNYZmNuMXY0cTBRR1NxRzZ4NkxLZldadndUZFV0bjF0Mmd2dmhtdUprNWRBbUhKREFXVDVYZHRWamx6R3F1WG4zK2JzM3hTWjFWYnBkMHgvbnZLNnZiU3JLcHVaM3ZaeGxsVTByNS9iZ2xDekRxWjZUdCt5Q2pkNGhCM2hwWG5NTlo5YjhQaXV2bFpqcjZKMzdPcnA5MXB4emJVdWJYOEtCakk3QjVkeW82TllQM2JudEErdDFsMkgzbnMxUk16YnYva1hOZFZscHJjdzhXMXU0N3p6eHA2TjhZdVRNT0I5TisyU1BMTzhScDJKenh5bEoyamxQdWdnMnIrUjF0cGQxalBpQ0xhTVphZG0vWVpzS0ZESmEzN2NqNGdkaWs3WWZQMzExc3dqOEloOHI3STlxRVU4VHFZV2VwVG4rbmxqV3RYSml4VXExTkRIZG9IWVlsT05JRHMwd0thRUw0NDMxK2MyeHhZZ2NQOEJYQWRXTVVxRmFtaXhzWG8xMFJXVmhMWmlpSzYxKzRPaTJQVlVmVjlLZ0VoZkVISU4vQm5IMVRwSHZVQVpOMHVhNW5ISFM5TG8ybU9BeEM2TTZGNXhDOEhXYm9CUGxCY1luWk15aWVMeDk2M1hWQnI3clJFZmVlbWR0N01CMXUyNHExSTRkay8rNjJaVS9oV1orZi9QdUNmVFQ2Ym0zN1RtcnVxYzZpd2pkT1QvWFFFOW9jMk90MlV0K2gwWDBqUEFYU0MyV0JsNmFETkhpQjhUZkY4NmNRV1RyNFJ1Ly9lMUxNYkx6b1BQMlEwbGhZYkYrTnZ0dmU2bmlmamNlZ3Zwb3B1M3QxWkQ1VWltRFRQWW56ZEYwd0tiSUNCVm5vVHBHMGFkL3h5bXBPaGRRdE9LUUg5NEpjamlSZGRXTTM4N2tzVXBzRzJCQ0tRVUZGMlJLV0JBVUoyZE9sU3FBYnZSYnRmNFFEUGdDQUF2cTdibnhucjRQWUVUT3EyWnVNRysxblp4Q2Y1NHZHNkt6eEQ5NjFDa3lMb3plbVRxZTJZaWxrVjJaOGZ1VXRDSWRBRjYvUTNyTlMxWU1ZYjNCNVlRaU1TOVNyQXUzZlp5OE9NT0lyejRCeDNESTUyY0RYcmlVZ1NSbVEzUmkrVDlNQ250aCtlYmw1WnRmelRkUExoMWRJcklQWXN6ditBRlJmSm4rZzhGZTRJbkdzSG1CejViUnlMczBGYTRvUk5YQ1N0amN3VVhyZDYydjMvVkd2a0ZQakNxRXpXUGpTMHZqUlo0TlZDeDdqdU9Wcy8ydjgwcmZEZktja2NjVTVUSFMxMTFTNVZlcUJPUjRGQ0ZyeCtvb2pWRzlzSkcyZmJFYWVwWjdyQklCY2tUY09NcFd6dXV5Wm5UbzBLSE4vbFJ4dnFpcjE1cFhidjdsRFZjc2JTakhURDNldU9FdkpYenhCYUNuTHdNOThaazFmRzFmbmxTWVJObkNGVHd3TFlPa1RZYlBYN1UwbUhHOWxhdjI3OWs5UHJWNlcydnBudGN0L1Jnd1cvdDFxN3Rtamt3R2Nkd2I3RjA4dTdqMXZkWDFoMWU1cTNORXExd090T0RBeTZaR0RadVpaMXZreVBLMUFMdFJjMGRDNXpPbDhOcFZiUjlnMnJHb09qNjN0dlk3Mis0SWRDOTNUWHhtNzVTcmFxdnkzR1JuNzJkR2Zvckx6M3IyZis5WnRuSGZzclluZTFZNnY3ejhwNFp0RytqZHVvTitmT3MrM2ZubFBWTWUwOWJ3N0ZSbnp5ODdPbm8zWE41KzF0ZlE4K2czcGU5d0hOaG5velhJUnpiOFNINzFHYjIwbUpId0JzVXNGak5HK01XRmJBRWpEcWNXNHNISVZtL3loY0xqWmp1ZGp4ZXlOZnVUZEVIOHJ4NGR1Q1VacElPME4waFNidUlCZU91TGhSWlNEaXJuR3d2RFRwdmp5d1hLK3VLejBJYlBIRzZHellWMmZ3SEVRYiszeEVIbC9FSy90eUNzdUlVTXk5T0loNjZ6b083SXNUQXlJRG4rN1BmUS80MElCM0VVMEVCRVRBQW5xczBza0JlYXpuUloxcXlLRWVtTzZ0VUFoRlc2RmN1MHJjREdqSldCMFRsdWcwL09JcG9GSks1QVRTeWJLQXd5QkhONEkxWUtsN09FZTZUb3BrWEFiSEZpellRVFdpeHJJTDJwd3FmMEFPNHFsamkrNGROek9TekNTT2RSUVYvanRwa2l4NVdOZkpuaHhsaXY2UU9FVVFHek1BQkxKZnlmQVhLNGJ1Q2Joc29YQ1FVVFVqT3BCUWVFTzhHalF0Sk1RRzk2U1MySTg1Vk9CYXc2RTh3cFRMa1pDemFxVG5XTm94WEFUUWpRRDlWTWs2TXlMSnFnWUo1UHlFT0NjRWc1aEFRaENTRFBVR1VsWndPaTRiNFNpbmxOaXM2WENpUElncjRBNjVIL3p3UUlKVG1pTUwzYXRNMkpHZFB1eis5dWU1cU1kRmZUS1ZOVTI2OUFuMDMzWk9QUzJzMWZGRHJpQ2tCRUo2VFQwdTJaYlRZRWFNS0J5ZVV2QUNJT1VTNS9POE9VdzVuTDN4NkhUenUvaWNkWFVVaFNGaVZET1lsWTJoL3VGSkxXdHd4ZGpxT2dNdU5iM1RXVGJPNUZhTzhtK1orc3ZRbThKVmRaTDdyWFdsVnIxVHdQZTU3cTdMM1BQTzJwVC9jNXArZE8wdW51ekVrblpDU0JoQ1JBMGlTZ0lOQ1FJSUlFbzNLdmlBcEJ2S0RpRlFHSEJCQ0NvS2hjaFl1WG9JQ0tpb28rVkVDdm9sNVAzdmV0MnJ2N2RBanYvZTU5NzV6YVZYdlhYS3ZXK3Vidi81bmJmY2RmcW9keG9waUpxU1NwWDFzS3JQVXRreDg0akR0d1kydmQ5cGRxdUlQeG1TOTk2VXUvSy84K0FuOUxKNWVXVHQ2QXN5ODl2T3RVVVpTQ3htMHJTUnpWbDBKcmVxMmpCN201aFR2SVUrbGxIYTRWN0xxWnh0T0ZzMmRKNGV3YkgzencvM3JwUzhubEwvelNpMTcweFgxTEoyL0VDOEJzNG5jNUsvRW5ZcEJMTXJUdng5TExoUDhpem5LOHVXRytJTDVjUFNSbkQ1eDk4dDFuYnlpZmZmZVRNRCt3Yy9hc3ZNN1o4bG5ZQXZPM1BYa0RBcjdnNmwwNEJLNjBEWDJuTGpxSlN1Yjk2WmNMMFhEL3J0THBERHVkMStXTForRGMvaG11bTA2N3JzVmtKb3BFbzFGamtGYlMvS0ZRMVgxeTV4dW5UejkrK3JycnJudGZEa3p6UzQ4VDcvU3RwN1hURXh5Tk80RnZPQktUNWlLTWl4T3hqREhDY2I5TlFyUXFTdTEwRXVDUmp0ZkhVd2dMZHI2cVNNb25hSlRTOEEzL3Y5VW1KUEdDaEpBbTQyK0lGanBYZE5oOGxCQjExTjVQWkdHYy90eklBSzNxcDh0QnlvZ3FuS0R5WnJOWDc1WDlsQnAyZWI1U0JER3RIakhIajkyd2lyVGgrYzNJOVVqU3lnYWppNWUzRUdPTWtOWEJrWlZHcWZwMFlYVnhiNjlTYlVjbDlyYnVzRGU3dHJqdnN2WnNvRmZTZGlPMzNmN3BCTWVxTVluRytuLzBKMk1PWDA2a01WVmdLRU5GT1VidlNBamI0V2lMck9mbTFMN0VMeHAxeVpzNWFLczdQNE56Y3VQT3owVDFla1J1aFBsbFZDKzdndnVtNTVZeXhRb3JBUUhxYUtCWnBsZng0dEJPNnFEemtlL0xEd2J0OGthdXpkU2o4MmY0UWNWaWdpbzJEWFJRMUVMSE5mNkhCcm8wNkxHTHhOZUZyU2l2WjhxRUgzMk0vRHE4eTVIMEp1WlJRcm1BalE4aE15Q0cva1Q0aVNNUlR3M0NPYjNIYkhyeUVTN0tRVGx4WGQwUHpTQmNQOFNqYW1SYTdaVjJxbXl2bFl0dVdySDgySTU5eHZYcmdkU0JacTZBV3MyVUdqM2xoWkZMWHFhbFR0cHVweld2U2FxZ0Q0SnVyVU9Ubkl0SnlOL0JkMEVTeTlyVFc4VStpS0phOTl6TmpuYmZMWXFCNU0yN1d2bVFhQ1oybFBpMUx2UUswN1hzc0JyWmpMYXJybWVHcXVaV2RNN0pZN3ViZGVlcmlMNnErM1FKamdCMVZQdVM0VG5RdkQ3Q3hBTFZGdFFFK2ZWTmVkLzVZNkFaanhUbUNwdm9BUnVET0NWRDVrRzhHa0tQQndrVHhZeGM0Z0t4YzRwWERPTjZ1bjJGalBzMWdqRlZMQlVTS213czBSWFNNemU1SjRteTc0TTF6clI2ZHppY2p5cEhEZHRYZ1d0NGoxUTVvZ2UrQ041MFVyZU0rUVhEcXF0ZGFQeXUrcFgrMjFWR2VUc0Rkc1Iva3ZWcjY4dDJNSytGdGlIaUpxZ0ovOUdHRWFhK1JXUDY3R2VSeFNoa1k4bElFbU9wWTNTN3p1NDhDbFpZTE93SFRwSlREaFFVcTZTQkFkNWpXYlBnZ2djYm5YdXdkTG85ZjdBcTZhZTlDeDhNcU01Zkh6SDNzTVdIWW9YeHBOcnQxZDJvVHpUZFpveisxcDI0c2lRdVoxNmlpMFpUNklsU2RYV3Z5bklDOWNuT2czalRKY1M4ZkRIcnhKMldZVFc0b3d2VkxSTDI0UkpqeXIyY2l0cGIwUzN3MXkzTjk3VlcwYWhXalNrMlVPNmp3cHplSTRXZmwvVWNGZ2pQTllGKzFwYUFLUW44Wkt1WkFPbHBSWmtZektYSXN6NlIxZENZSmFLaHl6RFJaaXdUN2lTQ3hIY3VoemgyY2h5ek51YWNJQ2pHYU5BRkJoeG4zKzBZV09ZQnlNTmNxWUVML3c4bFVXQTZJK2N0c3B5dFhWa0xiWXN0QzAzelFZS2E3eGY3cGY2Q292SEFGY3RFY1R5cmV0V1J5SUc5YTlPUFJpMWQ5VXh1Y0ZYVEFsVXpNZCtUYXJWZCt6aFJZelpPeWpQbEpKNzl6QUQ5Z0lxU0wzYSt6WmcyN0RWcXE1M0xEdXFHNW9Gc1ZvZFJZRFJBclBGQy9lQmxMaUdOcFdZNE56d1ZwaGNyU3ZsUitKVGxCMFFtZUJkck9LTUs4NFR3MkEzVGJjcWo4TG1vR0RaOFhUMFJwMmw4UXRYOUNYN1MzNVBmS054U3VBZHhyRHZmcGJIUW9nb05qTUNDaUtyekhVM2N4WEg0N0UzY1I4bC9IVEZJNFZ2bnZEb1lwK2UvaTVqOFRVV2RVU3RxUjZrcUhZTzZKZ2ZxcVZsQTJBd2o0YWF0dTU1T0RkSlI4OTN3ODJ1K3QrajV2N2J6SlRnRXBoK0ZWVENSeDVUbUJ4U2wyY1NQU3JxSTVrTFZUWkFGVVd1T05DMVM3aU5xdmxsUlBnQ2ZMOTlhZG0zYkxkLzZaVkQwVkxUdzVQTkpQLzVqR0tOdkx4Z3k5Mm9PNi9zTjgzd0xoM1NrNXdqZFJha0VmRVlYS25wUUp5czUzM3orVnJGMDQ1dkluWEhsdnYvU2lvdXQ5N3dtNWZ0dWJTM05Ec2FlcFZoM3ZxMWRibVN2ZldPNXZIbm5wanJ6eUczbHNQV2UrK3JobVovN2NuZXArZHd0VVlxYzdZL1hLKzJmdXN0VXJuMDRyM24xRWZJQStYVVlWWnVTZm9zOG5FeXFDcGgvaXN2dUpLcWNJN2xETlZ6NmxIQUZCcml1K2JsdVRnN3YvRVBKTVFPaG1lSWh4cTVPUWI1ZkU5R1NSUXoxSHQwa2x2NGNqSHRVaUM0dU1YVnhQYWdCNGt0Q0k3L3UyZjdPcVJSMUJlMnRRTDc5ZjJvMWorOVRkVk8zZGNzVU15a280OXE5SUJaY3hUR05VTGJoZjlBOTVKV0ZtY0wzRlg2ODhDN1FiU2ZRNkdrU25XT1AwNkkwQ0llZVI4cXNwZ2xHYWVYYjBHS09acFVCZ3VMSEUweUZRWTRoSTNGbUU1a1hncTZSeVdrbnRxdGVWM3JKNHJ6c0ZzZ09ZVjVYQmVOeG9UbWlaT3FGbEk1YTFwTFFwSzMxd2RFNklUVXJRZlE2VmZOOEx6QnR5d3c4MzlWVVE2VjZhbjJTbUl4WUFwaHJvZ2dWMUFnSGVwcnJnVWFoYVpwaUNNN1R1dHRDVUZmTXcxYlI2SjRhbHFzS2kraThwdW96ZjZzWVdQWURhSUZSMGhVbkxma1JYTUZ0OVhmK1hXaUlGV3lSMWY3QjdiVW8xUlZ1YUk1YnJMVm1GM3FkUmpWeEhhRnhSUzlHbjBmOFdpRFRwcHVDWmhhcWhxRnBWSEZNSHR1SUhHY3FoaDI0dG1ab2lxSllJS1QxTWc0cWw2aXp1aE9hS3FXb0R5V1dHNXFMVnVqVlZraEpVNFhMNXNhRHUzcFdXZGRLbGQ3SzZueXZYU3ZXZDM3ZHNQV214QnI4dDZmL2d2d1dlUmZJcTJsaEZYcWhmRzk1SjVQNGVySXc1VWhORUp1eTF4MmxFeWlCaVFyVEk2dWkyaTYzRWtzUGZhK1RPVS9BajlUU3docTVIdHBvY2NsdzlNalFWd2I3YnNlNkNiZnZyWkJiaFIvcVZ0SXF0MnFlazNVNm9XWW1XYm05ZGlMUWpHQXVMbGFCTnBiMjN2NVNQT0NCdFltYzh3L2s0K1FzeURtenVaeFRtMXdmZ1M0WmIwL2dqbVUxUkZscVFXSVJrYmZ1L0xCZmxEbUQ2UWVOb3Y1Y2t3YzJVS0JUcDB4ZHN3SjRJMmVML3V0bE51TFc2LzNpemovcCtrMldBVnNVNDlKTERTV3dOTU9lNHFEOTlnU3Z0QWo5L3NMWURJWnhDajJCR1dNTldTbW1KNk1ZVWtMT202MGVlTldyc3FKMThtUmxXRHhWbkpsOE8zbnBLeStBNTMzRHExNDFVelJQbml3UFM2Y3VtWHlEblY2Rnp5OWoraDZRL0xjd2xxZWZYRkxrR1d2NDQ0TjMzdm5CRHk2Vnc3Tm5CeWZoZStuazRPelpzTHowd1MvZStYeFlYOEwxSno3NC9EdkxKL3V3dnJUMHdWMVl3S3FNL0RwYU9GbTR0dkFBMXE2SXN2WmdISzBqcHVoM3dLM3hySnVYTDFwREJPcDRBaHcxUEplb25hZDBZUkEralAxK2QzQytkQk9halRKWnFHS1U5amRJZnFETXZ0NGkvVGZWS3cyMm1DVGs1RzcxN0p1Skh5N1VmRnR3Vlc4bGZ1V2dxeVdPcWpsSm1XbDhZNWFRV2FJNmtRUFRDenJ3M2RkQTg5ZkxFUkF2cjNOSForYkJZc216N2RmdlVnYlBhQ1p2RkoyNnlzSklKV2F0WkJtakVIT3VtU3BzcGpRVG9WR2FhVzgwakRkdUdaNFh1OTZDNm9HQW9JTDJ0YjltaHlMajZjRnBMY0gzeXhvSHk0VXh0TnN0MG00QXpSSS9XN1BJRWlEWUxQaTQwSDVwM3NUdGlUU3U1c1c3dHNqYU1Pc0tsQkI3ZlRRenhyMDRnaVk2RndvbWVKSm1vMEV2VEFOZDE4eWxlckY3UTJUVkkyRVpSbU5HTWZWNnNiSTVlM3F1dXpEVENFb0JXUWdxSGRzQUtsVWtlMGkvbi9qV2o0RDZFZFhRUFVYMlVQcm4wVHduU3FVcWlEdVgrYzZKaXFNaDJseGtVTDdVTUV6RzFpMVBYL2prb1AvYXRoOUZmbnR0elNpSHM2ZUJDYTlxUmQxSytTcDVUa3Y3T3lkSmFrbHl2Zmx4eC9tNEtYbkUwK1RQeUd1Z1Y0MmtsMG5pOE1EejViTERSSlhLTVk3ekxwTXpERXdwQVNZQUF6alA3RW1rNUE5MEhjay9vamdsZWZIQVVTOEhoRm1YTU04ZjBvM00xRFF6TTNUWXE5TllxUXpzWVhXMTJRdWllUTNrcjJ5dE5MOHkzeTJ0dFVHcjBub0hadHR1ellwWFk3UHV0bnVnNzg0Y1dqMDBzM2FWYitvNm5rTTNYaFo2VWVSMS9URDBtL3N1Q2x3RnBHTTN5R2JIQjFlTEpkZlNmQThvV3VUNm11V1cwdVdYWmFzS0JWbE5YYzMyRllPZ2VDYjB1NVBqSjM2M3FlM2lqc0lMQ2k4cXZBUWtzMWNXWGx0NC9iTm9iRndhNFVmbldOZzByMk90SzZ1QmNSbk1OUUZBT09mdldTRnQ2WjNPZzlBUmJVNmlFMG5UZXl6emlFZEpGclVINjRMRHQ5NHpaaEhNTHJDVy9KREt6YUlGRkZwbENLM0g5ZERRb29Vb0NJR0pFYVlMVXcvTklrakZwbWNvWE9XS0FlSXBqRTdWTVZ4TDVldmI4NWZlY0dKcDZ5Mk1DR0lMWk5NVTR5cVlhb0Rxb2Vqb2FOWlZxanpEQ0hPV3FNcWVXR2NLZC95YXJRTWYxbDJIR1ZnSHdEU1k0K29DVlBXYTczQlFJMTNnekw0MEQ0TEd4a3pEZ2NVY0NJYitkZU9sNC9Qeng1ZkcxeTJxZVZnVGZCaFZFZVZmQmZVYVpFWjBKRk02aVV2OEEvSk4wR2w0d1FacDhMN0NnNFdYRng0dXZGa2lqWUFvQXMyRGZ2NXVDb3YrcUJ1Mkp5WGJSb2hLMDV0NjB4RE52ejhWZnliUlBESVRUV2J4U0ZESTlmU2NkeitaeWpjQ25TNjVqSU5pQ2tmSVo1eWhFeFREbTJpUHl5Z0IyUGh1OVAyQ2xndlBheXlvQkI2SGJCMjk3OEROSnpRZGk2ejVscU1xQ2dkbEJvaVowSVRCbmJMbk0zc21xRHFlQ1JLM3JnZTJaOWNQTm16UENqQ25SSEZVNGJ2Vm9PUHIycVUzdFZzUC9DRTZtR3g0VDd4QnFFUkpWR3lNYk1HOEhOWlhpRVlsbEQxQ01uSkNPWG4xZ2Z1T1hQVlFpV3FnL3lHeXIrWnE4SHJnNWFLZlc1Z2xTalVNV1RMaTBsSlljbldnRFV5b3V2eFRCVXNTNkNpR0V5NlZJNE1yVHZOcXJ0SFNRMWNkMlJnZjJIa1AzZ21uaXNvNlJNRmJnY2ttS2w1Rm9TVEhjcUNYZ0x6ODhzSkRoVGZKNkQ3MHFtQmRiaXlrRm05VEREOURqTkFjbjBJTVpXMkxQTTBKUlFXTXRVTEJwaVp6Qk9Wb1FvSXRoUWZZQlF1MkVRbTJNTVMxRkluUzhyblNsYkJ5SE9lU3EwQWJJMUprTVRVNDBoRzB0RUw5clJjY01LM2hOYXRITnhRRHV0dGcrOVMyNllEQVpuSkxxS3UxVnFpRnpmb3FoMStHb2htT0Nkc0hzSitoYkJ4ZHZXWm9tUWRlc09WVFJkZHAwT204K2xMTHV2VFZuYzRYRGVSdnptdnpCVG11S0V4WGxsWVBuem11ZlI5VjdyS1AzTDV4K0V5VE1rMm50VHVoYzVSdVZJTEVVMXErZ1RBK2JuaFpvMDFwdTNGWmlPSEFtdUczRkM4SmxCdExMejYyZFdlTjZocWp6VE9ITjI0L1l0K2xzRmRveDg4Y1hsMVNZQ2dxYThNVGh3NmNZajlDeUkrd1V3Y09uUnpjbTNQYTFYd2g0NFErQnlUaUYwRitNR1UxZ1RLTW5oQmhOVUkwY2ZiWEtpVHRNV2hZSm4vVy8vemJxa0x2b2c3YjgvRE5ONyt6aGordll3N2RlUGpiTzE5OFhMRTRFVUs4YitlTHBIdjZ0RnlCQk9SOTA5aisreVorWEZOV1hwTUdXYjhmeWsvY1A3UysvanlZK3YwNzF0ZGZSUTZkMkRsQmZoay8vMUk0NXdkK2tudzhyMFhhbVJabG5ORFp2SkM3eEx0Y2wvVTJNZjRQWDMwT2tEbUJCSndnYkcrVGFTUk9Ib0o5bnBQbEtnL2lWcE1mMDRGUzIyVURsQWZPbFBHOTg1MDR2T1FReHBpQXR1VVc1NVJTWXFXZXZkenJ0T3BKckt1STNsY0owcEpkaXBtUy9ZcHJFODQwcFd3Ymp0OHdpd3I3T3lDWkhoQzRkdDBwUmNQVlZuVjFjZW5RUlRBc2xtb2xVemZjUmhsRFIvUmFxZFJiUzZPc21hVkZtMU9Ib3lKRCtaNXJMOW9QcExzVTFtYXplWjlydkg0QnRpOGlMZDZCdU9tNW5ubE9lZnRPTEI2cy9MQ3I3UzVzdWJ4UXFZeVVIT3h1dFluVEsyK3gvMUI4QWs4TDhwUnVoSnFqWGhocm5UQWdDSTZHMlhpcTFqNWNTUnhyZVE3RUUrQS9icG5XaEd0b3RXSzdVZ1FxeG56VGRUWFBKb3dzR043VlFKcGNLeWdsWlVQUk4zZnhzczhvMFBNNWpCWml4ak5ocXg0RjlXcDFkb21RYXVCWlhJODhxbHFCNTVYcTlmSk1seEVkUTRSWVhvdWFQQ3JqaUJmUWloSkxZSVp0ZWg2SElVOTVuWVp2eHJnQmV3czVZbmNITTFzekpOdWFLYThGKzV1WEwyNDliOSsrNTIydExpeTNxZTJ2M3YzU0VxaGlwYlB0bVpudFM3YWdXK3h2dGpmdi9ONDd0Nko0dmhaVjc3OCtpVUIrS2VkOTlnbHlPL1RaSlVTS0hxT0pKWm5pRWN1RUJneFFIb3duWUJISmVOajNvMmtNU0Y1Sk5uY3dUQVBhZXQwRjJtUEdzRGUvSHBnU2ozemNQblVqMWIzTDlzMjNxalloUzJsNXRESGFWellmclJiTFhzQ1lGOHltdFZheDdjQW9yRFdXMktwcjZ1WmF0VGR2RUxXWlVmYWM2enZOOFlFMHFqQ3l0ZlBMKzJlWGJjZDJGMEx5QnNldE5SZlh1Z3VoU1ltZkxzMHU3Nm0zeitOSmYxejZ4TnRvSVNYSmVTVGxpYlhnTy92Y01JdmJlWW9Pd25qR0dFbExNQk4yZXVSZ1lWckRtaXdDZFV1OE9IVExsa2xaTWFxMWV6L2VTbmQrS1cyMVVuSjUybnBwalJBdFNLcmRnY0hKNWlDWndZWWd3bXBWeWhtbkZTTDgyWGIzTUNIMWNzMkRUY0t1bHByenhYais4UGxUdEw1OTd3dG5TV0M3OHpOeGNlOG1KY1VZK3MxNjJNUWlkazNpV3pVUUlMMXBiSHZoWEs1S29jUDZvU3BhWThMU2tGejFNei85cnAybnJpQ2pLM2JlOXJZcmZ2SjFwTEx6bCttYjMwemNuVy9DYkdwemZaSjhEV2dlQlJuU3crajRUay90U1BzUVFSVnpQT3FTVG84Yy9USXA3dndpYUUza1ovY2RQTGpwa0oySFNISHpxVDkrNXkrYXhaMWpSWk1VNnRuQkEyMWpkdWRmMzdtWjAwS1lQUUN5ZVF0NlZxRWptZWQ1MkJIUjNkMjVFVmxMbllEOFNhL2RhOW55MWFQQjlmMys5WU5MaDRQNmNuUGNoQ2tyeDdiSlhraGV0R2M4M3JQbnk3NDd2bVoxY1BxdTA0UDE5VnB6ejZFOVRkZEtmTyt3MkNQL0NoZjQ4MllMZysvaXo1TjNrNE1DNG4zMFVhVWZaM24xTEVSUHZrQm9mYm93dDIvZlhLOWE4ZFpuT24zUFloczMwK0g3YS9MdkdhTG1SL1pkdWE5Y2RqdURqbWU1YlUxYkhGMHBkNXRpczN4VHhxRDNFSnNsZkpaNGxuTzNsUU9QNWJkMS9xN2lYUVY0M3RqZTA0WnByZDJLdHBlV211VTVkdXhCZXVnRE0xazJrMTJnK2IrcHRYRmtvOVZzaGNzSGxtdkZCY01jSHJrYmQ4cG1KbjZGSjJETW1JVWlqSnAxdUN1VS9TV0lVRzhnWUZCQTUrL25ic05rK25XOExBMkVVc1JCTnZaVHc0WVYycm9US1dUMUpsVmhtNDI3SEQ5dXFMUDdXblBxR2IwM3MrK0hpSzVlRHpKbXhJLzdwUVk1ZU0zSjliWDF5bXl6MUM5dTZjckpGMjBzOU9mRjZSdXZmTjVOdHovM2hpdU9xaUJKWEh6OGRXKzg3ZTdudjJnU3QvRTMwRzVaWHNsbGQzK1N4YXZpM1QycW41Q3ZiYjd3b2h3YTRMYWpoNXRMODFlV0t2UEg1cGZhbGNCV0h2bTY4cUZqTDlxV0xYUHdZSVB6bVpuZStzSkZDNUZYU1pKcmt3ay9uNzZuN0JsdktSVlRZaklKMDgwajVIYTlsZFg3NzVmUmxHNFkrY1Z1MFk5Q1Y4VXk1N3RleUovLytJOEx5N0U5eE9tcmtvckNMY096SFd0U2QyUlM1elQzUmErQzduK2s4Q0VjU2RGRVVVWFh4M3JhbTFUM1hCZlM5ckZNMnNnclJ0TUVMNGVNVVU3ZHZyREFxY2pUSlVIVkc0MzdVZ0Zja1ErUnQrSUVPNm83UmlFMkJ6RnVpeUhQZGNGSnhQTkVwc1dneks0WXkyU0o0ZHFnbDRoSXhqdExKQ3BFTkpnSU11TTZDQkdNR2ZCdnlvVVNVUVhUVW91NElBby81cW04NGRvZXM3QUsyMXhMTVJWUXdCNDYzMWFIUUxYeXFHblpvY0RJWERRa214Nmx0ZFN2Q3c4NHQyM1lpdVpydWk1VVMxRzBtQ3VLYWdtdXU0WmxsTktLQWpxRGFTY1JCZ1A3RWVMU216VXNTYWw0S0RCRGZ4UldwVnJ1NjhYQTBjeVYyYS9MZTFSTWVjZWduOExaWUpJTDFiU0NLQU5CZ0ZyQ2RnSnJyS3FXUnN4N3o3LzVGd21WNml3U0dnYWNLRmpyRXRyRFNUdU1PazZsRkJvZ1E3bjFoazZad0R4NDN5SkdwUmJEaVYzTGRmUmlKWVJ1WTNuQzlGRWhBbldMQnJwUnRhc3R6RkRYeWtFejBYUTF0UkszbkZ4YWRrUFBqZWV0YWIydWc5QlhGd3RYRmdycFlKcDROTFdRRHdmRENaeGh6Z3ZGTkdvempzYTRNa05nQ2htSk9NaUZ6WGFlalRJZXJPUjg3eGNvTzlWeW9wSTcyN1ppcHB1Z0tadVZrdUVDcStPT0R1MzNHbm9ZaXdRMFRRdUJneHpUZHhTWDhYV2lLRWFZK3RFZXhCZXE3NmtHdGRiY1hIR3hHelZycWtvdE4wamlhczF2TnJ4eTBmZU55S3JZU1ZENnNtMGRQa2FYTkMveXk1bm5wSDdnVmgxb3lJczZCalJya0pUUXBoeEl2L21yUUhacHcxUHZLOXhjdUFkMWExSWtQYklPYlhFcCtSajVQZklINUUvSVY4bTNVUExFMGdrNUQ0ZVJzUWJTQ3JDQnFYVUQybU5OaHRuekRPMGFlVzZrTkJ4SkR3bEh6SXo5SkJkenNQejVzTnRiRzBrRVNMU29aVkxMUnFBTVBOMWEvOExEa3g0d0Y5aHZyZDFEa29xdlJJcXIrSVpRdlplUWJTaDVnREtmUitDUGU0TkpWcGpBeThvc2dTNmloZlNHRW1SY25KT1Ewenc2RjRsQ0h2b0g5eEM1RTJWeStvWUZCcHB4Y2M2QjBsK2I2aGtvc1RIa2dWemt1UWk5VVlvbmNnbW1mWFprd2ZnMHgxWEtPRVpRTDVNVjlBM2xab2tCSW95SThTU3JOSXA3TW1lcHZ6NkZHT25sbWtyS3B4a1QvVWwyMUdEb1RFQkd1cjA4dHd1MUFvRlhrR2NHQ2dTTUJjUGI4RkdRQldHQzdUQm5QWmlSMVpVUDBzVmN1Vkh1ckVLNzNwaVBnU3VNSkZBSjlHcStoU1lGWW1sdWhFSHFRaERkNW9qdVlYdVZDbnlwT2lVWW5aWWgySldVZ081anF3YU1jVkhqaDRpUUNVNTI2R3FtTkV0Z2cxWXFIcWhLUWlGMlJTMDVqQW5ERmhxeEdWVU1PQlNFZjVYWCtTMTIxZFl4NWVsOUxGYUE0R3VnZjNBbTVJMXdyRXl1V1JUMERrdG5sb2EreXBKVlNYWEdrUmJxdXNZekJSUVJGMlk4clZoVzRHcXFaakhkd3JnNWVBNlRBOG5DY0RhZ2Y5eUJVek1GZ2U4b2pBazQ5Nnp1aE9WMGRyWllEaDF0RnVnZzF4WTBIYk9QRkJWa0VHNzU4eFFqM1lERUtzSE90ekRqU05kaTMrS3U1YW16Z2xtSWlXSDVWYW9TbCtzS3hyL0IxV1JkQzB6cVFCTllXTzV5UmRXRFdQV2JWemQ5TlE1MFZlRmR1S0JoTW95ZFEyY3kyakd4WHBOcWNCZHJPRkxWTFNyVU5CWHVxL3hCem4ydW1DWlZpaTVTNGJwR1ZDME5TMEJRZ21aWE16Z1BidDlPVlN0OEtkWXJDamxvY1BaZXJSa0lVeXNGUllGM0l3U2NPYmFCdkpxYTZacVdZV0xOSjZxN3VzUGhwUWs5MGxTcXFjbWZNY1VBSXE0YktuL0NzRUNCRlZqNlU3TmpvU09nTUx4Z0lGeXV4WUJjYVpHdUp5cGFyVDdKVkFRY05uUjRCLytxQVQvUjMxZ09LcG1CR3JZaExCZHRIZENJdkNwME40V1hodFpMVE9zQUpSejJVTFFHTTF5YktWcmtXMVVsWW81aFdiU2hZVktrZ2RrU3dCaFVlTU5xQ20rV1ZiazBHd0k3c0lTaFVxNFpXVVZMYmMyd3czaldEU3lmaFJIMW9SZk0xbE9Ma3hUVFE0aHVXcndNZlVndHFkQnRYTWVFVXpCZTV2Q0FaSlp6cGhZNWN6NUtFRDlMOHdWak5sVzVCbSs2eXVIcTBNa3MrRmxYb0xPRk9qeUNxM01qMUhXdTFEVU9uVklvRkhwbEJUb05ZakRiME1kOU9JMnFCRmFwejJGOFZpdGlZWm1RNVVXdFV1V0M4SDdKQ2g1eGtsREZ3aSttRmJrMVNoeGRheDd3WE5jOVdOUmRHbXc1TVBwTW9sdXBFc1Y1M0ZyaG40Rm1tNFZmS0h5aThGblFPVjBpQTV5QXo2eXpkRFNScWVLRW96b21IQ3BUNlZIV2lTU1JhSGNSRkFGb2JwNFBDMXZRSGlCVHJ4enFVcGxraWJ2SGE3TFNPd2V5aVRGeEVxTzNuOWZ2eVVzempDUmVXb1JKVTdqL0JGZXR2NzZmSWdtTGdLeEpVU3VDRlpLc28yOUJHbDM3S2V3T0YzY3BPcFVIUFJHMWgyTXBmWDNPVVVIZTUyN2pCZThHV21MWnNoY3hHQ0dtN21IVUt3OFY2SmthMVhBSUV5RXNYV1VhS2RVTzFZclVwRmp4bXFtSTJnMTloU3VnR0FxaVdRZ0pZbVBRcmlKZ2hLRmxscUVMRnQ0ZzVpY2lKWUQxeERWZ29Db2tFSXdLRC9iQk9EMFZlaUlPUTk5MSs2dXIvUzlzN3RtemVXUzFiRytoMllkdEdQWE9VVW9TZ3FqN0c2WExCWWhPbDVkc1lyelNkMkdFd24xU1RKelNlSzBpV0FqQ21CbHBaYUFDZWl4TWVwbUtJUGpxemNSVXFXRmplcU1BV2xKbFNDa1UxMVVJd2dqQkdSelhDTENFTFdZdEdtZ1o5MVZKalRRTjZLSFNneTZzTEFTR0QwOEtUNmZxelBHdzVLbjdBeHFjaWZrd2VLRXB1RUhXRHVDd3AxdHpGR1VxekdTQ2oweFcyYTNqQmMrV1A2aHVFSXd5NmZWekhLNEwxYm1kKzcvWXVMd3piM0ZoejJZWDZtKy9PWHJlblQ5K3F1MEVyVXN2ckZIRkNoeTFaQmwxOWN4elA3bHp6UVVueEpDb0MwK1UxeEY5bUh3UHlQUlhGKzR1dktUdzZzSWJDZ1Yva1BaSE5TS1piWTFFdTlNazhvaVhZVWRDME9kc1YzWloySFU5cjlDTGZEdm45RGxJYk83aEcwanZsWXo2Z25OdmtXU0N0SEhPbEN4MlJkWDA2aVEzTlBmWkhFMHJNNlVxcXdCSk12ZVowSC9uR1BsV3FlVUQ4ZGFIVFZVQnRoSjNxeFVnUmVWcW9vR0l1N2RrYUdhb204UkpTcW5MdmllS0sxNEU1eW0xNnV1MTJucTlQRE16bUpuNXozQWVtSXFJTWVLRDBIc2ZlZ0N1TUVHVy9nR21pMWRvM0xhNTlnT01iWVRDTnBXaVV3UGVnZ0JQUy9DdWJRRmllTWxNdzNrSHMveFVyMDNKajJsbVZPNCtqajNoK3JDMnZtKzk5dDVPdndOVGw3SGZZZXhha3FPWVRQUzRqOUVDMEJ5MzhCcnNJU0JwK0NEcHRVQmk4MUhoQmdVS25hUVNEUTJFQjRtR3lPTnpzZjlSbHU4eDZrKzBtVWxsTHhrOGhqTm9jMnpsYU9JMUhNb2RzbDNiSjY4QjNRVU5ES0w1OE00amJLNWE3YW5rQWRxclZIcXpRVGdUKzRvU1k4SVRDTlRxZmNpTENJSFJIaXVLSDgrRUFRZjlSM3BmcU01Qm9GQ0N1TzE3d0pWcENiTVpYOFNCbnBTQUVURFBiOGVCQXRJQmh6T0EraXl3bE0rVDFUbTI4NGpTclZSbUdUbWp6dTU4UDBYd01wVm9OUjlEYjNRbG5mRnJ3SWxCUXFMVXhKSThlalUrOWp3WHVCN2l3ZXRVTlAwNTRQQ2dqak56em04S1dBVWJHTmZjNXgyTHE4ZzNpSmxqcDJDdTdWa3lKKzFSR0IvMnc0V2ZLcnluOE43Q0J5U0NhMzhvMHJnLzdFd1QxTGs3U2Jib29xUVhUeUxyc0k4UEVETXZoamN3SEt4anlOMVE1dCtMNGNRbmllMkphZXo5cVNBclg0ckFYb3g5ZnoySngrZXVjYjc5a3lrYzM3TWZzVDVScHZzcTVpUEtJcGd4YUF2dFhreisxOTY5eC9mdWZGcXpkZlRmNnJiR1N6Vy9rZlFHSWs4VGRZc0o2S1VzV0s0bFRTV3AxT1BRaW5tOVhyR3gyZ0pMWTBPVFIxa29WdlpWU3hXYWVPTDh5ZVJxNnhtL0o3djlWOHYzU2pCaWRwYTdVWkFZZWh5OGREVGI2ZDc2aWNyR2kxK3NhVEtYWGRWNDVPdHViSGpVVVZWaFdJNGZ4WTFpNUNLU25lL3NMMVpZUFhEWEF1dG1MN0dNa2V0N0JnaGN0dVpwZHBxWFE5Tk0vQVcvTjRFREtYTW9qemFtNTU1dXNqUjAyNkhqRGdTS1orN2Q4b3EyWGZTL2h3akRxM0hoZWNkSllOcUkzMHFlL3FlblAwTitrenlKS09TVCtLbzhZemtTRTZXbEs3V3FCUFVSU2NiUUFkSWw3MmlkR0IrYktScUdNRUJQbnRsZUtMZGZIQUpqaW1ybFJaVkhtZWRhbGIxejNhSkxHbnZuNnlFQytIbkZwRmFxbGVaZnNQZWtsNjJXa29haXpOUmJiYTA3YzJzM1dPaGRmOXM1bStkQTJqeDV3U2pZTXRZbEhRK0ZMK0x4V2pxMDNqTDVlL0thYTYrNTVyM1hFSnhkODk3enVaRTVibVkwd2MwVVdib2JPTE9Qc0prbkhsZmZaei8zRHI3S1JrUCtIdXViVTlETXMydi9xVkk1MFhXYzdSL0o2Ukw1YTdpUFBZV0RFdkVTb1l5N21TT3I3b0xPTTVZMEc5MC9RN21RZFFTd0xDVnFWc05KVngyTnczUFpDR1lZbDllRjhOTzBYUVM2dUo0dFpwdlovaFhicmZZcXJwMUVlNitvMDhaQ294RTc5bi9VWm1jMzV1YStIcXhWRnR2cmpLVHROUFdGdWw3TzlzMnNYaUsyZWVvZ0szUlN2c1hNaFgycEVIRUREaVZpNTIveHVJM1ozWmc3dHF6QmcxVW50d3VYRjZDTk82c1l0QzVoME5heDFqY08zaGdZOG5lVVhjRDhGNG1OSkhJSHg3VHlTbTY4T0EvM0lTc0R5RG91NHp4Z2w5eENCUWk1QnIwV3lDTDd0UXRNcjllY2FMWHVYeEJBTVJkcVZteFZyNlBVMDhLcTI5WmhYRjJyS0JXOVVTZDZXV1h2b0p4VHRjZE1yaFlKRmZ4cW9YMTZsM2p3YzUyelp6ZkpiSGoybW11dXUrNHFySDNvcVBRc1phYmUwRDJncjhiOFdUUTRPVE01bGtIdWM3QUtjYUZlMkErVTd4azVrTk8zTkhZbWVTUXBhdjQ5aEkvUHEreE82OGF1Uy9jZkhDUXVqRitSWEgxS3ZDYVZ1dkcvaHZyelZ4ckRSbU80amJOR1kzRnhlM0h4QWVJbW5wZDRKNmpRTzZWNDQ3VWJjYW1qZzBadzRjODFxK0YxNDdubWJOTHg2MGl0Q09WV3crOGtzN0NxNnpVc3VRbzZkMzV5bUgwVXo3NjkrQWtUeis1MWE5OTVXaER2cGo5Lzg3dWZrNSsvc2h5VEh3YVI0aFBRaXdhRnZaalBrbHRJME1MU2xXR3lVMWlkWkR4QjEwS1lVYlJ3dFVaZEZRMDMwbVlwQVdON01pY2lrdmhGWGZJWE91Zjk1Ylg5d3pzdXRvNE9MOXNJTEdkajdYaGM4N1BqTHl0K2I5aHVIRWxTY29ucTdKeXdCOWxLQm5mL1kyVHJ5bTJTTGxmU0JnanZVYlZCbWxGYURqdGRoZFhZOHVrOWx5WEg3bXgyRnB0SE9POGFqSjQ2MHJRc3YxaWVhUjkvVy9kZ1ZLWTA2LzdLM0dnMDk1R2tYblNpd0d1VnE5UDRQdUNOajRPY3VsVzRCRE9ZY2ljZlBKU0VsdGxINmlRZjhiMCtzaUtCTnR0dXJ5V3haMW81T2xxU1RvSk5reFlHdmNyRTJNR0kzblc0OW4wbkRwODVyQTROeHpGMi83aDdkT09MYmk2VElxN2ZlWXJMWHp0ZncxOWtudTk4OXJQNERXZWtlZVJxT0tZRTQ5NlIzNHB3Njg2dG94dEhHeXZ3cFZnODkyM2lsZ2U2L3ZUVFg1UzV6SWZ5WEdZWkREdk5RRnhEMi9CQVJoVmpCNDJ4aytlV0x0d09Hd2RkNmVmdTV3a3NmaVRJcS9UbDJQWWRuL3BHYU5hNWlleUhhUG9UQ0laYXRMdDJYS1NPR1ZnMVlhTHVnMW9NZmVVTG1HWlF4RU1qMUhRWFhWRHdRVVNDTGM0YjRhZzJGZG9mT1JxcElJYUUwdWc2QmdjSml4cGIyYytvdXNKWUNtci96cWNDbnZPRVA1Mk1YNnlhZGRzejdmMnlyMDJmYmgza2J4aUx6M3kyNmFQMUJ2S3hjRk80Q3h4VUJwSHV6bGIreXNwbFM4dW5icnBzZWZteWxwcVlMcWgwR3RkVmw0RytwTjBJdkpaWlBPUUkzU2RYWXRsbTloS2R6SDlyWVhOekFXYy9Nenc5R0p4K0FjN0lmY3VYeVRQQjdCdVJBcXFoQU9GY2h0ZFE5YmhHZmVEYTk2RHRpdU41NjRiS1VJbmkxODBKTlNiRzg3WVYwc3pQaWJPZE95Wm5oVmtCODRxQlgvNE4rV1RoUU9HYXdyMkZqeFgrc1BEVnd0OUxMQlVkbW1DTzdDTUh5ZlhrZG5JL09VUGVTTjVIZm9QOEhubUtmQTFqSURCa2RqODVoeXZYeTdGV0pxZ3BLRExqOTZsa2xwekRVNUVhVFdzOElpTTBiVHBVT21GUi9rUDROclR0d2FoQjZJR1laMGhiWlJSVWQ1dkt5b3lTQ2t4Q3BRYmRvWVE1eXZIZGNvc2pUMGM1NVl5VDZlWHlRS3Q4YlRjbkd6MEpjTmJ2aWtGdVRwVEh4d2thSTdzOUdKVmp0UGoyYy9rVjRmRTRQaW1RSnBteExpMmZPYWh5ZzY0Tng2djdzYkNLY0toVTRLWXhXektHVTZ3M1NDWjVleVpQaXZmV1QyVmhZZ1NMd2hLL0dIMG8wTHpjb09qVFlSSkxXWFJGTjVYK2wzRmZlbU82WXlIdG8xUEhENkpMWVo0YllrSFRTYkQvSkp4c09FcmpLUUtnckhJdHZVR1l4WXhCU21ONFE5dndMbVI1d1R4SlVBRFJyUkZvcG5UU1hDdDBXVVpQamtGK0NkMEVRK2lnS1Vnb0F0OXA5TmRtMWFMcFZzMkFOekZkanFHRnpIUktSQ2lHQW9PaDVNS2dWVGlvZmVUZHZ0ajVLOUFqR0hPNGlxZ2tLdmRWdlZvOEdiY3gzUmo3TDQ5cU5weGxHWmc5UXN1b2dXTVRrbnJBczFrTWFoTENGM3VIeTdOWjFiS0V4ZDJZbVcyQjlsSWF4YXFwSjhWNldrdnNsTUhRc29xZWFWaXNZa2U2NW55UkdZcHV3TTBabHNCemdSUmZTd2p4YkYrbm1pa3FYTlZpWkh5YVJYVGpMaFBMTk1MOS9helF0dVpBbW5BelFRVGQxQ2lvV3FvR2dxOGdDa0tzTUN1TlZWMVRYR2FaUTRlcGlvOG9Mb2lJcVFzUUdDSjFoWWtxaFdIRE5jMmhIaE9Xb3lJKzhmOVVxNWJRbFN6VVA2b2tDa000TElQVEpJd2ZqRlFxZzlVUWUwWmpka05qb0pnTHBRcEttbXJZbW91MllSRDU0Qm1vT1lPSUx3cUZ4MDA1KzRTaUtDYVNTYXBBVzlOU3FKQkZ3M0FpUWt5VFcyZlREVkpOU3RjeURrS2pwU0U2Qk5HMWl0ZEpkYzhPRFU4ejQrSEdkczhOQXpOVkZJZkM3YnVHbDdqN0dkZWh0YUpTNHNlSzZ3cVhNOU1HTlYxQlJwbEU0NVE4S28xYnpCQzZEK1Nia3pqd3JrbVo2ZWd0elRhNHdZUVRLUnBOcmVqWFRhRUwxU0R3bUtHWFlDRm1GMjZob1J1enVtdDNXclpRZlE1cWhsQnN5N1FkM2RValkrSHF1Z2hVVCtpYUVkdE5adHU2WFVFSVVnRmR5RGF6RnpLc1VDcHg1aGlRZDlzd1BRRnN3a3dVUVRGWmtJbzVwa0svNW83T3lzUkhwWmxhVzVHLzRwRlFOMzFtdzNoQXBWc3BNZWdDR3VYQWgwaWt1VlN4Z0c4b2xGR2VvVTFjcUVLR0RRcEw1U29JT2w3TW1LNllTNDRybUlWb1E0b2xGSThjdFdKZ05seWJveXZRSU1LM2pVUVhoakphYWppSzdxcVlXeVFvbkZkSHZHbmxHTFV3SWdsSW5TWVVvVVZXRkNvbUsvYmduVUpmWUk2cU16WDBvRzhTZzd1cVd0RkEzZmVVMUs4RnVrMWNCWUhMVll1cUZvUHVVTmZsODZyd2RsUTE0amsyRCtJYS94YjVGbm1pRUJhV1FRSzVzVkJJYzVSNytkL25lVVZNdGkzakdzVXVoaWJkWEtJNzZqbWtUcmRwSGlRRHBHQnRQeGxPU3BCemhLbWZFSHJwU1BxcUx5aThoYXk2blcwV3VWYS9iYXhiNzJ6Y2NXWnRQTlQvYXI0ZDJBRWFua0ZYdVhxdGFRdEh5OWoybVljZlBNYTJOemFQN2IvL3Z6ZmFQNytNanRLeVh3TmRtMUpRaHRIUG9oclFEZUpTb0FSV1pCdncvaHhyZFVUSTBmVWhxN2NmM0ZaSkpmSnNZU3JBTmFrNmJLOTJUdzQyOEt4YkwzbjR3YXl6L2U3WXBDbERpNmt1WElSQ0pCbVRzYUNhNGt4aUlENHU2NHlzRmk3R0dMNVFKbnNndjVEQkdJMjhWWllKR2hFdzVRZ0ljRytpbWdtSkhaWWlUTC9BWENKWnczVXNLeGJBZHNUK2J5UGdFYWk3TXNJWEJWalFkMGxXVEZ0S2FUMWVkT3V4Y2NmaUhaRWxvdkpyRnU4dzY0bTdsRGhhVXM5VzJxdzhETDJqL3k2YzhQYWxPOHlrN2l4R2U4cEtPeTVsOWJzWDd6QkFuMXRNSEI2VnMxSU1KK3VINUk1U1ZvdUJGaTQ2U2QyRXM0YWpzdEs2SlQ5MktSM0FqeFNPallVZGVVZmZVMW9QN3poL3diaVNsZExXbnNtK1NSLzJoZXVVWTdqNE0reXQ5Y0xSWjhzR1J2c2o4aUVVZVBvU3pCTDEyTkhFMTluTlcxVElxbGxULytTRmVmUy8xSzR0QlczZ0JMRTFmM3MxQ295MlY3STlUUTJNa3VXMHEzSE5hS2wyWUpxdVViT2QzalBDYnQ3VmJQWWllUCttKzBPZnNhd3dLbHNoVnhEZzBsdHRla0ZzYUladkFFV3gzVksxOFF5N2JsRFl5TzI2LzRmUDhPUi8rOSs4Y1RRUC8yL2VNSlBZN0FmSnc0VW10UDczNVJJV3NHNHFQY1VjWlE4SkJDa3RrZXVUa2R2TG9neVI3dklzZjVSTGNnQlN0TURnVU9kWUFVb0tBSmdUVjgrSE1Zb1F5MlE0MlUvK1krUnlEaW1BRWxhZGtLY3hWRi8xcjN6KzhteEpXemtKWEthV3h2dG0wdVViWHJIVjJ3d2FkbTFoOXZMMUs2ODhVbkhDR2pCbDdXZ1hZL2pqMmRWN1pycEU0ZFc2Y28vU1d3dU55bUs5NFFTVjJVQlZtVEJWZTNHeHdscCs1cFpuWE0weXdsNnNWVHNlK2lSMHhWdFlMZjRCVU1HeXRiWWxTdW1jRXU1WkF5S2FIajY2RE94bTdmaVJOMlpvb3lLYjljT2hZdWk5bFlneGJUYXBoTDM1VFM2WXZiNTNJMjBHUm1VcG9iWTcxK0FlVjBGVzFrUGY2WmE2Z1VITWFOWURPY0l5T2pORmRNU0NWSks0L3VJMEpnZEl4dU9GcExBSVdzSnpDbmNYWG9iNXIvdGxpNCtsQmpvU2lZeWtBQ0cvZzlFd0FyR0VjMXVJeEZIdXdkcDBFallwc0JuSFBTN3hRenZyZVY0anlwNUM0dWxpdHNwSXJJUDA1dEJsQ3JzS2VGdWlQekg5akE5c2xyYm1WbnJ4MnI3RGZkSVR0VkpVQ2V2a1RKMldrNkpyYWtGSk45aFNvMFZJc3ZNbGt5MVRXK3RSRW1QK2ZTa3B1NFpPZ2lJNUUxYXJvYW51WHpzMU9kRWNyWDVFNkwzTnVyRjg3T1JtWFJWWEtMNXJIamViN2RYMjN0NitWcHVRWXRJa2RJSDAwbDQxOGt2NnY2eU5XOXZsRWpXTm9xK2Iza3JwUURZLyswclRYYVdHc2JodnNadXM3V250TDFXb3FSY0RNbFByVmVubVFTckxvdEQ1cnREQzJndW9zbklVcnFXdkhPMk5qcjNNcjJpRGdaK1ZXcTNWQ1RiQ0g1UFhrbmNWMmtpTkplT1I1RVlhZ1ZLc2s3ZE5WbVRvMGpLcUZUOGFSODJzMTV0cGh2RjlWbWZXRFpuN25Fc2RKZkxtNXQycnlLblpKRnJPZHY2eXN4SWw4eWZlNkJpNkd3M0RsOXdUOVVOWDkrS1hUdTE3T1NZbHZITjFsNjBLWVNjWXRyeUVFRmpQTHorOU9KcXZMeUJpWDA1bjRqZ01razJqblJKdGJSYnJ6bldzeGVaa3N5UlpaRGxKeStGUFJLVVU3c1lrYWMzY3Y5ZXNHallORGtpZms4VEgvQmg1UjhFRGpsVC9UbHFicWYwWU1RM1NIa0tHcE9TaG5TZEtXVllpRnhWaHZ2UDVXN2RmZk1WSGZ2clFyVStlSm0vUGlqdVB3OW9pdWJpWVhmZkFBdysvNmN5Wmh4NlNNc0cvUGYxVitqcnlrNFg1d2w3Z2VWZFBkVFlZNXNEdDJETEpKbjZROFRSMnBpOUZBbnpzbmlxVHBucXNPK2lQRVRSU1haVXUweTV1bE9vTEJxOUl4WW0raWpWN1hPTTNlT0xBYi95RUl2VFgrTHI2dkxLUlZ1N1pid2pCYmFMZjlueWhLcGRkWjRxZHg4amlSY0RhSHlMa2JrWitXQ0ZMVlBrd3lIUDdQOG9ZUFRIVDJXREt4YUFwck5IZlo3T3JnaEdYR3MvQjdCYkZvSkg5UjNzanpxdG5iQVBUZHRvZHh2azlLUk1YR3o2SThnNVZkUHB2ZkMvSStnZGc4OTNyUUwyV2RmMlVndGtmMmhhN0FQdk9MVnovTE55dFBZM1kyUjE1bms3cStnd21RQmQ1aHRSNkh0NGpxOWRQUzBHZFp4Y1hkSmI3Rm91aG9XcXFpR2NzcHhqYWxxNnBGdGN0TCtqTkxjdzJROS9rcHFKWlhybHJpZGhJbzlpcjdWVTd0R0k1dWlXYUlHVmV5QU0vRmJwMXIyejRudU0xeXcyUWI5UUdWeFYxOGRwVkU4VG10cDJZZG1pQlpNalVOS280NW9xU0dJRUJZcU5tVi92NW1JT0dJT1F5akozTzZ4TklpcGJIOHV4K3V2ejVzS0IzT3A0RzQwL1pZZFkraHdTWXRjL2xOdng1YUZoT0ZEVzZTYmd2Y0MxMFFkUjd4MTd1MldXM2JZWk9NcGZRZmVMbXBVcXJPZU5sWmxCdnpKVkFJdkpOdjlMb0h6aHlhTHRXRHB3cityckI5Zlc1ZmlteHJiSTNYMTR0MXE5b1JCNm9SVXp4YWo3eEEzRThpSmZxWFoxcFhNY1F1U0JMaG5IYkRVNGVPM3dNVnVWOC8ybTZsN3dHeHRZY292cVROT3RPUXFCQ2ZGdWpVRUthNUtzV1NDakRtaVRiTjhsMFBjdWhUZVJiSncrNTVwNlZwYjNOUnJuZFdGemRtcC83eGt4N1BOeWVtOXNlanJNMm1hOGZiUitZbnovUVBsb243WlVScmgrdHRCZlNkclpuWldWUEJrVGlpbjhsdGFyR0hVTERoYm1kOTN1bHVibVNSMjd5ZzFvdDhIYytTNHB4dHh2dmZNMFhlcTJtaTNPKzVOZVFTd3E5d2lVZ0M3eTk4UDdDcjhINEhTQ0RrS1p6eE1HUVJvWVlCQU1aWHkyRlVlaW53M1pYVEpMSStsaDMvVng2ZXh4SndWWHVxRTdLak1MTHc4T1JRY2traktFc0lUcWFPaVo2c2dTTnpCOXRqLzlmVDlyRHl2SzRyeXlHTEFGNkJEWnVUSi9IUXJpQ0tXUWdCTlVNR0N3aHN4M0h2aHUwR2tYNElBMVZ4cTA1eFZYMTJUZzIyMDZqdmZNaXBsNDYyVXNlYlFpQ1J4TmhPQXRvN2Z0THF0cUtDTndnTG8vYjh5dy8xR3E1amZadjFaZklZbFl2dTRHZjhWdG90azE5cy9LWFJzc3FSVVhkSGdRZW84ejNCN1pPU2xISmFvVk8xVWt4dGtubGxsMk5La25kdzdnYmJuc053Nm9sN1NVdVBnRDd0UU9uYW9meUpJWmREQXpmWjVUNlFkL1cvL05JYWUvREU0RFcrR3dudUdyNTBzV2dhclNKb2JVV0RybGVROWJoeVcyU3BVS25NQ3BjV1hndXlCdUZqa1JIWENHN1FCTFJTUW9MREptTFVmS0R0V0tLcEJGTlZvd244Q25yRTNDWTNjdnZVdVFnbHRJaEVIU3BJQktQbVpTME1JQVhsazFtc1N0TjlBK2FyTjRBUlpXU1pmYnVaY1pnYWpUazUvN1Y5czVmdEZkVzI2VFdYdGxlUEg3OXBZdW45bGxvZnN4bVY5UDJQMTNFeU9LOG9zZ0ZZeGZodExrQmN5eU54VFp4aFFrWHlmK3ZPMyttMVorYzJaeUJhZTI0eHN4UThkeHFxOXliOHN1Y2Q3T0NoZm56bUxuVk8rY2N5NFpUM0VsWUhmY25zRVR4SFRmZHRKdzBtNHZOSm5uZ0ptNGVzSTBicnlkR1Vtd2VMRWROc2pDSFd4YWJPNy93SXpOZXBSaGtiNEZWa2UzTnRZN0tHc3RmbWVBaVJZVWFZbTAvRzNwMWZPNFcxRjIzTU54MUM2QUpURW9hd1h6bmk0Y090NzBrYWFZcE1RNnBZdGtRaHc0UTRRYnBjdWlReDg2WFA3TERuYk5QUGZXUGFTT0Y2Ui92QXIzQnQwdDNQMVZ6ZExPV3JoZnlXdmNmSTc5S1BsNDRWRGhXT0E3VS9NckN0WVViQ3M4SHVmVk00YVhvcFFNQ2pXNTNnVWJaM2lEcmpVY3dtbGVRNTB2akpTNVE2VVVKZ1BaeG8wUTlISTV4c1Q0Y2o4UVVJNkNIcXJIOFVNUW1XTVhrSVpUUVFGSEdQWG9ZVnpHRzdmc0orUlZ5ak5COUlFZFNraEU2MDZhYzNzQmV3VWlGdEpVS0ExS2xCQmhkZlpEU3F3bXRVb3dxamlnZEU2TC9udkljNXliMTdtaXpmSGs0SHg2elo1MXRneHZYWXY1b01hRTFjbmlMSEVwRFN1Z2NPYkMycWc3K2hQUUltU0drNlJFU1o3UUVNc0REbEN6MkNIMGRLekdiMGp0b3pFeENUNUdqQks2eVhLUjBTR2pMSVdTUmlnUHNwcTNiL3U1VjQrKy85SlZycjN2T2MvYmV2SEZrNndpN2FPdllrTVlVcEJ5VnBrZFdWNCtzekRrZ0UxZnFzNVh1d1ptOC92ekg0QkUvRHQvaXdrc0tyeSs4dGZDK3d1ZElreHdpTjZJRU8xNGJTYXR6ZTd5YXJBOTZhMTJlcEdGdTh1N2xUb2ExTG1vRU9hQWs2RzdqaVRFYVczQWFPaXhyQmt6TU5vTnBUbFB1Q3B3R3JRaHBYcGJtNGlUdGp2S3dXd1NZeWFPS3Q4bmFFTFVPdEtjRG5jWWFIM1VxU3dWS2VYcUNIY2Q2VWhETW8zUGhiR0x0WEFqeE5Oc3JoVmM5bkFidGlmNElyZVBkWGp1dnBKRGxGdjg4YVNDdld6aEpJSkQzdkF0ZmsyZjVPWmVaeUZEdjdNa2FncEgwRFp6TGh4ejAyR3BmWWptc2JaT3NteHZ2Mnl1MDIwNCt5WEs0UnFXRUZCYkkwaDhSV3pVcU9tTkp4VXBBVGJVaW4xdUJEZHk5MUtEVXFsbmNOYVFCaUtrMk16R3dSVEhjQlFzTnFGalpJSnJOUW94UE5ZUkhXbzVuSzRwUUZPYVJwekMwMUVLVEk5RVIzRTBEdFhhUnFKeVlIUFJaWXZrR0J0Z3lTMGNqbnFzRU9zZzRpbE95UGQ2SWpFUUl6QTlYVElTbUZBclRWYmZ1bE5NU0pTRHVPVC9HS1ZNOWxya204SmlPb21OOVZaQ1BUSjJyYW1BWUZoY3VFOXhNTUk4VHIrY0ltemdLTXl3bHdmejEwUEd3dElDaFZGclZud1NGVnRjb1QzMFFndzBGbysrNGFxNUV3aFJsUlJEblcwUTRqaGxwam9MaGhFSUppcFpHS0xUYUVTcGo2MlFieUc4N3YydkNlU3lMMGpJbGxzVVV6TmFHajZkd256RU1VbVJSckRwVVV3UW95aGdab3JOaWJibnZlVTZvT28yZzdzVkowQXd6TlFyTm1NeG04eDE0U0o5QXk1aHdNYWE3Sk5DbGgwQ2todWVaZFF4YlRERGVpenBoVktwcUlBemdQZXBVTFdHRkI5MDIxWjEvbjNFa3pybktxR0k3ekJFaE9ycmdPUnltbERSYmVINlZSRnJWVEhqVjQ1WVd1ZjZNRHkvYmlxdEYybWo1MVZwaUlBNDZGMWo3SWE3NWRhL1JDQ3RCV0dRenhkQUxMTjB5M2REU0FvV3RxazJORW1FcXZxRjZabFdMN05TT2xSUnpUT0Fkd2MwcndqQVVtVG9PYndUNkUxTnptNUxFVVhtd1lCZVdVWVlHZGhOTmtCUkFHK2dndXVOeVhqVXdrUW5qZlZuR1QrYnFvMkFHREI0QkdySWNnQUVIUERwek1CWXB3YjJ6VTdvd3JhUVNXamI1cTJKWjI5T1ozNnpIdHRYcmxjdWJDNmE3ODBYTE9xbWJKYzh6ZEVFUUo5dlNaeStaUDBsZS9OK1R3TllNUWoyajZiZVRrOW55NXNJSGxRQitpSk9wWjl2ZXlZWE5rKzRMN3hlY2kvc2ZUdHdJZWl0VlZkQkhNYUQwbU9XTVpqOHdqWUg1R1Brb2ViS2dZd3dNOGNXd0o4S2VQdzVGenhkK092WjdQdm5vZ2JlL2d4ejRrMmF6dWYrV1cvYVRBMDhYWnA2KzhjYW5DeDFTT0x0ell4Z1ErRjBZaitYaW5NNmhrRmZnR1R2WkdBc1lzeXpNNE5OcnJkZXBJTDkzMjRCNTN0cm1iZnV1MnJ4dGM0azhVTzluRmxmLzBRdDMvcFlrK0xtMXVEQ3VuWXZ2T1FqM3R3QThlWC9oTEdneG96elZPSlUxbmtiOWlXOU9FallFSDVJdUxRbnVPMDdYUnpMK0wrbWYvellodGNNSnBISjdBbzZSVjEydGs5RTUxS2hlOXh3Z3hpVE5Cb2xVTW5xcHJGSUNReDVyNDFBZ0d6YXNqWW1qaFJKNVZrWGJQZ0xwQm5aSmZ3U3pCMzRBWi9maDdEVE9YbzUxUnpTdnFEbXlvSk9qRlYwZHZSZFlQaFRQb1BtSnNOcjdqdXhyV3lMeE5WbDRnTHJCNTZpd0ZFM1RIVlhyZ3daOERKTWFWSmxKQUIwak5nNENKWXQwdUozZnc2SnZCM0QyWnNycmhsc212YWpabnI5b0hxWjJLK29WZmFPaEdhcHBhSUhtR0Y0bEM2clYxa1lMcG1vMXlDcWU0V2krYnBqcTVEMlNiNUd6aU9NY0RoRE5QQjMzTVpiUzV6azZJWFpobHJGNDhuUFV1MWdzUFhMdkxkL2ZneHRUdXgvdE1YS3YrMnFpOVIvdDY1U3M2MktrL2YzZmF4MUY3SHhES0IxTjZ6S21mbm5uNnlSNnd0SzNOVzFidDNicDdBeHhtOUNDQzQxZVE4bEZYbUdMaUt4My9ub29tc2k3SWsrZUtESldmR21SSHRZdkkycnpoaWJlUXZXNkkvdXV5bTJ6ZDZkTStUbUZwYXBhcE1vYjN2dmVsd0I3VnRVdUY2L2pTbHQ5eTF1bW1JVjBoanhlQ0tTTS9uekU5WkJaUk9keUV4MnFPaktscFU2azY2U1hPS1FEM1dJa3ZTemJKQzhkS1lNUUozanZNcXBqR2phUTdBb2ZHRTNEQ0xJejY5ZVBxdlVqbUc1MnBGNGRYYjlPNXJyWFgxWFg3TWJOejc5MlFhODdmcWdzN2p3TmhIenR1YzJLNVZSTGVsSTZjYzBSTE8rd2lyUFpjN1B6UDUvY3ZPdUlMbVFXbTlDUDNQVlkxU25YNDNCeFFkKzY1YTZGME91ZHZ2eVBvUFBZemZuczZsNzE0a3RxemFyOWc4OStwdW5QZ29XMU5Lay9xWmRZTG1TeW51aDI0YUxDNVNBZC9VYmgwNGhiaXd3Zm5VNW91VVliTTl1V2lCdm80ODVYZFR2bjFreS9xTk9keC9sdkVHeW1hd1RHUVdmWTVubHhMUXc2Nlc3THlrZ29COVZsUmhHNnJZYmR2QVlTeUN0dTdyL0gwZHJMc3lCeDNJN1hwZXhCUVphUjR6bko4N2JTMGVSblRwL1AzZmZ0UkFXR0JaOUhWU3BNQS9qbWMxUzBXWE9xUFNnQ2c3bG9aZEUwMWZBOVJROGU1MVE0SnRNYzhuTE9xV0hDcDAwRXNES2hLMWR3cG5rV3NFY3JkQnVsQnU4c0JheCtGQlQ1Um9jVkhaR1ZyWTNEbGRiK0xqTGZhNGxRSXVEcVhFa3dlYWh1YTRTcjFQQU1qWnBZWExuT3pTb1R4VWl6VkFxcXNxNW8xTE1JY1NKdVpaUnpuZm9SWlk0akhOK3dnVVNaSWVoNVlWc1ZCQ2dIVlU4d3l3QXFZbER5YVN3YlFuV2QvNDZxdUlFSm4vY3JBVDZJcHd3VjI0S0hzZWhiOCtjd3hWaFY4RW1wT0tWNE50VThtejNhdWpRT2tncG9rWkZkaTh2cSt2NGs3WGVVNWh5TnpXU2M4V3p1dEpDNDNKb1JXV3RHb0ZjUmJGaVZDVE1nQkFDenRxM3dGak9xRWsxWDl2UlZJS1NtT2x0bnBzSE4wakdzRldXcTJhem0xdkFzVExsY2pWeDhGdVZDek5RSnJnZHc1QXpJVWlZbXl5OTg0VyttRTNuc0MxLzRRZ0FmYVh2K05oeDNGdk1LU2pJb0UwdjcxaVdzeSs3dlNOTEtNMlZXYVJmUnZsMXBsK0FYT2J2enJpaE5vMzhJSTFxTTNvZm9tUStFTVVtallwekMvTC9KKzVLeDB0OEhQRzlZT0ZLNENqamZNczFrT0tETVpHNUphNDFvU2YwUjNTODlUTXJyVDlnTEp0OUsrQmtKZXRXVkdGVVk5eUl1L0VsK1Zsayt2akE2N2MrUEc0TTZhZmYyekE5My9xUTJQNzgzTmhMTlNPcnUvazU3YjV1cmZsR2pidGo0ZkVla2xxalhOU3ZWT2hkVmVORVNFUWlPUlZINTZ2eXgyZjE5dm4raFBtanM2Ylg3YjVqYk54ZnJJdFVUclRVSHA4QmEzVXJKNWhVdnFROE83OUVUYytuZUpUTlNyTkdSMVZuNFZiMjRab0MrMVR1UDlaclhqWWloZldlZm1RWFBoUzlqc2xQTVBaYmZ3bTR2LzdJcnlmcEhWMXBwTy8yZWFEYkNSV3NGNWhka3ZEL21OWW5ucDZuL0ZHTlA0WExuRzAzdksvaWxNTzBYaisvdUY1MDA3b1VaYUxXZE9IVkpmMHp1Nkx6dWw1OUszOFozL25CWnVmNnBWLzUrK29XcnljSHVyZnFIbnFxRlAvUTcwN3piYjhKekdJVUt4cmZMaUwzK01CMnI4QUVWLzd5OFFHNjl0M1gvdy9lMzdyM3JycDF2ditPZGwrWkZJZXdENDRNSHgyZGY4SUxMUC91T2QzeTJONWVucTg5aEk0bW4vKzNwajVOL0pqOExkeG9YV29XdHdvbkNjekN1dElNRURBZ1Q5QUtrY3NBNWtuUzAza01TQ2x2YW1FSXB3ZUhrLzlTRjN4dGl6VWJZSHNxNnBDak85TEJhUkc4MW5nUkdTVTgrUmdUd0hvWVByU1dnWjNYSmZGS3R4WTgyZXUzRzdiYzMydDNHd2wzdmJseDFWY013RnU5WU5NenJhMUZVRXd1OXZSc3Y2YzBMVW8yaldyazRlK2IrdWRKSEd3M1g4RUJUTXVlY09Ib0UzcWhudU52UWw1eTV0OE13NzNaUkZFa0dDVGtlNjBiMDIyWGpuZnZuZTVWcWQySDduVWE1WHF2RmNZM3pOT1U4T1Jwc2JRZkhWaFpjdDdHd2ZKVGdyNk5FTERXYlMySm5CNUhEWE0yV1FmWVZXVU1VbEwxcXlpaDVCV2dxSm1qM21tckxNUFJkOWNaS0lCbHVGNjRyM0FXOVRvYmV4bW1lVFpEMmMvN2F5OW9palhzNW14amtXdkUrTWcxWlM2VUJjMXVHL0sxS1lqRE9hM05KOUNkNVRGdWVUbktKYm42R1c5dHJ1b3huWEprUkc2czZhRHhyZThUVkYyR2dHd2J0bEFNOXJNK2NNSFVYNUVRYnMwRzU2MUZXZjRSZHltc3JXRjRKRThJR005b1Z6elZCODJKNjRqZEI2MUdiNUIxaXFXVXQzbkNIejdOVm9JSTArL0NYUWZqN2s0OWc4RTB6RVY4WFlVTW9kSU5xZGl4VFJ3aFZ5MjRRbi83VEQ4K0E5dFlxQVpVM3N4djV5MFZubmROUE05ZmtQays1RXZpcXAvckJSTjcvQk5EQmp4U09GcjYzVUVqYms1aVJCaGFteWJHa3UxT0JLeG1kcjM0KzlRRXNZNnZJREw1R1RqQ1J0NDRsZEtxRXZsclA0ZlpHd3p3YVZyWmNuRXd3WG1VcWpvUTRISDNGMExjTkRYUGFWaGg3Z3JMSEdVN3JZUWxFNEpTeFdoazRnYnVtRzRiK2hKWm9UOGd2K2c5R3dYS3RyR25tUmtsQjZ3QmpTNHV6aXlRSnIzSjBVcWxsd0lHSkNrZUh4ZkhpNnFiYVVURW1CODFPOXhEbDg0emVUV0ZpbjFkSVhYZWNQNENqMmVjcURVcTFxaHFZbnpjQzlSNFZwc0Q0dklsZlAxZTFUVXo0RnliMHlWQmhyTlZvYk1oYUZZYm42Rm9FQ216TlQxcllGeDFvMC84RnRQOTFoYjJGMjJRZTJHc0xieWo4MThLbkNsOGtCUktRTHBrajZIL0V0aDVKMzlxek52VkFJaUpGRXJjV2ZzRStzQjVXeUFiRzFrV0hSYlNQb25lRzExbU1xVXlJWk5OR2MvMW9mQTd1Y1FxZENZSXliRVZ2NG5vazFsUDVvNy9ld2NzdVNOYy85dmI4VHZMM21hVFN4RDhhZ3RJcVphanp0eUVGVmxTeUJsbXZuUW0wUHZmUmJyaTZKUzJERnp3S1ptOCs0eEdTY1krdndXMm02MnZqMGRvUVRyS2FxY05uSGdWRUxPdW52Wmhzd2l0a1dKN09JV1N2bkRZSWNibEdCZlc1OERqZm0wOTB3YXFBVkFRREJjZEt4WGFJVmRZQ0UzL1RodU9PQmRaekZCVExwV0FLTEliMHFUSkRCczBoTzk4RTBSVFhiWUVlTjZNd0R6Uld4Tzd0d09DOFhJR1YrZVJpeG5TSExaR1lUS2ZQd1FZbU56T2xRK2sycFNGT0NwMERiUXorWWRyNTU4bmgyN0FqSThjSk9VRVVhcUlsQnU2dVJjZ2hPYysvb0w0SWkwTUJ5SFBpa0ZCYUNremlrTVphOUpBT2VpYlRWRTVvWkFTQ0lSQ2lJRFEyTmxYT0RZNmVRRlhEMHE5RXRWUWd5NFE5Q2c5RHlBeFZib0ZuaktteXBGQWRMaUcveFBEY24zcS9RalBHTXFwY0JIdGk2aGdsTndNTmoranJpRzJUSXNYN3AwVkNGVjl1bjVFN1poUU9WZ2dzTUxZUHhETkNBemgvZ05ZTWdiUDFZOU85ajZtNGR3WlArc3JYRXFsQ1NvSk5ENUFtOEdhczJZc2VFRmw1dXhPM0pBcE9LdXQ4NUZXMWg1TjUvaUhOWnBNMGQ3NXk5ckhIemg1b05tRjI0Q3RQd2hmNGV1REFrODNtazgyenQ5NTY5ckhtV1ZqY2VtdGhLb2M5Ukk0V2RLQndseU9PYUNoNklCdU8wLzVZWnFvaGtPb2FzRTRZQStqUGhzdTFaWUF0a2kxWVptSjlqQ0hoNDJsbDFaRUVoeGlkajNoUDhtcXVHR3NqUHR3ZXI2MHROZm9icStTdDFESGRkS1hFdDFwcTdUUVFObWErenJqMEVpdnhETlV1bnRZWk4xOXQzbGFQYlJPazhVYlN1U3gwbUZNTjB2dlVUdVM2aWhXdEFkMGhGSVJsUzBtS3BIbm16R1AzM1BNWXNYU05LbFk5dG1aOFlXbWtTV2h4eHJNZEI4M2hST0ZxMGxUMVhyZThKd1Y2ZVcxY1ppeXVXVEV2YlhLaG83SFFzeFNVaFo3K0ZIa1U1Sm90aWRaN0MvREsreWQ0aVArcDhQYkNld3EvVkhpaThOdlFVdXY5aWFBeHdZR1lCTGYwSmphVFNZSExpWGxrWWoyT3B0WVNnaEpNZXdKVEFpS3VPaVZFdysvNGt2Ny92U25uUUpoOWc4cjQrbWtoZkRmeEloM1RIQTA3VEdxS3FwdGVXR1NLMEUwbndESzR0dWNxWExlOXFHdzVsbTlZeEhTc3dQWjFrMncwRzlmZmVuMmpPWHZvSTRkbWQ3N21GYjFuVEJmL242NHFnazVZdS9UeVMyc2FwNWY5TklpclREV3NNRzJZdG00eHhUSnQwNEVuMEEzZEVqcGhpbUZGYnVER3RvZTFhNTJ3V01jMFVtNDZTV25uYTVjTjAxSXBIVjUyNk5EYTJxR2Z0K1FGVHNFaTlmMlQrZUo3LzcrdDdGT2w1YnMrVEEzTjNhVjNhUkxENkJJWlQ1bERXajRUN1ZuTkN5dTNlVHJ4T0VqdXY5YWRncFlJWHBkb2JPaWNrQjNyOFdLekNCUFJMb2g4K016S2tSV1lmbEVKb0RWTXVLZklWSzBBcmZ0KzFOblNSS3l0cm1xeHBtOW1zUS9Lc3VzVmk2MDBQYk1yRk9QQjlzcks0ZFdWVjJxcXJxcUtva01ud0dJTXdyU1ZUVDNTOEhndDBqY1ZHSkxhSkg3d3czQm5UNElHZzNZTmxNMngyQ3JHZTJMaVEzY0tFeVc5SERsT1lRNFYxVG1YQnRJR01YTDYrQ1JzYmR4bVd5Mzc1QW03YlRtMzdXdFdvT054eHdzczF5OE5TcjVyQmI0dE5GM3NmQ1BiUExhWnlkbWg3cUFMMDVtWTMyYTNiRHdXem5BYmp3UEREbXltWURsV0lURGlYR0d3d3ZqUXpMNHMyM2NSenJLeXJFZ2tmYWQvUkY5RDNpUHRORU5aaHlhWERYclRvdGVUTkxUekRxRDhPYzdWRkViNWpieW4zSzFVdXVXZHNJeGZpUC9ZaVd2WFYrWk56MDdhODlzWFArLzZwWGxOZUhvek5VT2oyajhRTjhsVkl0OFZqNElsY1lTSW8wVy82cGI4R0FZWWRIN1BUcDFXMFk2RDB1SW9iZ1Z4TUxWQmZ3UDYxcVBTcWxUb2lHVUs3VG1PWlJhZFAvYkhXUGh6bUtSajRoM1p1QWxHOTJoODlPVGVJKzkvcUZPZlBkclB2S1k2dC8vaXJYbStvTzg1dmxlUXExczdaeCtwUllGWTBCclI5UHlmSWY4Rzc3V0crSFZrVWxkUFJyNk1FYjlTWGcvbDNMUWJjbFRMQnpoRGl4NG5lN2ZXRnBlQVhkUTZ2WVhoY3V1YUZldmd2ZnRCcXlQTDE3U1dWaHNYMWVmSG80WEdzZVpnSmdqSk96cnQremYzcjJaUlZLKzMySkg3SGo1enVGV3Y3N3drWkxIMzNGYzkxNHRadVBiOUI0L0FQWlhnSGYwK1BVaCtHWFROc0ZBdnZMZndxNFhmS1B4dTRmT0ZQeXQ4dmZBL1lhQzdwQW8wL2dweUN6bERYa3ZlUXQ1Si9ndjVWZkl4QW5SYVJiaG1pazQ2bGdkNmpoSWlQZnpqYmRwVlFkNTJLUG9kRVl4L1BCam4rUHZ3R2F5bkl5ekppbXhzbTJKMmk0endHRTd0YWlOcEFFZUFTbmVhVncwUy95aVBGc1V5Vk9rMEdTV0xrUk1nNkxhc2FqN3BPd2pSUG9LcncwemdyQWN6YVlBRDNSWnh5dEFsaUJWZzRjcklWVHZkUENPUXcxMTFSOU9xR2JKZXBrUVU2by9PamFRMEw0Q01ONVQxY3I4bElub1BRQlpkdzZ3WHVYVTRFSWwwTGFJMVQ1YS9rZ2VNMTNyb0ZwRGV5Z3g0V1k2cjBJdXdOQUZhRi9IWlVWR2hreWVXSG9SOExPQ1YxSW5UVTg3allUSVdDQmUxakxrNjhsSGdpZzRHYytLVmw0bGdxeHNFazJNeGtVa2FkQkNrR1RmVExwWUw0WFVLNmp2dFJaYVJhclpoZHo1QWZIZHhWbThkMnZtbTNZbHNQZFVzOHRlRUZMTnFrWC9vYmJ4WW1TbGlGb2ltQ01YVk5FdjFUTXZ4Tk5zanVxRVJIMlEwUlFTZTYybUdZanNZdGtnMFJKMHJhb3FsMlZHdjQ3Yk5kMTVkOWdMRXYzWUZwcEl4akNRTEJUcnViSUVJc0NSR0o0Ym5XS2FIb0RIb0UyV0NuVW9RMXdRSVoyeHdGbWdJbHVvb1RmU1VBUVhkK1I0R1lpaUl6VnFGb1pqaGdKQk10VTNnWlp3eHdaVzdsdll2THU1ZmVpdGVqcHRjSlVaMEJhYWFhMjBkaFByYS9GNUtWRDB6MkhXS0ZNckRRRFhYWjdMWnBaWDUxcHpCeW1vUWdqWk1LRmQwVm5OaFlkTlZFU1FHTFZJV3FycWV0RktpWjdXVUVURWNWa3BoV1VPOGFRdkJFVnh5dUpVMnEzRk1hZUJ2N0huMDQ5QjRpc2sxb2pDUTZmWVN2VzZFYXFtUjZiVFlNajhkTjlLMnArbEJJdFRtcDF6TFVMaWRrSi9nQ0dua2twU2lBQlY0S1lFdWZnOFFheDdHb2Izelk2UnVUVGE0OEU3cUVRRTlrWnMyaWVvdVY0VkEvNDJHSmJrb3NCYXpXUktLd2JpcWc0UU5Nak5SVk0yYW40VUxhZHpXQ01oem9NZGEzREJEaEJOcVg1UjJLTk1OVkZhY3RndDhRbFdaaWFWOFZFVlFROVY5MC9RTllGem9vSVIxS3JBQ0p2NUZyeGh1b0dGNWtmRC9wdTA5NENXN3lqdkJlMjQ2TitkUU9keGJWYmRlcUpjcXZmeTYrM1ZXZDB1dDBGSzNzaEJxaE1ESUFvRUl0bHNFRzB3d0xHQU1JNHdNWTJ4allDMW1GeHVXMEl3QWV4a0huT2VIc2NGZWo3MWV6M2dHcjcwMk0rYjFmdCs1VmErN1FUYTcrNXZ0Zm5WelBQZWM4NFh6ZmYrL25ycWlJb3B1V1JLRmVwTjRMZFdTMlI3UDFzcTdicXJEcGNxdUpDaHJTS0NvVjAzU0hEVjYrTFdlOUFxbUxNaSs0MEEzYlhtWUVlTmJDdEc4aU9DWWJld3ZnYW5naDJDOE9BMnhVNnpZWmkyYUZhbmdSS0lPbjRsOVJ3bXJpZVNZZ3VVaUlONi9DbXlIMmhYYkRvbGppbHJkc1NLN2hHUGxVRW1FMkN0MWZOMVdOQmw1djl3RXBrY0pmRGFKeHh3b3ZsOTBHa1pGRlJ1K0c1RFFocXVJUkx1L0VuaEZzT2NNUlRjRnJaaituMUFITmMzaW9lTzFORTJrdXBmMzliOUgvb0Y4anBzSFRaY2I1dEVHVEpWbldYUVRkd2VManA4RVJPMG5NNDZETUJjTExMa09od3BxekUyVUI4em1NSXVzK3lPMXluMGJ1OXZyTitsYTQ5U0lLc0pRTXRxeWxHMzBSREdPd1dJYmlmcE1zeFhhTXRwY1VqUFpFUGtlRVpjRTBqdFFMUlJGcWN2aVlNZk5vVWFQamRZUERTK1V5cDg5TkI3c0ttcXg4THp0alJmZkdvSFI5MlpkY3JQNnNwU1dpM09hb05DMzZLSlRiY3hXNjI1SkVVUjdiYkZmNGNYSFJhRzIybGhXSFd1NTBnUDE5bkdSTHk0ZVA3OStmN0dreWx0TEt3ekhZOTgvaTRqYkhoZHlGUzdsRnJreHQ0Tis2bmgvZEl2MHR3aU53eEdqSTVrUU53VTBkV3NrNnc4WmpDcitrSktEN2FSaFBNeUdZNWJxMzJlUjhpUE1pWWxXdGtudTF0MnQxL2IrL2pmZi9mZEhaMFpoR0NqT0kvR1RoMjk5NHhITHNrenJTSG4yeUpFanRpMjFMSjNxTnFnSE1qUUhML1hKS3ZPbEtudHZiUHorN3pmdXJ1Mzh1S0owVEVYVEIrTmxjcnI2bXRZU2lOVG1YK25GVXZIbE5hUHF5Q1g1WE5rd1l0T2ptbG92QkhXT1hObTc4aFZ5aVh3U28zN2IweVJId3ZnVVIrZ3FZYkg5VEQ3czgxL25HYVhMNDJ5cTVPVXliVG1vVGtUaEpGbHllUXFSRjBma2tsMEtLMUhSODZ6Ni9XdW9reTJkcmM2M2g1WGovU1MwcWUyNUJUKzJYR0hZcmZpcUtHaUlONmNLZ2o5Mm9LZWhpbTc3Y2JYT3Qwc3pjRERvLzVidkYrTHlqM1VDVjhDZWoyNGZONHlOdnFzN3gydXgzVzdOSTZDOW92dHhFZ1pXNGxoRFZUYzhMNDZnLzV1dGRRS1RtTDdwNkE1MFJSdWcvUkpocHEzcWlpN0pvcHp6THZLckxCOTZ6RGkrTUFkVkRsbmUwb2d1OVRFVWxtRkVZbXVKY0dDTmVhT3pJRjRPckFsSUVlYnJaeWpjd1U2ZUtFL05DUnJsbUkycEQzTVBINXNNTXdTVFphRDU2VVNyWkhQeVpMUFVFb2psWmFiNUxLSFE5VG5OY0cyZWVEN2YybTdINGFHYW9Ec1dRdlNSd0EwL1NRU3F1YldZRnlSVmMwaURxcGd0R2RYQk90TFlycm9TMWpjcVJGQ1ZjeEpWSzI3Z0ZaeEFybW82MWZZYXNtU2VXSlJMWVdGUmlNT0NYejhlaHhiVmRXVW02YlNTTnQzc21nYXg3TXA5QjBaV1VIQnZraVE0NjVzSzNvRmdONjNaWHlNODNBTXVwbGE5Q25iUUlGd1ZIeVNhYXJtSU1LRk5kY3V2d09OK0Vzcld5WkZzOTdQQ1NkOU5lVzdsMWdkdlcxNis3Y0ZiVi9hNEN4ZStzM0xyQ201WldibHQ3eW55MXd3My9JL0pqNU1QUVp2YzVEaUdrWWd3QUdNTVVoN3ZzN1hURkQ3WXVKT0U4ajZPaEoxVGUrV2ptQXlyNkNXOEtSUCtCa2tCWFZaWFR1eDZjVHlycVc3OXhYRlpOZitXd0pPN3JkcHNjZGJRU0puSTBnRlpJN1lnaTRiNHlzajRLZk5zbDFkazhsSUZIVUtxbTZYTDUza3dUMytFOExhL1ZBcW9vSDVFVWxUNVRrdmtIejNFVFhqalBrNit3QldoSnpuQ2VCWFNaSjlvWkIvOGZqanFDTWwrTU1WMHVBdHFoczh3ZjFHUldwNVk4aG5VTy9KWTlXUjM3ZDYxWmxCck5EcUYwbUl4cm9aMVV2K29jNkNlaHZIS0hZUGwyMWJpTUtsdjNWL3IxNWFhRGFWU2JwZHNvMzB3STVmcXpmVUgxcGNQekdTejFXU3BYT3ZPN0N6UG50bDdkSFYyb2RmUGhuY09oM2NPdXYzZXd1d3FxVmRYYXJYcXVaWlhMbnRtSkt2bGpUeW44c3FWYjVOdmtSL2pOcmpEM08ySWNOOGVzb3FkZ3BLY1FwdUJYMGlUTUtacHNrd3hKSUhLeTVnc2hBbllLNWk2RFo5c21JMzdLMzBHdFRvWkN4OW5ZVDRhSGJBQUUvU1BTZ2dOajdsQUhiS3JndzVXVmFIR0U5L1VkV2k3cWcxeVViOXVzMGJZZGdzVXRsWGlsWHppbG9MLzlmNzJBdyswNzNYZHlYenZxV29RYkp5NWNUME0xMjg4ODJsVHc1TlV5MVpKcE90RXNTMDFJQnIwUW5vQUh4amt2Rkl3RE1WeGNLdHY0aFY5dVBMOXBGVXN0ZTV6bHB6N0p3dXZyOTU0WmlNTTh3c3picHIvd0Y4aTcrZE9jRGR6citEZXlYMkMreTN1ejduL2lwQlI0NVh4Qk41a1Ayay9IN1dhZHJQN21mc3NWMm8vemdhZE52MTh6NlQ2Q0FOMHVrSGY0OHQ1NXNGNDMweTErUDBMeC9uSjQ2WCtOS1UvUldPR0JRcWtuZnlDeVRSMkJ6dnZLWjdGS0I4a1crNWtvSzZublhRS0hRQzNXbzZ1a200bjJiQy9NbFVKK3JrY2tlU3JIRHJUelAvK0VvMldRM2JYY1kybFEwVy9IOGhFZEkwSWRHdyt0UkdmS1RTQ3NMemo4ZVhPVExWb200S2hHYXFqU25GVkxmSmhXdmNicmJBMW03YXlNcWlBNm9LR0tuSXhxQlllSjZBQkdjN242bW16b0VQWEpKU0s3UlNSSXNHNEZoU3RHT2l1UlFYQjg2MXkvRFBFTTN3blJxbzVOeGdjcWpVajFMcExTZloyVFpFMHkvQkxoZzBxdW0xUWkvZXRxR3lxa2l5b0phR291YVpzcTVZWFZXMFNxb2FwZTZyamRmOEdkTHBxWkFhNmJFY0d6eHRXcTEwaGQ0bTZiU29HYUY0dWttYWpURFA0M3lOVkx5aUQyVkxWS2VXbEY0Q2lLNXRGSkk5UlpZTTZKUnpsS2tkRUZVVFhLUVJWQ1V3SFV4VWNVR041SE1EcXpEb1ZBZDQ2UUtieHczWlVEVnFseU5BSm1qNkVxdnplTHhEUExSc3FpRUNQNnBhTTVKYThyQ0Y4b0NDaWZTSEREWVYvUXFZWnRXVGFtUC90ODZaZDRYaytvUFJoME9jZHhXSUFKS2h0VzN5b21BeEtneGNLY0gwUmd6OUJYeVVDb2pScW1NYjlKZ1JDdGhWUlExZ05JdnIySDRMS0tnbzZ4V1IrWWlsUStDcDAya1FJSXRoQU1hTkhaam1GTEFiZ1ljN2xFdWdWTjBHN3VwZDdFZkljSXk0dUF4SEdESnN4cG16a0dFRnN0SEhReVVPRTV3ajBIRXduN1kvUlJFYmNMTnhHMmRZUUttbUttN0lFUkdzNnZ1WUVldTN4NU1BdHh3L2ZkTlBoNHgvT1o3ZmNmdkxFdVhNblRuNDhuMzFXY3JXcWFtbUJZcWpDSzl1cVdUY0NLMUFxaldQdmJhdEdTZmVnWTFEYUNnV3RYSFpOdjMxRmN2WEs1UGpYd0JFTk9OeFg0WEJ5UnhRZVBYTTBoSDlzNXNiUjZidE9SL0ZrOXI2aUloNEQ0ZUUrMGlPQ1lIbGdaOHdUd1hiMDJWWW5jU2k1YjJkeXdHdW0reGtHMWFmNGRYS1o2M0VqS0wwRDBBcy95LzBxOTlzYzUyOVA4dGRaY2lhTHRtZnJmSTV2ekJDd0E4em5ScHhFUDBHL0hldGZFam10OCtPTWdPV09OTmtZZlpCallEQ3dwalNoRVdYOFNhenpZQktwczRYanc0eENEQS9JQWREWngxclp1ZHFuTWFPQ2pRaUhqSDRKU2ovR2NEVHNGdmp4UHBvVDgwQ3dUaW9jWi9GZ2lMRkpjTnpmU3JwbWc0R3VvMjJvZ0VDcGhYVkw5eFNlR05HSmdlRlJRc0cwTVhVbjhPTlgyU09kanZ0QzlIWkpOUVJpRjhNR0daT05abWxtUlpMQlZDU1dxQXRTRUh1eDVQaThoQ0hFU2dDNi8rSVFWRDhxZENrWVhBZ2FvWU5oL2haUm90ckIwendZRjBXWG1ySTdyOEViaUtwRmlHWXBqZzlXQnRSbTBhR2lWSUJHam41R3pkSGk1VkFzNmY1dkc4SXVjYU9BcDMzb21sUVI5Q1hIRUd4ZUpKR3AyVTdCTTVxbTRCUVcxM0RvUTFZUkJSbU1ObDdjKzBkRDZhbSt2UHhsUVpSS1cxYWZlTkNHOWw0M0xyWjVCdG9neUNhb1dCS1ZwTVNSSlV3K0FZVlBWNnZSUUJFTkFuSVFic2V6aldvTjhVZkJPcFY0T1lrVmVPeVNqWkRESXJ3MHJjcU1mY3BxdW1xa1UwdENFNzNtZFh0KzNaVFV3QlJpSXlpVWhRS08vWW1DUVNnYmw1cjR0SkhidGNVdEkvYVJ6MGE2R2RkdGpCazRETHpwZTZET0dJcFRRdE53UEl4aVhHUWg3cmdHeC8rR1owSTNxSnNlbUhleWJ2citNOWY1dGI5ZG41dXJlMjV2WUg1c3JvWTBXbEZ0WURqMU9lTGFzWGhZakc0UkR3dFJQZnJnTlk3c1p4Y1BMcXEvcWZXbFluTWhzR0wrS1ZoY1pKaE4veDc2bTUvbmprTWZNd25HdDhna0tEK1BWNTNLTXRROG1LM0xsQytza29OSkpPeVVpbXh5NEppLzFDdWFHbnhDeGZTMFVEZXJDOTAwSzZ3VXE5Yk1mTlJ1ejY4aEc5cFFVa2ViclVOSER4Wjk2SmJMNmN4d3VEdzJMTk0xSGJraWRlYVR4RytRbjZ2Vm5FaVdTMW5ScEtCRmozbE45WTJhbzFFSGVuRWU2NW9zM0tmd0d1SkpFOUM4RmFpbzZrTUxzNFNYcUdHRnk4cU5vOW1DYWJMWXJTK1RKOG1uTWY3YVQrUUp0eGFxbUZOYy9BbC81OVgweHB4eksrZVJpSE93TWVnSUpsMUlycHhpY01ldkQrNnAxSFN0WnNySStDYklyWVBaOEtDaStsSERMNHVnbm9tVmpnbTJxU1ZyaUhGYmh6YXJxTjFncGQzMG5GTGhGdkxwWGpZN2FwYmpNclJtTVBCVXgrMXV0OVlIOVVZV1Y2QmtITFdqT21ZaGdxWlZyZnRMNDhwU3phcllBajliRGdZTjE2K1ZGK2Z1ejFvems1anBTVjA4alZIWUdEV2FQK28yenlodDZZUktEbDBUT2ZWWURvdkc4SkJIMy9XdWRlekhwbldWWEs0RS8xY2syM0xEYTY4M3UwZG4rNTIwVXdHNUJRSlAwY3FGVXRKYjd6VzlTT1NwSHRWMWFEbzJEN0x1L0xUeWtVZXhJcmJpRGNNbDNhTTNIMnlId2VGdVpSWDZreklZdFhXN3NtdzVxL1BMT3lWUEQxdVc3MUhMS1ViMjJwWVhwbVJTZmJrY1greFhtUS9pK0pUdkk1dDhDeFlqOXYzZmNKQ25uaUppL0Q1Vklma3Z1NC90ZHRLQzdNZ052N1VCYnpmWHo5S3N1djkyeFZLeUFHL25zN2R6Ykw5RUs3SjA3SGJtWWJnTTUrcmQ0b2JoekJ5OTVSQzgxcEZ1ZFEwNjVBcStsbE5adHAyMStaVURaWGl0ZHRWUFNwSDk2dUpDK1lmUE1NOEdHMlA1My9najhMMUNMa09zaWJaczh4Z1FqWmtzKzBBTEdkWlBPWFF6TjJlWHN3Z28vaXp0SjRUWHhRalVVT1kzcUd2L3hudE1JV3lhRDdheit0RnFYYVYvNVN2NlBhTlRHNHVWeGIxL0UwYTYzL3pSKzlrUkN6ZWRVbFY2WWpRU0RWQzAwbFZURkJVVUpqZTl1UzRKbHJuM3MxWHlBYTBZYnE2MTU5U1h5VUdvV05yU0tHVUh1OHYybEpjV3VVZ1VlUElHR3h0aW1ZUFI5YVFpZWRJcGJCK1JvNUY5OUtnZGZlSnFLTjZsZnV1SmxhT3Qvbit3bzVQaDhHb0VYNjNWLzhlVGZVNjY4cDByZjBLZUlSOWs3RzROcm9QWjl5UmovbkhKSXJHUFJoQS9Rb3N2c2tsR0VjVUNNODB6SVI3VE1SUVVlYzhEbGtoZGRlOWJoaWs4TFBpaGxQNjFZajBoaUx6N3pEbEJFcjk5ZjQrWHlTMC84amUvZXVHRklDNXVVaE5RV1BsNVBqVDNQcVNwb25MMkw1WFEzaUNpMkhWaVVTYlJYNzRBRWZ2OUwvMzFzNyt2RW9uWmVSZzc5ck1zVmhIdEdNNW5xTEw5a1BGRlllZXlnVFZ3R3FFTnZTYU9kS0x1Rm9mN0FkMVRNM2NMRXdBblBVb25GYVkwZnovZk1MUkgzbGxvVWZoWGlkcmQ4aU5SdlI2Tk54VERjQXpqQzkzU0kxSERzUXFsWXFrNmV1UnBrS0dxb2xqZEIxVmRkdzJEUENWYmVuSEdySlpxaS9WaWRiblViVVFQaFhWUjdSZ3V5RVRYT0x0VTdqYWpod0xRNVJYRjZjeFl0bDRwOWh2anZUMDRBUDZtZmNybnlhZEFueHBoL2NReDJDQW5DMEVSTjJsWDJIMkNSWlBrSTVzNzZCNEY5WVZPSFEva0V6VFFGTk1zQmthZ0h4eW42ZmlnRG90RjAvUUNpcUphMUpSWUZiTFpEODFsZ2hvckNPUERWMGpKTXVHOVFwQ0NuaWg2SUEzRGFxbFlMaEVOVG0xVVZxTjcxZzdzck4wYnJaVWJjR0Z0bjUvbi80QjYyVUNPZFdrLzVMNkdDRHp4TlBReTV3UUNIV3M2OWd4SzJ0eUoyZGtUY3d1bnVwSWc4OEdoUjkvdzZLRkRqKzYybTZJc0J1czNyOE5mZWU3RWJTZm1WczR1aUZSYzZPL2lmamdJcWMyUHpPRCs5ZnorM3lDZmh2YmNRajlNTzVWenlnL1d0VTRpQzVqVUdlODdOMWlpQ01ZVzV2bDZMRXVBRWZPU1Q2R2VVZ05qUGdtQ1N2bXU1OTlacVdhdGw2MjdRU0ZweHg2VitaOXd2VGlaTFp1S1h2QU4yL0pYKzJUdzZIRExVRFJWZGNGQVhGeGJuRnRabVY5WU85aGZtbkdxbGg4NFJkOWNMeHAyWEJCOXN5cWQrY0NaTXpmdDVMRTFWLzRNR3NNSHVDRzN4UjNoempLT3kxektUM05XY2p5OCtzUnV6bEhIKzFpUS9XaUtRRG9lZGFTQUJxRk1FWkdQV2RhVFpENFdTaXJKMDZ5WWFEUnhoVjhIdG9jVzlZUUFaVEtFUFBYMXlPUTlvL1hoaHFLSUptMXFJVS9zd0FKaHVZUGhqdFN3SXhNSlBubkJlL0VSVFkwOHhlaFh5aTdvUkt0N255T0twZ1JxSUlqcWpBQ1dic05kTEFUQytCYVgyTlVXK2xhOTJLalVnZ045VXlTR1l2bGhyZDRCczBVU2hWWmpkb09YTE52M1MxSFpFNVhTd2ZiZy9HQ0R2SzRpOEJWUm9ZVnFkeVZwS3dqOEpac3g3L2hlMFN2b2dSc0daZi9RYllnM1dXazFCbjV6KzhVblJBeTkwc01YcGtFMUxWR3pBZ2JtMGx4b0VPWGs0R1dhRE1xMDdSV3FvSm1xQmJtZ0VsblZGVk5XZUtzYWxNSzZZVXRFbHpTV2YwZFZ1MmpGcGNINTRlbzlIR2NqMWliUGtROXpjOUF5dDdtajNIbnVmdTVoN2lYY3E3azNjVC9KdlovN1JlNlh1Y3NNWDVrTlZkaUVqVkhXbVhvWHNGeGU1a2VhWXBaTUJxeHJKQWZneGhZZVk5WEZIeHRmWlFsVE9BaUNsU0xKMFJBeHZqZ2Y3b1FsSkdtaG93eEhnUE1JbjVHUWYyK005WVQ5azN5M0hSYUlEQ2VCM2NxMjVkOGVLWGpHY29xM1k0WnVOdTBEeVFjVlJWQ043bWJUVkpJRFhiQTRWWFYyWlRobmlZclIzV25xWm5PamE4TEczbmp3VEhtcFJCVSthUWJ4eXhWWnBZVkkxbFFhRm5GRVVqTTBLMTZJelVqWElpdGFoSVdQWU5SRVhLQ3hBdlpUSVpSLzBMRnFOZXRCYzFDbGNkQk1CRW9OZUl1Q3c4K21ybWJiTHl5Q3dtMHFWQVM5dEdBN2xsVzN6SmZ5dHJGWU5tTS9iUXBVOG1WQnN5M05UdWNYL3hlL1hNWjRCMUNEOU41dUhGWU5wUTRXMzV3TFp1cnMvTHd0ZXJQYmNWVFZ6SElRSFpxekJHdCtZZWJCT0xESEhVMFJLc1ZQMkFZU09JUW5vd2drc21HMS9jZ0xlTjdMb2lBTGVPSm5WZDBPWXpEVTduSTAweFNrNkU3WEo4US9vNFFsV3F3STFHNzE5Njd3dk9ucHZ0VXc1R2E5L3ZyWVVDaGRTUjNLVjBxT0V4RGlMUVVHOVdPOUJNY2JqZVFSdnQ2b05VV2pXVW51d1VmdmxGbmYvMnZrNzZBL2ZRQWpUOUhQaW1QNEs3a0RlUnIxTWNGNG05QVM1NENUYkgyTUh6ZGNadDgySHdtZk1rUHU0My9DU2Zzc3htQ0prU05ycXdkNGZuTk1xT0ZxcGlRbnJtZFp1a3FSVTBlUVpkRlFkYTJxNndxeURJaFU3czBiME5JOGpWYVJHTWZpZVY5M1RFY0h1MDlUWk1sVXdUam1oY1NyMmxBNDJ5OVpUWlBIRDI4K25JTEo0RlhLbldRMmNUSC9qbExzQjJ6SDFQR2tocVJSVllHTEdHcC94U3NZcW0xUnNTRzdxbEpNWjBvT28yZVJTODFLbzFUeGZVc2tSYmVhenEwZWUrekFKUGJuR3hPc29EcTMrTDNaL3hRMVVhWVRvQUxRa2VNVWZ0ZHNJL2Z2N1dXcnF4bmh1K1B4UDFZRFMzdGZOVmhWbldmZ1IvSlY4dlM0T3owb1cvMkYxYUQ2UHMwS3FzUTVTeHgxdXJhZnkvQXRlQmJNcjhMc0toekZnbTU0SE9jQkVhaWxaSG5LTk9qeU1yVFBNRSsyZ0Q0WU5GQnBLaHhqS3djNFcySFlTcmp4S29MQ3IwUk8rV2kzY2tmY2pHTlg5Nlg3UVZHcTM3am1ST1dhV2hUVzdudnBmV3RDUWEzdGZielFpT05HNFErOW8wYzlBVHUzelMxTFVHVFJ3YTJGdnllMkY1TWZDbUN0R1J0YVJDVGh4NFd1UTdwTHBtN09IcG1aT1RKcjZjWlM5NFV1SGhDZjlrQnY0QlZaZ0E5bXdkVUdjQTNZemwxcmkzdGNHV1R3Z0xIdVJwT2tpS3V2a08xSC9FMURtYjRIN3lMQmhJcm5LcW5rMnBJYVlVbVJNczhiaTRzR2o3bEpNek1xTDUxM0l0dU9uRHNSRDl1MjMzZXQ0ZjZncFdjamZ3TnhzblhGRUEveElnbEdIZDMyQXRuaHM0T25EM2FJNE1qQlJVSGlEVVV4a005RnBWUWpnL3hhbmZ6S243ckdyUDhaclV4dXMzVGNyRkFNTkw2YkwrdWxwcUtvbGNWeWViR2lVYVZaeXN2bXFzNStrTHNGMFI3SDB5OTUzWkRUOTc1ODhsd3ZqOUtpa3hkdHd0UmRabDhsKzJYNkZkMnlRc3NpcmFzNi8rc3RyYlhpcnVKbW5SckNGcnk5djlKU2JjY0h3NmUxZVh5clJZZ3QrYmVwblE3bzJHRFN6OC9yakhTR1hla25yTUFHeWI5ODFWWW9hVVgraktGYmRtQXJzaVh3NS9paVZxd3BWQ25ORjR2ekpVV2g5Y0xMVkV4cGcyOER2WVlPNVhuQ1JyUnFlNnJiNHBqMnA3Z1g3bWNiVFlCb3BtV0JaTjU1eWdab1A2TXB4c0drSSt1dnNLVEJRVzZwNFlHNS94U3AwU1lRbUF3RkJ6RTB4aE9YSCtxZ2s0SHRjdG54L2EyTG01c1hYM1Z4czVmWnFsNk8rcXBWT1ZWTE5DT3NIZHk0bEhZY1VURURnWWVLc05wYlBoK1lZVDFkYkpSRlIzWlUyZEJBTjV5cndEMFFQZjBHcytRM3N4dnUyWDFza3ZBa2h3Szc4dWJGcmNGZGRaMlFZZ1BlWFNqR3BXcWFMR25xMHV6Q29xVTZvZ2EzcUIrS0MwSXAySWpMeW14TExrSS9CNTN4dUhGeVFXdDZmU3Bwb25kN1liR3gyaTgrZVJZZWZNcC84NnZrMnl6MkxHSlliQUYyTDJoVGovMkVVVnpqQzh0alRQYW84VmlPZjNEem9YSjlkTS82ek01NHZ0N1E5V2F0Ti82UlF6ZXYzek9xbDBsODh4dWF5ZG5lMWd1T2FudEJyWkxOTGl6TVpwWGFIWTAzM1B4KzdlZ0x0bnBuazJ2d2IzeG8zVnZjWVJhSm5PdjVXeVFQdjJQNUpPaWN3b3Fic3JBQ1ZDUHIrY2g5MW1jSjIvd1VnR28wemlLYWJpTjAvb1RxWTMrQkhMaWNycWZ3bDg4K3FJTHRMeEd4MHVKTmtCQlBTQ0JhSFhJTFR6UTcwQnBwUFhHcVNpS1JQckZLNStUQU5BTkR6bWVOL1V1dzJXOEp1dWE5K1lLaUNVY0Z4RWFXWlNjeTVYWTd5VlI2ajJKYnJpNkRrYVFITDVRTlg5ZjlpYTM5TFJaM01ZOHlwVDIxR213d2dxSE8wakdMTWdROU8zZGpnMkxYanFPSlEwVElBbEpzcWxUU0pkTnBmNmJ5NGZYbkh6WC9wSlQ0NVFxRkczbDJJYnI3NjlyUzNwL0c2Mjk4YlBmUVk0ZC9wL01SVlZPY3JpT0krdWdCY216NTNQaUFBa0t2WEdpSExkZTA1SEk1TWRzM3BYazIzZXRlZjNRU20zOWxENzdMYTdsWjdnQ3poZS9FK0FEbWtOa2ZtOHROd1NDUGlKZ0NodVNFRmpSaHdYR3NjUTMzbzJDemFjQnB2SitWTWwwZ2x6ZWV2d2xLZmxnc1J5RUlic3RWVExIYmxVcW1wWnRPR0pXTG9WdXViRDUvNCt1Z0NsYlN1Z05kN2R3RXdieHNoemI4bmM5bm44aG5sK2VPZGlWWFo0UjNrbVM1VHV4bkQyU2x4RFdRSTUwWERDVEVPM3BXS1ZxKzRqckZhdEpycmlYSjJ1NWE4elhRODRhT28xMDM0Nlo1Z0hrK1kvTzdjaG45RkdQL04waEcwekhMbVlHWHBkY2tNVjY0OEtoQ2ZQdUdXMis3OEM0dDBYNWFGUUxyNUhWcGpIZS9UaXY3ejN2ZXgwenpVM3JaeHd5SjYvdjNoSHNNN0FCdXZCOWRmYjFmWm1vR1k5a0gyRFJvTnNBbUVUT1kwOUdBalZ0a3pGM0cyQ21oUGcwWUlTeTJqaUdqZ0F5UkJ3MUhVbWlDTFlsUmhtS2p5N0ZkNE12K0p4VVVOMHNuK3RYSExtODg5TVJERzJ4eTNPS0Q3Ulp5RjRwQk1GN2lOVmtWR25PcUx3akVGMnVpS1ZsaXVOTkN4Rzh4Y05lV0VIdTVQcXM2c05zUnEyQVFpVTNCZVpsd24vTnk0Zk1VYjZNcVY0dHZkM055azQySDJnTGw2M09xeHk1YkZXM0psc0x0dGtoRVh2VDl0U1ZlQmRGUW44T0FET0tKWVBxQUVBNjM0TEVJTHdiKzZxSW8vMmZCZmtSNjJ2NEJNYzhYL002VnIvQlBrbWU0UCtiK2d2c0g3Z29PQUxRVHl1SmYwZTNCUEQ4NU5ES21hZTBRTEZXR2JqOUs4eHhjMEh4WllDektUSnZzQndwZGxTQnlEcnZLb0NSWUc5bm1jOGZCTlhTZGs1VkphZ2tPR1kzejVQTkpHaWZGWG13OEdhak9SNm56cy91VDdQYXIyeG5ISnFQWkdVekNsMWpVS3JzeDFBRUVLa0JxdkNnbjI4Z05BRVFKQXNPdHN3TzlPa01kZ20vUFovV3l3QWpva084UFF6bDUwTmtVbGkxRkxNMUM2Q0NkRVVlaXBTdUFsQmN3a0xIVTFBN3dlcm1oKzBSODllSmNOcUxRbDNhV1NyNUpSU1N2VXNFNHJyVGE5ZVhZMmp4M3JqMWJiWUpLTDlXOHJLQkt4YWl0S1hBM3BiYnBPanhSVzdKQURGWHlFU3RiNFFVeE1uZ055WDRKdzlhSklzVFYwSzFBQzNESXdERFpkZ1ZNSkVIejVWZ3JFS21jbGh4VGxvZ0FScmRFVlpNUFovYkdadUtwamJKalhDUmc0RkdkcDRJbFVVdFM1QmZDbXdiNmxxaktKditVU1IwcUdvNGpVbnhtcFJRR05xN2JFcnlHcjUyTG9aUU54V25wQ2hKRG9zZkdUbmtqTEZoUjRlQTJmRTVRM2phaW9vemVCREJZUUg5UkpSRHB0ckcwUHE3WHdyaFNxeGZjU3RVdHUxUXc3R0lFWWlQZ2xXSzVVQys3SkhSTFRsdVJLSFR3UHJGc3pmSUZweFpVQ2xUVnFLVldTcUlxQ1VTVjdTSjBZVjdCeDgyMm9CZTBxa2hVRElpRkFoVjBzSlJVVzROUHhTdEcwZ3pmWVJsNnUrNW92WFdCaG9vamRBTzlJSU9WWFBBT3dXZUQ3aW9RQmM4MHFGakVlS1VyL3hINi9pZjJjNlo5TGdidHU4NmxFd2FnUGpmbU5oaWlJaWlWMHBnQmhObUVZWURsYzRyemNZalFZVHNraHc5RENNMHNCaE15WTBSTU1jVU41Tjd4eVROWHVJVmtmS0hodGxPMWFxMFcxRkpOak9YVlVJeXJRYmhWSmNXNXVsUnV6aWpwWExoZ3ZlWm9jVHcvVytsSFc4T2IzTjFENTZFTHpPYWxTbEt0UkpWb00vWFNRMTdCVzY3WWxZYVpHSWJXVVNOMVViZk5HZXNwK1lCMmZNMGEvWUY0bi9MUmVDRmE4Vy9YZjdaNnFEVHAxMytYdko1OEhIcjFJOUREZGpJY0orcXpJQTU0OWc3Tm5Yd3N6QVFGY3FlTlJMVVlYZzZiSWhZU2gzb0lSa2ZXeURqUEUrN01GcUE1bmxyY0hGVmIwa3FudkxwYkdqaWViVFZqbi9qVzNCeFpOSnBlZFpZRVVXTFp2TEd6a0oyc045TXR1L3ZBY0thV2puVk5mN2JhWDI0MVUxSzBxc0x4UXRZbW5vdXh1Q0lOdmJGdksyZ2VnRTFaTGJ1eElzb21sZXRKTWM0cXg2MjBRMVI5S1V1UE1YdnhkOGx2Z08wa01mdmdKT2E4RGVrNEZPdzhMU0FPV1lZRHNjalUxRWZtWHhuVkQ0YjdpRG9lelJXUkhBUkgzamV6L3Zqd2FPUVF1OTVaYkhXMjA5WU91VWR4bEVMVGgxb3VLclZBN2N4N3JkNXdidVp3dDJyVGlxdmExTENLbmlDNUV2S0lTV1M3OHRMUEZWNUhWc1NoTVU2eURUcVNlMGR1UE56Yk8wb2x3U3RhQnJWVnAwcnRrckNxcm5kbXRzV0JNSDlzZG1sV3d6eG5XVkw5WmtGeG9ITGoxU2I0M2xNODM5UFBnZWhxSVhCSUIzTzNveVZNV3NEWHhVaWtBWDR3ZVRMMHVZSXBnRkV1dWp0QmhpRmFNWkorWExYZ1lYbytQTnZTaXFic2lFaGt2Vmd3QTkvZ0EwTlZXeEVSSkRBVUxiRHN0SENoWUlSSUt3QTcydUhNMmJZa0Z5enk5R3AyOVVwN1gyeUhnVWNpdmF5SW1tU1lNNHVHUmdzV2xZa2NudjJvck5nWWhpSi85NDdqVVFBV1pEQ3hpL2xYd1R0ajdncm03OTJOZXVTUWFXaTVYUmNHY1c3K05IT0NNU2tuRXBwQXpFUUlGL3IvYXAydmlMM1RDK3QzV29WNnVpdzBzdVphay93d1RJWjdyMVBsT2xLTDFtWDFQQ3pLS3B0Y3VMcjFkbFd1NGxhWS9LNGJMSnp1SFY4TlZ4SkR0emVQTUlTaHVkMS9oYnRmZ29lL0JKZGV2ei81MFA3a1QyVk5rNmV4bFZkQUQ3c0VlbGdOc1dXWWtHdHVJOGhUamVXS1lKTC9KSWJzanQ3TzhaVk5hKytKOWdFb0Y3NFFrOFhlTUowMTdyTVdaN2RIVytQL1hhNGxDNnVid3NLeDlzeW5TMGM3WGpOYkdHK2NPbkZndE55QWkyZVR2UGpQZms5ZjJPWm1vT1NYdVNHM0J1Vi9FSHFPRS9BVnpuSzNjZWZoV3p6QVhlUWU0VjdDdlpSN0JYZUoremhqUnZ3TWQ1bjdJdmRyM0s4akkyNjdqeG5ZU0hZMlpDWk5QSmxQZnpIYkJ6VXdxMk9YQ1d2U1pKbXR4OWpiNUQ4L3pUTmtzMnZuTHMxY3FZazRYYzJ3MmI1bVR6elZIeEZSQkZuTktSdTJZS2piK3ltYWNYK2NZL295N1I2VFAvSFVsRDFTT0xrWW5TeFB0NUUzNit4ZkswbGF1bjVMa2l3MW00dk41aWYwSkw3QzFjVmFXcFBxdjZmcmU4L2djbDJzWDVKcTRoMWlYVHdxMWlYOGFVbHlUNUo4dHRsOFc1TGMyMnoreXAvOUNmblEzcXUrOEtXOVY1RWYzZnNGMkFtWFN4STZ1bUUwUERWNnBha1lGVXBVditKYm5xc1ZMTXpmQ3pSZElvcG95cnJtbTY2dFJvNnNYa3FTbzNFQ2ovVjRzL200UHZuM1o4MjU1SW5tYS9Wbm14OWo2M0RBM2wrWW1sa0dyV1lsbVRWVkM1ZVdOUXZraDZuVllWN1hRTGw0cVRiOU45eDc0UU1Qa0o5OGZPOXZiN3VOUExRK3p6YitXV2M0UERVY0JxckFXNTRoS3kwWmRFNVpRYVpzMmNWd01hb2tNZ0xyZlVEWEV6VTVyWjlxRHB2d1M3Z3BuaHo1Si9Ja1Z3Uk5mdzU1d3hJR0lUb2hLcjBXYjNUcTRlbnZPKzMrOUlXNi9XbGJmNkh1T0RyNXR6RGQrMGdsQTRHVWZhck1adVNTclhlN0lESDB2ZjhKcCtTVWJ1OTlIZmRNLzFpN21tQ2RQZzBhQUZSOUtidCtkQzNPcnVXMVNzbmxkelo2cCs0ODFldWRXdGpvdmZPL3BaaHFlSVRsRzVKM3o0OFhUaThzbkw3cjlFTG5YZSsrbXNNNHhZQjdrcnlHdTNkL3ZEOUg0Smh3M080elFhTmdYWjZhT1Aycm9WTlhxeXRqMnhneHpsRFVaQk1Hd1RFSkpXWXM5UHlsK3FpUnBaV2FlOUNyVnBxZFFiMU1LbzFSWTdjc0c2cnNOVzY1K2Vqc3pOSFpoUzZZbEsyYVhZb3I5VFR3UEwrcCtxYWh5YnNyeGNoME5Tb3IzcmphM1drUno2c05hcTlvRG1xKzNmQnU4V3VPMTZ5ZHE0RklsMEJ2VXB4SzBqNTA2NUZPNENaQnIrMlVMU2NLMXZ3SXBKVlJvTXNITmRsVXFLYUdjV3NuQTUyMnNyeVBRLzgwOUNaM1h1MjlzZk5tQWRQTUxRZHZPMkdJcEFrTGY1Z1d4VldtaXYxbU8wSGt6c3NTSTY0bndNd2dPMzVCSE4rekdrVzFEcnhCZk0zeTF4cXJEZHRTRlVrMVZUc3I2SElVdE95aWJxVzEyNXVwYXltb0lGUFRoVFpSZDdwaExXMjhLdzVYN3htTE1aemJxVjJ6dk9YV1BOT1ZCTTJVVkxzZ0kvNkFyTnB1WlNieWJLZGdlU0x5T3NpUkFlcUJvRnBoTWxNSTh6cjNuU3QvVEo0bEgyTDR0VndiQnhBelpxZnNEMjdSNlp6Qmh2UWoxQnV2TGs2R3VxNE9lVW5RT1pMUGlXVzdWK3RacGxxMmVvNVVybGlTYzQ4amxxdW02UFFzU3hKOFhaU1hhcmdvK3JwQUZ4MnBWTTJQS2RYeVkvYStVN3U3L2duTGxPd0w3RVRKWHJRc3JXUXYxbkZldGhadHFXenBKdUh0Q3piY0Rld2gzbDZ3TExqaFVuM1J0UEZJMk42OHMzNGh4eTMrYjFmK2lIeUovQ3kwZEFlemExQWxqdVVGbm9WN0k4RFo5M252ZUdYL3Zkbmk5N3ozM3dXYndVTTNQbmh3MFRqOWZqYmxCVmV0K2xWVmtXR3VDYTZ2Q05ybVpGNVZvWmN5RkNHdy9LdUxHdS82cXFCdDVNZW9jT1pmcmdmcjN5eE1Md2pUajhIQjJyb3FlSjdDYXpVUXlwNWFDM0R1d3ByZ0lmOFZGV0UvdEJwY3FvSFZjKzBSb2p2Rmhmb3MrUTY1ekNuY2V1NVoya2NwWWFOS0VkUElRRUp0a1N3TWhwR2MyOVJzdWszcXJCVTBFWDBHMWJNTWVSTVp6aWJqTFloaXBJREg4TXFwMC9yYnJYNEwvcTdZeFdySFVaUTRHcmFoWE52REtNWUlpV3JSRm5tZDBySlBMdnBsR2N6QnZoZnZQVnR3WitaTEhTV3dUYjVCczlMQzdBOFgyMjI0em44cU1NRjIwdmNDZXpTTEF4SFZLbTN2Q0FjeVhBaWk5dXpJRGp4Zk5nVkovSEpZcllaZkZpWEIvT1ZpNEplK0VNcGdhVGxxQ2JNZjR4YzNsL0JLM0NRRzZqZDVuanpEUFp6bkpkbEVUcGVUQ2NjUytnOG13ZTVzQThPQllTT3cvUnl2TWg5elk1SDE2T251NUVpOVUrN1F3Q2FzeDR5WEk0YmVndlJ2RWN1YkpWZVVUV1JZVjBYVjFoRUxOVEQ5S0FoTmwzaUs0ZXVPSXFwbzJ4OG1rampmZEJWWlZtV2RWZ1UrVml3TlJSdG9XZ3VWdWpiVFREM0tVaGpCTU5mdEVpMkttT3ZZbkpla3NhZnltcUVpdW9xQlhOVzhKaHZFRUNVd1UzV2QxeUtSMGl3SWlHNkpnc2dianFxSk1tKzAvYnE3SEpoaDJIWHJmc3ZrRVRuVHRCQXJub0pDSFdRZzliK0x3K0d4NTlENG42TVVFeGI5bjdFUTN2MHlaTjZWNWRFL1U0SVJZd01Nb3p5UElHQUl5ZjI4OU9oMTVBNGxPVVBzR01yTG1tSW9zbTZxWnNWU0RLTExzS29wRkhmT0UwR29odEFCU280VW9Mc0VNVndRdWNHcSs0RmNYakFZRlI1Vm9BNjZZRjhJUk5haktuNkI2NGtmdm1USUJBN0NMNGM5S2hWVUJRK1M0U1lJamt2RWtta3BPb0lUd2o2UnAwVWpOQnFXVWluQnZFamhPL0c4NkZGZTBoWExMT0tZNjNWK3paZDh0MS96Ly8rQ3ZNWkxldkcvWnpFcTJ2WEZlSzJ6OVdQLzNRc3h4M3RpY2Y0M2NDcllDRzF1aWRzQW1YYVd1dzlLOVRYY083Z1BnQjN3V2RiekI4a3dHdzlXeGtsSVl3UnBHaUtMNnZWcmxLMUJUNTlOZGx5N2lFZGN1NGdzREpTTjd1RXEvYTdWZkEzUEJ5TXdvVGhVd2xMd0FnYUZOdWkwcnpzOG02ejE4eFBpZkhYNldDK1JaZWdKRkVTakJ2dFVraEE0RlhHR0pFbDhMdzhUSWtra0VtU3c4Q2tsTVN6SWxPSTZwZlJ2b0NtTG9rUmhVdWN4MlZjRVcxOTRLY3hGbmVDcEw3ZHRJZHRLeXdVNFN2eGFjMkZoNzVjRnBQcVRSVkhjNG1FaUlwR2VLQmJnREpIaVJMeDg4SWdvSGprb3prZ1BINUVFL3NqRHZGQ1FYbnNZRmcrL2xoZnVFMUtFTkVxRlNGaGJGZmkxTlVFWERoOFNoRU9IQlY0NGVsZ1VEeDhWWHNKTDRqTUg4VTBPUGlPWllNTi84QkJiK1pBVUNzSmJkbVY1OXkyQ3NDMG42NGtLai9CdFVTSUxCeGMzSmVGTitUbHZVa0RCZjhjdXZNdnVPL0NKaExmdVFuWGNmYXNnWHQ5SDdUdzN6OHdXNllmQk5hcmNoRVlteWpWL05uWjFWWWU3N3dyWFhWM3RFcHorWWpNdWRRdnR5RklMdEc0R3hUQ3Bod1ZRMEFJRHZrMWlSNlVDZVhxMWUvV0V2Wjh4bldMWjAwMjdpbjU1UTNlcmlXdHJSbENIYnRjc3E3TENHNFpYU3dJM2w4Ky9TcjVGUGdYOVFaMGJZNXpCOVgxQ3d2aGRKM3d4TExKbm5FekdyL1paWk5oRHkzbmVWNzQ1ajl6Tk15cmtheHA5SXNtM3ZJYW4wR1ROdDk0blNXb295ZnpTenU0bUNFN0ZjSllldUtzTkZocVZoN2VlM2VHcENJWVlIUnhhSFk1blRPdTZKdjFPY2FWRWlDcGJRbjFOb0taNlNDQVZGZWtwZGNXUnpEaENtUFZUWWwxUlhNSmJ2c0U3aGhrcnRtWk9zYVQvUjlCSE1GY3pZRDZGSm92bnBEa0xDdGhwK0wvTjFJd21mQmlQUE5VcCs3Zi9VcmxEbnRwN2tQM3UzUHNMWE91OExLcG1GeTVrMWQ1dHhkc2U2MWFpcU5MbGNoNFhxQXMvZkEwT1pjeXdKSyt4NUdsRzYzRDFOSVFmR3Rlazh6ODduNnkvci9qZWc2OW92R0w5aThvWHM3Mi82cEtMM2V6WGZ1MWR0N1Z1NjE2cVBibnpkT0hwZTJleW1RdFBQUDEwdHp1MTRUNUhmb1Y4a1p0Rm5pY2Z4Nkl5UnNCcmtVVytNMFYwVzhuQjJCWUlYV2FZL1FOVUpIZklNaU1HMk4rNmorYzNnVzdMVXhXL0lpajhSL2g1Z1FoZkJsMmUvMjFlV0JCVS9xY0VSYmhIRUc3bFFXbFFoTU84Y0Z4UWhSVUtSNjNCT2h4d0x5emVCZk9mZ1NNV0JPRjNGUFUzUlg2T0hPU0ZueE5tZVlYLzE0aTMvMFdCQ2lrdnZJdm5UOEttbXhING1qOElTMzhBUzVrTUMyTzI2UzZCOHNkNTRRT3cwb0thODFzUy9TRE1acmxyY1dCdGJzQnRvVTB4UnFFRWlpS0dOZUM0aU04K0k2aUo0MkZ1UG1jNW5kc2lvMnljaHZWTWJldHNNblljZlVyV3JaclhkcHhPUzZsYVpma1BVU1kvN2tXci9SUDlZZnRHa3BVTExlbjhSQjk0QXRYRU5DMzR4V0s3V0x6THJNZ0d0VHNkMjNZTjJUREprVXJ3TTBzbWY1YTArdjBUQTdKYTdkYmk5ZzlPUmZ5ZkpLZ2FKbGFwVllLLy9KMnVnSjM0Sk1pVkp0ZUh0K0xJVkY4TysyaEQ1eDdvUlRMRXQ5cVAxS1lkZE40aVRoSGFTcU14Tk4wY0hZdThwZFZQMDM1clVCL1VYeXdzTitvTDh2cjljZlZZZmJBOXFQOTlDN1Rna3UvWUhiK3UxTHhTNjZ1OUhZU0NJSFlKejJtVjRLUWJtL09kYXZ4SVp2SFBydzlxOWNHL0w3VUphSGRLQnhSc3cvWkkrM2NiOHdSUHExL0ZnY1h4N3BSYkJvMS9kMnI1ZzluUDhqVkcyVGdhNWF4cjhNelpOby9HdTVSTmtKN1pPNHkvNTN1d0dQL1Y1eDIxN3BVNnBlb3N1Ylc3T2o0OTNpZ0ViNUNPdlBnZzdOdjdhRjNOdXE2YkJRM0xOS3NmS0lFQzMyNFgvVW9sSzVjeHlIL2hsbjVXYU16Vk5zbnFtZEVvSStlSU9kNTV3ZGJ1WTg4YW51TjJ1NjVpeXRXYThjYldvQVYvZHFWVGdUK21yeVBlTldMUGd6U1gyQmhnSjhrUkpJWWp0RkNRK3hrVHpqcVR3SkljVXpUdnlWbVF0Y3g0RjBjNXl4aGEvYURHRHp2SkVKRnZRTWd6T3V0cExON1YvK2k1WGdsbDZJYVpKeHV2eXFpWDh0VFNJRmZ2azVWbHZQRWs2cGExZTN1YUE1UlBjb2MrU0pUVUl1UitxYUpBdzVOQkZTSXkwajRncUR4TXJJMWpCWkRocmtBOFQ2QTZGUVFHWXErckNPZ1JHZ1FEdkFWa24wVmxDVFI3RU1lWjRWWnFRN3N3WDFFZGhaZHFiYWNRR3FZb21CSXlJdUVvRzRoS0ZTRlhRSEtLSURlUkhKY1FTMklZMXBvTXQxZEJ5TVlxd2hXS21IYURhWjRZNXdNV2hMRE5ReE9DcmtXa2tTNVl2cVpSMTNMd3hwWXZndFNXU0R2VG94NnhrZkpjTUJWUUo5RHNVQmtpdjEyalRTUUpsZ2xaSzRPNGExZ2tiQ0plb2drNmpFOGxVT1lLVmNWaGJPbEZXMFVjVnQ0R3BkTkdubDNaY25VTVFZYlhweUlhT3NnaW9sSmtxcEJFZmRIZ3E2Q0hTcW9iQlUwYUZpZ3Y4cXFHWkJFU2svK1h5V05RVHlUazZXblRMSTNIT2laeDlzbkNmRy8zMFpkODdUM250N2ZQUDNYSEhWLy9PbW50ZmYxbEw1dkU1ai9DZUEwNG4wRjdEaWZPL0dpYWpzaDhQR0YwTmM4Si83OTl1WG02Y2VqVUhRL0hYaXVjejZ4b25NelB0Rzg0ZTlkd1hQQTdZYTl0aHFSZDk5MGZMWjI3b1ZjdmduMW5LWmFYbW1id1pLTXpjOE5TVXZZTjI2U1lJS0JPZkhTSE9SZWtWSGZpNHo3RzNjNjlDbU5BT25tZ0RaaWVqTjFybExGK0NPcDdsb1k3WlAreEtFaVF2TVdHZElndVlzYlBIbUlRRlhxK1UzUWFZNHBrS0xQY1NqcDV3VHpOYnA5N2pzVmlZV3dDRkFKL0tkbHFkNXZWTUNnMCtIUGtEc3MzUCtBN2ZBWmRrMU55Zk45TlRZVW9KZHUrZDc3WFd3SVZRS0dLUWVjNzU1TEVWalc5VzVwN1FoYU5VSFdTYWpFdXhTNlZqRkN4bStWQ0VNYjJwMXNMQzJuV0pYcFRMZEdTWmR2V1FVdi9EYlZ2K0dHM0hZV3ZWZzhwY2F2d2IxcGFlK1c5YnpHZ1dzMWdVdkxGOTNaMlhEQUhFcmtRdkUyOUJRSExGV3IwQ2xyWDFxR0dpSXBzQkJpQXBVOWoweTZUdjRGdjIwY3V1dENXTWN0dWJBczdKQWJWWnB5TnN6ai92MGhnTXM1MjBQc1QyNFI4VXlwbHF6ZTVtQWJBQjd0M3I0SXBSWVB6YTlZUDJSKzcrY012ZmVnNzlkZjhoTGU4OE96Y2k0eFE3RlFOMEtRMElsWXE4MmNPZHdxRzJHaUFjR3BWK0pPU3VkQS9VdkJHMnF1OUYvMUk1K1R6T3Q2dHIxcTlYM1U3V2xGRUVoWHUyandnQTJyZ0pxS2lYYVA1MFp5NUlOblhXM0Z3Q0IweE5FTTNiSnp2aXNlVGZYM0NYUlBDUWZYNTdmbDF6ZFpnbHNRNi9YbVl4d21zcjErcnh6MmowMGZxYy9QMWhaNmlhY3FMYXJOenRWalRRcXE5dWo0L1YxL1V0VVVLYlgvcDZqalFQNUJMbkljbDJnN3ppSmhySGlCREdjOWMyTlBIVGllaGp2bURoK1FmYW9PdFFTMFoySkh6NXJSZjcyOE82ckI0RHJiMjYzWnNmL0pvYlZDcjlXdEhIZWNZT3M2UHJ6dDJxN1pTcmE1VVA0VHJSeWI3bjBiUE8zZWRYOExITENyQ3lFZlFyVTNIMnp5aW04WEk4NHBPUDNLNXVmdVRDemYwQkw1V3UvMi85bTVZNElWYWpmSnpSODRjU01YNXd6QWxUNHRxSUsrY1daZzlYYjI5aVFzelo2cnZ5QTRrMGd6c3hpbkhHVmV1c0xaNlA3VFZKbmVTTVgvOUFMVFQxM0kveFgyUyt4eHlMMHk4N0N1NUZ4bWthb2l3aFAxNDRtYU80czU0NGxjZjVXaVorU2Z0TThmNkZCRXZZSDRuS05kcEtiTHlqVmttV0o0VEZnOVJhc3ZwZDIvRFUrT2NreTZkMHRreHhPSHd1N1lpUTA1L2hkMFk5NDh4elF5MFlaekhiQzJsR1gvcDBFc090VnFHY2VqUmcvMkY0WGQrNmVDamgrS2tEV3ZEaGY0bUQyYWtvcGlPS2hxS1FqVnFPYXJoRUZ3VEpJcFp5NDlxanViNE5RKzBHOE54akV4eFRKa1NoZlpnM2JZbjY1VDJsSTVpOHo2djJwS3dvMlNLSmZoQ3BlS0RBQnNvRzVpMXdaQ0NRVng4dWpGc1NNbDZPcGM2eTFVTUJ5UVNiS2tzT3dsR1FRbUNGVkdHeHlWaFY2QXFWb0FnVjd5b2dzbThNMVpVVlJtUExjK3p4dWRxVHNHeHFqWEZVdWF1TGlhcWFzbzh2NjFZL0ZhK0dKcXhJSm1LYWFBb0l4Uk5iNWhNZklnd2VaYThuaXZBWE1qQkthbWNZbkFTaTBvYWpkdWppSHorc09oYkYxY2tBY3JwODBoTzlSOGZjdm1BdkJWMHRydjMvcTJyS3FlV1FDUSsvREZCSXNLN0cxS2d2RmR5LzhXNHR4Z3A0U2YzWWJlQmhlZ2E0MjQ4STNyYk5abEtMd1h0NFcxYk9qSC9zNkpmMjk0L2NqblFGcXJ5emd0QXZ6anZDNFo0dDZCUDJ0SG55RVhvSzBQUUdMbVkrWURIak9NRHE1U0ZlSUd5bitReFVDc01sbXM2OUlQRDkzS09KWUtOL3ppeGJLSldTMk5GcXdaUnN6TGo5ZVBpcGEyRk9kT3NpSTRtUnJwMmNybTkweTRWem5SVlRWU0h5NzIxM3VrbFZaWFZlMjg1cys2MGlzMzVtbXlNajkxQTNwZTFWOWNIcXFYMGxucGJjTXA4bXRRMDNuUjRQZkJ2WFZrNDFlTTREZXl2ei9NYzQwSzVrM3VRZXptMHhMZHg3K00rREMzeEc5ZGdvMHJ3bkR4WWVTeU5OWk9UakxWUnBzWXpzWW9aT0JGTHd4bE1tTittbkhBNVNla0s4NkxWRUFVOHloUE4ydnVnaUlPeFBNMkNScGNkaU9JcG96RTZjZjZmTE9mWXJJelZGbVY5dkkwZVBKYjZEamRtSzZDaDVrVE5WTVk3NFFQUWJmSlZ6VkZWUnlOTHFwYWNLUkhYVUV4UmJhaWlTYUZOUXIxMVN2VUU1SE1qY0ZON1pGRkY5Y0thSzRQbUo2STNybmdzMHhSM3lTVTZMK2tpNlJsVU0rM1MzbWU4aXU5WHZCV2xLUFM3allvWVNzcWdXSnZKOHhtWEp6Tk1qblQxRlFPaDhJelRoZG01bGNWMnF5dlgyb21Jekc2cVF5ZFA0bGhDbzJNVXlqUFJqRE56cyt4R21rZFZNU3lRRnlpbTZacm1leHF0dVhaUGFaaWVJbHVXck1DZmJ3VXhrZFN5SUtuanByUFpuQ25XYlFVVVhtSllTcU5EUEFjZUYzb0ZVRG03aHhVcmVzaU80Mm9VdmFMWTdOeStFVmhLeEd1RzlWdXFZY0Q5VFJNbS85TFNzd3ZsV3Fsd2RxRllYTmxlT0ZlRlRvUEN2V3diODVyS1ozNWl0dDd3M1RkaFFGb2hHRTlqdHIvNUwrV25DTjhucW9POGNlK1g0bVl6SmpmQjlPdU9mZ3RLTXBnOGUzV1JQTjJNcng2MDl6SHNLdmR3Mzl0dzZXMU05R2xYdmdPTjlqQjVFY09XWFFETjRSaDNqcnVQZXlIM011NkhyeG5mYVU5SFpWZ09DbVZZcEZqTis5dGdrVWR4WDBicW52YTEwYXhERkp4Z1JkWDRlSUczK0hpNUJ1SlRXdDRQSU43SGVtNHZmdy9VL2ZERGxtL2J2a1ZVemJJQ3k3cXBmdXBZc1Y0ckhMbGh1NmJFcW4raDkrQ2cvOEQ4ZmI0V3E1VzlyOWNITzhONmZiZ3pxRmVGem5acjkzL1liVzluVi9URnJmVk0xL1hGelkxTTIvdWwyWTFaK0N1V3dZak15bVNkcmM0VTh0V2ZVeTNMdHl3MjhhMDNGL1JxZlhHaFZsWjd4MDdWNitWeWhaQkt1VlN2MzNEMFFtTUFOOXJHdTlYMTFtWUw5Sk1LU2JlVVdxYUZTNXZWV2tlUEZqZlZLdDVwdGtaOHZIYlpuNndHK2RyMS9zV3Q1eDREU1ptUGtUbXhCdU45WjN3Vis5Q2Nnb3FGdGFGbGV0MXd4a09LN1FVckJhL0dpN1JzNmp4UjV3VmhBRGFnTUlnRFNRYVY1cnNHSmQ2bHlISWpibDRRK1RrcXFMRVhheUovWE9UN2duaUxheXBnWDNYcE5POFljVnlXMEc2ZTREL3ZQOS9vK3p6Z3lDaFVtK05XelRJV1JWbVdabU13VHUxam9ud0xRai9mMm1xQWJoeUpEVlBWaWtHcjBuaTdKQjBHdzlGcVY5dU9MTDVVRm04VzVUZVVJN0JINVlQYTFFLzBTU2c3RmVwcnlCVXhOZzRwWThmOXNXdVRsQTVUdDBrbjBJYmQyaU9iYTdjLzN0MTlaTzBDT2JqYjNlMlNwMC92ZlhsdDdYSGk3ZTJ1clpIaTZjZmhIOGQ5MzI5Q2d5a1lCZXBqWStqNkk1Wk5FY1dZL3crR2ZDZnYzc2VZZ3lsZjkwMk9oSEczdHpaZW9HcXZGU2F5WThVMXl3RU5wM2gwUm5LYVFjV1BBaVgwa1Q3MjJpL3pBVUhxemZaSzFXcWxHSUJCM0NvUUJZUmhhdGZhZkFSbWpXakVKbytLUDQ1Qi9oZVFXMi9uVm1CbEh6SWppeVpQQ2JQcm4zT0NyYkgvcVArT3BLMkR4KzY2NDRSdW5WaFBoNW9HVGFHMUZCWERrcDM5NEFHK3NsU0pNN3RWTjVKYUxTSmRVVDIrZTJ4MmNaSDBadXBFVU5iYnZFbnNoWEZ4ZVYwd2pNcHl4Yk9wMXc1RnMzRzFURDhCZlZ5Qm04VVIwcWxzR28wbkNUbTU5dXF6RUFnNndZOUR1NUhjUUkxU3E3WWtDTXJxMGpCUXQyWVdXdVdiK2ExMDFqSTdabHlNNjE3OENEOWFmRzNpZ2tWUFhUKzI0c0cvWGp0NEkvbEIzYXgyZWpQcjdlYTlTV1JkL2E3WXp5NC9WMXRiSUZrLzNDZHhtNUM4cGR2OFNnNHhTbjU2Ny9WV0FIckxhMkQ2dWZhaFdmRWVVVGdzaUd4eWo5RFpQTHpaRWNUYUJuazZzSzRldWZkZTJOUUtKb2VKUXBDc05ocXJhZXZRN0xSY0xwUFBRSHRpdkViRUJTc3NEc0hreWNhZ2s4WGtNMy8ydFR2ZThNYm4zNTdjZHY0Y2tqTmV1dlFIdmNkdnVPRTk2OE53ZVF5aUltYTVqVS91KzZUUjJxOXh5VFV4dnR2Y0xuZUN1NUc3Qld6L083bDd1ZWR4RjdrWFkremFjRDkyamFZWWF6ZnVqOGFwVFB1Z29hUXlCcVFKSytNMDhpZkhEZnU1UjVzMlIrTW1LR1o0NWpoZ1o4TjV6Y2kvSm94c0dsS0d2NWhkbXhRdnNuOC8vWmdnLzdqLytoOFF5TVBDNHB0Qi9ENW12ZW5peGN2cnkzK3c5Szc4aUU5Y3ZIaUFMR3ZLM3NkRWVvU3QvcnMvOTZ5OVB6SjdGNi81Snp6TTh6OGcvN2tkR2VmY0Y1aUdXdFVNWTRrYXNrT084M3VId0ZnK281V1ZxdlFDNHh1bVRhMUhUVkRhaGVBWExNY21EMHRkL2hmdHdIMmwxbE4rVGRlMWlmejlIUDh5MFBjV3VSdVF0NGxNa0tmUThjYmltbks5amVGVURhRnpnOXJSd1hZVEllMHRKbGdnZjN1ZFIzaVRSY0xRQkVFVlkzcFZUTEw5bU54QmdqQmZMT1NZWVhHekVHUHlqcG1tZ2pIMStydGtUNnNOVEpISTc5YWRLbFgwK1VOZ29raEUxS3NDRVNSWS9CajgrSWp3TXp4ZndwQitJaGdWVUxySWo3MWIwYWh2eUtCb0NKRkhrZnhHZjdjMHVScDUyeTNydGthYm52MVZSU0ZpcDZ6NnlsZHQxUmFwc1hLSWwzbW9rZ0hTZ3hNY1NEWFpsTXp6L0t6QWwzZ1o2VlJvQUhyYzNsdS9xbE5KazBXcXFvVE1ORTFCc3B6Skpkc1YxV2Q5enoveHJ3WGI1UUphcTBnanpLUUN0cHdwM3NaRUd1Ums5YmxqYUM3UC94b3d2WFJLYXp3ZXhmM2NSR0NLZGM3aDBSd3lraHIrdGRKNUFjcnJiNVFxTmN5eUpKN0hZVXVZbEN1UjRablVNSjR2ZDRvZ1phdkZqbXc2c3VaWVhzWFJTcnBjZHFOR0kzTExjczAwbElwS3hvcDBYcm9zQ1VOQ2VEazFEK2grZVhJcFNTeFhuSm1hNXNhMTJmWFpXZ3hGVXF4M1UvZ0VUbER2MVFQSDF3K1lxU1FMSTU1aEpsNkdQdmN5dEw1WGNqL0t2Wk43aXZ0Wjd1UGMzeE1SUjRtaEt1d1FrTFkwenI3bmwyS0NDaDAvNTI4TDAzekdXZnljdngyQzhPNDBlcTVmbmRBd2dxdGZxMzFsMTJVWlFVY0xxdHRRenFZTCsxdGlsQTV5T3ZsTUdWNHN2VzRLZGd5Q0ZEQTROdmgwYkIwSHZXU01xYzhGeVRJSW1XRitqV2lGQmFDK1g4WVFGSkhNQzNTdXB4aEoyM0NLVlFjS01ZaW9Ia1U4SDBVNmpRTGY5dDFLMFRGYmlhSDA1aFNoMytmSHE3eTh2aUdyNHczVldCNFpWbmZCY3NvSjJQeUI0NHFpNndTR2F5ZGwyMTdvV3NabzJWQTNWbFY1YzEzbVYxY0ozeis1ZVBhK3MwdExNRmtzekJ5OTVlZ01tL3kraXFRaE0yenFzK2x2eUx3cHFRTHYyYnJJVTlYUTBMWlhvTW9URDVRa01IaVJPOWtXREYzbVpkR1FNQUdHQ051aVRuVHBFYmxnVXMwbzhKb2l5aCt5VkZtVXhHSVF4SDdnMXN1ZWxUWnNyZFBTSlFTdDdCQ3BrMGxhMnRhdGVtSzdwWnJuZTNFUXFKWnBXb0xnKzQ3bU9iV2lZODFucGo3dXE4ckJiVms4ZGxRZ3g0K0xSNCtKZE9lZ29nMVdkU09idDV4aXpmVjB4L2NGQkNDd3VrdVRsMXc4dXpRemVjbVpveGhWcjhpS3FEblRCV0d5b0YvZ1plVlJQNlFIZUdrR2JoMDJZS0pITU9GdFd4RUZSZEZzUStKNXYySnBpSE5tdXBvaGlaSWpXN1Q1ZkMraWh3d0ZpYnYzWTdqL2dka3RROFlaa2l0KysvNUUxdFlSZXNmS2JSWEdFZGJaM3h2bDBVMHVpeFJsY1NqTUZzV3U4VThKTmFyUHMxM0RONXJKZzRFaUVjdXpvSjQrUDJuQ0p0ZCtYdFdndkdLSkQ2aWVGNnE3dTJyb2Vlb0Rva1g2a1I3b3VvRkdXTHRSVTZnaGFLYXBDWWFzMWhwdDNHcm9jRUMwOXlXVmZ0U3FCUzkvZVZDelBrcXZ4aUpkQWprYW9SNEp5bU9hcFRHVFh5RnkwQTdUTVhOZTljbWxBMmZ2T1h0Z2FlbUllZlBGOCtjdjNtd2RYbnA3ZVVTZXZuejUwYVhHMGxlL0NwUExCeVkyWGE1RDdtSjAzSFBrTTB4aFUwRlpuRWI3TTFUQjRXRFlZUndISVJ2aGlkQVZQeHBIRkVmaWNUZjBocDBwMkNGc0Q2N1hNZDhjYm0yR0JWa3FsaXZ0d0tlODVhYkxXVzNHTjUycUQyYUFjWVJ2TDFQTHhBeEt6MWx3UkhXbWdQaldnYU1ZaWxQNUxwdmdRN0hqeEtXMHVlTUgxTFRrWWF1eEpEc2JjMnMyWFZnMnE2VVNTVnEzelpGK08zQUVXbTIybm5CS1pVVU02cEp1S3A1TXFTU3Bicnk5d0dJbjk2NThDdlNjTDBBL09VWlVKaEt5ZDJTaldCWUR2NFMzekhYV1BGMlpxZENkdEpNVGV0UW1zSzJ5bjQvRldYd1lNT3dURm11STdvc09DWW9MOWNBVm1ucHJKeFBISTUrRXRZUExPNjN0VGlubTlXcHpvemM3b3lyZDV2MzNKVjFGQ1lMYnpjQW9PZFQwZEtQZFFNamw0ZzNsU3FjUUVUSkxUcDRPRm1mbVhsbXVaUWZhSkhuNDBOcllLTng1NUo2U2VuclFQcFNwVWFpUlp1M0J3ZHBzdTFocXphMFBGMDNDbFMxRmdhYmlWWTNBVjRyRkpqWG5aa3J0OUVFV04vQlp4bEV5ejkzQlBjRDlBUGNha0JBYysvN3BOUmkyekVzYk1oUk01aVc2QnExMmd2aUhjWVFzNzMwNFhwdFExZ3ozaHhZM3BreVNXWkJBQlVwR2ZhaE5iSTY5ZmhMRFZ1YnVHVEJIenpJRHpXVmgyNmljZEZqa0Z4dmRaUGVab09YSE9Wc2lMcExQZU0zUnlhaGNBbXNzTGhrNkl2bEZ0VEdSWkUyVmRFVU5CNE9tTFhlTEM2b09oclBTRGhxeVdlM05WMnFJdXQwcmVCZzJyK3FSWHkvV285amZXYXhaRmQxNHQ4blhaU0xQZ1RuUmh2bnNJakVYelZhelQrbGFPOU0xdzdIY1duUEJkeXBVRm5YTnRUU1BRaWNsR2NnNHEraTJGNE1VMWtTYlZqeWR2TTB4QTR4Z05NUFNUSHU0VWhza2MvYTZyUE1JZzYxcU1UTFRFaTNvbkxqcjRPWlhOMnVPZ3RUeVFwSnFra0RQbVVsbHRqQW56OWZUME5QaERzVFJ6TUp3VmFCeWd6ZjVjV05lTUFXR3dpZHZwQTJ6M2ZtZ3EwSURjcnhXSVZ6MlRjc3hOSkJsbXFYWW9vb2pyS2JoNnJhTWlMU1NJTm11ZHIxTnVmSWNOcVc4SHhRS05TS2JqaFV6Y2hiOCtyQjhYU052OFR1SGVoVmZkNmh1aUtFZFZxQXV0MVdkcW1GR0JOZjBDb2RXcm0vSlA3bHc4NjM5Yk11djJMNVgwbXdpam84VXE4SzJFMG1DY2tZZ3pLNy9KL0pGOGpvdXpmRW1zK2Q2bW1sbHhNZTVMSnkvY3llcldMRm11MUl0ckhiZHFqc3dIRTJ2bFN1OEVIdkY1dDFIU09mZ1k2OGd4MGZuaXQyd1hHcVpFWkZPM1ovT2lMTzl1QTdGOUNLQnY1cXprUHUvL2orV3pUdjMzdWVYU2o1NUNLWTkvc0NoaFVxZ3VheHNuTEJxQm1aZU5sMmV4N0xaaGJJcCtWZlBlUGZpemVjRzJUYVVUUUJsNHhCeDlXaXhKdXc0c1NncVovaThiUDZFdkpZOGhUNlBkaWluay9hYWo5cjJjeXhZSEhKaERRdWFEd01YeThkWWE0UmNLaGZkY2xTTWpIQysyQ20zN1J1TVptbXVWMi9QalJlSHhZQVF5N1FOUjFIc3NwdHVmbUVndDFxMVlnUW1iNjEzK1B3VEx6NnpOZXB0KzJlZWR6Q3RMbVoxWHBUTThueWhWT2dNL1drZXhoSzVIMlBSeVNqSGpXZGgxMWRKeWdQV3ArU0tkSWNoOXllVFllamN2WnlCQ2M0ZVBGZlVWM0xFb0ltZmlXL0toUTBQVkJ6VDl6VkRsYWw2dDZ4YWdveHR2dVVGbHFqckd3SFZ2VGhwM2JkWVZoRXVXZkc3UmwxVzlRMURGOVRqcWl3VEQ2b25PUm01UVNtcWh6cFYxSmNabXFLNzFIQnVOOVg1dE5NMU5WY3IxbHVMQzROVldUSktCYXJKSFNNVnFXbFVUbXBVVTBtcFdVenorUHQ4bkl5QWZYc0U0Nnd4TW0yUjd6RGJBdldHRmRaWndWb1lNR3pmdFBuOURzamdpOVdGaUZrbGFLVWx6T2JEdFIwQkpmUERvVTJGVmJDMTFLWXNpek9DYW1uQ2pDakxZQUN0aXJKcTJPUUYvL3dSWXdtUCtKSnRLRlJjNVlrSVIxQnhodGNzRlk2Z1VsTVRDYjhxeVlyaDNHY3I5Rkdtb04yTWpyQ2JGVm1WeEVlcEtpdi83STZuRVVqcitsMktKTEZkRTkwTTZnUnlZc3Vjd2ZTWkxDMFRDVlVaZ1R6LzlPclNMMzN6bTN0UGpCNTdiUFR6NU5MNTgzdVh5S1hHbDcrODkwMDhMY2U2VnNuUGN4Ylg0OWE1VTl4dDNEM2NSYXhqMEJoUlk2bGhRa01PL3MrUVJWZ2t5M2hsR2YyMk9kczZGTzRZWGIzbzZBVlZKMkxueU5FRXFFWEkwZk5ySkpzU3g0K25DK1E5Y3RIVGRWRXJ6dmlLNEp1ZkhUMnYxdWdlN3lUalNCZHQwdDB1bXJ4SWwzUnROTnc4TGl5Y3VIVzNMY0gwY01zMFpNdEl0OHE2NklTaUUzaXpjMDhhQjdmajB1WjIrWGxhWkVoQmJNaXhpQlJJS3Fqd1lCV0t2T1h6VWp3ZmE0SzU5NTJrMXBocG5qd2UrcVNWNnBLYk5rSFJkMXJKNldMbG5lWFpRRWxXeG14SzJrTG9DclI1SURIQUtGaGFtSThLZTUrdlZvTGhxT1QwaWFoQVF3SFZ3b1ZIcEtKSUZTYjd2OEgzb2Q5SFpyMVpicHM3enJTZmxSaERlRm1LRUIyelNHdFdrdnZvYXZ1eGE5SWdKMTlnYVVSZytURTRqb25GUEVrZlkwdmtTVTFWMW01ZEhGNFluUEVQNjYxUTBlVDVVeHVnd2NlZTkwTzY1MFdXUlg1cTRkVGN3cW41K1ZNTFhsc1kyWFhQL3lPd21GSE52dy9ubW1XU0FzbTJXL09uZXFmSEc2bEFTUkRNSHBzWm1wRUpmMHY1N0tuT3dVNEhJWkZVVWwyT3k3VlZ3emIyLzZheFlybXNDK0Y5enlEYWs4OWVGWXhUZU5meE1odkVYdUFaWWwySG9UUU1tRjhGb3hwWi83VlBKSkJuTFB2ZkczVUxObklPSWNtait2ak4xbVlyRU13VnFkNXFiYlhDenRKQThHUXQ4Tm8xMTRJR0JpWWU1bXVBQXFLYldpQUxxcXhIaUlodzN6VVM5WXN6NmExeE5IZGlyckhlSzg2ZEpFZlNyVmFuSVMyWmdrL1NyYlMwM0E0K1EzWGthWEhtUUhlMWlFU3JJdWdIZ2lDQXhxQUpvcWFKQnVFRm5ialhhZEN2ODZPYjI3ZWRtQ3YwMWh0engrZXVqdmRjWm5nNVhXaGJVMzROckFwUlB5OGRlTWRGS0sxOWFnMzJtamlVbUV5UkdabnBnSmd6ckZQUHd6b254U1owTXZKRGpiUHptdzl0MWhvdlgxN2J2TGlWZnJZL1I0LzZZblhsdHBYMjdyRFdQOWV2Z2RYS1M2YW9WQ3pmQXFzWG1vYmc4cElJM1JYeEluNjJYN1JOU3kxU3dsTnliejNaZk9pSi9rdnJaYmptL05tOXI1UkU3ekR0RGVGcWxlSGhGc3plYkF0RXBMWWtXcnBkRWlSUjBVUjVSb1lhNUEvcS9HYWtZMkNXNnpxaXdQcnhLOTlnOVdPUlcrVWVoL2NmSXFRQXhlejdSWklpYkN3RzBzWTJDVEYyaGtFTjFFbC9CeE5wTWRSMnZOODQ2aVMwQ1R1V1pqWkpGd203QnJwT2h6c2tQemJlSWYwWURnanpmSGtXcWpqdWo2RWpKSmNyUXFCVktmVkJMSUhFOVFORnFlZ0JYNjN5Z1ZhalN1QWJzRmtQUXhVMmgveUZBa3RlWFY0Y2k1ay9zdDBzQzgxWk0ycTFiV3NjZEtUUlNNN0NvVzIzVzdFeGExUzlxRVphaTVYbGFudGRDU2dmTlVnOVZQV0EzU0lVU3lVeDFNdXF3dTZzR0FGb3RXVWpGS3BWSVRRcWlncDM3bURlN1dMVHRicG1uSFljZXhEUFVMeEZ0T0xhYVNleXUzYVF0U3huRUdUeVlFR3BSMFR4bGZWT1pibXltTllqUHg4TCtCWi9pZndFd3c5bmprZXdhSkZzSnMvVHBNTit5TkNrSS9RblRlTFBVdGhvTWFRQWhob0tKbStJZmxCb2hEN2JHL09YTXJkNG9XdmQzSjd6N2ZqK1dJdEszZ2M5MjZYenU1YmFxa21GVktHZUhyek44ZVdDRFZhNVN2MHllYlhiVURmRTJmaFZrbWNZbDhoYkRkSmQrNTA3djNEczV1NzRhNnRSWEFRRkNBd0Q2L252cjNtSDEvVFJqWTZPYU1mRU5BYUpQOWNPYlF0V1hPdlYyajBEaElTWExISjlIek9OeGViY2NaaUc4VEN0azJFNkRQdkRYNEYvdi81M2YvZDM1SUgvdTY1cmpaSGJxT003SG51OHRuZnR0YjFyZSsxOTJ1dGRidSsxNjMzNDNyZjNVa211T1pRUTZVQUhTVVFiZ25JOVVxcm1LQWhRRlBVRFJKV2F0bEFKaVZhVldnVVEvWUJLUzlVbWxRNXhQTVNISXFFUUNTbWlmQ0VnVlBFQm9Rb0VkWml4ZDNQYm83M1QrVEVlbjBZejQvay81di8vL2N4WFhqWi8vSXA5OHpldjNocmdJdjBhL0R1TWhWQ3d0YitCcmJJUHhrZ3hiVitkQUxwZHcvTU9ZVVhBdzUzQmtuQnFHMm10RUZBaUtuRnEwUVpLTFFydXV4Zm1IeklCUlBZc0dvNmZDdjZvYmsrdnZWTXFycXhTRlRhUlJEUmlNa2JPeUJDeVo4TnVuREFSWkZEYWtNVENBOU9qeDRvd3BSR2lQQTVYZzNFRHJNckFtaHNPdlBoWFl6UzRuWHZvZWU3bk4yQVNmQndBUGs3U2F6Z09ubjc2SHhTNUFSUGRZZzRZS1d5UXAyaEprRlZzbVZpZm1QbkZxSnNRdk9uNXp3L2kybjhWOWdjVG00MHRZM24vNlJoK1lBRmlpRE1IYVExNGhZNlFDWWdnNm1ySUlUSHZkcTFwRTVCbjdhQU16NTBvWWEybWh2bHFaRDNUUHhMcGFPRnNkeG1jUlhTYzRpSEtTREIvZE1RL2xSZEZQYzJRVGprMldVNEkrQUtsZFl1SVExeDB2OEZDK29sZW9WQnhxRjJRV21yTU9BZGRJdlIyTHUzMHdnUFFnNytaNXhiR2JWbm1SVHJGSmdSSk53dnRNWUFOVVk3Nnl4TmJGSEZtZytqMnp4c0duMUxlSUR3TVkzeWk4ckVidWMvTitQNVE2RnV2LzE5N080UDU5dzU0RjgrL1BKYnJCRVVnNW1vUlFuM0l6a2tDby8xcTZNeU9kR3V5MzZKM3NMakxSSXhyNExjV1Z5eFBGSHdKLy9pRmlSNW41U0ZjYUhVdWRiMEZDSU1uNi9VL2pKOGRxVzQvZE8zYU4wcEhzNVpwQUdDWTdhT2xSc2ZiekZwV2R0UHJPRE5YZFVrdVpXM2wvRXcwanBFdk9vRm5kUjdMbHJIUVl2bklybmZ4c2hsNmQ1MFEwS1dtUnlndlZHeHQ5OHJ1V25nbzliSHE4Q0g0MmFhNytjeWs1RFhGbG9aV1VXNnRzTHFEMTlpOXRYNWRmQjdBNXMyZDIzTTNxNTg4OWVDRDI3eVlsNzVXV00yYmVDRVA0MUpEckRoaUIxZkNGa2E3VkRPRWt4Y2NnbnVFTWpGaThQSmVjdzRVQURlREZ5TDh0d2djNXVCU3hTZXdsMVdDWjVWc1ZnSG5sYXhMVTl5Ritma3Y4aFNCc3pwUDBjRi9qaHc1Y3JLN0M1VDkvZjJIZTd0WEhnQVhENnBuZzhkSnBYWFBXNmVwNEZuODB2dXVlN1JhZldic1l2OGN2T2U2NGJqL0VuOHJOMklhdGxVM3dnejRVQnVPbUJjaWNQc1ErVzBRMUl1aWgyUVNGRUJmYUlmRW85V0kwVHFVMlJKSSt4RU5TdHZ0OWprSlEvZ0wvQ1o0cEp5UG8xbEw3eHF6clV4eXNtNTBhZmJrQ3hTZFMycFk5ZUEwbTZFQm9GVTVUbE9RWVpNNUc1eGxGVkVXZVMydXVhaFdySWtDQkJTVG9wTUlCdCtwclhBZ1hTM0lLdTNOOTJZVmVIbGtVUklxSE10UXFDeEtDVzE5UE5zQTRNUzNLZG9RWkFRcFRsOHRtVnFpT20wS1dKV3FwTzNKYWJaU050VlVIQ1VkcHRGY0dMVVZGa0NVNDYyaVBQY2FaVVBBcXd3RUJackp4ZWxoZlllTWVmbkRkbDdKRnRBaWFEUnIxVWdKeExZRHE0ZEdHZUZoSXNiYkI1d2Z3VjhuOEpBMmk1Qm1KdUpNeVdOdW5sdkc0elVaWjVhL3dMQ1ROSDNJaWZrblJHOTJzYlhtZjRxNzlkcVg4Y1ZqUCtWUTZIY0k4Rnk4SE9waHpoQS8yeUx3bktncHVudW9IUytDN0ZpY1gwSU10UWJBR0VSb1NXQUJkM1VMcjlwTENmWXpUN0g4TW1MK1RvMXRKRGptcS9jelhITHovZTh6WE9LSGR4UGNzQThJUm51OUJOdURjT2RocFVmUHRNQmUwSHQzb3p6Qm9zUzRjeXdQWGdoNllPL3VVMXRpMHRxNmV1b2U1dnVQOFBldGs3MGxyQXBHUEZ1YTUyUFJRMXpCbm8vK1MrdUtRZGZxdWx1V0hNVStadGhySmNsTlZiOTNtNlp2cjY1WEZ4czBQZi8xV3ZmaFdacHVEK0taSjhJODdwamVnUzFkYmNITTVRditpVlB0ci9TdWdmb2RvQVV2dlJUdFU4Y0NYRThrMFlrK1hqSWlLbzVaSURzZHVZOHlNZ3UrdTlrN3M1NU9yOVJQK1BtcWJwbGFyZkQ0L3UrcTU5cXU0d2F4ZlNDYWhZdVdRVERiZ3J0djRiNi9FVXZqdnUvR2pwQjlRNy9CRXFUcFB2YWFIcVl0SVY5RDl4SlM4YS9heUdnREZkaVBRQ2JJd1BraGkzYzNvZ01OVVhNaVlzZ3cxeHkvOXkyNGpYaVNVRUFJYkpMMGNZdERiQk5JT3I5TnhZWFB5dmdEWVVpS2d5QlZERUZscUk2R1ZPbFYrcmdOdUJTTjBnMDZMaVRyRktRYW9zRENRb2xCS1c1cUNyS1BBUWZ3ckpqSnBua0psQVdveWhkVWxaVi93TVVUSm8zTmpKUEJQOEdqV0lCVFNWd2lNZ3RtUExrRFZRNVFnaEszVmlqRW9JVVVKWHhUbXNPS0FOVnNzeW9QVlFXaXlOZHg5eWFlS3kvanVWa25HUDlxaTNYNjFBU0V5aURjUjNGYjk1ekh4QTFNNHY4bXNiYnJ5dzVXY2VWMnpTK0FyVGZabitSSDAvcEl3dTEyZ0xCeVgxMVVFN3hjYUpTVkpPQno0d3ZlblZzODlYcVRMUmJBbytwSS91MjhxcW1keXR0dWUrcjZsK3htUnBHTFZJc3gwd1lRclBzZWVlNUs4SHVSQWNhNHJQRDFvZSthd25wVU44eUtQY3dYejdiNzBDQmhMQ3NabFl3K3lIYnhJd0xYenZYVHB3RXovTVVTbGhnb0orU2x1YmtsZklMeHcvZnZkYnQzaG0yM2xPd3F1RHhpcXNVMTg3TzJLdzhYNU9ZR1BoSEtBNWV3NUttRlZ0ZFFzejZrWVNSWmw4RktiNVV4RmZQTTF0WVpmR0pZZ3Y3Qy9sOUpjUDFKc0RyODJQSnptamRseVFkRnNqWGxlZjcxRjQvalZ2d1AzNFg2cWdBQWVKeGpZR1JnWUFEaTVrMGlRdkg4Tmw4WnVKa1lRT0RhTHFYck1Qci9sLzg3bVZvWlR3QzVIQXhnYVFCSi9nMGhlSnhqWUdSZ1lEencvd0FEQTFQRC95Ly8zek8xTWdCRmtBR2pOd0M1dXdlNUFBQUFlSngxVkx0TkJERVF0UzhpcEFSS21RSUk2SUVFRVVGRzZCS3VBeWdCc292UUZrQUJoQnRDeEFZbmdXN0ZtcG54L0x3ckFzdS8rYnczOCt5VVVzcERHN3RTZi9PRWM2SlJLNTlkdHprT3RudVVOZGtXUHB2ekE4NmdlNDR4eTd4UVhMWUhtbXR0T1hBOTFXK05RK2VjQXlSWENUa3BMcUFmNlBxZjBXSzJPSmU0dnhFdTczNVBXTm11aVAxQmNTa250QjhSczlxSEd1VW40VG9HL3VkK2gzNnpja0c3YXJ5TDhLS1p6czdZNXNmaWpsdk8zVHJzTzB4M3JTWVk2N1M1aTNHcHIxZkNMY2JkKzE1OWQ4VjllUDRRZjZrWmowNDNWbGVzZXowcVQ4Y2gvV1pmMFZYcjA5THBDcHFkNFh2bEdqb3ZVR3ljcDVwZUJzL0ZNNFQ5aGVndllEVmVFMk00YVJ6bW9UbjJZZ1BLUzJxQUdQT1grSmE2bU9iTWhqQjdMSGt2WG5PNlY1N1ArSTZVdzJmc2dkeXZlV2tQQnRlVnZWZDZrNnFSdHkxWDE2VDFoSExQOGExenJIWHZhWDhJZjBDcndaTHZjWDNydlhkc3BvT0dzWVMvQkFRanJON2FTNjl4K1Urc0JxNVhySGZVOXREcXVnczlVcDFFbSs0dWpGaGY2cVg1Z09pYnp4UjdTbjhkbnpwR0FBQUFBQUFBQU9BQlRBR3dBZG9DdmdMd0Eyd0VwQVU0QmFJR0hBYjJDQkFJTWdpZUNSZ0orQXFrQ3ZZTFdndW9DOUFNR2cwaURsSU9jZzdhRHpJUGpnKzBFREFRdkJEV0VVUVJ1aEphRW40U3dCTWlFNGdUdGhUNkZzQVhlQmZZR0tJWktocStHNjRjYmh6cUhUSWRlaDNhSGdRZTVCOHlINEFnbUNEMkljNGlRaUpzSW93aXZDVGdKUTRsVUNYUUprQW1ZaWFlSnQ0bmZDZXNKOUFvTWlpcUtUb3B1Q25nS3BBcXZpd3dMSVFzdUM1dUwxQXZxaS9vTC80d1pqRUdNU1l4VkRHS01jQXkrak9hTTh3MEFqUWlOSlkxQ0RWWU5iUTJIamFNTjJBMzhEZzRPSkk1ZWpuTU9ndzZURHA0T3hZN3BEd3FQUFk5MEQ2WVBzdys3RDkyUUFSQVJrQ3dRU1pCUmtGeVFiUkNBRUpLUXB4QzFFTVNSQ3BFcEVkK1NLWkkya2orU2JoS2JrdDRTOEJMM2t3RVRHUk02azJLVGZ4T1pFN0tUMWhTUEZMTVUxNVR4bFFlVk54VmxsWE9WaFJXUmxiT1YxQlh3bGdrV1JSWnJGbmtXalJhN2x6d1hXQmRpbDJ3WG01ZXFGN21YM1pndUdEVVlRUmhnbUhFWWVaaUZHSzhZMWhrQW1XU1pjaG1VbWQwWitab1NtaWlhTkpwSEd2SWJGSnN5bTFTYmdCdUlHNThidVp2ZUhFR2NhWnkzbk0rYzdKMEpIU1VkUHgxV0hXS2RkcDJUbmFrZHVSM1FIZ2FlVXg1NUhvcWVxUjdNbnU4ZkZwOGxIME9mV0I5Nm40aWZ0U0FYb0RXZ1VLQnRvSXdncTZDNUlRWWhGcUVqSVVTaFpTR0NJYU9oeGFIc0loV2lQcUtBb3BlaXRhTENJczhpN3lNSm95R2pPNk9BbzRjamw2UENvOWNqN0tQL0pBMGtUaVJacEdna2Z5VE5KTjRsREtVaXBUUWxQeVZXSldtbGVpV01wWlNsdlNYbHBnU21aQ1o5cG9lbXFhYkpKd21uSGFjdEowRW5WQ2R5SjVlbm55ZklwK2NvQ3lncktGZW9jNmg3S0owb3c2aldLT3FwQXFrcEtUd3BTaWxTS1Z5cFlhbHJxWStwcENtNktjdWVKeGpZR1JnWVBSbS9NeWd6Z0FDVEVETUJZUU1EUC9CZkFZQUs2VUNmZ0I0bksyU1MwckRZQlNGejkrWDJJb0RYK2hBdUU2S0tLU2xrRWxuTGRqT0hIVFFlZHIrNllPOCtQTzN4UTJJcTNBUDdzRUZ1QUJ4TGQ2MGwySkZSY0dFSk44NTk5eVREQUxnQUc5UVdCOTdmSzFaNFpqVm1uUFl3WVZ3SHVlNEZDNHczd2dYVWNGQXVJUXpoTUpsWE9OZXVJSkRQSEdES3V5eU9zV3pzTUlWWG9WejJGY2w0VHlhNmtpNHdId3JYTVNKZWhBdW9hRWVoY3ZvcXhmaENxcTVhaWVPTExXV09vMUQvWkhKcGJieG9sSGEwK041NEprdlovU2JZVitiZEJwSDVEcjFMQ2N4ZDZ1OXF5TnRQS3RITkxpamRERnVXT3VUYitLUXNoVWRCREVsSnA3cG9YVW0xaWJOV3MwWDN4bkdJVHFJRWNHQzBNSVNHaW5ya0ovZitRU1hyellNUEo2UDJPK3hPOFljQVR2bUQzdjBiNXQ5Vm9iOTZhb2h5enVvYi9xMjI5d2Z2cjNMS2xwMWVieW5PVUg4MTkzeFBjV0NjdzEyTFh6V1BtZXlQdHE4UlhOSHdFeElWck1aTzBQMkhVeFdXd21hcVBIcGY4bzduT0ttZC9FZG1vVUFBQUI0bkcxV0JaVGp0aGJkcTBuczRNenVkc3ZNNkhiYjdaYjd5OXpQekYrMkZWc1QyL0pLY2hMdloyWm1abVptWm1abVptYitUMDR5blo3ejU4ejQzYXV4QlErdTNoYTJaZjdUM3ZKL2YzQWRHRmJRUWhzZWZIVFFSUTk5RERERUt0YXdGZHV3SGZ0Z0IvYkZmdGdmQitCQUhJU0RjUWdPeFdFNEhFZmdTQnlGbzNFTWpzVnhPQjRuNEVTY2hKTnhDZ0tjaXRPd0U2ZmpET3pDbWRpTnMzQTJ6c0c1T0EvbjR3SmNpSnZnSWx5TVMzQXBMc1BsdUFKWDRpcGNqV3R3TGUzcGV0d1VOOFBOY1F2Y0VyZkNyWEViM0JhM3crMXhCOXdSZDhLZGNSZmNGWGZEM1hFUGNJU0lFRU5naEFRcEpOWXhSb1ljQlJSSzdJR0dnVVdGQ2FhWW9jWmUzQlAzd3IxeEg5d1g5OFA5OFFBOEVBL0NnL0VRUEJRUHc4UHhDRHdTajhLajhSZzhGby9ENC9FRVBCRlB3cFB4RkR3VlQ4UFQ4UXc4RTgvQ3MvRWNQQmZQdy9QeEFyd1FMOEtMOFJLOEZDL0R5L0VLdkJLdndxdnhHcndXcjhQcjhRYThFVy9DbS9FV3ZCVnZ3OXZ4RHJ3VDc4Szc4UjY4RisvRCsvRUJmQkFmd29meEVYd1VIOFBIOFFsOEVwL0NwL0VaZkJhZncrZnhCWHdSWDhLWDhSVjhGVi9EMS9FTmZCUGZ3cmZ4SFh3WDM4UDM4UVA4RUQvQ2ovRVQvQlEvdzgveEMvd1N2OEt2OFJ2OEZyL0Q3L0VIL0JGL3dwL3hGL3dWZjhQZjhRLzhFLy9Ddi9FZi9KZHRZV0NNcmJBV2F6T1ArYXpEdXF6SCttekFobXlWcmJHdGJCdmJ6dlpoTzlpK2JEKzJQenVBSGNnT1lnZXpROWloN0RCMk9EdUNIY21PWWtlelk5aXg3RGgyUER1Qm5jaE9ZaWV6VTFqQVRtV25zWjNzZEhZRzI4WE9aTHZaV2V4c2RnNDdsNTNIem1jWHNBdlpUZGhGN0dKMkNidVVYY1l1WjFld0s5bFY3R3AyRGJ1V1hjZXUzOUxldlhObk9WdmpVU1NNa1dFbUFobXBva084TW1wa1YzaE1KSjRJYlhpMnlrY2ptVWx1aFUxRkxueWVKWXBvaitkOHJ5cUNrdGZlSEpKeDcvbThpTFdTY1pjWGljZ3lhZXlRa0s0akxiaVZFNXFnU0txTTZ5RXZ5OEJZcFdseFpib2JyRTFJYU1kcFd6Ujd1MEU5YnVvOEYxYkxzYytyMk8xNXdDdXJTaTFHY2lhMHp5ZVNGMkxtT1d2VkNwK2FUa2c3aVhoZXJvWWk1VVVrQXJPbjRscjRDOW9OWmE3Q2RSRlpRamFzb3JHd1BxRkl5YUpGdHU2R0dZL0dnWldpMTZCUWFPMEdWWklJSFlUK0F2WERyQkpXS1pzR1lYY0RyNFEyMmhwV1d0RWFJaE16T3BPbGVhcmFrRk40YklaUkZOemdRcjloWWpad2RubnlWU0t4TENnS1FaUlZZYitoSmxJVUY0L3dlaFM2U1hKdXJOQVIxM0dYR0gxVzhzd2hRNzRxaFp0NElnM3ZSYUp3cjZsWWVGRkt1eEs5S0ZOVmJDS2VMV0V1YlRwb29JdThITkd1NlBWU0ZCMnlVcFJTckZLV0ZPU3dXRXhFcGtxUHFPWEtpMHB5ZmJaMUdlRWdVbm11Q3RPSmpOa1Y4TXkySE9oRmxiVVpSY3VrZmh4UWFJSzRFM09UUmxVb3VySElaQ1JWWlFpVm1hcGpsZml4TU9OU3F4NHRScUcxWE50V0xKTmtTQTlwZVJhb1NQRENienhDWjI5c3BZM3dZaFdsVmVqTVdPaGhyUG5JbnJINFppM1dNZ3hkdnM5VG9iUGtQcVZzR2FxWkYrdUsvT2ZGTmFmZzlnVFhXUjFLSFp1V2lCUFJwVURtNUVlbDJ5S25iUEJFWGtvdFBGRk1wT2FlMEJubGRzZlZpUlpWM2hMVzFBTVgrVmhhRVJ1VDlVWThFcUZTNDJDMGZRUG1WSUtDU2tXdmJRd3ROcmZrL29nV0dhbFpuNnl4QVoxVzZGNkRtOE41SS9MZFdIZkowQkVvRDFaR1diMTFSS0VKK0ZRWUNyV0x3YlliRFl3eW5ndzJqelRFaVlBSlJySzdRV2dhZmFOcEJwc0hPa1FxY29Ub2paenJtMTJ2anJSd0dSRFRnMnJQZHpRMGNTOFJOaWhkU0d3M1NZSkk2aWdUTEVsNkZKZkZlVmNJT2tyQmN5c05GM0QrVDIvT3VtVEdtbzlGNFFZeUhqcERlZTBubWFRVmszWmp2VVRSemtRL1VTcW1uSXhOa0hRMzhJQlFRaGxBb1o4MHJ6aFNacndlYnVDS1B0aSttYzMzME44MHRIeDV5ck5NV0cvT09vbW1BcUFTYkJHWUVKT2xDMTA3MFZWaFc2UjY1ZmFVdTZ3TUNqSGRtSFhUVUN1VnBSbW05RTNBZzFSa0pCcnRWSkhjZXFteTY5eVJhdS9lZG1yemJMZFA3akNsc2kyWngyRlhGc1p5V2pYZkpsMmRGK1J0eXJ5TXZLQjlxV2FwTXJZdmJWVUlFeFRLQ20rTy9YVlJqT25UOXJxaStIanJTdVVaNzY0dnQ4YldUV2ZkakdRY1o4SWJpenFLaStHWWNzMjRZcVF0ai91Ym1EZFdlbElKbjZTZGt6b01NOUtsVWI0TTM1ejVHWlZzV1lXdGpKSytsWkcyOWVreHBnSXBBbGwwbHRnalFBblVKbFBOV2xrOXNuN09FMWQ0WHM1bnRBcy9GekhKcE9tUWxWVWU1TjRjdE1sb1MwVFlxdXptTXRLcXVjOXlPZXZRWDZOdFhpNzNWb1ZzNVNxZWVTUlRRaXUvNEtVVDBiWENPYStJVldDbWRBK2t2dHRGc0c1YXpxNFVaYjVTbUhQNlJVWEthcVVxNUd5SGlnczFwck9aUW83bDRxekRHdzEyRkFrb3FiUDFISkJ4bTR6bVExVmFPck5UU1ZwM1JSblpMdW1FWjNiZDAvbkZlQ1JESXhIN0piZGEwT1c2RUhiNjJBbGRLZnBseWtNdEk3cnM5TFl5VlRUM0xCaFJBb2lwMHVPVk1pMVhTYkRqb0tSTFFEZjF0SW1XWmU4RzFpK2JsQkVrTGVYV0cvRDhNTjJOZ2I2ckVZcTFPL21BZERtdUlodWtsTmhlV1psVXhGNVoyMVFWYk0rZTdwNktjaXJpcFdqdnFaVG1mcE1RdW01VC9VV1dublFoZGpVdDd5cFFEd2lSUU5JV3BTaUdDN0xJbWpuek5jV0V2aVJhMEMrWk1xdGptc0dvYkNLTHBLY2JYWWxTVHE4UzFMbnhEQjl4TFZ1R291Q1pLTTNrakF5SmZkdzNKT3BSU29wTENlZnU0b2d5MDNPQXhOb0lQWkhVRTFrcXlZR2hPclJHRm1HVmpmdEc1clJvV01uTStrYTZ1M1hXTWVPYWt3YVpOb0ZTOUV6VExhUjBwYlViU0FPa1JTWjFvbWdvdzl6K2dzUlY0dG9HWFNqOWt2ZU1xcWhuY1ducW0xTHdNUzk5VitOMEY2ODJtNktpcHZmb3RsaFExd3VNTWpYdEVhM241VE9nak9MTHVsdVNPZzlWMW00SURjbEdjUEtLcXBwT3dpZThNMjhXQXVQTkFiMURQWllpNTVJVHR4UEo2WTZzU3VwVjVzTGQzelRVTnhVbFVhbW0xRE40aEtsNVdiVjBVVG94Y3JwYWlNNlNEcW00WEI4U1RJVU1WYmZwSjZXaFhWQ0taNW5xdTdXcDdaUkc2V0d6Z0Y0bXdweDV0aW5MVldlYy9pejZ1UVZ0MjdwVXUxclVUdWgyUlpWbisxVG1XaVF1V3JWUGlVcUtFYTlVSnV4VXhsUkZ3Vk52d2puSmpVLzloV3Y2aG1Sam9aWnJ6bGw3SW1uQ3dVVG1HLy94NTJUU2JteUx2Q1RZWkx3eUtXaWtFdXVtM1J6UG8rZE1GbXRUaXF0cHV0dDVySmU4UFUzenlQU250RlBYSWZCZzZrOGxhYy9VYktVS2pxbXhOYVRETHUxRWQyT2dOeTFET2hFMVlacmdoc0pQUzdydmN0T2FVUXZUcDBXVHhXSXRod2UxYThoQ2lxVnJYR3BPRjhxT212b3ZNUXZtZDBWVDB0VDB6QWRiTmQwNzdWcFJXYXpXcXJMa3orVzVGM1RMbHY4QmdlOFdmd0E9XCIpIGZvcm1hdChcIndvZmZcIik7IH1cblxuLmZhYiB7XG4gIGZvbnQtZmFtaWx5OiAnRm9udCBBd2Vzb21lIDUgQnJhbmRzJzsgfVxuXG5AZm9udC1mYWNlIHtcbiAgZm9udC1mYW1pbHk6ICdGb250IEF3ZXNvbWUgNSBQcm8nO1xuICBmb250LXN0eWxlOiBub3JtYWw7XG4gIGZvbnQtd2VpZ2h0OiAzMDA7XG4gIHNyYzogdXJsKFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFWQ0lBQXNBQUFBQzN4QUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCSFUxVkNBQUFCQ0FBQUFEc0FBQUJVSUlzbGVrOVRMeklBQUFGRUFBQUFRd0FBQUZZL3QxRDZZMjFoY0FBQUFZZ0FBQlNYQUFBdENDanU3MlJuYkhsbUFBQVdJQUFCRzVzQUFuRmdrbW42TEdobFlXUUFBVEc4QUFBQU1RQUFBRFlQQzRaQmFHaGxZUUFCTWZBQUFBQWhBQUFBSkFRN0JRVm9iWFI0QUFFeUZBQUFBcDhBQUFzMFRhMytubXh2WTJFQUFUUzBBQUFIZEFBQUN6Z0RZQzFNYldGNGNBQUJQQ2dBQUFBZkFBQUFJQVByQVoxdVlXMWxBQUU4U0FBQUFWb0FBQUx1TjUzU1JYQnZjM1FBQVQya0FBQVM1QUFBSldoODF6MjZlSnhqWUdSZ1lPQmlNR0N3WTJCeWNmTUpZZURMU1N6Slk1QmlZR0dBQUpBOE1wc3hKek05a1lFRHhnUEtzWUJwRGlCbWc0Z0NBQ1k3QlVnQWVKeGpZR1I4d2ppQmdaV0JnWEVhWXhvREE0TTdsUDdLSU1uUXdzREF4TURLeklBVkJLUzVwakE0ZkdENE1wM3h3UDhEREhxTVp4aGNnY0tNSURrQUN2ME5Od0I0bk8zYWFieFBaZGNIOE45dm5ZT2lwSkVrSVUyS1pLYVNlU2hFaGtTa0lzMmxRbWttTkNtU1VpSE5zNlI1RWhxa292RnB6cTNTY0d1NDk3WDN2cnNiOWF4MWZsNC9iNS9ueFdOL3ZxMDY1L3ovLzcydmExM3JXdGNSZ0dvQUt0d0JyaEtvZFN6by80YWF3L3lyclBwNkJXcFdmYjJ5WmpPQWpmeUxOZEFvczZ4YVZqdmJNZHM1MnpWcmtEWE1PbWM5c2dIWnlHeDBkbVoyU1haWk5pTzdLcnNtdXk2Yms4M0w1bWVMc2p1eUpkbXliRjMyYnJZKzI1QnR6SDdPeW14enFwVnFwKzFUZzlRd05Va3RVdHZVS1hWT3ZkS0FkRXdhbmNhbDg5TzBkR1dhbSthbG05TXRhV0Zha3BhbXg5UHphVTFhbHo1T242YjE2ZHYwWS9vbGJjNloxOGhyNVEzejVubTd2R1BlTngrUWo4cFB6eWZuVS9KcjhsbjVEZm04L05aOFVYNTNmbi8rVlA1cy9ueitZcjRxWDVlL24zK2UvNXh2THVvWERZc1dSZWRpUURHeUdGV01MeVlYbHhSVGk1bkYxY1hzWWtHeHVMaW5lTHg0cVZoVnZGcXNLZDR1M2kzV0Z4dUtiNHFmaXJ3b2k3OUtsdFhMT21XVHNtblpyeHhVRGl1SGx6Zi8vVGVRSWF2TWFtUjFmSVRxVm8xUTQ2eEwxanNiNkNNMEpqdmJSMmhhMVFqTnltWm5jMzJFRm1TTHM3dXlwZG1LN0ozc1F4K2hyN0x2c2l6N05TRnRtK3FrZWo1Q2pWTFQxREsxVDRlbUxxbFBHcGhHcGpGcFlwcWFwcWM1VzBab1FYcklSMmhaZWlhdFNHdXJSdWp6dENGdDhoSDZOVWRlbWRmTTYrYU44OVo1aDd4TDNqOGY1Q00wSWIrZ2FvUm1WNDNRd254eGZsLys1SllSV3Btdnp0L0pQOHUvekxNQ1JZT2lVZEd5NkZJTTlCRWFVMHp5RWJxOG1GRmM1U04wMjVZUldsNnNyQnFodFQ1Q1gyd1pvY3hINlBmaWJ4K2gybFVqMUtvY1VBNzJFUm9SSS9UL2YvNkhQL1NWMXBSN3N3MDcrZFc1NmpxZmwvRTYzdTNYQ243dTExZFYxMForeTAxKy9jek1xbHROMjl2MnRRNStIV0tIMjFFMjJzNnpTWGErWGViWEZUYmY3clQ3N1VGN3lsYlpCL2FwYmJSTjlxUGw5c3VXNjFmYmJKc3JVRkc5b2w1Ri9hcXJZVVd6aWhaK2RhbzRwS0piUlkrS295cE9yVGk3NHB5S0t5cG1WQ3p5NjhHS2g2dXVwVlhYc29ybktsNm9XTDdsV2xHeHJ1S0RpZzhyc3NwdEtydFU5cWdjVTNsUjVmektKWDY5VUxuY3J4V1ZxeXBmOGV1MUxkZnJsVzlVWGV2OGVtZkw5WUZmbjFhdTkrdXJ1S3J0VXExQnRTYlZtdmdBOWVWcWE4aXhOdEFlWkdzNzF5YmFlYmpkcHR2dTFvQ0Z0Y01IUEJXdjJmYjRuVk9zaGgzSEczZ3JPL0pFZTg2ZXNlZjVHd2JaYVhZNlRzVnAvQVV6ZVNqR2M2cE5zSE84dWxYRFZxak9lVnpIQyswcFR1SVhmQUFWTmdOL29yc040cTdvdysvNWtmVm5WOWEzby9BWG5zVnpQdjdQMnVWWXlOOTVDYjVEUDdSR0d4eUtGdGFVMitNTG41c1gwWk5ic3crdlpEdldZMTNXNHJlNDJJaVBlUzlld2pOV3gxcndFQjZNYnVpS1d6R0RWK0MvOElrZGFXM3RFdTVzcld5dTNjR3IrRFcvdE1YWWFEdnhlSnlQK1J6T28za01oMkYvcjlQTjBZeUgyeHQyQnR2Z1BIU3hoemdiYTlrSlAyQUQzN2U2MWg5SDhVYk90ZUYyaTUzQWUreEd2b3pyTUEvWFl6WSt0TjdXM1hxeDBtNWpUenNWSjF0N204Ly80dlhjQ20vZ0xidlhCdHRJbklEM2VRWnFjaGtiWWd3SDhDZlV4bmFvZzIyeEEzYkVUdGdlLytKTUc4K1YzTXkvN1Fpc3NrUFlqWSt6QjZlemc1Mk45MnhiM29SdjhiWXQ0cCtleTl2WUtEdUcxZmdybitIVHRpK3VZRnZiQVk5aEdSN0hVbXhqdCtNQy9FM2FqdnpPTHVNTG5NVnJzSWlmY2lmYkU1OWlEbTdFWEZabmpzSjJzYmRzWjF2RGc3aUhIV1pkckt0MXN4N1cweTYyaTNnNzcrUmkzc0VHdk0rTzVTdllHWk53QTM2ekZaeGpmVmhoQzltZk03Z2JKbU1GUDhiMytLZFZ3MVYycHMzR2o5eWZMYmtYbTNNZlg0Mk5lU0QzNUhWWXlmYzRuaWZ3QSt0b1Rhd3hUbUYzbTRleC9DZlgyQ3BjaE9QdE9ueUpYdHlGYjJNY2JzRUMzR1l6N1VxY2lBdnh1dTJGbTNFVGt1MW45L05WTzVyajdIRSt4aWZzV3J2R0h1TWp0b3hMK1NpWDhIWDJ0ajNzUG5zQXg5blZOZ0lqTUJvamNTeU80V3M4aDIveUxSdUMxVGlDWi9Nc25za0pQSlpET0lxRE9ab2pPTlN1c3Ezc1prekY1WmlHUzNneEgrUkRmQmdmOFVNYmFnZFljNDdoUDJ3QlRrSnZmb1Z6MEFPMThKTzE1bDA4anVhN3Z0azlQSmNUYmJKTjhjcHhnZGVQQTNFMC8yV3YybXUyMnE3Z2s5YlpsdHV6OXJBOVlrdnNVVnZxVmVVdXU5VnVzRGsyeTZiYU5LODZ3MnlBOWJVMmRwRHRZN3Q1WFRLcnNFcit3WXcvOEVkTzl1cjFHVC9oV2o3SDUza2JGM0FoRi9GbVR1T2xYdVV1NEVrOGtnTTVpRTNZZ3MxNGdOZkJwdHlPdFZtSE5mRUVuc1JUZUJxZll4MWV4Zk40QVM5aU9hN0dOYmdXc3pBZGwrSXlISTYrNkl6RDBCYnQwQjRkMEJHZGNEQU93WUZvaVlQUUNydWhBWFpIUSt5RnZiRVA5dlhPcHpHYVlFODBSWDNzZ1ViWUQ3dWdMdXBoVis3QUhXMDcxckJ0ckpiWDFxMnRFWVpqRkNaaURkN0VPM2dYWCtGci9Jek5CRnV4RnkvaTFieVd0M0ErNytkVFhPNTEraVd1NGdaK3cyUzF2VEozc0lPdGs5ZmxFMjJjamJWVDdGSzczbTZ5dSsxMWU5bGV3V2ZjRmtNd0dFTXhES2ZqREV6QW83Z0RpM0VuN3NaZHVCZjM0SDdjaHdmeEFCN0dRMWlDUi9BTk51RVA3dTU3dzJFOGd2MTRNay94M1dFOS96SllTK3RueDl0WjlyU3R4TmJvandFNEVnTnhGczdFMlRnWFUzQWxYc1lyK0FmV2U2dVM0MWVVK0EvK2pWKzRIL2RsZTNiaFVSekowM2c2eitQbGZJUHY4aDNmYWY3Tmt2K3grbGJQZHJWbXRyOGRhbVBzSkR2WkxyUW43RWw3MFY2d2wreE5yODNWLzdlM3ovOERmN2FKZnpSK1dQOWhhNk1qRlBiMVNPRnFqeWJXMEdPbGNLekhhbUlEUGRZUWU5RGpWc0xXSHJjV085ZGpUYkdKSG11Sjc0bkl0aEhjN25GYnNla2VhNHZ0N3JHT1dBT1Ayd3NManp1STc2ZklkaFI4NEhGbjhUMFdXVjNCYXg3cmljVjc3Q3I0M1dNRDRSU1BEY1hpbVJxTEhlZXhpZkFHajNzS2IvWFlWTmpSNDE3Q0V6M3VMZmFjeDMzRW52RzRyOWp6SHZjVDMrK1JOUk1NOHJpLzJHa2VEeER2QnBBMUY4Unp0UkRFenh3bzNpc2dheW1ZNmZFZzhmNEJXU3ZCZUkrdGhWTTl0aEdiNExHdGVKK0JySjBneHFHOXhIa3M2eUNJZWU0bzhCV1ZkUkxPODNpd2NKM0hRNFFYZWp4VTdDbVBuWVdUUEhZUmZ1R3hxM2hYZzZ5YnhCa3c2eTdlNlNEcklkN3pJT3N0aU8vM0VZc3g3Q3VNZVQ1Y0VOOC9Rdmk5eDM3Q2p6ejJGNHM0UUJqM01sQlkzK01nOGI0SzJSYmVZU0ViTE41cklSc2lpSGtmS3R6a2NaZ3dmdVpvOFo0TTJYREJRby9IQ0NNblI0aDNiTWhHaXZkdXlFWUw0dDdIQ0dJK2p4ZkVmSjRnaVBFK1VSRDVNbFlzY25hY01OYkNTWUlZLy9IQ256MmVMTjRmSWp0RjBOUGpxY0pZMzZjSlkyeFBGMTdwOFF4aDVOR1p3bGgvWnd0alhVNFFSajA0Ujd6elJIYXU0R0tQNTRsRlRab28rTmpqSlBFT0ZkbGs4VjRWMmZtQ1dHc1hpRVg5bUNJVzQzQ2hNSEx6SW1IazdNV0N5THRMQkpFRGx3bGl2VThUUkI1ZUlZdzRYYnd6UmpaRDhJbkhxOFNPOUhpTldLeXpXV0x4T2RjSm8yN05Gb3YxT2tkc3JzY3Q3QTZQTndyanZlY0p2L1k0WC9pbHh3WGlIVG15aFlLTkhoZUo3ZVJ4c1RCeTV3NUJqTjlkZ25pL3U0V1JwL2NJSTMvdkZVYk8zaWVNSEw5ZkVEWHNBWW5mMzJRUENxS0dQU1NJbXZld01OYm9JMkp2ZUZ3aUZubTBWQmk1L1pnZzhtS1pJT3JIQ3JGNDc1WENHTXRWZ3RqalhoWkdyWHBGL0FTQzdGWEJCbyt2Q2QvM3VGb3NjdlYxcWFvUGF3UlJBOTRReHB5OEtZeTVla3NzeG0ydDJDMGUxNG5GR24xSEdPUDZybGk4ejRmQ3VOK1BCSkVqSHd0aXpqOFJQeUVoKzFRUXovdVpJTjdqYzdHb2tWK0lSWjFjTDliTDR3Wmg3TzFmaWQzbThXdGhyUGVOWXJIdXZ4TkViZmhlTFBhSGY0cEZ6bXdTeGxyNFFSajMrYU13OW82ZkJERitQd3RpekRLeHlLOGtGdlUxRjR0YVdBaGlERXRCek5ldndzaVozeVIrUDVqOUxveDgrVU1ZKy95ZmdxaWpmd21qOW04V1AwUENQNzZLbnlhUktINnU5RU9TK0FrVHFVTDhySWxVS1g3cVJLb21mdjVFcWk1K0VrV3FJWDRtUmRwSzhDK1BXd3Q5NzA0MXhid1dwMXBDeittMHJkRHZMOVVXL3UyeGp2akpGbWw3Z2VkOXFpZm10Uzd0S3ZUNmx1b0xIL2U0bTlEMzFOUkE2TFVzTlJUNmZwOGFpWitVa1JvTDN2UFlSQ3p1cTZuNE9ScHBML0VUTmRMZWdyYzk3aVBtTlNqdEsvUTVTUHNKdmM2bVprTHZDOVArWXFNOEhpRG1OU2MxRjhZWXR4RDYzS2VXUXEvLzZTRGgweDViaWNWbnRoWjQzVTV0aEY2VDB4WVdjOWRlL01TUDFFSDg3SS9VVVJEajFrbmd0U2tkS3RGWnA4NWkzdE9tTGdMZmgxSlhRY3hYTjJIa1ZIZXh5Sk1lUWw5anFhZFlqRWt2NFFzZSt3aDkvMGg5aGI2dnBNTUZNYlpIQ0wwdXBIN0N5TDMrWXQ2L3BnR0MrSm1CQXQ5djBpQ0IxNkowbE1Ccldob3NjWUpLUTRTK0p0TlFnYS9KTkV4c0Y0OUhpL202VHNQRmZJOUx4NGg1RFUwamhURlh4d3IzOERoSzdEQ1BvOFZpTE1lSXhWZ2VMeFpqZVlKWWpOK0pZakYrWThWOFgwL2p4SHkvVHhPRk1VZVRoSGQ2bkN6MGZUR2RML1I5TVUwVnh2cVlKdlE5TDAwWGkzdWZJZlI5SmMwVXhQTmVLWWpQbVNQd2MwVGFBbDZuMGx3eDM4UFNQR0g4N00xaU1lZTNDS1BlTEJEemZUMXR3WmpiaDRSeEx3OExZMzAvSW9qbld5S0l6MW9xOUgwbExSTjRUVStQQzd5bXAyZkVZcTA5Sy9EZUl6MG41cjFkZWw3TTk2QzBRdUMxUHEwVXhqcGVKWXcxK3JJdzZzUXJ3bGpUcndxalRyd21qTnF6V2hpMTUzV2huM25TR21IazgxcWg3NVZwblNBKy8yTmgxS3RQaFZGWFB4ZEc3bndoOVBOaldpOFdhMzJEV05TNUw4WGlIcjRTZUUrY3ZoYkdPdDRvRm5QNGpTQnk4RnRoak9jbVlkejdEMkl4Tmo4S0lqOS9FVVNPL3lvV3ovV2JJTzdsZDBIVWhqK0VzZTcrRkVhOS9Vc1F1YjlaNERua3k3WUtQSWR5Q256Znp5dkZQSGZ6YW1LZXUzbDFnYStydkliQWUraThwc0RuSTY4bDVuT2ExeFY0N3ViMUJMNHY1THRLYktwNWZUR3YrL2x1WXQ0NzVnMkVuZ2Y1N21KZVIvS0dRbitXdkxHWTUyamVST2kxT3Q5VCtJVEhwbUxYZXR4THpPdGt2cmRZL1B3K1FsOGIrYjVpdmdieS9ZUytOdkptd2tjOTdpLzA5Wk1mSUl4bmJ5NzBYaXR2TGVaMUxHOGo1clVpYnl2bVBYSGVUbkNjeHc1aVYzdnNLT1pudjd5TElQNjlxOERyWU41TjRIVXo3eTd3K3BQM0VIaHR6WHNLZmYza3ZZUit2c3A3QzcxUHpmc0l2VDduZmNXOHB1ZjlCYjdlOGdFQzMwdnlRVUx2QWZLamhHZDVIQ3owT3BBUEVmcTVMaDhxakhzYkpvenZIeTMwK3A0UEY4WjdIQ09NWnh3aGpEaFNHTzkzckpqWG4zeVVtUGRQK2VsaWtXOFRCRjZ2ODNNRWZ0Yk96eFY0N2M3UEUvajVLNThvOUQwaW55VDBzMG8rV2VqMU5MOUE2UFUwbnlMd3ZqeS9SdWo5ZGo1TExPNXp0bGpreUJ5eHlKRWJoTDZINWZPRS8vQjRxMWlzeDRVQ1A1UG5pd1F4YjR1RlhuZnlPd1R4ZkhjS1l2N3ZFc1JhdkZ2Z2ZXeCtuMWprNXYzQytOa25oWkdIVHdtOXI4MmZsZmg3OXZ4NVFYejlSVEUvcytRcmhUR3VxNFF4bHF2Rll2eGVGNHN4V3lQbWUycitobGlNNjV0aU1mWnZpWGx0ejljS0lsL1dDYjFQenQ4UmkvcndybGprK1h0aThmbnZpM21QbDM4bWpHZjlYTXo3cy94THNlVWV2eEtMNS81YUxPWjZvMWpVaDIvRVl1MS9LeFkxNFR1eHFCWGZpOFdjL0ZNc3hubVRXTXp6RDJLUkN6K0tSWTc4SkJaNTlMTlk1SEFtRm5tYnhHS041R0t4dGdxeFdLK2xXS3pwZjR0RkhmcEZ6SHV0L0Q5aVVmOStGWXNhL0p0WTFQdmZ4V0xlL3hEejNpUC9VeXoyaXIrRThmM053cXlxRmF4Q2Y4NkNRbi9Pd29TZUcwV0YwT2VqcUJUNlBCWFZoSDYrTGFvTFBRK0tHa0x2T1lxdGhKNlh4ZFpDMzcrS21rSmZSMFV0b2ErbFlodWhyNlZpVzZIWGlxSzIwTWUyMkU1NHFjYzZRcy9WWW51aDUycXhnOURYWnJHajhFaVBPd205aHk1MkZucXRMSFlSK3Y1VTFCWDZXYVdvSi9SOXBkaFY2TFdpcUMvMC9hbG9JUFE5ck5oZEdQZllVQmozM2tnWTk5dFlHR1BRUk9EN1lMR253UE8vYUNyd2RWN3NKZkR6VWJHM0lPWmlINEd2dDJKZmdhKzFZajlCakhremdaOUhpdjBGWGhlS0F3Uytwb3JtQXQvWGloWUNyNVZGUzRIdnk4VkJBcy81b3BYQSsrbWl0U0Rtb28zQXowRkZXNEdmYzRwMkFzL3pvcjNBMTNYUlFlQm5oNktqSUY3WFNSQ3ZPMWdRcnp0RUVLODdWQkN2Nnl5STEzVVJ4T3U2Q3VKMTNRUmVyNHJ1Z25pK0hvSjR2cDZDZUw1ZUFsOXJSVzlCekhNZlFjeHpYMEhNOCtHQ21Lc2pCREZYL1FReFYvMEZNVmNESlA1L3FXS2dJUEppa0NEeTRpaEI1TVZnUWVURkVFSGs0RkNCOXpERk1FSGsydEdDeUlYaGdzanhZd1NSNHlNRWtlTWpCWkhqbzRTeGhzWUlZdzBkTHhhNWZZSXcxdnFKWXJGMng0ckZtaDRuRm5sK2tsalVnUEZpY1orVEJIR1Brd1h4K1pjSWZKOHFMaGY0bmxSTUZmZytWTXdRK0I1VHpCVDRIbE5jSmZCOW9yaGE0UHRFTVZ2ZzlicTRUZUIxc0ZnZzBWb1hpNFdSQS9jSUl4Y2VGM3JQWHl3WHhudS9KSXcxc2xMb2ZYdXhTampmNDZ0QzM4dUxOY0pZMTJ1RjhYN3JoQ3M4dmkyTTkzNVhHTy8zaGREUE9jVjZvZTl6eFFhaDd6ZkZOMkpSYzM0U2l6ek14R0x0SkxGWUk3bFlySjFTTEhMNWQ3R1kyei9FWWo3L0ZJdDUva3ZNejFiRjMySmVCK0xYZk1HdTkwZ3hQMU9VMWNXODF5bHJpM25QVVc0bjV1Zk1zbzZZbnpQTEpnTGZhOHFtUXQ4UHlsWUNYd05sYTRHdmpiS053TmREMlZiZzY2RnNKL0MrczJ3dk9NTmpCNEgzb0dWSGdmY0paU2VCOTIzbHdRTFBpZklRZ2ZjTTVhR0NlSmJPQXU4ZnlzTUU5M3JzSXZBY0tyc0tQQWZLYmdMdjg4cnVBdTlqeXg0Q1AzZVVQUVhlMjVTOUJON2ZscjBGM3R1VWZRVGU4NVI5QlQ3MzVlRUM3MlBLSXdRK2YyVS9vZGV1Y29Bdzd2MUlZZHo3UUdHOGJwQXdYamRZZUxMSElVS2Y5M0tvTU1aaG1ORHpzaHd1OVB3b1IwajhHclljS2VhMXR6eFdMTjUvbEpqWGwzSzBtSjlaeXVQRWZPOHJ4NGo1R2l1UEYzZzlLVThRZUcwdFR4VEU4NDBWeFBPTkU4VHpuU1NJOXg4djhETlJlYkxBejAzbEtRTHZtY3RUQmQ0Ymw2Y0ovS3hkbmk2SXZEMURFSGw3cHNEUEMrVlpnaGlUc3lYK0FyK2NJSEc0TDg4UmVHOVhuaXV4Z01yekJONy9sUk1GM2lPV2t3VGVJNWFUaFY3bnkvT0Z2citVRndnajM2Y0lJeDh2RlBxK1VsNGtqRG01V0JqUGQ0a3dudTlTWWR6TFpVS3Z4ZVVXOUxOQk9WWG9kYXFjSnZTYVhGNGg5TDY4bkM2TSs1OGhqR2VjS1l4bnZGTE05N1h5S2pIZm04cXJ4WHh2S3E4Ujg1Nm12RmJNZTVweWxsaXN5K3ZFSWwrdUY0czVueTBXOHp4SExNYmpCakh2d2NxNVl0NkRsVGVLZWI5VXpoUHpQcXE4U2N6cmMzbXoySnYvRFpieVlFQUFlSnpNdlFtWUpFZDFJSnlSZDJaVlpSMVpXVmwzMTlGVldUMTlkMTA5MHpNOU5aYzBrdEFjMG1nMHVsdU0wQUd5R0tRUkNITzFrQVF5SUpnRnlRaU0yUVpqSTR6OFd3dmlzMnd3YWdHMjVkOWVleGJ4R2EvTjBhd3hzSit4Vjd2bTg0SU5OZjk3RVZsVldkVlZjMGp5N3Q5VGt4a1ptUmtaOFNMaVhmSGVDMDdpdURQcjVEbXl6azF6eTl3eDdtYnVYbzRqQzQwZHBGYWVKUFZhdVpndnlGWTRHcXZtTWJQYXZkTkxPZUdvREUrVjYrRmFBNTZLV1VvRDNvTzNvcmFzeUJrU2pTMnhBcDJ5c3hDTHlvVnlyV0ZINVVsU0tFTm1ZeWVKTFRUdExMSEkwNUtpU05GMHRMMGVUYWVqcEFWSm1zT09PVTFwcnl1YXBwQ1dvdDBkbWQwOUcwa2Flakx5Y0NTcEc4ZmdqVW82ZllzaVBTd3BvWUJsNUF3ckVDSTVSYXBJeWh3VzExN0I0eHpOYUxGanJmMHhXdDRhSHI4ZVMrZG5aL1BwbUdwSFRDT1NURVlNTTJLL0ZrdXRwR25OaklBbHl2QW5XZ0dPVXpuNDR6bXl5Z1c1TVc2VzI4a2Q1TzdnN3ViZUJkRHpRQXhnVWhZR3dWTmtEUWVveEFBNnNuT082NWNLenRPc3lXUU5qaUlBYjZYVDJLbmJzVG1qRG45MmZxQmRCWkJ1MFBKejBYVDdLVnAyRG8rbkZVbkZzbFFLNXlISjNSY0dhWTRUWVl6K0Nma1plWWJ6Y3dtQXRvTWpORXVpQmluTWtOb3lhUllNRXMyU2hXVlNteUdLQlhrTk42dEt1S1hqMjdiZGNpOGV0dTI1ZTgrZXU5K0ZoK01UemVZbGs1ZE93bzg4N3Q2R1E4NjlEWWUzL3RTMzk5cTlzNU9YSHIxMEV1dUE4K1JabUNmUGNTYTNtenZBWGNQZHluRWx4U0N6eE5OWkFQY3hnbjB5UytTQ28yRGY3Q1F6TUkyYTVUcFV0TG9Rc3hlcWVJYitpU294S3lvTFdXSmoveFlMY3BCRWJXak1ESUcwN1cwUzJTSUt1dGlTS1BTYUluOTVYdElNY1h6Yis3ZU5pNFltNWZPbFpESmJ5K2FiQVo4djBNeERNcGtzdlg5aVg4SS9tN2VLdm4vMEovWk4rSXBXZm5hOWRxeFdPM1k3SG83TElpOU1DZkpEQ085ZkxndjZhd3RZMXZqRXhEZ1dYaGk3YW5aeGZxd0NaUlV6bVNLY0tybTV4ZG1yeUlvMmxUZnQvR3cwUEdtYnVXa3RGSjBOdTBYQ2dmWFZQd0djUHRTZEZ4dzB0VHM2RVV4U25xRU94Q3c0bk0yQjYxS3g0QjNtWmJJaThqL2hSWHBvL3haNUdwUHRWK0hSa3laSE80K0k1SDF4VE9KaGpaM3djSWJycFQvVlMzYkcxMENkdzNVMldYSCs0ZVMxejFIbjVzQzF0Mjd5aUNyM1ZmOWt0ODRQRHEvejZqbnJqSERHdWlLY3NlN25oTE43cnJyNUpBZVYrVEd0V0JRZy9ZTlJWWTMxSG5wRllHME93RnE1UUZpdnVYV2hsZi9vaUZwL3N2ZklCUU5iTy9Oem1QdEFKUUhyaDdra1YrU211RHBReTF1NUp6bXVXWkNqc1lWR3JWenRKSnhPb250TDJYVEw4NHhDWjc4eVF3cXlVcVpEdit5VURjQWpXWUl6WUNlaGpiV2pRV0lRbUVhQWJ4ck5oaDBEUElNM0doUnVuYmx5aml2clJVRFFocVpkdzA2ZlpxZmZaNmVMaDUzK1M4Q1h0NDJBbEIzUFNnSER6dnNpdHFNRzd0YlNvUy9ZUlNtcTVJbHM4UkhmRjhMNjNaS2c2bjVGS29rK0kycElRa2lRaHB4eldHam41MTZzc0ZPckw5TTlQU1ZsN0x3U2pzWENTdDcraUYrVVVqUG1aNDFnSm5aN29YaWZuWDhxTjNhYjN6Q2VWSUZLaW9MY2xFVDUrN3BoNkd1Q0pBbnJtRnJIMUZvMzd4Q21jQndxaU0vNSs4a25vRGV2NUs3blhzKzlrWHNIOXlzd2k0cDE1R3F3SDdwNHlPb0EwV1Y2SkhnRytxR1BQMW9DU0dDWDFtdE90WmR5bjBjYWpiUzZXYVRkWFBSd0EzWjFZWXd2Mm9OUDFLdWtzaWdKYzRLMGlQWHVKY25sY2ZOSUpEV1ZpYmEvRXMxa29tRWV5RFgvTlhyY0J2ZmJGcVBYMzNyS255L24vV09Lcml0a1dkRnpVd0g5Q0huOEVMdTdQVVR2aHRZSU4xQyttMXkvTXhVNVlzNUhVNmxvK3p2UmxLb2l5VmJWenBuMjV3b2oyU3ZCY0Rpb3lWQnRUWk1QYTBlRURVLytDdExPTTc4QVdEOEE4MmVKZXkvM3Q5d1B1UDhKdExQc3pKQWdjY29LREh0Z1pScEF1aHM0RVF3UzVObnczMG5zaFNZTWREbExtbktzdXRCY0pqdjVaWGlzMmNDM1pKd0lOQW52QXc4RVQyRUJjTkdJMmZOWjdDeEtWNVY1ZzVUaDNhcTlBSk1KSnc2UVd2eFpCbEhrR2VJVW5BSmNsWEZtd1FQd3F3TVpibVFKZmlPR244Z1MyVTNIYk9nanFMaUM5WUVMdVVESk5TRFJoVVp6ZnBuRW9Qck9uQ0lYYVgvYXpibG1vMHFaTklkL3F4VlZ4MExOZzJyQUNzdXE0bGZWTVl1a1kyRWpQeW5sNXd4Tm1jRGJWMllUcXVHajl6Slc5OTdmbVFGQmcwbW82N0p1VzdLa1JDb1JMYWdGaXlHWlZ4SWxYZlNab2hUMWgrT0prRDhxaWFaUDFNZGpSM2wrV1pENUNaNFhHandwRTdHVVZjUGliMHRYRE0xWDNVL0lQbDVWaG44am92ZDlRaXY1aUNnSnNxU0ovNkdUK0llSkxVR2ZtbFlJTCtxYUlrbWhjVXV3eG56cHl5ZVgwbW8yZUNXOUdUTFVnUnZmQ1ptU0psZ2lDVWFJRUJBQ3ZDaHBVc1F2S2J3a0JHS1dGaVNhTDVBbzJnR2ZSb0s2YWF0a0RHcC9wYUR3WTRUZlIvankzb1NpUnU0YW5xMUE0Ym9JaGF0QnZWZTY2ZXVWYm5uTHZwU29raXFyT1hhaU5PdE0rOHc2djV0OGhkdlBIZWFPY0ZmajZNVWhBNU1laGxDNEp3b3RBN1BubEhINjIxWVhlNFFoRHg2QjRlVytFN01wWjllRVRJZXdhUTlVcjJubm16YjVxYUFMZXlWWm5RK3M3S29oYjFhTHBmaGlJbFZKV2V4eTEwcGdYcFdsdmU1ek5hMlF1K25PbTFwYURUTGJYek9USnZ5K2FwcmtsMDN6R1FFZUNkWXVGc2tZWlIwTDh2aGNrWkJ5S2xhVUNqU24vVDN4NGxvUUNzTUhaMHZqbFMyWFRBY2w0ZzlnS2VZL20vQ0hZczZaTTRBWENibU1zN2d0UVBFYzVHb2JDMk13U1JhUTNRMGlzMnMzR3pYV1JJZTJNd3AzRnU0N0tRb3E4SzYzM0NMcWtCQk9pcm9ZT1NuMDhnQnIzeXZvdi85R3VGWkU4ZFpiQmNqUmhUY0t3dXFtTEJTMzRBOW80QzR1aXZWZ2RjRFAyNndPOFBtYVlzZHdsa05WdXZXUm8vWkhOcFgydHMyZi9OUCtpb2tuQlQxd1VoU1ZnZnA3NjhIZ29iQlA3eVJkd01TaVNyTUxCb1hCQW12MTZmTnA2RE5EUGhyWlhEZHZ2MUI0Tkx0ZzZGYW9zZUIwdjk0RlRMbWcvTXJtUGdnTTZhby9PUit3UVJYY2V2Z0FIaU5HeDdDQjhPYWhaU0ZzdWMvU1BoN2V3NGxOcnczcE9FODUxcWdlR3RJWncwRHZiUi9VeVJ3RzVTSHdKTXFRRWN6NDN3MmVBTitSNGlhQkhsN0c5QVdJS1d5djFzQlpKb2hUQm5VSHpYNFdmNU11Z1FuOTBhQUFjamtraEdBMFBRNmlQOVZ3a0JWRnkzbjFBRTkyWlg2eWxvN21Ra2xSMDg1d1ZLYm5ORTFNaGxDeVAwR2Y1dkRZd2dPVjhaL3FTZk51bTU0blAzWGw4M2x1RWRya2xWL3RycVFPY3EvU3gxOTFaMFpaY2FyMXFnVUNlMDlLZjJ6YjhYdHYyVVlQeDFxR0RyeGJ5NGhvcTNwU1g5VWk3MTlkYWEyUVozb1MrMCszdWM5dU81NjZIZG04MjAxOEVKODMxMVpYVjRmV3N3VFY2MVpWNlZZU0t1eDRORnkxSGtack9FMnJhaFV0OHRQei8vTDZoVFJwT0R5YlhXQkNiWnRlNVllSDBDRFgyWm5pc3EzVWdZbXNxLzkrMVJ4V1Q2bGJTYWl3MHdVbVZMVlo5WExSWGRRY2E5cEZxMWd2WGxpL0wxNUl0eU8rUHZOZDhtV3lCcmhnR25WSE1GV0FLM01SQ3N3ZEZFQ2J4VTFEa3ZZODhXbitleVZSZUZLT3lFOEtvblN2WHp0Nk5EWjJWZGoyUHhtY0NqN3B0OE5YalpGVnYvWlpYWHhTbHA4VTljOXEvdHhZN0wzeG5QOTNnc0hmOGVmaTc0Mk5jUUxPZTdKS1BnbHliNG5iQVpEeVRHT3E5YXU2b09ueENjaEc0RU5GQUorTHRWQUVSREdmbkd3L2poT1E0T3pkT0NEck4wcWkrQUhSZ1AraWRLT21STlBMNFJqeGY4Q29HQi93azFoNEdlWjNiODZ1YU1vcFhmeUFKSDFBMUU4QlVraEhUMEJ0VHhuR0thanRpV2dhWUVhUkZjaThxNTM2SWdwQ0xBTTRpbXB6bXBZNzVOd1J4NENuMUNnNGw0bUwrV2NJVnI5Y0gvejJJNUwwaVBmYjd6ZU05N052KzJtVEpOcTg4MnNZSjFEOHZFN3U3OVNWdUhYczFGbXB1NTNwem1JRzZDWStaRVdwQ2creGVKYlFZV0dSOWZPdjdVdm9Cd3JiTTk4aDk4TjRkT3RyZXJRZk9DYnN6bGgwaHlLcnZNUEdiWmE0QTNlWnNKRTdDbUtuaEZGVkFPUi9JV01CK0l3ei80MDhSejdPNWsrSndVMTJ3Y1ltazJYWE42RktDbVd5ZG82cDhkaDV6QzgyaHoxMWFMSngxbkNIV1ptTk1zZmFoQVlwR0hQbnFNSS9uRmNWR08yR2NiWkdkVmROYnZsOGRQMW5wM2FuMm11VTNxNjRPdm91b1c2TklIaEFxSHV2dU1TWkV2UlRvMm5lUUoxTDRmNVZuWktudnJpVWN5N0t0MzVCVlFqUnRyRTN4TTZUMk00UkxSd081d1Rwd1JqckxybDE3Y0Q2SEZUUWhUQ3RCVG5WcWNHSUdwTVRGOWdwM1BBNjI1NzZJcXhORDR5eDN1ZWdpSE1YQ0xqY0JUV1NZemllMGlSR0Z4RVBuWlV5b2xLR2duYUcwSkZoMW5zNldPeWJIdzVnUDEwK2NHQXo4bm5JeFZRVVpaTFZjMkNmOXFzNmVFcnAwS1RuZ0NhNTlUMDdKa0wxRWgyNnlFb0RoS1VxNncrY2p0Z2ZaTTM3Y1ZrLzI4Yy9zZ210am1oYkR4ZjM2bnQvcDc1bngxcW84S0xEd0NBVVcrQTZDTk1zc25ybnpnRXI4blMzdWo5VXRBdnRpdTU0dUw4M0hxcU0reWk3ekFjRGRsRnhPWlZsNGc1WlZGUkRHd1NydDVhQTQrSWx3T3o4VzhpNWZOMEc4SFdmWURUaDdMWDFUREJhMnkrY0I4NC9GMVBud3F6SEE1OWQ4cUVhZ1M0OThLaEpzTitkRVJ6dzlTZzdYcWxJdXFSY0FkS29MSXIzZ0Z4NWp5Q01rSDBhOE1SVlgwWXdmZmtxa1FxZTk5QlhoQ0YxSFMzOWRBUmJObEtyakQyWjdJamh6Z2pwNTJJUWcwSDRGZ2VySUE0WExXNXdXN0twaGNQZ09sb0M2aWdaV0oyN0FyRXI2dHZESmFEOThOMTdtTHFnVzFYNHRDNE1yK3IxOEt4NE4zMUN2SUpXOVVxVTdnVmg2QmdZTFFYMVlJcjE3UzZNdXFxRTVvZ3hNQkpRdytVZ3QyMTkzVURieGxIOUNzaENTS2V5MFA5MERIWlI0cVlSK1NYVWFYeU9mdkJ6VENIeUFweGVFTVhub2VXZkovZlJhZnZ3NTJuRnhCY0U0UnQwbUxuemNoWG1aWmFiQWFyUzlMYTV5NXAzMnp4QVJzWWZoWTgreXZRcDk5QnZzMzRTeUExOXBFTjlUQkFlRXpWVXNaeHNQMCt6RjFGOUExbnQ3dy9pQ1pkdVpLajhaM3ZIUzFjTWM4Y0xHYVFTbFpIZmFmK28reGx5dzZNQWdnK0pBN1ZXQlNEQmZUU0I2ZXlRSmxEWU5CM3ZQT3VLQWQxNU5rQUNIbjlVN05hRkxOSlNuM2ZiVE5MZHlwd25CRjI1R1BFOWhVdkpvOUFhSTExeHorMDlNb0RkejdQRjk0MnNNWWw3TzRsMCthY01jRTVVZDl2OW1FZVRpMlB6UjVzSEg0N0pGd1E5dldtODRvajhoakJZdmttVm90MHg1MUhRNG5mK0dzdHZQMHpCZEY5ZitlUmpJejhnZE12SGZsMGVoR2E5bzZKcmR0VERBMFpUU2o5UFhpY2pNYzR0WHZZNzUyVlBueDZGZnYvUXc5QkdlNHhoandmMDFMdC9SRzdDL0hhK1gxcHcrbm5jNmpjdXNBNzdScUcyMTNqWjJaeVgvL1hVT2VQeXJmYlpLSUNUN3hjVzdINlJyZmlQUTBnQjF1ZjNQUXg0dENmbGtPMGpldWJta1IwekRNN25vQVJLdUY5YWFQYkxQOVpyTGh4dS8za1VXZmpTOElaMjhmaDU0UWQ3QUkyUHhBODVMdzU2WmlSNk9OM0REbnhYRjNVK09GTVpRT0IvL2Fnb1Bqb2NaLzc1dVZGbXNSOTlkK3R5UDRQSjJURkpjMEFQOWMxTk5FUVhHSFg1KzU1Q2h0eXdxUktQMGNwRlBhb210Mi91ZDhmVHdHamFSR09kQWVSOWZzMTlmalNGL2ZPUnVMdEoxNW02Tk11ejZvVDRXeHlCUUo4WmlYTng3aURONUFuSmcyUTlDYkkxUjZ6OGdLSXAzeWYxU3oyUjBDclpIVm1yMWlDclp6Z1FnMXVhMWdJeG1IalM3ZTlMZkl1UUZpK1JuZXdzRVc1MkZrUnN1QXNQUlF6dnhmc0ZIcDRXNFRGZUVEcUpWWUZuZFQzekxJZDJnbTVkbThYd2dQQVI3dE1FQ1QyQnBXZ3FIYmw3SWJaMndWOXZlUnZVMTlCMHAzSHQ1OXpHY1JMV0UyRDZITGVITzhoZHg5M0czUU16dkZpdkRzcWg5VUZCcnpnb1dWdDlxb0dtQjk2T3AyMkswNUhSbzdMdHNEYmlhQ1c3Ris0MFUvcHVIWDRwODg2RllJVG9lN1MwdGtjbmtlRG9Xd2YyRUxJSEd2SmRBTVp1Z01GdWdNSDMzTHlQNHNXRDdNYmU4eTZ4Nzlaem5US2htTU1TendyK3RpZnoxL0JEa005eDdwb2x6OEg0bklRTGloQUdXQllHMEVIMG9KQlRvbGhyMzFkamMrcUlDRDg2MjJyazRmNDhZc0cwcVZZWmtUb0NNK1lJVzZjY3lITG40anFIOXR4UWx5Wmw3d2VtSUt2QkptYi9DK2YxaGJraGxWT0dOSUxXZzQydjQ0T1VvMW92V24wRXU0TzZMTGlqREdiaWRSSHVPSU9aZUEwbFZUdjg2UldYUWhVdlphaGpnanc5d2VwL2lRZy8yb0tKcDhrRTQ2RE85OEhBeTNsNTZJTWNwMkgvOER6QVpacmJ4VjBCMExtVHU1ZDdPL2R1N3IzQTk2TFZFR0tMSnJWc3FqTVowa0x6a0RxVElxMm9RazJSY05uQ1pGYmgxTklNamZzdzFWd21EcHFnR05USUJFMmlCak9VVFVhSm14Tk5SN0gvQmxtQTdGUkFNU095cjdoMDBmYUNIdEFtTDczNjBxbUFhb1psWDNyKzZOYkRXeUhQYVpUaCtEcFo1bjFUWTNKQTRlVmtXZWQ5ZXlIRDJGcVJBaW92RjZzQjN0ZnVNeXk4cmUvcTBWYXNoZlovVTl2amhtMzVUYnU0VklRZlZtRUtyYlNueHVKQk8rcVB4REx6R1JLcWJOdFd3VnNweDBuQnVjNzc1ZkVkbHNqN0FtS2tuZ1hnOEQ1bDVtQ0taaVF1bXBEbGczMFdodjMyaHBmQnA5MTU4eXo1TzVnM2RaU0xtNGp6RU0xNTFEVm9NaFliSTBySE9LMnJ2YlZqYURSV0puLzd4UzlLUEM4S212UkZTaHUvS0dtQ3lQUFM4T3dqZDk0SldUTGN1dk92a2U3OTlaM3dxQXozUnVRenVmcDU4alB5Kzl5bDNEVmRUVk9WOWpyV0ZtcFdkSlU0TVR1R1E0VnB3eGdyQk1PRzJxb3AxRm9OeGhjNzFXc3dQZ1FjWUUxcW9CNkZCMXcxeEo3S1pUbVJDSktnaWVuZEJUU2tQLzdHNCtsc0liZGdhRUtlcUZKQVZBaFBOQ2RaMkJHSnprMm1FbFlnWVIyY2NBcTV1MStiR2pPTTZYZzZtN0JzVjFPVnNBV2ZLQXU4RUkxaFFkc1dwbWUzMVRLcFVPUlRraVpKb2srUDJwVmk2ZnBhTUdCR1k4NTRhMCtqdHRUK3pIaXVtRWxseDVlMlJ0QVVpWlA3L0M3cVhJczd3QjA5OXpxTUJJZ0ZXU0tBQnZRWjB3NmlrYjRDblZwMXlyT2t5VGcwbDNGcUx0RGwzN1A0VUxUL2RtOUEwSFJaNFpjRU5hb0tTN3dpKzFSaGxpY0NIMTRJQTJXK1M1RWEwL1g2ZEVOU1d0bENNWk1aN1RMeDdJU3F5MCtvNmhPeXJuNVlsdnhLdGFyNGZaYWtWSyt0S2xLazBDbzgyRmxqT0FOdHY1OExjQ0ZvZlFGR3FnMDBHRnJKS0RLZzlmNE1HM0tJZjExTFJDSUpiZDJmVzI5UGRTOTgxdnFuLzZQR1J3S2tGWWp3NmlmMGJQQVQ3ZlYzOTJkcGNjanJ5SW5yOE8xMXJzTGRBZmlLSzlYUVpwTjM3WllOM2phb0NVdVdiMlpoVWpSank3eXpUSlNvRFNNUng2R0RXS3VJSUlkMEdRMXhIQmh5N054c29MRVFXa3F5c3gxRGd4ODZncDArZXVDaWVwNUwyVXFnWEUwWU03VVpJMUV0QnhRN1JiTnFpUUJrQlpJczZ6cWk4M3pNakVjeVJQRkZ4dVpNa29uRXpVS1NDREYvYkZHZ2R3dDFvWE5Uc0VJWnEzTjMvR21nWWtjRlFRTmt2dTgzQUlkcnducXkvMk5Edm85Wld3aVBCVVVEN0N1QjZLaFBERmJnUFU4TDRsSDZKWEhmSjBWUm83d3ZUK2xvQis2Y1ZDZzc4Z3pmcEQ0dTVXWGVwbk85a2VXVkxIb0t4UXplTVlnRFVNZXB2WlBRRXgzZU9NL3BHUTF1MFVhdldHQm5SVVpiY3FRbzdJeXZFZzZhR3E5NTJwVU1ER3ZxamNTY0c0dm9Lb1Zyak9kMUlpeEN5d1NTS2xxWmtDVjBiZ3YxUXY5ZDZKT1dwK0JPaDNuQTJ1dERucjRVaUo2dHhHUmg4RzRVWUtjQ2o3c0JuTytuUUVKcWNwZHpoN2lydU5keXY4VGREZmhpMmVQQk5rUFFKTnRkUG9SQkhDNzJPMFpNRXFGanBTbk5BVUZnbkJSeXg0aENvU1RITHRwVmc1U2QrZjY3VkdQZHVVbm1yTlJKUk9odjgwOU8rdCtHcVpNcDYxTmRrVTc2MUJ5ejNpUXRMVE9yaldzekdYM1BkS1kyZHVMUW11ODl3VWJqRDdyWlk3VnR2V3hTa0lveFNsaXNZTkNpaVZoUmFuL0hJMUd1TUh2T3p4TWxQSDFaTUhqSmJGZ2hFODNFVkdwMU5RY3YxYjM1cWFsRVl1clhhSDVuM25kOHJ5eVU3L3JXTjRRWjBtaENXOHNsQUdpV2w3MzY2Mjg1WS9ZNG1kL3l1anVJMWY1TE9CMGNzNzFyRnUzWFYrNTQzWmIyWDQ3YlkxVXlEOGVEZDd5dTQxZTNTbFlBdnlmZ2V3NDN4MjNsZG52dDVMcitLbDFGRDhtSDg5UUZMb3pyZnhJaWI5Y21teVdVVFRuOFhEdUhsdXhrQTQ3dGcyZ1ZIejFFY21lQUQxaUQxQ0hFejZyZkgvTDdiMmVuWTMxWFpHVTJ2NGJ2dzZHOWtZNENlY0JYVDBmVGhFdEhhL2hJNTdmaXZXQitCK3ZRdm5XUDMrQk4zT3ZSNzZCZjFkdFJYM1N1Uytla2NQM1A1ODlSSG9tSDBOb2ZEM3U2S1hMdkx5aUI0bk9NM3YxaUE4a1REMFNxdlRpSEQrR0J2SzJiZktDWHVTSUo3ZE40UldoZUw3M1M4YjFFSXRxZTYzbGN6bzE2dzV2bXFQL05HZXFyOFJ3WDVTYTRaZTVLNEpydjRSN2dQc1Q5QnNlWmZkNWk3cHdXZW1ZWEhqK3l6ZjRjK0dTZnB3ZkxIRng1SFZ3VEVNNEIyK3FnMnY2VUMrRDc4SHdmZzdXQW1lVGJwN3hablVjd3M1M3BBZmZ5YnJLWCttcTMxM2IwK205ZEVoN0hpMVY2M2M2dDRzWGo3bTJ5UVUrZHZQWVRuZWZvNVUrOVlHK3ZlN3VDdE02cnEzemRmdEk0azg3ZGVXNkoyd2NqL0JyYVk1elo2WlJxOHp4VFFxZFRpa28zSlhWVDlwQzg1Z0NXV0pPRVF6QUlWeW5RV2l1MHZibVY3aFdlMXRpcHhlNjFOOWdiYmk3SnNmTjl2NkE5eFo5QU1EOURZZmI0aUdQN2liUGVQdEhyYkE3NHVBNC9Ld0J1OEFGV01EbWJTd0Z1S0FMOEpnRkRWSUYyTGFHZjNIeTQrckwrUlRRdEF2UWpGVWxwK0plTXBDTDRwMFZTbUJFaHErM1ZsL08vWis5d2o0dmJPREpnNDZpYzQ1cjh3Vm1kSkZtYUhPZzU1NjBOVFRLZmpUTWdLNzFJNlZZRGNNWkZNUHI2S0ZlajZWREhJMkE0WTNhekRNd3FzSnl5WXVObGpQb2tLWGd0Z3pEY2NKckFpOW9LeWtpMi9OTWVpWHNoRVVyNTR4VlZDUVdTY1g4cWxIQnVxemEySkRHenBHdEdJR01Ia3FIRVZMUDZtbURHc2pLKzV6TStYOGJxSTRLM0ovT0JSR0p1Ni96OGxyRkVJcEJQamlkOWdUTE5uR3JNejA4WGFhYmo5Nlhmb2kwdjY2VnlNYTZOQS9PbUwzT3VEdTlCOGpVWUs3UFF3b1BjTVlBNWRhdWlnazBSbXVkS3E4MTU0S3NkWks1M0FxVW1OTlhFNWluTXRRbitPUTEybTNsSWVaUUNybWNhZjQ4ZGJzYiszMzJMTy9aWlJCQTFUZUxGWFdKQUFnbFJqZXc3ZW1EZm44WFVYM3cxSXVXaXhWeCtzaHpMOFdwNSsxWHB5bGdTT0U4cjZhU08zdXpMYUxZbS9SSVF6dDFBTzVrbkdua3daNnVoRDgyM0xsNElTUUlJdWdIcGtNVERQMVVQTEpUeUN4OEtOZHEvWW90MktGT1lpaVlNbTF5Y210eHBwa09HWGQ5aXhiUFI1WXMwMFovM3AvODdscmw3ZHBYNW5nSE4rTjhnei84TWNKRWZabFFjc05FNDBJNFpPaFk0NFBnTVBzc3Y4MlZnWUJ5QUE0SUNteThyOEhOQWdpbkJOWUFDTTdMRVJ0akFmUnVFSFlkOGVuWjE5YVo4L2laNi9NSDR2c3dqVzJ1WDdWalk1ZDgxdDFQZFVqdXd0UGhJUE5YKzQ0WGR5cFJkM2FOUFhUMitKLzFJbys3NzNzR2x4aVB4SkU5ZVA5ZDVHNDd0SjBncS9zamkwdmlPU1hYbnhWdDh1K1lmOWRlMlBwTFpWNWpTOTFUdEtXWDN3cjE4TXY1SVkrbmc5M3oxeGlQcFBlTVV6NjREbnYxUDNCUzNoN3VZdXhSa1lPYVhkQjEzSS9WTGowTHZVOGRSR0FIQTV5dFdkSXlIY1ZGbmVpVVFvMUM4Z245V3pBSVJDLzRWK3lmaUpKSHNwbU0zaXlCek9jMmlEVWtGL2pzS0NKUktzNTYzMEhxUlh3MGFkd28zNkpramwzLzF3SlZaL1ViK1RpTk1CSDkwYk12aVJiK3piM0VpYS9rRThybkxkdSsrTEpLZ1JPS0VLRXBDdlAwL1pxZTJ0TFpjMlpxYW5kL3BqUDljR0NkWjhlT1RrNVAzaU5sbWV5TzNjV2N3TGsyUE82TCsxc1BUVzdaTUgzNnJManJqMDNMY2VGQzN4ck1UOFd3MlBwRWR0M1JlV0hweFAveHQ5QkJxYTJwcWl6bUJ4MWdPL2g1STE1T1RreFdqbnY3cXRkZHUyK2J5czk4RmZMc0dYTVMxM0MwQXF6emF1SUVRSmNPdlh6MDdRNWpHcE44VDFPNXlEMGhqbXQwcjE4cU04ZytBVEpSeVErcFk5T2JKVDlxdnNzTitTelQ0SUs2NnFNSzE3R1NNaDdWQ05MdUZoYmdJQnltL0hnb1JMaFNpeVdBWTc3U2YwdUxhdE1LVHNYTHlESmNzazlYMXg4TzI0WXZNaEdrcFVCbzlCU1FsSE4yU2ZaeEZYTEJLeGhRV201RGdCK2NwbzJTeE1Bd2ZWbmxsV292L1U3SmNUclk2UGltNGxsUUVXbk9ZdTczanMwOFBUV1pBVldjc1ZkbHBWbDByUVlrdWFqZTdzSUZVdVVSMVVPV2Q3SUFXeXFqbFI2TmxwOWhraXFnZ2ZWaVJtV1V6djJyb2FqcjZIeU9QS0ZvdXB5blhtWEh4bmRHMHFodS9XTk9VbThUanlEbitxdnB4UlNPZmZraU8rcXlFVkZnMEUzeVlqNGR1dHhLeTJRakY1S2tWa0QyazIwV0poR1h4NWlraSs0U0hlSW1vcDNRalJCZEI1MWFCN3pUNFVEb2FNcjZ5UVMzTE52REdSMzdzOCtXajcwMlpUNFppK2VobDBVejRIb0NQK0tTb2ZCN09QNVowdHQ0SHNGa0JMTkwxSGJDS1hsZjdmajk2ciswc1A4Y2ExYWJ1TXp6WHBzNDFQRWZiaCswR1VZL1ZUVk82dGNJNjZxem1ITlVYZTc2L0E2VFlHMENDZlJ2M0NQZnJGMW9iYVlBbmJ2NDdYNSt6OWUzdElrKzk4dUhRZXRuSmM4RHliMDdpY3kvMzRPb2ZCL3ZqLzNCUHZMS1FmWVVBUi9ISUFHeGVZYmk4MUhhL2hCWjJkQjlNbmpHNXJVQm51WktkNzZnYzdJNk9xTlREbERaMUxDOFdIT1pJanVyTXZJc3JxUjlBTVc4eVhFb08yTzAvd3lvY3RHK2xMVGxFa2VCcjZ6d1JaVUdVeGZhbk9xbGQ1QkJ0SFczMm56eHpQMVMvMWNGZTJKam5XUk11RVRVQmVDYnlmWGErRGxzWGdRYWY0YURsMkJaMUpCNzUveGtXK1QrQk5mNGRVUVdDbVNvdCtCYklkQkdRNU1hQjY2eUQ5R0hSc1ZBRTVxbm9tb1BZSGExaWs3SGFCVmxDd3dibXNrVFhINm81SHVoL3JzMHg1NjNjNHFGRitPWEt0VEw4eUVaN3c5Q2ZxTUIxY20yRG5QeUpJcDFjV1NHb1kzeHpCWjlickNUeHVmSzIxc082Z1JjcmRQM0V0ZFZJQUQ5Y0JibnlNdlJuSjhWTm9iNmF3ejFRYmVRdDY2aG5jK2pDSklzc29ualN0aWROVmdHNkhaL1NhSHBIeUN4ZnF5bG51STVUNllxdXp1UUM1a2Jma3R3cU81R1ZVTThzS1piVnN1WW5rMlYzMllTdXcvd3ZMU1RhLzJJR1FodHVUdzQ5TUZud1dYNFh6T01rbDRmMlhvTlJXOHFVRTNib2dxcmhhbjRYR3ZXcUF3SlB2UnFWSmFlQllTbm9NZ1d3L2QwWVhJWnJ4eTFIYlpkWFpPdXlkS0VET0o0VFBsVk4rOE44VGxYOFNqWmxuWUFlV0J3L0VqQmJKZ251VVFWL0NQTFY0bzZ5YkNaTk9kK01QQ0Rvd0JXTGZKR2UyeHZGcFVJb2tKVkoreHZocmJtb2tzNVdkcWJWaFVMYTlHZWROSEpzdVpZWkNKalNrcEVQQlAxbXVyRGc3SjJXUVZveXpZQ3V5c1hVUFFLMTZtcG42Wms4WGxncVhqcFp5TW9xVVZNNXpyVlJZVEhmdG5EekZLOE5heWUvQ1RRd1JsM2dOUE1NZnQxVmFXeTlURDdYMTdieWpxSUhCaWVzMUFZQzRUZmFhd0NockQ5Y1dMcUl0bFJWcnhqU2pPbTlqcmZOYWVjNE5yb1ZWYktGeVVzQlJHNmpGTlR6b3h4OEJuRGIvWUNsOXdObU84TGRpWHBxNktjZVlyRTdHa0hLZkphTHZiWFRLdnJHRzlUL1ltR1pueUVTVzRTM0ZSYmVvVmxFQ2JCWVE4Ylh4cFgwQmtaWFE5NTJGbEY4REZmaWVTNlRPQ0pwZTVITFhwcDRXSkdPNE9CYnpLVXlyS1pUKzN3MVZYcE5JSllvYk51M1ZPU0xTKzBiWUlaV29wRTlzcWEvemplLzYvQjhNTHkvRXJlc2o3eWwxQ0FrSEtyejZEek84L1dJV1ZsTXpSRE8vNUFiU0EwUUFreU82VUJ4RzhDdnNVVTVGWTNVTXZDUlBGeVBiOEMwVjI5U3crbnhsWXNESlN0VERZOXQ4UFZ5ckd4Y2lTdlJVT2dSWmJHU21rNjROQUg0Zm81OEFxUklwQWMzYzYvaDd1RGV6RDBBMEhPeHZldTY1blZpNjVnZ2VFTUx1ZTdubnNoMDhJOTBiQnFyVFdwSmhGWU5xSVpvb2l4UmhRNnBOcEhxMUtzb2ljN2plaDkreDZhaWFCVndDRmtIZE8rNk91RVI4TDhtR1JIRmw0NnVSTlBVY1oybWZFckVrTFQyaHFZQVZsak5HWkZWWFE0SEpaMnN0RnJ3eThHUjZGSXdMT3Vya1hmaUl4clpyeHNWcENZVmRqVDBYRG95Vm81UDFHaW93QWV4SHgrazRRSnJFL0h5V0NUZC9oRjJhT2pqb2gwOE1sdUtqZWNpWS9sY2JuMjFsZnZrTy9OamtkeDRyRFI3SkdqL0FUd1RvdWFlRk0rdUE1NWQ1d3d1QTNMNmJ1NjEzSytpRG9vdHRNUFVRZFJmUGVzbGdJaDZnckgvQ0g0MGUxUHlORHlOSzhJdjlBbjAzU3NZc25WWDlvZC9CZFlobTYvY3lGdldTc0FVUVh5VzlWams3cUhKUWk2M0F2OXkwVFJaVDR2dFZTa01vaWFNUjUvaXp3VVVId3F0cWdoWGdaeWZYb1VWTVN4cnFpL2J2YW5wcWg5dmFtTG54VEdmNnFKeXNnSnpYcFlDc2hZc2xhMVI2YlZUOUM4ZFBYMDZtdDdZTHhpQ0tBcXlKc3F5Q0l4Q0x3MThrd2hpZGtVVnBNNlZNdkNVSktndFpnR05zdStYeWYzUVR3cGd3d1Z1aWVQc21FRndxUlNtT3FyT3FQVmJjYjRJT0orYTJBQmx0QlE1aTRHQzZzU1JNZUJJZzNTMFpYL0pTMzYvc0Nka0N3ci9Ca0ZYZWVFK1VjNUo0c1dLcnN3MWVkbnY1eThoeXE4STRudUlLTFMvRzdidGdtMXZrZjJTSlAvbXpHZWdkcDhVZVZrWG41VEVnNi9CVVhoZDQ0OS9TL1pENWYvbVY5cVBmMHZnL3hhWWw1L2pPd1c3WTFQY0FscWU0eWE1QmxDMVpaaTNYcXdYN2kxc3NIdFZIQnFNV1pVbkdSbVB5ajlMcGxLeDdPeW5lc0UyZjN0TEl1YzQzN3lyRkExRnBzYmYvT2xJL3VSYkoydnB2ekFXZGpiOFlSWTZacFdlZEdQbndlMWZEdWpqZG1ubUJmV0x0UzNaYVk3SGVEbGtEOEEweHMxUnIwSnFTSzRJY2xjejRMb1ZNajkzR2t5cDBUU3BZMkd6VWY0RFZlY0x0MnVhK0xnVTF2ajUxeW82aWVyeUc5OW9wb0I1eTFpdHNweXhBekhsY1UxSlJwWmpTb2FzQlpTM2h0VDJpNnBmL1pLdW5wYlZYQ0p5T2piMnFGMEsrRWtvV0lnZGlaWHBlbkNiMmpBOEIxeFpnOW85WHMvZHpwM2tIZ0o4eDRnNnBRdll1YmlxVzNPb0ZWOVRpVEZqQk5Sc09EUEFGL0VBeGRnWWFkcE5odUVZL3ZPeVF6YXpXSEF0a2xHQnlzSkNPallMRGttRFE2RjZDTkVwdGU1Q1VrSitjN0dzSi9Wd0t0TzhjU3ZQTDY3Y2M5T2lHdGIxOHVMRmhFaThNSHQ0cnBTZlgrTEovTUhaY0ZDUHlObmp2NlJJY2V3d09HeUhJUVkvU1JURG9xYmlZYitnNkVKWVZIVHhxbTZxL1FPQVdoa0l5R0lGNXQxYjRJTjZXRzNjME56MjZtMkxLNHVaVkJncVVGNzhFQzlHdEZBWVBtakVybXZNSHBnUmdIYU1IVWY3WFBoSXMvTkpaVTdVNEVNcUhpeEJWK0FUdWlKV3U2bmJGSzJjeEhsV1dVU2tLTHQ4eDNOMGZXQWJ0d3k4eHlHNjh0a1h3OFFla0FqTWFzODczdXQ2b01qUlVqNmNGeHBzbkZ1a2pHcy93TDZTVzU3QUN1TEJQZUZobDBEdG1qOUdsMzJQQVRsUmhQYlhTYTY5c1dLbFFpRjA1WmVrOXBmc1JNSW1ubEFKdGE2aGMvdG45QXd2citSbkRiMTlTdkVMZ2ZKaHN0SStGU0s0eUhraWx3TzJ4N1haV0NlNHhxdGo5QmxtbTlTMGNkSFc2ZHIxazBOb0M3UU8ySFJ0amRrQlVjZnF1Uk1uQ0tDMzl1SU5ONURIWFNjTmlkcDl2ZWo2bHhWZ3J0Y0dWek84dm50QzE0eVByWFV2TkxyS2ZNL2F4UjdYbmdzT3Y4Yk1BNDR6ODRNUXUrcGJwWmh6bjRRRFdXU1A1ZGhqVlhZRmZmdHZaNTRsZjAvdFRuZHdoN20zYzZlNFQzVTRTMnJrZzBUTG9kWkNNcEtubU5KWmVFQ2p1aXJjRmxoV3NmUDRRc3dzemhCWFpWMWxDbXRnTXMranBNNDNaOG41RmZtM29pcnBma2xGNHkwZkx4QitZdHNFQ09DOGptbFZET2dTMEsrUUpUMG1XdUhMNFJsNGNndXZ3b3drSko2TmgrNEtCVlNNSjZhS2MxQ1F6NVFVZi91ZitvcHkwNnJreDZMME1DdEs3M3cyY0I1bHFvR0h3eEZmMVBhYkVaOWZ6V3BCSXpjNW1UT0NXbGIxK3lLbTM0NzZJbUhuYmtmVnluZVRpTzVUakVRb2xEQVVuMjdGNCsxamhadkdyRkxNWjBZaXBpOVdzc1p1SXFGUnhaaWh5aHNjVlhYZVVBbVo5SVBoVnc4dnp2TDNpdU02ODV0ZmhmbHR3eWhGNmJMRlhjVldwRkMweEloN1RMcGNwdDdaSlpqWFk5UWlzZWdzVTh0eWs3SitNRmJ0cW5kQU53ZWlpakhueEg4c1NJbFErNDlEQ1drQm94MmRxaDJybGZlMGYvYUlyUEpwYmN1bHFmd2Y4cXI4eUY4WWl2YXZ5Wm5LYTJtMDM2TjRpQW15c0crTVYzaVQ1NXR3dXBIbnlkSXR3VWdrK0xpaXRuOGFUVU5KMHdjYXI1ZWxxd3JaeHlSNURWbkxGNmR2dVNycEZnQ0g3L0Q4UldNOGxDQUxUUjVLVUhoM3paSFJGNHZMY2hYZ0pvYTBIUTBDcEJyVGpWdG1kNFVBV1dJRUJ5Q0dkcld2WVdnMWtTTUwySmdYbVFVaVdUK05yVndnUkhuY1UyMTRWbFZWZ1g5Y2twOW8veFJ4eDQ5eVQ4alM0enl1eXlydTJ2dzZZSkFzaldBNkR4aDREN1g1N3pqdUZQc3RUSlNxNVNnQy9LOFhxMWJUcmxldGZJWjRyaWI0T2t2eEowNUJ4VURXcGtFSGVKVE5mNitGREdNTzJPOVc2d3pIRW9mYUwvS3Q5b3VISUxseG1rYUs5bW9DY3N1NlRySndXSDVkTFBhNjlWd250YkdCUjJaL1NHbEhFVWJWSTlUUEJLQnFZelFVZEZkV092RWJuUmtxbktHeFlNeFd1am90aDFwUUwrR0l5aERLQWluTHBDc1MyaTZGb2FHYTBVQ1J1UTdqZ2cvMTJHY1dIbFRLdGJvdWNSWjBXb2R5L1Z3bHZKQk9DenhSaVN3c0xBZ3kyWlR6N29JWk9NTUZ6SEF3UFovKzNmUmNPajJlcThaVDVlUllOR05IQkZFU3N4UEt0Yk5GUWZEQnNFb1c3b2tsYzF1eXY1dWQxQ1NmRXNjRnJqamg2TGx3dFNISXZHSEFZd1o4SUpHQVQyM0tDZWN1UVZsNjVlWnJyOHZNWmVBM3BjMW1LdnRGZTNzK1hreVYwd0pkTUJPbngwSWhuQXgrbm8rUmNIbHNjbkpzMzhXVnJRV0ZyYWUxWERzRlAvWEJlUVBJMlAweGNKR0NYOE85bW5zZGVtakxiSzI0UzI2NmxNamVaR0wrTW0rMVhDTEV6TWNWUm9zKzVGNzFaZjd6c015Qko5bHBuZDM3ZFZmN2RJaDk0aWwydWZZU2NsMTFGcFV4MXFtY1hRVGF1QXVvSTV0MTU0Z3kyK3dYdXowenN3Unk4eUJEUkk0TkRSZDc3d21xMVR6UnRXSnVmMnQxbGZTRmdWc2JIZ0YyYlQvS3h2dTlOc3V0bHRkcW1mSWxUSCtBbG5yek1CNTJEc2JQSFZGckt1QjNXcHVIZktjYkE1cWNQbHVOMTZnbVlPME0xMnF0czlxVEZTYkRlK3VaeTdGNm5tSzNjaTBhcE9aRU4wNExYZjhOZ25TU283SGtCeXpySkp6UUhnRG42L0FQSWV3MUJtOXYxNVM1RmxudllPVDJHamtFNTc3d1BIT0sxbXBUVEVkQ3VWYlAzL1paZmc3dzJDNXVQOGdmT0JLYURlck1WblRkUFlwT21UcUlXY1dDRzZ6Q1JwdDlJSHNzSWpSNjJLRmc0b2ExS0plZ2JzVmF3K3pDdllCUnQvSlVNWlZyRldtcytBclZ0bTJad2hqdmsxVDBiV1czNHAzRitLN3gzUGl1K0NMZTJackZXKzEvclN5dUx6WXB0K3ZzZGtqTDJmM1VtMm1rK1NKVFowM2lpMU52aHFFZGIweHZ3eHZOZURvZGIyTDJ0dWxHSEc2OHVGaXBMTGIzL3hpWjV4OURJVTg4QVllT3ptbWR4dEwyMmovZXc5MlBHdkwrT1BITkFhczhaZUM2ZW9IM2JWZTUzaFVoQUpNNzRYeTQyblhPWHFmN1F0RER5VTVDZWFpYmVzdFo4OTdkYm9INGJPZ0VCaWdJMGEzMitpcTlRYTdxUHFMMHlsL3BKYytSK1o5UkpDZlA0MGh1THlvS0RMWFdWWGpyS2hldm9GNjdBWGo0TUhjZGpHVWs1akwxZFhEYlRzMjcwZmNIUmV3R0JsM0dZNW1hT2RrSUdCeENoR284a0VldW9obUVIWFBxYkJJVXloTHl6blhrbC9tY0dkaXg1OWd4T3I3RGdpS2hyMCtnRUlsUDZMS2lXN29vOFlxa2FFZVA3ZDRSTUFHWHRqK2o1Y1lEaWw5VWhFc1ZRUXNFOUk5cXlsTXdNY25HNHJhTDRXK3BTYmkxZ0ZuUFRWSTlYcjVrVlN4RkRoZ0oyMmNyQVoraVdhcVlrTWlXWE4wTXJBRjZiYmNqaGhLd3l0RjhOamltMjFIakUxU2I5NDZwZEVGN2wxYklUTHF5VW0rdmlETHdvTnZQdWx2RTZEc2RVa080WG1TTkpZLzhsRy9tY3MzZGVNaFBYRFF4Y2RFVmVKaXc4L21aZko0ODNndmU0ZGxVWXRWOUFRL3VDM0JZd1RkbThxNlBCVUgrMmVEeTZEdHFVayt2amphaUxOU29zUnFxYktoZUFkZ1YzRHRpbGxudm8rclF2YjErdE5hWXYvckUxZk9OK3VjQzl0YXRkc0RKeTdyUEorYWRiOGozU2RKOThzVHVTcU5SMlUzV0x6OThaTnZ5U3FPeHNyenR5T0gybjV1WitWWnJQbU9PTHlpRThNcUNhSm1YM1M5Sjc3elV0Qll1MjNhc1hxdlZqMjI3ckRPUGVRTDhKUElEbDhFc3ZwcTdHYmlBZXoxOFFEZitmYk96UnFwMHAzaXhtM0pEQkxKWlQ5dkF0Sm5NeG9RaTN4a2Vlc1lzdWlRRGNqcEpORVZpaUh1TlVlQU5Sc1B2TVhRMVl0amh1YkM5U285R2hLMGVWdkpiWjFabXR1WXJjTmx1TWRORnNYN1ZMVmZWcjI5UnFrYzRkczYxVjVsdTByV2ROMW41VDhEa1BoVk1TS213YllmamNUeW1wRVR3RkNWTHFWSWk2bE5WWHpSUlNobDNyK1lpbVhBNDAzNC9ZOTN3ZU5rSkpFU2NyNnNmUUJ2M0lvelJQZjAyelpzb0VxV01pTDBJbzBqaHFDd01ZRXY3SE5mS0svdzgwMTh3ZXB0dS96bXlCTzExalRnb0J3RG44ODJoV00yVFhIOXBEMUFsU1pjTUExZHdDTWh1RzRncm1VTlNTNktiRWFqbjhKcGhOeDd1SEliZDVUalhaNVBTckNJM0RmUHlZaGpydDNGdjR0N05mYmlmM3huRitRenJ2OUtBMXF0Nmp1dkJTTC9ldmhqMlBEazFSeWs0QzJZNTE0MjkwWDRmam1vWTNlUTJEQXBCVnJYMkw3cXR2VzVJNmpWRFVsL3Nwc2dxQzB2T2pnTVJNT2JtNkplQS9XbS9DTHpiNkg0WlNmeDZCNWQzOC9iRHExNDY5SWY2bFowL3lDNTV0NmdMZTVsMzJNSWJxYy9XQlFEaXErOFM0R1ZkVkVWeDRWNEJUanFqVzk2MjdhT2FrNWZhT25TdjV1WHlUcjZCNjVoOUh0WG4zOGdQRjNqK2dhS2tFdWtCWHJ6YzVFVWVNa3dwS0lXbEMyanMxd3Z3NGdNU1VhWGlBN3hnOGp4ZW14SVVFblJ0SlFibTFxR1gzbTZCeGk2azI2UlFiWURkb1VUbjMraXZ4S0RCTXNHSU5RcWMxYWxRUEFTL0MyZ3c0VlRwUGtsV3hQc2tkZDJQTDRlR2pOMkxYMGJ2dnVTWmZyeXJGNytBOXF4dWl2WGRhWWZMYzNvc29Od0lmQjFhN2xZUmVzVWI3c2g3eC9zTU5YNWhzYVd3blN5S0RQRFVlK20zNmVKNk43bmFxZkpBMDlzckdGS1NOYmREd1U5dWVodVQzK3cxdVI4VTJIcXQvUkhXZUkwYjBuZlh2WXkrMnhROGZuTzQvUFB2enhPQ0lJdWFPRGNIR0VnV2hMazV1QWE4MHIyK2dGNWU4UlF4ck1pdUQ3QUhEaThaQ3VmZndndG9BZWZSUjZDdllvbnVaOGlWK29LNmR6VktMTTVDdWVoR1VHaGlYSXIrTUZGTGFBSGxybElPdEdrU3RZeUU4MGdBNDdYYS9scHRyeGxBMFpxdXI5MGk4N0c3YU9nbHFtaTVLOHFyMGdNUEJPT3kvMWhYaVJBOVpralJTazhvT0kyRjdLOGRDNWhRQUYwNSs2RzB4RlNyVE9uU0VPVmMyTWg3ZFIxbHY0RjlvM2owR21sb2U1MjdoRHVDOXUxbXZaOW5rTHd4SDUydXltNEFIcVYrUU5BU3BPcUN1elNuMkFQUnluSTlDemh5ekNQa3NQYmM1d0VMeVhYNHQ0Y0xSaHhYdWpaZVZGVk5PYTFLLytoVlNwRjNkWXoxeE85dmd2TjREMENkYVF5UW1EYlQ0NEtwYVBLbEZPd1VhRjE5enllNE9MZkE3ZVQyb3pSNHdYMHREQjFFWk8vNTl2SGhUVTBncStmVHMrMkhOdzBPcmpQT0oyanNKL1NQWlhwOFhCRnpZenowbkk5M29JWWMxLzRKTXo2c05jeU9lWTJKamo0S2FnSk1adTlneC9qdzYwUFY3Y214b0w1VXp0YXkyZHIyV3ZaRXNMYVVyTVRiKy9PemE3TjVQRHljM1JtYWU4OWNLSnordnJxMUZaNTl6Mno0dzg4bHM4RklmbndHM3RxZ2IyWS8rcFZVSm1oZlE4S3orUk1uOHJQdDFkbjhvVVA1V1hKcjJFeGZjZWpLZEN2VS9rRXVIODVjZWZES05GdWI1emllSjZzZ0hjVzVvekJ5NytaV3VWUGNSMUdlVk54bDlvVllpYW5obDZqV29vbjVxTStQRHBNcktSVnFGanNCbGNhd2kzRVlqM1dHTTJxQmJBZHREZ3F5WWhhS0JXZStJMkdXNXVZcFNXTlh6b0JMSWJEaTdFN3Q4YUFXRlZGQUxCSXVVSFF2cmxWNUxSTUtoNmpndVU2UGNKWFJlSlZYNUp6R3kxbmRpVDhUZC9Tc3pHczVXV25mcU1LMDBOU0VIRGVlTWVLeWFrVFNJaE5HVzJLYXVSL090VGVTWlVNbkozU2p2UEtvYk9pUU9PVVRlQkJKaThWaWdLV094ZFZBMlZxMFF4TTk2WFFpWkM5YTVZQWFsM1UxdE50S0pLemRJVlVISWxNUEJJT0I5czhKOWN4SkVDcWtQbDlPTHFLWXZKZ3NING9ZUm9RYjNPTWhqZnZNakk1d0d5Uk8zUnZiYXRTdUR2ZXRyQmdSYlVWUDZpdGF4QmkxaWNmS1NzN0VKL0JCa3h0ZWw3TkZzRzFXdlRIQzZxTjI3T2o3elBEb3IvMzFIVmFQczBXblZZcmUyR1RXaUIwNUxyd2F3K3B4dHNpenR1V05RelpxcDVYK2o0ellhS08vYTFoTTAxMGtUK09TVU8yRk45SjlIdjNxdmNIS0NVZHkzbWprM1JpdDNEcTVtWlhSRFBkSG5nK3ZlMTlva2I3eXpuQnVYTlhlK3hndjNoc0ZQdXg5bmJRRzZ6TVl2NzJBZGt2bmlpbXplYlNQak9hLzBqL2dSd2Z4SHpybUIrcDFydmo5bTBmKzZJajlmZDhiR2FwL1pmUDRINmpUdWVMemI1b0ZJNFBWOTlWb2RDaitsU0Z6WWFCTzU0cS92MmxHakl5NDMvK3gwWUgyQjNxdk15OXk3cGpPOTBmNXorY0doL0ZLLzZ5Z3NqRy9tNnk3YTYyN3FYOXYzaVZaVEwxdnl2MmJUdGFvd1lHVFgyQWhxVHI4WFc5L1NialhGOTYvSzM3eGxmWTFLaC9RNk9MQ3dZdkNwVVpKKzZBR1J4TXkyMy90SjY5U0EveWtFR3ovWVorcU5kSCt3amo1OEFkcmdpN1VKRmt0VXBhK3FNcGtkVXJ6TVV2QjkwWnFwVklxSEF5R1U2VlN3MVQxbGs4OTdZdTBWMWtKMDZ5ODlmV1ROUUhLQ0RKZVB6aXMvYmRlWVB1RnpnYlp4VTZpQlBlWTQ2SzM3ZTZDdmtlRVBWOW9ISGRYbVYyanFTcUZSdnQvS2RJNGJmczR2dDVObmdkTVhEMDIrNjJ1MzdLcERFeFNmTmMrODJYZ2w3NENVdmdEYnNReUd0K0hicW81Zy90YnVrZTZsNnhpa0ZqM0tOT3ROYWtGcTN1TW9aRXJsb0NCbCtSWm9uUk5LdURnMmxRNDFMb0NiV0ticm5rRlBiZzJHR2hHOVdJNGJBZ3gwMWFrY05HTXlWTE9NVUlodzhsSmNzd3NoaVhGTm1PQ2NSN1B6RFJEUXRqZk1JUzQ1amhhWERBYS9yQVFhdnBsZFdKQ2xmMW52ZnRVcDdSb3dmdEZYRU9Wd3NDMmViNG8yZXlacU5YL2pDM0JNOVBuOGRGZ2c5N1ZGSDhqNkwzcnlzcHVYSWNvbCtQSzBFUDlSb3dzZG02Sm1aMWFPS2FscGcwNGdmeUVXaW5HTzZGN2podzVLdnFFKzhqYXRZTGUvdUh4YTQ0dXQ1L3FtQ2U2a1ZxZmJEZXVFc1NQcmZ4WFNYamZBOWRzZmR6MVAyTGZIdWRxM0Y2UUJJZC9mOUQ1cWpSdzdaemplcUMycXg0WHExd3Z2VEkwT2RpS2k0N2dqU09kWGJ6WjRkSHU0UnVkUXo5c0c5eXVFVzJqY1JOZFJZdmkzZEVBNHdlN1BsYllGdHdQcWo0STluVXpwWSt2OEJMWmZvS1hlSU1uRDhCcCsrVkYzVFJ1Tk15TWVLT0FWbC9TWUJ1SUEzZjE0azA4djNRZklmQ2V5TCtYSjlzdkg5ZVRVZE1RSmJRMUU2aWQzSDhsUHdPODVnTzZnTEUrRmdDM2NjVENNRE16UE1pWGFOWllSTXR5dEhVRUNxWUFla1BZRjlFcmgyNTAyd1JNVjhJMVM4QjZZeGpEQVIwdXVHOUlpckR0eGtWSnpXMC9wbjljL1ZWUkZ4TVpYcEdhaDk2Zy9wTXFiYnQ1c1R6K3h1VTlOVkZvLy9hV1M2ZUkrSjdwWnUyR2RKWTgvUTFWV3J4eG02Q2s5R1BiVzc4cWlwbUxTNUo2NHREVXE2QkljY2N0Uy9zV2F3MVZtNEVDZjNYMmlycjZSeEl2dmpmUEMzTlRNLzB4b2hJWWpaaU10RTAxaCtyZFBaem9uaDZYZVNXR0pPMFB3VFpvbE5waFdvbjVlVkc4R2xYcWduRFJiN2dxZFUvTWJlUUphcHM1T21XQVM1R2NJWmFHZlZ5ZEozSTVXY2FLL2NZK1dqRUJBN2Q5UWVqbjdQcGlnTDlhRmNWUFhzUmFjMVFVUDkvWm81SjhtZHlPKzBwcTN1ODJYVDZKZkJ6bVBGQld2eUM4Q2NQQVRnbVExTWt0N1I4ZEYwVWZmUEpOSW1icWtIWjV4V2NKeGx3OXlMMmVleFAzRHVBNVhLZjlzbWRQSi9UYm1xOWh4Sk91K1p0QnJIbTBidXZ0b29ST1B2U2l6OUhIRVZpVVNIaTBHOHMyRnNWWUkxYXhqamEyZGhXTEtUYnNZcjFacjFyMmp4UXBwQWw4REtkSExLYUsweWxGODZzVjFhOHBxV2xSamJFYnZLQ0ZKTVdVRk9sSDhQK0xmdCtZTG10KzN6UVBNMGppU3o2ZmJBamJCVVAyRmJienZIYlVlTnQ2L0ZROG1aU1VWQ3Fjb0ZNdzZrc0UvT05IUXNRWDlQdURQajU0Wk53ZlNQaWk5R1k4a2tvcFV0SVE1UVorcmlHTFJMTFNpWktxUjZibzdPWkxDVWVYUkxKbEN4RWwvY1pFT0pXYWVoOFZuMTJZdG1nODU5M2NBZTVHbFBVUVVsVUtSM1IxV3U0WkNOS0lNYzBlYUhESnV3c2NhbHpJb09kMG5BWmc4SmtEUVhEMFVDRHpUQ1lRR3NzNnVqOGRuWXVtL2JxVEhmdlJ6UXdhMTFpNlg0bHE5K21tNHRkajBXMFJ2NVc4a29iVGtuVmRmbXVieGd3bHVHcDJxbXlaNnJadHFtbVY2N3QyRnVXWUh3ZW1QeVlYZCs3YWV6TnIrRFZWSnhhVFJRa05GQ1ZSanNVcXRabUxvb25MbWVWYXU5V24rNDkyWTBDZUsxWVJSaVZCbXdDUUMvSmhJUi9PazJKOWliZUs2UERsUUJJaGdpYWtKVHl6V3c3NmhPR2VhSjFzTisyNHZtTDRuK2R5N1JiYVdxRlphV3ZWL2EyMjJ1dXQ5VTRXL3NFMXB0WTd6OEFyUUMvYU9UaXZ0SHAvcTYxUkY2MXVITHBWdWpxUE5vNTMwQjNpUDBDMTN0M0oxTFhkSy9ibmRHeVBPaW9qWVdEZjFueS9xVW1IT2UrUGltdzNoejdsREt6RTg4ZnVvMDQ3KzZuL3pvKzd5VnR3QVBOemNOUWs0UmMwVEJlUG9iME9iVkpHK2tXeEFsaEdGa1VIY01xL2JMb2Y5Y1FTYkhtY0l6eEpPL3dpZmc0TzdSL2hsMTdFd3libDVUc0JWVG1pS01QSEtxSzRmOVA5OTlINC9JdnV1dnZtUHJnVjhKcmJCNFB3SHRZblorK0Q0bERvbHM0TDV0SkFUL0hIYnVuQy9jZWUzcmh2ZUIrYzJnVGk5cGZPRHZXK0hpS3RvWDJRTzc5T09IMFdzQWY3T3FpUHBsekgzY1RkeVozMDBKUm1EK1kwdGt2ZnZvR0R4cTEwTjh2ZVpXd0VmVkdLamoxZnRSZ1ZBUVRySlNTNndKTWtKUmc1d2ZEUFUwWXlJd2d4UWNoUW5uTGVid2c1U2xHU2hCZDBEMGxaeXJWeWhlMUVVSStvQW5sN2gzcWtTMVplbzVDNzJSZE5pYnpOaTJrc0tFMlRxYWp2Wm5wVHkxbmw5QUQ5cUsyc3JPbzVhenlUR2JkeWY4VklCU2RRSDVnL29yYU5UZVJMSmF0L3lKbEtua2Ercnc5ZEkzV0ZVTFJLekNPd3FnQlUzS216dCsxRDltajd4YU5LM0hwaUcxWnpHMldqV2ZJSkt6N2RQaVZLNU1EM0R4QnBxak1pRkpMODUzODJDNHVlSjJseXNjQXI0cmUvTFNyTVo0RmdyQUlWWk96ck1GcTcyVkVhbU41TlNYZlN2UUNCQ1cwNmFMRlZhNWE3NXZRSzF0MnBOdEdwZzNIVXRGT0JCdTVFNmJLQm9iSmxGaExWZHVwRlM3SHlSeGlCK1lFc1MrMi9rbVE1S1V2UUJUNURVWldZY2VYVVpWTStTWDcrVkx5NGZmeEtTZVIxUlpiTG9oZ1NpY3FyS1o4Mm8vazJjdXM1d3BFVUVMMkFwclgvUVpRWG9SaHBVUmFOcENUN2dobkxMMW4rT3cxL01CMkc0ajdvazZWa0tmN1ErUGFpS2xxS3JONHBDMkhnSlhpeHFFbUJSZDJVVXBLcDh6ZFRyWGtuZnR5emRBOHJHeWdhbGFDYU5yWWc3N2FTQmxhalk3ZEpWM0ViTGpCd3BYTW5EUWFGbEI5L2dDVHF6VTZvQnpJd0pKS1ZVSVMwYXNkcUo4TUJEZWVkRVZHMEFDL0pKeWN2blR6REdiNWxuNUhYZVoxSXBpVE5LbkVXUjVUczl3NkxEMFo4UlhQbkJoVGkxMU4rMlFnL0dJaDlXbGUwcEtoRElldGpBVnZPQTFqM2hDVGZwTXpETExJRTlXNFd5TFQ5Vkhlb2ROcmNJdmRUYmN0ZXRLOHB1WE85TzdOWi9GUzdPNUg3WnJHTGFaMnUya1dwVW1Zd3orWXcrdFVsTEo0S1dXWnE2WXFsbEluSk9HOGxKQ1VwTTdaRi9taTZVbG1zVk5UOXZIbTMrVnRuT09qb0ZOeHY3S2JWekJ4YVdqcVVvY2xkVFNqT0VCVTJLUldSWEludkxWYWVhQzB1UGs3WFA3cjRDOGMzeGdDbU1XbnlIWiswSHJxaUxCeGo0Q3hQMHlqelpuYTZ6bWFOR2VoQUVoZEZYUTJvUHBHaXByUnBMUjVhdE13MFJVT2lEKzdvNmlJTDJPRXN5SVYzRnA2RnJ1c3lhYkljTkpPWmNZYzJpRGNxY1F3TEVLOFlQTE8rSHM4a3phQ2Y1RmdjajR1dXZ1U1N4eno5SlhWeDgvVjAvNDYzY0E5NnNMTW5iRXNUTjVWR3orK3l1MzZMVHFtTVk2WGh1Rm5Jd1BOQnp6RTBNVzBDa283WlE1QzAwTUVjTHR1Zm9qUndnWmNpSUVucmxvU0dQd1FvRmd4bUhoaHRHUmhQSXZFUmlWK2dKRE0xZ0xVL0dvTEdCNUxqZThlVEJpQnY3YWptSXUrOVlUc1Vzc09JdzdNVnU4SlVhbStSWUpZUVB1SVBDb0lZallxQ0VQVExnc1lUb3ZQU1c1aXpjaW0rWld3QWt4LzBFVjZOa21QSHlKdDhKWHNpbDYvWXBiK25DSjA4NlZydk1Eai9HN1hYakZQTDNOczI3OS9kZFUxeE9vUGZMcnJPOWtVYS85eXVOaDFJTklIemlOSDQzTXMwTXFNaTVBVWFMb2o2SXRMQS9KUW0yRFNNZXFOS252WnMrL1A3dW1GRURVTzM4L25aWE80T1ZmWEhsbU4rRlNUN1lrcTU3aWZYS2NueGJRYXdDeEpNVVl2WHhZb284SGUwTis3Z0JVaUM1S242amFnTVhTQk5xSUtTeUNVVTlJUHZjUmtiV0hqVXlER0Q1TFdRMzdMOG9YMGw0ZHZmRmtxdlVhU2N6eWdEV0tPQ0tyWFBFQ0twa0JURUNCVHF5MG1LR3JXc3FNcDE1OXd1d0NNYXRVTTRqTHZnSVBXWXgvZ3htNGpLRW1uVUhhOUZVNUJFN1NxaktaRGQ5QVJCZ01uWG9TRFB6Qm02YnJ4VFpyTkpUaXFTRk13cmhyNmhHMG8rS0VuS1gzek1xRlNBN2xjcTY1UldQRHlIUzV1ZjdlRUxBN0RLdmlONVJiOEJiOXlnSy9rait3Q2psQzYrUWFnY25vTy93eFhoK3YvZ1VnVFdKa1lQWnBuOUZxNUxLNGhNNnMzdXhrcFFlN3ZKQkJmOHIzVG55QTZNQTg3MjZUQUhNTWdoa0lQSk9BakhFMUQ5OW90US84UmNiaVUzQjN4aTZIUklFdVkrdGdqRDhGTmVqTDh4N2V5NVpQOWVaM3BDMGUvQzJ0K2xLMi9DS2grZkUyYnpTenRiMndxei9OemJGbUVBKzlzLzk2QU1haWZ5TFBWUnhCMUhIdWZXdUtlNUwzRi9qQnBraGpqY3hyaHM5QmlKZHZDQU5WK2JKZjlPckY5OXZvdGpTRlVwRHVVQW0zVXZYR1c0NlhUdk9VV1hrYkxJdjVtS0pPcFowZENmMGcweHE0dUlUeVR6NWJDUDlOQnVyZVphZkI4UGVTaWVtOHZGQ3dTZ1Q5NlBHUWZHTlVWVU5EK3dJTXAwTXk1S2U3QnY5a2hpdkRuTjBBNWxUMTRxNDhsUUZsbGN5UTJ3bnQrY3gyQ1g4MmwxYVc1dVNYMkI1dDFhVm5SZEdkaWJkRkEzMTc4L2JYZlRJbzhtYXNRcThWL2V3ellQTzM1Y3BKdmQzQ1BxSTVieFAzalMzYmJ3Rm5lN01XRnpuVWF2NGp0ZHF6alBqa0VqVnZMeFN4Z0ZzL2VsNGN2bzM5dGM5OEU5WEdmUHRxSnZiN2JkaTBXVjRjdjZIMlI3M2dtM0hIYzN3aE5HVkdyakhyYVQwUEZiV0NOd283Nk96VjBmckVhdjhEZnRUY2FGalZIOU53UUd3NWY2c1FHMCs0Nnora0gzZGZmQSsyWE9vanRlRGRQcEt0WXdYYXBEdnZRQ2xQZDFCb3l2Zm8yMWxhYS8ycmZCTExueEcyeHJPTWo2MnRmWUkzY3B2ZlFMOUVteHM5ZnNMNU0xTGtydEgvcTJpZXBzQ2NqaWVQUnZnZFVjL0lRaTZuZHYva0xxQlpidTFCR0FRT0hRcVR1cnIrQ3BCNFZKLzQ2VUhYOWlwaGtjM0FXc3lENUY2L0ZWQnVYWGU5SnVSY2pITmtNTzVLRmV0VHFnOC9ZUGhVbi90bG1kTFFIcHJtQURXNFBaMGtCcjhSdERXcnU1eHZlb1EvcUd1UFdZb0ZFd1JveUhZWjJmMlZRYUN5Mk9NT2IrbGZhMXUwZnNRS2YrVSs5RmdmVnUybHUrdTFsclh6bm1zRDZKYkNxSGJmMDZVTkNtTlliNnVhMUdoTTBHdjdqUjcwalRrZWVISUliUkJpUm51RTNvVnRpOERuSXVDNUxTVUt3NzBvcUVmclFmODQ0MEpmblRJY2gzRXd6UFpVMGlEY1hBbzh3eUNMY0pod21qRFV1R3dYdllXdEs1ckV2TVlkaDRwSVhKRUxDTU5ETVowcDdlWE51R1kzcm81QlkzRCtBck5nMXoxOGI3UDlIMWpncDNLWlJKQTJIakhrL01LWmtGazNLNU5WeUY3SW83dzR3dzNkaEh1RWxmTEVwK1BWS1BrY1VEaXlSV0w1bVg1MjNtVzJIbkx6ZFBveFZFcWZTVnF3MDlwQnM1ZXJ4YU01UDZnYU1IMEE3b05XYk1hVGFkV0trUk9mQkhkajRjenR0L2RDRFN1QnhmYXBUZWNmUUZaTFJPbk1EakMwZmhCZTNnUVhqYnhSbTROdmtGU3FsUXdNL3lGcU9YR0JEQ0RYS3A0THFxNjJlSk1mNWtrcE9rK1lNemxBaE9INXFYSkUzYWVrTnR6OTN2ZnNPZSt2VmJKWTA4b1VveTBiZGZXNk9rY3FsNjdRNmR5SklxSzhSMzBSMUxlOSt3RzhqdTl0c3U4aEdsczI5Ymg0YWZoUU1iUWF4SGNGYXVYd0w2aTJKVW9PMG9aNUZpTjREamdCMXp0NTlNNzBLNUorWkF6RktHWXVoRDF4QVFCc2sxWFdlL1R6RWg5TGM3NXN0ejFLVmtUdEdXWUlDOWNVSFUwTEZwRDZUZkRmTnNWUlJCV0xWRnNXOWhsTW1aN1VPZFNjZkNuMnZLU1ZHNGQwSEU1VnYwcm5xWHdIZ2dwZHZPSUIyVjg5eGwzQkh1THZTZFA3c0h1TE1wZ0lUNWN1QkQ0cmo1aDlCLytLd3JrclBUWDUwM3NFNzNndGF2OUpLM004aXNzQk5STHdoNlBSOE45QzIxYVlRWEdCRTBESlExMkY1aFpETzdrTmpjOWVLbVpxeXg5cEZWRlN1cURpY1JuUW9lWWpYZnpOZE9uMVV1OFNvSDNJQXZJMmJLWTRkQllqTWs1V0xjbEVJWUpaSjhhRW1RMTdCS0g2d0ptdWdYU1FkdVZDNU9BS1pZNnV3MjVRSGFqczR1UUpzaDF4eU14WEc2dlI1Tk03K1dGa3ZjQXBCYnA1QkxSMTljNlZ5UUZndjdCWm40QmszZ0crNDJTWEQzUlJwR2dxWGRlSVd1N1F2YlIveEc1R0FNUXNNNVJqSCtJOUpDbWtFWG0yTjJySGxPTTlhenZxNzhpMDRrM21wRW91VjZsSmVKVHhEamg5TTVNN3k0R0JhL09XcDd4UG5PUzZYR3BwY0VJb1o0d2dkRGtSMUZFODZpbU9EanFkbEMzREsxa0hEZnFFMFNYM1dXbHlTcXU4WTlERDdCcGJtdGREY01qdTZNaHdFT2xheXJkVWVjMzJqU1NFQzR0S3F3cUs4MElCWHVab2k0djBpM2ZiRDZ0bWp1S2pWc3hTR2g2ZjJoK043WmNIRm1zZEkrbGExbEZ5ZUlzOXVaT1RUSFQ5WXhYTWFKNGxLaE5DYkNuWVFkZjFXNlpVUjhoN1M0ZHNnWE1aaXViZVhRSWJLNlVFbk81dE9XWEIrdkxNS2pXM2JLcWdadjU2WXZud2xlTmdPcHd0SkZPOExCRU56ekZTc1BIb2ttOWYycXVsOVBSby9BeUgzei92MXVITjllbTY5K2VTMGV3UHVNYTNEYmZjR04zc3U4eDlCMDVUaHpJR08rZHhmYTd2ZDllSzhvU2lJdDVUakdSeGJGdlIvdXJsVzhZdjF0MWdlMjZIYnhvZE8wTDdUcDRpdlMzKzBuaDNYNEs5amZabjNvcnRCdXV5KzQwYTlVZjdlZkhOWGhmRi9iWDBiTEw3UnRGOXFFVHZ4SEdodGpHYmtVNWhrang0QUpacFdsQVhpcHFoaWpEeUtqM0d3d3JTdmJKSlUyWWd6NkFUcUh0Y1l1dTgxWmFEU3B1UlhkaXAxdHpBNm9tdTFDaWZZS0RmUkx6TTJGZlNGZUVxWlNjNWxGSnhNT0pubFZsS0pRN1ZzMFZZNUtvc29uZytHTXM1aVpTMDBKRWgveWhlZHlrN3ZzNFBndUo3KzFrTXhGUkVFUCtNV0VlWXVaRVAxK1haQnlVNFd0ZVdmWGVORGVSZGJLMnpJVG9pU0w5bFRLYWVocVNoREVSRDRRVG1MdzQyUTRrRStJZ3BCUzlZYVRtckl4MXU1RWRsczVWejNvU0dQYlMxQ01FUW1va2o4WUxDWVN4YURobDlWQURyNWEyajRtT1FlcjNyWFg1N2hGYmhmM0ttcjEzbG1ldy9DczdyKytWVHVEdUR0aG96MFdDelJOdWZ0U1ovWE9YZFhHTllpbWE5YUIxbGxrZFhiM2JDbE43R1NvbERic29DeW14eUZuUEUxUCthU2NNUDNKeVdodW5LU0w3VFcydWRRS25xTFI5SmY4ZEF1cmFJak1ZVkRSekpTY3lDalFkdFNaQ0IrVHBqSXNWL3FhbTB4TktuNi93QXVpckUyWDVLbnIyUVpZN2FmWitUczhMVGFja053MUZHcjdjalB3UjdqbU5FUHR6cnAyQTNLcENCSnZaN3VoM3RLVFIwMjVLcndKZVp3M0NlUW5ieEpvdXYwbk03dDNYNzk3OTB3dkZ1STY3ak5Vd1MySGdubVdPb1JQWEw5N3JoZnIwTzJQKzJtOGVJeW5zdys1TmJwNW1qT2lDK3E0bUpWMXcxTU45QURHaFhHdGFzamMySXl3bUJ0VFVzVWV6TWZUcW0veUluVkxFbmZtL0VzUHhDdnBwOXd0dzdndFkwSW1OU2RQcFFjZ0RNbDdmVnFaajQ5QlFTZjY0WHU5dXpNWXc2TnNQNEFnTnc1ampFTXZ3THE1VEtvWUhGbWdXdWN5dFlmM1lzY1MwelY1TmdHUExmeDlRdUFmSWFLUTRQRjBJQUtUL3MxdnhrVklJcEZUUEg4S1RqRThpNEwzVmt1QlY4Zy84anllMnliUHZ6M0tpL3l0dHhHUnR3aDVCNlRmNFo0RXdlSkZjdHV0UEZwdFlEL0FtR0RyYW14blZHNEMvU0lCeVVWbHM4K0RnZkYyVHI3and0aGsyMGtzTkhpNUhmVUZaVDRxQjJjWEs3bkZ5bnBsVVpISWh5cGIxOXJyNWVSNnNyeGFUdVp5eVhJd0hBNlNmR1ZyRGxla3Z5RXBpL0YxRE1TL2lnKzRhM3pQa2Y5Sm51VXU1dDdBL1RMelFXZzRMUGdxTGllWGNUMko3aitYSVRLdzhKMzRyTUJFR1lTT2pwMkU3cVVGSENvSzRSaldqTVpsTFNzT1RISkxkdW9naWNNZ2E1WnJUUWZ1d25TdU4yd3JTK3htekZaZzlOdXlSNzdyaktpL3l3dENYcEg1OElRY1V2S21yV3RidDJxNmJlYVZrRHdSNW1YbEhQY3ZtYkVTaWFtcFJNS2F5Um96a2pSalpEZmxQTnUzdThaalpqeHVpaUYxY1ZJV1JET29sZFVBQm1JTXFHVXRhSXFDUExtb2hzVHplT2JtVkRpb05UVDRHWkZVWVVzcWxVNmx0aFJTRVdOVDVsK3diVURXbUZVQngrblVGK1NkMUJma1Rkelh1Sjl3dnlBeU9VRGVUdDVOVG1HL3lBNWw2YWtiUnhuRFI5Qmd1RXNBYzNUL2JWQlhqZ1VNbkV2N0pRajlnaHVpb1J3d1NUREFPZTI3Y3RPRzUzR0h3R3JES2RMTnBNc09kR3lRQmtHbit3M0tkcFZ1SWgyem9UT2JwQTczWmZ3cWRSMHBOMm53Yk9ZOWd0dSt1SUhxTS9BNWpOV1paZnZueEJSSTBZMG5jSHQyYWtCTG8yN0htblg4TnF0RDU5dXo4QTNGb2h0WjB6cDB2ajFHdWppbTU2M3RGSXJuQmtQRGZvWEJzSk4wb2pDSE93aytKY2d3RG9KcTFGQUVVUkI1VFF2ZzhsOUEwM2k0Rk9TZ0NVT0dQaE5TemFCTW53RXl5WjZSNkRPS0VWV0RxcTdqRnZRaVlBbmVBcW9qNjZwUDEzM3dYOWQ4U2k5ZjhiSDg5a2t6bkZiQ2ttbHJNQk5TUEorQ21hRFpwaFJXMHFHb1QwM05aRlNmR1U2cFlTa2FWd1ZaU1FoQ0doNVI1K1NRbWdxYlBqVTlBOWc1Vnk0RFc2cE41TFVKWHBMNENTMC9vUUc3NnVZbS9TelhuNlM1VG5GdWJ0LzhmTUhLWnJka3MyVG0vMUxUVGE5ZjFjOUZRdUFWWHZGTFllQ01aSjhhTlZXZkxFbEtXUFlyZ3F5S29pb0xja0IyNzVwUnZDdXFZZG1uOFBKRVJGUWlpZ2FsNHNjVVV4WWpQUHhGUk5uRVhOMm4rVFI0Z09hMnZ6T21CckJCMFVvYUdoYXlMRGlvNlVvVUcralh4cUQxc2d3dGM1K0tUU1RZVXhIUlVNcFY5bEJPWlE4RlZYVk8wQ0pLdkpTTys1TXBYenhkaWlzUlRaeFYxVmtSOHpNbDI1ZUMvUEVNemQ4MnYzY2VmdTlDdUcvSnRyOGxpb3JFeTM3YUtNbW5kUnNsQmFDdFFBT0lwR0NqWFpCb3BxbjVKTnBvdjh4TFc3ek5VMVczZVR5Q1F0VUE1RjVRYkhlZDRYWVlrVWpLTkpudXZCdHpNek5ralFSNTNuRFZaRnQ0OThYWi9NbTZvcDErVVZQV1R3OHNlcXhvQ2ptRStnR3l3cmw3d0h5WHg3MFFrcDRkd3d1VUo3R3BIUmY2WERhYWxGV21YaWtPMi9LenpDSUR1OHZOWFgvSmJtQ01iZ2loM0lFSER4UnlpbCtOcUlGSTRKcUxacXVRY2ZsREJ4cHpsMThPZkt3MEZvbnVlK043M3JodjN4dExiSlN0dUg2TjdxN3VhNHMzYlMzdFRjVU1OU0Rwc1NCUlN2N0ZtKzYrYWJHOUdwelc3VmgwTEo3SkZXY1B6ODBkdnZIdzNGTU1oSUcrRThmOG5EM3R2UEFXWGtBekxxekdsSzlxUXovdmhycVZ1WjNjdGRBcGRNc0VJQUZvTkliV1RjZ3lVdGVsaHNOaU1HZFJvY2NhUWJmZmxaVUZUeE5jZmhiTEtCWndxM244eHhUMy9FNGg3TnUrdlhLME1qTTU2YVRpWS9ta1h4ZmpnV0NJYU1sc0lpNGFRVTFyL3orTEs0dWhZRUwwQmRMRllpSmJtWVJyK08yNmF4ZjhKc3F0WGI2SXBHdGhUUllTcVYydlYzMkJjWjhRNUEwU2lHaCtJeEpNbWZIVTluUTJHOTlSeUc2Tis0S3FGQ1Z2cSt5cFpGSnhNeFdNR0g0dDRuZjJIdHhUeWMxZDhlb3JaclZ4dzRwS21xWm85cmJzL0JWem5maFdQZCtvREIyYlo5RjFPcmh2cXl2Z01lUFpjaEdqZW5SSDRYQzk1NlA1Mi9LSGIxUDR2QmhKKytnNUdoUUZMZTJxa1llclFaZmU4K3IzdlBuVnN2YWVvQzNvOUp3Zy9JZVlQcGZLc04rbDYxMFp1aWNLWFdnYkdvSU82SFBUWXd6VXJ6bENiYndHUXZ4djdxQWVDUXF6ZXZrdFFmODdhaSsvNHplWnRQOWJ6TjRsN1Vrcm5RYzJPcStJM25KNk1oSUgvSEJuWDNpdVA2cWVhMVJkMm15VHROQ3crbHdadS9Fa04za1JvSlBqVzNXRFZnSzNWbXQvdXB1VTNvcnJUVy9GMUVtYXVkSEpaVmQ5OStLZXRQSGZ2Q1YyTXVuVFBaLy81K2o2dE5zdWN0N3RDcDkvdTU3dWE5Y1BSN2RycmE5ZGhCdmRzUFozenRJeUd2ZVM3Zy9nNDJ3dUIyMWJvTGJWbDNPdjVtN2xYb3Q3OGRMOU8vS1VwYzlUY1QzUGZESUcrZnpOT1p0bEFTZnZzVW5yTE5OaUVHcjh6K2ZhTFpSc3lEb2UyeTJVYlFoS09PMmpURnlNc3FEZ2RQR2pkL2w3ZlZmZkpNenYzNDFqVCt6VjFUUGN4c1pxSDM5K2dzbWRiakR3MWxtdW9CeWdkbk5zU1YzUjF0YzJOcm93Vzk4RXN4dFkxUFZYSG1aOXE5cTRCNERUQ2YvL2lnRHQ5M3FyM3RxSFc3bmNLbTdUMVY1L0dVQWpYQWRraEh0VktQU3FWU2gwb3k5dVc0b3JjRFhjQTU0NHZSbUQ3ZXNHWElkR096UlFjbEZnaUsxL2VXY2doM3l1WmtTZmpLWVBJVHV5UWM4cm9sQVQrRmJMM1hud1VEcDZZdFZObnpMMC9lVHROV05nbmNjZm5lUGhIYkY5YXRoaXozNjl1MDdXb3grdHM2NlRVZVVodmFJZW1teWxqQVlUWjNiRmRHZjM2QWdTY2lKZzVzYkx5K1BGNVhJeEUvR0xoSHFxWmcvVkd4T0p1T0VUZkFQdXR4NUNzbVpvb1ZMcndNN3hnT3BEWjFXSkNQSEZvOXY4aWk0UTBTZDJZK2g5RC9pV1QzVGpmcC9UVW9hY0l3SXRIMnJuS0R1NDRhNCswV1VpQWlDSHNjWDhyL2JUR0hNUFl4SU81Qk9qTEZqYTMrL2F5UFlPbkw2cHpnYzljWHBmZHYzTlRhdlg5ZXBnbE5mbVFQUTJaK0M2OUhKaGN2c2h4UFY0aUxSYTMrcjZnZG5zaElmMVhwS3M5c3E0UUdBU29BTFVBQnNPclp3bnRxKy9rL0FjcHJzcE45WlppOG9PblZqSjU0aVBUR1BmeTRPUU9ldm9hZnNwaURpTi9CQWh4bk5hK3pQRGg5Q2dnM2NuQnVIcDA0cDJaTmdnNHRpK09IL0lQMEMrU3VQU0xISDd1QU4wOVlhNVhaUm55UXhSZ0ZXbUdoQ1lwaVdxZDZST1JFVHViR1VFWEtIZFZCejBFNEJKTEVPU1RlZWUzMEVYaC9OdjF2U2M4Wmd2cVdwSzB0ZitoczlIcEYxVmpINU5wblZKMFJYUjkxaEFicHVLU3VOVkU2Sit6MzVvWCs0aE84Y3IvR3Q0ZnUxM3pkOFZaSFNtZUgxK2RuYjM3R3plVmJ0K01oQ1F0VHRVeVJmd2ljclgxWmgvNi9WeFdlRGxyNnRKeUVvcWQraTU5a0ZKQ0k4bHNuRlRsWC85b2ZoY3pINVhqQ2ZDS1VIK0wyOUp2cFVRSWNBcjdiL0JRbmZQcm5ZVXNwcTdYdktjNnorOHpPMENHRjBDTkk3dWxCSHVNcFg1elF3UEhRV0RPMmZnYnNaS1BZLzcxTnBXMGJHVXV0bXNXamFVWk1JY0l6K3FMR0tVUzExWWJQOXZPaUE3dTBBU3RYdlp2aXVYYTVFN2NuLzZHZnN6elp5ZCsxT2dWTGluRGRFV0FTM0tnckRZZVFsZWFQKzBWd1pja2hZK2ltK3UvMm51ditQMk55MXlTYTc5elZ4My93ZlcxdHU0RTlpK0diNFhWc1BnZXpZc1dkN3VObXlaNy9EWVN2ZFplSy9MMWNIOTdyUHdYcmNNZysrS3RPUmZpMEx6V0ozNi85V1BOWVVpNmxRMlovMllYazFkT2lQc3dnZDJDVE9YVG0zT0dtZVN4ZW16Rk9USitwT3pGZFhOZXRvVlBlaDZ3eDlSVzR3WVNMbFptRFhVeGdGYnhKWXBtZEVXakFuTFZoekx0aHk3M3JUK3gya2piQVJPNnpIOWRBQlNwOE1iRy84ZmNXOENKOGxSM1FsbjVIMGZsWldaZFhWMUhWMVZmZC9WMVQwOVI4MGw5Y3hJTXkxcE5CcWR0TTRaZ1JBejBrZ1dFb2dXQ0JCSU5tUEFJSEdwQlRLSXl4Nk81WkFBTlFZYnZEL3pXYnNMUnJEMk1ueGdmMkRMOW5nWDFpQkV6c2FMeUxyNm1BUHd0OUowWk9SWkdSRVpFZSs5ZU8vL1AvbmNjNmVlUTAvdkZSUFdEODFBUEN3SWg4WEEvS0dWRVBlS2hmMDMzRkM4Nm9lSEQvL3dxdi9HZ0EwVjlHb0dQWTdIbUY3Q2psVEZtdHFtNkVza2NYREUrQSt2MFhvWGNMSnJ2RTZsaUY4Q2Q4dkFRdDRJcW5LVmFqZVNxclVxSEdyTG93Y05kY0V3RmxUalp0WFFsQVhidnUwMjIxNVFORVA5NFN1bVR0eDU3SmhjblhKZThZclgzSGJic1R2ditMY29jK3p2WDZXNWZJOGc5UEN1OXFveUg5TnVVUjFoVkphbnBtUjVWSERVVzdRWWY4UElLN3kzRHd5TVd6YzQzaXZDajFSZk9iSzVldWRJYkh4ODRBZHQrVWd1SXJ6bXZiaUVGNUplQmpHTlpHQnNxQWxRUmpNcWFyU09TdGFhR3NRUUlsRkRnanlKVVNMTHIza3NqQUFrQ2I0V0svZXNhTmJ5UjF3RFFKNk14ZUpzSVRPc1QxNEE2NnNMT0xrZy9OeDA3K0ppcW56Y0xXamhzcDAwZk1TSFM5bkpMRnZQVG9ZeG5FRUxPQW16UFhCL3puQUxzMFhFRjFQeS9GUU8zdy9ycjFQei9UbENmcDF6TEUvaXcyVUtQSG1jYmpyMHFJYlV6QkNYTnVMbVJ2M0FpR1FVQUI5d0EwZXFSbGhVSnl1b01aeHl6ZWo4Ums5NjhjOFJVbFBLcDhjY3NneVFUWXlOSmJKa1RjQVorN1NTd2dObitBUmRHMGpSemUyQ0tPQi95MytPZUtUZys1cFh0NTd3YVN3MTh3Z0pWUHc5emREdE1nZjNDVTJjYk9Cc3RyRVdNSW9sd1N1QldaT2dYNXFVOFFWQ0U3ekdEaVdEUGRzK1J5aGg4VlRhSkk4Rk9SaFBOeEJNT25ud01DUS9JOXRzZGZ6dThXcDJuZndIUjRabjhuMTkrWm5oNnhvWnRPUmtuUnoraXpaL05FRHpBNTZ1cXZxZU0reWh0OHBLUE9nSmwzdUN1Q0tUUEtxVGZDTzJqSXlmSUpPQjVzaWdEcDkvc2JEU0tidzBTUW4vcWhHL0RtM29pTGlhcmlVVEpzNDRNVHRWU0pCa2k1ZVRMQk9qeHdTZXY1U2FJUEFtZk8zVDFHNUJOMmlyS2pweHlSallmWEQzQUZaSmlyTVh6QlkxT0tRUGRvTkUxRFhXSlVsS1phcXNHc3JNSlRNcTJnODNYMHFmY1NrZkhudWFQcHB1WHVISDlIaGdKYm9IWVFGMkVCNVFuQzNpZjRHcmU0R1oyRGlJZjZNTGZ6RlN1bEpKRTNyTkRSdDZKU1dxbXpyK1JycWJDTTM1aHA0akZWdDY0Z0NxUkw1c3FEWVIxRm9rZFBrR0lYQkRPbHBPekxVOHNPWVNvTHVFMzdHSDdlOVIwWkpsc014RXhFdmlIWTVGcVFXcWxTMUUvbHU1ZXAxb042TzU1NmovR3RmeGpoUG45WVpOeWZvYzMrNmMzaXppc2xJamZyeXZFajZUUExIVEhXVHVZdTVuM3N3Y2ovd1BLSlZtWTZWeEJTaHNhZFFiQTlyd2NnMHNkcjR3VGlPbC9ZQ3VPWGx4UExhU2JrZU1ldmlJS0lHS0poQXdwK2lzMkdTeEs4T0tYVkJyUG9TS2VBV3htVUZMVkY5ZW9DTU15djc2T0FHWEFKZlVzSFJnOSt3Rm5ESzNaZC9WS3RCU1Fja1hZcnd1YnRuR0ovaUJzbDNTSFUxeUUxMmNtVTJJN0s5L3BKYnQ4Z0ErdFgyenFQTXhMTkw1QnUrNWtuWVp2ZmZkVWRWRnZHWUxkUDB6UWNlb2NMbmx2bm9TNVgzSERJcUdUUytkUzRzc1Y0ci9Qczh2T0lFaTIybTdWN05NRy85eDVyZ3RLNEd6d1BPL0h5L2hYMHdMQm0rb2pxSDEycnZwelJHNTJ5RzZpZnhxbm8yNG83cnc2TGZDVXprS1ZJaUdnbDlyUGRyVGl2STAzU1MveUlyc0YzbWVidEJuRE9QN1drYjdQdDEwZlo5bHY4L3pKRzM0bnl3VGY0ZE5XTnVZdzlJNkU1bk9QQkx3R2VYQnh3R3M2eFBVSFNWYWFaK3E1YUc1U0Q0eWQ5Y1FJUnV0a0lCR3drWUtidEc0dWhBWGZwTkRwT1k0cjdqTHRIdlN6L1J1UGpUYXhVZW4wVFE1alhlVC9WZGQxWi9rdzA5bzdqL0Z0WGRPbDc5VStoYk91aHI2QWlmd25HWmlGWjBYdU9IUmZUVmMydnhZZnZxNjZScFB6aGc2Y0F1T1Y2K1ltVDQ0T1JIdXluZDM1eitaR3hyNlg1QnB4TlVzTXkvaDhsN0tNTFZJNFFBbUhtSkdhSDZ3NVphWVNuaUpnaVp2ZThPbmlRWVJ3ZUdtTUFyVy91K2FucDRhc2dQWDc4bWtESm5YT0oxRG5HeGw4cElRQ0ZKZk9sczJQU005WVB1OXVXSzNvM0FhcmhGT2RmSjkwZm11VDJtcXFNWjBKeFhZamlsSlBNdkhPWmxUWkljZkFVVnJURXAyOVk1azhVVmFUTGVEZE5GVlZCNS94d3F2YWI1QUxobVIwdGtyby9XVEw3RmJzVTVQL0NkS3hGVUJkMWl1SFZRU3l6V3VpZVZvU2dLTjV3U2hxVnZOc2dML3IzNGE5eWU1UDdrSFB2czlWbEs0UGhaVENxTkRhZVhISElmQzU2aSs5QmpQb1htSFJVYWlpelJ4ekF4UEdmMGpSVFhXbTNTZGk1RElmYXpwa2tMNE9hbE1GbWNTVEFiUDhhQWpMbERVMEZWV1RCY3JPQjVnS2VFL0llKzAyM1hKVUNwNm5haVlrS09QYVpZazM4ZzhoN1Y2R0tFam4rVHZMaXdzTFMwdkxhRkhRemx5Y3o4b2NMTWNmay91TDBoNk5Rd3hsMGVXdm1RMHVpZ1Nmc3FSbGgxdUliZHc4dVFDZWpRYUdNTERuQ0RMRkVDdHNhVUVrN1N2UjB5SjFEZUgxc01RTXdWV290TDVGYThob3pVejdEMW5MTWZOMFppV2k4YWNzNy94YUFkcFpFTy9wKzlzNGRickl0RUoxOUtXVzkrVytqdHF0aERTZHkrTWppNHV6TTh2aE9mZmJPM0cwMHZpOFV1SThmVDhHNDVyOXF2ZUZoNjloUnJKK24yclZDT3VRQVNBbEFqaVVoT3JscTBMdUxjVmRndUI4VSt4bGQwdFAwYTdXM2p2eTVOSTVDM2M4WkxYNy9sVDZKb3gydi9lYXVFT3FQL0EwUGk5RSt0MXdYY1VkK09MUkNUd2UzSS8yT0N3OXpkNkpOOWhkeTJRNktHek0yNjNwSU8xSVExbk93MHE2NkVaOW5ZYVNJUW9acDl5cmRXdzFIc2pydC9HQjk0MDR0ZmFjQVZtc2N3QnJpMXQrRUpnRGdhV0ZUSmJyZ2pVRHdUWUlZRnFiYUJaVmZSMUNqZXpuNExGUEpTS2hRZGpxVlRzeG1rZCtVNFZ6OTVPVUhWOHBFL2ZHRXVGTDNJaTl3aVdhUzhYdUFVT3B6eVA3cENFTjFTMWdsWjlBMEV1ZUVxUWJQb29uVDU0OURBOERpZlRSaTd4WGdoYmYyOGlaMHluZWxqMjkzbjFHV2p2WjFUK1BrR2ExUFZKU1NBb20zU3RIM3lCbDlxdHNRMUcxWlo5cEVWSnNncVJnQWF4dGN4R3pWeW5IVWxZeVV6ZnZoQUFGdDRWKzI2bmlkRmo3MGxrNGxpTXdVazhzMGhTV2NZSlpZUmI5OVN2ZjA1a1VraHVwUnRJRU5QS0w3U3l6eTNFTTV3TEhYT0oyQ1ZkTGhPbkFVWHJuamdlclV1Y2pCYWIyaFprR3ZuR2VhWEorY01DQm1JSlMrelRnRlZhcWsxMVFLNkNXSTRuLy9hZ1VzQ0lvdkRCalFCTkxLSFZhSHdaQk8raUQ4WTVxV2xON2VFNXptVTV3cmxEWHVLZDRUZHVVazJrb1JtOXFGZjFsMi8vcWJ3SGpVNXlDamU2ZlpSN1k1emwrQ2NiZGxpSmk3Tk5FRzd1cStFM05HU3FOK0U3OFkzRlRkdC9lcEdDdGt4eTVFWWxrdS9BTHZBRVkrQyszUWNyOGlVcXZFU0dEbGhIaThSSWNTWGVqN1JDN2tlZk9XSDJteWRNTmcydmttYkh3aVZWa1U0SXBuQkNVc29kZExCdE5memNzbTB2bTVWMHVsSnc1V1ZCV0piZEkwU2xpYUtzR3EzTGlFUkErd1dTTzNpWEdiUnF4S21kdzNvZllyTDkvUnY3KzdPNHB4V0M0UEdPdmZCdEhidElocDJOL1VkZ3B4QWNPY05lRSs4WXpUQS9qTjV6RFJiSVlpTVRlY1FjcEY0dHY2YWI1UTZlUmZvUDVsYUlFMk9ld3VOd1IvbmRobVpVYTRhZnJpcXR0T3JJUWtjSm5UUHNvZDZPRWg3djJLdXZLRDBwTzFOSFZ6YkwzbmlwU2tOZDh4cVozQnJGUExsV2ZUUmxJWWdqU0RHVEpNS0ZpT0VGNGg4aXRhK0FWTW91N1lqZ2wwZ0pOR0V0azBRalYzeDZlYUZDVmhvb09UbzE5eERVSVhRdEp5WE1SRC8rVXkvY0hhTitWN0hkZ3hETUpWNndSNDFyK0hXMHVIclJUbEd4T2NUZmtUQ1R2VWtydUlOSFdHMVIrYU54SFYrZ3g0OENNT0Vqck9RcWxpWEhsWm1ObGgrRzVOdG5mV3RUK0FqKzhsbEptTmtvTzVKaFNJNjhjVWFRd2xCU251Y1YvdW80dmttSlg0MnpFbFlOcnFhWFhJMnpEUithVnV6MUNOYks5cHg5OVcxbFA1VThxSWJpR0tpSWxhcFhKV2hMWTZRU3ZQV2o3K3RBMk80YWlLVCtSakdqNnhseG83L1RWaDNiZGxSNzUvcWgrS091QWQ4MEpMbENiRlFJQW1FMFZsaStxMllDVUt0WnU2c054OXJDSSt2c2V1dGFiYzFIMXYvb0dwZmYxb2d3ODNleVUxOEVuZ25GWTdUeDlMaHlyS2lnajBDTEZoZlV3TUx0aHh0N0FSOWI3S0ROVnFTKzdEV045cmttMjBjb1BhVnZaUzZXYWZ2SUYyZStoY2NrNnMrSENCWlNIbUkzU3hHU0JkWEdKNW9hQzljd3lsVzRLQVEra01RaStwK211V1QybXFjWkV3SmRFWEgwT2RITm0veVNJQno3ZkU3aUYyQmI1YVUvd1ZjdG1YQmhMNzZTT3AvY0p3aEwrTks3UGgvK1VsZ2dtVW1oZ1EyQnF2aWQ5aEN0anNUUkVCc1N3U2Nxdy9JSmxYdm82bmlrMU9JeHFiWGdFa1VGUjZzdmlFQjBWZEFvS3d1K3YvR0E5VDVlWXZGelA4UnhuK0VsaEhEMmsvYmxzekZYa0JHUEJOeStlNDY0YVlwbmpEd0NJMlFmM1p0T0NRTGk4Wis0ZFZyQUJWQUtXYktaMm80UDhUYXdLMTUxQVNtWjdyazZ5ZXk2UWtTSzBPYmY5R3BjenlsbW5JeDdzTmJWb3RIb2FsaWhTb0VVd09wWWkvVmpFNHFhUWFqVWRIUXNubGJxc2x4WDB2SHdFVmlPZmF4ZTN4OCswanFLaUEvUW9Yb2RNZE5tVEp0VEVzcWNGak9ueVJzZG5KdWJXL05veEhHQnY0VjdxSjlZQyt5Z09XVzJXV2VGWnRCWjlHN0ZmSnV0RnIxMERmUi9udDhVWGtqRXhTOXU0dkd1d2wvRGgzempGUG9pUVZxL3NIa0t5ZGRRRklTTjVLVTI0bEVJWDNjTnAzNW9uZU1OMmY0WDZJdEV0b2UxZ1RNeFJCTk95VWpRcTVSYjgwekVDMzMzaloyODBIdDlVVUxOUlcrSFFzZ0JIelM1RUNkdGZORDNVREpHL3FPQzlHMktoYkJpck9zbEVWQm54eFJwQmdDdCs3THJqbkFSUldXdzVtdXZPN2lGTDlIMy9mYnFFb0I4L21zOGIyMUhYMk5NTW1NVER1NlNieUlTcGxkeklhN1k1ZkI0d1lrUi9NalpYcC9kSUl0WStjakZVcUo4U3NubmxXK2ZFbUxDS1I1cnNpY1ZKUXpQVUFiWnpnZEJIaGZGMWpRN25FZExzaHd1eUxaOXpmb0ZJRFpxNXF0RW4wK0FsY2pGWWg5SGFVVXJYSGxxd20xaUJZRHU1Qkw4OUVibzAxVE5uU28valB1MWlTUitBeDRvVENRTEE5Ukt1L09BbThMN2hoT2ZucCtPT3diT3AvQUxDZUV2ZVB3SytEbzVYS1pHVmJTUWlZVy9pT2xtSlFCWHE2Qmk2akVreHpJUnpsRFRMNU5pUGsyMCsyTTIxQlVzQmRTYW81bTBJc0lUT3Q4M3NJYjJSOFNmOG5Ea3JmQXVUdjAza3QvMFIzUnQ0bDIwTWovUmxoY2FGNXhxM01LM1A2ZmhpMDNsNiszTVh1Wks1aWJtVmJqOUpiSzAxdlJDQk5BZEFHWnEya0FBc1FUb01KbytNWlBFSWlDMlhyakFUWXhET2NGRUxvaFFWTUxpd0JVTFVHb1Exdk5GSXJoRGJhQ0hlbDc1eWg0MTdSTEdCclg0eWxkRzVBM0E3TERlbVV1dW94d040VCt3QXVGNDRLSURxQ3RpZkxqNzNCN1VjUVp4RGI2SW02TW5oZzgwamxCS2lPdjRKcjRSYWRzYkc2eXFqUWF0QVg3a1dxMGM0RFBleW9Pd0wrRXphL3JyNGljMXZJclFjdFNjRzlCSFBvSTJORnRYeGZQc2h6K01TT2JzVit6L0RlNVplVVUwMXlIQzZSSDV2SGErZWxUSVVrY3RSQVhzOU8ySkNpZXM1VExiNGJtS2JtdDNWbjJzNDF6NHp2WnpMNngvNFJsT3JlUEw2MVRQdFZ6dWIxaXV3VE9VNjl2dDU1QitybGV1TEJuRnk5aUtkWk1Fa3laejFCakZUR2pDcXpVNnUxU1prTHlPQ1F0NjZncExBWFJhTmdjc1c4WHdlUUNBVVhqVVYxUWg5bUZoWWFFNUMrMFFPRmtVNWZDempabUlsd1VMQVRkY01md3VCWjVCdlVVbFppNFk3dUxDMTE5b1RGMXdXV1BTKzdHQTk4UlcyelRtMnVtMUpQQlZXa1ZVeXVaNDJsYktNOUcvUWNIZVFzdjExa2F4enFRNjRBSzlsWmJuTGMzaXJNQ2dPaGNQU2dLUnRjNG9jRWJVc2ZEclBQODFkRlhrOVViNzd0ZTRNeUdQaGQvRGM4VFhHcjJiM0hRVitockJrR2NqK3hHcytlNkVGYWJKMm5wdlJkRDZDQzVvZTBsSUdFVG5CMVBHTDRpMnIzakQ4TXY0Rlg4a3QwcXlQL3BlbXBZaWF4ZG9xZHRYdkdiNFpaNS9RdWFGSDdkL1ZvMkN2aUNMVFh3WThEdm93ZjI0U25DeDJzQ1M0Slh4dURyUkRyc0ZOcTVpdFJiVXBBRG1QZ3FCOWZlcFBlbHRDYXkzMUFVaDhXRXBaMC92VmFVUE53NXNTNGZ2dU94RGx6MTJaYkh2c2I3aWxjNVlBZjF4R2w4dkNIVjhCYjVlM1R0dDUvRDEwWUZ0NlQzaFhlMDNGTWFpK2ZkWllxOERGdVJ0ekRYTXJYZytDYUpGT3ZDR2dFZ2JFcDlkRVNtc1FLMHl6RlluYXdJV1drZ1VwbGl1SUlwSzNJMmlaY0I0aFVJb0JKdFJNQmE1eTR4aGlRc0NjNGRSSll0b2RncHQ5ZE9aSy9mc0hwQ2t5alozVTQ4Z1ZCN2E1M3pJSE5nMUtNdEJmam9ub0hjbTl3elBjQWhMOENvWHZpZktiQjZmSW5jdEZXYUwvZm1pVlhZMHkvSXRYWStYazEzMys5dDYwMXFoRkF4Y21CRDZ1NFRCZ1YxYVN0dmVueXB2a3VYdEYvK3NPOTgvMTQrNjJVSXQ3OWlYRDJ6M0xzWlBGRGlXUnorS012c2RjazlmWVNhZkdOWTVCVC9hMHJ4UmM5S3BhcVdOYm1IL3ZsVFczZFFuVS9zZy9tanJXS2R4bVJ5ekFkWi9TOVR1SW9rdFQ1bkpTcnZ6TlJZQm8zalNtdGlFRXF1QVIyZHBzallXR2NEQVFZQklqdXpNd080OW55WjExTWpnWWw4d1d5REovWldIUHZCUVJSQndtUXNEdXc3dUdpajBidk9GOE1zeWVXZlRKbGhweis4YUdLUzEwTWhZdUdqNW1SMlFYTEQ5NHIzYlpCbVhxMzhLVnd6K045WHZ6cGJsbkcyU1NwVUJONjFwZjNnOS9xS0hRQXVpUG9aNFlDUEV3VGpGL1E4V2NNQnp4bUliTERjUVJWR3RPYVhhbUZQUjhXVEEvYVdTakgwQy84V1N5aWZ3MzE5eWtRaWVmU2E4OW1zd0pIeUFXNUxabUhIMzJ5QkZkU1BHeXNkL0Q2ZktFdmM0VWVjZUZhUm4wVks0dklUL0hsLzlYdFJ5ajhVKzhFWURRanY4RHJCb0JCVzloVzNFdUlQQnBDZzVnalRtQk9objhHTGZWSk94ajZ2d1l1ckgyMTRzL0JGNkJuMEl2OWtESzE0dFhHNittdndFZlRWQVczNzJDVlJmV2tMMXg1bUdyeW9UK1I5Um4vQ1hNWGN4RHpBUFl6MmhMYW9nR284NzFnZFcraUN2Rk9kcVp6dGZCV1c1MFFpTlViL1VERXZ3OGsxbzdmd0NnWjhhcFFQN0tNWHNVcDViNldrTnljSmFCK3Y2cU80ODZ3UjQyR1RpV0JmNXJ3TDNCVlB0UGMyZ1hMUmFtRU1MaldnR0FsblZqR0pRcEVlYWo3cTVtYnQ2aldQZjN1M2dud21ja05KbE0xWnlrUk42VlhPQkxnT2NZaWlueGpJU2NIM25tWDZDdWcxMnNDYUlHekdGK2gwQVpsTmNTenRyWjNRRXcrY3M4dkUzVHZ5bVQvZnloaEJNemswR2dzSDNDbDJCMGUxbi9HNGo2SG93QVBUei9LRWhYY2tvK3BDc29GNVdGdlZNUmhkbHRoY3ByM2pTVWJsa29XZHlzcWVRNUZUblNiODA2M2QzKzdNbHRJY2lwNGNucmxaMFhibGFsNThVb0NEQ2s3SWV6U0ZmWWNHdlpJaXNFVE5FQXlLTFZrZ2Nodm1pWElod2E0aGRMMHZDNWFmS0ZRb09neUtNRzVoSENGb1hLRXdtc2loUlFYTTlrTDF0ZXNmbGdpaHJBaC8raVZuUXpNVEl0a1M2YS9MZ3l3ZVNCVm5aMGpld21XWEh5bS9uckhEZjRLNkJSR0QyWmt5M1ZIVmYySEZkejRUb3BNM0FUNk02WFlKRWUrQmhGaGQrMHRRS1ptTGJTQ0o5UWJsNmNDSnRGWlRLR010dUh1amJvcjZkRXpSWkRQOFFqL0M1RFlHWjZUWGRhZ2tlSjB6Mk9CbmRWYlI5ZE4wemtnVW9qczhZckpHWFJsQXhJaUlqL2d4RnlaTndOd2ttYXNURGdSZ0ZhaE5iV0VCekFUaUppc1VXcFdJVi8xV3FFL2ovU3JWV3hidlYya1NBZDRNSlloUU5mT0xXeDFxSCtxMzl0cGR4SDdEWitvYU1MR2MyMUZuN0FUZmoyZnV0L2tOcW41VUlnb1RWYTcrOE4zSDcrR2c5cThyOUd6YjB5MnEyUGpwK2U2TDM1YjF4UitRNDBZbS9wRG1IV2RsUWN2Zk1aWGFnNjlDT3pOdzlPY1dRMmNPT3hpcUNGQy9FSlVFNW9Oc1BQVHFuMUd4UktrdWlYVlBtSG4zSTFtVlI0Rm1SNWFuTUtUYXhEQjBzT2ZmajJXVTNSTXBHY1VsdDNWcnlnMkxWRDl4T3BEbG5OUlhSYXAyd2N4L2RzZCtNLzFYRHhsdmkyQVdlMjBVWCtFNlk2bUdsUmkwZzZ5WG91djBtN3VmVXRueFJYT0g0QlpZTGQxS1l0OE9xR1Q0bktUOXJoanZzWENOSDRtZ29KaUdVZVJpUDZGTzQzSnVaaTVqTHdZdDFkZG1qU0t4T0pFYkFmWWNxQUVJd0NRakM4TjhFQ1prQlFnRFJCN2lrZGk0dDhQVHZLUG9peiszSHBWOW9MRy9PNStxNC9FczU4bDg5bDFQOW5DdDBqM2NMRHBKU0JsYmlYVGVXeTYwby96eUxIOEpIdUhTNEJuSzV3eERRUXArUVc4emxyaytXeThrckJPRk50bS9qZngvT0VSNnJqamF2NDNJZlptNEh6SlR6YVhlQ3RRT3pIL2dOeGdFaHc4Y0NITzBYSFFmOXRvTzRLOURyQ0pGYURZdXJUWnRRUTNVNTJ3ZHllVmUrMUMzcUlpY2t1MUtCd01xeUVMaCswaE4waVJkTXh6SUVWc0tIVk4zUUJWM2tCVVhHVXJmTWIwbkZZb01DTjBpWVVES0RuQ3FkMDdlMDNkMWNLTmRqUEtmcG5EVXhQV3B6dXQ1bjlJME9HQndjVXJweUdZVXpOTlFuZWtsZjVIaE5ad1dYNTNWOWJyZmJjd0hmUXlKMmVuaEplRlJvcmwwM3Y3MStvaldkUjUydlNWZDVsdnJxZXpPRkw0WDR1Zkc3S1cvbE9SVDh2NzJKdzNlcG9QT04zOVdnc0d5T0Y4dk44V0lmYzlONWxRRjZSYlVXZ1J0SkJOeW9BWnhONG85QWtaMktWaFRFaGpZVEIycVNzeFgwcVJUTGJrQWNTemNUTG1MTFpSYTVlTGJleExLYmtQQUkzYUMyRStmeUFjajRrZDlrMldnekdzZTNGUW80aVNQRXpyQTgva09vc1cwL0dmbkl0L3JaRkhqOG4wOXJCNzdGaWtBTVBvVUZpNVlyNlZsYi9EVlpqanVhNVVYK0tMZkQ0VGk4NS9DNllQSG5VdHlmd3IwOGt2anNVWTV2M014YmdzNjA0ZnZTOHV3L3Y5SlEwY0lpNkV1UjJBaE5TMXhmd0NzVkJsbUNjbmkyNHIxaEhNelRFaGM0SXRMVUJDZkI3c1FzcENMdnVGaU04aFdjQXhQMk9SVDRFNWZpc2FTUU10bTRWY0s1UzYrVWRDR1RqcWw5WFFZZVBocnJ2WjF6NVBiektqbEhsaEdvdlI1c3hVMHdqN01WOUlPK0lDTVJ0NFhLWTRrTXlZTjBSZUJjU29WeXNuQ1BJRXI4UFlJY0xhbTA0UmJyV0pQTVlGMjhobWU5ZVNMREZpdzJYd1dkc2h1NE1HdEJaWlZEUStuY3BrVW84K01WL01abDNBTnFnTzZkVzdaSEk4YW9WSVRFd3B4cEhvU2lIK25sK1BMUjQ5TWNWOHJkdU4wZWZTMWRob2dnVERhZmNRbzhESkhLTFBHWkJ0L3NuY0FiMWg1bjNaeHRzTHc2RVRuM1UrUEpBTFZwTnRxTmFpNVlhRysyY0pXVUdIMmF2djQwdUUzZFgyUlZkc2EvQ243OUFwS1BzMEpWRlVrRGtoTGwyb3RKMis0VThYdmFLZkIzUU96RUJieHd0SmMvMVd3N1JUcHlKQ3FiL1RJRWhXdnZlMFdteW13RUcwQnROYlBOaXJqREFlQ1dQdGRHT3lsd281eEF5alRkbG4zNzJacnErWlYza094WE9wcG9IMXFqaVZhTkp4dk9ienhaWWJFN1cyZmEzaFFqejZYL0xMVXh6YTZVbC9ZeUI3Q3VRRmFSenVkOXl3QWVod2U2eWpCb1NCRzhqQWhvYytBeUFmUmFaUWxQZkNBejRVNG5sU2NuSkR3bzRxc214Q0xFM1U0Rlo1OEN1NnpacklXbkg0NWo0eDdMYzZ3VXVGVVJXYnFaamxuRG50MlROTmgvRk5LY3FvanF5OERObE0wWWx1bkZjbzhnbHBkMU82WXI1MVE5SDdma1dJV0xhNjVtS3BKaXhKM01kQzZUVkN6RVpydnhSS05vVm55L21lQnNWWlpQOXNwYXorT0ozcFROR1hqR1pDV1daWVZWYmIvM045QTV2QlhMRTUzMGxlZWdaMUJRMkIzUXpzM3N1WlQrczZ2dWd1eXFlV0pURzhMRE9jMFRIUUg0WkdpU1JNSmxkZllwLytGNjlMVU9ac3M5b2hhdjlMckJPYzBUdGlSOEFXN2RXTmxZdWtIYjcxZFc5OHZ6Ykp0VlBCT3JHVWJPVnBwNWlJZFcrTkZSaXVNN09rcEJmSnY3NTFLeXhiWjcxM3BXdSs0THNWOTl6Q3l6amZCcWRzTFNnT1d4TFE0VksveVVIN3A2UG1PcnFkME9JVEU0eVVocUdrS3owNnFVeVMwc3pOdjI2Rm1IMkk5RTk1cWFtcEZNOVlocVNwbHJGeGI2elAvdnJCUGh5cmE4NWZ6YUVvYW9Nb0VvaEZ0SVhKSFgzTzJPYW1nTEFjc0VDVDNhb3lEZFoybmpUYXpoNEVGSFR5QXNxdkVpU29zQ2k3Z3NsbmJ3ajZBQmlYZXcwSlBEZ3dVZnlQaWd5YXNJWE1MeDZYTnAvWDgzcTN0Rlhlczl5QXNDZjMwcXJySnEvTFZZRnhTZmdnUDNhTHBxWDU2RDdGTWk4VzNpVnRUVCtkVFMyVXA2THU4TGNxYmM5TDhEUHI4cm1FUE03ekZ2WnQ3TmZBUXN6czNCTHQ4MjdFWFczZWF3bDI4YkFHbTA0Z29QOE9wWjlzL21RWDdXKzM4aUUxTnFTQkUxWlBqUzZSSGdpSTZPaExldlplRnRKY0RMK2hQSS8yUWRZM0RicFl1VXk0R21waHFlVU0zT0kyZ2VWL0JmTmUrWlhpTVgvb0pZMXR2eTYxN0tLT3UyMGVmL2YyK2xkYy8vWDIrMS94dnRkMC96NEQzbjBwQlI3QjJOM1hZSkQwNCtZaFNLRnB6QS9pMDVsV29sajA2R2RUT21mRjZycThuWTU1WFkvMU1IMVFLVytULzNqS1ZNSzJ6TStGK2ZVMVB1eWRQTTlEZVhHZjUwR01YR1R6RjFnaHNDZm9pQlY1d2lBZDhnOTJVajhNQ3BZTUtqNkExTmpwanFoQ2VDQ1lRNkNUZDRTcHNrS0FLZWVOQ2ZMRmxvazZ4ays3S3l1cldMRlhTZE0veFkyaXJZaFdGVFBhNmF3NFZSWkMxSm12YWZGa3ZwVlBsSXhJcVNXbHhFU3drMnpzWkt5VlJ2ekp3VGRVRVFDN2JKY3lndjFvci9EaTMvaStLVW1NZlhKSkNLbTAvOUw2ZitOVjB1ZjQ0Q2JGenJ4bDI2Zm80Z3ZxeWYyY2N3N2lRRlV5YUJsajZKVTZjY1JxaTE4QmdGY1hMUmtrRWptb3hHZG9LVTZ6ZnVOdEh6RHE0QWdUTVZYK09sb0JDazlQSWdpZTIzaktTVksrcGVZbUQzUURiVnY3RmZFVXhYMXBFbkpzeWVqT0dweHNCdTlKUm1zdXJvY0tuczliaUtvVUlNejh0TlUwN3ZIeUVRQXBPRDVXeVhrODA1WGVFQi9KaWVDM3h3d3M5YXJwYkl4YktaWWs5UHppMmtyR1N5dTRSUE0yMTRQK0EzQ1BnYmUyQmRjcldtdFJJS1pxVXZCQ28yaGxXVWQvSVJ0Q2p1ZTk5Y3BUcEJGdTFwUndQYVNOZkwwRUs0ak9vTEZPUm5hWldtUnJLSVdZVktDdTRUaTJnUkZzVFFJZ1RRYU9TN2h6VkRrU0NnWnBrZTNKSmplRVI3T1hNbjgzYmNvdmlibEtwVFFYa0VrYWppaWpjVlZJY1J6UEZWM0dKWUxhbUtVZ21MQXJnbHF3Q09QVlh4Zkh5c05nVWUvaFQzaTdZdEFZdjBHcFBLTUlMMUkxK0tWdkNCWHJqVUNFUVE2RjBBemt4dkluN1JzR0JOc01MZTd3L294YS9GZStLcWw3VWU2eS82UFJ2d1Rqcm52S2N3VUNtanhVcTVhOVRvOS90L3I2K250S2o3V2phYkx5VlNkbGZTaU1jR2U5S1VvZHVLc2VtWTM4MzE5RFZPVFlWL0VER1lmNzJyMEpmekFyTm1CbDUzTGhWUFhsUnMyME9INWpoVHZ0QlA4NXEwZzVNVVBuTWhMKzBVMmJmai9aMkt5bDJ1Q1hPODhaZ3R6UW51SDF3b205d2Mvd2M3OERIeGNSR1BuTDh5SkUvVnNkUXBjNElpR2ZlUzZlYmRRcXFZd2grRGI5SVRhUnFKbGpNVmZLWERDNXBpdmFCWmpTelR4SW1IOFFyUVEyQ1ZwbFhMVThBWjVnZE5DTG1wV2xzbFIwQWFXSnNvTmJtVTJxdGJ4STFOcm05V056b1lpeHZKTGp1VjZPdmh1dkhRd3NZc3luZWU3aGxzbkNybHMxbk4xK2ZERDlKWFIxK0lwM0xkVWEwVkwwcTI3ZVg2Q2wzb0xvR1RzUXh1K25tRWNObUY4RmFvaUhzTmlPQ0VFN3JxU1FZU1RGTXNqZEJXQ1g5Z0tackFPNXhvYVM4MHNycEM3RHUvUHYwcytocXVpeTVnUnkxVlZpTktlbEpiL0JRRW10RElPankybWdoOTVoMHBBUHo1TENTcGQxaENNWW0ySll2QzF2QXJlb3lWMzhYVnVYZExlSlJjZm9hZ0FaSGttZVg0YUQ0L09tWW4xSzhMd3ZLeUlIeGRKZjdGMUQ5Z081WUpBcVpDK0F4cHFGK2xqYTBKLy9vd0trMVFwMGs4TkZnSWp3V0NCRDdJTlFKUjQ3UDJhQ2ErVktkOTl3R3ZwRzFYeEZSb3ZxUCtTZHgvLzhrcnFSY3E2T2M3Uk44SVgzTXBUdEZoUlRrNUdzL1VhY1NFRnp0aUY0TEZPaDRjdk5oZFNKZVVMeHpWOUxkb3VoM3hieEtaeGNHakdKWlMybDhNNnF5RFFTb2cxR0xQTFVkdjBrR2w5STc2dC9BZ1VxODNvalJ3RWtYSTVTU2xya1RjY2o5QW4wSlBNQVBnS2VGQ0tQc0tYTGtCZ05CWWRZd3JjOVFHL05PWXpEMFd3SmR4a0t6VURIMXVLTlBjQ3g3akZ2WUEwUE1ldENTSGgxdEdtbnZ1YWVNTmYxUU9mL21YZ2lnS2Y4a0lwMTg4L1hYMHY5R1g4TGg5SXg3ZmpqS3ZodG00UllhNFZtNjE0cnBXRHBJc21jMHJSZWhIalFrZE9wRWtjdVZLZ0xzbUlqZ0xQZ0lPZ1dBelFnY3pHWTdUV0ludDhqTXNxMkZWTkJOMHNheU9qK0F6SWo3RnJuY0Z6dEFyVU8yS0I3WnZRMmFjODJUOWtnT3QvSERmMEIyc3pvV3Y3UnM2aXU5RUgvakFrWGNyK0ErcFhSbjhRSjFsdTRMR2ovak5YeU0vd3A3MWluODRJUEV4UG03czNYUFhmQ3VMNGhwN3gxQ2ZIcjZLYmhIekFmbmRSL0VmaVVQLzFlbm44SGYzUlRLN1hNeGNSaEVFU2tXQ1lURE1Gc0c3UUJMOWdKaGpKd2g5REt3S2RjT0NBQW5IZ0VxZENDb21DeDRTZUZJZ1FVZEZDdHNQdmt1QkN5UFlSTFZZbVdnNjdhT1RyN0hmSXNsSXUrRFFiTDAydVYyU005MkNYRDFnMkVGQmw5VUJWYXIyREZtSzdQNTNUVXVibGxXT1p4VTV4d05QdGlwdmp3dFRTVStVTmd5TlRzOGRjNU45OFc3bDVpUGkzZUZ6VklKYXZDaUdOSEhtNnNsczEvWFQxWnNxNG9DVUdmQVNZejFqZ3FDcDJoSERUV1YwY2U1bUxsMTI5eXR4M0ZuNHZNNFZMaHNZdVR5WlByZ3ovTG5BZVU0aDE5c2tuaE5KTERYSVVqazhqazNqV2pwQVVGU3JaRG1zUTZJQXNwMEpRbUtDUnhjcXV1TnFnZE1qcUFVS1ZTUk9jVVREZ0hyMVlIZ1BXbWVkbHROVW8rK2hKUUVReVk0VFlqakNXZklnb1M5eHd2K2lTTWMxZmkvM1VNdzhPRXBqeEw4QzUxSytJbTI0eXM4K0pNdGRnN3ZvaVovZEU4R3VBTzdML0kyRy9ubkR6c1NQWk9MTGVjcWtrbmZ6YUZCUzFNOUpvcXZ2Q1g4YW9hWm1ldXhGU2JuWUxiQTlFU05LblFiN2gvTlJ5RCt4WVp3bXVNb21Ic0Z5TUliVjJyeXVDTlNLSTZ3Njh2Tmw2bXExck9ueFpmUWR1cWQ4RmZhK3Q5UnlyM3BDelNxSkoxRDl6V3NjYThmTGpwUG9sNTJBU1lJb0ZsT25IMTJsSUkzUjJiVTYxb2l2RElpcGwvak4rT0MveHJWSDhuU3c0eUJBbUJVMVI5TVUvSUtaRXpyZTRqMFJxdVQ5WGZzdnl3cEtUQWkyYkFtRW1ITDM3STBiTnR4MEZ5UWJXb0UrNEJlVmlUZnZhM3NZZnNaM2huSzVJZGxpWlNBNWtsa0w3WXdlY0ZkSEFCREQ2S2QvaWN2Nzc3alBla3dHMXpUMFhQQ08ySXExM1QyNDdJQVQyZXk1UVpZbFFXbTFLUXRWdHVDaHNGU0RLSXB5elpOR3dDWWtZVjNGRHlTY0taWXFOYjhpVmFhd1FDSUZBQVBmelphRENwNElKSEVMSzByb3g4NkZDNU9icGlaMnFKb2JaWGNxMnVhWE9mbXVDOFR3MnAxZGhkaDExck1IdW1OQjEwOXpCL1ozQmY5NDZhWGROeU4xd3VoNWJOT213WDdmL0Zkemt2VkZlMmZYeHB0Nm5kdGpmYmxkWFR1eEltSk03TzNQcEsrYjJUamJ5TnlwSnc4clczUDV1bklvcVhWOUo3OVp2YzYzM3FCdXpvL1kvZ096c3dzWGplNm9QbHdvR0FJclhyNXpaSFJRK3pkNWk5ZDlJSkU0SUZpYmxYR1BFU0l1cE1OWWRvYm8zODBFOWF1SkRWK3VGQ0Ura2dMZmx2SzB5WnVkbHdaeHJTSUNYUU03ZTZXT1VVVFBsemFYOEw5TU5yQnZkKzMwSE5sRG8rRnp3eGNQRFYwODNGMExEZ1MxYnJJaldwNlg5Yng5ZEJQK1BjOW1XSDRZSkpuaFZoYk5sVGJ2M2x3eU5Tc21teVNiRzdyNG1vdUhQTmYxU09ZbXVEbnIxZW5HWG5rL3pYWmdTTzVnRGxNa1Vkelc1UmJxV1JaQ1oxWlIrdFVDMFcvc0FZZHlaYXd0T0svVW1vWTd2QjRJRFhURDllSG5ucEpXTHhWWjFkTzZ0VHMwRGU5cVhSc1V2Y2U0d3pBcWRDUFBaaVZPb1JlRTM3cVRVN2tLeDlFTk1vK3lBcGJ0V1B0K214V1F4N0x0K3ppREJFOWx4VXZWTkw0ZjM5Nk5mNENUc3JPeWdSL2NvMWZvUnRuUXBUVXVlUEpPRGo5WDVlam05NCt5ckljRThqajhOQUUvbm13YSs0Q3pRMlBUd0gvVHhmSmpHbXRqZWF5UGdUVUNWMVpBUWhlQWVFMEtzTmdXRkd2RkNha1k0RGx4Z3R1Q2dKcGlTZVJ2RWtRVUJ3eWp1Q2pjeE1kM1h6YmRPL1BqbVZ1M1RsK203THAwNEIvdW5MdDBGMW9XUHlSSjRUTThqM1pLMG9mRW50ZkFmN25sNWZBWGM4dFVQSVNBbnh5YXA1ekE3cnJ4aHhUT2NDUEJOQ1RBaDNzaFFhUFJNWnprb21NNG9iNUdORGEzTDlLZjU1aUxpQ1RRNEFZR0MzT3gwQkhyNnJVeG5CS2JDSXlyQTZEVFNKTVFTdzY4WTFKMXdwUEEwakRoVFRnVERzSEVyazRRTDZ1ZnpOa2oyeE54SjdjVmQrazVZc3lpNmpDWXNkNE9vK1M4blhDK2wrbXpNdlo4UERPL2RFUlNGblAxSlVVNnNwaGJXa0k1TDUwZkNkenkvRWcrN1JGek8xbU9QVUt5UVAwMTYxdDRPdFQ5elpuM0xTeVEyeEJ6bXJIaEtRdE1wSnV3SEZyR05abkI1YVRCQW9IcmtXSlNpd0F4R2JoU0JiMkVwOFF3cHlyU0MzZHJGdTZTa3l4dmFYZC8rVnQvaGY1WWRsMDUvUG5UbGdaOVRiT2VSdUpQZmdMTnBFYnhvb0FGRThQZlRCZFR3SFBUTU5ZOE5nQWlkNG5pQ3RJV3F4U25LaE8rQktoZ2VGekdPUTVRdjRKaXVaSUZncUFpVm80bVJMd2JUUGg0c2dyd0lJV1ZvMSswWm9UK0cxWDF4dmovT3hKL1UveGVUWHVYcHUyQjdMOWQ2NVJHTC83dkplZGEvK0pYa1N0eTE5bmtpSDJkZi9GeWExTGk2dlg2My9SZmRORnRlRnRIUHM1ZHRHTkUyM2poeUk3QmpRL2hRd3ZOdlVhY0FIb0MvUmtlUlM1bFhzYmNCckk2bEliUVlVY2dYbmdHNlZRY3hBcjVDT0lnaG5jb0ZTQ0xFNnhhZ2dJNlRnaytRSGlNazFoc1BCMkRQM3o3anRTK2c1Wm1icGlwWFZmckwyZHc1eEkxb2dQUzdMSW02bHc4UTQ3UWJHa2dYQnk1Wk9HU2tabmh0dy9QbkhKTnplYU5RQk5VZmI0dFgyL0xuNXE1dm9iUTlIVzE4UU5kUS9FTXdrOGlHbW1LNW0wYi95REt4T2t4bWgvcXVueHM5SktSa1V0R0o2L3d2Q3RLcHF1cnZCb1l2SjF1WmZlMHNrd3oxZ1hreXdEUFU3Q3FJVXBjcWFrbHc3Y0lBYUljMFVSSmQyb2F0TnBNVzJDQ2hFR2NmYlhHSzl3Ynd3ZDhEaEd3L1FHM1cvNCt5MzI1cG5USHdsT0dlNUFBUGRIVU5kZ25uNU1sOUxUQWNrTDRMM044S2YyWlZEbHVvNy9nbFhENVRqdnVHamFGYmlKcDBYQzdLOGdrZG82WHNMejNJSG9qbGo2cXhOZW1WQVpBYW1Ccmc0aUhCclJkQlloYjhMd1NKeEVRVmRBcXdPcUlXeEI0cmxoQnJKVEtrN1hTVkNENGNmYW04TVZzTm53eFpoaXhOSS93bUNCd09VN0FBd0xpWm8zZDFkZFhkeHRIOGNsM2lkZmVlNjJvMzUzTjN2M204RVU4Yzc0SXNmS2VoMFFCRGUyVDVYMUNMaWZJcGlmbjVOZkI4dEhyY01aUlkxZVdRYUF2WDFuQXA1ZGp2aCtiNzVIbG50MzdSSEVmVWhIZHJJaVhXZ00zZkZWMDF4b005czJsZzBiTTVMb3hVL09VSzZPbEY5UHMraUZURzRuUi9xYWJtdlo3a20zWUQrYlI5VmdDZkJXZUd6cmlCWjFWWWFCVmNKUmVjY3haRlY3bFlhMnRVQzRWMjBXQ21yZktMSUJyNWFRa1hBZHYwOVVGS2MxK3VpMi80akRLV2dLL2llZGhrVGNsQzdOd0FpaGJoUmtKN1JVaGc1UHdKYkloeVoxM3R2S0liK1h2dUVNS3VNMGtucGhMeTlML2JETXd4SWt2SjYyWGcrZ21yTG5kaDBlcXRsSlhxaEhJYTQwQ3pSRDZPS0szVG96N0VjZ3JnT1d0dGxvNXE2b0FUM1NycTJYRmZlaXpqOEs3ZlpxWGtLSDdSbGZKOEh2U0xsWTlBYVdBNWN5eHpGQTFZdy8wR1A1Zm5xbnVWaDJtak1HaW9HVVNycXZIazJZd21YTXRIckdBdE9Lbkp5N3VkcnNTcHY5VFhGZkMrZFJ0VkhkWG9nVThheTBTOURBaU9WTThtQVpWSnk0ZDlYcXNyZlFvQnpJOHdwM3l1NnBBOXVDbXdYUXFFZU1RR0QxNHMreDI5UTNtTFpualdINlBLQ3Y2YmZEbVQvSXlkMlZmcWl0ODUzblY0bUwvQmsyMXNWUW84NGd6N05Kc1VaSkU4U0NnQXRCdlN1TDVXL2dnOWVoNVZ5UDFPV0czTmJIK1pwa0RMWXpHWW9UR1VldEUraXNYaWR0MW96NDNVMTlNQzNsZ2lnUlUreHFwWnZJbFI5VUdRUjdpa2JXWlV0Qm5UYzgxLy9EM1lORGZHYyt5R2UrOXlWRm5GajN3U1p2dmZUTDgyRmltOTcyU29zazdZUzNtOWU4UlRZVmRiaUYrbld3d3BDelBXOW94TWhPa2VyTnhaM2J4WWIwdjgrQmxZeG5WVUFMSGRvTDdlTldJNGpWZ1BTWVAwVGVBNnRjb0phQUtFTnNHYVdkaUdzR0RwRlNrVU9sa0JZSWlpa2NlQ2cwSUxYeWx4dzQvcW1RY1FNcnN6ejRmc09MUi9FZ21mcjhpWDh1ZnpDMnB5blZXN0g3QVJqdHF4SVdrWUZ2L3d3bndvRGthVXg0MTN2WFBZT2VRcy8yekF1RG9DUnRZZnZiZTNMMXBOU2JPWUtrdW5qRzFyV1lpY0dSSnNWNklCM1RkOFNVczUzd1YvVG1XMjY3RnN3QmhTZ1pMQVlrbkl6RTNrU3Nzc1ZrVFhoWGNZSUNnNTBjcmcxUHRRdENaZGp4ME5GRnhsZEVSMlMwbjdaTHR5dVpySmVNbnNzSG1oS0NVNGJQLzR6NlJjMzBwdzJ1WnRBQ1FKSmtNM25BQzdNR3FSQWJ0Q3J5Y0pxZmNlRXJXY3ZHM3E3bzU1djJKcWlwdkR2eTN4THYxYjdydUF4L0g4Z2FuVmdSZS9CdkhOR09QdzZmdzlaaGh4cjRHdWFXWWFUbExrTnNYTTQwWUx2K0wwZnBvRDJqT2dJNUQ0NmVBOXhiS0xnSnpadE9iaE5TQVVLUHMwdzBuWVNqYytOcmxydEo4dThjdHVrM3Q5eXJURmE1Ym5aancxWTFKckFsc2tETDJkNzJja0dGVGxmQ2JXSmpiTGhxcGxJamxCcDBUdkl5M29oWXluS1Y4VnpMNEdZSC9kOCtSRHFWN2V6TzNYWlh5NDVPcDk4WGRSUElXMDA1NTkwblNISzZzaDN4ZStLU2RWRlhyQ1Z6b0w5dXVhMzhaaXQ4Vnc1WFRCVG5JelBIY2Zhb3VpN2NvOFFoSEhCYVZDZWZFOWNBK0ZSQU5hS3Jtd3o5Y1FyTFcwejVvQlEzbWFhSlZFUHhBckdOVVhmaXlTWEFvTVZJUitta0MrT3NUMFZtc21HQ05CaGM2dDBHRi9IU21IM211VXpRcUk3S2dtNXpxR2ljTjF4SVRuaTJZYWMzdHpRWisvNDlPcHV4QWRrelo2dlkxcVNnSGlTN3BHMWhaNGFWaVR1cXhySW9SdklFdTI5VDdNek5JNHhRTkRROGsvSVNaeUJpS1dRZndxWHBNTWVJeGxaUHdlSmpzSGxEdnhUOThzbDRQNjRIMVNWWGh4VVJNa3dYOG0zNDZibWQ5TGU0a2NobEIxeFFMYVRkWkFWcWlDMDJSN3lqd0l6elJxcThxVVIzOVFJUi9UYWZ5TnRjdHFkeFloMjdxbXdLZVFBUVlGVWp0VGpiV3dBQXhtRlFzZkVDMVlRZ29ydUVCVTJpc252MEhsKzhmZnJmTjBjQ1FwcHlYRU8zME1tS2xJZm8zV1d5bC83ZTd2ZEVsZWVLT2o3VWhTdGcyV1JhQXJhem9peEw1TnhDdFA4TGlZY01pVDJRYmo0UVZOeUZ2MGRQM3FnUGRTVnZWSkU2TnhRMGxSdXZLVkl3TXJqdy9NVENNTklYVDBFeW12ei9jalJYRjk5eWtJVXZSZENHVFN6aHh6Yy9hOGJSdjRvcVR0VmhDNUJYMWsxWVFoQTlIUzdkRGZwRHRkYlUwdnNCTGlCYXBMSlV6ZFVFZXFSaEZ4L1ZRLzB6LzBNa2xvMkpaUFZLdUtQRlkwLzZHMUpVSTVLS2srZDJXYkRweTBCMHNSbDhYeGR1RzhhbFpWNjRYZlRNTlQ0VjJjWUpnYWxOL0RUeVVBZkVHakdZdW5tczViOG9QeUQ5OE9hbmpJdldtcXhBb2Y3STZTekQ5bXdnK2QvNXV5NEx1L1ErdGV0RFpYNHJxcW9CNzRWSG1BZVlQd1VJTTh4a2QxSnNUMm9yeFBJajdVNVhxT1Uxa25RTTZtUWFDRmJ4VEszbXBWdTZqVzgxUlR5dkZpbU5GT2duZUthZk1wOG5vbis0TC95YURxMmU5NlE4Ry9xZE4rVTdWN0w2TlhBRXdYc0krY2hWSjlwSXJTWUo0VHpjc1RUeVlMQmFUbnlNejVlTzZRZWFGSy95Y2NrTkY1QlRoUlR4Rk92OEpudE1EdVI3SWVUQWhlSkNEUTFlUW1VRi8zRW9MRDE4QmoxNHZpWHhZQ1lkaGx0bklYTVRNWXczdEQ3QUVTRmFCeUZ5S0t5eHFpSGhESnFyZ3p4QlhZMk1PaGJXM0xRU2dkNElJUSs0S1E2MVVxWFVqK2dndzB0WWlvRHA4Q1hrYXZxUUtVVDFGa3FYQXZ2U1IxV2lPbHY1VzhqVExzRVd0eUp2Q2hreHZSbnVGdXBRU2IrYmxWMkNoVHRscStYSFRuZUJaRll2REErN25yMWRTeXZXS1FqZUxDd3NMSi9FdEd3U1RMMnFpamV2WGsvcFRTL2dSeFZjby9NM3VBTDVKWmZrSjE0ejcxbGJGVlBodllPbEVyOWlqZ3JqellWQjBQK1lZYnpJY2ZuR2c4RWxkZlJNdmZneGt6M2Z0YzB6M1FzR1FwQTJwSFBLYnZ3ZWJWK0xmdE9IT2gzZUt3cWhkMFJWVjNWQVlXT1RKZzlRM3FmcENMclZCa2d6aFF0ZDA5cjFMVWxUeFkySURXd1RzblU4eVE4eHJTRThRMjBTN0JsRVBvVWxwTEw5WG01MEM3T2JRS09SMEpPbHRSczErVUtsdVJwMHl6M2g3SDRrVUkxR2lXTU9WTW5xZjB0UHZHSDI5dWo5UjlBYTc0czR0UEd1cVNGQk54QThxM1NQaHY5eWltMTQyanI5cXhldnk2Q2VNdkl4UFBuRjhwTEVWaC9EeG43TWNlbVhjWXcxSE14eExMS1Z3SlJjVHM4R0FmU1d2bWdiWVdWVkxWT1REY2YrZVpJOGFMbCtwWloxWnkwT2VPY0N6RXNjTDk5b3g1RG9aK0hvSHNGRGs5RU11NThSY08wZlcrdHlZYzQ5bEhkWjF5UkxGbUd4RjlRbnovSWVwckNoTXROTXRTUkJLUnV4Q0JIUjZGc0hVbjBVdVlYR1B3d2NLZlgrcXBlcVZwOXJFZ1hLVFh3aFVjNEpDU2pqT21GMmlkSitYc3MxYmtnazMvcjdVWk54UFhYVmJCc3Q3dDBpT3AyaTVCMjRSWlYyOWorTjJRYS90Rk95KzVFVEMzaE9XcWlidFR3cThMOFZ6YkViSWVkKzFNOUlHVTVXVEcxVi9Za0x0NXJCQTZ2V3JiaVdGRm1kNFEvcXVZbkY0dUdrTVBHUnNJWEtvTHJCYnhGVEtFTGV6ZkVibUk3OUZIdXNQQTJRZWg5aGFrY0NhQTBsSEdYcTlGOVZMbXhaQlBGQUNnbVZEbEluSjJoZ3BNejVYS1U4MXJxMjI4bEFaUG9Vem9IbjBUTkpMRElpcGJyRS82YWZZZU5IbWk2WTdYbUJqYjVLVS80MVZpcnlBOG9KVHRQTXMzLzNQYjFCa09WQnFuTnJESmJyNWJpUXBQRC9JSjd2NVlWWTBSWFpBNkU0SUZTVHdxb2d5ZkhjQ0hZN25CREdaZk9NVHlaUW85QVJjdkNmK21HRTRxRFR1dkZaU3BWZlpkbG1TM3hvdnVUdmZxbWxsWGJ2MU5manhNcEluOFllMSs3MU9YSEllRmtYK21WaGNkdjVLRkU4NFl0ejVBQytLZHpteUIzd0dSUEY2QUMyU1NPL0R6T3VaTnpGdll4NXRZSGtVcVV1N1JDTVVPL0RocHdBUWZoeWtjQ0pHdHdIV2dXR2hCSVljbjByVUVWMUtaYXc2Qm5XT0x3TzR1Q3pRSmdlK1dNSFZUNUZzeUVvV1VWSEJnREZWQ1NCcXZDR0t0M0FUQ0JWaXQxR01ENlQ4UkNaYlNoZVFxVkI2Uk1WRUc2eXhvWmlUeDEwczZ3eFN4c1JmLzBrZEhWQU5uVU82Wi9JWlc0L0h5dXFGQXM5eFk3RmsxalpIckV4dnhleXVLK3c0eDZvR1A2NFhkRW1lc29LQnROT2Z6aUhuZUwwK1NnSDB3MXlEV3dWL3NOMjJZOXZKTHNVdzFWTzRveXRWMjFHUmFVcEpQaUN1d3ZnZzBNemlxeEV2T1FZeUxFRkR5RkszOHV5SEVOZm55QnZja1I1RGQwcVhxSmsvRkF5WkZUYWJ5RlNUNm5iWEcxamlrKzc4eVJNclNRellKbWJmSHZBeFJTUjRsRWFRNGtvc3RuS0ZDSEVEWUZNOUVrMUtRMHB4cFUrMGNnMmxIeEJscEdKdEFuMEZvRk52OUhBaUN5THlGcHU1UXhHVzZnM0JJWXF2ZXRhTFB2YTY0SFZJbFFYbERrRVIrYnRwS3ZMNHdDSkoxemo4cHNVSWx4QVhkQ3Q2Z1BHWXJpYS9SR1RSSUxOcmM0NG9VVU5GWGxpSi9yMktGNTZ0M1NwNlduaEs4OFJiRmVwQUdsN0V5OGlXK1N2RE12cm5kaXFpYWVxR1VxZWJ2M3ViaXY5N20yRWZoNW52dVAwV1NYcjFLQ0YxZ09SQzZnQ2pScVI0aVBoNVBVdnhiZkYzbkQ4blExeitIQ3laWXlPbkdVS1I4Z0FrbzZQTjdBaGE4emhhL05NL2JabG13OFZXL2xPZmFqUFp0aDJQOE1ISnZMS0VwYVlkSkVLVU1Nd1IvMjhxcVRaZVNxcEU1RnhkSU5TMkRRelVSNXhNM0J4WUdNRTV1MGlDdFVURVhIRFhUam1SbmN3bW9JTWtTaHMwY2VPaGV3OXRGTFVOSlhvSXpzazc3L3FjYmVkSFJoQ2ltNldkZDEwd29mSW13bWROOVlScURoUzQvazJITm00OHRLbWZLd3lRUTBCRlovTHFCUDZGMDh6U3lMYVJKVWdhYXozZlpYdlJSeG1mR1lNU05SWldHNHZzd0RsVzVrZ29PVkZBaUlkb2piaCsrckNBaHQ0NXZYSGo5STc1bk9OK1RNdHFId3Vjekx6Mk1ZNzdlTUtPYmFwbEMzNldTOFo3Y3JWTk1RczlWYXZ0MnprOG1veDlWRlUvNnFlSEJuYnVDMy81Rk1kOTFPOHFkTlUyK1JhKzFreHVxblhsTXczZlZhcXZKM0dOenhHOE1pbUNsd2ttYWxFMExrRXNsWXFWSnBaWmtXSllrUmR0K0h6NXhMUXhnb3JrcGlMNnp2QzlRMFAzRG50KzRkWFphU0hPai9zUEZYeFB2RG5EeC9teERZTEg5MXhtY1Z6RkhnalNibEJLRnkwdGhtV1dDc2M5SnhqQ1c0YVd6SXI1L2tGMGJIQndjQ2crMVRYUk4vYzZSYmx4c0craWF5citvWnFpM1BCNlJUMlF5STVYOEtpbjlhUVNQT2ZZbGZIc2p3VGg0USthNWdlamV2OXJkZ3g5aWdtWVBpTHowYkdKT2o1RU16RGhnMm9hdEttQkVqMHQrVmpCODhVamtuaFVwTm1qb3BnNUlpZ25GZUdJSUVRWkhqMnFHWWEycktYd1g1VEpMY3R5NDEvMER1Q245RVhLSysyU3RZak5UYWVVYU5JWkQ1b3VLTEFvc1dLWkJzYlhrWllqZStCUHhWVkJ5dC94NWp1MmJiOWorOGlCUEErQ0l0KzFxMi9ERFJ0bWJ0eXc2WmIwRGRDbGprTXZ2SkRuRUQ5SCt0Zmx2SXFla29TWHplRGIzbngwZXlITGFmaEdMdFUxYytPeEd6WnNxVVpnZC9pMjhNK0I5blR5bmNTMnZwbGpHNzYwZVR3bUpxZ3ZMYlZrZ2JXckFYUVdtY0xjTnVwQWZGaHFKMEJCOXM2TlcwdDl2YVg2cGtjMjFVdTlmYVd0R3orKzlmYlgzNzUxK0ticnJydHg1TlRXMjdlUzNhMjNvMFhkU0tSS3gzdTcweGIrTDkzZGU3eVVTaGo2YVNZMW1NTC9EdmFZaG1IMkpQeWV3UjZmSkUxK25UK0xXRGwzTXBjd2w0TmZZMkdFVm1Fa2pWbkVtQ21KN2NMRUZsamNhQW9RUU02SmhZZ2FLTFl3Z05iY2dBT0xaWTFjNUFHY0RIdmtPMWkrdkpzVHhCbFI1dzRjNEhSeGc4aHpkMmRaNFRzd05qK2RHZFp6T1gwNDh6VGVDN2QyWFJsN0tmZDFKZXUrL0kyNkszeXdLK1ptbGY2WUs3ajZHNEV1bHQvNGdtaHdHWTRYUC9FSi9KUU1aNGd2ekFwNGhCZlZya1M5bnVoU1JUellvMEhyTXowL1hsZ28ydTZDcnFLZFZyamZ0UThVeTFqdFdZam01aDhRbjQ1eHlxelQvR1FxTFgrZk5tamZsc3dVWVJGV3BHSWJLMHB0cWh1aGNETlpUWDlFOFpWL1pKR0JCTGJmTlk0SnNBQjF6SEQ3V1FFZlk2OWJJRGl0QysvaitmZjkzZGhGSFA1di9LZ2tmWWtWV0l0RmJQN3ZEVmNTSG54UWtGemo3L01zQ3k0OWYvc2dmRnNQbnI2ZjQrNlBZdXl3N0F3NG9lMTRhVytBNkszU2lybHBoVHRCV2ZvdHo5ZUtaL2Z4Q2pxdWFjTnVtK29NYm01SGRVUGZYaU80Nm8vUDhkaW5VcVRlcVp0Qk0vdjFJNW40VWp4ekpKNGhDektLZEZ5UmxpVGxlTVMxbEttM25yRDRtMldQci9qRktHc1RCdnY1VER6OEFtaFRhQzRpOFRxQ3haYm9TRHpUbUw4cC9tV1JHV1UyTmVYNGFyc0Uwdm54NFJaWmx6RUpIY1RGV213UkIwYlpxL0VrdS9PdVJ5QzVnRXpEOTBLQ1JocytEcysxM0IxdzluaDBLVTdDWEhRdFRpTGNqZVUyakw1cm1idVl4eGltdG1KVnZGM3NnQkpVVnNsVW5mc3VqU1JjNCt1QXBEVFJPdWEwUWMrZHkzZjQyZVlIY2xremQxOHo5OFptN290aG5VVHBIU1MrVVFkSjhGNjRTTnQ1Y1o0Y25QL1BhMzVpYXdZR3JubndOSU1maWg1V2RFcHByU3ZoWFpLZzc0ZXorOUVpUFpoYiszT2k2NlBQRXJ5aUdXWXJzNHU1a2prRThtcm4rdWdzblYzb2VrcERSRzNSUmtRckx6RDNsUEowMWtGNSt1bFVJdlErcUZyUWtXdUE2VGZlT0lLTzhDUVVrYXpOODVhVjZlN3J6MllzaXh3RkpNZU9vK0V5b3E1ektCZWVKSmwvK1JJdklwYVZoV1ZCWmxrOHNQS1M4QnFCQjd5Ymh5U0lIbTZLdENOREk0VWV5K29wNE16YVI2ZXVtWnE2SnJ5YmJGU0JsMFZGRVdWZW1NQVR1aUlhUmdQbnByMnVydmpkMWhYWE1OK1NqNUpiVVhPL2JWMXQ2NmliRXl0cTdqZXZLeFJFTlJUK2M2dlcvc08vSzY1SUZ5NmhwaXpLZTkxV2Q3OXRYWTMvQjMxWGFQZWFIeGEzb3E1K2gvWDAyOWJFYjE1V2NKY0ZPeHdENHpvdWt6c01Sa2p5NHFBcXRvMnNRUHhFanVQaElZdUNxT2dndWJaNzJOV2k0eVphc0ViVExNOXgyY0YrR01uNkI3TWN4N1BwVVd1ZDQrZzlNUmR4SEI3dVVNWmRJdVBla3B0Qk9NTnhLTzZjNldRTDJ3cmtvU1JoeHBnL2cxOWFYbW9pblZLaHZMa0VWbTRHS0FjdGhXSUxlQzhEekJ1YWI3SDZFQ2MxNEVHdVgrNU56MDk3dm1XbllrL0ZVcloxZmJwVW5peVg3aU1vUGE1dGU2T2ViYnVFTDdsSkpSUlNocmpqZjVzcUFCRkZJU1c3ZmxvSDFqNDk3YnNQQW83d1ZPbmIwSGE2blJKNFRlT0ZsTjNBOENLWTMwbW1oeGttYThZTVdpVnRkV0RZd3N4Wm5PQ2FzMmlsRVVaRGlraklOUWhHVm1DU0JtOUhoYUJUS1RCRG55QWNhaWRhd2J4L1M0alU1dTE2Sm81TEZmRWwvd01XY1FySk5LNlBUS3BBSko0VHJsRTMzQk1RczB0V0l1eDJyejJiNEVXR1N4UlRkNUdDWStIYlJ0TURVbWJmOVBTK2pEU1FIcVYrZlRsQ1dBK3hlUzE4Q1N2aW1kdkYzTWpjQnY1WFoyanhGVExLU3RpbGxmdFN1YkxlTjNMR0w2U2RMaXFLTjBUTGd3OUJTNjZYL0lWaXFuMGIrbFJUTVJLeDIyS0pCZHYzYzc0L0wvSzM4YUtoU25hUExhbEdKNmRVaEk1aW4yejE4UHFhMloyNjVNUzcrdnU3NG82a081NFdTeVJpbW5ja3dEK1FDNDd6b3NocnFzT3hzc3h5anNwUVhyeW9ib0VuWjR5WkkzYkxzM2g0Q3F0NTQ2SXdpYlloRU1Jb2dqd2d0d2RyVlJQRkVRbVBVNWpnZ0Jyb3Z2ZXliaWt1SFd5TWdnZWwrRlhoOHZ6b2tmazFxNE5ZQk8raFlNSHoxQm9ZNEFmZzIxUVNlM21OaXJOZkVPQitha3VQZkxDU3pBQXp5K3hnTG1adWdxZzF5djdVRVZ3NnNhcmNrWHYvU2c3MU5XcWloV2pmVmhrVmlkWUVhME5OMkkzS2dNeU9SbjNndm9LTzFNOVFPNy9DZGROWlFjbW9kcFpvVHpzWmRUbFNSMGNhZFhRcW5obGR0NzRrYVVXTlhkbW9MK0pQUVBEdmkzamMyUWNlZWlXeVlnUFJMd0FkWEt4dFJoSDZaVnRKcFhiNlZFQWd4clZVNlJpeG1pdTBRUGRRbmZBbTJMR1hZWjNYeEhyUnhtTzVoM0xITmlMRW1saVhmcGxGUjU5Y3cvcDdUKzVFN2g1SldheVRsUU1BdDFoVVUrcWlFdnVEeFlYNnd0MVg0aWRZK0VuVDlmbzB2dDNDajduUzlHNkVTcm5SdXdjZUFGeDB1SVpQSFFieCs3QUw5OElqM0tYRnhVV21yY3pMdjMyWlN4MW9DMDE2THI4V0ZMMWl0WGkrWlE1LzYwS2ZXS2ZRWEpzOVB3K2NER2UwNVpOS2FMZm5Od3A4Smd2K1czQUozOUl5NGtkRldzdHlYNjgzYmZmNG5Zbk42bC9RVjlFN21qcm9Ic0QxQXU2WGlmeDRrenMxV09FNXlxMzBKRjJ4RDRHbU5DUkxMTmU4R3M4aUVsRWZYc1R5SDBZa2NENThBYWNmYUIzbVA5aDIvTW00dENBSUMxSThONE9PSmVBd0pBL1NEU1NubVZaK3NaVTFselZaQnJhOUJWbCs4bzRacG9IVEFUWXBXajdRWHNDaTB6bFhyYkFPck53dk9lM0RGQ1d0b29sUUxUcjVxZ1FrVHpoQjcyd3FxSzllMDdvQnkyYmhLRm1xVTgzMzZ3SCtGeTdnenZCWlhzYi8ycXduK2hvbW1hK0dwK0JPZEJ6U0wrNFZUV01HSjY5OFBsejgxVldzd0Y5MkZjU05zYzN5SnBrS1JMVGpvbGlvalJLaHlka0lib0Zia0pkM29CdWh2M3Qvb0wrZkxoZXE2RG5WRE1JM2ZGYm1QeHZXNnpMcTJqdGptT0xlTDhLNThBaTV3amJNMTE5MUdTK3dWLzBLTFQ3UEN5dTQ2aWdiM0xxeFloeng4VytMV2VpME45Zk9RbDEzU05mSlVnK3VKdGpPNGFRdkFoQmRtNzh1ZktxQkF2QklheUkvMWVSdTdlVFgyUXordzJkbHNqdlhFcXdiaGZIajlRdXhQbmZOcVRPV2c5aSttRjhRLzlraFdMdXFWU2NwR25kN0dGMndBbGlvUlVQUUdheXhvbmplYzY3dFlqazBpZUtad0FIQ0JUeW9CTmNUam8vU25ZcEVhQlVTQ1VnUFN3cmU3bnNpWVpwbEg2VHhVaHBMbzdFVXQ0MUx4YWhvR2t1aC9WUW1EK2Nqem9mRmlQNWhtWEE1QzJTZVdDUjhDaVhDcnpHNzJwYVhiMzdYRTlXOE53RklKaE5la1N0V0o4Q2hmUUl1cEFOU3NacG43eUZrOEdDdURKZUpGUy9IMW5QQ3J4Ymh2OXppOHBJQ01GZEtIZVltZ2Y4OEtjN3h6ME1vVDZqa2N1amZlYUcrZUpxQmkrbXBreEVQR3ZQdkJBT0ljU2U0NXBwelkxWFpuV2pCM3NFYTlLR2hQV01DMXJEeFdQRUFYU2tXaHZlTVIwZGVUNWFWMFdLNFNJZzNTWUxhOGxTK29uTm5obkQ3VERPM01uY3g5K0FYR1NWaEpac3BhSXRISEg4RFAxY2pVRXBjZ1hEcGpCTzJBYkFjUmhNbHpKTkVzMjVXcDFob0RYekVIUmFpc3B0ejdEaFdzLzFTNS8xb2xKY0RVVWFjMFZYOHcrMGJ0MXlJSmkvY3NuSDdFL2R1bnB2Yi9ETklybHBRRkg1VWlPRVBYWjJKOXg2VEF6ZEx0TTN1YmQxa20zVUJ4aytZdklUc2pSN29GcVR3cjVzMzhRcStDYXVobXFqeVNKT01ZaGUzcFhibzF1a3RXNlp2UFZUYkV0N1lPL3p0NFY2U0xOdnl2SXovMlZ2emw2YmpNVDBKYzBKUmtvcXdUZXF4ZUpxRXc2YUpGVkRYV0hHb2RVTkRMZ0hzSTUvZ09GL1VIcmt0WVlFQzBJL0wxV2drSTR3ZUhaQ2NrR3hCZnJTSTVqWDZWR3NnbUNkQnNaVk1xbiswdnZBeEZXZEhMeGtSSDZld2piMnE2YXBTdHgrUU1EN3FvaWxUL0FTMFJBd1Nhbis5UHYreFZBYmZseHU1WkRUd0g1ZlVxNG1KRS8rVHVrVVNaSGdiOWI3TVVMd0V4aVM2UnozU1BScHJHcTlpWHNlOGpYbWMrVlBtV2Vhdm1SK2NneTZ5WWphc25lZit5dnRMWjlrLzMrZXYzSmRXN0dPTm9JV1p4YmY3T1lRUFNVSUNodEVFTVRHZk9ZdFZvbVlldkFhYXh4ZlA0eUdkMmVjaCt6dzhiajNkNjMyTnE4K1M3Rm5qMkIrZjQ3MnQ1QjJOT1VXSzlOWUgwRUlVZnc1ZUtIZXYvbFlBc3d6K2lQL2RCSFVNcDBFMVpJU1lxbzJCazBHUnV0MVdWODJXb2dSMEVHREl4TU5ONUNZRjlqd1lld2pwdHg5TXdXSUllL2pYSitCalowRStDYjhTbmtJMkdvWDAxNzlTRmM3WVlYQ0tLa3JzTENmSFpXNldsYmJ6UE1leHp2Z3ZPNkI0YmExZ1d6d1l4MVRCZFdKeDhBN0ZlNDVsNml3TDNGNnNxZ2ZxM1pHWVJvVXRXelhEa3hERmpaaVRjbCtmcklwUHlmSlRvdnFBNW1xNk5MRVpQNXNpRXBLZktaVk5sWVRXY1p6dU9EcCtPRHhWTXh3Yi81YUFmOFEwVTZrbTMrSXk0ZGloSEhtWDBPZ3NxTk1HZzV3YjliK0c4Q2xRMmJveFNUZGw3U1p6ZUVObG1JaldBQ2VPRUhNQXRaTHhWT0dseWk4YkQxL0VMNlBtVkJOTDNDOEtVaWJPNGk5UFNpclNyeUgyaXRpWVRpNVFVcVZNL0RST0VabWNnVkZKa2VaeERSSzNUbHhyd2c2NEF0Y3ZuY2ZCcU5SWWg2TzJnQm5tSnVZWWpLWVV4NitCQWplQ29nQ0RJcDJmQ0JZWmdmMHJOeUlrSTVMNFdvTkl2aFhWRXJTQ1c2WnFEU0F6OEd6ZGpBS0lXeXVXS1pZaStybWx5UUkvMnIrenZpVlhUQVl1TDNJU25rc1VSMVUweWRaNUNYOE1MQnJwMjJhbjdaNUp2MnpqQmxZTnoxRk5TY25HaG5yZGJ2ZWkwVWxKOEJXNzBoV1BxVlo5eTg0TDl3NVBPVjc0eHY3YjkwZ3FVc1RMN2gvaGNSdWpSZDlKKzliOGxsb3VxMGlxSXZHYUkycTY2dXVTSVFPU3JheVk1dWJSd2JqQTRabWZFMHlBTnN1cGdpbktXRDFDTENzbXF0TnpDWTkzTk5kTDl0cHFrTWtYTjE5NDlWaGxKUHl2TXhPaWJLcmk5Rlp3azJPaVdPZ3ZzVHllcjhid21INFUvR1pJeEFhdVRFa2tJQ3dBdkFpaVFKYkZ0VE5PZkNGb3lBOUJWcHdxMHl1YUY1UDdDTHNUWE5HOG1OdzNsWVdGQnJMV0VHRXNaWkdJZmhwa1ROWHdqZHhRY3JBOGZDRHU0TytiUmJLaUZQcnR0UTVuTkJaeFBPTE0yTVc5aFVyUTMyT25YVFZqaTJzZi91SFlGUm9yNCthU2tISHpyS2h4RXZvb2lCcjRZYXdUUHpCY0hrd081ZkRQMlAwRlJWbnJjTCtMbTdRL3FCUjZMNDZaSE9JNXhHcWluVkhYUHR5clhUR0dSeEJObkwzWlFKS2hOV1BrbVYvaU9nYjBEYVlKa2tUY1lKME9PNHVGS3M5UG1lcmRzaWpxbkhEZFZCc0orZHhjSFIxV1RVdlErZkRKRnBGNXJsNG4wQm9Fcnc0Uk9aZXBkUUNhT01YbXdvN25STUFtTDkzSXEveU5RTkNwY2x0dkVUaGRGT1g3VlhNcjRXT3A0Qk53WHViNXJlaDl3T3lCaDdHRFcva0dSd3RMK0tKL2ljY2NVcDZHT3o4dFRFTnlyWUxqM2FSVUMvNjVVWUNwNitqdjNLMmF1RnduNXViUVBRMks5aWZwajZERDhiUzFSbms2QXdZNmZpVHkrRGhqZWRDVmJRVUtiNHArNjZsbWdkUW1CaFBnWGFRSjJzVUlZVUhZUmxhVDJsWE9BRUQyL1NicmtpdVZwY3JVdUlRRjRNb1VUdkhweVFBd2ljbzRyUVZpb1FZSUFpSk84VjE0Rkd3cG43ZHNNZU5iM1BkZ3RXWitlbnJIdHY3K2JlUEh2cm9sYm02eDh0dE1jMXZYQ0RrL3ZQb0Ura0pMSVQxS2pyOElqNWlmUnVrejM5aHhvclVlZXhTM280MTFnTTI0dEZmaHVvWklhZEdqQ0ZURUh5N2VIREc5ZU5QSGJCTnFCcnRWRzB1S1FHTUd3ZmsxQ2hEU2pHYWFpRVpockpHbHlvcXBUUGRLeWdsTjltekYwaENQcHp4OVRzZXpINTRNTE1YMkpXMTBIc3VnaXd2V05tdGhZWUZJcllvWWN4UkxQNlpiaWhNVEZZUjEyWElLNW9uZWFlVlFiOHBPeGMwZ3cvTlh5RkpDd1RxamZBWFBkL2xtUE9Xa2VrZm5zU1FjTHVQNTVPTGNLU283NXozRHd6ZDBkd2VtNnhzZXc1NysxZWxuV0FIOU9kWVE5d0J6dDRtR1dTSTN4SDN5WVZPbkloQW04S0FWZ0tnaEF1Z2UxWlFpenpkaW8vTGp4TVYvbUJWQkZ2SFIwTDdrOXUzampwTzhUTEJZZmsrbXRqYzluMDdyTnRaMGtDb0VzV1FzZG1jc0VGUzhLOXQ2R3AvY1c4dnM0VmxMdUN6cE9PUGJ0eWYzNFV1cSs2S2R5d1RSTXZpTDRLSjltWXN6dXNUWk1sUmJEUC9LemhpZVJRWFo1aVFkbjlvSFAzVVJiMWdpZmhKOUJYZ1Z1cVo0RWoyQTU5UHQxQ1BKSTFHSTFXaDUwR3JQTmNUZmFIMXhDL0phdVVoa3hwTGJNVnVRK09yNHBTTWZCL2p6UDZZcEZtUUVxUWJaTVpwS3dtVTN2WnFYbHZIN0RBOStzeXp4c2lpaDBtZ2pRN3d0cmpYb25qYlN5SHhma0k3Y1JCeHFLYzRQRTlsV1lQMkRNc205SENTQ2xtd0R1a1pwaFd3cHJBTERXZ01WaTViSE84cytlcTRoK1lBVTFMWlVFcjZQMmx5TWpnMXllZmJib0NldWt3QmNic3VTazJzMzEwUk1OSjJiZHpaTm1OZXRrU094V3VBM3Q4UjBNVHVZVnpEM01ROHo3d1g4WkN3eUU5R242UnNLb2pNdUV5NWFWWnBzd0VnVTREeUZkZldpUHU4MUx3dXcwZzVSUUJDVFdTMXZZZkYyRStHakorRWVCUHNHaXd5bzJpbE9lbWZaRjlRWWlDekF0aVQ1Z3FTcU1WWGRwaUpkY2xST2tBMEQzT0hOWkV3M3NKQ2xjT0tRb3V4VU9WN0FnMEdBSko0WE5VMlBxK3BHVmZCTU85R1B1OVZwTElZK1FxREhqaEVqOEpwNU5LWnVZYkh3QkRxSzZBbFkvOFcvL0w2WUplTU9KV2lpSVFpaTVDcWFhK3VTS3VLZncxS1krblpaMWlUUmtGaFJOSFU0d0VwQ2tvc2JzYVFtb0p1YWJmQ0JOWEtrWFY3QzVYeGpwRCtEVlhNMzBZR2FmdllnandkbnFTeTAvbmVNWG13cjZicmxEa2NwV3B2VnNVRjdXM2J2OTZ6eCt1Z09pczYyMUxGaElteEpLTmVESFhhQjh5L1grWGJDY3l2c2ZtSVVYVGM1YTdHbm1wZS9kNDFjQTJmaFMyVGVzRUFPQWdja1NoWXpWU3RoeWJZQ2tFSmtOWkpBSUtGZlBhc05sazRrVTRxUGx0eVNQWXVIRVU2Um45TXQvbG5CUnE4SkYzd2xsVHhSR3RTZVZheXk5U3h2NmM4cE1oWlhsMVM3d1pteVRMaTF5c3dvNEhEVkNzMEl5N2hZNjFqb2FVWVU0UG03bEs5RzgvSEszbm1TR29pZWI0dzc5c0R1SzNZTjJQRk11SVFZd3N5TTZ1MERWRWFYNi9nV1NONUplSEJ4VWgvWVBUQzRlMkJMSmxNdkFwMXpNWHh1bVZoZkpSSm1FL2xSVWs2d0d1R3piWDlybHdSRnJOQS9CMXF2MzdRdUR5T3V0WWhFUHE0ZjBaZi8zL2pIdzFOTjAzaDh0REM3YzdaSWxPaUJYYTlwd29sSTNhMTNSMC9nZDY2VHR5Zkpsc0xHSW41eE1nVmROckI3OERSRFh4K1NDTjlxa1dEUmIyaEVjZnhHTDR4K2VJNnZpcGJQNC8yNDVuZVJKQWp5QkJ0Nm1MN21Da2VuVXVNbDh5dDdLRHB1RCt5Nll2ZUEzWHk1OEV1ay9VOHphTFRWL3NySkxmam5PMTh1YXZWNngwczE0NnRnTGdxWVZKdk80emtyMTVWL3NKZjQ2KysxWXNxQ21sSVhsTmp0Qzh1TGlGaER3aGRjT0FJbjNNV0ZGbzdnTXRvYVBiZmFYRENFNVltR2tvQ2xiVzlwclVkY3Y5YVByZkZjNURYYjJJczM0Q1R4REJsSVZaUUxYeURlWC9IMkI2UHV0Wis4b2g3Y2lhWmo5Y3ExNXZ4YUQwRE1Xai9HUkdzR2lNNzFsRjhQTld0NFJYajFTeExXZ2k0akQ3OE1xMGQ0M2p6R3Fkd3gvbGFjMjQ4b21jVkQrM2tlWWkrTzRaTzhRcDlQNnFNT3o2ZkZiOVowcmZYaThCdHZXZmM1TzliNTViYm5iNFhuVXdMT1pvMUw3UmllNVFLcXdRK0V4QzBIM2RQeEEyamplcjlBNVZ5RzFvOUx0TVJtelFldFoxdkVPWEh0WjJCZGI3M2ZiV0RsYjhYOWJnT3pIM3k5U2hRbnZ4bVdBZFlRVUlBSUYyVU5DSXlDQ3N3RE5ZQWhKL0VMNEo4QU5wQkpDU0F3eHFpaGYyS3NES3JrQklVVHJPR240Sk1BcGhqNDdNekE3ajFYVG8wRFpKakVJMjVtZUU5U2trWXVuZW5qa0NESXludjh4R2ZzMkg5Mlk5K1JMUWVsMnEvNm0zSmMxeTNmc2pTbmJCWHovYmpUZHIwM2NlRkFVQ3BvNmQ1dHZ2RDhyb0ZCWnovUGNvQzdkYkczZlVCTGFmTURGOWVBL2RZdy9scmsvczAydzFOWVRlbm1WU2w4c09QQ0E1T0FmV0RoeHl1Y1Bwekl6eFM2cTZOOW05eHNhdS9sQlhkamliaUZTVVRYL0NxdXJ4alR3OHd6bHpNTHpDdGh6WWxPQVRRbWpnUmVEeU9JdkJtZ3NUY1JzS0xVRDZqY0xTRkFKSEZkVVdBNktLRnRqdXhCY2FybVZ5alVJQjdkcE1nYkxHS1VoNTBLTVNDZjNIUm9JeDdMRnZIZnhrTnZ3R1BZSXE0VndnUHlaY1JqTlRlelE1Qkc4cjRxSkxyTDZmdlQ1ZTZFb1ByNUVVbllrUm5JN2pWU3FaY1RRR3YyOWE2eENOWktuR0FKZnBqRkF6dGEzbmhvRXp3WW5vOS9KbHlpbytRaXBRaGh1MHFTMEYwY2QyeXVKNUV1bGRLSkhzNTJ4b3ZkZ2xTNkw1Tk05blQ3V3JldnNJdFVpM2pLNzJZVnZ6dmlWY1k2MERLak1BVm1GbjkzcjJSZXl6ekF2QkhYWWpjdWFFV3FWYmJnejQvd25vS1dobFhVS3NBcEZPRlRyMFVuUkhxQ2hCS1JFeGE3OW5HaEVWL1VkbUtFeGYwUjdLd1JWSzZFUkx5UEFsU1JnaE9pcVhLR3pxb20wbFA0QzNFRmdROENYaEJjanVWVE9wS3ZsMk1zeXhvYzRsbmJaZ0dxRE8vR1pNUi9kYjBUNkhYcm5RbnYzNjRvNkg0bHJlQnQrSG9salp6dDRhKzNvOWR1djNFN2VvUEJLcVlJUUdDVkJPN2RzUlNXNlhRZEMzVXBsNVg0QkdkWW5JQU1oMk9STENPV2N3d2tjQmJIclhuMHoyd1cvN2dld3dvRC9rR09qZUhuSU5abXcrOXR4eitPMzBDQkxYNERWR3krUUdTWC95YUpSK3hsQmdrbUxVTy9Ya0M0S0RlK1ZTOG9laE54cVNQMnJGd0VGQndoTHBsc2dRQzVUQUVST01TSWsvTVQ4VXAxUWtMSExDL3BidzJTbm5YWTh2QThnSHA3Tm0yNGIzWmpUOFd6d2wySERxSFB1N0d0ZS9mdTI0cTEwRU5GdTMrNDN5NGVPblFZVHhpZTlZbWhkQ0tSSHZvRWx2K3RhM0pEOGJuWnFWdzJtNXVhbmZ1eTVmVmNjOE53YjJrbW01MHA5UTcvSCtyZUJFeVNvNzRYek1nN3M3S3lLdXZLdWl1cnF1dm91N3FycTZxUDZlNmE2VGw2Um5PMHBORXdPbWFtZEtIUmdUUUlDWXZEVUVJQ0JEWWdDL0hoRDZQbkJvd3RHekJqVG4xZWpoWm9EZGhhUE0vV0dwNk5yZDZIL1F4cm5wL0FBck1ZVWh2L2lNdzYrcGpwRWJ6djdjNlJHWkVaV1JrUkdjZi8vUDNEbzVWZEJTTVFNQXE3S3FOSGJyakJ0UTM0ZjBoTXV6THhCT3hZWTFKemdLNmlsOElvbFByTUFqYUhWTVR0QnF1QXJ4bFR5MU5HSkdFYW1VZzlrakhNeENscVVYZVBwZ1ExcGE1b1FVV0xHVXFnR0ZDTUdKb3lVd05UVXdNcFV5NUdidytrK0ZPUlRDWnlpazhGYm84Vzc2TjJjL1kvS2RvYkZFMVQzcUFwdHhzeFdZNFpqSXVEQmZiSU1tUGdGaXpBQ3RSaHB4eXBIa2VrVjVHdVgrc0N3VkRqS0xZT0p2Yll5VFFMaHRlaXRFWUZlR1VuL2l5ZTNYN1RQN2treGFXbFNaekMrV2dSczExNmRHeTJPVHNXMWNPK0NtcFJlZDBxTmF0RkRDNWtUUXpFbGx1cTJscU9EVXhZK0lKZHpOZjNSWEtEQ1FzL2hSKzJFb081eUQ1SDlrcnFEOWpnWlBYY2FVMTNWTGUxeTZnTXRidWZ3R01oak5laktpQkZqTEUwS3BNWkpwdHNiWUh0ODVzc2JSUXVva3B4OTlHbGNtNTJRR1ZsVmgyWXpmWGdQMGNVeVRBVlhSbEtTd3FxbFBZVVVYR3BOTEJZNXArSjhYenNHYjY4ZUxpTENuMWVVa3dEQ05EMGtOTHhDZmdoN3FjNXpDdnRBNHF1b3kzc0dZU09sTHpYVHFWSHUraFludVVicFd3NGEyWWxNNHY4VDRIQzZpbEN0VCtoU3FPQ01DcXBUMngxTVduWjcwZTNtL2I3TFF2ZGppeHFGRWc4VVIrWHhuaWRINVBvSlVmdDUxeXltbTNMY3V3Yi93N1RGeDhsbU4wWkVsZEZLaFZoU1FiWkZxeklRRUVRK1pacGxDU2pZUlR3Z1EyKzlmLzBlQjVWMUpUZlRkaFBySzJ0dGxHNzNVWlB6TTF6UXBQM0svYWFFWlRjREdvYXdjRzZ2WWFiM1p5eDE2UVpmSEw0Tm9iWUFFMFFGTDJwVXFQSDFhMjdGNE1UdUNzZzcvdlloVTQvU3lUdVZoNldNd2hFV3lVeHU4RGpJbUwydXFnaEs3UG8yQ09SWUN5amkrVkpGd0s4WjFpZ3EwaWh4UXkrVjFnbzgzNGYzeHpCdDNjTjgreFFkbkhVZWY2RnlYSW4zWG1BQUljZjdJNmF4M3RmbEpzYlFNTElIUDZwa1NhdkczekNNZGVtL014LzRDL3dQTHFHeEdnQVcxT0gvdTB4bUlVcHA3TnB0aC9IbzlwRHpncDlQb0YvdHdBaFEzbmUyay9la3hYenlVT0hHcUZRNDlDaFpGN01rb3Y3TFJwT2RJR3pQOVh0Z204czBLQ2oxZ2hVZjJSeUlFR2VtZzRHa3dPVDlKcEZ3NUhpVjl6ZmJTNXB4MHQvaHdyb3k3UWRqV0pQWUtQYUJzS1kxcm9McVJBR3Npdk5MckRGdnUvOGs4MnY1TGV1SDI3Ymc5MUcvTTNtTm5MYjk4aWY5cmJDNWRjZVJBL1NkblQ5WWJwUkFIb0habTJxMU9pMHJuY2M5M3RwM2tlSHcwU0dWaU5qbHFydUFNeVlHVnhGM0x6TUJCMFYzKzhaa1JUOFlSTGFnWi9NUkYySSt0SmtHVDlHR3BlWkhITUdvNzNhMDVSdU93WUlwa0orcTJsVjY1OTdXOWI1VEhldVpNNXNWOE16bVc3RnpveHVWUi9Sa2JPRDNXZUt5VExEVEkyNTlxS2VMSmhZTVkyc3dSa3VEbk9oRTN0TzJra1k1UXZuU0VUQmMxMVorbmZhN2JXWEdDY09IVnFqWjl5QWFVbXdCSW5FV093a1VZczZhUFlhdmxpV0JZSHM3QXRnKzJLdkFlb0xDTExhbXg2R0pOTWJnMFVqVXBRR3dSeloxdW8waUh1QWZJdmlWaUZaOGx0Y2MreFA3NytsMy83VXU2cktzZ3FIZUc4NGxzZDdNMkNKZXIvemNLOGw2dGY5K00vNXZoZ3NmWm1PM2hsWmVIOWVBcStyQWw1eUYxeU1HNHBqVG5rcWdLUjB0KzJMeEhyZnVKa2phNlFRaUhLQVdjTkxpQitlSGVZUjFkdHcwVUJoQlBNN1U5REZVMlRrMFNSbWczb1c4aGVHOWdjODJaQW9pendvNHpBUEs0YXluc0QrSWRqamQvYzhScEs3Ky9kN1IyOUxmYlJCL2x4bERqRFhNL2N3RHpIdlp6N0dmSm5PcFY0L2RtNUQ3Rm16T3pwcjFUNXpvcGQzclVCQVd2cUhlZU9YdUliT3VUSFF3T2pHeFROdTgyd0E3M05ETEI4QVVmV2wwM2I2TWdwRGVrdUhPQ0lFbk1XOGo4anlGWjRWK1p0MmtQYVRJMHV2dEhhV2NiQmN2b3pBUGxWanBnQ0J6RkZKT2k0RFFLUDNqTk10VW1UMk5ZRG1rRFpEeGRmRzJCNmIvYlFqZFNENVZVck1SekZWUGd0OU1kdDd4QmZYaTN2S3hBTHNTVGpzTGU4cGtwRkpSS1VrMVpvdXcyL0FBVEVRd0lBWW8xbzlSN2c0TURDNGY4UVo0TTdRSHRrL09BQ1pBU29vR0NCVUIrL0V2Vm5EbkVxV3VSRjZvb0NKcHFtZTZrdGl5Y0ZZckZFY2VKTkdseE4zMFBEcVpLTWtrZ0huZ3JkZ2NuZWNlRTlOb3ZmRk9Bb2VqdGkveHkyM3BzdlpLVG1GZGdsNGYzdXdVTm15Ri9JanVVZ3NVNTcrSU05RE1mUmYrZlZXTVc2OE5hWjU1WWdQQ250VFd2aHIwQVZ2czM2L1BEMW9wZXg3Qko1dnA0VnRPeU5oQnFiTEI1OGdLUGw0S0hQcUYxcUQ4V0wvR0lrU0cvVk5ZeVQxcXhnSEwrdXJyMTdPVjZhOHl0ZEp2QlVmc2NoMmRTU3VXMG0rMGRtSThNb3I5WVpmK1UzNHVlL0I0ZUh1NW1CMVkyLzlzU1FRdHdCOENIUTNucVZ1Z0MvMy9WMThvWm5MUVJnU050UjB4NGhEOWdjNk5iOEUrRkNnMndSM2JTQnJ2a2swam94ckpFcXd0U0lFU3BDNjhmWGFxblFBOFNMaFRUVyt3eGQ4VDBoL2g0Ny9CUjhOK2g3UjlZRHdpQ0MrQjN4QUlmR29pSS8yeDd2Vi9aU3VQOUo5SnZTZW9INityeXdrcnV1dGRIOWNqdkZMV3l4SS9UeFdGVDNhb3gxcTlYaUNySFJydGIwcHdZOTY2K0xJM1ptL3huVmhDdjNPVmxYMEdTTEVKd1RsSC9kMXUrUEgzU1J5RXcyUDBoRm1GeDZuTGloY01CK3VCbW1qM0MyMjJqRDY5MXVwUHpKZ2JZM2FORmh0R3FLYlRLNFg2WFlYb201MTdwWm5PZFlVMVJlUUgxZVB0amNxU1A0ZUE0eFExekNqcDY0Y0V5UmFzU1ZBV003WEdoc3BnaDVxQUw0SHQvSCtCb1NkOWZiNXpwYjhvbE01UlVvKzZkYS90dXk2NEtEV0N5KzArclpScTlkdUZtQUJ1dTJ3ZTBBQ09qcFRVbjludkZRMytKa0ZMOUcxejNUcThXdGJkbWdQYk4yajIvUWgxL085bzB5NTkxdnY3THUyTC9vcGI5N210YkRuZGV6RkhRbmpSbHR4Q1dlemVOVFdjRGFMTDNjaWM1b2gxeXFsc2RuY0pkeG4reDFJRk94bUlaRW9vTFZDd2w3UGpvL3ZHUi9YbEQycWFpQVczR2drUVpLcFJZclNiOFc5RGsrMTRXQlJNZDV2cWFxa3p2YmFrNXhRWFp5eGJqc3UyWW91d09LMjlid0FsZHd6dmwxOW1uVFhjdW4rNytNMU1zNk00bGt1MHFEb29FZHltVXJBQXF1UHVmS2E2cVJEL3pjd1ZmLzB4SFdOa1pJbTZyb1pKZkJFKytmT0RpaDg1SE1VSnpBY0dxM3Z1WE11Yy8xVlNtbWxPbkk0TE1kTmppZWdSSk9qbm9UL2ZvSkp4TWV1cisyNmNjeFRHbkY4c0Y1aWdjY0ZyTTNUekMwRXVUZ245V2h0d0JHN0sxS0M4R0VrUzRhVUtmWFdHaHkraS9XRzZVWi9aeUZBYXpoUE5EeFZBRVRGaitpb2tZZEFZeWJJendtK0t0VzJVUnhDSGJGTVBCby9EajI0UzVPc2hLQWNodW13VlBxTUhvcmtLcUtLT1U0cjVBbUdxZUo5Wkovbkdrbmg4MW5EVE9UbTlzM20yZnpjTmZYajlnWFk4NzFhZzFlVU85U0pEMzEyLzJvMDlvVkNqVVZCWTRZbzMxaDJ4bStVcHhOamlGR0hkTFdpNnVyUWlFeUJBSHl5b25qVlVGQWlSZ0QxSVZVYVBoeExCT3FaM0d3K083ZHZWLzZXc3YyUCtITnl0OHIrNUVDckhkL3pNRnNybUlQNmFmeXpQUDc1VStKME9URWFjL204THlEUVJVYmhlNXNsRXBuQkFBRDRZQVJVYVdhRUFzTlNtZUU0OUdPSks1TGgyUGpBMExnblk1b1p6NDg5Yk5pL2UwalNmQU42cXJqQUNnTXNpK1pmelhQY2oxbEpZc3UzVG5uREJ2bzFJNkxaUDlNeWtkdjF0T2dUdGZQdkUxbjgyK3o3WkE2SkhDZlk3eFE0cnVPWHdLQm5tQlF6ak5jd1FOQVNRSFlKVkNwTTEzbFVDTHRwNGdGQ2drbTRTSkhCV2lITTlWMUJmMk92cTFxaVFBWTVzcHhFd241RFlqQWFOdUZ3RUZuTlRnWjlxY1VaZUpyNEN6Vk1pLzFENjVzMGdWcitvQjJMNkg2UFFnNW9vTmxxMmwvb1huRDdjeDFsaWM1K2dFaTFxVGtyOE1jZDVjWkdYcGdJVm5LekErVHo5c3V4a1ovYW5RSmIrejRZYWUvYnhNb3lhc2ZIS29SMzF4eUpETENmT2NHOGtua3Q4N1l0a0E5SWx4bFZBMVlOSVl1ejREclRSelVBU3lsZEFyYStkMVBaS2gvZVVKNHRnOWR4V2RYeDB2MVRRQVQrVjhEeFpSbDdua05yOWwyZGpURFdibHZPbG80UDY5dERiUFFmVUZ0WFpieTRmUytVeElzYlh2L3M4OGhQQW9BcnNvd3E2OTJmWEcwZjcvZ1lkUS83T3FtM2RsSnpYVjhrM3NHaUFWdVpIS1pmV3AwWWtZNWJhMi9uOXVxdCtxQWx1dUFyMGc2QXp0REt0U2c3bGtYWGR1QnBmbzlDUlB3UlJha0JaMVZvRU9heWw2Y0Zyc0lKMDREMjFrMmlOcytiMmF6Sjg3MDBuVVZCSWFqVEsxQjhWSXVnU09jM1BPNGtHYVVUendUa2VrVzhDcitXZVQzekpvSlR6V3lBdGVzUk5ZSk1RM0NDWUZVYnZRTXMyL2RJUHhadnRrOVJZRkF5aWo1QTRYaHBnUUlteWJMNFAzTFBqeCtYaEs5RFE1eXovYytycTRoWlBZN1h5L3NjaXNaZW80U05FQW81VjFEVHZXS0Y2SDI0QlZkRGR0dENheFk5SW1iS0dUdnUyV28zOFNBOTN0cjRneTh4bTE3QndEWHlzODY1YVlHUWNSV09WQTcxUExzYnJ4ZlhNTmN5cHpDbmZpdlJ5MytFK1FQbVl4MHEyNFdqclBabit6cStyeGVyRzdOOVVNY1M3akFEd3FYZy84RThqVXphTFJidWVEZ0QrRGQwdEJPb2JFUGNNcmNzbENyaFBEdmxOTG5sdG4xOVkyZHN2ck5LQks3UUYxWUlpcTNUMHV2UzJ5M2M3WkRyOUhHcnAvczZ6MXNiWDdHNi9aMFcvQ1IrK0NWOFdLVTMzQk45dWRWYnoxVnB4bG9uK2pTMmoyKzhiSzV4WjF6aWpsaERhamU3RTZ5TURRdjZKcXlNRGZjaDRwS2p6NHhJTmFrWEsrUFBYb1FVSEw3VWc1VHhsYzdWdlM4VEorTlRtM0F5WFA1OERlLzZUZWFraTYvYmNiZ2pjWUJLUlFxNFN4b3dDVEpwaVBFQk5FQ3BXTUwwUUdNQ1ZHaGc4NFNiNUhyczVTazVRUC9peFJsOUtSRXV6WTc2b2g2dndLTkNMQmN3Yzd5YUt5MDNqeVdHUjlLeE10Skw5bFBUcVpBWWkvaDVQUjZ5RkN1TTV2Qm1IRTJIZzM0OWtCb1dwTEMvdG10SVM0VFJXbWlnVnRaTnI5L25EWWdDNnd1UGNSWVltQjhjcngvYUxjUWFVOE5IVVNvU0w5aldZR0l3NEZFTFBnOGVPcElnVHM2Z04xNHhYSTFIRlhra1kzaTBpSzlTTDNrQ0lJQ1hTRjlBYk5RUXBzeVN1RC8yVWtzUUYrVmt1QmRRQS9acm9HU0ZqZGgxbXdIcmFpU3NWTGFXaFdsN2pyS1Y1eW1UOWUrcnErdHJhK2luc1BULzRsR3lBWkJ0Z0QxSDBuYXIyVVFXZUtIaXhDcXgxdXo0WTY2dHJxKzNOa0dVa2lUOXcvUzBhYzJKQjdpYjJjY2NaSTVzNFhYYUh4UHdNaHYxNkRhaEFMKzl3M1loeG0wVll0d0FnSmRzSEVmaUtyUG9xN2hsSm9OWERRV1JJQmRnd1UxTW9CcEJ6RE9oV2dhQlVSVm1XUkM2WURjOWtxcjlaaWlwN0hxem51Q2FyQzlxLzFQakQ3LzVOVjdtWDdvWHJhRXYyTDhRb3hGaDlwVytBT3M1VkJQOVB2UWhiMGkwMDllYStXdCtnRXY5bDNITWp4Qjd6aStqLzQ3SENtYmdUS0thcVRkY3Q2SmNiMnh5MXgrcG1KUGN0SE5IUisrTFZRSXh3NGpoaGUzNFhPcjU4UHhRK0dNY1VXWCtrUmJOYXMrSHlqTmgrMmZKbVpYVTMxS0o2dDhHS3MxZ01MWm5LWXFrMU54eC9NalFmUGlQcVB6MlkxbzJxdjFEZUtZY3NuK1dXcGxKL2kySmVjcjliVERvcktmUFkxcnFRNWlTR2lLNkZzcWh1Vlo1UnAraGE0L1dzb3J1ZTI3NDBQRFF3V0VpVzlwRmpsZmhOZnZ2c3ROWi9BK3REaDI4NXVBd01TZEZqOXJuNkptVXNyK1huZDR6blhYa08ydkVOeEE4Z1E0eTF4T052RE9keGtDOTFaSGtkSGM4S1lKSFZzVHNFSFlkNlE4eHJTTHlZVElvaFg2b1BWaUNQaldsQStXMUpNVFNNV0hKZ1JCZUR5VUxITnZrdWE5SkhvL3U4ZHdPUTg0cElpbm5Ra2xBZ1FPSUQxMWRWdXdwdllLcDJrQkFwNXBLQWwveWc1REM4VTJXZXpzOHJudnMvMFRkOWFFVXBndVRvUXN0ZW1GWjFTOUlDbW4zMTUyNDNERW1RYkRSR0lFcUpXbjNsem9NQ2U3c1JyaTBTZWk5QVpDOXh4L3hmVjA5NDVNcVFWQ0N3MDJkMUhSWHZ2elRyamJ6ZDliV2VKYnNLSDBIeXYvOVgvZ2JmYWl6eHpHbWc5WG1MbmpCcnVTTnlKT0VTOXl2RUpHUjQ0UGVjdkN5a0grcnF4blh4aDRvNWw3cGFXVzdHKzdhUm1ua0JieEtuMkZleGJ5UitRRHpoMlFQNjRTeTYwVDNJMWt3dldyb2RDOERsQUxNY2s5RWFBWXNYQ0tOQldvQ0J4eXNzNEZKYWJaQlJCTjRsTlpwTUhEaWNVVWMyREVKQUE1WnhQb1huaGhEUW82RWM4c1I5MnFuU0lNQTdVT0pSczd4dnpTSllBTjlKV0g2UzVtQnVDa0labnpBS3ZyTlJNcnc1K0xKUkNqc01RYjloaWVVdFRJQjFmQ2xBNGx3S0pHTTUvSVBCVUpHSUFxSFBYeHhJdUtSNUhoOXJCNlhKVTlrb25naUdqQkNBVGpjSjhyWnRLRkxpcEVLb0NzOHVweFgvRWxESFZCOFdsVGhKL0lEdXdieUU1SVNWeVRkU0dkbE1aQkNoVUFxbmF0a3dNUTFVOG1sVTRGSWFIWmExK1ZvWlZDUDhKem84WWdjcitqWmNDVXE2L3IwM09EMTZWQWltc2pnUS94NmF3RDVRaU9oc0ltWjdwR1FueDE0UXp5YUNHWHcvVkQ2UTdxcVJ3Y01VeFdpQTk4a21rTnlVQVExc2RlTXhjeTlDYnhjUENhb3BqRVF4VVh4a2ZxNjJ5OTlpV0N6SklsbEE0TzZnU0JjYXhlVDJydmk5UlZKRFdRMnBKTGpNWTMrZXlGWUMwN0dwWkQwRm1yUjhjYXcvVDB2OG12M29sYlFmdE1wRmZtdlBqaDU5YVNTVUlvS2VxUVFERTRtSk9rdDFDYm1qU0g3ZS9kcWZ1VEZaV3YyYTlWVGJtRmNOdUhLMTdzNmdsSE0vKy9hUWZ4dU1ON0YxV1dKYm1heHI3cmJBa1l0YVZudE96SlM1UVBmMGJSL0tRa2Z6azhtOGdsV3d2VGM5b2hSU1UzN3pnRlpSZkozOE5NL0VVb2ZvUS9oWnlTM1g0RzI5aklCM0xmZ2YwNzdFQ3lKSks2L0k3MXVud1doUS85SGY3OGQ2WFFTdmh1MEZ6WjFGTys4YXcyL0swVThvY2hYbExxZmpYeEZxWmF2NVJzUUhnbC8zMFc4TFZYRGFNT250RmM3SCsram1JTDliSHE5a2w5UGYwYkl6YVhGVUw2Qzl2VjlTM3UxKy9sZUVJVFBwTmZ6bGZYMFozbjlUV0o2TGxUSjArSzBrcjExQkJxcHRMR09Qa1NxeDBtWHJOcTlVS2t2WHFwR3I0ZksyRTlzcm9sakI4bnV3WFVwTUdQZ05ZWkVjRm1XNmxUcUVURU5kMytzZCtFeXhsREIzU1FKOVczVXFTZDNBekpzZWFCNjdNemR0L2lTNVdSQUp5UlVmbkN5dm5nb1ZUdzRLYkw2TDE2aVFaYlEwWU83VGwwek5MNXI4Y29EOVpHUm1WUVlJVm54VHN4cWVobVBNRjlNc0c4RkVtekY5QVU1emk4RUIrWWx3L09FRXgvcXYvazRZUUpwcWlSbmh3d3ZPeEwzQ295QSsvVjU5QmE4UG9QdGJwekpnOFZVWXpPdTV5WjdYb2hXSXRGZ2JaaW1hamttdTdGOGZqS2YveTk5dVh5YTUxajdqMWdPenVnRXUwNWwvQitFZTVQNTcvVGwwQWNsRHZOUkVvZFpLaklId0JibEszaGZYb0Q0TXdXVDhpd0F2UUFjV1FZQkVJQlVrc3pKdWtDcHVoSnk5ZTcxaGhPWlBJUG91aTZWVElKaklwa2lLcGt6ZS9ZdWV3ek81RHpxWFdwSUd2SDd6R1IrN2k1enordVJRbWsxTyszbzNOTzVTRjBXK0RFaDVMbFYxYlBXYkQxVFQ2ZHZHVHRvRFpubGNFUlhiL1dFaERGZWtPdXlhZ2I4QjhkdUtZMVNVaEQ5VjBmSi90MkIwUkVwaE4va3dXODAxR3V2T3JiWXNHWVBIcjdLdkd0dW40czUwNHR6ZDhVT1Zxb09OcWZZZFpGeDFCREErSlVhRUg0SEgzVjIrNVdyTWVzSjhnbGVrS0x4Q2Z4UmxVVlY1YnljWDcyaVBWRDAyai96N3NxTk55SkRzUWJhZmMvMksxbmF5Nm5xb2hJVVF4UHhxQ1RnM3d0NlpsWHZvY1hkVjZoKys0ZU4yRkNrWHNudDh1NjVaemRabDE5NjhhVXZvVC9EM3pYRHpHSSs1eVpBTDJwQUM0b05NMEpRMlNBZUN3VkJjUlFOZUMydWtNQkM5Y2JraERrWmxrTDVraGd5RzVOaE14U0VFSG9SU1NTQnRodDQzUjREWlZXSWdLcVJMWWlxYVhMUVErUmlUOEV2NHFvT1J5TER1QmV5dk9UWnJVYVVwYWhwUnBlVWlMcmJJL0daM1dnK0VnNUg1dEZ1bEVWN3crRzlLSHVMeUNFQUVVYVlDZEE0UmVHMGF3V2VLeFE0L0trOVhEb1VTbk9lU1Z5R0M0VWdORDIrbGtod250dFVEUWtIRHdwNEFsN3BNY1ZCa1pPWHJqOTU4dm9sbWNNWjArTWRuTDk2WmVYcStVRjBKWkxtYnB5VjhCbGRKN0l5Ny9QeE1pdnlTUERuL0FJNkFRekQ2SDJqd0lOdy9NREprd044UmVRVUxyNG5qbys0R0o4L21lY1I0U2Rzb2kvNEN1YTd4c2w2Nll3WDhJRHFIVENOalNPR3VLcWo3M1hHZGZ5cXFaN2g2M25qSFdkM0xlcjJQang0ajU0ZXdPTjlkcVoxTTNxeU01ZW1yb3IzVEppRitkdnUvSFhWc09md2pCazRmUlRQc2RmY2ZPUDBMT1A0MW9PTXo0OTVlY3VOcHRieFh1cjZMb25FOVFndjhNUk95ZHdZRWdTVGdBUVBoSHA0bmV0cUNTYmRVRnZyeEhIb0JQRWVBZ3VZVCtkblA1MkhGRnJGcGRmSkUrUmtuOCtPajJkWHJITnc4anVQNElPOW5wdkREM3c2TWZucEJLUTZtQzNFWDIwMzhkSE9sMXkrdStSZzBVQ3NTeWNGdUVnZ1hscEVFYXBRbTF6c1FPbzM0Qk5NNFIwa0wrVUJYNnVFVDZVcXJGWndxbEo0d0R6NnkxZmxnSFBMSm1SZlhmZHpTU3RoeWI2eTErQzhmcitYTTd4bG40d3ZKVG0vWHZmSmlTeVV6YjFxT0ZNcVpZWWZ2R1VzVnd4R3M0T1pZREF6bUkwRmlybXhXeDVNUmxPWldCd3hGTngwVWc5cnF5dy82dzE2bDd3Vy9oOUMzbG1lWGRYQzNpb3AwTlFEellEZVdsdERMTXNmYk4xNENQQ1oxdFprTmFVNjl0eTJnNEU0UkhiRnZOdjRQRFN0U0IyaVNCZFV1ejNRYlhpZXRycEttaHdCTTVLL3ZPbVU3Szk3L1Z6aWNGTDJsM0VpR09UODNySmZUaDVPNEVUZEw1KzZpVGJ3ZnR6QXR3MUE2d2JlaHB0MmYzNXNiQUF4bi9hR3RkK3RZaG8rNUcyMW9EM1YzOFd0K2JUYmptYnJ4dDFyYXdTZ2srL2pBd3V3QzI3UEJSYW9zQzFDQXUxU05GMmlETnlHOTBPSHoydlJxSFplV3hPNXQrT2w0KzJjdURYbmQrUk9TZGN2NkxwMHE1UzgvbmZ4Ym5rbEppR1BzRzZNMmkraXIrSzVySVBQNnlqRXBjV2JReG8xQ25oeGt3U1I3QXNtM2dYUmsvYXFub3VhZUxscitUMGV5MTZWL1FaZXFPWHZYMUNFV01odUJlS2lja0d4ckxFTFBLWW9WdkVpZDBFSXVIdlFHbnFRWUNvTjRoNlljWFZreFA0UE5IWFYyZ0xyQ3R1bGZOaU41cFd2WlV0T01OdThjMFpuYmFKeGw0dDd5bFo1VHhHQ1RnWXNZdDlsb2VZS0prZldJVlNsUlZTNFlOUjE0NDFneWtXeVRZdmFjbG1XQTRkTWp6MDJYVTc4b01JT2JLSE5iZTI4d0g3N0ppSUVJUkhST3NrSHRyVDYrck5ONVNEcDJjNEFyTi8rNjhqbDJIK1ZkbUxodlZPYnNIdTNidU1sN01QRUxSdkxiTElWdS9yeXBmNDdzbC9ma1dhZ3RVM1RkcUl3MkxOZEEvdnR5cFoyWUZlMkU0WGx0clptV3pWQXVvamQyVGMzVjdwamcrYlVPMC94Q2k1WnA4OThoVHo2RmZpVmJ2S3ZOdVNkSk5tcnYwemtnM25tRUhPQ3VaVzVtL2sxNnFFTnRBTUpZOXpCck92Z1YwRytDSjUveEJ1VFlBaFNEenJpaVEwR1JTR0NZVWMyZVdvK2p4K2RsS2FLWXJqcndOa3hrNUlvVnpKWlIvc0ZrZVBDVmkwenNzQ3lKc2VKQWl1eVZtbnB5TzRTUWxsV1BEdC8yNjUwYW9JRFNxMHdWRDF4OXJyYVVBRUlObTRpbGQ1MUd5ZEoza05lU1dwYmxpV0pvdUFYUkZHeUtPaXhSVzJ0M2k3TEhKOGV5RXlsRVRzL1VySjREbDlBWEtsYVdpb1dkeGVuQmptRWR1MjY3WFZUa3ltVzUrSWNtN2hxdlBxS0tiWjZiVzM4eWdTTHIvQnNhbkxxZGJmdHNqOW9qcFlybGZLb09USWlpNkljSENxYXVOTEZvZmRUZ09ZRXRkOXk0NTBBanh2RS9PMHA1bTNNWTdpSGQrZ1AwWURkQ2ZkK3RVNmdoaVlvNGhEWlI3TlVTTGFJcU0yU2t5RDRqU1Znakh6RTl4dDRLMklCUkljMitKSVZJZjV4cVU0aU4rYUpUd1B3RmtVMDNldE44WEJ2WmtEUFJuQlA4WmxBTnBZTitLTldMbXZhNXlPNWlEZXRZcnJDSzRkMGp6K0hyRmpGU2hzWkphWnJ2SnhWVmErWnFPWFJ5c0JVUEtKRmNjbENuTlgwcExXeWh1bHFvNzVRTnpoK2ZYdS9qTFZneXZJb0doSzl4WFRjOEVVek1XczhtNHRrZEFXUGlvd2VqRWk4SkVnUmJRUVAwVUQyT3F0a2VoWE9Fd21PR2I1Y0p1MFpTdURwTWhBYjh1UVhmTW1wQVNFZVMvb0Q5cXJDUnhPSktPQVM5TWJieVJDa29XdDJ3SjNWUVJyNXF3aTZRK1hWMTVqODlOR1hHWG1IckNVL1NGNVIyM253SGJxZUFFYm92QnRsc1VmTjdzU2hKYXdhdFgvclhXazJxS0hRbEYrUVBuY0h2T0tPc1ZJMnd5dVlLV2I1d2ZIQ1hKWVF0TGtob3BBQUhQMFZTVmo0QURFdHVTTTdHdUpZemd2Y1U3cVd2WXRjL0IxSjhEb2VWa3czZmlySVlXcTR5ckNvME0wZTRMQ0JLSk5jaXphUUdGTnBnR1QwMjFhaXQ5WVdsbDc5OW51WEZtb081dXhZbld6ajlURUtSM3V1eDdMenNkdzl1MkhIZi9WYjc4a0JMSzJnc09rYnA4bkcvNXBXQ3RCbEJmWjdpQlMzZjlyeE42QTBWUjczNUc3aUgxamR3ZzlvdzNyZHBiczZROHhWK1dTTmJDTmJ5NTdkMnJLRmM4aXVvQmN4M2lCUVhaT2d3U1BPVysydDdWZ1E5Wm0xVndGeEFRd2hJV09obHRYczJNMCtTT3g3NW9odCtFVnExak5BdGtxUmVuY0l3NzRhbnV3R1pYU09UcDNSMmxhVmF4SVJXZDhSMTlaZFA2R3ZLVUxBbGJpK3RTa0tlb3hyM2JNWGRpTGRVSXNjTTV4MTFLUmRXSG84eGpzRllVSzd1eENlVHJPUytqZXFYcDdXMVdWcU1icXM2dFAyVTM5Umc3Nm1HbE5xVDlvc3htbUJlREZKQWNBUmM3ZUtuOWZWSjZmTGp4QzdMNElUL2toNWVyWDJzZldXUlMrMDQwV2FLTWI5RkpUSnNmbWt1bStRMWRYeGVMcCtLMWxkZ2RaL3d6anZzeUFhUXlaOExJalQ0a1J4aGw4WmRtWDNydlhEbzlTR04rdWduVDhPdXQvMXJwYVhwVjJQMld4NzdZWHN1RjErRTRSdm5veThIcGFiVjVKMGlCWGVoVXMzcVpWdG00S2ZXNHAwSGtYaFIrd2VyZk9UbVB0ZVd4M1B2dENBVU02WU9ZQnptU2V2NlBMYWE4eHA1ak5rVnhRcE1tNkRIdXVPREFNVVNDNUlKdHdvR1k3aWlHaDhxTzFqRHhZZjBUWFZxelZDeG9EUFhxUktwWndVaGhOK0RYUHJlWkZFdEc1UXU3WVFQSi9QNFYrK3lPK0NZSmZvckp3STJNVGM4aitDZnRYbkVTUWhGSjBZV0RBRWpsVlVRUnEyOHRHNHhLc3lZdVhBZEg1MGZyUVFTWkJtNjFvNDdsVUZWbFo0TVowSmprM0VaVjdTQkkrWVVYMTZ1bGhNSzRxb2VpV3ZYbEFsSlZvT1dxcklzU0ZlSGowNFpDclYvTkRpNERRUENCeUdMMnhvT3Q2WDhlL01GaGRrV1Mwb0ttNllSek5DbW1kTmhuZHpZdndPaFJWMHZNNTUvWXJmbHk0RVFwa0FIcmthdnVJVE9ZLzlCejZQbmxJVklTTGk3VjZXTkZsVFpFSFJKTTBYanJNSXJ6MEpjOHduYzJ5WWx5YjJqTDlGNENUOHVsSUdWaGhGbE1XazdQTWxCL0l6YVkyUHlDaXFTZklJcm41RTB2Qldyc2hLd0cxTFVSYmtxZXlJd1BwNUlSbUs2aHJteUYzYWxtTWt4dU9nbmxNUC9uR215alFZcGxhdDVjMXFPTi9BTENxbXlLdkl5UWZ4L3l6SlU2dXVHc1FLQVBXQVl4aXl0bWExMit0d3NGc2tiVFdicU5sczJtdjQzTEl3ZmRocVdoYitCMlZXd2VrZmw3UGFxTlZzdnNRMGNYSElnY0ZhTjhhS2pHY205UTExWmVZUWJxMDI0ZUpvVHhGbEo5NlpJSkpTVHlCM01tNG1RaUszclpNc1lqUy9QK3IzODNnLzFaV0lJYWk2THhsT2FLektlM21XQ3dSTmEzQWFib2lLNU4weU9zdGQ4SGpVSDVXRWVFRFZQYmpEL1I2djdzUDdMT3pKRVk4Mk1oQXpQUGlHQjIrektMUmx3SmFOc3VveXhJbTZaRXlXbDljWDI4dXQxM2JlRlJlSjJmTHp5K2tQQi8vaURjU2VaRGZnZWdkeDNSMWhNaGo4Unpxb3ZnUzBoZERTbEpJR1FXYTkwMllRV2pwYWxFYUhFZTdwa3B5MG9VdTZDOHZYcDQvalNlNGI4cGMwditHVkRUdzFvMW9JMTFEeEI2WlhwZ04reFNONG85Nkk1b3ZIcnA2aUFDcFJSZG9yS1VFdEZWTjhRV1BVcndWNXJ6Z2tzSHc4TnpBeHNEY1VpWHF6QVZGRmEyUGovcUxIMGdSZjJLUHFlUHFxa2plQXFXZ3RKSGxwckpoSTBTdUZOSUdUZFRVUVNRNk1GQWVHYklzNjlQMnBDaDJxWndLcUZ6OFdpdmk4SGlVcWdJZW1WeWdGdzdsa0psOUsrSU1xeEVxQmZleExaQjhyTUxQTVh1WW94SDNxMFJ0M3JOdDhLT0ppellPSlBlWVRFWmplRTdMVFIzQytRUDBqTmh4Tm55amhQbmM0cExEYncreWJWRmJrWGh6bE5iNVN5Tld6RVV3bGV4U3BzZWUrVXRiMEtVZEVqaDk5a2JQYm9mdFdrS2pzNVhsaExGNHA1UXA3Wlc5b2ZpYUoyY3E5Q0hGMzl1K0VmNkp4N05NemdyQlAwdUxHYUw1YUdNeHlncEtPVjYxOGh0V0U2YWRaeVQ3dUR5UlNEVTVHeW5JUnI2L1haSkpEN2VVeXh4M25STFNNeHBiR3g1ZkczcHdzcFZLbHBJTk5zczVtMFVjeG5UWEpITWI4TmRNMVBvZmhSVVJ1enRCcUVBSVhyRTZBNGV2YW45UmV4aU5vaFV5TlNhMnVCd3BtcXpxUjVGOXhqYXlKd3ZYb0ZmQkpJU2JQQzVjc1lwSFk0ME1CSWVZdm1pa2h1bi9wbFkrRWtrOWQvMEFZS1hKUlVKQjFQU2xIckVWMldOTEJhN0dJZmJYVEo4RU9sd0ZUSk9XSUQ1d0lDeVRVRjdTekZ3QWxYTGo4Unk1Y3NyM0lmK2tpcS85eitnVDA0QStocnpFRHhFNnJTU1NMVHFDQW9pUzZTaDA4UlVxRUpJRm9BV3dKVkRzTkFnNFRNY1dDamg5WjROSkVEODJlVGJUdW1SaWFWbnhWRDY3L09ZOGdwK1M0NTV5T1pxWUY3M2gycmo0NXh5ZCs4VGVwVjZjTUpSWEFxNjFlUnBIaDB5dkRZdldhMDFjT0NiSDRDSHE0bURUejZXTkRlK2RGbHVXT3lYRjFDUC9PTWJ4S0lFRlVpd00zM2x5d2J4ZzZOcFRSc3dNUnpMbUwxWFE0UEgvVlZidkNvVjFYbFljemxNZW1ka0pldkt1UDRUWGhXbXE5UzhTR0Vtd2I0SVh0QUF3MVRJaVRUclQ3b0NsMFpQRU5wd0RYWTV3VnBLTEZqVVV4S3lydzE0WlAzSWkzdVg5dnF2RmdYT0N1aTF4akJPTnFVMGsxV1FFVHQ1d0JONHdYZUlId3JqZmlSTHp2UG1waVRvKy8wYnhCc3YrMXFRVDBFZjdHNktrcFBhRGc1L3hOM0JGdGpzWEZ2Zy8zcHV5Zjg1U0g1UG1SVFVVYzdKVk9MTkpMN3FmYnh4VGRQbDZONDhQbXlqRVlvY2V5Rk41VDZQbDlrSGh1LzB2KzdXS1h1TzFvT3o1NkhXN1JsUVZ3UGVDdDhCNTI1UmZrRGF3ajcvZ0ZrWGV3K0MybzFYVjJKTzRxMU4rUnlxRC9BL01DQXZvenBzUWNBeWxrME5rdVladkEyM0dENnZ4aEtyaFhNd2p2dWlMcWFEMkpDMWRqSXl3UDVBRklxZEIxYit1cVNSY1JoQzNwd1dvYVEzOCt3bEtmdEpIQTRtSmdYTU9jdjR6cDRBZytuOFpuRnA5cjQ5clFFRXJVbklJMXI1eVAzbDZnaGdWNHM5bEw3UU1LdHcvVU5Mc3d2ZVV2VEllMDJzQXRNQVJ2aWVabDlKYjltTURoT1lYZm53cUhVNGVtbkdLbm5jZmdjZTFRME9lejdXdWdJSDd4TmVHeFRKRytDTDhQWGd0dkw0N3YwNi9kOHVsck0vdG9NTzNNR0Jrelh5ZjJYV01FUzhlaFY2WVdVWi9iSXdVdXBIaFV4UGt4WW9KQnVROVZXU2JvYmVNQlg1OCtNSHZUTFA1WFBwVGlGUWp1a2oweFRpalRwYUVqMXFSS3ZKYlJLc0ZuVkd0RHN6ZmRkOU5zTXNIaGdoNHVuU01TbWtSMEVzK2tOcEZOVVZwN3lrWDNjZFU2cERMVVJLcXZNaHVjanRFUE1OK1Z2ZmZ0OSs3QnJ4OC9rZVU1d0NGTkhSekU5WnU1ZVhiK2xZbDdvYjlYUVJqL2xDVGNNNFBMdmYzVlM3azByb3pFYy9IVXpNMjRlb3MxQW5CS3lybjZzeTdtVFoyc3pYMXhMdnBVVVVWQUtpWGc3NzBPS1RSTVV3bGtiZFJTZjJ1VjRxdDFJeEtLbmo0QWJ6Y0VxVnJucEpBazNUZzFiTUthKzlTVzJzVS9pVnVEU2ltMklnay9nY2ZPM0NwcWJ6MGhxSW13NmRqS2ZabDg1enhUWkE0eFJ5QTJNQTJxUnVRbFhiamVGTEZMSnVpSmNBMlpFakhkb0d3eFRLcyswT0I1QjVrTUxNWXVpcGxmaitUbThxdWh1TG9zeTh0cVBMUTZmR2c0eFdrZ3dTOHZMejlFVXV3V1plelY1ZVY5VzBMZVA1QXQ1ZWR5VFQzZ1dWR2l5b29ub0FPdzl1U2dnUGNrVEpZTnI2d2thSkxidXFEOXJ5c3J4aGFvOW9RUGVCcjMxWmVaUWVacTRBTUtJZW9SU2l5UXVrRmlJRTliM3dtWkpUZzl1Z0dPMTRFOTYvWXJwbTB2Mmxzc2cydjR3NzNVYVBJbUh2OGpKcEY3ZjRnYkVnT2pFODdEVy9aTURQZlhWcVh3d3hidmdiNzl3eTI3RHRDeTk5TENOK01WNDJiNkMzdnhydzNsZUdKa0lneTlKUWVRdDF1VXdzL1dod1RFaTV5UzNhcjdIQXlXM3JIMnF4MXBqVjltTFAwcVJvMGptKzZPa2Y4cEkrUlhOZ1orVlYvYjFRLy9QZHZFZEJ5Z1IrRVZFQ0RpOExjQk95N1lQMTBldCtSK3UwVVVqblNpanhGVlV5bGNBR05zeWFROWRmc3EzaHNXVXhsTjUzMEpyUnd4cjVrN2g3ZUlWY1ZhUFRLK2tDMUVBK21RNFo4WXZOTCtQaTZwZnY3ekt0ejh4aXJlS2c2d0hzL1VwRzZLY3JvNE9IN2JTSVk3aUhjaVhNcTdlaFlwM25SK1lhU1FpT3d2NW5RUE92djVWVVg1L09jVnVPMzRZbnlSeFAvT0FwN3BkcTNvYlFld1Y1UDlUY2s3N21PZTgxbzJlcUpZU1FhaERmbUlOVlkrT244bW10WE9lM0xuZWZXbXh0SEJTaXhvUmVQUnBjcHRLbitlZmVZcHpUUk9Ja1ZyN29icXgvUFZ4U3ZIQndNK2ROSXd0YWMwSy9JVXh3c1BLRnErZkVWMU1CdDl4VWpKcXp3ZzhOeFRuRWg1eVo5aS92b1JFa3RxbG1wd0hNRTIwZEdITitMRkV6T2xXaDk2ZWtkS2pva2hsb2l6WDVSRlVlR0UvK2daOHFkWFZwL2JjRW5IUlpFbWkvYTdWMWJhWDFkMW55aHphOTFwZG5aNXVDOFBKWDY0dkV6bXk3K3liMGFQNGY2R0tEcGJSZHVpbEtsTGJJRGo2NWJnaWc0NVcyTGYwRHRPZnk1d29IeEZtcXJUVWZ3elR2ajVGdU9aMWw0ODNqTlZVSXlYU2J5dTUrazBTdklvdG5sQzJjOURJREdZQTJJbnByak9KREdYTnNYc0lmTEFCdUZtd283ZWo2QXVsSXB1T01icVpLMEV4RUJZQ25YU1BoUUNDNmtnSVRjbFRveGtLY29Ba2VzSEl6RHB1S3dnOHV3SXkzc3ptTmhEZkpSSGVPcExFWjdsQXp3ckJuREdqeGQ0KzBmRFBIcy9ZdkZpL3poQUx3L2pzbytUN0d1UmVCOXVDMFQ2K0NESG5oQ0VFeXozQUYvaDhiOWxMczdoZi9ZcWp4NWdXZForSjRqcDBXc2grUWhQMmdreG5tQWRMeFByK2dPNGxZQnI2SXJPT3pGM01aK1pJYUtjTUkzbE5JL0k3QkVhVlZFeWEvanlPSldPVlNmTjdsb2dic1lRUmo5aHBhUmZUNXc4OFdiRngxK2hCQU5YcTNoOTJpdElac1R5dHlXbHhTSTdmOFd0dy9rM0xVOC9PNUVvamszTXpVWlVQY1FqTkRWOGVQNEJDbjlzVW05eDlBbUpsUkRia3VXMjN3cEhKV0V2WHNQVXE0TUI1UXJlcDd6NXhNbUU3di9QN2VubDladnl3N2RHSi9iT0h4NmVRb2dQK1pUSTdOekVXQkdwRkJSNWhmcU5VM3ZHWHJub0JPNlJVenVJNGJvcElLMEpRdEl4dHVRd1NtbldHVElicjIwdkhpVWNrNDR6VkdCMUhoUHozT3laR2J6Smk4Mjc5M0RTRWJoUVhDd0lvaXlNSGg3bkxpSWtmWUZhajF0VWQ5T1MrSmt6c3h4aEQ3ZzlkemZ4ZHhJS2kwWG53dmpoVVVFbSsvdno2R25IcG53WTRvMDNOclZSb0pIT0hQYVFCalZ6SXJ4REsrbGxhQ1c1dGtMYkVhSmlPSFNNMnpWNzB5MzNBeGw3MTZucjZ3MzYra2U1WXc4ZmhXdjc3ajlBcjdRY2hSTlZQejErLzYwM3p1NXlxanBkdis3VVhWRDQ2TVBIbkVzSDd0OUhkTFlVcXdMaWVWWEFjN0JCZFdQOTFqUVh3WFFrUUFid3dYNHlmK1RJL0RzRmlVUVpPWDdjY2NJUENSSkZYTGg5dEZZZlBidDY0TDU5a3ZDc0pQZ0ZhVllTZExjNFNjNStlK3lxQ3VGM25uZDE4YjBCWjBCWTFXVnRkQmZNbjlwaDFjZGRiQmRhTFFMb0R5NzhOZ2x0ZXpBL29mdytKUDZJbXhwZXhxMy9KQzlFWkZINFlIVDJDRWVxOEFvNWduc1lQZXlIREQ2a0V1UlVHSllFbjhBOXpldml4M2MzeUtXczJjR3pvdVBmWU1LNDcyYnd1Z2R5M1h6L0JDZ0JMTUdXQUJBUllpQzJlZHAvNnJnZXNsOTBCK2ZxV2plRWpsOVhMNmc2anl1OE5qQTF0VHcxTlVDbk9GbzRybmNHdEJaYWFiWHNSOTBoZlJZVXEyZFo3amd2N1lWSGxxY2VwUk1aMnVBbHNhWjNFL3Myc0NxWVlRN2lOZTEyNW5YTVE4eTdtQ2VZVHpDZjcwZzFNbDFGY3NPSjc5YUpHRlNxYlFrZXNwRVJyVzdJUzVlNHo3ay9WMjEwVXhzUXR2cVFvNHhPc1JxSmVJOFhTU0ZCWThjbUJNVzBxRU92aFZyMnVvc25wWmhyYThzcnhJMEVIMzY5azNwb2kydHp4SUtnU1JYQjFrOHJjQjBPTjdzNlltRUo3Z3VvcFVoL0tBbUpSK0dEUEpvUWNFYjV0UFVFdlBFSjY3MXRSV3BDRWgrYVZvOUhjZmZRM09vaWVxQ3JQWjdHSmV3WHlBWkZidmVtb1FSOFcyWFR0MTNDdk1jcDVsVWdROXJaTjBVYi9TbEJ4OWpwNGxJblZmalZmSk1YT25HZnpOWFZOZHJKVGRybGFQcGxkamFBOS9hNmNxK2ozNzZNYmxSZitybGpnNURHbkEyc2o4dk1TZVlzOHdEekNQUGJwQmNwZUQ3Vmk0R05hN1hYNkZBRVNnNUVjbFd5cFRWZzhKSXdJbWpqUUw5RXZuU0ovTWJ5Nk54TERJQ1E1dytxSHFQaGlVZWtYVXVoSkpoSDJUYXY4bndEazFMSDd0NnRTSlZDb3ZrQ0dQKy9nS0xub2Rrdjc0RGErRzJGT2ZWTlJrbTFSSy9uYkRKVUlWL1NQaXV6RnVjVkg2bkFZTWU3a3IxS3Z5SXh4V2wzMDNhUHBjVmE5L0pxOTJwdkNWZis5SFgwZ2lOL3lvRTNabkJiWmJLMGFVZis2ZHpOVzZpTWw1em9pMVNYQ05ESlcraUV2KzNnRGxKZG9Nc0hyaEhhME1lTWdVOTFZU1BlSHFYdzV4R1IwN0VMaU1aVXFJSXhmWWpyczlPZUl2ZzFjUGlxaDFmNEI3blVnZkwwbVdsMjVzWjdUemVTY1VYZ0h1VGI0MWUycmh3bmgvV3V3WmI5UHp3OExpOG84V1RqOUwwM3pyRDRzZktCRk9JZjVCV1VxamdQakYvWlc5ODgzcldPN2N5Mi9ETGEwQ1JidXR6ZDNXbnlDenRwMEl1YkhvT2svVGM3YlJ2cllON0NuTVZqUWdDbWc4YTA2QXBOd3gxK3NOQ0h3ZldMQjNsQmphZW16OXg3Wm5yNnpFejVZQksvVXdYdnVBdmRWK1FlNUpNSHl6TlFBaGRMeFZWb0FHNlllbXUzRVE2MjlMZHhQWjRrZEdHTjJjZGM0OWdSdDVsM0FKWjJuWTVKcVdQU0ZKSUlJRzl2MExkRzUrQlF6MTNsQXFFemhBMGFCN00vUGwrTmMzODg3eVk2dm8zNVR1akhCeWhKWDZhTXdwOXErQTlWZDlEVUZ1Q1Q1N3NhR0VYcDFjZXMwTitvMDlPaHZ0TWFQZW4wYmUyQXJnZFd5SUdnSVd6SWt1RHV4QkhDT2VQRGF1Y2lxdEFmb2Y5ZTZNMFFlZVhmNDMydkk1T0JTQXU0UjBUWFZHcUJRUG9SOW15UytyUlE1N3RpeVlXSHFZSHZUcTdVS0RrdXRkOENvY3k1dVd2TVNGbEwrSGhkeTZRV2lWQm03Y3JCQ2I4UlNnZWloZXpDK0pIVlgrdVJ5Znc3eUdRT2NwbVIyOFlIaTJsWk5QWEpLWStIUFVCbE1wODRpeng2cnJnL2tpaU1MT1RUWGdXZFhUWDdaREw5L05VU2N4aVBuOU03c0QyaG9WRW9NRE14WEFWcEl4MXJKU2tpbVRoWjJoVCtzek1xdG1leWxnR0VyTzRMQVpSWXlGY0hUTExzdURFcGlwUEdlSGFhZnRzUDBOUGJISlp6V3k3ckpRWitSUkRpR3Y0VkxTNEloSTRsd0NPQjdJZm9oMXpwTzNYalY0Sy9WWlhaUldKb3VHMkZGYWxJWTAxM1dvdXY0UGFHSkpQb1JEb21PY0xtSnE5TnIweExaL1JDR0t3K3dnWDlqRVQ4ZVVuS3VkNmlHNEw5MytqWk9WbndRREF3NXpQd0E0WnZMaEFrcnNDUUtwS3I2Q1RkSTFiN1RtNU15eWFKZ1ZRbFhQTWx4Mmh1NHhnMUpkZkdvY3RiUUxzbEVvNjVPMGp3c3NBMllBQy9mdkZZS3BnaEE5aklaWmJvQUw1NnNCNE1oNUpHdUpUZFhUbTIrZ2FPRnp1c3hNY0ZTZUI5R3N0Mm1BbGswa0dkSDcxcGVpeGp3cUN1MWp3cTZneHExWnNySGd3bkIwWVg4MmtOeHZSekxDZEswb3c3Q0NSRlJEeVAzSEUxS1RxK1hvUk9KYkxIN216ZHJpL0E5MndlYmVpUEtuVk1DN0UxRUQ2ZW1UOWFIck1pZVdoc01Ga3BudWdJSDIrckxFWGpVU3NZcXd3ZWJkd0V3c2VmVStHakx6QTRmdVZpTlIrSFJ1MXU0c3IzQ3grOXBaRlhSTE9EMVN2S2VhMGpmS1M4Y3h2UDBTVDRqd1h6RzVCdGU2QlNpcFJ4b1R0cnNWY1BCck80VFZsbFNiaC8vcWdNT3E3YTEzRDIrR2dORkY3eTBYbGcvdEVETnNHd1E1aWgzai83RENTZkdSd3ZZeGIzdnZGQm1wM2RUMis3OU5IL2huNkkvbmZNcVhyd1BvL3JWekFrc0FBRlNjUWlja0lCT2RhakhaTlNUblJqc3VPK0JnNlZlc2N5NzVHSFMrRmtLQ3dkL3RGYUlMQ20rM1BwV21VbUVKZ2NhMlNML3I4VnhlcG9KWkZSMTBSeFRjMGtLcU1GMUpnN3NieTdtQmtjcVZqTkZWbGVFYUsrMDFjZmFsUk5XUTZOMXBkUDNPYUwycTluMmRERTFMNGp4ejM4Q3N1dThKN2pSL1pOVFpENVFldHVNcU1PWDMwWnRRMzJ5Vk5kWUlTLzJsRzlUMzhXYi9nbk9GN0d1LzYraitDRHdxRzdMcS82S1BwcG5qOUJIdVgyZjVpSG4rcGdyTDZBbm1HaW1FYmN0a1dsYlQ3QVg2OEZOOVZlZjNaVDliZXRxMkRmdjNWZlUvMFVZRm9DRHRjS3JFWUZpTk5IcmZUN1RmVWxNQTRJVVN3MVNtUk1FcGcxR01hTmlBUEhCcVFGTklBRCtOQnNHTm9wZENqTFVzTkU2OWZvb3Y4SVpqNUkyQmJNR1J3MkJPMkVFVXdYU0VDWlNxa1lsNmV5N2V5VUhDK1dTTHpra1lGTU1MRGViamNSOHhxdjl6V0lLU1RhaVVKcmZmMnFvMXBlekw1ZVVxajl1Q0s5M3BMeTJ0RlFQQm1JRVBJeEZNeFpnNE5XTGhnaTJYQWdHVWMzVzlZTkU2STQ4WHROd0pWcG5teTFlbkhKQUcvb0JreXAzY1hjejd5WmVRLzR4UFZqcVF0NXg4aCtzOXRaajhjSUJSN0tqK0diVWkzdjJFYVdxbUluUmNzS1BRZ1RHVFp2ZGt3bDh4U0VxbGJkR0dHZTJwSVRUcFZkaVFhUEJ4SWpxWkFkU2sxM0x2KzJLdG1TaXRmQllEd0NQQmY3REF2SFdYelBEbFBSNHM5SHZPcHg5TnVPb0hHWFg4c1dzNXAvMVY1emZnSWZFTlBEa2QyVkNCd1BUb1FTaVpEUnZXcUlpaUxhZitrei9DdGdPNStWOFI5NkpyY2RjU1JxS3NlNWRVZWU2ak1NWDZ2YzRlQ0puSUtNUCtoM2pRbmp2ZjA2NW1ibXRjeXZNMjlqSHFYZThWMG1ydHM1Ry9xRTlHVFBaM0ZsY0hOSXZIVFB1MTNkUTBTWjIzMk1DOW1HWlRYMndDRkxSWEI4MU9rUVlGblJyM2MreUZkQ3FWVElZTGZ1L3UrY0p4MmVrVlJWUWd1U2FtMzlPVkRMZVJjK1hLREN1NVZwVnhnRmIxM3RmaGY3SDBJSnQvdTMrZ3lrNi9IdW00T1BkdVhHVDlMeGZWa2pzVUtpekdRWHRUamZvVFlCaGlyZmcyZGJEVk1jNXM0WnRZalBjMnM4aTZ6cytIcDVlbTM2ZTlTc3Fxbm95aHIrMzBTZEtOOVFSMVJwVFpmTDB6YU4zZVFuRGx3VmVuUmxyTThUV240UTAwbUFjdmtLNm1sUE5Ib1FSaGhVWVozcFoyTHVMdHVSd21EeUZ0T0ZXUUJReVVwaGlxb0EzOVBzU2ZkZVo2ZU8vSWJnVmZrSDdLOC93S3RlNFRlT0VGRndta3NFMEYyQkJKY0cwZkRWQ0EvNXgwWE1jNkkvKzJ1cUt6aEhUK3YwaEpqZkVSU3Y4TmEzQ2w1RitCMnk2SHpMaUVhTmI1SGtqMFJaRnY5cW1wREMyeDA2Mk5lQXVUT0NPY2NGc2dObVM3M3hhNE5pLzdnR08rdDh0a1JhWHk4aTEzdW5PNFR4UGJac1h5dXpYdVVhYU5leC9VYWhYbEFlVS9BeGlDL2EzOWJRWWRuTERuTSsrNHRVd0xGT2hTRXgrN01ENlAyb1BhSjRxSmpoTndKVGVOMDBmRDREWERxRHN0cjB5QmM4QWR1Sk5qdEtuMTViWS9CSWNtT0J1WGc3dEQxVWQzWVRjeWR6SDVucG53UTVjOEd0ZEVkR1U5M0VwMVIvdVZzWHVkSkpCUHZzRm9oNzNSakZ6YzRiam4xVm5kaDdTWGhGQ29zUkU3WHBsNjlRSmRRTVBmMUJYKzVpRjIrN1NLN1VkOW92Y3R3bnFRSldDWVNDQVgwZ1ZHNVkrYmw4Y2lLUVBSVERkTVpvNUVBc3hzY2RmWmhDSythb3RIb3pPN3UwVmNZNW9Ud29oRDlKOWNLeWY2UXk3TmQ5TTJYN2FiU0k2Mk9HL0hwSzRYSnhMb3BpK3lPTVRPU29pTkQ0QlR5WHg1ZzZNNHZuTTNpYzV3a1Nwck9nKzFpZG1CM2dZY3c2MFY5OXFGR3FocVdHRDlNT0VrQ2Y0SVhhSkFhK2kwaHFTSTBxV2wvd3NCSC93YUIzV1BIenIxMEsrWHdoWDJtbzVGdjZpYXdHVzU0YnpPWGhWNTZPbkJ3ZWVDaDBOcExNREwvM2R1djI2UERKYStjLy9zYjZmc1FjOUptc1o4RWJWT1dmTElVYWpaRFA3L2N0dlpiM0s4UGU0SkVWODRiVCsrdmVhMDhPSC96elpPVDI0RERDRDRlSFQwYnV2MnJ1bFU2TUJnWTlpSGV1VVdMWjR3ak5IS0JOS2txcmxSd1lTR3JaTXc1b0ZvUm9FSXkrYmN3Rkt1eHNhNVlpUGFyeTd4S0VkL0hxbzhUcy9GelUwdDZ0NisvV3JDaGVNbGttR1hvWUp2UERzSGJRVkNqNXo1SnlXdUQ1OS9BNi9zOExwMVh4Nk5GUWNzR0lJTzA5ZWxsL2o0WWl4a0x5TDhETWxjeG42bmRMa2ttbWE1djdJSk1DRFZ6L2RPaFlzem9CbjlBbFd2RFVSem51bzJBQXlmTVB1K0ZLSGlaeDBOSGhyZXFPWHZWN3ZNcC9oT2RrUEt3ZUlnYUhEK0VCTDNQMjJuYjFCZnVQTlJJWHZNSzhtbmtEOHduZ0ljY0lHRTFPd2oxdDBsanFZRTRrRW84Smt5anBLWGdEakxIR0FoS0s5UjVUMTB0bGNGZUFqUzNoN2lqc0ExNDA4RUtBOTZVRlpPSjNTNlhpZ21ORkMxYTFtek1FSEFDY2RuSFhGdEVhai9MRDNtbGZ4V2NNaEhoVDh3bEJSWmRyMGJTbytYU3ZsSWxLWERyU01vemxRSFJLOWRpZlFoNjV3ZU0vNXp5SzdIazFwTjZCVTlvN0lIV1BwaWllOXd1OGtGQTRRN2xiVmVWbHI3Y2xxWE9TakdReExTbkJ6OTZ0aE5VaFNRNUsrMWlKNDFuRUhvZk1OYXhJTW5zaGN3UHZRY2dJSUY0WlJFKy8wMHdJb1lQQm9PeXhnbW9sS0hsR0FwNVNWRFJUVVRGYU1uTzhJYVNEWndhVjZGY2tEeDV1bkJBSTlKODhYRmdNS2VKVmtxZU45eGVEVTFGTTFaS2VraExnYjdoU1l2bUdFaENVNi9Hck9WWmk3NGJNUFU3bU9sd0VlRzB4RHkxOXB5WmxUYVl6NTlvdmI4NlZqRjVDdmNPcWQwajgxVXZNdWZhV1UwNVVkekRscmdGQ3lCbkNZRnJlR2NMT25FTzRUUmt5NTdvdUs2NGVyZXZDZ3VzckVITzVqcHgzZy9GY1pYUDlrbWg0MHd4VU9UbzNuY0NldmJPS21NQUgrNmVneE9QeUt2OTduRXVYZlptMW5MaUpnTTE2RER5OSs3RmhOd2I3M1pUZm9DSGNtQmM3eUxGdnBDYzR0QytWYlBJc1dQZkFZZWozSUFHSG94MmM4cnZ0RDBJUzNZS1A3N1lKN0NlQzYyNmJRTmQzUFhNRzh5QzNnVTF3d1lXOTN4aXoySUhIMzVMeEMyKyszTVVHN21GWWFOQ0NlYllhQnZoOTl1eHlNclFLZ2xUZ2luVjFlaldVWE83a01HdmJkOC9oZUNGbmo3VlJxOTNHN0hHN0FuRWRhQkY4d0dPMzBzMkJCcTZiYTdyc055MEorTlZyN2JhOTF0NGtkejZBKytHZUhTQkE3QUNGQlRnb2M0Zmx0aGRFMzNBTHdVMmljZkJJRXR3RjNtRlpqNGRJamdqSjdpTkpFS25OV05iMmd1Z1ZLamNndzc0bjJXeXRiWGVEOU05MzJDWjZBbE96SlJLUDZEVlVvMzZSZG1VN0xDcVJIcmdCTU53SnZHVS83ZkQzMkNuN0x0SldHdWlVSkJFRUNiY1A0SVovNWppNVlKTW9mNGgyQ21qVVhtZFo5OWsvSUZrU3NlMHo5RG5vTC90citMa2J0bXYrK2N1K3dXeWh5L2ovM0pqNjlxYUtRekxRYWoyNTNZMkxqQ2tMZXRUYU9CWWhNRHZrMnAyUktZU2NHNlIvS0EzVE42YUNXN1JySXlnNmJYL0g2T0tpN1cvc3NKOGUyYTdSdjMzWk4xQ0xLbkRwTUh5V0RNTXBwOWxyaUl4Wis5bk9zSFRLNFZzMHpEM0p2UWpKRjkydTZvbTE3Q09SbHZjQzdrVURLSzgwMkZXbVFVaFpiT3dVUjZoWHZsVHFOUjk0U01TVVNHSjVPU0VFRk5FNmRlcUpiUU1zajNTaDBHYTdsZ1J2VjN5c1BKaE1Ec3FzVDVuTTUvOXVlMFNmczEzY3RUN1BjNGFST25zUzNXZG5NSFZ3SGZPQWkxSFR2NS8yNW51VndIU2xjRFg2QVB3UjdOTkI0SDdyTThvYVF4ZTV5ejdRTmIvcHBLNjJsOGxFZUFwMm8yOFNiZEdqTkpiQ1lZMUNPM2l0QWttTUhBNkdLWXhHM0UyMEJJN2dZdlFka3FFbVJIQTZwK3JVV2dvUHBMeXNMOExkQlY5Q2p1d3JwU0dkSHI4NnJnMlo4NUJlU2xjRDJxQkpyMXNOQmdFK0kzb0dyVEh2eFAxVkIxOEtpT0MrZ0lyalFQSkRIbkNLTWN0WmczT084S0RRWnN3M0FMc1FCdE1kU0pTS0pJWURSSzRIaEd5cFB3OEc4cGhaRGNNWll0MVRTWmdabVFSaXZ3WjBQeVRjOTliUkdzZDZwTk1uVDU2V1BLd2tMbUdXWHZTSyswMVc5R3BzZkdXdmdGU3ZNS0o0MVJFZU05bjgzcFU0cTJraWF4NFF2Qkl2SEZpU0pNNGp3dU9paDVPa3BRTUNMM21GQS9oeGpUek9JMFhuUjFTdk1pSjRWU1NReDczNDhmMzRKWnk0ZjBsNlROUWtGQjBiaXlMSjYwSGVNdWZWT0c2d0tXbThLSjBhdTJFZlNLMm1yb1F2ZU9VVXlMSDIzVEIyU2hKNVRXb09jcHptNWNwZTVQSCtzci9nMk14K0JIMEk4NWhWWnBxNWdTQis5OXJBdXdKMFIzblRjRnpGeGwwQVBzSytjUm5FVldwMWlzSFhNd2VrL3JudzdIRk81WTVqbWhmVHIxVkMwRllKUVh2amdvK1ROVkZpZDNHS1grRjI0ZS9oVWJoWWdPT01FYTVVWlNXQitNVWRQWVZUSkpyRU5QNlI0NVNiblVMa2l2M0lGT0ZtdnowaXErS1RzdnlrcU1wWFRNbnlsUDEvSUg3NklNZTV0amx2NWZpZUFKMWJ0RC9ZNklUbndQM1EwU002dlNMOE11MFBiZE4rbEwzY0RrRExQVDFnazZCcjZBSGFBNVhMNlFIQmtRdXU0dmFQNGpVTjdCSXZOUUkyaVB3dmxlYzI1TGNiQk9jbDRTeFVDeCthM2Vod1RTY29MajZzRVRSWWN0aisrNjkwWXNUZHVrWEsvcWR1Q0xtdDIzNkpyLzlMdG4zYkFYRHVNaHAva1cvLzFNNWJUMzJOMXRGdVpwWHhNbjY4TW1mN3ZYT3lzSEhvQWFXdHh0VzJFbmgzR3pHclFVakNsZUJxbTh5ZHYwZC9RdnB2TjU0NXI3elV5QW1HdG1UVW5JbEVJYk9ESkZhR0E1b0djWHBveEZOdzBYQmdHS3ZiRDZGSGt0QytGaHd3ZXg4UXVDTFIrWEkzbS9GQlF4ZDRsbWRsSVp5VmdpT1pVdElLUjRhRFVhL2Y1OUczSDA1b0JOMkU1NXdIcnVIRGJ3a1NWOEF2VlhqZS9wZlJkRlpnRlI1Q1ZrbEcxQ1BuWThtaUdVdDRvLzY0eitPc0xSdjY1K0tqcS9DcjZwOXRoOW55eSt5Z2l3eTVnWmZkUVN6NEt5SEE0U2JqRDZKT2RmM0FHbWJXUW4zRDd5Vm12Vy80VWV5U3p2TnBKcnZGR0M1cy9OSE5neHFvby83MzlBM3pWdDlMWmJKbXRJa2VEQ3dKRHpOWGsrZ3lENERQTlRVWGNISE1jdmc3T3BCN2JqQ0dLaVZ2aDFFUm9oZFJzREFDYitpS0prSmlpY290akJxRURDeWF0VWx3VmlKL0MvazZxRXp4UTJIQUhuUGt2NU1SRWEwdGpwVXl3WlFWdEliOG9hUmxKVVArSVp4SkJUT2xzY1dwazFOVEo1OTlTd0RQUHMxTStHTHZYcXdBcGwybG1TZ1VyL01JZnN2eUM1NW1LUENXUk15WE1MVVFHdjFSSVBDajRjaEFJakVRNFlDRzgya2FpbnJWa0JaUHFrWWgwWXcrR3NVUEcyb3lyb1ZVYjdSY0tVZmxVN3d1QjAzVi83c1YwTDhVYTRWMXpITzh4RFJiQWQ4cFdmS3JabERXSDR3dHhEakIzL1JqY2xQZ21weFFMbE5zQ0tLUEdBR2JPc0IxcFRCRVljZEFsT0tFRXNNR0lyUXRGV3NSNnJycW9LV0pLWXJ5U3AzYlhJZ1ZOOGdjQWZFaGFQNWdUbysrRmZ3RS9zd2ZDNGZDMlpsYzNBcnduT3JWK0Zqd2xtQ00xelNWRTZ5UjNFdzJmSHZhOE1WWm1SZENvcXpjb3NoaVNPQmxOdTR6VXFWcHY2N2RjTjExTjJpNnYxSCthZUFUaXZMeFlLQVN4MC9wQWE4c2FENWZQaGJMKzNSTmxMMFd2S1R5KzZxYzREZytsdlVhY2NudmwrS0dOeHZqT1M0aHEvVlNNTy8xM0hEdHRUZDR2UGxncWU3R2RQOFo1cWxNS2ozSEZISFgrWXJESFlPZWxmRERVYTUrdXNGTHNyQncxeUtYNUpSRGdNd3djZmRweDBXSzMvMnFOMC96SE9WYndMNTRiWVBlaitrb0pqdjJlQTBYNWJiZ0pqcUdlZG1PaFY0bjRjRFZPa0hBLzQzbTdDWTk1L1JBSUJFTW9uRjhOeEVJMko5ejhxdTB0SDIxbzVoMGJMenA2ZFZRTkJHa1I3U0xKbDI4ZTlvR3dHRmprSkUxQ2xramk5YnRKdjRQRXVoVm5GcXpiTWIxb1hMbEc1ZkdNOWxXRHJHOVZJR3M2MTlrUjlCWDhib1RZYVpJYnpvN0hUSDRxM1g2clNHWkVRQURrVVJZcnlFT0hDalRJaGsyamNSeDFnZWU1V1lKOGNTUlVrSkNTZ3pScnZqeEhUSFdHL1U4OUpBbjZtVmpkeWpJNTMxc3QyaWE0dTdIdkQ2VStjakJneCsrUC9uWVkwbVVBN0hwdzZLWXBoMTYrcmJmOG9aRmNlOWVVUXhyajkybVJFTnMrR0ZObHJXSHcyd29xa2ZmKzk3b2F6NTg1TWlIS2M3cUY1R0YrelFDWHErZ3dxczVTcjhNNGFRV0ViSitLM0gvaHc4cVBvRzhWWEhxTkhya3c2K0p2dGRTRlBLYkNuNGpucUo3M2U5RSs0WEd5UUcycmY4bmdma2lQRjlSTWt2a3BSbkUrbnVhcG14cStOdVRqNUZxSFB3SUN2ZTBSYm50TWEyL3BiOEZEWHNOTkpIcGpJTTIrakN1UzViR0s1c0hkUTllT0F5OEFtTldzK3NjczRnbWpNUGdpUGQ5SlJZSXhKVHZVY1FjYWV4Zk1wTHdKZTdMQ2h2d29yWTN3TXBQYzE4bXhNRkpRWHIrYWJ2TmRIMzJuUGZRN1h1OGc1S1AyZEd1S04ySDM0UHVnOW41enlxOFNQMGVuYXpTNkEvUWgrQk5hekorazkzN0pqQWhmUDVwMU83eEV3QjAwZXZ3bTZpL1N3Y0xmNEdGZFErZ2htaXNEWHlESGFNNk5SZE5Ka1hCOU4wSUY4NGE2cG9sZEdCRy96ZzdXa2dRNjVHQjJaekFOd1FGQWN4aU9WMmRuMHFYQ1hDTElqUjRJVGM3UUVKVUpBY3FGaldYNGZXUTE0c3IxRUtWYkhKWXZKMlk2R1FWYm5DaDhEazh2blg4SzdJZ3M4cnZBN3AxZWlyekI2b0QvYUlqaWY5Y1lXR1FVNGIyRFE3dUc3cGRIRW5teHRzVXBheWk2bnBRMTEyTTlLZUpuMThVSWhVVytwR0VBRjlKbEdwNHZ3eTZTb0hPVENmNHhLNWJubjVjZngzSHQxaE9PS3ZxTDdneit4YWt1ZEhrY0lFck9IU0c1NUQ1Z3E2ZWRXWisxOWZGamRjd0NESGFMeEt2WVpPWFhhMjZYYXlHOHFxRDM2V1k3ZlkyQWZvY01DNThXRzI3OGFCd2YwQjhWdkNIWXJySVFzWFNGb29TblhXK2ZhMFR3WkZXdGJUQlJ3YTlJMEROQ1l5WksySXdERmZnWU02Y2FleTY3ZlczN1VwOWxkQVVaK0ZRNlhBVXFHcFFnNGpBcEdCMVhXR3kvTUxOcy9PMzdkcDEyL3pnWWZzdm5NZndvZDFsYzVodWpQbW5pUWZ6Zmt4Uk1hZ1R6cHZDcC9VRWJLZjJDSDJBMXBzOVpqQ3hETENPTktoTWpocHlOaWp4UkcwOTNRQTBwVnE5RVVFSGpLbmxLU09TTUkxTXBCN0pHR2JpRlBYcHZFZFRncHBTVjdTZ29zVU1KVkFNS0Vic3lZbnlucW1icHZhVUoyNVRmY1BSMU5qQVhDVmZucGdaR0dyNTFOdlFsSmthbUpvYVNKbHlNWHBGSU1YUFJUS1p5QnlmQ2x3UkxkNUh2VDUvSVh1dlZUUk51ZFlyWDJIRVpEbG1mRE1mRGFxeXJBYWorYW00MzROa1RHT0UvVjVabEdTdlA1UUpJbzgvN3NZQmV3NzMxVWZ4SGxjaEh2NDkwRllFYXMveFpRZnJ6NTR4UU50Y0IrTzhhckVMSHR1SEVrNXhiTkdMZHBRc1A4QjlQcHZVL2VuVVdER1ZKNXhFSkpoTlcvUEgwdCs0b3VpUEpPTkQ2VVNXVVA3bEFkejYwdm51bC9mN2pIQjZDRytBUmxvaDlsdkpjRkJWbG1ZcW1hYmZGN2FLa2FEcURSTytJWlFKR2VsTXZlcXNweFNQYlo2NUMrSnR1NHJNY1pEYVNhNlduMzdoUnMvQXhXdTdPVUh4YXB4SHBBeng3b2Y0dzhUSFppdkl6QlRxUW12bGlkSkZxRXJjUE1kekxJOVBOTDc0d0tHOUJDbDhWdUxydktCTWM5SU00Y1QzWHZIcmJOQ1RMdnBpbFhKOFdBZGdibDVsUFVsZk5CM1VNaVZmREluQ0V3U25pZlNIZUlzZ3dwK2JSWks5LzA1NjlWcEpEWnlrbCs2OGZ6VVU5SVRqL3VTK3NWZ0kvNWJBc1p6dVQ0d0V0VWpDU09VOWd1aktyWlRPM0hmcE9yQVpocGpsdDJ3WlIyM1RGWTVndWhpaG5xaEFybURMMlNNRkNHQk04R1BJQnBPdGdRa3N3WWdoRVN2UE9hN3gxTURwbi90eXlwbzFWMWdjYVdDeU55NXc4NC9OYzBJY0U2Mk5rY1dCWGZiYStmT29uUnlKcmtWSGtxaDkvcnhOTW9sb0tOYWtocEJOYXRqVW4wUE4rRWo4SlNaWEYzSC84N3QyWWQ1Mldxem5FSU12dDF0dGZ6b1FTUHRiVnN2Q0tZK1MxcG11ZkFkd0hGTWtTaVNndGZkcFhucHBROERwTlRGdHlSR3hCZmdIRkdBWUdWV0NlM2VPcUdmUGRjRHY3TyswMjJzdk1TMXFKWW5XbkhPTEtsNTZFZXhJUkhYVXRDK0FwUUY0d2VKaVRjWEJhUDhpK2dtbWw2NWwvcEQ1SFBObDRuTXhCWXc5SHVzNVFGOGl1RU5GU2tnUldMa2lRWkVUOHhLaHFtaWtZSndBeUROQ1lZRXBDNGpCQ2ZZY29iYUs5U29RWEE3K25PaFFDRGxLRkloRkd2V012R3pLTFF4bm1DcFVpa04vbGxJVjVEM0FZR1ArY3l0N1lQVDlJWTRiOHJDR3I4R0x5TXY3NHQ1eFhrRmhNUllUdzBqaHg3MXhIKzlGSXQvd0dhem5Nc3BhalVBSU10eTREMzgxSk9OaU9kODRCOCtGalFiUGNrTmU3eENldERzcjltMWkrYnFmbUwvU21JSHZ5M01xbDFjVFljVExRazAzSlRuRmNud1ZobDRWTHdZcFdUTDFtaUR6S0p4UWQxNDB6S09VVWVjRU5xVjZqQ3JIVlEyUG1zS3p1bTZrRUMreEF4NzhsNVYyVk9qUG5mcmlneFBJc0dldG5HUHVZSmpzenRkS3RuK2hOQnUvK29WU2VSbnI1RVdYU2VPeVYwbWUrQkVBVFpGakNwZytndGlHMGhnQnM1SWNxbnlCeFR1Z0pIWkp0SnlaYndCWUFpYVc4TzdacUhjSktMeENwZ2xvRnVhVEJVekhmV1BTT2pLMCs5d1NUM1pGYnE0MXZYK21EamlCd01KNTIyMXQ4MVcxODRnOTNrYWZuNHdtRnU5cWlwTEVUNStxRDlWVVlJWGJlbUMxdmI3aGl1S1dYRys3dkEzRklTeVRTQU5kSk1MZVptMENINVRjWmhWTG0yaER5SlBKM09pQUZEN2MyN1JlWk1MdHJqbVBFT0RDNmFWdXkzcmhDbis2NlVxM01KRkhVMWxRZy9oWGRvTDVTdDBVTEdJZEt5dVR4bkozN0swYVpzY3JiWnd0Ym5Hakw0WHNZNEJVeHJMSjBVT3N4SG80enZpdVYyT2xKWmJGUjNaUE01RHpmdGVnUlE2T0p2RWxqWDNGZHcxelZ1VDgwUks5WGg3YmxCaEY5eHlqdjVBY1BjamlueFZaNHgrOXVVQnpEL2tGZGdrZjRYZHhZWWs5Tkpva2lkUGY5YlBTck9tUGx1bWo1ZEgraE1pVlJ4Mzd5aSt4SE82ZlFhYU85L3VqZUwrQUNKTmoxQVhQMlFwSUYwVWNzVmVra1hiaDZSWW9paGltQXFTU0taVWdTbW5ERkUzd2NlcllwcVB2bW9xVnp4eDdSU0dkQ1E2WVVjT0locTcySUhWUzgrdnlRU0VhS1E3N1IySVFydkFqQTYwekE4TkdNcmxyeXZlMUl6ZE52bXJFbEkxdmlscmExTlBmb0dnNWJ4ZzhjMTAray9WcGNYL0JqTzNlSFFzdHEyblBKTzRFOWJnWTE4SktNSXgvYVFqNVFXQTI4cnFhUDUzNDJ2TjNUOTQ4WXU1T2ZET2JRYnFhdm9FQzZEZyszRlJYNDJNaW1ONUo0emxkeER6Z0JNSFQyQ1Rub1Z3QVJHNGsvNFBPbWFRSnAxQnJPTmsrUkZ2N0MrY2tCU3l3MnF0dGVsS2tjeVN4UVJ6VUF1TVNURzNZcTBCeXRGNWlWaVNGcEZ5YlBPcS93VEZCVEpsVlNmeG5JclhxcjJWanArajFDTDhCaFNpQURvbFhZMjZMVDA4RlNPUUJ4bkpCZCtDWjVuWUJldXhWS2p6YW90NUxXOWNiYlVEczVUYTJZeU1JQnRTbTBsTmwremQ3d2xIM05PdFdWd2NtMFFhMCt1cmM3L20rMnRzNGU3WExkL1Q0ejFCYmpVdDdhbS9rZjdlVkN2NW10NExiQmp5eWV5TDNPTDdTUUtmUFljcjhQcUluZ0Q0WmQzRURKQWY5WmNQWnFXeURsdTJjSlRNc2hVMFN6TTdGaG1uVTNQOHVBd2ozU3h1QVlMaThVVVdmVnhTVFVxWW1Ucm4vS1pYcTVuUWQwNnZVQk5VaWY2aUZyR1ZWZW5GNlVKSlhENnM4RVpob05PbmZjTjdxMXFnMDdZZS93Q1pJSWY5MDUyLzN3dU45Y0dLcnFObnJEeVV6VWJ6bmRmMVRna2IvbDVUNmthVnJpTUhqT3BBSXJ2Vk9YcXN2eWgyZUwwa2ppRzd1V1FWQzdoakRSTHJZaVgwRFBuR0FZekVKMkZ4OStMcWJROEVXK20vakRWZEhwUVZBelVMYlJvUzFtejEzSmc2SVB4Y1BmRkk4Y05NQkVYQXl0d3NINittOTFheFVtbzlXbXMyS3d4OCt6d0oyVjFmdVA4L3NaMjRBcnJycmxMUko1Ti9ZSlBMM2tmaFdsSXZFSkNFRXMzUWZDamx1WGE3ck40SFJjMkpkZ29nRmY0TkdIVTFUM0lCMWVyS2I5RHprSUJOTTB2T1ZWYSt2VUM4TUphdDRmeFJtNklxRW1LeG82dlpKM1JTenBlS2VwUTh1N1NtV3JIMzMvK2I5KzlLOGlwNVUrVFJxMGVmL2IzcFNIWUNMWGh5SzRMdVZwRDlSS0RTSzdMc2tnZGUrNFRoSExTOW91cTR0TEIrRlg0V2ZQN3IvL24zNzd0L2ZiQ2hLb3hNYm0vUWg5T0FFNE1rUjVxa291dkUxR3ZXdUFKWExPWTd5MVBYTkJlb013Z0R0QkNZTWg5Q3JSSTJ0Sm9kd1kzM2VLaXNjZDNRZ3BCYlFYUFNrMjl6SGVkVStpZHRJR293YXJDQzlpeTAyQ29XRVA2bThXOVIrN0hSU2k5UzlyelgyN2JnSlRhYzVIZHhiOENlaytoL2dNN3VnYlM3VjVNVE1kS1Fwb2NJbXBCNzBvK2YwMExPaHBQNmNYdGFmMVF2UDhqci9uS0JJejByNFpKK25BYU5rS2duNGgrZjBKQzZMaStLUzVjeXpndkFjandzcStLUy9oNGFrU2xJRzM3SDNCbno0R0o1Zk1FcVB1VWljWFlJTm9rUlZhYjN5ZlJVSG5XQ1BUcDBLd2pvYW1JNlFrTDBYVjBOblRSYlhtVlltYUZXaGV2WWJuVm81bDkwcTY5Q0FWbCtiUHZDc3JyTVJKQWkwNFJiMHcwK2Q1dmRldzQvcnRLZmUyTjlTRjZPVEliN05zRGROa3pqa0ROb2d3VE5yL1phRDRRMzVUb3lmWURkOFNWZnhMVzExRWYzTWZwWVkyVSt4NEo3Qzl1UjYwdlplWHppY0RvZFBZaGFOUDFvQ1RUN0hOZkNweFhIZ3FYQ3NDTjcwUEYvSHB4YVBqdkpzRkI3Rmh3KzRDZjQvZFZKMStLbDBHQjJST1c2bHhPRUhWYTdPY3pmeTZoTjlWL2dXT09hVE5RdjlFUGNOVUhWTHpOVk1pM2tWOFVwOEQ2RDBFREZJdjYrM285WG9Tb2E3SWU3dzRnOWU3MFJjaGFsaTZEMWZUd2VUWGFNVENYRUNQMFFOTTZ1VGpRbTgyaFZxL2JBUkpSY2pxQU1XaEY0SUdVR3hGQXNRdVZBZ1ZoTHhadVEzallwaHJwR2ozNzdRYmwvTGgvVi8xTU84MStPeDF6MmVvV0ljV2ZHaXJ0cjRtUlhpcWN3bkxRS3BaaVY1d2Y0eEJJeVZ5S0hsekc1SHovcW9XZEtQeE5KVXVwU09IZEZMNXJUcEh6Uk1FMXhhOFhIUWI2S3l0ZUExRE84VXk1Nk9GNHR4NHFWQUhKUmp5QkxBQVpBVDd1ckk2Mk45eWxmRzRTKzZPRjUxWnU5R3IyOFJsRXI1bkxUQVNpQWJXR0JCdjU0R3Z5N01VeE1JcWpGVU11c1FhQlgzbzg1S1ArM3FPbzZwc2NGbXh1L25HdGUvbHpQVTRxRnFXbE1PM0twQytvcEprdlo4VjRrTkxkSXk5VjR3K2F6Zm4xa2NpcW4xNnh2L3BtanA2aFVGMWVBOXR4N0E2Y2tyaXFyQnFiY2VlQXFYYVE2U01seEhqZ3g0SUNGbVlLUHZuT3N5dDJGUzVaN2p1T2M0OEhIam5ubUdBOGMzOWtaTVpENUY3ZTBFQ1gwUTdqNUg3dkJmL1NyMWhqdWlPdXd2alhQeFBQb0tIcitqekVFYVJhU2E3ZlhFeVJzYkhITkF6T2dvTGdwRURBdFc0ODZFTFJMUlk1M0VGQkNRKzluT0RFT0NtQ2dObjZHQlBkNVo1bmdoR2hWNHJzektiRzhHSFY2R2d1UXdaYmQ3QWtxMlFWNXpvc0tEUEpLdmNCeE9vU2FrWEx1d2Z5QjZ0cGZSRGtRc01zQmx3bGw4bkFpQVpGMGkra3hTZzAvMnRPT1R0RTVmM0tJNmZTMTRpZWxwQVFNdHNQOXkyN1l6dmZaOXdET204RGdZWnBnWTZ2SUI4UEhOTUltNHlMbjJObFVncllFNXhIeUJTdzhDYmZqQ0JVWHlYMWlUbEU0Q25ldmxFczVEd0tKSFY4OHJDcVF1bk1lMG83U0paeTNnM2JlNnVRNUNPRnNEUGlSYkcwUWttRngvbGJKUXBkNjZvSFY3SGZueCs5YVJaVGVCUGNWVmFtUFdkUlVCdWQ1YnI5RDFkeW8vdU9PT0g5OTVQVlFQWnhSSTlmUFRibFM3SXY3ZUUzaEhXdHlxaHZrYStMaUFCak83UlJXcjRTcnR1ZURtbmtQTk5ySUlSMjJ2OTlhMWJibkovcDY4ODg0ZjMzRkhmNVh2aERRSzMrbkdZUUUvVTBUNGdTVEU0dWpvcmhzT1FEOGx5QW44Vk5qQVpOaTRhMUh1QkYrRUxlSTgzWk1yRnFhalVXNHVaMDJ2VEh0RUwxdWNLckplMFROZFF1WHBKdDMzZHhjcW1FRFB6K1VyQTM4QlFGUDJlalRzMGJsdndTTDdMVTczaE0zeXpMUmJMNGJFVVI0bTNvUDBwU0tvWGVlbzRyVkUwQzFJVkdRbllqMEZucWI2ZDFoUG5jdHBCR0plWExrY3d1KzJXcWpVVnpzWjF5dWdLL2h2QUxXZ1RuOHhnT3VZeDIycEZENDdVemI3NnhjdFQ1UEI0SXNKL3dac3piOEpzYjUrTlBESW5IZjZzYThPbDl1aFRwVXUyYWxRazRlZ0pnOEpzZjA3NjkzLzVmVmRndm91L2YrbnZsK0Yrbjcxc3VyN0MweUg4K2lybU12T2dIU1Jxb3BTSk1BNkljU3J4Rkc3VkVURW5zbEVlRENETHdlQTFsNWMyZ3FtcWlIMG5lVGh4QVhsWG9OblBaaElmblZEVi80Nm9NdXlmVUF5QkNsdG90ZjhkY09yekVkMnFma1NsWmFDL0xNbjRlRzRraTlRRFViUngwMHg4WjlsdlhHdkVRbDRkUDFlNWJuQVZDeHBINUVFUThxWWFPSTVkVmRrWHZVMjhtVWlnK1ZLWTVzU3ZpRHZDODI0ZEErTmY3NkxhVEt2WmQ0TVhpbzBERGtCd0hlQTNQckFkREdsNkJodzRyOFRWSzBPbncxc09RVzhQd3I1RUFuclN0VHd4VkxQWDJMb1NjMUJRWk1ha2Y3ZjJyNEZXbzZqUExPcnE3djZPZDB6MDlQZDg1NmVtVHV2KzM3UDFkWGpqblFsV1JLeUxFdENscTIxdVpLTWtZeUI2OGNHRzJ2amF3THJ4N0VET2JBQjhrSmtDUkEyc1EwK0NSdndIaTdCN0c0Q0JDL0pDUWtuWVpYWEp1elpYY1NHM1hEMkhJKzIvcXFlbnJsWGtpVmpjaDg5MVQwOU5WVi8xK092djc3LysrbUtHa0tpRmVsOEdoazIwQThsV2NPNmdTWkhXOFdLVy9WMFd6YzBjd1dRbS9RZzBsYVE5SFFpWVJ5cmpEU0pwSWw3aXlQZHRaVVYxRjZWSWZTcVlwU0pSRFZ3ckJpYW16RmRTNUwwdU9aWG5VcXVWYklUeERKMFE1WHA2aWJkdmNDWHlkOUwxSzNrVUt3MXBjb3hCVXVxRTdzc3dOZVpjbHozaXhxSnFZbmx5VEhITVpKNGRPc0JKTHhxeGRTaVpsbDUweVdtRXZmMHBLSGxncGo3ZFZsVVRWbUxKMnRLSXk0WGl3UjdwY3dZWDVmM1pmMFZGdFg1QWVGUmtEVm85QU54ZEFkK044azg1T2xuYk8wN3dLSWlKMllTTlpDZVIvOFkrQzRNb0RzSEltYVJHdUdYaDhpRldIVXVBOW5LZlRuYkk4VzlvaWFSNWtnbGhyRkVkQzlKaFl0bExkRVROajExYSs1UXNUVTZpUXk2K0pHN0l5dG9IeFVlRmFGRkVuYXBsUXVTbFl5Uk5CT3VtZlpjS2p3cWVWSTJGUFlrVmhOcHMvdGhMdU5mVDIwZHhVbkRjY1ltbHhOcWpHaEZYNC9MQ0ZrOVlXdjBnY1ZrYmFvVkcwcGE5YzhCT1BrYnBGaVU0dzJsbG95cnNrRkw5dldVV1NxNFNkMkxLeVp4emJ4bGFVVTFabVZLM3NkN1VnNjVWMW5NdFJiam0rdHQrZlFwM0tPUnhXWGRkQzVzd2pKRHpESi9hQ1pzTktiWFlCMEJVYVV0bXF5N2FVMjVvTkpPcVZJOUorMTIvMGoyVTRIZFFVTEhEbEsrL0tPRExGWTJPeHgwSzlXV29qMGFFRko1UkZOYTFjcGRwVXphZXJ6VGVkeEtaMHFoallVV3RzUGl6emxVTjdybHl0aHRDZ1RJbm9sMDlaRGtQcUxMWm55VGZtUVFaZjZGa2NZS3kyVDBHVjUyQ0lkdEpjR3N2QlpRelFSMjVrSGtOSTB1aG1sTjZRYUtCZ01qVmFNdXNoUWFjT09tS2dzREFLelNGVk9VV09Ha3FIUUVqaElSajBDSDhRZ0FDL0ViS0w4WXZJN2lYcnpCQXVJTk9MYnRWN0ZvUnVnd1I0a1dUOHFtRlZTZjBtOEExYmJjUjZ3TjdkbURXVWpiUFh0Q0VyNjlHODRIRjNuZHlRRTBYT0VhSDhCaGhxejgzeEtuME9lbzd0b0M3Z25FT1puNG9vUHZWY1BjMCtDYjRGRXNLMXJZNjFURlpsUFZGeFV2ZGpIbWtWV0YzRTk0OG41QzhxdXlkbEdUVjJVNVRFZ2ZlbzNhUVdIUlI0MVl6Rmczc3ZRL1RBVHJxdHI3TzM3dEtySnpwa053dmg1Zm1JQ0lUajIzc3lqZUF2YzVheWlwcUtiME5LcXNlME8xdmRkMlBwQ3luckxvbi9OQngzNlM5aFA1U1psOEFDd1JrUGdnb2NmSHIxZlZ6MXZXay8yTVVoOXdyQmMyWkFDSlg3dGVoWVVlenJQdm8zN2QvUnNiM1VBTHZlYWV6cW5yTmRKcklzSGZmcjFXMnNQenZ3MjlUYWdLUWo5bVVIOUR1NytYelhTbHhuZWY0bGs5OVJUUDZ1bW5ONTZ2aDY5UFhlTytDQmY2YnZReVhkWE5BaTdVNStvbG53dGhIOWpyeGJ1eFVLTUhDV1VCNVJ0VG9mc0ZNTHBXb21EMTA2RXhlMzM2MkZUU0tCV3NkSXpVYXNSS1c0V1NucHc2OWdldFBVZjJ0T0w2b3AyeHhaUklqNHQ2L0Q2a0l0a2tJbmJ5RGhhSjJaazZOdDJzKzZPdDlQQ1lhOGRUNDhPWjFxaFhhOUk4djlBQzJHK3JYRTRkeVkxT2FkclVhUFpvcXB5WEpDdWhTWW9hUzZWaXFpSnBpZDU4QVRHT0hHYkxocjNmNmFLWXNrUlFva1d3UExYREFKRmJyMlNjSHd4cXZoWXNqcWZUNDR2QmVwUllaN2pXV2Y3eUl3NE1hdmFoUW1pRjN0WGhOOE5MMEFlenJuQklUdEFINlFnOWZod29LN1RqY1ZaUzFGUDNnY0JzYzBseGhDUm0yd2hvRFhhRTlvK3VoeThiaWpkYm5DMFdaN2ZORnZQeEViUXlzdjgydUljZUJnclZmWVhkQUp2c1FUTFZtNU1lUjZmb2lIK014VFRlc09zNUV2bWpPY3pRN3MrQUpzRDlHcHp3SGNDVFZudklJZ1l6cXJxMDU0V1JwWnpaK2ZlY0JnUE5KVGljWmtTNi82Mmc0cjEwOFM0VGVTOVc4N0tTWnBkdGhHUkYzbzdWdElxM3lZUWdaTlByUkVGcEJXMkJRQzhLTzNUL2tmTVVLSjlLWnV5RThTbUZ3S2F2U3VRdm0wNDg0UmhQS2NwVGVpcVpjTXd2UTBnaDFKUUo1N2pvWXlObmhMYXdDMVl6VjhZQ2NxNlBnU3k3NWZZTXd6dVc2Uk56cWh3S0NSM240b1pJUndkZkUvR0kxcWh1emlDT0FIYjhNNDU4ekkrdWJRaHhoSUxYUWppdUE2Z3hYa3gyMXdEbnVFSlRZVnpkaTNSdWVJZnduaDRPaUtsMnRPczJJaXo0MWRFK2ZuL2tZZllKLzdWQ0M4MkJxYmN4U0J1MFFVTkFmM0lDSHRQWVc1cDNOd3NsSHVhMU5Nb29aRStFOXJwUmVoa1E1YVZDVUZrYzRnd3A3QTJlSEZxc2xMZzVVL2wrcjJFWFo5RTZ0M21XU3ZrQTY1aElVbWswTkFIeUx4d3Q4ZkN5cFVKalptaXBLYlg0ZDhGNy9NYVcxRndhbW02K3BWZVc3b1V3YTNvSTVRZDd1OHVBb201ZlVja0JQKzQ2RDRGNEhUazFCcVZ5WWFCU2NrOUEwNDFkamFzSklONnY5YzVOWlE1bFFEOTQxU3J1RzZpUkVQR1hyQXRseHRRSnV5aG5HSmFLcVEyRDVDVjhOdTJ0QzlqbVdyWGRweFF0NDhoOU45d0QyWFRlM25TT0RsZXM5T0cwVlRtaFc1S1k1YkNDckNoWitxWERxa3oxQ3ZrVmppdEFuUUdVK09GKzhzS2dnWnF1Tk1jc1hSU2xMZ3NuZzFZbFVkU3RnR1N6cE1zakQ2eDJYK0ptOGU2UDJTQng5WFRFcC9wRHhua0lNcmxTR2s2NFordjBwRkhyU1NQYzRNWmx0QnJXN2l6VXppMkxPUWVwVGs0c3UxRER5MEpZeFplQmxmVEhSRU5sZE85Z0paNXhNaGtIUFRSUWlWc1VWVlhRL1pGL0c5Z2Z4b1MzQVQ1a0hHQ0tGUkp5NW5IcklTZWY1a3ZmZXFQZWl6cGEzOERNVTJlR1JlN3F3TEQ5REFJUHEyYnVmY3JNRVRZek9hWUkrbU16dTYxaUxleGFzQ3Jic3FhYkxrd1h6bVBpWWtsZWtTWHNFbnllWGtrZk82L0lhVms1WHhwTEdSN0dpaWhWTTVwS1RLTGIzazF1UXFjcFZjdFVKVkhCMkRYY01UcG1McFhWNHRCUVVhVUpleUpITTdGYnRwK1NkRjFLK1RSSkwrUW1mcEh6N296dGNFMWRwR3FDYm1TcUdCRmNUYVk5WndnVGhLc1pnMll1aTdycDdoamoreEpkMWwvWGhTbGhMNnhwbVVmb0RqRjA3eTNDbUVZZkpBK1h2VkZjY3lBdHBTK3BOdno2VmZxTEhtbWJTYXpPeHhKSU82UG45VE1hU3NUbVZadzAyK0NOUlZWV0p4U0lRM1hZV0ZMOFRTYU9KMC92dm12cHpKbWx1M2FmUHJZN2tkRjNvMlJHV3pXTVZTMlRSTHYxVEFMK0MzRW5DYlZPT3ZFQ3ZZZlgrT0dIVjFjZmZwalg1MVg2M0pmUlZ3Vkx5TElWREZFd1lVMXhCMm9vWlpoUjZjTnpQSUlPYU9XeTlnT05aSlBvWWpLcmFNUGRRTk9rUzNKU3ZpUnA2RE54dzRoM1YrSmwzeS9IbTNFVlhWRFY3b29hNzQwSGRCMjZMcVNGaW5CQ09CMUduV0l5RXptYTBtTklTdUJFR1hETGEwY0wxckNYaEVvakRIODluelkyTmZTMFN0WnZaTmdGOEFHU0tQZG55allMaGNCWWlSK2M4YkNGdlJraXl6VU5HV1JzakJoSXE4bnlzcHpMeVY3UnNvb1BjVnpYUTdJeVBGUWZTd1g1MG5IRFpwUnh0bkdjVGdTcHNmclFzQ0svK2o5V25ISStVMEFDVmRDUVVObjZsNFZNUGtpdW9EbGxuSkJ4QmNYazZyU2k0blFhcThwMFZZNk5sR3k3NU1yNXZIeTZOL3J1S0MzNWFXVWs0NU5UdG9IcGoyR2ZJbjVtUkVuN1M2VWRzbkpnT0wxL2k1cEtqdi8ranJjdm5UaXg5UFlkZjVvYVQ2YlVMZnZUUFh3SWwrMmNzQ1FjQUowSy9iTkliZjBOaW1UdHAxTmhFdkdEVHdqenRNWkhoSlBBYVZCN25YVGZEV0QwbmtPUjQrRVZuTitKQ0kvYTRGemZiblVjaVErL05xSDM4NHkzdTN1SnEyT2pHMW05ZTc0cURuQjV4ODF5NXdiWXVpOXF4L0JLZC8wcW5OM2RiNFZNM21zSmU0VytBMjNCb21QVGZ4SkY5QTJxNlMvU3RuQ0hjQy9WeVo0V2ZrbjRyUEJGNFErRjd3ci9YZmgvVk9lR0VXcytqRkxHQ0tKaGRHSXJMckJhdENmUUpEUU5pRWs1cGFTcWpjcGNtK3B5ZnFxcVZQelhTVDJ5K1h3emRjbG1OdnZONTY4My84M255cWJ6VCtzbWt2ZnZsNUdwMzJyNHBFV3d1bnp5eEltVHl5cW1KNzRSYTIwL2V2ancwZTB0ZEN0U3RwNWFWT2pyRWh0cjJXSGxlc251Qy8wME1HbEcxOWRlUnlZYmt3eGVTZzhJUzQ0eDRua2poaU9WSmNYWXFYdmFjdHIzMDh1YXArODBGS20wRTIzM1hOZmJqbmJTaVgrMzYrNUc1Vy8wTXJyTzRlUlZybjN0QmovYlA3dzR3T3hDSWw5S202NTlicUxqMHVQQ0w5Qit1Z25UMG1aNm0xdHRsR2tmcS9iNFZ4dlE5VXAwYlFvZEVLS0VYd0dxckZVVUNJVStUUmNZdFBHQ2tpR3lRWTdOdUxiSW5TMG5STmF5bWRGaFNhU0h6VkVwMFlDMnQ1SlB4ZU5HOTNlTmVCeDB2UXR2a2xWTGZpdTZHd2lzRG55Y0l6YWp3RmFYaFdNdGpJYy9OWXh4NjlpV1JqNWhJSkgrMGg5NE1STDV4Z05YdTRpaWIxTytHYVhPQVJhMlRIKzRzcm9NcFBNblR3TGwvSEtJQW1XZzF4OUl4VWZwK3FYMGFGRUtSUGlSdEppWFA1cjNZNW9rUmovMG9rOHZlcjJMSHgrQUFZZXgwTUFldndtUnpHSmlNOEd5ZWVFYUZpN3g4S3ZjbjB5NDBEYy9YWURJaldETGVwV1ZVZ3pBRHkyZjZxNm4raTUwS2RSSjVjTVlwQ3pXNVlEZXNTNTBxRVlBbkJ2anFCSHVOMXBzWHdBaWpjTWo1Yk9VeTdjdG1TOXVHSTZjZVptMTJVaTFnL3ZVS0FEK29mTlZtOEZjUFo4T2F1S1MxV3JjRDBYcDNOOW9XZGp5OWFHZ2tOY0txcVhiQ1RwKzBuZm84TzNZcWltcUJTMWZES3E2YjMwMU9aVXZwVk9wMVB5V1RLSlJ2K2VkYjZzMTQ4UERqZC9mTmpFNml3T29RNEJuUjhlMzA4Nm9sVFYxeEVJeGwwNkhuK3NoZDJFTS81d2NWeDBjUTlhSVN1K1JuRVFoU0ZxRm9DUTdNM1NwMHhpcXp3U20wZDhuK1Fycks3c0V3WjNiQ0JGRElYY3hxWENWZTdOTE5lOEhHOTdwZ1Z5QUpBQlZGWGxrNTRPbE1rTzcvQXdjaGtlYno3WkdoOFB6MmI3NzlQK2t4NzlaMmxrcUwvMXR2K0g4M2FGV296bDg4TzhpMGliQTVnRG40bGVFY2FvRkN3NkxxY1dXbStEWHcyMmVQdmY1bUdXUHhmZjZNSjFweFoxcGd3OFNNOVl2VHh3dlMxaVJOS2x3b0xsNGVwSCszYlF3NE1IRUhKU1dIM2ppL3VWS0VSdEFPNXpMTDU1KzZQUmkzekVwWVA1SUtPU0IvRDNBWW5ERzVONGErT3FGSXNvbS9GQ0t1UTg5OGNDdURhWGEzNkpGMm5KbWNkRFJpSGtYYmRtMW9Walp3cFl6dEZpRFhrVk1OK1BjbExDL2NiTncvRFYzT0R4UXRWTFFxajBMakZvd2RsVkRseHJZNllhOVNlZ2xPMUF2UXBBWElRS3ZzZlZCSnpHeUpWQ2xtSWhKM01haWhoV3MwMzlOeEhhY1lERW1xY0VXcXU4YlNydFlyUmJiaXZHQ0YzajA3NXA3SXFPS1FUKzFyNVVKaUJJbmlrcmNtSnZOMGdOUkZSSlhTSkJwN2FOZkI2U0FNVUI0eHBBeUZJY2N2WENQRy9BKy81WnhGdXlEZmJaeXlLaGNkYXVEL3dQS2EyOEhybFoyeXl4S1V0L3d3ZC9pelY0cHo3WG5Td2hkaWx0Nk0raXczNlp1eFJWTnh1Z1Nsclh1ZmpDQW9YLy9mZHYrdmtxWFFMeUwwT1ZRcDd2MmtpUzlSRzkrSWZ4aC9Nb3FZQlpWY0RwQUMvZkk4ajFZMVdURmhFZHJLckttdXRhdG9zaGlaMEljZUJsOVRTZ0lXOEc3eitIT3MwV1I5TEYrUERBSjdiOFliSDk5Qzd4RmI1dnZuU3BnaC9kRG9HeURYbmhGa281a2xwZW5FNG5NRVc1ZlA1SnZIOG9keFhRSm16dlV6aC9oeHZZam1VUmllbm1aM3NOWXRMci9SNVVrOUY5cDI2V3YzVEpkbWJXdnZPbG8rUG51ZjhtRk9hcFhmQm02VjZXWjBCd2tlS1U1aGphTU5lYjd0WVd0ZnF0ZzBkL3N2bDlScm54NlNoVERNdVR5N1lWWllhNHVoeTk1NmJ2VFBFUlRxZnhZcFJUditTMnpYUkkyczRBRHlBVnU3bHhmV1F6cTlXQ1JyV1dkdlNPVEU4TTMwZW1iYlkvUXd5czlFZ3RsSUxaeXhPRVRsZjhObFA2R0MzekRKUTN4NTZBdmNYdnhmckNZUlZDTUtFUmoyKzBYWlN2dE5oVTJNa3l6TVlQcVVYUklxdzFhQkVPcmhEY2pReThib0tlSXFqZUhYdWJ3OEdNY1pmNWtOdGs5a2N4bWsrZm5nSy8rV2FOaVBBdDg5WFBuazludWY1YnhDcGJmTEV2U001amdaeVJKUnU5UTVQTitZaVhobjJjMkw5cWw0andqazJjN2VSWXlvNGN6NlNEMmpHaytFd3ZTWjdLLytpWG9YVi9TcFdkRjhWbEpmMTVXR0g0NEhSSVFDcHYzaHM5c0dqbjlpSmgzR3R3SlFjdURPY2hucEt0c1BSTXAvaUhUQnV3bEFNU05CeU1Eb2ZoVGJGRWNZYldwS25rTlhwU1B4OHBaUFlhOFZEeWhFVUFBcVhyU2xYRVN5NW1FazQ2VlVVYUxwZU9wbENtSkNoMGRKV0s0R2ZaMk5wRWNIRWtIYUZSMjZqRmQwYk5KVFNaU1V0YUlJUmF4Sk9HU0hFOW1pNDRSUXpyUll2R0VDVFJiQ1puS3hNTHNocUtVZExaY3VUOTU3Z2JZczM5NlVycm1MdVlUYjBSUTE5emgvTjAzTEN1R2dWdW5mYXNnRFBPb2t2TnowUjRYOXl5UE9qc3NKd2FJbjUxK2Yxc0NOaGZZaFVIdktwWWF1dzd0YXBTS3cxNmlta1lIMHRXRTkzdDk2L24zK0VJaXlFNDBWaG9UMmVDUHRBYlkzT25mZEVNemgvS2xzK2xxTlgyMmxCLzZYdDl3M2oxSmx4N0cyZXlJWWhVS2xqS1MzYUEvakFuemRCVzFzUmNvekprSEh1d0UybFFoaFRuN09EMGJCaDF1R3p0UXJ3SytoVFlvREZ2UExBWnEwa29FWmJacldBN2lkbElORnM5c0RYY2ZKNDdTenlUYWhiMkZkc0pIeGFPRGJScHUyejZiaXBtU1BqVE5ZM2xORCttU0dVdk5icWY1ZHYrQmIwcCt0RlpKNW1Vd1lNajVaS1hHbjhtWG1UL2RXZUYrNFdmaG1VUmhtYUVPMWlEUE5GWC9MZVQySEo3bTJzQ2E0L0k3V1BTVU51d2RNSjQ5T3BZcnRCLzRQTDRLcy9UTWJXYTA3Z2VXR3R3K2VyT1JUTEdIV2pmR3R6UGp5MWpWemRWbjZ6bFhyZFNESUQra2toSnMvMkRIVGZoVmh6WTJSREJWZzRieThjbzQrOEQyditGK0VwMStTL2ltNkV6bithTnZENHZxVFJOUHdNRDNSSFdPM0VJcUhxQm12QXA1TTByRnArWFJ3aUxSa0lRa21oV1JXc2s4bG92ZWlFVG9xWVFJMHNoQ1lWU2V4dko4bGVjeGNkTnZjTGVKRHcxdXZuQWRDN2docThKTzRSRDQ5ZHhJTkcvNWpmVUljVTJSZDdQWmNEZU0zMUd5KzA4alEweW9ReU4xSjg1N1NzYjkvQlU5SmU4dERSMGZXdkx5TDErUkJTUnJacXNkQ3JGbEdrRTIzNFQrMDJ6a3ZiOGQ2RCsvRFAybjZkZEkwdmVUcE9ZenYwbmU3K2VGTzRSSGhhZUVEd3EveHVOWmpxRDVSb2duZ0dXampYb3BOZzRTbjdsQThCWVdLYUJGMGUxSDU1enVKWmE0SEpoMEdyTTlrMnBJZ0RMUExhK3NtOEx5RGZka3Y0aEs0a3k3NGJVVnZ3MFBCaVp4dG8rRm5raUxDcW1KNHRRdXkvYnl1a1lzVmJXSXB1YzkyOW8xSllvMW91SnNMc2dtRVoxVVM5MXZFVHFZRW8zb2xtbXBvaVVxdG1FWjlGeVVpQ2tXNWpwemhmRlNqdWlhUmh4VnN3M0QxbFNIYUpwT2NxWHBzZmVPVFZQTlpLSU1RNmZxcGVOK28rSEhMOUFaM1ZPeHBKamxpVjlZSW5vaW5xZzA0dlZVRG9zS0hWMUZuRXZWNDQwS3ZXeVFiZlpzc0JzbStOMmwyWGNqakVUWlZXV01pZUlUNHFvS0ZvbnF5aUpDdUx4UUxpK2NWRzNaY1pQMDJ5Ulp3WmlxblBSTGtxNGoyMnFDbGxEdi9nZjZzTXNUbUh4a3BXNFk5UldxYlgrRTRJbXlFSzBkSGgxczF4eHc4OXFvRytVTnR1djdDY2FUazV5SWJIS1NjNHNObnIvZTlrMUxlWTJjd3ZON2ZyS21Ibkh6d1o3ck9GZ1I2QnpYSHFpN2QyWHQ4V0R0MGRYbXVlZW5pcWJLSXRpclpuR0t6blgxTEZyTDFoUGVuN01pSG9JRFVoeWdDM1NDN043UnM2TjdzOEVUVnFtWnpVN2VPakZ4NjJRMjJ5eFpaclZReXNOUWw2Y1RIcXFGbjZPSExrTzM1ck1qS2hqVDFaRnNHT1BnTWgyL0hoZHl3cEN3SUp3UzdoVStKUHdLSUhUN2xTRWJLTTBiZlFkTHA3K2NqMm9oejFXakt5SG9HWndmZUJTL2dieW9QTUpjWkE0Q0pncHNWWG9oU3h1ZlJkaEFxc3owdmpmaXJQaVl6eDZNN3lWTEJmY3YzRUlwK1M1T1FQRUpRL2tMeGNpbTNOenVuSnZLZGw4NVRWUW5Idk95dHFWWnBtMXJWdDF0THFROEs1NXozb3JCUlhpK1ZrTi9uMXBvdW5WTHMyMlQzbVpudlZqY1VjbHAvRlluRjdkTzg1dStVYXl6ZGtaZmxIaHVaTHRiS0xqYlIzTHhYK1o4RmQxdks0YWhiSGVyUkU0bVpWSjF0MXNxR1l0bjZacGNqcHVHa2krbmZUdTUwQXl5cXVQbXhweWNobnpJZHI3Mm5telFYRWphZnJxY1Z3d3pMbE5GTFJzZkl5cGRlZVdjc1p6cmlQdytaZ2NDclA3TFFsRTRDUHlqZFlWNTZOSEpPMFIyZ013NXJRL1YyUWw3cHhIMTB6cC9wNGg2dEZHREtmVDFTaXBUdFE5blMzSDd4Wmd4WlZhTVQ5UnZMbVVXZEsySWJUdXdDemVWUGk4U1BDbUsvOUZWOCttYkpVdVRUa3VxTFoyVExSWGZTVlB5R1FpYThPWlVCU1ZLdXRIT2xnNE4vYnBSTVNkam92bWluU2htRHR0RG1TMnVPMnJuVmZkcldKd1NpZmo1WUcvQm44ZWFKWjJSYVg1M1l0V2krZG1xZEFhcmRtaW4rNzkwUG5HQlc5UUgwekxpTXdIZkdZZTZhWkc3cThmZHJ5djdKeTBUdlR0V2l5VU1NNTJkV3JqNTU4d0dPdFI5Q2t0VGtpNzkvRE16WGdrYjA1UDBCdlJ1MDBvVXlpTUxFL081a3Y0ck52cExlcGVCcHlUcE43MjNqa3p0S1VrRE12ZkI5dVkzUWtteWdDZSt4eVZzSVFmQ29Tc0RKYUUzTUhBZDJUWnBXdXVKWkNVNE1UeTJLRXZsVXVWWTg3Zk1vUytYTVU1OW13NUJXTVV2TmN1MWNxWWc0dEdoeXY3WnlkaVE4ZHZOWTVWU1JaWVh4NFpQQkpWa1lqMkcwRy9SbTVvdjBkdnBJUGJITHNibHpQNXliUXlMK1pEekNQYVVKNFRqd2dyVjc0UUVHNEVZS3d5UXdyQ0hEQkV3MkJRNnpvbzJMcklZN2l5Z2hxdzAyblUydVY2amVkQVVBQVQ5c0RHMU1SM0MvTWovbXM2MDA1TW56em1pazAvT0p1NjhJemxORThpNVQrbU1lMk82a3JIRm5DMm1TOVpPYnp4bHJEdVRGWFRlR2ZNdDRwbTFDallWZkN1bXMrcHRrRHBJWnlqcFZvbW0wam5UbS92aTlJcWExdktxdGovdWFlaEpUYzFydnZxRnV5ZUcwZnZPTGJiVk94T3p5VHo5MW5QM0p1R3JaeEozcTZseGI2ZFZTb3Z4ckdobkZIM01HKy9vbjArSWxUOTBoMU9aT2MvTXBURjhBNDRSZkpDbThISFpKUFQ3YWFvNlpIcGtkdXM3NEV2U0tyck5qQ08xKzJITmg2Ly96dnhVdVBmN1pZYTlTZ2t0NFUzQTZ5RzNPUkVDbzgzcWdXSXdFMzZmaDRQUmF6SEdIb2lKV09rQkxFTUFHZ2VlMFlhcmhLN0pFUFowamhtMW1Mc1E0M1hqREcvZ0xPU3hvT1FFbmJES1NTZmo3d3RnSWIrUVNQdHVvaEtYTVF0UTdHOXgzRnR3cG03Rm1qR3JucUdMTTZWZU5wQ1gySmJ3a0ZHdUs5S2RNUWx2bzNxdVdXNG9LcklzK0ZPaUEvMVRsWWIzRzlsU3BUNDJVcC8yN2U3TmNUK0QydFZpSnYwRldPdWhGMFdwVmFxZXN4MkQvamgycWppZXFpL2Ezd2JINUcvYmkvWFVlUEdMMzRjYnY2OU1WcDNKVWFwNnlPK1JaWWs4Q2xiS1I0a2swMU9hR3B0d3FwUFIrcHI1eUFPdjZXby8vdkVOd05ScWcveXJzaHZabWEraWd0ZnBMTzMxRGVYMUhua0hYWkFFYkk2OEJsRHRzdERYQnRES0ZYZTBBbDB0TmZuMDBDeXBlb05EdmxDY3F4YUE0ZG81Y0R0TE1zaFhYM081L3lvM1pFMHJ3OTdPV0dhSUJldkpDakFJWDJHeU9nZCs4aitackdxUmhCU0dDNjVXcmhEUHROOGVnSXpldUpCRVRnZTdWR0tMOEUzU3VidTUxQU82WGJweENmMDF4OU10TVR4ZGFWQTBwYVgrWGdtejA1VFJCU2FibjdnVnZZN1c4RHFlY1dnYmVRWDlGZk5oS0FFK3ZBOExoMkFGMCswZUtGem1wdXNad0N5aDczMld1OFFsdXY4cnYzQTRqNUlKZHQ3OTdlUjh6Vm4rbmVCM25yOERTWi9sL0dGd3orRUZkZytjWDA3VzVwTEx3Zk4zVUYwdjRyVUIzOThxODhhNkNXSjZPek1KdHRoUFhMblpWWFZuK0ZiZ2pkempiL0xpMlplbWlsRWFScVJYNkdIcnlzcEt2bEg0aDZ0ZC9MTlhXZXdwY1JYQ3VGL29SU2Z2Qjd0ZkN6N29aYk1lbXJ6bVd4L3NYK24xa2N1aEx3NUV5QVNrckQySVZ1Rmw5UHRrU1p2c2QwN0lxampYNW9CSE1XNm1yTk9ESEorbnJSUVFIcjI4d1FDdEtYUzU5Y2dqZEJwVE5MUm1uV2FPbWZ3em5kTVcvMkQzaGQ3dC9LUHl3M3NmbHNGM2ZJQ0x3UlVDWVppdW96dWc2VzFnWkhBSUc4VGFwRTNBWFpIcHl3MW1sYVdUK2p6Vm4ra2d6bUlpdFBFT091R3pVNTkrZ0M2ZllScXFEL0F6bk91OGQ3NDhldXFkUnJKZUpjRlFwVGprZUYrZEdGV214dEJRcGJrdll5OGN6MmdacDU3TnZTdDVmSHNDVGV4TkZSZk0xTWpNemoyRnh2ajRCcjZHN3I5T1pCcU5iRHZST3FDSTIzOW1LcFlMUnFaZm5QaFh1N1RNL0QwanVsY29aVzViNk13UGwzMnorL2VkdTNNVE0vbWowOFhaYXJFVWQ5VzBhWWNjWHBmUkdzUDVOMERiQXVaVFdNMm5DQXYzUldmWjJYcURUckwwc1VTREVtQVdHRFRkQmZnbU9rNGdVbGZNc21JUW00djJLTzllSzZYY2ZnOTRjOTF6dTVLeWdrT0tmdXFVcmh4Q2hpUVpNYXhtaWhrVngraUoyUnh2bnV1K29Gdks3Y3p6NjNiRktoeFMxcFJEMEo3VXFPK0EvYmRGeDVZOXdpM0MyNFIzVWgwQWhZRlpVSkZScm1ObWZ2Q1o3UXdxb0xSZHdQSFE1dGNPMyttOUFWRE4zbDErV01mNWRzUGxEcU9OYUx6eWVWUXpIdkpNUFB2cXIwb0l5MWpINGhtZStKTkt3OGdtSnB0UTkwKzdBYTF3N1ovYW5XSjJhUDkydVBRV1Z3Nm9yZ2JKOThkc0xwZkVaU2FINXM1SU1POG1tTDZoYjBkL1JWZkloR2JjTGZFRWVxKzdwMW5JdWJYbTFORU15RXgyYTlralZFeTFUbVYxMTlLODIvbndZM1dNamRpblkzNVdVZnltQ1RmOW82RlJxV0pzMm4vd05KVmkwQk9wL3I2N21MUUpINnN2STRFOTd3S3d6cjNta3hXdTlSelBYdXVad1I3UE4ra1k4Q0xUMTdZTHR3b24yUjRQUkdhWTU0MkpiZTh5ZXF2R0ZXM3R5aXZYYTMxaWh3dGNibmM2YlNibjdmdFgrR09SSzQxR2hWMXFUajU5dzIxMC9RQ1hMSzZzdm0rMXd1UlpmK3hBK0Jpd3UrZndIcGNKTTNQMC9PdG96SExZbHI5RzVaSVc4blNrMlIzRjJoMGNIRGw1L1J3UDhUbmoxT3FLekYwbndqR3pYWnYzWlcrUWNVNk12OERwNGpndDNuZlc0ZWZDaFRQZFM0N1R2UlNMcytGWlIzRkNVRnhuSi9FVnR2TndXV0Q3aDRxMnRoS3NYRnhCK2dPcStnQkpXOTNQd3BpT2p1dlNneGcvS0JuZGY4ZlByWFJvbytMMTRGelBlM2dzb0w2cG9qeUE2d2VQVXZodDMwZzFCTEN3c1BLaE5mWUNOaGUybjczMlduVzU2TVIrRE9WYllGcjRqMlBPZWlmb1BIMGpWUWw1R0dHdk5FZHIwdUErWEgzZUkyc1RGejV0aVRNdVhVMDQxVG1xTTJ4d1FXZzNCang4ZkQ0a29ZNmx2NkpieFVxbDJFdDAxMGZQanE3RFlXVjBQM2NqR2psQXRuRSszbG5hL1NXc28xdHVoelo1ZSs3QXNRTzVmdksreFd5Mit4NTZJSDBtdW44eEtoSEc3UExPT2hzMXhGNmRtSTNNRlNyQ0R1R3djRHZNd3lIMmM4UHVXZU1xdGpHT1RTTlIvSUlHTExHVTZmblpCbzhjaWVwc0dSVzUrS0QxbmQ3eXdXVnZKOWkrd0c1Vy8rNkFIeGZtWmpNbk5tNnhBbHZqTVlkT3kzWlJsRTBURjlPMjJTTXlSMnNncDNxMnU4NHk2bVRyQXk1ZTNJYUdPakduVkdiY2ZTUGxraE5ieTdlc200Z3B5MlF2U2xqSkNJdkZzVHM4dG13THRKQ2E3eEhPN2sySGtBbjZtSW9pYlA3NTBackZuMkdHVks4QjJqaUw4dFZ1OUFNam9aZXdLRWtqeE1UYm5pVWFDZ3JOckZoSXlaTEdRbzAvcGoxdFNGdnlzdmF6eHFFWnFwSk9OT1RwcFlsYkoyZmY3TTJxa2dieHVaV2ZWOGxmcHdwaXRsbEFYRnZ0NkUvRlJDazl0VVEvTUxJdkVUaDN0Q2R2bldpUHNYSGl4NWN2MGY3MWI5Z2UrUzY2NGwwRlhTVGNHdTlIRVZFSWQ3VU5RVFJnMTY5ejdMTlBZQUFGWXJ5Mno2R3Z3T2NGZkZwTUxVRThUZzc5cmJDb1J4eGN4dURwbklJY2h1WnY1K3IxK1hvOXh6ZGZmcGlUNVl3c0dyUjlwcXZ4ZktZNE5ET1dLdVRxcGxGeXA0bzNIN201R0RjK0twdlNMWklvZjBUU3UyOXlzcHFWTWpRUmlRUi9YRXBuSnBlMmpBMjNOSzFabjZ5M2d2UmVFNG5TcktUTHdYbU1SSVRocSticnAvakcwdEU0bGxLWUZHVk5jZ3FHbyttK1g4OVpXVzNiazFQRlVxbGtKMjdEV0xwWGprbVBZSFRTb3UrbmJLMzc1elNmazZUdU51ampPVFV6MzZvWnFxN1k3U0dhU1F2VFpuZzNMVWdZZzFKOEREM1BaTnNBbnNIYTFTUUxnaUU5cXd0ejQweTFlV0FMSmJyTXdjTmVTa0VkYmdRdGMranpsOERXUGZQKzk4OHdhN2UwK09FUEwwcG42S1hEYno5MzlyN0QvT0x4aDFaWEh6b3U0VFZ1eFZ6aklPY0xzb1RIZzJBY2cxdVhORE0wUkxNNEswa0hjOWxzN2lEejlaS09GUEw1d2hFSm5FOUp4Q3ZFZVNlSGVYeWthRGMwQ2pMVlQyem04Q3ozNEVWaUQwdC9rVC92Qi9tVENKblJOdkRaQnQzT0JuTFlqZEdwUW82ejdRTjc1NTlrK0k5TGJNSlpIYkE1L0hSOWpnZTVoYVZCRU92UDdkN05FRVNZdmpMRXo2YnphKy9JMzNlTlQvVE9OOVVsdzlhVlY2OExuUlJyRWQ3eGFtVkY2ejJ4WHEwOGx3TE9KeUFnamkyalB3WWRLTXJ3cUNIUEZFR1h1bXhodzN3bGc5NHdHTVY2V1dlbEcyTXJzcDdQUkYvam1PRmxsWHNGTE10UnFabHhqSVBYZXFpZ1Z3RDFPc2tLMk9HSjdqWU9lZTFlUUN1ME9rRFl0UUxSR3ZLcFMvd053TXBPY3Jnc1M4QUhHVkQyTUFzSjlBcXQ1Q1dhRlFmTi9yTzA2NVdydGV2MW4ycTdWdGpZQWpFU0lUYkluWFNWY3Avd0w0Vkh3QmM1WExxekhWa2dUcWcyZWhRS3ZWU3A3eUhYSjVQM2UrUUtNLzFVbEZlRHFvZktqRkwxV1M3QWg3TWt6cFRvcU1WUDJ0WEdqTWhzSXZNSlVTRUppYURrQnh4RUpFZFNrUE5Na3FZU3Npckc1K0dXVHV4bWVEaytUYThXNkoyeisyWVJrZlAwenBuajhNYk4xcDhpU2Z2MEk3R1ZCWW11VERERytac25UREVUTzBXd2lDU3BlRWcvSFR0UGw5WnlYRmIyRVUyV0RoMlNaSDdVeUQ1MmVZRWR2d09YdjhPUC9QSU9yN253U1R1ajJvNTF2amtqTDN6U3o2Z1orM3h6UVloc3Z6OWkvc1YxWVFMYVFjUkFWbU9XTTRVYmJEanJLNDlOcU1DOFRoZm1DclBzMUtxTjlrd3ZadFQwL01PY0hnWTk2TzBmZFZQUHBYZE4rTS9KSXdkdTIrOXBUdklkcWRRN2tzNzN4dnhQV3ZtbWhlNThyTmw4TE5GVFFnSk8rZktwMm9qOG5EK3hLLzFjeWdWVnBCWUg2dVpEL3RnbnJXYmUrdCtkVHFIS1ZKYXFNS0R6ZjBXNFRWZ1J6Z25QZ25kQWUyYkFKbGJsVFpqemFVYlJLWHYyc2F1bHJveG0zM09BaW5wSXRGRzRtWWttc1FueU40SVN1SndvZitiSnM2QVZuK1VrYkN3YVRLckRMejBKeC9CdHBtNzNMNytKSzI0ZjR5OC9nT3ZjbnNRVmNXWlZ3Z3NCQkF5OEdMRFBNdmZyRkhNOWFPYkRTd05IWnA1S0QxeTRFSHB0OStMUzlJMU4zWUUwakoyMGhVRHM4NHRvRi9vRVlEYVozU25zQy9YTkhldzFUWkx0bVlIdWltWjlJdDFtV1VqVDFkdXc0aXVLZElaRjJuaVRjeGU4M0tYSXJxemNDY2s3RXdmaFpmRnUybXN1a0k5bFM0NFgveGd4eVhOTTN3dTRZZllodU9XaHdTdlBFVk1RL2ovaldZbUNBSGljWTJCa1lHQUE0cmQ5enEvaitXMitNbkF6TVlEQXRWMUs5MkQwL3kvL2R6TzFNSjRCY2prWW1FQ3FBWVMvRG9NQUFBQjRuR05nWkdCZ1BQRC9BQU1EVThQL0wvKy9NN1V3QUVXUUFkTlpBTHJVQ0VNQUFBQjRuSTFXMjIza01BeWt0aEtYd2xKU2lrcTVVb3lyWkV2WWp3REpKV3ZwUkpGRFViSVh5UWRoVzViNG1CblNKaUpLTzlHTjFPVCtiUFY1eSsxOXJzZU5hMGxVYStLMkxpYjN6YWp0RTVONytJclcvV1QzVi9XK1hhL2k1ZlA5Ny95OXNFdC9rclBrcXZuU1JZeVRzZFdXWWUwNTYxcjMvZERuZHYzQSt0aDdZV3k1c09DdytNcUdiOE83NVZpOHhrZXplLzNXdlJadnQxeW1YT0hiOE1yaitoS24vUUxycldOVlR2Z3pPTC9nVUhCaXhGN1BoaHE3WHJUT2lGVmYyK3UzK0VsU0g1dmVQUGFvNTZVdThoS0RmcTdYejYyK3dYTzB2bC91N2NwbXVyKzRYdFFLY3ZNcmFrVjhEalp4Q1o2WGZNTmVyVm42MEdMR1BEbjR5c3BMMTVyaDJEbFVudXFFQmRPSnIrYnJJTWR0N0lmT1BEK2M1U1YrNTBHMGE3WC94cUQ3SHl6aTFjNlV2c1lEdjdaMklDL3IxYThiY2tGdWovclBuMXV0YVhPZlIzLy9SM2xvT0Q1N25XL0JHQmpJdS9vMXNOVGU5aGthZWJYNnRQOERyMlQ5UTlaLzZQV1kvMUkvR1U1K3pqVXl0QW5lcDE0eFhhUTFkaDR6cXEwOXRZY2FKbllkTTZYMTZUcDd5TTdzczg0VGhWbEJHak0rVHppUTlTeHFSRjJtSjVtQmFaUFlNLy9nTEdFZjlNZEQ0enFqWnZONmdRY0hmeHhpQkQrWXY4YlBnWmt3OVlYcXI5aDljZXMrTWR1N0R0NnhicnlWeVBWbERZZ1Q4Sm53OEg2ZmRlTnpRV2VGeitma0dMUytPUEVaZGVWbnRSK0V0OXE0MkVlTWhMaGo3MU8rWFQ3UGFOUTB6WTJJTlF3NTUza2ZkRGIwSFB4dVEzZFREUE9YL2dMM29CMk8rdER2enR5emdWY08rYnFmbGZ2bHpPUUh1UTQ4THI5Tk9YNUxuWjlxOHlwOEYwNXp0cTZtR3JWNW1CY2NPV2dyR3dkNGp4aDN6T1FRUi9URE5sdlo4eXVlcTh6UlBkYnJOWjk3TjlTQi82SHhYd1F1QW03QzBUM29hT3R6b2JydUgxWm5uRy9Xci80L3BQNC96enpQR2gxem9aYi8zcUdPTEFCNG5EV1dDMVRQZHhqR24rOVhhSnU3RUVJUlNxRVJpelZDQ0xrV0dxRVJRaU5iSTdRSm9abjdOYmsxY3RsazYyeHQyb1JHeHF5WlN5UFc1dGFNYWVTMmhjdys3Wnc1NXptLzMrLzdmZC9uZmQ3bmZmMVAwdi8vako5azA2UUtIcExESUttaUE4aVNLc1ZJbGQwbHgxTHB4VWlwS3UvVnlwRXVWZmNGMlZLTlFMQVNGRWcxdWF0SlRpM09haFZMdGRkS1R2NmdTS29USmRWMUJybFN2VmpKbVZqblBWSjliM0JGYWtCc3d5QlFKcm5BM3loY2Fsd0ZVS05KQUlEUE5WbHlnOXV0UkdvYUN1QnRScjFtNUxnbmdadFNjemhhMEZPTFRLa2xOVDFjQUwxNStnQjZha1YrSzc2OTZOT0x2bHJ6M2ZxMDFDWk1hZ3ZYeTQ2QSt1MHlwUFk4ZmZHa1E2clVzVkR5Y3dYMDJvbTR6bkQ0QjB1dkpVaGRlSGFoLzY1b0RlRFpqZHJkMFJpSWp6M0o2VWwrYitvSEVkY0hQWDNRMlEvOS9ZZ0pwb2YrRDZVQitES1FQZ2FqSXdUOUlYQ0ZFaE5LMzhPaXBlRzhENmRtR1AyTmdHZGtPZUFKeDhQUmFCekRmQ0x3T2dMT045QTNGb3lESTVMZXhpK1ZKakRqaWZnK0NkOG4wOWNVL0lwRys1dDROQlZ0MHppUFlSWXhlZEwwRTlKYnpPUnQrb2dsYmdZOXpDQm5Kak9mQ1djY25zVnhIa2ZjTFB5YVJYK3p1WnZOOXh6bU5tZXpGQS9leGUrNTlETTNYMHFBYXg3MTU1TTdIeThYeEFOcUxZUjdFWFVYc3h0SjVDemgrd042UTdLV2NiYWNIVmlPbGhYVVhZWEcxZml3aG43WDBPYzZ6dGZEdVFFTkc5Q1FqSWJrSEdrakhtMmtaZ3BhVXRDZGdyK2IyS0ZOZUwwNVVkcEMvaGEwYnEwQjROaUdkOXZnVDhYZkQvRnJlNXkwQTg0ZDdFQWFjVHU1MjBVdnUrSGFnOThmb2VGajluVXYrNWlPcG5UNDkzSDNDUjUveWh3ejRjc2s3d3Z5djZTWC9SRlNGcjFrd2ZNVmVWOHp6d1BvemNhSGd6d1BNWVBEN0VVTzc5K1Fld1NOUjVsZkxySEgwSEVNL20rSlBVN3RFM0IraDI4bnVmK2V1enpxL3VBa25XTFhUdUhKajh6bE5EdDZCcC9QNHNNNTZwNmpyM3o4UDQvVzgzQmRvRTRCZHdVOEx4SjNFZDh2RWZNek15bkV3MEswLzhMWnIzajJLL0dYNGJ0Q3oxZXBjNVg2MTNpL3pvQ0txUFVidmQyZzd4dnM3dTlvdVluK1cvaDdDLzl2RTMrYjgyTDYrSk1kdTBPOXUvUmVndlo3NEQ2eEQ4QkRadkNJdTcvbzYyL3FsaEwvbU5rOVFlTlQ5RC9sLzBBWlo4L1k5My93OEhtaWpLSmx6Q0FaR3dmS1pCeFNaU3B4VmlsWHBuS2FqT05LbVJjaVpWNXlrYW5pQVRKbHFvYUNISmxxNUZYUGs2bFJJbFBMQ1JCYk8wSEdpYnc2eE5YbHZCNjg5VTdMT01OWDN4MVFveUY1TGc2Z1VLYlJXcG5HNlRKTmJzcTQrY2cwZFFWRk1zMkFlNmxNQzJxMkRKUHhRS3RuaG93WE1kN1VibE5EcGkxOFB0eTFjd1RGTXUzM3lQaEd5WFR3QndVeUhkSHdpdDkvUDh2R0QwMmRRT2NJR1g4NC9mTmx1cUNqYTd4TUFIbmQrTzZPamg0eE1vRnc5Z3lYNlpVbDA1dWNJTzc2bkpEcG15M1RqN3RnT1B2RDBSK3ZCaEEzRUIwRDZYVVF2UXltcnlIVUNQR1ZHUXJYTUhvZmp1N1gwVHNpRnFCclpDQ2daamllamFvaU01cm5HRFNPb1Y0RW5vd2xibHl3VEdRNU9Cc1B6d1Q2bmdEWFJQcWJTUDlSem9EektIUk5Rc3VrSklDSGs0TmtwdUI1TkZxbkVqc3RRSVlWTVRIa1RJZHZPakZ2VWZ0dGNtTHA0eDN1M29GakJyT2JpZmR4YUluRHkxbk1kUTY5eCtQSnU5eS9SMjl6dVpzTFR3TDY1cEUzai94NXpHaytjUXZnVzRBZmlkUk01R3doTVl2d2JUSGZTZmlUbEN6elByTmZ3a3lYc2ovTGVDNW5waXZ3YWlYN3RncWRxOW14MWNTdG9ZYzE3TXRhZWxoSC9uck9ONUNiek4xR2NqZWlJWVdkVE1IelRjUnNaaVpiOEhRckhtMGpKaFZkcWZCdlp5KzJ3N09EMkIzMGtBYlhUbnJZU1grNzZHODM5WGVqOVNQcWZYeEZaaTk2MC9GdUgvWDJNWWRQOFBSVGNqTEkvd3lkbnpQYno2bVppWWRmVW1zL05iT28vUlg2ditiOVFEbndOcHVaWmpPYmczQWM0bmtZSFlmUmtVUHVFZktPb2lHWG1GenFIY1AzYjhrN3puNGNSL04zeEo3ay9TU3ovcDZhZVh6bm9mVVV2RCtpK3d5YXpwSi9GcjV6K0oyUDd6L3hQSS9PQzJndmdPc2llMzBKL2t2ay9JejJRdndvaE84WGR1OHlkMWQ0WGtYek5lNnVlOHY4eHE3ZUlQNEdIdnlPbmx2OEgvNERuMi9UNzIxaWl6bS93N3p2RWxmQytUM3U3NVAvQVA1SDFQc0wvQTFLbWVIamNuRC9CRTFQbVJNL1c2YU1YWGlHM24vbzl6bTc4UHltckp4QW5LenhCeXRsclF0SUJNV3lGVXBrSFdKbEsvTG5WTVU4MlVxbHNwWHpaUjNMWkY5MEJUbXlWYm1yeG5zMTdxcWZsdVUzeU5Za3QxYXliTzFCc2s3T0lFMjJEclhxUnNyV2c5ODVRcmErQnpnaDJ5QlR0aUY1allodHpGMWpORFFKazNXRjB6VlYxZzFkYm5BMzVieFpBSURmbmZQbXhMY0lrbTFKdmlkNW5ybXlyVGJMZWhIdmhUN3ZJdG5XQmJKdHFOMFdEVzBmeXZxUTk3S1BiRHUrMjZQYkY3NE85TjhSTFIzUjhncmNmdlRVeVYyMmM0THNxekd5L2t0bHV4SWZrQzdielUrMmV5Q0FxMGVTYkNCMWUzckw5b0tyRnozM0ppWUlUWDNRM3hkUCsxRTdPRnkyUDNrRDBEOFFmWU9qWkllUUc0TCtVSFFPSlc4WWRZYWpJeXhlOW5VMGozU1FEYWYvY0xTTW9oLytIcktqQzJYSGdBaDQzMkFXWTZrN0RpMlJWUUE1NDZrOUlVTjJZclFzdjBWMjBsclp5Y0d5VTlETzMwWjJTcFpzTkhkdjB0dFVPS2FoS1FaOTB5UCtCWUF6b1ZoNG5HTmdaR0JnT3NzNGtVR0VBUVNZZ0pnTENCa1kvb1A1REFBdU1BS01BSGljcFpITFNnTXhHSVZQZWdQYnJsU2tLd2tvUlJDbXBUQ2J1dXFtM1hSUkVMb1Vlc24wUW1kU1prSkwzOE90NytCaitCUStnTGgyN1pucFgvQ0NJamdoeWZlZm5QOFFNZ0NPOFF5Ri9WZmwzTE9pWGhYT29ZaHo0VHhxdUJBdWtHK0VpNmpnVnJpRVU5d0psM0dOV0xpQ0V6d3dRUldPV05Yd0tLeHdpU2ZoSER0ZWhmTm80azI0Z0thcUN4ZHhwb2JDSlZ5cGxYQVpRM1V2WEVGZHZYUnQ1SFJuYXhJYm1vK3NmVDJJYlg4eG03dnZzdjVWSDVvNFdkaEkrMTR6dFlqRFA4VDFUR1Rpa1ROVFBkN3BaRE5yT1Jmb0lMYWhUdDFtdGJKNkhkdWxtVGh2N3R5NjNXZ0VvbnNURzZJTGl3Z09HaDFzWVpDd0Rybi9wR3Y0bkFPK3NFVWZDOHd3cCtzdmJ2MFAvNUJuTVYyTHJDOTFlZnhUaDVUUEdmNjMyL1dvUmxuQ2lKWEJsQWxqN0xnbTJORFRvdW9Rc0E2eXpwQjB5RFpZY2FTM1dXZG5TeW9UNmw2VzdLaTIwZUFJdnZnOXVwajBEbnpHaTNJQUFIaWNiVmtGdU96VUVYNHpzeTVYM25zNEZDdVVBb3RUdEtXNEZHbWhMUzdaNU93bWI3TkpYbVQzN3FNQ3hWMWFhSEZwQzdUUTR1N1E0bEIzZDNmM3pqa24yYzFldU4rM3lmOVBqaVJIWnY0NWR3a3UwWC9GSmEvNWh5OERBa0VCaWxDQ01sU2dDaldvUXdPYU1BT3pNQWZ6c0JTV3dYSllEVmFITldCTldBdldoblZnWFZnUFhnZnJ3d2F3SVd3RUc4UHJZUlBZRk40QW04RWJZWFBZQXJhRUZtd0ZXOE0yc0Mxc0I5dkREckFqdkFsMmdwMWhGOWdWZG9QZDRjM3dGdGdEM2dwN3dsNndOK3dEKzhKK3NEOGNBQWZDUWZBMk9CZ09nVVBoTUhnN3ZBTU9oeVBnbmZBdWVEY2NDVWZCMFhBTUhBdkh3ZkZ3QXB3SUo0RUJiVERCQWdFZDZJSU5EcXlBSHJqUUJ3OThDR0FsaEJCQkRBa01ZQWdMTUlKVmNESzhCOTRMNzRQM3d5bHdLbndBVG9QVDRRdzRFODZDcytFY09CZk9nL1BoQXJnUUxvS0w0Uks0RkQ0SUg0TEw0SEw0TUh3RXJvQXI0U3E0R3E2QmErRTZ1QjV1Z0J2aG8vQXgrRGpjQkRmRExmQUorQ1RjQ3JmQnArRFRjRHZjQVhmQ1hYQTMzQVAzd24xd1B6d0FEOEpEOERBOEFvL0NZL0E0UEFGUHdsUHdOSHdHUGd2UHdMUHdIRHdQTDhDTDhCSzhESy9BNStEejhBWDRJbndKdmd4ZmdhL0MxK0RyOEEzNEpud0x2ZzNmZ2UvQzkrRDc4QVA0SWZ3SWZndy9nWi9DeitEbjhBdjRKZndLZmcyL2dkL0M3K0QzOEFmNEkvd0ovZ3gvZ2IvQzMrRHY4QS80Si93TC9nMy9nZi9DLzNBSkFpSVNGckNJSlN4akJhdFl3em8yc0lrek9JdHpPSTlMY1JrdXg5VndkVndEMThTMWNHMWNCOWZGOWZCMXVENXVnQnZpUnJneHZoNDN3VTN4RGJnWnZoRTN4eTF3UzJ6aFZyZzFib1BiNG5hNFBlNkFPK0tiY0NmY0dYZkJYWEUzM0IzZmpHL0JQZkN0dUNmdWhYdmpQcmd2N29mNzR3RjRJQjZFYjhPRDhSQThGQS9EdCtNNzhIQThBdCtKNzhKMzQ1RjRGQjZOeCtDeGVCd2VqeWZnaVhnU0d0aEdFeTBVMk1FdTJ1amdDdXloaTMzMDBNY0FWMktJRWNhWTRBQ0h1SUFqWElVbjQzdnd2ZmcrZkQrZWdxZmlCL0EwUEIzUHdEUHhMRHdiejhGejhUdzhIeS9BQy9FaXZCZ3Z3VXZ4Zy9naHZBd3Z4dy9qUi9BS3ZCS3Z3cXZ4R3J3V3I4UHI4UWE4RVQrS0g4T1A0MDE0TTk2Q244QlA0cTE0RzM0S1A0MjM0eDE0Sjk2RmQrTTllQy9laC9makEvZ2dQb1FQNHlQNEtENkdqK01UK0NRK2hVL2paL0N6K0F3K2k4L2g4L2dDdm9ndjRjdjRDbjRPUDQ5ZndDL2lsL0RMK0JYOEtuNE52NDdmd0cvaXQvRGIrQjM4TG40UHY0OC93Qi9pai9ESCtCUDhLZjRNZjQ2L3dGL2lyL0RYK0J2OExmNE9mNDkvd0QvaW4vRFArQmY4Sy80Ti80Ny93SC9pdi9EZitCLzhMLzZQbGhBUUVsR0JpbFNpTWxXb1NqV3FVNE9hTkVPek5FZnp0SlNXMFhKYWpWYW5OV2hOV292V3BuVm9YVnFQWGtmcjB3YTBJVzFFRzlQcmFSUGFsTjVBbTlFYmFYUGFncmFrRm0xRlc5TTJ0QzF0Ujl2VERyUWp2WWwyb3AxcEY5cVZkcVBkNmMzMEZ0cUQza3A3MGw2ME4rMUQrOUordEQ4ZFFBZlNRZlEyT3BnT29VUHBNSG83dllNT3B5UG9uZlF1ZWpjZFNVZlIwWFFNSFV2SDBmRjBBcDFJSjVGQmJUTEpJa0VkNnBKTkRxMmdIcm5VSjQ5OENtZ2xoUlJSVEFrTmFFZ0xOS0pWZERLOWg5NUw3NlAzMHlsMEtuMkFUcVBUNlF3Nms4NmlzK2tjT3BmT28vUHBBcnFRTHFLTDZSSzZsRDVJSDZMTDZITDZNSDJFcnFBcjZTcTZtcTZoYStrNnVwNXVvQnZwby9ReCtqamRSRGZUTGZRSitpVGRTcmZScCtqVGREdmRRWGZTWFhRMzNVUDMwbjEwUHoxQUQ5SkQ5REE5UW8vU1kvUTRQVUZQMGxQME5IMkdQa3ZQMExQMEhEMVBMOUNMOUJLOVRLOHNhUmlXRllvb2FyVjl2emNtcGhGYUpjTmFrVVJ4M1hDTnNOOHlYZC9rNTY3VDlWcW04R0lSTmpXUlpaek9xS2FaS3pxeWhvU2gwN1hqcXVHNkl1dzZJcW9hL1hiaUdwNHBOamI2SW5STXcydEZxb3JoZFJPaksxcU9iRFVJUmV4NDNSSVh0UDF3bnArNW9tWDVTVnZkaHQ2MFJYYTNkTXFpZXAyZE1pVkJMZU5ETDRYNlBSVlVOU29hSjBIWkNFM2JHWWpWakREMGh5M0RqVnVtRTVwcDdWZGJaVU9ydjhxcTJsejJLbk1TekV4c2k5cnJoSDZmSnlHTy9mNnlSVmJaeC9KRk50WEQwa1hHMk05M0lLdk5UcWlxa2Vzd1dwa1k0YXMrSzdVdStxelV1dml6VW5NUzVHeXhuMzdGL0pSTnoxVGVvaHFibXpMeCt6Y21oaVJJbThoTndMUWwxMmgrNEdlblRITDZGYy9WenczMmJNNGkyNXZMY2RYYVRNN0FMNWcycGhlUWdxcFUybkJ1VUtjdHVWZk5EK2JzbENrSlVqNGV4T2FZeXdabXhreFZib3dwdjFkRmt5UWR3VWdOb1owbmc5cUVWRkpvWjJCUTBtQWRJNG9jM3RFRGZtVytDNDgzWXlzYU1lcEhGWU52b1JQMTBPRHZUU3pIYjFraU1rTW5pQjNmcTdRTnN6ZGt4MUZ2R3hadlo5TVdacStvY0xOdHFKM2Zpa3pERmRRMlpHSFBhaG1PTEJ5YXZpWGtTelV5SEFyREdoT3U0NVZUVXVCN3hLMUZnbHQwVy9KU3lkZ3NnNTZJeHcveTNQYjlnT3ZHTnJjYTh6ZU1lSGpkdUprUjBRL2kwZmhSSjNIZE1iRU50ek9iRVRsTDB2TmxQSEtOeUY0OVk3RWRDcEdWaWFndHJFSmJpTERXRnZ3R3FtaEJ3bkxiTVVlOE1HdHR4L05OZG9ueWk1d3d0aTFqeEk2M0o0cHQxL0c0cnUrcVM4eVhmcnNnL1hORlh2cEcyR3UwL2FFclowWiszWmdFamhkVjIvNkNIbnBpVk9TZmlMakFnbnplZGYyQktMZER3MkduUE44T0hkRXhlZkJhZldHeE8zYXJZd3VYNGFVZ1Ftb24zVW83Y1Z5THF6TndYZmJKbmdLUkdQRnNKS0hIWmFJYTE1WmZFdnRoUTg2d1p4bWhuTkNaTVZGdjFCeFQ3akJlUG1FTHBtdjBEYm1JSmpYNmpwZEVreHFCbTBTVGg3SFRGMUVsbzl3OVJ4UkRMYUVVY2hRSi9aSW1YQzZJRWxkRXhHRnRubjlpeXFkUFc5UStuYkxvZlRwbFlwZWl1WW9vR2lxSG9LRjJDQnJuSGNLVUpkZlJsRU9ZTWlWQlJYUDJEQXppMXNTVFZSV1h3MUkzUmNnaG1LY3dGalhUMXNXRVVkV3dMY2RISVY0aklqVUdqbWlvS1VtL0tDVzYxNklpYzN5VnNzQ0piRC9RUTVzejFGUGk4MzZmMVZncEJGbXdudU16R3Zmazh1Tkh0UWxOMis5NThxdHo3V3REV2k4d2hsNnVucVJwYnlzVElieGNiNHFudFVMZUpibGFraFlWWE1iWFFlaDcrZWxmYkZQQmRwRXRuZEJwSTBlOXpKTFRKNHR0VTgzbE5jcjhJaU03N29sbDZJMkpiS0NaRVIyQU01WmJXNHR0VTkzbTE5ZjhJcU5jeXFrbENYaVVlSzgzMGcvMC9OaTBTNXJNbXE0VHFObldXM2xtd21XWXFJNXBVVTI3dkhwaW5xK1I0QnFHQ2hBODZVdlprbGpxalYzZnNMU1BtRExOYVpvRTJmTkczbEJVcEdDNlNidXVnZ003TXhhS0dwdCt2Ky93cEV2TSs3NHJDaEtXVEwvVEVZSk12OHU4RzVWTjMwMzZIdThhTHM1Q1Z2WlJUbkVsdmN0Qy9ZQWpZVVBlbFNMbVVzMHhHVHFXcUdSczN2UzlnUmo1WVl1OWU1d1d6Rm00MTJCVWxaZDBBa0xwL1pURWJyVTVMUGFtTEN3elBGN1RFMHVaNDZ2SmNheGdoaXcrK0JKRnR1R0VVY0ZNMnJ4VitjSnZtNFF5QUpDWnhCWExpQTBaRWd1V01EcDFqcys5V08vZmNvcXJsbU4wUFo2WXFNeW83M3NXV1o1UnQzeVhRNUdTNUFxblVYRmU0dzQ3ZHc1b3NwMWwweFpWcWpsbEt5cFdzL3pNWVZheTJhMVlTYjh0ZzJCQmZsOVJyQkJtUE1QVUNWaDB0R3kxYVNkMDhtUXcvV1RRRkR6QXJoK0lGdis4MlRIVGk3cVM4Uko3Znc1alZaR0V2dnF5Qm9jYW02VytraHVWakN6TkJhRDBqYWRNdXRYbGVWTWNPaXBqcU9lTU5iRVFLRlhqeHZNWkhBdXU1cFNsbmpLNWtFb2FjeFdXRFo3aFNqK3QzTmVhMDVaMHcvS0Q1YS8xb0RsbHJITjRibG04WWdMNStZeVYvaUJHelE2cnVGYW0xUnFLZGZ4UUV1b1lDNldPNkhOWWJYUWM0VnFzbTNqcGplb2R1WEJGMkZvaDRrckhjYlZZMDBCblN6Vk5wQ1RVVURtSnFvYThDVFdTYzY0Zjg2Z0pkeTZENHdGVUJxZlB5YUIrbGdxVFNYZXBRUmRVQ2tHL1QyQjFkQmN5SHM1cTVBODVtL1E1cWRTbGxXVFFjTUNqN3V2eVF6KzBDaExKZHZxeUk4bjZKYjd3Qjg5M25GQytvY3hJRTQ1N0lpeElDMWNOZWRSWXZjN3dpdS9xanhXOFpRdVNGdmtTOWVvZGxtODhaSEo5bGpRdWRIaHJOenUrbjlPb1kyWUx0eTlIMXc5N3J0T0p5K21VRk5rZkRMbUJKR1lsV082eW5nbllDM1lOWHQvVUZmMWFsd1dRQ0ZuYlJJVXVWMnQydWUrb3hSS1JYOWtwc3VCcmkyclhkenVxTjQyazg1enBob2FWcEF2ZUNDcDJ1b2pRM2hidDdkRGVmczZXeTlQMmxmTGpNTDlRVndiWFdjVXZWVk00TUhodHBWQVlwcGpWVUk2NDh1WjVyaEtySEZlZXNKa3pjUFNiTUJIT0tCSUtVemdEZm9HcXByd1lkWjNJZEtMSUR5UGRleFR3QTFXRVBXTlBsRzFlNmJIUkpkdXl5alpuRXR4QVRkNERtMk5TVkdRWXhsVjFiUXNqNWlJTFJ0ZjN5amJITVQ4YzFmV2Fid1dKN0UxanpvZk1YbFN3L2I1bzJINFVPTEZlbExOakVvMzZQRUdWakhQRkpOUnp3Uk0wTTJFcW5aalFLRmJ2a3ZHSzAySlh6bDlXY1RnMnlNeXA3bGc2TGtnSG51S2kyaUVsZGVVcW5sVDhqbGZWd0UvaW9rSWx6aUU0bERYNGxrUXhweWZTNDJXazduZ2RQM1YxR3V2NUwwak1MUTI0Sm85RlNYNkxZODZzWUcvUjh1VkpqWFF4eEVOUzRaK0s5NVhzK0tia2NwVG5MTXZsc0ZOMEJjZVZHVmZ3TWxWclFibnZDVzFvbUtpNFZNbElsUmUrVkNrODM2NWNINXhtdEF2U21URmxTUy85ZDBXS0RUVVdDdkNXVVBmRUxjajdERXNQdmFhVmw2MWtnclNwZ055SmtsWEhyQ0RSTWxZcTNkYjBzY3hpbTFKVGkydzZtQzh5c2t6UFdkUXV5SEcxQzNKYzc0S2NnY1dZeTdlQkU4bDgyazA0UEZsK1dPU0pkc3dTWHoyV0FkSTd6L1NOUUc1eWRqcHFaQ2UwTENIbmdWVjVseU1XRWFNNlA0eFNvZGxVbUJlQjN4TXRlNG9ONmpsV2tMakVEcmZueE5RWGRwa2xGUy9PVWJYdnNBaGhyeC9NS0tSMmxYeUx1UnhWMGFZMk1UU1VyMDRYWEZPVGROK2x6RGRqeWRLQ2FTS2lTSzN2dDlPWXN6U0RIb2MyUjh2SGFWTkpVN1o2dkc4WnVucUF4clRROXpuUTlIMWUzaW9MYi9iOUpCS1ozeW4yazRpSDJoTUprNm9uaHBIeWNrMld3aUxLb2svRGIwdmQwdXFHZmhMTXBDVHhGQzJuMzFIbWZTaTNYejB3cEh0cmh3bVBSeUFQUTlYeUxXbFlWNjF6MERJNE0xTlk2bWhHb2NFT09yQ0xnVHh4YVFTR2ZFVTllRVZGaURPaGNycWVhL0t1QjR3WVNtbzZydTVGUVZuUTQ2MWJsdTJyZDVyTVVTUEZxbnBLQmxJZ2MwZVNGQU1lczZpcTNsQTJXVlNvenRkUitrSUZpZm1TZE9zeStHWUpwY0xwRkd1U2pvd3VsYm9iaWN1QmI1bjhuUlQ0ZmlYd3d6ZzBXQ1lFZmlKZE82L2dxb3JrTFZieGEwaTluUjAzcVFNeXZTeVd2WWE5R0lReTlBZThWSVdWOFBOR2tLeGFKWFdCdzFHbHRGSWRKODF5MWhqbFZOK0VwMEl5NDlXVmlXT3hlakh0MnNxRTE0TE85alZVdTdnY0dpWVhqa3VjajFoK2Z4bUhyamc5YVpaeGlXT3NXRHF4WlY4NU16RkpKVmhtS3Rka2hhV0VyN1NJQkxWUWRPVkpIT05HS0RqVXhxMXRsZC9NU0MwRmNzWTFyUExObFI3ZkxTcFVEMFU4RkhycGxWTmNDRm1QbDJSTUZYRXRqTElwSVlhMVVHV2tjdkFaQmtMRFFzU3FZMDZleG5rOEhabi9YNVlaWXAvZEZjOENwK0hsMUZaaG1yRGNEeHVSa0VKUks3WjZTdVRjbHpUbVd6amdEY2Z4V3lsY2R5NUQyVW5JK0ZIYzBDajFFSXJVV1puMU9JU29GNDVzcFZ4MVNRV1ZQQ3RwVXVCYjBKU1hRQW9icVg1bnhreEtSS3NoanpjQ2ZiYlduYzBSZVpqWUhITjUrc0p0eXFYSjNTZHl5Wms4bG5YMUx3MUhiY3h5aXB0VC8rWm9LTWJ1UWMxaFJrb1NHQzVYaVZsL0IzT1J5K3NobENsUjl2MlpZZnhvc1BqUm9CajEyZmVWbzc0dkQxaXFrZWNQV1l2MnhDd3JDdGxkWUJzcUpqVnpQT0crRkdNL21BcTNtYnlCdzdLaTZnQkxJUzlSLzc3UjBXM0t3dTVQOFNRb3lIdVRuYWM4ODlXalUyUm1DYlk1ZXJuWUR1ZTJLYXVudVkwOGVTMXBQQ2VsVVQ0NXFDcUQxRThGaVpxOEk0SkpHcU5ZcXBuclRHSldZcHh5ODlLUTBtMGt6eklrNWt4WTcvU3F4RU9ETnpSYlE3azFCbzRZY3FPaHc5TnNzeXZ2MnRVb2FXdTNVbUkwTkVhVktHRVh3QmtsUllsWGozaG5oUHA1SlJwNXB0cXdFcFNqa1JReG9zR0p1RXc4MlBzNlVWR1JtcnFxcVYrYXdWd3NtelkxVXhvbTNhNndTcHFWOVMzaXNxYlVvM0VxQVNhVTJNMFcrQ2U3akZpMXhzYUNVOWN2b1EvTXVReHZSTU5sNDBMTVBscjZyNXJDN0lSaXV4TGJ2RmpEcmloTHdKNEhZM3MrNXR5bm4zYW5NdjY1dkVYTzI1UkJUdE95dkNFOUZWODdiNXMrTDYvbkhqRk8rdTFJbjNPbW1CZWlRdnlodlZxc2prU1V4OU93b2RLN1RHQm9rZ2tNelRLQm9WbnFQaFFweERKU3hINVgrbUVPTTlVTWN0K2NKZ21wcklyU1gzdXpmUFVpblhPcHM4Y2NsMlVqZFlKUlZLZ2lsNVZhRXhKVXNnT0RXaXdsMFVpL3VvSmNuRk1OaXVOUkpSN29nMnVNQnhYKzFGQzRybEZOVklibmVLTENTSWNGQ2VZU2p4UHZNSktaaUdseUFsaExEVTQ4S2lXZTFNMXN5U1J3U2NPU1BrYXJKWkdWanBXQ2FiUmpZYUUvU3dIOXZLeHczNnFxdXpwdVZpZ1M3T3JqbXNKNkZDVXN5a3ZVWVBYa1JheEJaRGJiekVqUFkzay9acHkwOFdTa1RQOUxLaU1Oemo2U1RLN1dOSkZpdEtoZ1llQVlibEZlMkNBVCtWbldLeTVIb3l5bnJtdjlvaFpQaHZ2Y2RpM0Zjb1pUbUFSTmRoakNWaEpRcGdaalZsUytvVFRVbTJOb0MrR2E4dGl0UEpScElxdWVvZE54YWtQT3A3VHliNlJRblhqT3BxVFBPNi92ckpwd3pza2xuMGs1cXhLV29hS2thV1hvNi8rSWw0WWg2emE3dU5BSzJlZU1oTFl1V2ZKLy9RTUc4UT09XCIpIGZvcm1hdChcIndvZmZcIik7IH1cblxuLmZhbCB7XG4gIGZvbnQtZmFtaWx5OiAnRm9udCBBd2Vzb21lIDUgUHJvJztcbiAgZm9udC13ZWlnaHQ6IDMwMDsgfVxuXG5AZm9udC1mYWNlIHtcbiAgZm9udC1mYW1pbHk6ICdGb250IEF3ZXNvbWUgNSBQcm8nO1xuICBmb250LXN0eWxlOiBub3JtYWw7XG4gIGZvbnQtd2VpZ2h0OiA0MDA7XG4gIHNyYzogdXJsKFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFUMlFBQXNBQUFBQ3FtQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCSFUxVkNBQUFCQ0FBQUFEc0FBQUJVSUlzbGVrOVRMeklBQUFGRUFBQUFRd0FBQUZZL3VGRCtZMjFoY0FBQUFZZ0FBQlNYQUFBdENDanU3MlJuYkhsbUFBQVdJQUFCQ0tBQUFqeVk3VHBWbm1obFlXUUFBUjdBQUFBQU1nQUFBRFlQRG9ZMmFHaGxZUUFCSHZRQUFBQWhBQUFBSkFRK0JRVm9iWFI0QUFFZkdBQUFBcGtBQUFzMFdNMytwbXh2WTJFQUFTRzBBQUFIZHdBQUN6Z0RFVDhjYldGNGNBQUJLU3dBQUFBZkFBQUFJQVByQVVSdVlXMWxBQUVwVEFBQUFWOEFBQU1HWUxGcERuQnZjM1FBQVNxc0FBQVM1QUFBSldoODF6MjZlSnhqWUdSZ1lPQmlNR0N3WTJCeWNmTUpZZURMU1N6Slk1QmlZR0dBQUpBOE1wc3hKek05a1lFRHhnUEtzWUJwRGlCbWc0Z0NBQ1k3QlVnQWVKeGpZR1I4d1RpQmdaV0JnWEVhWXhvREE0TTdsUDdLSU1uUXdzREF4TURLeklBVkJLUzVwakE0ZkdENE1wM3h3UDhEREhxTVp4amNnTUtNSURrQURGSU5QQUI0bk8zYWFieFBaZGNIOE45dm5ZT2lwSkVrSVUyS1pLYVNlU2hFaGtTa0lzMmxRbWttTkNtU1VpSE5zNlI1RWhxa292RnB6cTNTY0d1NDk3WDN2cnNiOWF4MWZsNC9iNS9ueFdOL3ZxMDY1L3ovLzcydmExM3JXdGNSZ0dvQUt0d0JyaEtvZFN6by80YWF3L3lyclBwNkJXcFdmYjJ5WmpPQWpmeUxOZEFvczZ4YVZqdmJNZHM1MnpWcmtEWE1PbWM5c2dIWnlHeDBkbVoyU1haWk5pTzdLcnNtdXk2Yms4M0w1bWVMc2p1eUpkbXliRjMyYnJZKzI1QnR6SDdPeW14enFwVnFwKzFUZzlRd05Va3RVdHZVS1hWT3ZkS0FkRXdhbmNhbDg5TzBkR1dhbSthbG05TXRhV0Zha3BhbXg5UHphVTFhbHo1T242YjE2ZHYwWS9vbGJjNloxOGhyNVEzejVubTd2R1BlTngrUWo4cFB6eWZuVS9KcjhsbjVEZm04L05aOFVYNTNmbi8rVlA1cy9ueitZcjRxWDVlL24zK2UvNXh2THVvWERZc1dSZWRpUURHeUdGV01MeVlYbHhSVGk1bkYxY1hzWWtHeHVMaW5lTHg0cVZoVnZGcXNLZDR1M2kzV0Z4dUtiNHFmaXJ3b2k3OUtsdFhMT21XVHNtblpyeHhVRGl1SGx6Zi8vVGVRSWF2TWFtUjFmSVRxVm8xUTQ2eEwxanNiNkNNMEpqdmJSMmhhMVFqTnltWm5jMzJFRm1TTHM3dXlwZG1LN0ozc1F4K2hyN0x2c2l6N05TRnRtK3FrZWo1Q2pWTFQxREsxVDRlbUxxbFBHcGhHcGpGcFlwcWFwcWM1VzBab1FYcklSMmhaZWlhdFNHdXJSdWp6dENGdDhoSDZOVWRlbWRmTTYrYU44OVo1aDd4TDNqOGY1Q00wSWIrZ2FvUm1WNDNRd254eGZsLys1SllSV3Btdnp0L0pQOHUvekxNQ1JZT2lVZEd5NkZJTTlCRWFVMHp5RWJxOG1GRmM1U04wMjVZUldsNnNyQnFodFQ1Q1gyd1pvY3hINlBmaWJ4K2gybFVqMUtvY1VBNzJFUm9SSS9UL2YvNkhQL1NWMXBSN3N3MDcrZFc1NmpxZmwvRTYzdTNYQ243dTExZFYxMForeTAxKy9jek1xbHROMjl2MnRRNStIV0tIMjFFMjJzNnpTWGErWGViWEZUYmY3clQ3N1VGN3lsYlpCL2FwYmJSTjlxUGw5c3VXNjFmYmJKc3JVRkc5b2w1Ri9hcXJZVVd6aWhaK2RhbzRwS0piUlkrS295cE9yVGk3NHB5S0t5cG1WQ3p5NjhHS2g2dXVwVlhYc29ybktsNm9XTDdsV2xHeHJ1S0RpZzhyc3NwdEtydFU5cWdjVTNsUjVmektKWDY5VUxuY3J4V1ZxeXBmOGV1MUxkZnJsVzlVWGV2OGVtZkw5WUZmbjFhdTkrdXJ1S3J0VXExQnRTYlZtdmdBOWVWcWE4aXhOdEFlWkdzNzF5YmFlYmpkcHR2dTFvQ0Z0Y01IUEJXdjJmYjRuVk9zaGgzSEczZ3JPL0pFZTg2ZXNlZjVHd2JaYVhZNlRzVnAvQVV6ZVNqR2M2cE5zSE84dWxYRFZxak9lVnpIQyswcFR1SVhmQUFWTmdOL29yc040cTdvdysvNWtmVm5WOWEzby9BWG5zVnpQdjdQMnVWWXlOOTVDYjVEUDdSR0d4eUtGdGFVMitNTG41c1gwWk5ic3crdlpEdldZMTNXNHJlNDJJaVBlUzlld2pOV3gxcndFQjZNYnVpS1d6R0RWK0MvOElrZGFXM3RFdTVzcld5dTNjR3IrRFcvdE1YWWFEdnhlSnlQK1J6T28za01oMkYvcjlQTjBZeUgyeHQyQnR2Z1BIU3hoemdiYTlrSlAyQUQzN2U2MWg5SDhVYk90ZUYyaTUzQWUreEd2b3pyTUEvWFl6WSt0TjdXM1hxeDBtNWpUenNWSjF0N204Ly80dlhjQ20vZ0xidlhCdHRJbklEM2VRWnFjaGtiWWd3SDhDZlV4bmFvZzIyeEEzYkVUdGdlLytKTUc4K1YzTXkvN1Fpc3NrUFlqWSt6QjZlemc1Mk45MnhiM29SdjhiWXQ0cCtleTl2WUtEdUcxZmdybitIVHRpK3VZRnZiQVk5aEdSN0hVbXhqdCtNQy9FM2FqdnpPTHVNTG5NVnJzSWlmY2lmYkU1OWlEbTdFWEZabmpzSjJzYmRzWjF2RGc3aUhIV1pkckt0MXN4N1cweTYyaTNnNzcrUmkzc0VHdk0rTzVTdllHWk53QTM2ekZaeGpmVmhoQzltZk03Z2JKbU1GUDhiMytLZFZ3MVYycHMzR2o5eWZMYmtYbTNNZlg0Mk5lU0QzNUhWWXlmYzRuaWZ3QSt0b1Rhd3hUbUYzbTRleC9DZlgyQ3BjaE9QdE9ueUpYdHlGYjJNY2JzRUMzR1l6N1VxY2lBdnh1dTJGbTNFVGt1MW45L05WTzVyajdIRSt4aWZzV3J2R0h1TWp0b3hMK1NpWDhIWDJ0ajNzUG5zQXg5blZOZ0lqTUJvamNTeU80V3M4aDIveUxSdUMxVGlDWi9Nc25za0pQSlpET0lxRE9ab2pPTlN1c3Ezc1prekY1WmlHUzNneEgrUkRmQmdmOFVNYmFnZFljNDdoUDJ3QlRrSnZmb1Z6MEFPMThKTzE1bDA4anVhN3Z0azlQSmNUYmJKTjhjcHhnZGVQQTNFMC8yV3YybXUyMnE3Z2s5YlpsdHV6OXJBOVlrdnNVVnZxVmVVdXU5VnVzRGsyeTZiYU5LODZ3MnlBOWJVMmRwRHRZN3Q1WFRLcnNFcit3WXcvOEVkTzl1cjFHVC9oV2o3SDUza2JGM0FoRi9GbVR1T2xYdVV1NEVrOGtnTTVpRTNZZ3MxNGdOZkJwdHlPdFZtSE5mRUVuc1JUZUJxZll4MWV4Zk40QVM5aU9hN0dOYmdXc3pBZGwrSXlISTYrNkl6RDBCYnQwQjRkMEJHZGNEQU93WUZvaVlQUUNydWhBWFpIUSt5RnZiRVA5dlhPcHpHYVlFODBSWDNzZ1ViWUQ3dWdMdXBoVis3QUhXMDcxckJ0ckpiWDFxMnRFWVpqRkNaaURkN0VPM2dYWCtGci9Jek5CRnV4RnkvaTFieVd0M0ErNytkVFhPNTEraVd1NGdaK3cyUzF2VEozc0lPdGs5ZmxFMjJjamJWVDdGSzczbTZ5dSsxMWU5bGV3V2ZjRmtNd0dFTXhES2ZqREV6QW83Z0RpM0VuN3NaZHVCZjM0SDdjaHdmeEFCN0dRMWlDUi9BTk51RVA3dTU3dzJFOGd2MTRNay94M1dFOS96SllTK3RueDl0WjlyU3R4TmJvandFNEVnTnhGczdFMlRnWFUzQWxYc1lyK0FmV2U2dVM0MWVVK0EvK2pWKzRIL2RsZTNiaFVSekowM2c2eitQbGZJUHY4aDNmYWY3Tmt2K3grbGJQZHJWbXRyOGRhbVBzSkR2WkxyUW43RWw3MFY2d2wreE5yODNWLzdlM3ovOERmN2FKZnpSK1dQOWhhNk1qRlBiMVNPRnFqeWJXMEdPbGNLekhhbUlEUGRZUWU5RGpWc0xXSHJjV085ZGpUYkdKSG11Sjc0bkl0aEhjN25GYnNla2VhNHZ0N3JHT1dBT1Ayd3NManp1STc2ZklkaFI4NEhGbjhUMFdXVjNCYXg3cmljVjc3Q3I0M1dNRDRSU1BEY1hpbVJxTEhlZXhpZkFHajNzS2IvWFlWTmpSNDE3Q0V6M3VMZmFjeDMzRW52RzRyOWp6SHZjVDMrK1JOUk1NOHJpLzJHa2VEeER2QnBBMUY4Unp0UkRFenh3bzNpc2dheW1ZNmZFZzhmNEJXU3ZCZUkrdGhWTTl0aEdiNExHdGVKK0JySjBneHFHOXhIa3M2eUNJZWU0bzhCV1ZkUkxPODNpd2NKM0hRNFFYZWp4VTdDbVBuWVdUUEhZUmZ1R3hxM2hYZzZ5YnhCa3c2eTdlNlNEcklkN3pJT3N0aU8vM0VZc3g3Q3VNZVQ1Y0VOOC9Rdmk5eDM3Q2p6ejJGNHM0UUJqM01sQlkzK01nOGI0SzJSYmVZU0ViTE41cklSc2lpSGtmS3R6a2NaZ3dmdVpvOFo0TTJYREJRby9IQ0NNblI0aDNiTWhHaXZkdXlFWUw0dDdIQ0dJK2p4ZkVmSjRnaVBFK1VSRDVNbFlzY25hY01OYkNTWUlZLy9IQ256MmVMTjRmSWp0RjBOUGpxY0pZMzZjSlkyeFBGMTdwOFF4aDVOR1p3bGgvWnd0alhVNFFSajA0Ujd6elJIYXU0R0tQNTRsRlRab28rTmpqSlBFT0ZkbGs4VjRWMmZtQ1dHc1hpRVg5bUNJVzQzQ2hNSEx6SW1IazdNV0N5THRMQkpFRGx3bGl2VThUUkI1ZUlZdzRYYnd6UmpaRDhJbkhxOFNPOUhpTldLeXpXV0x4T2RjSm8yN05Gb3YxT2tkc3JzY3Q3QTZQTndyanZlY0p2L1k0WC9pbHh3WGlIVG15aFlLTkhoZUo3ZVJ4c1RCeTV3NUJqTjlkZ25pL3U0V1JwL2NJSTMvdkZVYk8zaWVNSEw5ZkVEWHNBWW5mMzJRUENxS0dQU1NJbXZld01OYm9JMkp2ZUZ3aUZubTBWQmk1L1pnZzhtS1pJT3JIQ3JGNDc1WENHTXRWZ3RqalhoWkdyWHBGL0FTQzdGWEJCbyt2Q2QvM3VGb3NjdlYxcWFvUGF3UlJBOTRReHB5OEtZeTVla3NzeG0ydDJDMGUxNG5GR24xSEdPUDZybGk4ejRmQ3VOK1BCSkVqSHd0aXpqOFJQeUVoKzFRUXovdVpJTjdqYzdHb2tWK0lSWjFjTDliTDR3Wmg3TzFmaWQzbThXdGhyUGVOWXJIdXZ4TkViZmhlTFBhSGY0cEZ6bXdTeGxyNFFSajMrYU13OW82ZkJERitQd3RpekRLeHlLOGtGdlUxRjR0YVdBaGlERXRCek5ldndzaVozeVIrUDVqOUxveDgrVU1ZKy95ZmdxaWpmd21qOW04V1AwUENQNzZLbnlhUktINnU5RU9TK0FrVHFVTDhySWxVS1g3cVJLb21mdjVFcWk1K0VrV3FJWDRtUmRwSzhDK1BXd3Q5NzA0MXhid1dwMXBDeittMHJkRHZMOVVXL3UyeGp2akpGbWw3Z2VkOXFpZm10Uzd0S3ZUNmx1b0xIL2U0bTlEMzFOUkE2TFVzTlJUNmZwOGFpWitVa1JvTDN2UFlSQ3p1cTZuNE9ScHBML0VUTmRMZWdyYzk3aVBtTlNqdEsvUTVTUHNKdmM2bVprTHZDOVArWXFNOEhpRG1OU2MxRjhZWXR4RDYzS2VXUXEvLzZTRGgweDViaWNWbnRoWjQzVTV0aEY2VDB4WVdjOWRlL01TUDFFSDg3SS9VVVJEajFrbmd0U2tkS3RGWnA4NWkzdE9tTGdMZmgxSlhRY3hYTjJIa1ZIZXh5Sk1lUWw5anFhZFlqRWt2NFFzZSt3aDkvMGg5aGI2dnBNTUZNYlpIQ0wwdXBIN0N5TDMrWXQ2L3BnR0MrSm1CQXQ5djBpQ0IxNkowbE1Ccldob3NjWUpLUTRTK0p0TlFnYS9KTkV4c0Y0OUhpL202VHNQRmZJOUx4NGg1RFUwamhURlh4d3IzOERoSzdEQ1BvOFZpTE1lSXhWZ2VMeFpqZVlKWWpOK0pZakYrWThWOFgwL2p4SHkvVHhPRk1VZVRoSGQ2bkN6MGZUR2RML1I5TVUwVnh2cVlKdlE5TDAwWGkzdWZJZlI5SmMwVXhQTmVLWWpQbVNQd2MwVGFBbDZuMGx3eDM4UFNQR0g4N00xaU1lZTNDS1BlTEJEemZUMXR3WmpiaDRSeEx3OExZMzAvSW9qbld5S0l6MW9xOUgwbExSTjRUVStQQzd5bXAyZkVZcTA5Sy9EZUl6MG41cjFkZWw3TTk2QzBRdUMxUHEwVXhqcGVKWXcxK3JJdzZzUXJ3bGpUcndxalRyd21qTnF6V2hpMTUzV2huM25TR21IazgxcWg3NVZwblNBKy8yTmgxS3RQaFZGWFB4ZEc3bndoOVBOaldpOFdhMzJEV05TNUw4WGlIcjRTZUUrY3ZoYkdPdDRvRm5QNGpTQnk4RnRoak9jbVlkejdEMkl4Tmo4S0lqOS9FVVNPL3lvV3ovV2JJTzdsZDBIVWhqK0VzZTcrRkVhOS9Vc1F1YjlaNERua3k3WUtQSWR5Q256Znp5dkZQSGZ6YW1LZXUzbDFnYStydkliQWUraThwc0RuSTY4bDVuT2ExeFY0N3ViMUJMNHY1THRLYktwNWZUR3YrL2x1WXQ0NzVnMkVuZ2Y1N21KZVIvS0dRbitXdkxHWTUyamVST2kxT3Q5VCtJVEhwbUxYZXR4THpPdGt2cmRZL1B3K1FsOGIrYjVpdmdieS9ZUytOdkptd2tjOTdpLzA5Wk1mSUl4bmJ5NzBYaXR2TGVaMUxHOGo1clVpYnl2bVBYSGVUbkNjeHc1aVYzdnNLT1pudjd5TElQNjlxOERyWU41TjRIVXo3eTd3K3BQM0VIaHR6WHNLZmYza3ZZUit2c3A3QzcxUHpmc0l2VDduZmNXOHB1ZjlCYjdlOGdFQzMwdnlRVUx2QWZLamhHZDVIQ3owT3BBUEVmcTVMaDhxakhzYkpvenZIeTMwK3A0UEY4WjdIQ09NWnh3aGpEaFNHTzkzckpqWG4zeVVtUGRQK2VsaWtXOFRCRjZ2ODNNRWZ0Yk96eFY0N2M3UEUvajVLNThvOUQwaW55VDBzMG8rV2VqMU5MOUE2UFUwbnlMd3ZqeS9SdWo5ZGo1TExPNXp0bGpreUJ5eHlKRWJoTDZINWZPRS8vQjRxMWlzeDRVQ1A1UG5pd1F4YjR1RlhuZnlPd1R4ZkhjS1l2N3ZFc1JhdkZ2Z2ZXeCtuMWprNXYzQytOa25oWkdIVHdtOXI4MmZsZmg3OXZ4NVFYejlSVEUvcytRcmhUR3VxNFF4bHF2Rll2eGVGNHN4V3lQbWUycitobGlNNjV0aU1mWnZpWGx0ejljS0lsL1dDYjFQenQ4UmkvcndybGprK1h0aThmbnZpM21QbDM4bWpHZjlYTXo3cy94THNlVWV2eEtMNS81YUxPWjZvMWpVaDIvRVl1MS9LeFkxNFR1eHFCWGZpOFdjL0ZNc3hubVRXTXp6RDJLUkN6K0tSWTc4SkJaNTlMTlk1SEFtRm5tYnhHS041R0t4dGdxeFdLK2xXS3pwZjR0RkhmcEZ6SHV0L0Q5aVVmOStGWXNhL0p0WTFQdmZ4V0xlL3hEejNpUC9VeXoyaXIrRThmM053cXlxRmF4Q2Y4NkNRbi9Pd29TZUcwV0YwT2VqcUJUNlBCWFZoSDYrTGFvTFBRK0tHa0x2T1lxdGhKNlh4ZFpDMzcrS21rSmZSMFV0b2ErbFlodWhyNlZpVzZIWGlxSzIwTWUyMkU1NHFjYzZRcy9WWW51aDUycXhnOURYWnJHajhFaVBPd205aHk1MkZucXRMSFlSK3Y1VTFCWDZXYVdvSi9SOXBkaFY2TFdpcUMvMC9hbG9JUFE5ck5oZEdQZllVQmozM2tnWTk5dFlHR1BRUk9EN1lMR253UE8vYUNyd2RWN3NKZkR6VWJHM0lPWmlINEd2dDJKZmdhKzFZajlCakhremdaOUhpdjBGWGhlS0F3Uytwb3JtQXQvWGloWUNyNVZGUzRIdnk4VkJBcy81b3BYQSsrbWl0U0Rtb28zQXowRkZXNEdmYzRwMkFzL3pvcjNBMTNYUlFlQm5oNktqSUY3WFNSQ3ZPMWdRcnp0RUVLODdWQkN2Nnl5STEzVVJ4T3U2Q3VKMTNRUmVyNHJ1Z25pK0hvSjR2cDZDZUw1ZUFsOXJSVzlCekhNZlFjeHpYMEhNOCtHQ21Lc2pCREZYL1FReFYvMEZNVmNESlA1L3FXS2dJUEppa0NEeTRpaEI1TVZnUWVURkVFSGs0RkNCOXpERk1FSGsydEdDeUlYaGdzanhZd1NSNHlNRWtlTWpCWkhqbzRTeGhzWUlZdzBkTHhhNWZZSXcxdnFKWXJGMng0ckZtaDRuRm5sK2tsalVnUEZpY1orVEJIR1Brd1h4K1pjSWZKOHFMaGY0bmxSTUZmZytWTXdRK0I1VHpCVDRIbE5jSmZCOW9yaGE0UHRFTVZ2ZzlicTRUZUIxc0ZnZzBWb1hpNFdSQS9jSUl4Y2VGM3JQWHl3WHhudS9KSXcxc2xMb2ZYdXhTampmNDZ0QzM4dUxOY0pZMTJ1RjhYN3JoQ3M4dmkyTTkzNVhHTy8zaGREUE9jVjZvZTl6eFFhaDd6ZkZOMkpSYzM0U2l6ek14R0x0SkxGWUk3bFlySjFTTEhMNWQ3R1kyei9FWWo3L0ZJdDUva3ZNejFiRjMySmVCK0xYZk1HdTkwZ3hQMU9VMWNXODF5bHJpM25QVVc0bjV1Zk1zbzZZbnpQTEpnTGZhOHFtUXQ4UHlsWUNYd05sYTRHdmpiS053TmREMlZiZzY2RnNKL0MrczJ3dk9NTmpCNEgzb0dWSGdmY0paU2VCOTIzbHdRTFBpZklRZ2ZjTTVhR0NlSmJPQXU4ZnlzTUU5M3JzSXZBY0tyc0tQQWZLYmdMdjg4cnVBdTlqeXg0Q1AzZVVQUVhlMjVTOUJON2ZscjBGM3R1VWZRVGU4NVI5QlQ3MzVlRUM3MlBLSXdRK2YyVS9vZGV1Y29Bdzd2MUlZZHo3UUdHOGJwQXdYamRZZUxMSElVS2Y5M0tvTU1aaG1ORHpzaHd1OVB3b1IwajhHclljS2VhMXR6eFdMTjUvbEpqWGwzSzBtSjlaeXVQRWZPOHJ4NGo1R2l1UEYzZzlLVThRZUcwdFR4VEU4NDBWeFBPTkU4VHpuU1NJOXg4djhETlJlYkxBejAzbEtRTHZtY3RUQmQ0Ymw2Y0ovS3hkbmk2SXZEMURFSGw3cHNEUEMrVlpnaGlUc3lYK0FyK2NJSEc0TDg4UmVHOVhuaXV4Z01yekJONy9sUk1GM2lPV2t3VGVJNWFUaFY3bnkvT0Z2citVRndnajM2Y0lJeDh2RlBxK1VsNGtqRG01V0JqUGQ0a3dudTlTWWR6TFpVS3Z4ZVVXOUxOQk9WWG9kYXFjSnZTYVhGNGg5TDY4bkM2TSs1OGhqR2VjS1l4bnZGTE05N1h5S2pIZm04cXJ4WHh2S3E4Ujg1Nm12RmJNZTVweWxsaXN5K3ZFSWwrdUY0czVueTBXOHp4SExNYmpCakh2d2NxNVl0NkRsVGVLZWI5VXpoUHpQcXE4U2N6cmMzbXoySnYvRFpieVlFQUFlSnkwdlFtVUpFZDFLSnFSZTJaVlpXMVpsYlh2VlZtOVYzZHRQZE9qbnRMTVNKb1piUzB4a2tab0pMV2tFUWdrb0NWa0FaS0Fsa0FnWThBTkNOQmgrNDB4TmpieVp4NUdXUEJaV3Y0WVpCN2ZiMnd3bGhkTXcvT3p4VFB2LzJINXorSWIxYng3STdMV3Jwb2VnWDh2a1pHWmtSRTNia1RjdVBmR2pSdWN5SEZudDhqVFpJdWI0UzdnTHVadTREaXkwTGlBMUVwVHBGNHI1Yk01T2VRM3c5VXNQcXgyMy9SaVFqWlhxdnRyRFVnUmhwU3lVR3NzaEUwNVY3SkNwanhGY2lWSTE5aFB3bGE0YWFVSStaeWtLSktaTU50YlppSmhraFpFNlJNV050cmY0a1dSSnpVSWZ6eDNZQTcrVGh2NmFkMHdmUVVybFlrWGZDYkpLRkpaVWlyNGVYc1Z3d3A5MEdKaCt6UjgvaGhtMHI2TEZ3bVh4VHptVGdaMXc5Q0R2cGlvK1FrSmFtS01neDhaQTU0ajY1eVhTM056M0g3dU1IY2oxTCt2emxDejBuQU43VHlyMUJKWkNDZUpLU3REOXphcmY2MWgyYkpkc2hXRHdOUHdrb05XY3BwQlRUWWhqQ0dRRHNDTGR5QUtCb01mUmZQNWhYeitwcmdaQ1FmaWJxOUwrWWppOHBKMXFQbzJ6U1JqSnRxbklBT1QxdmpIdkhoS2tYejROUVNIZTlGSE1aZUYvQnNWTHlFZVJURGRodUp5S1liYjVBUm8vMitRWDVDbk9EY1g1YkxZK2lsaUdpUTNTMnJMcEpremlKa2lDOHVrTmtzVWRsTWxYT05FbzNIaUxnd2FCKzg1ZVBDZXQyRndjT0xpQ2Znamp6cXZJS2c0cnlCWW5iajQ2b3NuT0U2QzhyNUlma0tlNXVhNUplNGk3bXJ1WlJ4WFhJYStOa3Z5T1ZrcEtYZzFTTWdNV3pJR2lteUdGL2FURkdrMHJmQkNvelpITURIZ09HUXFKWHVaU05Bd0M1QldLUVVaekF6K09kTFhKdER4dk1RZzVGditZS3FXeWphTldNeG9aaUVhOUpzeGExSXhUR1Z5NHVUSjhwUmlHc3BVSkxZYUt4a1R5MnF5ZmJvVTh5WFY1UWxqcTNMVjNOeFZxeGp3RjBtS2xKR1VCWkVYQW9MK2dtOHFBamtWa29LUUxFQWtNdVdibnJjUEoxbGVXY3ZLVHRIOFU0ZnQrYStXWXVGQVBXeDRXN0dTMXdqWEErM1BPNWxDc0RvbnltL0I5cm9ySitoaVRPUTVISnYvbFd5UmozVDdKMGY2QmhYV1RjcXlYb1hqRkh0WmNPaSttR2ZYYnU5YlZhVG5zQkFJMmsrUVQyRzBmUnpEdmppNXZKTkVJUnNaakdMd245Z0ZnN05jTC81VUw0ckRhUVRNL2pvYk96ZzJBSzZTdFF2TXphSDdmdGpjWTBBZUFIK3RDL1BiUjhPOHZpdk1pR2VFRmZHTXNPK0taK2RhZFo0amxXby9Ud0ZUQWRNL0hnZXFwNWZvUHdUWHdTRmNLeThTMTVzT0xCVDR4OFpBL2NsZWtoZU5iTzNzdjhOOHN3M2pYK1g4WEl3N3lEM00vUmIzR1BkUjd2ZUFEdVJ3c0RkcUpic1RzVHFSWUM2UDAxRU95QU5TQ2RxdFMza1ppR3NhYUFOMjcvMkUxa1F4Y2FqREdBRUtzQXd2dy9pMEVlNGJCT2U2Q1NtZEFwdWRpTElES01JcG1tWm8yaVhzc29kZDNpTklreWxkMDdLbHJLYnBxVW1QSit5UDZ2NTdYSG56eWNTTUZGSW1aVG5FQjF4UCt2VjdWSGRjSzRxdVNFUVNmSUkwZkRuRE12d0N1OWdEbHcwTURNM0hMbXZzUWpKcWFwTDNCb05lZmpKMVFpUnUvMUxrMC81Z0lYRkh2bmc4TmJtWlNiL2NiUmhQdUNPaXV5bUo4dGU4YnJkM1E1QWs0UlRHVG1Gc28vdXNoYkduV01ZckE4VzAySVZUa0dmZ0g0STJ6SE9YY3NlNGwzT3Y0dTdqM2dTakJ0c0lVQTl0MDZVN29RNTJIWlpCZ2pUUU5BUGN4UkpCeE5hckxIVFM0UXlLTTJrelQ1czgzemNKVzlXRk5NbGIzUlE0WlNqMUtpa3ZTa0pGa0JheEdyMG91Y2dYT2haS0ZiSlcrN1NWelZycTRzcmlPdnhYQUtQdENaaEd5NG5FbDk3b21hNU5lMEw0SllIdktnVmRPZkttRm51NXp6TVpMU1EyU0dZb1l5ZDYrdDRVNUYvR3JMR0E4dUppR2Y4MXhhZG9xL2g5T2JFYWpzWENMR2RKT0s0Y09jTWUzMjVhMFNNY0o1ejk1ZG12OG04RmZOYTR0M0hmaFhGUXNtZGh4ckp6TU1NMW9IS0FBT2pvWHA1MTl2M0VXbWpDakFkVE1Vek56V1d5bjE4bVJaaWY1VERPaEdFNVo4L1R5UlRJMFVLak9RODRncS96ZHM1TDVCS2dIa2NLL05WaGVtK2tpS3pBYjdqWjZJOURKcVlzS1RKOEVESWczMW1DNzB2NHR0UndvaVViT1p3VXZJSEJDRGVOQldzK2hZMk1vMVJXNW9FREF0Q3FGc3pkalRBTVE1bC93RFMxWXFCMmVUS2llV1ZYTWlpa0o3MjVLVGs1NDlmVk1yNjVNbzV2M01sQTM1djI3M2x6WGtXUW93Vk5kQVZFS2VqMlcxR3ZPeWlKQVplbzVVUEhCSDVKbEVtWjU0VWFUNHBFTENRbGo4WkxBYmVveWNtYzdPSlZ4Y0xLQkd5L0JteE5KNUhxRTFVbmphN0xlaStKZHE3eUNxR1hkTXY3SCtVSnYwZUxLUjYzNHMrRnphUW5jZWxVSTZvWC9GZDFIZ2R5b1ZDaTg5aFdlWm4zaEV3b3dlVzI4bUczQzJMQnNFcFN2TUN2Q0RLZkl2eEJ3aGN2akVpODdoRjlBVWtYVFpHb2hrNEV0K0RoUlVrREVHYTdxUlRWTC9zQ3NvYUp2UDcrTk9JdUpYSDgyVGFNM3dQQTgrUG81WXAyQ2JzR2pFSnMvejdXSGhtdFVvNXlZYUhlZUlhMnRpRU5kQ1RucTdDRjdRNjlDWjZTRHUvTDd6c2s2TUloU1ZhbmpjcDBjeC9PQVB1aWFXREcwMUYyMDV5dUdOT3FMSFhTbGZWQzd2Ykc0dTJIOUxJcXQ3L3ZDUVpqd2VDOWh3UjQ2WjFMSmFWL1U2UUlNQURLWkJ4NCtteDhFcUw0NE4ra1pHck9LN0YwbFZMZW5qZ3k2eVZaL0RnV0JQYis3Rm1nU3hlU05TN0VUWEpjRTNvdGRFZ2dIMDBNd2pCWndIQ0JKelZXSDRZS0U5NHNQUDZZS0ppaUxyeis5Y0NPbVlMd21LaUxnY2VFM3JPZ0tMeGYwTTMzaVJxK2Z0M3I4SlVtdms4UU5uYzhRakVEZnNnYXVZVXpFUTRHQXhadk1SaWcrQnFXeWtCcGR1Q1JUV3RuQVovWVdlU2Y3d1RNTXdMK2ZqZ29Qb29LSzNvLzZTSW1iQ3Fkc3RNdzlzME9WT1N1ODZucFUrZUh0YjUyb2ZnSWR0SFFCYWl4MEdrSklIZ2R4SlJ5eWgrY1gxVkhnRHNDYnh4eDRNZ0FQc2IwamxFZDRlU0lyRGlDdU9XMmFCdVBibUZ4eDJjakdxNHZINFJwWkF0OWFXZjVvekRQOWRYUEhJUGxFZmdraVJFOW1QR2IyeUF2YjNJV1ozTk43aEltS3lOZEFHSGY0WDJYQ1oyOUI5blFPaGxrcDBQRE1qT1RpZ01HaUxSd05RS0o5bVVEY3Z3NlhKK2dvdkl4WG55d0t4K1R6WVRaOGthbG42RXcvRE1wNm9VWnU0SEphdlRMYlF6L0NZT3JLYTJnQVVkbDNtZkk4NDdNT3dlMTZCZHpoWDR4VWtEQzU0d0F4ck1nZTBPNFByRzNKd3hmZTFDVjVkc0FpN2NCT1R0STlSSGtxWjRJM0c3MUpHT3k3MTZ2ZEpzSUtiMzNBbHdqWUdwMkFRTGdwSzVFRG1BcFZBYUV3R2xCUUNETSsycXZJTExWSytpd0l2V1h0RFVTOEJ4QU9najdUbmlLREJJR1ZiR0xJSUNxV2NkMmhNQVpNZEN3MExyaytkRTFad0NkRklUYjVGMEJBcmgxOFZhWkFzU053SkhVUlJDQUZleFhYQVJwLzRMQUdURU1ZV1BhN2VpTzZpK09SbWI3cVVIZ09UcS9uQVZwaG82SkZHQ3Bud05HZG8wUnJwSmlWK3ZWVUpWc0hFMllkNW1KbzJhY0dLZU1NdnpILyt6VS9YZmRmMllkZS9CNnd2YWVNb3hUWGp1eGZlclVLVnBubXY5RGtMOFh4dHdzbERBa21SWWRVc1ZxeUhRRFVPK2FCY1hWcXpZQjhhdjlPQlhnWU1DMDM3MEJoVzRZOFZBdFlSNDNFN1ZRdkhMeStNa05zVE00bEY5c0dNWUdsTCtDOEt3azdPRDYra1lIOTJkQjFueW9BMGZWWWNoeEJLTldyRU5iV1BGc2JFT2ZXRkJDK1ZBMTFDeWNzd1FHSFlPVTNETWF4aEV3WUwvSHNySFdDSXZna0VnMklwQ3VVS1RrbXZWcVBWOVh5RWZPQ2NUNW9XcFVtd3hyT0NTSHZESVVNQm9IQUpsMnZwNFA1YTN6cVMxNThOeE5ndjN1KzlEdlB1NzB1ejYycmRiallScDJFNUNmRHhIZnFQN2xjenBqS0Q3UUY1Rkg2TTg3R09vWDVyb1RzV3dwZ05ScS9kU29yTW5hbUx5eERiZWhEVGRoYml0eWRjaTk2bURIbVNNWnpwcCtaK0p3UkQ3QlA2aUwvdFlPQXZHTGhObmVwRHBSbUVBcS9kTUZhUTNTd0VvdlhhTDlYa3pocE83MDh3SDRpaU9wN1c3d29aNnR2OHpWc2RCOVp3ZngrZUNMZ204MDlTM3VBdC9xSUNFajQrRjdZZ2VtLy96RndUZVNFZ2QzZ2Uvbk83RHlqYkVRdG9icWN1NzI3WTVkN051elF6cUxuUlRiR2lLM1pNVVpwMGpCbmFIN3lRMFlzWlYrNGtGOFZNZS9Db1BDR2J4Ykd4c2IvOUFkMHYyMHpJRmpZQVNqOUU5SDhESnhSckF5Ukc1SjVkd2xWSWJCOUpJdW5EM3FNd0tPZ2RHT3lnWTYyZzNpalBibUVNbmRPRGNZTzlIVkIwY1BYeVBhcFZudDB4d3RFMGNrU1pHbUJTUzBucmVIU083NTFYZHR0MmJwenVjTzdSdUFvaWVVaFIwb0txT3AzTWJvMlh5UWYybWVpKzlzVWtHMDJ6UDd4RklxaW8zbVl5NHpZYlFBMzVtQXNRTU1QZkR2OThPRE53amptTkMvZ0JTWGZCd3IvL0ZMZ00vSHRDTDg2VHQ1cmVhNStEK3JUekR4OWlaZWh4OFl4d2QrbVpVRnhZb1g5OE13bWlHOGpOVkVHSzdoVGpqSDg4MTJueUMydjhla09OQ1A0Wjk3WUhaUWRiRjREakFoNlVnd2Q4STVubmRWK29UUHVSNVQ1L0FVNDlwK0RJTEdjTExqcW9XeUo4ejlYNEZ4bU94b2h2eXNGNGI4dzczd2kxalloMmxoSDJaNS9SVTgrRXZoNnhEN01MbUdEcnBQZjVoSmwzOHA0a3VxZjREeHRRN2pLOG5OQUxVNVoxMmxvVldWd21PUXZ5T3Uza1RMdlluS3JPUllqNVFvUkgyL2dFSXNQQmR2K1FVKy9zVXRWREwrQ2YyQ0JoMDl5Tk5rbmNGQnp0azNoQzRLR0RFZzVSRkZ3RTEvRWVSR0ZNRGZKKzRBdHYxRWp4NHBqaDdrYWFDL2pPcWRjeXpaUVFlQXVnTVFxaWJlVDhYOXdhb0tQKzhCTWc1cEFybXFEMnRzS1J6Yi9pSGE5alA5dWlHRXA4dklPaTFXSEZvNU9yLzZ2bjRFd0VPSW8zcVVzeitFT2VsajJBY3RxZ3ZyRnRhbkdjTisrTThqdXhyMFFUMDJxblBDUDlmSi8ybVdmNUNxdUxvZHJVL2hoZVg4SGViZi9qUkYwelVEK1pNUGpTMmd4d01scVZYRkxwamNsWmU4ZFF4VnVXRXNTL1RranVITmlPdWZqR1dOZHNCODdwNjRHLy8yMTJNQStKZXhJQytQSVdDa2Z2NHdCODg1aW5mRDg3K09vWWwvTzE2eU9EQ21aYWJPSCtZZWprZFJ3TjM0K0p2R1llMzJzVUQvNXpIVi9JT3hNSGRvOW5uUkJXdDRKWHdjWFREN3FNK3pqNG5pWXlQbzJEZjZ5WUpEczdlQVpwOFByVlNHaVBielk4b1F2bllldE5JYW9Obk8zUEdRTTRmdDF1c0dTUFl6WTJhbmI1ekgxR0VPRW16V0xsMTZmZTZlWkEvUjYzRlZOZnRxK3FuM0N4Umx3OVBjWUxOUWVycmQ0Um1hVkZmZnJYU2Y1aDVwdGp5R2FINXhMSjNsSEwwNlQ4Z0NGNmM4Q2NDZkJkYlltUU9nVmxsZzBpbEg4a3VRdHR2L3N5TjNFeDFqejV3RStmR1NTMENFUFFsRjlkOTBZTi9pZmtxMk1POW0zait3c3VYdlUvNysxNUZaNE0wU0swY2NLTHVUOTFkNTZMSGNFc0JkSFpUUlE0TXFqL3lnaHFFK0lEQVRFd1RjVlZGY2xiejNYZ1lGM3dJRjN3SlFYRGJtOFhlY08zaXpJOUdxT1B4dEY3OUh1Q2tBbWs2SFE5TXNhOExoeVZFaE53amlrZmJuajRoMGtlQkJFZjV3MlVBOFFvNE9QaVB6Z2t1NCtHSUlvSjNmQ0dDK0VVbldqa2NkbkpFSjhqVENVcVRzNTFBWFloQU1NNk0yOGRQOFdLZDZFTWJQZzR3cWRoNUJFZmpvOW43b29NZzNPaEFQMTZMYk53QXZUM08zRFZNOWFLRFF3TER2REwwUXZGR0dIK0k5TkhqZEhuNkk5NUJUMWFHZDVCVzBDVm4zbitUZk5VTkhtNEROeEViaHpMdjRTYmE2Yzc0SkM3L094eU1UY3B4Syt6VlAvcFNiNHc1eVYzTzNjSy9rWHNzOXlLMER0NFpydnpDRzZ2UFVUcURacURNWkI3V3dwVHFUdzBLbVFnME5RaWpuT2d2TThBWGFjdEJZY3hsb3AxMHkwR1lVRFF3R2I2VWRkams5a3gxYnNiNk1ocDV4bTNoVTB5ZHJtZWFCWnNZd2pabkxUMXcrWTZnaHI2eWxhNWZWRHRmZ21aV3pJSHlMcGtpeGltcTZCYVVjRW9Ncm1pSVdsdUNXVnhmU1VxRDlMNUNkYVJoSDJlVmhkcm01bFd1MUlHSW5ZbUZQMEtjYTNtd3prMmxtc2VqWnkyZG1McDlOV0I3VHEzbzg2WHI2K1VLdFZzQTNmc3Z5dy9VcU1hZzFpN0xnTmVYVWpDYmJVa0M3ZEZibWZhWnN0elRsUHN6Zk5GcnM4bnAyOFVONVhYcEMvZ1hvQ2VvbDdTWnFSVkJUMUtjbVFKT05jSm9vSFV1UnJ2YkNDcVBOUjRsOC96T2ZrWGplTFdqU1o2ak80ek9TSnJoNVhocjkrSWJiYjRkSEpyeTYvWnRJbTc5NU95UTE0ZDJZNTJ4T1FudlNMM0FYVTl1Q210MlJjYXUwWlJGaVJjNDdRamswS2ZZR1J1eG9KYnlrYS8rSkgwQ0M2a0t6SVdIblFYTVM3Q0l5ZVQ2WHVmdFJLZ0NYTDgySVJQQkNONjFmU0lYaFY1MklKbUtSckNHTENTakhGaFhDYTdsd1liazRQeDJlTmdTL0ozWjR3bTcvMzZHSXk1VUxoQ016eng2c3pUTVpPV29KTGpFQXVaV29oRHhwVHpSbUVsR3Y3LzJTSmttRzEyZGZQRDI3R0FtR05XV3luSWxINCtHUWxiQ0tlM2JZRVRlQTJoL2hydHJkanBoYVFUa3pEWnF2VlMwYXNhMzhmcjdQYkJNNmVMNk9xd2Z5V05QaHY5bkRhd1ZWMk1NcmNoSnFyTlpVUVV2S3lqRXRwb2xQN01FRzJqTmJyMWNNSXh5Tm5NdDR1UFVwVmYyVXJFdGlLcVhwTDArbGZQc1Y2Vk9TVXJ1KytwNWJvNVZvWnczNExOVDFJYzdEK2FDMk9XaGpLN3hNb0dKTWFka00yZExBQXd1ZUVQZVdGZzBFb3RxVysvUUgyOS91M3JqKzdJTy92Nm55QVE5cGVRSzgrbkU5OWU1ZnZqRXkrRVQ3NEMvZnlHUXFOcGVXdWJ1NXQySFBRdHNvM3JFSE5Iakx3R1ZvT2NVM1V3UTd6akp2THhNRmFVWll0a3U0NGcxa3VSTXBOUnY3S1ZXcGRTSU5LNXltVms0TG5VZ1k3Wi93Y3lSWDlnQk5kOGcxejBYRGtsRmFpQnF6alZranVsQXlwSEIweEtPN0NPOGlRdEV5RWdLdnFiNjZWMU41T1dKRWlnS3ZDM0xFRlRSZGxpeEFrbExVQ011OUpKWVI3VThTL2lNZ3lqRGpob0VhNzNzWEJKYXdGVDlYdWQxSE9WNkV2QW84OFpEekwyNW5rbnVlRU1RYmFMbkNCZThVRVE0MjNyZTY3Y0xCUUxYbFdiNEp3N3ZSTEMzekZoM2tqUlN2cE5CU1Btend0a0ZzRTlHNmdLakhTQU5iQlRGZTYwUktpSHBzbFZ3bkltT3JZTXVablFpYXJCR3V2LzZ5ZDBmOW5VZkhlVlh6MW4ycXhnc0p3NEpLdXFDMkxqUG9pc2dRRlVvUnc1SzdTZVN3RVMzMUp4RjBYaWhHUFpIV1NCVHZLQldHcGZNaG9Kc3ZSSWZ6THZJNzh0NVpQSEV4dW5KMm0yK1Jqd04zMytBdTQ2N2tYc2E5QXVqS2N0LytDMEJSbDFaQS8vZm5CNld2S1NKMExMS1VQWENQNUZkR0E5blFQTk9UQXJYSlZ1Wkh2S2pERzdJWUNLTjVndlNPUUNYd0RvemNHdzU4cEN1Q1NCK0pPQmF3YXJTZzVYSmFJYXFtYXZ0cXFiWFdPdS9iK1l3VWxZeEpweGVmajE3TWpOTCsxNTVsQmxsbEJxYmJtamwvU2NEdERsd3liMnJoUWpoYytNRDZqa2ZoOWZXT25ycXpmeUdFR3ZzQm5icUZObzJBcjdBd1M2QzdHS1RVcno0OVdrZ0cwdTNuU3FzMy94dkdTQVJpL2JyeU8vTTNyNVpJSkIxSXR2OFVvKzNuSUFwbE1tWFpPbGtGZWg4RkNqakYxVUNTNzdPRzZjcStIVmt3MU95MGd0M2RIdE9KTkR0bXJCWktiRWpwUTN5NVhVRzJnWnlHc08xR3p1R09GY1o3R0l3bFdHV1hDSHY0WFhoL2g5OGlxN1hDQm40SFFmdU01ZC93Vzl2SFdjTERMT0cxN0hLMWt3bTh0L3ljWTgrN0RtTzRZMGQra0hzSjVYbTczV3h3RjBIblBqLzBmdWVNNTgrU1hmSWdkMUNqV0F4dTY4WSs2c01ZQm1UcUJUcFo4UmtNWDlqbU0rM0YzZ2ZkWkMxSk9JUHhNUUdkOUxwelo3dENOdHVuUnFWRCsvU3pNTTg4NU9DaUJqUDU5VERtM3NTOWovc0VTUHI1MFhYbzNBdTl0Y1MraDlXQnJWUHNwVFNVMEI3S1djb1BHRkYzc3Q5aFZJM013V0NpNTdzNE9kakYwOVFxTlViV2xIVUkzbzVteVowYjhtOHNCUWJQOUpCZTcwL0RBaWVMNzNjekpTTngzajdWK3c3U2swcjNTM3oyYkRmdHYvYysyUjVJUWxpOGs4dDZYK080bkxaNW1vNjdQRkRGSm5jaGR5bDNEWGN6dE5Gcm9iOE9qYjlpQjhuVjVvaFljVVJNNkNBeXIzUmoxb2hudlJqLytoZW8yVHkvQm1IN2t4UTNyVldLeDh3cXUydHZTY0tLSUsyU1RYYmZZcGRObHNpNTIrbyt4S1RQaW53QnVUSUl0akgzeHg4ZkU3WS9kYzdYd0tOMWVGTUJ4cmtMTUJma0xDNE9mVHZQMlVDNTVyZ3FZSEVKOTQ3TSs2dS8xbTlBMHdKYVFZc0g0aHIreEFMeEFQNW9nVGcrQ0pEMTl2cXY4MDlwUGRYL1BlalFLYVMzM1lWNXVoTnZsM3Z5dVhOdUhHSnhjcWkzWVdWelpMVERCejlEenRCNXA4YnQ0dzRCZFJoWXpXMDBiVm1oaHZOaHE0a2IxU3pjcEdZMWdEMEY5cVZrQTJzS25CRElyQTI3Q1VLTnBhQ0VZOG5QOTZhblB3KzY0NW92RWRiMHRFK0x1NFBGbStjVzdONHpyMDZmVmViRlpDaVVkRDJUZExtU29ZR2wzbnV0aUNjWXpCMmZtU3NGZzU1b09CdDF1ZlBoS0Q2N2ZycnYyWnEydkt3WFMvbUlWaWpsYy9veTFrK2lZKzBSOGpYb0sxbVFONWZwL0VhM0phRHdQa3VZaEFrTXhES0ltWEFoZGdQQXA2d1pzR3pJeFhVTS8vc0VkV2VtNCsveG13ZGlYN3FzdVhTNUhQVHhja3MydllKMDlKT0h2eGozQkYvNG5ySThIejVBbnZ6QzVFeTBZTVRWV0tnNDlTVTlybnBVOGRMeTR1TEs0bUtaN2NzZzd3akhOZlBSNXY2RFRZVjNtK3FLSXJqOWF2MmkrdHZOQzJQdGg3UzVTakpMM0k4bUl4NmZYRktUWmo3OXFDcTR3bnI4R2N4a1pYR0Q3Y0xnTk1wRC9JUzJaUUJHUndMbWRKdWI1aGE0eGVGV0xkbFFTZmhUVUxraEsvQUhyWmVGVzZnczNvY3R4VzdBUzJqT3ZwYTg2b0xLQTFNekt6T2xlZGVGcFRrdFBYbW9NZlZBcVgzYW5sY3p1ZktDSzMxaWFlNkI4c3kzTG02V0h5aGlFNzc5bmdNSElEall2bEFzUFREVkNNNmt0Ym5EYWRlOC9RNzN6TlFEbGJScm9aekxxUFAyUzZYaUErWG1lOTB6NVFkZ09MaWNmVGxQd2JnK0FQTDNFZTV5YmdWbThtdTVsM0kzY3JjRGZUU2hiZWcrS2R4Z0FrMFZNdE04eE9wTlIxdFRYVUNHM0FxRlF5RHh3RzkrY1B4TUVjbHEybFl6RHlLUTNjeGJFRlhnMzFhcy9VUnAxck5vY1JqaTE0Tytsd3RYUzZrckRuLyt5QlZwNlNyeDViNGdFVjFtZXJKNThiV3Z1WHJKRG1ya2p5ODljT0RTUUpSdXQwSENLVVRiWjJhbkp5K2N1TG8xUFZ0WnRvdS81SXNrSlg1c2FtcnF0V0txMmQ3T2JML0duMUFtNnpsZXV1L0s2VEtabUw3eVBvblAxU2VWaFA5aFY2aVlub3FtcTRXbFpJUVhLLzkrR0g2MkpTR0RHVVBRbXA2ZURFNWdHTTdBejFzUzlkalVWTm1vSjc2OXNsS3BNQjd5KzBBalB3N1l1bzY3QmVjUnRDNVpzR1FZc29NYVQ4RGFMQm1jbTBQTSt0a3hFc24yREViUUV0cVo5b3N3L0pWU1ErcllFbVhKejlzbmdwNkE1aEY5Z3VBR3VlNW1laEU4ZVo4cmIyYm4ySGJvVUpEeXhTcmhWQm9KaHZCNSswL1VrRmFXQ1ZFUzVsbk9USkRWclExUDBCdWM4ME1HYmtHNFdhUVh0eXJDcyt3Ry9iSVNtZkNVcE81RzY1Sm5JbEtoTHpZVUlwZTEwSE4wSTNYSGZvdkhOWVV3VitCYVRPOVoyczhNdUpaeG8xMllyclVVcTgwdUJwcDV4K3hWcVZKYnBielN6L0tRTDc5VE50MTg4V2JOUldMRXBieEtjd3VKRzEydTlxdGVMZCtMeFQ2cGY1VmZWQlBtaC9WUFpqTHZqditCbVZDQlRkMytuN3BQL3oydjlsMFZybThMWFZSSm1NQUlWazc3SUdpdHR1RFdaK2didXRGWkZ3S1lWMkdHd3gzTUZJaHNmWkFiNkxlUDVDdVpUQnMrYTNPVXRlUllpYnFhSUpqMU5pdXFVd0FVeURselQ3ZU00dm1Vb21SRDJiRWxIV29ET3pDbXVOWDEvdklFR05kRmFsbGNiVUtPMUpSMTJNSzFhNkZHV3R2Ylo3REFUS1pibE1rS1gxK3ZiTGRXMS9yS29lVnlJOHBxUWxuRlhjdmFYbDhuSzc5Q1dRNFA1K0htdVQyb1BjcDJwQ1FySCtwYVcrSTZua3pYOGRpR3RZVTB5VHFRS1BsNjFnSktRL2JtMjkvR25GdjUyL2dWV3ZxSk9ZRVhnekFNMnB0TzVCQTVRb0dyWk5wLy8zdHZ6cXc0M1dqN0tRYldmaGdyQmkrUnYyUFhHeERpWEd1N05RTC8yWHIyUFBDLzJkNGlyWTBYaHhXSmx0VUNIaTBBczIyQm02VjJzU0ZhWDZocktPL1kvZlZFUmphZjVtUXBsSFhXWHhYc2RLRnFoUmZSd0RYREJuZUd6WE1WTnMrUnJmYTJvWCtxRFBmbXhoYTU5K2NnenErc0VCVHczekF3cjlaYWorb0czclRZZm4xbTMrN2lJakFqSHVBdVE5aE1tVlY0SWR4azNaLzFlN1NXOUhZUTB0RjFVbFNoZ0JQcVd3cTFLTHpOWlZKL2ZFQkMvYTRWYkRDeUJySWFoSkhVNUFkK2pwd3dCaWNOUFpLVFZWSStqWGpGd0xsZ1VINVBxS0JGRTkwMWJOTTN1YmQvM2Z1NGJ2d1huK0FHN2sya3ZNMkYwQWNUd0FWZmpqNGZRQWluTTZEZFc1em83a3ExZ1crcFYwMVpzaHU0OXcxK2NWSERiamliNDRDTlU1ekZLS3RqR1VWWE9laFVHcmFBOXIvRm8ybVdiZ2h6a3FoSkxzdE8zRmhzRkdlYURlaVdCZ2tjMHVXZ1M5SkVxZGdxeThGWVVFN1hUVnpXOXdraUg2RlhtUDZhR1VWMmEzNkp0SC9xbjY5WVdpU1ltcC9RUzFIVFVGMVdJbTdIaThWNDViQ2g2d2JaRjV3SnVGVERqSlltTHBtVFZSMzRQWSt1U3VuSW5ZSVlnSDdlbnFSWDhpQmtPcHVPd1RRa3lqOE9SNWdOWnNjWFNJMjdndTVEM1ZsYmZnU0tjUG5Hd1ZJejY2Q3kwVjN1WVlpUXlSOE0xTExjS3ZhajQ4YUV2WTM0ZUYvNzY0QXR2K2FXbFV5ejVWUmIwMzVqWjQza3VVc21CaEZneHhQM0lRb09XMXJBRTR5blpqTzRMdU5VVXJNNmZPMVpHTmNQQWUwNURIMzVKZHlkcURPQ0Z1eUo0MVpIak1jYjNHdmVYYitvNGw0MGd4ckdNb1pRWXV0ZGxvSktmQU1ZcWJCVnpRTzZtbFVMd2xJRGZaN2d2RGxIR3RVVWtEU0Q4SHdzY3FYc09rUzE4cGxIRkdsVmRidlZDNkx4Wkg0cGw5K2JuenJrenVyeXE4MXdKTC8zb24yNTNONzJDVlRwK0wzN0ZKZjdoRDV0aC9pOUFSSUtoRi8vZ2R3OElWNVBCYnFJUitLRk9jUEl6L01rTWswNGJWMmpiajlxOE8vMnVZdWUvTkpGUzdsYVdmdG9KbEJONXBieXVYMFg3YzM5VGUxd1RiNU9DMXZKRTAwckU1c0pwTC9EeitlQ2VjL2xrSnNLdVY0bWt2bGNkRHFDZUZPZHZWOGY1dzZDSkhBcGNKUTNjYmR5ZDNPL0FkaXI5WFpHSlFlM2dIZTZTdjhlZTJmTFYrZWVqYWdpVEtaK25PSFFXVXJlNFVZQmlmZ0lYbG4xYXRnWlRwZy9QaVpiUUZrTmZWVTNNalFFVXF0SlJrQnhKVXdZL1hSN0dJMjVsSUFoYWUzVGxjcnFhamtRWHVWMTJldVJOT0hJYXFWU3JsVFVJNEltZWJ5eXpxK0c3MXRkSlVDR3lraFF5aXcwOUV3aWtDNUZKbXJVNGN4YnNkWGVTbm1sMmtTa2xBNGtEdnZhcDN4L3BLU0RoMG9aTTVQd3gxT3JxeTNmKzI1THhmMEplRkE2RkV4LzN1Zm9jcmRBZHQyQ2VTOEJkSFNWZTVoN0QxQlNYTldDb2VMb0JPbnVhVlBCUGRlVXJXVFV2VTYzOHJEL2hiQVVjclRuem1yRnlMdjluZTMxVWgxWFBSeGR1ck1HTW5BWENnNFd1aVVLUGtIV3c0RjRjTk1JaEhVWmJzWGdxOXF0aEJtcHJNQnZ4RXkwMTRncXlsNUZWRjJxSit1QlVGUU1kcGR6MHp1dkxLcUVVVit5Nms3M2tyZ1ZUODZqdUR1Zks1Nk11OUlyaHF6cnN1U1JOVyt4RkFvR1E2V2lWNU05a2d3RC90U1pNMlppamY0a1ludUlqRlJkMFVSWkZqVmxPQzZUUFhENTBsWFNxSmNZbDY0aWEvMlpPL0w4VndqcS9kQXZSUVAxSVJidWxtOEM0Uks2QWl5eUlTazZuS0dQeitlOGRFTU05T0ptU0pGVHVLdSticGNJeVAwV0pucGFDd3BWNjdDb3ZqSVFpeFZpTVlrSTVCV2l4OFdMcjVmVWpDb2Uwang2Wms3UWdnSGhRbE1nNGJlSTZrTzhMUFBMb3FxOTZmRG50Q0Q1ZC95c0VIc1hJZStTZU5VamI4cnlzV3RsWFZPT2xrKzlUd3ZJbXY2Zlh4Y1gyaC8rRzBYNGErQjM1TzcraTd0aHZzNkNCTnZzK3RicFVUZC9UMkZJRjExd056ZkFxMUNlcTZPQk5tVlNTS1J5aXd1Znh4NmZ5Mkg0bGNsWUlSeVorc2F4cE4vckplWGtTOS91amQ1OE1qOXBmY3VvWmZMMUdHVTUycHRNWlBHa3M5Y3MvYjZtQWhOa2YxUCt5R1ErV21iN3pzbEJ3TEhNWmREeXNpbzA4eWhheUd3UmxEb3dhRFNERFFTMzJTaDkwWDdqNDgwM20vZmRGNHp6SnA4TXRVcHkwdktFbGNjMUpSWllEaXRKc3JIUlBuUDZkQ1VhT0IxT1AyWVZQVzdpOCtiQ3g4SWxTcTl3WGVwcExnYWpiVDlRck9QY1NXNE5SaDBIc2l1YnNEdVVmWUY2Rk1MMUo3WmVHT3FhWWxmWmFxRFZaTVpVakhqWmZkeVA1V3c0WXlabnFONmdlL0Z5YUd2dTdBRmJzRkRzUTFyb21FQUFmc2xEaS83RnVtaUl5WGh5ejgyTGl6ZmZjL09pbWhURnF3bjBiR0hxNkxWSHA2YU9UdmtNTGFUSExudHJiNFZrbjZJcjhDZUpvbC9VVkF3T0M0b3UrRVZGRjYvcHh0cHRRN2V5d0UwbEtnbmdCeXBRVmswVWt5b3RadkhtUFZBb0ZGMFVGQk9ZMENrc0Nzb1RlSm1QWHZhb2hQa3J6ZDQrRWxHRFlsUU1Rb0t1UUFHNklsYTdzZGZwUnRaQ1NnbEZHWjM1RlhtSXA2bU9iZy9NRnBjeHJ6U2RuYjZJUjJ0WUd3NnNVNHAwTnd2M3JaRXJXZXJHSWx1cUJlbmFBcnhZbDRUVEtOaERvSFlpRXBrVkJGblJvUHVoY3dDeUN0RTVZQ1NBVHlCN2ViVzlCZkt4bjdSSXVhTVNrSzdwcVFjMnRWbU5hTEpQMGZETDdCemtzaUZyQkhnVVQ0bThLdWhwLzBoeDFqa0pycEhvdUN1YnJYUTBMVnprUUV0REJqQ0lROERQYjIwQmY3M0IxdFVKeE51VnRUVnlHcWptc1dQSHlIMUlnempHVjNmMGg1MDFwQ0ZkMDhBKzVLNk5DN0poR08xcTFaNGZ1Ui9nQTh4L3dtM01ENEtQM1kzZGpWeG15VElzV2RWeG5pQlRYejMvTDlSNUNpamlVZTQrN2lIdS9ZNTNFcHhEMktSajB4VjRtVTA5aWt6bkVRV05VS293dFFsaFdRRitDR0xoWUo2NUVjRjVQZHhoQ2M4bkQ5c3BiNWVzL2hXWXliQ2s4QVFwSVdDZW56a3d3OE1jSkl1OFFIZ0YzbW1pSGdncEgxUEMvaHRKZ0NUZ242VFR3Wk9HU3hHRGJuaWJCbGJBSFpSa1Yvc0ZJTlhTMkV6OFljZ2tGTkJaZ2VsUmVRbHBFZk1TRmRjNy9RSFhwQjd3YVREWCtUUWdUN096T1o5WDgza1VsK1lMNkpPdWdMOTh0KzEyMi9jUTFWUHgrU3B1S3hCb3Z5cHpUZHpNaGQwNEM3ckRPVE4rRFhCMU5BZXZEM0xJZTdzNXVDYTZPZHhkOXRQYlY5RjhQT0VSK1NTT0lTK0NZNVJmaHpHS2U1eHkzQ1RNRTVjeDdTNnlET2oxaFMzaXNhbkRycUtJazdlQkR4UHFWY3FZVkFmMktnMDV6bURtZVA4akowVjk3YS83b3RLQ0FCTFpSdTE0clhUdzdDUHg0b1hSN0pPUC9MSDB6K0Y4NnMzMkFkcytjQVVHTVVFV0xrcnpDaC9rK1NaY2J1SjVzblRTR3doNEgxZlU5dk5tQXI2ZnVhSng4d3FmakQ3NmFQdTU1eVpuSnkrTk94OUQ4QmM4ZjNHYWg2OWxvY25EMXdyUDVEdzJCNFJnakNXcGJtaEhIVkVheFVrdlM2dVhEWkYyZFFEd1RUTlJmZktSOXRjZmVWSWdtMFI1dkE4a2VLdXFPQVZ0YjFQK2dhMmhka2R6Y1ljM3BPNjZWRFhVQkpZVytGcGdaR2xVNmtUNGxUV3FGRmpyTG5xMjcycFZLcTN0NDgrdlZDcUhTZm41dzVYS3l2WXBmSDBxWVZJdmloQ2N1aUVjdnVIVW1TMjhiTkd3bzJ1aHREalB0YmozVXR0Y3RHbGgzdkRRRXNaeEJ3UklRU0VGRFZ2Q3pUNEovZ0ppMHhsckNWczZDWnlQMHBHTE91UjZGbnBJTTU5ekRCdlJnQWxUV3ozeUhxSUdHejFkQ2JWc1pXSkFEY3Y4cFVwNElaRVFlS0lTV1ZoWUVHU3k0OG1mWmRNK3kzK1c4MXQrYjdxVytreXFsZ3JIS2xrcjdZc0dEVUdVeE95c2VNbGNYaEJjMFBxeDNIRjMzc3hJUENuR1B4TXZBVHVwVURWejVFeUVYcFJJSkhxZEljaThZVUJxQTRxSlJxSEFIVThlbXJ3eTZidkNaMW0rbDd6cytQV3BhZ3Irc3NaTUxKeTIwaGFRQkNFclNPSkNUamV3MDdwNVBnd1REQy9yc1dJeHRyZVJQelpKRi9jcUZYclI1WWkxeEFHbFJ6M1BHOGg3SE45bmVlRFEyTXJLQ25jOVNGTjM0dTQxbVMyU2RNbTdzTU1WMm4vVXF6V21GcW93eFl2T2REL3ZkTzRHSG41cjFNT2hsT3l5eGQ1OWhPbDB5SEZXeEZQc2R2TlhlT3BZUWpyakMzMlA1TGtMdUF2UnZtN24rTnJwYmF3NUtJNzIyU2FneERuTWNKRGpJeDJJL2NZYWxTVFh1clozN1IrRHBNZ3gxeVRNQkc5enRHdXdUU28xVnZvdDdpcVY5dWZwVjlUcXJzK25DbElvR3kzRnlUbGhWanBLdFd4M05hRnZqeW81UFFyV1RRWWtxcHdaMEJ0VVB0NGdxMVFINmV1SHorZWpEbFJlK1ljWTNsOUFQckF3NFBzRitib0oxTndPVzN0SWcweGV2WXZkYkgzSSs4dUFJV1A3TXVvcGhibExjZUFqSUVXMHFSTktnblpCbS8yYldmWjFXRk9wL1UyS1NMN1dmZExSTDg4RHpidVFPOHlkb0wwRWhSeVluZktPS1hMZVJoWXFUVUo1cHVIQnhkZU9rMUZFWThmUHFMUG50MVFFaVBPMVJyRGJLakQ1MFQwSEJ1RWpyUW4wN2puaEtTNGZYUzU2SjlEcDUwUUxHZUpXdUlsdnF1Rm11cEp1aHF2NHBobkdWKzJ6aGRxcDJoSUZHVWdaOGFWcVQ5M0V2aXd1RitHUFpYa1QydmRNRlp2NG9tcUd3MllWSHplTFV4RjQ4V3l0VUtpMTE3NkVsZjRTWlBMNDR4QjA5RFJNejlDeDVibVN1NWw3TFhCdXUzTGh5aTZXT3NxUXpjcnc5eDExaGI5RVcxbngwMldpbmdNTWYzRzkxOUx2N0VTVUI3cXhSN3F4UzNvSkwrcysvRUs3cFVnbThlcmtLczFMVEpBMU45Ym9tN3ZiM3lmVDNXUks3OXZWWHJRWEhCdVY4c0ZDQVozMVlNTzFEeXZxUVh4OGtIeU0wSDcvSmY1Q3dPY2l0NCs3bkx1T1daNmlkZ1U0MUI0NnFJRWlOVmRIKzBXWVZsRVlSTHRTTkdHMjJIS2dCSE84UXJVdnpTcElQTWp1eWlXcVk2MGpLOHUzMFAvUmdjYlYxOUsrSHBOVTBRQWVOTGcvbVhLTG9xejY0SitYVk5WMXhhVUxGNkNUcEJmT2JPN25CWThvU3pWWlZWVWw2TW1SYS9ZMmx5KzhjTG01ZDlzSUM3OXBKdllrcGloQnlKZkNrNllzQm5UZEZWVjlrZ0pmS1laWFZyT3lOQm12Sjh6ZkZNSzUxZFduSk4wMnMwbGYzaHNPK3Z3U2Y4VnNMS1crVEUzRlpqbEhadW41Q2k1eFZjREl1ZndGbjhPVGNOZVQ1bWhYd2lCTkppcUxHQ1NvVitHcnFXdGhLNXVkeldiSE9CamVjRDZBb09KOEFNRXFmakdiWlhTQnlXOXU0TThXWURTZ01Ta0RDR1VMaS9rVGR1eURxVEZHSTBpNUc5cUNkRjFqNnlYMXhmbnIxcTZiMzFPL3VsNnFlL2tKcStaeVZ5TmwzbHN2NVpONW56azdhL3J5eVFEWk9ySnl6ZjIzTmhxM1BuRE5sV3E5ZWRuOFpIRjJLYmZINDltVFc1b3RUczVmMW14L1Nwck9tTW1KYW5VaWFXYW1KZDdSRVg2Vko0NE9DdTJhcm9leHl6VTd5ejRTVy9ReHc4M09LcG5TYy9uVGpTRng2dlBBMDlVTHNyV3pyT09vcTE2a2E1Y29kOTFoNVN6NEk2b2ZMOWJIRFYzMWV3MDlveHZiTlBUNjJUS1duVm1jZmRuc1lzYUcyeFhVODVERHFPOGhxKzFQa211Tm14KzhlWTFsWUxIOHRsZDA0NjMraERyWFU2Zk9xUW4vV3cwZFh2akxjY3V0YVc0clh2WWJEMU1iMDUrdnJGUkM4ZmdRRFVNN3I2cGpqL2phRVhNT213cUJ5REJiSUtpZWJBLzVTTFoydVZkMmVVODJkdXlNYkcrSzVGcW0zQlIvUEpMZTlFVzNSajZsbW9IdUxGZ1IrWHZ1d1JsYTVILzZVMTc4Mms2eXBVaVBkb0xiUjd6dHAvMVBEOUQrdDNEdjZuaGg2ZEgvNWhBdEg3NGZwdlgyTHVuNzl3UDNPejNxZDM4aytMTk95ejNXQmZ2bHV5RnZEQjQ3REFIei9iN2VjUWxmYVcreXhiN05YbHIzQ0d6ZE1BcS8zWUJvdlFhbnZFV05oZGo0ayszdlVrOHlRaGZYYUlkNFlKQnJHOGUvc1IwZ1dmUWhQMm8vQWRrWXFvN1Q1MkpPVDJ1K1c5U0ZTMFhSRW5SeCtqVVFoRVd5UGdCZ0g1dlVYZ05NVUdqLy9OMkNlQ2t6MjU5NXRXTzJ6L2hwQ3IrSGkwTlBPVUtsUTlQTHk2WDlmR09CK1IvQnpZOG96VGRmVk92K2JJNlExMWFnaDB1dkpkS3hxT3lYZzZJNEs0cEIrZDdkbXUyN2MwUWlyNVdJSWxWZVMvU28zUDNTL3h1N04wbGZuYnhjQk9hbWk3Rk96cEp6azIwdnNqcnlWZkJGTmRlWFpVWEtTUXFhdDgzS3ltV013RDE2N3RiNjF6dEVSUkh2Z0FuN0ZLT0xaRzczdHVyclYxNmdleGZRbGVuK2dadC9jVzN4SUpiMURBWVA3b2I3MS9mVXpNKyt1UDUvQ1pYR2VwWWJ3ejdndW5DOU9OakppaUpkUnVHNURJdnZSdGQycThsSGRueUMwYy9zV3FtZGRWSUdmR1h1OUE0S0krYkZVVDZ5NkllUjJHakE0UFVMZUJXRzdoL1pyWEpIUm4vWHZTZkNydlhrQjJqWGk2UmN1eEdwODZGSURpLzVBNUFuZjRmdTJ5Z0NISmVnLy9jK3RXTFgzYnBDZDVSU3Q5SnNmMmdWQUtrMnFRR2FkeGpRS1ZSbUVZNXV5RHhBZDJXbUppZjNUVTQyREIwdHlxMnNabWl2ZVVONzlRMlJOMGx2OFVaazkvR3VJR29lTnlTejdId0d3UlordDIveXNHN0FOMWtMUG4rOHZVMHlyWXJmeVBaTHpDVzN3ZlpRZE9SalpsbTl5TFFVd2FHWk56dlFYNXFNQThsQ2pmSktWZW4zc1dSM1ZVRkQ5Zi9RdlNqMllrQk9kbmlJUjNORzVEVDJFaER4VDd2LzRYaXZGaFZXaTlXKytwTzFublc1MHp4UWpabGc0aGpVYjlXM3RRTjVxUjRLK3YzQWZwemF3czFTVDFhN3Rva3dzbTNKZGVkb2k2dDJBRUlxNDFxZy9laU9obk5zR2JNQVo0b3JJODlmeEhVR2FyMk1LMzlKQjlFWG9FWVU1UUJVS0ZGbU9XU2g3M0s2MDR6M3Y4WlhYWXFuRFgxZkNVUnN0cFhKVzF1cUo5c2I2MmFnRmpCZjZsWFZHU3Ztblg3MUI1K09wYnlCYkdFV0VtN1R4S2tQL1drTUxrc0gxMUlCbnkrUW1vdEZ3ekZSamwxSzkvUEtaOXNjeC9Qa0lXcGJ0Y0s5bEhzbGR6L3FBQlZudFJIa1o2WkJaZnRBbS9pY0tsNTdMR3UyRzZPOURQRFBIQW8wbWEwbVZiMUtXWnN0QU1PQTdQcC9vSTB6dk8za2NhOW1pcmdJbENlY0orL2N2RlRsdFlUWDc2UENRSnZKQkQ2L042SHhLZy96b1dMc0sveE9ZWitod013STNXL1pyUlZDdnhNcWFPUUd5OS9lOGx1YVF0WVU3VTJQOGFLaHIrbUcrS2hMNElPeFlENmY5N0RZYWtSMTVZS0hMZDg4eWdpWkRJYnpQdXR3TU9kU0k3THV6WmJMV2E4ZVRwaVJpSGtYN29VNmpEMTVVZVJSNTZqcmZOZnZJUE92aGJoRUc4WSsvd3FEN25QN0I5bEh2NjdLOHExQU9tK1RaWEpiVDVxczlHVE01N3pTYllKd20rUXRqMXhvRzFWMnY3dkl3WDdmNy9TTGxNK2RNOGwvblhsQVJPRGFIeDBKM0loNjk3bVpHSEFyWnZWTDRNOTY1VnNGNFZaNVRORTM3bzZXVWZVdTlubXRHSFFSM08rVWpkeTJlNzBlUHpkOFBiL3VXYm9QbWR2aHU1SDR0dEVWNEpwUmh2LzRJMnRBTmhLMmQ4MHcxcngyWW5PTjJReHpQeUMzc08rYncxNVR0L3RUcjJ5SDRuMVpjUjJiWSs0dk85LzdoejJqOW45T0tqdS83L2tCY2dIL1BUWFlYM2Z6K3ZQRy91YTVkS3lubnpPZC9yVSszaVBtRGpqNisrNnVucWw4blJKT2pmZVIxTitMTHpvUHYwZ2RmUFQxWTdJTEhLYzZ2WVg0eHNJeDBLWGo1dzlIZjUvZUZSOEgrK3I2RzJOQjJlaUF1ejIrWFRyOWU5N3BuOFBlSjRlNjFPcEE1M2I0SzNiR3d3eTFaanJJWFkvYUU3dmZFaWdvTThjYmRwVXhGbWdEQS9WQlQwSFVWMFJudTA2MWU5QUt2QnR3MDl2bGNQbHkrdzZWOTJnbmtldGJ1VGhRYkJTMTkyb1Fta1R3dXRyL3JKTTlxb2VmRWJ6dGo3S0Zvdi9KTHA3Mlg2WEoycHRxZ0xLYUpLdHh5ckRIVlptc3o2Z3VabEQwa1VDOVdJejd2VjUvdkZoc0JDVlhvT0pTVDdzQzdUdlkwaEQ3ZTJielpFMkFQTHlNNy9TT3hzSExYeXdPdXJ1bjg1MUlFZDRwOVdISnBtc0ozcFYremhzanR3MGdoR1FwUnY0L1JjcFFFMDYyNTZ3VFBSKzBQTjZQbHNjM2orL0lCS1BRdjE0NCsyVmVJUDhuVitIdW9sWmk5S2daWUkzWTZVb0t1bnhGbnl2NGoyNVg4UUEyL0EvVExWOGxoYTRraDRGVUtOMmxaQWljdFdTYnJpcVhZQUEzbldWbEdqaHJ6K1JIcHBTTXE2SFptREt4RUF3bnJLSVNtdzJwOFNUdVR1bTlDQzVNZEo1WFZkbFY5UW8rVjlYRFcwcXhxRmk4cCtyeUNkNnFTMWFMeFhPKzNUTG51L21ZVmlMR3NwODMrN0x2SzNiZVA1eTM1TzdQV3cyenQ4WUN2QzJWb09RRmc3ME5xOFh1WGdyY2IybHlHYTRFbU8wN0JhSHJ2eGN0eG5HWkhmdWkwclNhVnBiOG5LNW9kYmZDSHpwMmplZ1dqcFAxbHdyNmovYXVYRFhkL2tYRkVkQWRCMTFmSXQ3RmF5UmUrdERxMzBuQ2I3OThwZjRhcDg5M3l5OXdOZTRROWNJeUNvYmRWSUM3M1E5QnZOcFRIK3dhSGE3SnZzTjRQZHpWVlR3em9PN3NIbGpYOVFIbjFLODhEcnZVYlpkaUt4YWlOc3gySVEzaDkzY2ZWV1dwZnJ6MW50eHJXbStvU3Q0ZE1KR0tWNm9kYjcwNzkrcmwreFprV1gyMHQrOXpDMlNLcHdIVGZpNk1Pd1Nwa1h2ZURzRlFjZnphU0thczJFS29hemZ1SEdEQ2pzYVlBamFJcDZkSVJCYU9MVHhWZVRoNnFBaVJoV05rYnpMeGpvdjIzN204Zk9mKzJXdXlKQWRFTVpZcktwSloySC90SEs1UGJVQzZSNTk2T0paWU9IWVNQaTBkVHJ5RHVBdkxkNzdwenVVOHBCZkZhUDc2Q2lTY08zWmhRUm4walJDbHZxN0hMczlZOWdnam5qR3VadjhVSFpDOGV3azFpcUo0ZzZDTFQ0ajlobVY5WE56RFlWRjQxd1dDZ0FyTEcwVHgwNExlTjcvaVR1VHlLQzg1L3V5Z1c2MnVkclJ2dGpSeDNhSHdCTUJ3QTlPSExyMmI2VU0zQnpVT1pQWFZueGFIblpaUWYyZmt2NUc3OFV3VXJiL1dUWWVESTU5ci93TDlweVZFOFJINGxreUxFTlhKcTlyUDMwSmp3dHNFZktnTFNSenZkRDhKUVR1akl6RER2SnE3ai9HVFU3Z0kyT2ZWRzdkUUFPbnNtdERnUG9LK2c1WFFWSjdlREpqTHp4RnFJWjRpVnRmNUdsdU1DdVhyUUR5c2FraTI4ZzByWDIvV3F5SHJPVVZ5S1FJeHNBc2JxWm1FNWpiMGltNjR0Y1JNaWowa3ZPcVNsSUJNQjVUOHYrdGFSQk1NTmNQekJpL3hVWmRxcU5Qd241b20rckorKzJaa0xaS05TNG9aTWNKMGVJaUJ5ZncxUG1JRURmZ2p2bXZ5a3dHUnZnZ2JFVk9SNHJxb3RMQ1lsaUwreEdlRmNqenh1TktRc2NIejBVakFvNGg4cWNTTHltM0NkRGI3QnRVSUJLak5xRUR4MXdMOFJibDlhSW1HTmtmTmtqTy9oa3dsaFh0T29NSzQ4UW1sOGxBVmQ2eFNxOTJ1Y2c1d2pkT1dMTlVIWmR4TVBlRzMvQlZmeEorb1oxcGJyWXJoMFVKQWpFS2F4ekF2eGUwMW9uaU5HZks3QW8xZ2lQaGc2RDlMeVVCWlVoNHZYSCtGNlE2aHlCbHltMWRjWDdnaVhLdUZyNGhFSkZFa2s1TkVGS1ZJSkQ5M1ZJUThkT0hhVE1CNzRkVGNUM3JleE0ydWI1emQ5dDZ6UFJWWGNseVVaUDNVYTBhK3ZzU0g4cmozd1lZb3RqWWFqQlh4eWw3QjQ2cmw3QW9vT3E4eFRwODcvenhIRlVMdFV5MzhXWGYrMWx2dExVQ0U4d2gvNEI1alc1MDBaSXZ1V1VRM0dXdXQzczk2YTl4Tmk2NWRmcDlISDZGWUo1eDFia0YvUUNSZjMyRlZFTW9QUHFudTBEWDZzMHEvb053Y01pd1pjSjA5N0ZDUFA3NUdmVk5TTXA3NFRqZDZESnVScjBBWVJTOGk2eDFsVHFwbUtKS0tLU0JvbitrOTlsV2hjMEJMdzBXUVJkS3E3SnkvSUxEODdUT1lNL0g1cmZacHdwMXh2b2JnYzkxSjdhN2V3OWRYb2RkQWI0R0xqQjRveCtKdEdFZWo4TGdUYjlLdmdiZGpYVng5cHcrRGE0TjRhNitPUkJ5cGpFZmNTTHhWZmszRTlXanU5ZHlOM011QTZ2Wm9idDgyWExyc00zQTJ5ckRCR09VVmVyZmhFVFRZRnBTOGplUExCRkpyOTlGYUw5RGFHTUlaVEltR3AwRXR1cEtDRUJhRUpFYk5oc2NRVTBGTUVDTnViNC9zWGhxWmpTUUxXa01udDNaSWJDd1hUUE1VTThmZFpsemtMVjVNWUI0SkdvMmI3dVAwSlg5eGVaRE1rdWpodzI4ZzVLTEpxVVBmNkJCVTRleS9BMjcraks0aElYM2hwS0ZETElKSzFtWmVSMGV0MG5Rc05WRXZiVldwS1ZiWDdXenEydmFaYTVWSWFITUJnVnVnS21RVzNReEZGdHUvZDhtM0VyMnpIL1NmL1N5WXEvU2xvZEZLem5nRzU4dzJwZm5yWEE1bzM1WGNjVHdCQStaSGJCK1FQSmhCVWJjaEhNUFpPWHFVT0xKUjlHeEsrR1BIUEZOWnd6RlNWZktkQmhJNkNuUlNuaWlVWnE0SUpsMlNHQXg0c0JXUXZNcy9kZW16dWl1dTh4b1JYYUtZazFWSkZ5VHBDdWpLdm8ybnRpT25JcC9WUFRyOGxiNDRjUlFtbnJ6ZjdUN3BUNnBtWk1FbEtCZGhQUzlTaEF2MG9HaEpBZGRlVFhDVmdCK0hxVlNRVCtwUWxLaENUby82anJ0eG55cE1MWmdWWFh1bGRWK250b3lMM0dHNlNrQmh6OWZQVVQvVXJYY3dreWJNQis0c0NRNU5kNlNqV2QrMEQ5amJobWV2eDhoN0JEZVJERW1hVm5UWncwdnl5Wk5tV2xjVjB4ZTBTS3QyL0ltQlk0KytvN3JkUHJlYnJNSDNwM2dEWkQvWk1vNjZSYytDSkNnOEh4VFVkYmNxeGtTOUVpMEZ2TDcxUUVwUjQ0V0Y3ZHJ4V251NjEvYXZ3RXg4Ym1lY3RzakQzQjd1QU5SMWhiVXpqTlBlcUd4USszN0tEdlZ4UTMzajBHbCt1K2ZMckdyMmNUMEV4a1RlRzhDeWRZdVF2UlBKaFdSWXg5dUFOODlHSFczdkR6RURJcUhtdnN6OURtemVVbGhTSnBvVTRtUnBZaTlQRXBWa0lVSHZHNU9LRk81clpWSm5sa1NmYWt4T3ZZVTJLSk1Gc0c1NEh0VmVyb1ZyNk1NanJjaDJLWFRIR1ZvVU9idGlaYVU3MWloVFk1ZnNQSWdObmEzZFNEZDdyRWo3T1VueWFJWk03VEZqdmdBbGlRRWZKVDRGMmRBOCt1VkJ1U0FIUTZWYUNmNTZnOUJTdFhDc05NRzhyazFZYkZYQ21tRCsxeVpLc2JDL1VsOWFxbS9IOExNUzA1a2dYVVVicE51NTEzQnZvSmFESFF1a1lIY3lvYjJTVW8yR1hlL3plYjJmN0tWTy9kQnJKNXQvNkg1RXlzalJyWW4wVEdadnY4NEVrdE03d2FvMlM3YWNzMldyU3FsNEhyNkF6RU5LcUhyU1ovbjlsdThERGdFTkFPMTFNOUxybWVGRms4QzRFMlZGRjNnaUNLWkVsSndDUWhqdzZMd1Fjc0ZMVStSblBJd09Dd29RNG8vR0dqRkROMUtHN2xwVWVGSWd0d0FaM2lTLzYvYjVJajVmKzgwOStxb0RiWjQ2S2xCMDNTM3hMa0VWRlZYeUNZSVlDb21DNEpQVUlNOFRGeS9kVFpNSTJWQWVPbENjZUZzdEVmZHEvVGhaTURPQ2NQaU5TSnZWVHAvNWQycmJGSUh4QUhUUEdqcktKdGd4ODNJeDF3ZmhJWHhTLzVaZGpGWVpTbE5FRVlxQVFCbUdrZ0dUSU82aGFmVWZmYk1Gblg4dWszbjlLM2hCTEl1YW9LdHV3NVRSMUdKQ0ZaUm9KcW9JNmdRYWJjZ2dsUEE2cEJINFY3Uy9jbUQ3UUhDbW9BWnF0WUFhOU0vVWVpUDhOOW1BYUo4aVJGTFJ3N0lZZ0N4ZEdVbFJ6VkRJVkJVcDR6SktJbnBoVnFYMjJXOS80aE82RUkrRXZONVF4UEIwejVQOEtya1F4by9HMWJuTHVXdW81d2xBeGp5ZThkekZSMTlYcTl2OWE2bGVZcktlWTdQKzBxelRRM25vdjRWYmp6dTk1NmtLMnFjL0xMTVJoYjFIYzZVMVF6K2pHMXJhcFVuS045OEt2YUNjS1ZmZ24vQ2ZCdEt3L1NqYXhlc2Y3VkVBRnhDTHhXTlJ4WDBIdnJqRHJVU1BMUUtOeUpWblkxTmE1bEFaZmc1bHRLblk3TDFJSGR6ZCt1RlpKMUhxNndMb1F6V0wxcDhndmZTNVlrOGoxeUVIZTV0OGxSQ2FodUl1YUJ1OU1ETFB5TU1IVVdWSUt3elQvNFJpNk8zVHVxRk1FRkhSeTVXVlNybENlTkcxNVJKNVV2bklJdlRuMysybjd3Y1hzMVBhaEtLL0NTdnhKbDJaMEtZeWU4aE1CWDVPVkpMNTZGU2xNaFhOSnl2M0xzSlljUCs4LzJna3VzYk5mTEFxM0R1NURlNXhicFA3SFBjbFpvbmZnWkZ5bXVlbUVlZkJlWXdrRUZZNFZOK3RLMWhoa0ltYlNuV1FmRFF0UUhFVkVkL3JJcDEzNUwwRjNhZS91cWRtNnFjdTU4SFlVWUlTd0gwbWtxeWtKRVBmMGcwcEJZS280cEhhVndHbmQ3U2hPUVRtamp4UnJsVklQcHJLcGFLUEJ4NE1iTjVVVUhWZHZmY0FadFZIY2NvWG53OHZtQTdtWW93YjVHWEJCZkFXSjAxUmZnbTI3RXRrMFp3c0FuZ3VnU1FPSDM1dThpSkNEajFBYWREZlJ2enp0ajN2ajloUitQbTUwMWtIenljYTFoVU5MbUkyUjV5V1BFWlhOSE0vVmJrSUowNVE5WXo0Z0tDUDI0UjQxLzFNU3dOSnFjTG8vcUYxWFFldThlZFFqVHh4ZDl6eFV6dExHMzJpMC82ZEZYZ3haN1gyTkZuOXAvZU9PV3ZxemdjR1lYcEFFRVlEdGZ6QUlGRDMwNk4rKytBeXFWMUczNmxHZmVhRzF0akZjS0x0ck96UFJpcjJTSElIcUt1akYyclIxdWduNUN2a3R3R21DWUJvbE4yak1sTDUrTVcvRlBFd0tlckUvOGtubVJQLy9qZzdhNHE4REkrSndDY2l2aEVoeGZ0NlVaRzlaSHJqc3o4a255RWZZM0JJQTY3NE8wZUdOSWZPM3FZZCsyM25VVUNNQVRNV1ZsWVZiaWNjZzJlSGRMYlJLVU5IYnlNOGU4OEREUEtoODhKWkI0NitkaG5VQmppTnhJN3lHRDdCNDd5cUdqdWZWbUY2MksrUWVkU1VrZEdkWUVTTFJ5SDY1SlBzVklLL0V0aXhZdXhNSis0c3hhdHpadFJRUS83THpsWWJ5aHdQYnhySUp6aXFJYUlqMEQ0aW80RTEvczVabUNQUEY5L3RMS1ZuUjR6Mkg0MWRYRDY1ZzdDSnhIMCs2LzlzdldqMHVlVzdHU1M4ZFVlaHBEVVd3ai9mU1dVK2ZSN3I4WjN6V0VlZWg3N3J5dndGTzJuclc4WkMrTlFJakgvaFJlQnc1RG5ydTRING81MW8rZnZ4VmhVN0NmREtXQUE3NDJ3Lzl1blJnM3BuQjc1KzUzaGwrNG4vRTNtYXl3RE51QlR5cEF2R3VGZ3MwMEhDOWlFMkhiMFpPdFRvQ096V3FKMHFqcjhNUFAwa2JKSVArMlpNZGVtS0pkV2M4WVZDUzVNcE5SNEt4ZFhVNUZMb2REU2ZYOGpuUDN2RTBOR1ZHdzJQNEc2NEl5ZU9LRENkM2VCVDllTENRbEZYZmFGOW9hWFBwaVlEZ2NuVVo1ZEMrNDdpZHd2NU54ejVPbkpGcTZzWWZoMi9VWTVnQm94dTRCclprNDd0UzlqQ3hRWTZROUpWQ0xabXA2RFhLOGRSQ09vcVpKSlJwSmxMeW5TV0sxOHlJeWx1WmZHbDFZUDN2UDN1ZzlXWExpcHU4Z21mckJGOThlbzVPaGMyNXE1ZTFOSEhoS29SOThVdlh6cDA5d0dZSnBkZWRyR2JPR2RtOVBpSmMzQmVZNWlzY1J4VmQ3MlM3bnN5dVVtdUNsSVdPMVZuZUw5K00wLzlldzJwbEx2dEYreGZZKzNiWkJzT0VZK2dDc2RMRUVRRTRTSzR2STducDFaS3RkSkt4em96OGJ2TVMvd0hKYUZOZlRtWE5XVlQwY3FDOUkrQ2NKM044eEg0NmlKQnVJL1hoQy9FU3FWWWY2LzNNWmZ3N1R1b3E5QVZRY3FnOFY5R0VoeDVoTlVOOTd1VVFjYkNuZFN2cERZN0EyYU53ejZ5N1IyYm9vTy9jdlVqMUgzcFlQRHBnVDNSM3oxUGJKeG16cmN4V08xRjd4aHcrRTdVRjRHZzNwNjNFSENwdUZJOXNwYkM2Sm9CdWVycTI4aktZQjFpZUZxSXlFL1M0MEVtSWVwc0JpZnJ3K0JSbzIrZ1JXd2pzZU1SNmxQT3B1NGQvUDNNTG1maTlpUSt4NG5CbUJHaFhpTlJUODBIUlNJRXhvc2NkeXlMOHU4aVlPOUdKMm94ZE13aWRQMEdSWUVpTEhWOCt2ZWhqSzR1ak1CYmlQbSs2L2RlUTA2M3Q0QndVMXkwV09UKzlyY281aExtdG5nVGk1TWFtbkp2c1gzaVc4NkdjVXpmcnJDWDIyWUNjTHpxcE9UeEswN3Mya0ZnMzcrQXUySDM4MmJzc0dMUUplbGFFM1ZLaUQ1N0ZzM0pHb3diT2NkYmErelJNMzh0aU1HbFBZRmdOblVzS3ZCK1h1TE5tVlJ5eXVSbEFyeVo2YnlLOGJ5ZnlQVFZ0QWxwem5VSXpiV2lHUElFckdoaE5oWWhVVUZJQ1lUM2tkaHNrZy93UXZ4Y0w3czhGODkwTGczcTFTU0hxakNrM281REUvUW1rNmVlZlBGa0V1cnNTcUhINjhBSW42Vm56eVBoVjlnTU9iUm1SSHo3YjNIUE5LZU9UcEVWKzRCZG54SXVuSGE1b29jbnlpMGpFSWtYTmEyOHVGaHVuMHJWVXMySjNOS2V6bkZ4QitsbWlZT3FURGF2dkNCdzFUeGtBSi9QWHVxZDNzZW5DcFhwdkJkTnVSWlhGdUhEeWYweXlTL2x2blpTZ0UrOWRGSHVtTGV2WGdtbzF6RzBPamtIOU0zeGxRN1p3OGU2OVowMFRYeWpLNUlmWGUzNUpscy92d09xZVFkYkJXZmFkTEkycWtxVkVYVi81MjgxMllkMzBHd3d0K1p2T2ZxbS82aTJaTVl0OHBCN2lCZlpsdi9icjlHV1gvci9weTJGK3NpajhaeEt2c2kySkw5K1c3YWZHTitZL0VDZGY5VWF2OWc2blRmbzlOeDN0dmU2UmZjWk05MU51SW8rMFJHKytSdzZUVVF1Z25xYlFnWVdWM2FRbThnQnNQZ2V0K21rQ1QwL2t1MTNWMlJMZGpoSFpJdGw5Qkc0UkxmMmxPendVbytidEJ2MkxFKzQ1SXhQOXhKQkxNdHlmcUZhU01ZdElvbUNHSkFVN1VaVmtRSVFGM2tybml4VUYvTFFCd1dSZUhYZlRESzN0d0J2ckZDa2FCYVdpOFFOSFpQM0pnTTNCWkplbnNpNlRvb1hGTTJTRlFvTGdsallTemJ5alhnSlBhWXRYTExnc1hoQmlNWjFYMWoyZXVXdzF4VUhrc3FIRFhoRmdKc29KaHI1U3JxUk1ZTzhwaGZuNDRVTENzVGw4YWVDd2JUUDR5SndHNTh2NmhvZk5EUDFUTmNPQ3YxS05lbHEyTlhVTnlqZHRXUXhqMTd3VzZjTnloNkdET0tjL1llR1Vlak5peTJYTFpOaWwvUHEyQjUzSTJSOTdzQmNKa1pDRVc4aFlWaSthQnJ1MDFGNlNWaVNHWFJGeVZRb0h3VFdMTlUrelR5YWVkamwyNDRidEFvNmlZdFBxcEdZTE1DUHFHd29rM0gyVEhuR2lVWW5ORlVIOWtHVWRTczJxVTdlejV5aXRWZlpsV1FjSjJtTXg2Ym5BZDBDUEV5RWFkNmF1SlRwc0N0eU1SODJPODQxaWgyTzArNDN2MXNYWG9lMDRYVUMrZm5yQkJwdmYyUDJ3SUVUQnc3TWR2enpUUjNkd2xPVHluaDRramZMWWl1WTRzU0JpcE1BQXFjTjBMLzJCTGNBL01zaFJqWFJ5Y1FZeE5mcHNZb2RUeWREV084ZVRrUXFpV201bG9tcTRXUVAzZW1vTkh1cFZvNEN2dHBuUjJLYXk0TUVGeWxxRTlFaDlFTDAxZEswR281RE5odURxTjNzWUpiYWhmRXRhc2RRUUk4ekZwNVZFTVRsTHFBY1FrY1RQYVRuS1E3Y084cWJmN1VGNFYxRUZ0amwyamd2dlBLVkFoOFhaT0UzQmZpVFNacGRoZDZibGh1R0gva25HR1p1V1d3bkJQSCtwS0R3TjkzRUswS1M1eCtDdEE5MUwzMXZuSEd3VFcxNlRDN0ZsWERuV1ljMzY4dytqTHZ0YnVLeW5CUCtyR3dPcWdoVUQwWUt6N1hYMENYaGRuWXVBMVFydC9UYW9HZmJBeDF2SlpNQkRGb3ZuUEc3ZFY3alZ6UmVkNU5OVFRuTElXSjl1YVdMbDNMdE0rajdjSHR6RTlCN3h1MktSbDN1em5yVVR3R2ZsM0IzYy9kemJ3RkpxZU5mejB1b1V4TWJSRjJTSkRMYUp6c3UrR1FMSHRFK3NwL1FrdzZzTUpXSzBVOU93L0YyMGxDQTB0a3d4a095WFFlU0J2MnRXYW8xOFVnUUdOZjFoaFZLRVFzUHh3aWI5bzdUUU1pZnBSV0ZEOHhKUGpYdDgrdHFxNlhxZmw5YTlVbHpBVjVSMG9UczhyNHg3UTVQUjZ4a0xwZTBJdE5oOTdRczczanlnUUVQNTk4T2lENmxOU2Z6WXNDbEZqUVA3L2Z6SHEyZ3VnSWlMOCsxRko4WUNBYlBJODEwTkJPUG1oN1hnaXd2dUR4bU5KNkpwbVBwVVE5Zk5YamtDS2VpRFFqL01MVEYxZHpEM0c5eGozSGY0LzZaekpJbW5xRnFvdytQa3EzSWpyL3h4bjVTYXRxT3owUHMvamhQVXI0Y3JVYkNWclBSOFlMb0JUYmVTakZhaTNiNTFFT0lBcXcvcmpudUoxYWpDV01HaGt3SlhhRE9rWHBKQ2RIeldtVEZVdEJtT293RzAyblNIZmJkMWlyaXBva1NibzZneC9GQmQxSFlFU0s0N1lvYXJzSnNoOU5iR0gxaDAyUDlvTHMwbVVNYzZ2OGF0N0EwRzNhMzJZUC9RVGwyTS96YlJGTFZ2ZTY0NHBjakhzM0Z5MHFja0xpaUNDN05FNUg5U3R6dDFkVnNKYXU2REU4TUVvVTlQcG5JTWlhU0llTHpoQ0ZSekdQb2Fxb1pUL2lzZ01mMjY3WUlQN2J1dHozQnNDK1I4RVlDbmxKQXQxSFlaazh0WDd4WXF4MUJGOTJSU0RZU0lSOGdpdWlUZFpVbm91RVhOVjcxK2xSZUZmMWVnUmRVbCtRVEZTSUltRVp5cWZESTZ4Zmh0YytyQ3BER0VBbXY2akttNFlVN2pVQWdIZ3plUERxL2dPSGtKOG1Zbnd3UlhZRkhSc0RKajljRzhoTmV3N0pMS2RDTDA0cm1sUVE1RnZabk5aL285ZnE4b2svTkJrSng2TzFlVFU2ckhsNVZlWSthbGpVdjlQWklLSjVVREJFbUhyOW9LSWxZT0NJTG9rOVRNcEJPcVVyU3RLejZYT0ZRelBKRkl2NXdMQngyK1ZScFJoUm5KTTNyQ3NNRFFJM1Bpb1h3dVR4UlBWS3JIcTJ1TXljS0Q0bXkxMjJJcXVDV2VVRTBCTUVRQlY1MkF6SU10MWNXQXdGSnd2Y2E3NFlxT08rSjRvYkt3WHRKQ2dRVzJHeHhsdHN0NGJrTENtWjc4N25RdDVjN2pHZWE3NUNzOHloWlY0TjVmOVUvZEN6ckx6L0xpMC85OExOUDdiQkVCeEYzTDU0TjBmNDYyLzkrOXBkbnZ3OXpHNTZadnBkNnliMkc2VDZRd05JemxGajNSL2REbmVraVorT3dSdE5vSnFZN2puMm9qL1h1Ym5GclI0UmtybmpyRmRtVXJNdGUzaU5wa2hEMlhIZng5Qnc4dlB5Uks2cXpCY3N1Um5KQ09tQW1VdFc5NzkxYlRTVXc4cHVNVXEwTlhNam00czE3Q2dmalBwY01VNC9pTXR3ZW9oUmMxTEZ3ZThNSTZRRXBzR0NHWStsc3NWQ3lZakdyVkRpS2tVMUdkczJCQy9EYy9UajRkV3IvcTFYeFY2ME5zMWwvQWZySVFaQm5zdHcrN3FVd2srTHVEeHNvZG9NQ1RhLzFHckQyOU1Ccm5EN3Axbk82blJ1cXVOQmtKajBONWdBZktUbXFuZkVzWkpzZWo0elpVQ2RpelFhL1g0cjU1dXYyU3dyNzZ6R3JOalVobVc1RGNjbVJXRjZVRGFQOVIzdG5KeU5obnpjaXo5ZVdpeFAwTGh5Wm5OMTdlRTl0cWRpYW5La1ZjNjA5L3BocWVGMktTNHNzMWZhSVBqT2x5VDRwd2l2WmNORWJ0Q0krWDdGb05STUxFNktncHNpSlVEQ2RTc1dqWWY5RXRPVEdtMzJwZERCVVNVU3ZuczVmdUdCNDFWd29rMUlsMmUwcFhuTjFORUY1aTk1ZWt3bks4NHpWNUFWcEM5TVZlL2hMOWZzREc2bk9LMlo1NldWYXlDTTQxNXQyY1dlOCtBNUZ2RlVWL0M3bmVrTnZiS01jK24xNm5vbEZWKzdydFdHSEhwUW5VNmdUd0k2OWRZK1AzRFpNSmJIR0ZtaldFb3FoMzZ3YlQwSUV0YjBRaFhkMEVlZlp2cmpBWHYvM1R2SmVEajNaQWM5VHhuWFlaZTRsYk1kcFQ5SHAyTUVVZDVvdUx6UkNBMXV5UXAxOVdpUDgrSkdmUHdnUW9UaVAreEhidjkrTlNnL2lrZ2gxRTNPU1BqelRlVXJ2dGdmZVJmcml4Zy83Yyt3OHBLbTdQaUlvbnJ2MUl1ZGRMLy81MSt0ekEvWDZsL0gxT2pWUUw4S05yMWo3SDg5Uk05WHg4L3MwNTRJZWxLRTkzZG03VVhSOGxWUG1Oa3YxQVZua1M3b2lYN1lUeVhlRndHeWZaWHBuTVJDOWZLS3paVDdUYnFHV2cyeFJYVWVMemlWYjFHT20wLzlmeTY3L0Y3dDhqMnlpNm44REpRRTgydE5hV3p1enRiVSt3SGl1c0pIUS83ZXFLVnVLVnNGUDhidFQ2MXRiWFArWnNMMTZIc0ExdjEreGx2VysxYzZtNC80NCsySnIrR1ZDandWdFl6M3RsVlpycGIxOVB0VWpYS2R5WjlZeW1iV3Qzcm9ZK3NDSmN6UGNmdTR3dFVBWThIM1QxUlFDN0d6R0g5RDE3M2dTUkNFT2lFU0lmTFptbUUrWWlSWG5nQ2U0ZnY0N3FONCttakJYeFRmUjZDc04vYmdvdG5TZXIvRGtUVFZqU1B2dk50dnJJNVQveDNYam03eEl1Qlo4eFEvdDd6dHd6clVUV1pIenZUTU5uTlVUdW1YS2RJeEwyV0dOWXlodzNXTm1TK1ZXb2RBcTU5TUJqMEQ0Z0tCTGlXeGgwZ3dYUWlHUFM5UkZreWZqS1BMdGh1NHZ0cTVzRmIycVc5Q0VwTWlMNGRsRFZ0eWxhQ0lSNDZMbStKUzVFT2JUanUrNlhkY3ppcnY0N2VOOTdRenRVZHQweldLYXJsa2c4dHVmYzdhWEhLWk81VG9iVFVkd2JOMUY5RU9kalM1OUFUMDNjaEJtOUxmM0d1N04zRy8vK3REYk96MzJEZXptc1lmdWgvT3IvNXJZZUhBUkl4aFk3SUxCVmk5SzFudWZVWmVPTkhpeE9MVFA3YWR2cGh0N016WEh4Y0E1azh6QmU4Yy81SGw1aG54UlBhWWRRUFMwTXlMNUxtS0xiSjlmdjZtSS9PUWs5UkRKLytFZjh1TEpNYjRhOFp5TS93UGsvejhGMm1wM05YWHNmRlY2R0R2dTFVU3RTYmhacE9mTjBJMGhCSStXVXZEVXpjN2hxdFlPZFFyL29GYzIxUTFYVFBVb01WZjdDNG9pWHRUMGVza2xMbEh4cXBKclF4WGFXbkZPK2tId3JrdExkd1ZMdk1LdjhPUVNvTUJYTGk3YVVBMDdtU1NiWVZXUVhxYUlyb0JMVXYrYjZGV1hibzNLK2orcE1WZFlqNmt2azRQdEd3S0h5aCs3SzFpTEJlK004MFM0UjVBdjNnTVpYTG1ucStKd2ZESHpRR09yWElPZTlaZjNkNVZ6MlowVFAyMjlZUS9lZ2xJUE5rUGt1Zkl5ODNGMlFmc0hodTdybk5KazZLVGN2WDNmOTNQLzJDTEpaVUVYQW9Kd1FTY0Z2RzAvMi9zQWJnbjNqLzk0bHZ2ZTk3b3dvazF6bGJ1TmVrTEl6L0k5YjVjRzM3TWRTUEc5Y3o2WCthWURYODlUSnA2VTBKbk9RVXpwcG9WRzdPWmg5Tng2a1o4bjVkcXhlY3BkekIrcnlVbnNIanNmL1lEZU5hOVVKL0g5cEhwbGMvakJISnZvbmoxSEpuMlB2akkybjg2RGo3SEpsdWt4dndhNCtXcDMxeW9YcE9wQjNJRFUyOUFPN2FuZ2R2dVFGYkt0ZWpQMC81dzIvSWJudEI3V1Qzc2dkdHJ2OTU4K2ZmcXBwNTU3aW56aENqbmkvYUhIVWw0dVM2K1FMYzhQamFoMGhhSk1YM0hOc2RyUnI1NjQ0U3RIbjRBMjBhSGN2NGR5UDlHM1QzWVA5ZnArRVhlVTdSK0NNbkVDUzVJZVBHalUxQU1KNExDYmxtSURUSXBkdCt6NXBoV0NnUk5TcW5ZZGdLMDM2L0M0U2RZOStnbVA1NFR1ZVlYdWNXbTMrWHl2ZUlYUGY2dm04dWpmTzNINkR2ZzVjU0oxeXkyM3ZQcXV1OXlycTMrM3Vuby9qZi9vYmxkQXpFdFNYZ3k0N3JiRm9PdE8zUy9OcTJxdHBxcnprbCsvMHhVVXhWc3p0ejVvMjBWWDV0Yk1jL00zMmdjbXltUTZiTjlVcWR4WWFzeS8zSTVQVDVOeXg5NEErY2twcU9VUzFBN1ZZb3kyZDdoZGVpWWFYUk9qTHN2b29oZzFZMEVhRjhyV0doTE9MVmtZK2ttdG1nVnF4RTV0VDlWU21XeFZuVjYwRDloa0ZZTEY2ZmE5WkxXOCtNTDJJbm0wdlZsZTVET0x6MmZLUGpPaEtSbEZ3MjF2NVl4eDZWeUdIc3RoWitZdU5jcUw1ZkxpTmdaZG5oN3QzTHByQzBVcXdLSTlFVHNnMEVSZXdsSTZ2QjhlcTBUMy85VHNyamNaWWVmYWd2SW5QRytValE5TnVhaU9OaEthbWdwRnFNTFdOZlVoZU1IejdkOFpVQjNjSlVpU0xFbGJmd0xFeTREdnVxbDdPWHpJZ0xITEU0VlJvN01jdTM0S1A1T2x6ajRuNVA5OFFJRXJYQXY5NDdCZGVHeFY1Z0xxRmlIVXVXSEhxdTEyTHpBUjMyOTJEMldEcVFnRi9PM0tWWE56VjYxaXNFMnY4Zm5adTJibjQyUGk3NitpbitXdXcyV01rQTEvd2kvQ3YzTjVlNHpGWTZaTDExMlh4ZGxkZk1RZCtTM05aY1hMN1g4b3h5MlhSdU9rUU9PZFBTckF1REdmd1ZkeUp5a2ZYT3UzQjk2eHdGTHJuTzg0NjZoc0ZucG5QVHFyZlBQMHlDdVRLbTlzUFBhcTFEMEFxOEdPRjN2TUo0clhzVFZpdUxUZjlVRzJjc3d1NUFKTjlvWlVZK2J5RTVmUEdLWkIzZnBwc3M5VVBjU09JeUZQMTlKcDNiQnlGcnl0SGE0WjVCQitmUjNMNURxeC9kWVBzcnpaNWJVZWorbzFQVlppOXZLWm1jdG5NUVBxV3pEck5WUmYwQk9PSld6SUoxMS9KL0NwbHVYSDkzam9vbTQ0ODBQTDhVVTlPL0xVZzhIekdMcHVIYW52dlVHV3dzMTRybmFHbkRMMDlpa3M1N2FBb0YyaENZSGJZRnJhNnJlS29jY3cvUGRucUdIVm9xb3VEc0tTUmp2VDNYaE1aVmVJK2huQjZWMUJHalRVZWJ3UE5FNmphM1VQT2Z2YXN0d2tTTVczY1E5d2IwWHYwOUxBR2NtMVVyR3p5YkhaMmVyV2RXMHVVUTFZeVE1VjZ6aUVxQk1tWEM2bkdqUXBSYytzZzNkVW5HRmNFUzQzR2NTaWg1ZVhtaVc3MXk4dFdVbVJacytHenltVWYvMExHNmkvNTlGVXIvMElzNTg3dzZ6eTJxOWpWM0ltSUdsQzhJSkdKUjN6NWhKYXdPdEdiVnNvRlpINUYvNWFTK1M4c1hTbGNVRlFWSEZkWGtiTm9jZHllOWRYcjFxNldBeW5Nd202UVROUlg5VFZ6N0N0bFh0Wk9iNitjOGRZVVJQT0MzWlpqQ3Q2MW5mM3RPSFZ2SjY0VlRkOC9uakFhd2pHa2dlZUdOTjMrN0s2RXBjTVFaVkRobXJVclJ2SzRiaGZWeklUYkd2blJNWmxhWkZ2c1cyZzdWT3NDRWZ2OVZYSHIzQVFWMUlIeDdoZ05lMnYvTEhMOWNlZVNROWNQbXRNZnZqVXFWT1Z2L0xrUEgvbDg3RUw0ZjdpTC80TDExM254elhtUlc0WmVPOGp6aG1nYVBLUVpiNXRjR2VpaFFyTUtxTUhKck4zYUdaVFBIWEhqRzBLSklUUUE3eHN1dGxOVnZJbG02eXJDbHJPa3ZZUGVIb21teXI0ay91Q0laZm43Ym1aMitlUy80dTRONEdQNUtydVJ1dld2aTlkVlYyOXExdXQ3dGF1bHJwYnJkbmwyVDB6dGpYZUdDL1lzajNHWXpBZ0d4dHNiSUpNSEJpQ0NXSXphMEE0QnN5SGswd0lTVmhNTExiOG5Id2tjVjd5Slh5UWdFTDRFZWQ3V1NhRWw1akY3WGZQdlZXOVNab1o4NUs4R1hYVnJWdTNxczY5ZGV2ZWM4NDk1My80OERRYUNFL3ppZkxsbDFlQzFsY1U2eThzNVUzbDdGdHluMUxOdjdCVTlKdWlKcHVxWnNpYU9ESitxR0VhaWxsTXpGMC9OMGZ5SVdDb05ETnp4Vnp6aWxycjNja2dTTDQzeU9XK2x3d1NDUWFSR0hZd0poNW5tR2E0QmxjbkhZeXVRb1Z4Z051Y1g2VFdEYU1IaGwwWTFyUkVtdDNtQlVIaCsyM1QxMU9qbHUrNEErbVVLUWthNTdDSVZjenNvQ1RrQkdra05WQXhmU005YkhsZUxGa1lzRlZPNDMyT1U1M0JZVkpnTkozOVhVMFZORWV6UmczTHhQdzl5K2M0aFZVVWg1OENYbTVhVHVaR3FnT2FKcXFPYXJrcHkzQVZsY3JabktiRlJWSm9TczRNWEV0dzVrS010RExvUTB0RUFnRVdoT3RHU1pzSjNQWkFYMm51cG1GdmliQ3hSMkIxOFZ0bUplQnZFTE94YTREeHVFWmtYK29uOFR5TS9sSVVXMC9SR2Z1WExVbmtEanNlU2ptK0l0bVNJcmFlTmNaU29QY1JsTU9zL3A1UWFpRHhBOGs0NHVGeEpJUG41a3Z4TzloTVRRYllLSDZvS2hNS1RyZGVrQ2h2Ukw4WDJRMVM5RGJQSU1JZ1ZSV3B0WVlUZjdXd3NMSnlabmtaTGJmeWlyUUVweFlVcWNaaGNyZy9JTnNyY040aTVxZ2taYW10U1Zxb3pxK3RMZEk3NGVxMGNFS1dZYURzN01rSk1MMXYxMmtDOUdjdmhsUjI2VncwVlMvbzhUU3VjM3RzUGtqYmMxT0YzTS9WanZCc3BiSlVyUzYxMXM3Ymh2MjZ1QXRwUVM3c28xL0cwa0FWOUZ5MGwwYWJDK2ltVFNoVjZRUmpiZ2EwNDdxSGhaejFuZXc1ZSs0Y2RPNlpxejFjM0JaRjFydjhJT25MNGpjdFN6aHk5VGw3OHlzYzc1SHNEa2xrUlZhVGRtU2VZZm94dVFiUEdUL2xmRkZTQ2xOVGU2ZW10b2lIOGppYzJ6dlZ3U3dEdnFIRWpOUFl0cVZpYzVZS0dtMGhISmJkTjhTcEE0OWtLU2cwYXNUU3NDWkZRQUNzZmYya2hkTCtQQWt1TXc5UXE1UFhkL2ljNjVjV2wxYlB0dklQNzhYYys5NkhUNFF4dlNhdENvMU10WlNwV0pOWVRvRTAzaXlzcnE0dUx1ODF6YjN6MUk2YzZrZldjWi85V0xkT0xZejQxUkc1TzNqbEZNbTROdzVZUndUdlJNaWlRWXZDRGl6MDZkaUMwSDA1UXBKek56K09MdkhaZXhPRklDL2pYMUJZSkZzWi8yaWN1UzFPUFA5OE93VHByUjFXNEd3bnVkaEpyaDhPQ2tnSkNvWGc5R25ZS3FnUUhDWnh4Ylk4c2RJSmpqb1hPUVFJWE90TVYvcHNGRE9WNi9TTmkvQzNsY0U4MnhUUjBqUm5lMEQxZ0p2RU05a1ljZ3FOZXBPaVBFWitWeFVMTlYwaUFJTFBIWHBYbmxmYnlyQ1l3UE41bHZzaFd2eG82OGZYZWhsV1JaSXo3WXc1ZDIvL2duVFJUOGM0aFJ2WVBzRGRsdWQ1OFoyUitrekZsN1JXNytLKzBmcXh5bWE4YS9FbCtJcnA2dll2WENRaGRZd2pseWloalJYNk10RUJ1cGpmSEtJckU5MjlWeW8wQ3FWQ0wyNXFZU09LSFB6OHRIa0c5OVF6WnZycloxcXJ5eG1QTEVYZ3pkTDhQTzZxWjB6ekRPNjY2MmNJWGhQK1pwOURjazhNUHdadFVNTTFOK1NVTmxvK01XMThkZWoxbitnNWFqM1NjNGprQ01pZCtvT2M0NGlKY0NqUk41bXpJWjFNS2RJN05UY3MxS0FxSGE3dXBRTmU2OE4wdjBaM0dYb3luSjhCcitwcDVuRThmdlhVMzkxUU4ybEREdGNPWHhTeDVJczlOVlRQY2RSWCs0V2VJMVR0clQ2TXNjOHhTK2gwVlBmMkE5dm9LazZVbU4ra2ttZnA3bFRZSEUrRzVnbzl2aUhUd0JzaUd1aHJNRFJZNkJMRnVDN29DbXFwQU5IQjRqNkJUYVZSMkVISlM2TnVSaUhiWitNQitwZWhrMnJTemxRelZrcTljVGpXamc0RUxoZnNPenpOVGJtYXA5YVBzM2tPOGNkVEZpNXBKNC96aUxPd29IczhQSDhjTUF2VHVjc1VYN1Z0MVZlT0ZxeDQ2OGVrMjR0QjZ4K0lBTWVoMXppU1lVaU9QTEtYWmZmaUsvYlMwbnZ4aldMNGhoZlIweGZoNS9Ub2ZsdzhUbXdIUFZ3VDFHelI0RW1hWUxBU1JESG1vV0hhZys1NWdaTy91RHN1bVNyQVdNUjNDM0V2L2hLV00yVXJaY21tTU9lUUU4NmRXL3BDUGpucUNEcklyYnJnalBLMkhTQk9BUTVYNFN2NjlaQi92Zjc0dWZ4THUveG94amJLMUpMZjljWXd6KzgwZ3VoOTljWXg5SW9uRlUvSDdhOTd5c25pYStEVnBPM2szYjJ1THRXUjdDVnkyTzZYWmtaYTYxKzQzbGRzVy9Hdi8wSmtkNFR3bUFiNjFqeitadW5ZSlZIRlM2M05CWE9CVkpGQXZZbCthSnFyZU9CNmdUSEJRd3lSQmV2Vm9kWGJWcmN0dm02MStSdjQxS29KWjRmeGFicnd2WWhQL2hoT1V0L0g3NkpkK0hsSHdDTitrbGlmUURqNFdlcjVVbTYyazNUWk1CUjlRQmZabm1uRmpuSTdRcU5CT3lXazhFRzhlc1Ira0plUWdPLzdIcFo5TkV6K3FuMWtKdVlKTXBLUklLUVNGOS9wRFFEVkFjc1JzSkc4Tnp0M05Kc1ZCQzBuQ0Vob2pBdVliQ1h0QzN4U1VDWWFQTDRvSytKTHI5cEhzYUo5c3RzL01pWWhJdWZpZWVGZmNSdStnL0hKMjhTejFTN1VoazBKTWNVRkFnb2JObWNSVmlKZ2VrQS9XeFNzMWtNRUtlVUJTMWprV3p6T1FNUTBvUFVRWktERVRZSW9IeVpQUEN5THdrMmMrdFVOT1pTR3M3aFByVEJaNGtIV2RnSnUwOUVsZlF0dEg0NDJQVjM2TnZTemsvaHpkSG0rMXJxVkVQYWhHbzhQVmU0a3BpNDZoVDVFU0x5MWZRb2xUdElrQmR5cjBuSzQrRmUzeUdkQys1M24wT2REdnZTYzlqdnROWXhLUUVObTBrNHl1Tlhxc1o0Y1RPSy80eUtTK0ZIY0RTQ08wcXdvYmVtVzUwRHA1RmRPUXdDbDB5SlpNT3VNUDlUWEU3d1p6ek9vYkUzbDJwWmp5WnUzb0hScHF3SGsyR2EwdnZBOG5pZjJvYThTZWF2QzFNRHJ1cGVFdG5HZUE0RGJuQmhxOVN1Q2krY0tOMDdxOWVNT0ViSXdLOGlYVTlxVVFrRTVLNHVwR0ZxUHBVVDUrWi8rQUlzWFAyQjVybFhuK0g5YkFqcVdCRm4rSENVTXZjVFdOTHUxYUJlQ29HQmI2RmM0cm5VWEo0cVJuZU1hODY5aHZLd3E2TC94REJYeXZCWGNxRzViZDBaUUV1T0IyUGFDcnBDcS9BWTRQZ3Y3eVhhUzZya09YNThxSWgwWmVhSUJ5eHM0WFVRcmtyZ09oSzJMVW11ZDZxYlFRaW0xN2xtRkNhcTNtaWhZM25xcVJQMkVPdlpaWUZmUkY0S0pURGlDRkhyajBOQW9iU2NBdEFibVZhL0FIVHZndUR0Q2k2dlcyVmQwV1dqZHdYRUJyNkxUWFFjY1BmK3RPN3BNdE9nOWlPeE83Y1Yyd0ZzTVdXTm9JVXlNRkhvQ3dVYzlnSm9WTXRoUUFvRWhwcUNFNUlJcDlMUFh6d3FXSkFEczlPeDk5elVvb3JRbHpMNys5UTF4cy95MVRjdUlqZDVyTy9jTU1UQm8yOTBTeGVNS0J4eE1peFEwWjdyUjI2Z0VJNUV6dlptRTk2K1FNNzJacEYrUU8xWEN5SWpSS3ZodTlMYTNvZDFDQk5pZEVTUVdjbGlTdkpBeWQvK2MxL1dYMmN5ZXJyY0tmdHRjb3RzZmtJcVJRYkhQRUkwSWlZMGU1RkI2b3NkNkRDMzJXSW05cDhzRWpaamFkWjM3eDI3VHNyZDNGL3pmVzkrRDZSbi8ydlZ5R2hkYUwvZm5yRmYrSFBYNis1NXpTTit5WW4wbCsyckdodkluNkNaMjBGN2JKM2QyRCttVW40NDN5WERVeHV5T0lONDd3L3FWK0V2QjBuWVlJQnBHNjRSZzNRM2ZUN1YxbGxwbEluc2FmenQvOHAxb1dMZUVSRFNtczJzQ0xpLytIMHVZeHRJeXNmVkVkcldEQWMvMXpFV044Ni9EY0JTUVBuTFFqT2p0RmtWVG5UbUlueU9FcmxBNlY0RE1jNW5WQUZEOTlBb2xjNlZOWlMrTnV5Nk1SaUk5Tjl0MFNwM09jZzVhNFYxdWY1U2lzRDhhZnBYbnBwZCt4STlTQVBsSHQ0ZGZjZFFYUUU4MXdCeWdZMzg0NUlRd05FM1VQU1JaQUlMYTAxM0E5Ykt2dTVUWmVVVXNpRExMdHY0UGZTQ0tzeGVMaWl3K0pzcnY2Ynh5TkJsMm1lKzNPd1Q2REM2aWlCZkRsYVIyK0VwV3hqZFQ1Ty9oa210UkcwRFBpYXI3SFZtTTZnSHJCME1FODZvSGJ3TVFUZkVJV3VzR1lRR2V1ZGhvQnVqdjA4ZlNOeVFvOEh6d0dTbWZtRHVvU3ArSk1tNUlzYTIzN2Z6MFR2VHhkUHFHZ0FMUkp6NGpxUWZuRW5ucE0xSEdEYW1qclRmalV1RTZEZkdmNC9Gc1dvYzJMVTJ5eldBUTFsN0FtdDRMa1NVckpSTWMza0hRS1ZkQzBNa0JGSzUzZUlET1NsZnpwK09pRkdCYW5lRmRLZldoWTI4c0ZacnArYklralIwNWVvM241WkdUdkhpaXlyRzh6NnRzNjdOaFltNTg4cHFqUjhhazZ1QmQrKzNDWkNId2h0TWorNjdoWjQ1VW5qNnllMjZvTW5xUmx0SXVIaHRuSjVmRzl2b0hlQVhMc3JpYmZDdE1YS2FQajEyc3BZeHRoMFY3c2xBSXhtNGVLTWUyTTB3WUl3ZVBIZmRobVhRYWNFMklLQjVXaXhyWEM0UEVzNVN3TVkzcEx2WWxCOUZOMkcyWThzOEFjVktVYUszamFvV1UyaVNvZTJaMFgxQjY0emN4Z1lRT0xVcTg5OGp1aUtUY0lBM2NQbG1LN1NqdlBoS05FUytRZWFpQzVlVUpoZ25WajNFU2J3NXZjWmNGL1hVajNKSlJHUG90OHFlUVg5SHhLUG1ra293OWdYK3hwUElFL2owWjRtNys0Y3JDaWlSODVOZGtObVk4OEY3WW9ua2p4c3FQdkFGdmxWLzdhQVQ0aVhiOTVBMXYrTWtiTnFPRlRnVUF1VXUzK0xtZ0dmZkRMZm5xWVl4QWpRSFVDQkNnUUg1UlRjWStyUUl4NnFjN3hMU2FtQml3Qk93bXA3WFdKa2QrN0tNUjhHVHJxejk1NEJkKzhnQzBqVUwwK1V4Zm5PSjdtRjlnM2tUaUpiYXRiOGs0MWFlRERmcnNIdjIrNDM0N3lmN3piZ01ZeGFpMW85R3dSRFhFZmhFVkdvVUZPMTBxcFdHakVlVSsyYXoyVy9GdEdXQitXYS9xemxOT2dJY1J4c3ZFV3Q4N1k2cUpkY1M4Z0JrMHRGaEt0OWJoOWlpZkxoRkRacGhtOGZheFRZSVQzN3BKSGlxUE92Z0JnZE9pMFJMelZ2SkVRalVYVzJmWDJ6dzlxcE14ZEpoODhaVnlhSnNEQytMNEM4OTFhY1B4dDhCMWVQenU4RVdnbWNJU1BVUWxJMmJCRTFWUlQrNjRmRWRTRjZ1aVVmRExxWHlxSEMvbzc0N25jdU81M011cXhJU29LbVBaRWltQ25Faklnb0t3Z0huM3c1YVdLWS9zMkRGU3ptalcyL3hLTWc4UU1mbGtCVlhod3ZGY2EyMkJMQmNaOHRzRUVmOFQzaVlia2U4djJKOVBoYjVSVW9YRzhKWEFjNlE1Uy8zdXlRY051cGdjY2FvRkQxYnFsQytod1VrV25HZkFHWkxFWmdNM1ZxTEprY1MyTHBTOVk5ZkVkVmlBSCtUNTFxK2JnN3FabU5xYlNHZnJKMjRmUzJSNWN5Y2U0UElqaGJkd2x0aTZLbHNmaWNjOVhNZ0tjS0cvbjdoaVpJZGdKZ3pQVDZBYTFUK2lSWHczMGVKYVQ1aDZ3UXIyVGdXWmcrWDZOYldVbVJVS0kvbG1vYlRUZkRNbkRHSjJ2YlVTSDI1c3IvdFJ3V2NuTHhkMmpGaEp6WkhWdzFUekdXRW1QSWpuOEdtSUE0K21VREdNSCtKRG5BZkpsL3pBRDJwTldBY2xkdmJOMmg1MnR1TlVaTEZGcWRqQXYwcWpodjlYQVAwVS8yL1dBbndZMUlqaU1ZajcwOFJvaDVYdkdOVU80VjdyZnNCT0hpbkpjdWxJMHY2QW13bWNROXJvSGVhUW5USXN5MGhacGZoU0pibFlIWjRiVUdSWTc1S1ZnYm5oNm1LeXNsUnliWUhqQk50Rm11NmNRSXFoNU9menBkM29YclM3aEZQNEdKMXdkRTRXWmNPY05BMVpsRzQyN0h0UEgxYWF0aXdOU3JMZFZBNmZ2dGZHSi9ERXl1R1JueGZER0Y3RTFnREdpbWs4aSszcWxXMUkvTlErMXJZM3pqQ29XU3ArelhYSWFrL1JBYmIyY2ZpYzhFYVBFdEp0a1pydUc1NTVwYmw4akQrbG1xdFBaMEtSUTdva0ZEZnc1c25XWnlPbEh5NjU4MWpyRE1xYjZxbldJbngvYWh0enlTRW9uQ1hNQVV4Z3VzSEQ0RmpieDZCcjZLa0VSYmZnVU9CZnFBSEU3NEJZSndIK1FkU0hnQ3pURlgxSmhNQ0VuZVVGZkFyZGRhV0p5UTFWaTh2SGppMjAxaGZ5VlV6TFNwNzhtOC9uV1NRSzhid3JETXdNQ0RYRGRkT3VHOHZuMFExWG11M3c4OGM4VW9kVjI4WlZYZ2l2eS8reUlPVHpOeVVxNVdUSmp0djQ3eE41WXJmY1U3OHMvanAzYlZZcjNPODRoMWJJcVlENDIxNXB3eEswSDBBSGhRQ3J1T2ROb3Q1cTFJODlzd28xc0lRaDJ1QkRnalVpU2FxUzFEeFBTeXA5cE52SFdpZlI2aWtJVEhvTWMzQkRrakRIeTBPWUM3NUc4aVExSld2K2RsK1RrMTA0YUpUdW1mTlN2V21FOXMxSVRXOFNsbjFMSXIrOFNUQjJjUU50ZXdFWC9OejBFYTZ4Ri9obHR0eWtSaWN3WkJQOVRJUjhNNEFrR2g2ek9RM0xkSnZWNGd1RkFvczRoNU80YlJ6K2szQVNYWjdnUmRSRVBCZnVyd3p6MmE2eVcxZjFOZGtzSzRNbDlpd3JzN01jVHNsdkF0L2NKL0hOd3YzMU5KdnRLdG5WeDc0Y3RzY1lyRXFlNTIxMXhhNFBKQWliRU9sWE42M3NHM3BDMUxlRHpJdEpjZXZxL0tBN05yMGJYWU12Y2JweDlpS2FENXlYNGlMd3FoVWE4WUpJaHdRN2tjUUtvd0Yvd2NOOXRyd3AvY2V5RXVjcGltRHlVbGFTK01sSlhzSUp6cFZaVlRBNW1xY1ZlV25yMnB3VmgrS3VsaEYxOGRKTDhXWXdKdnBhQ282Y1hhSyt5VHVZSUtnOTUza0hJZGZXN05OeGJscUYzeFlsWVZDUVFNRTZLVXJIcURmNDF2VCs5QlRvRDA4SnNuekdnWkxCSmpRQ3Z1RjVhQ3poYWJBdGpyVlhRamNsOEFWbUhWU0RKeXE4eWxlcWRBMXdhL3FxeXdtT096SE04WlV6YmY4SFlsdUZaZkExWm52WEtObWxpS0ZRbkdUdUhndnhiNHZoTk9BVThKamZxUUxtd2o5RGFTU09lbmNXZUkrZmNWNENxMXZiYUhvS2FNWjBSSk1CSlhXZDhLNFhLY290ZzZabmt2MDZvWGV4VTRkam5mNzdJSWtKM3lDeHk1bm14bUE1ZmI0Wlk0REp0OFY4QmtYWGlVMENNVVNZNjBxK2ErTzBCY1Ivczc4Y1NmNytKak1WcnNGbTM5ekVlWHRvbjVKejAvZE9BZ1dTQ0lSYnYrM1RuVUJHVE9nVDJrWEhMdnoxSDJVdVo2NC9MejFscVZ4cFFQZ1RrV0JGRVlRb3NoTGNoQ0FQZFFrbndleS9PZU5KWlh6VUJNL3htbGdVZ2FmUGJUNXhsbzFhVWxjRk51YXhvdUhaa3dKU2ZjT082ZVdZT1JCbzMrQURYc0VjMk9VQ3h3ZTZvY2ZzOUwySTVTVFZ0R1BucU8rS0lWbDVOR3dhaXFTNDFjbE1JaTVackdibWVJT1RGZE05ckh1Y3FVamkycUNrNU4vcUZRT0QweEJpV1JGeHdpYnY2YUx6dG92ZkgwMTFZNnlBVFN1UE9idGo1SzBjZzdmVFRtNWRzU2MybElYa0ptUExERm5KT3pmVm5ZQjFZcVhvbTRpSW8rSFg3VzlLN3pjbDRVQ21XSWlWSkNUeFNVR2FEalREMEJKYjA3c1RzNnFsN0lTcElERGl2TjRLelByUDA3NVMvNkpLSHlwMXNNVzhPUWNlV0xPem1NZHhPTmh6ZmNkYkUzN041aGUwajN1eGFtazltdWV2UjUvNmVsZGJ0N29aOVRzYXVueEsxc21tSVhuZTF0VCtlYjBVbHRQbFVsMld0U1ZOM3RqT3g4OC8zaERiZ2VuUVNCR24vU2dORVZ2Q0JjRkdWN3E4K1ppMEgwL2xxb29TbUprM2NGTFhQWnh5QkprdDRIMFM4MU9ZZDRyaExwUVFSRlRFTDNicm1qMGo4TlBUNGlsZUVQamFsSGliSUNqaWFUZzRyTWl4UTVBNExTb2RQVUtucnVlcDZhWlViMDBGR1RORHU0c21jNGg1Q1hNYjh6cm1MY3o3bUUrQ2Rxcjk1UmU2eG9CUUs5UWVBd3Bkb3dIVlZ2V3RiVFhPY3l6MGE1WmU1UFhvV1ptb1pGcHJaQ2ZEWkV4eklQSk9tTk42MVdZcW9zNEdKU1NCUkhuQ20xUG5LYnJzUWNxalcrcXMwWnVERm5EamZxTjl6ZHdtcWVmSXhDYTNrMXNXQkQzZGx1L285LzdiMzlLVzUvLy9lV3Y1cnFqRTdjMm0yc0QvaXZlM0tFaWhKL0xpaGJ4STRFTi9uMkJidWdSZnZEQkl3ZHJ4V0EvYWFOQ2xTWDZsVVNtQVBaT2ZOaDkxNTYxUzhsRXovZlY1ekd5aHRVekZldlNKd0puUytKVDdONCtDSWVUWjZ0b1pHc2VPWWlnQXYwZ3dNRURPOUl1emt6U0lIMlZvS0tZamJuMmYrbXEyVWJnYk5lSzRTVmNqSThVRzZEMW9DS2dtT0dnK3RxSm8yd1U5VzhxcFVqRVJNM2c1NW5LR1pYcEczaG9ZTWRVVjFSd1pHTmFVRmMxeFduOUwzVjJ1V1FRL3djZVhsdENuRThqVVl3VS9LTWFVakRlb3VKS3M1RTJEWjlOeW8vQWY4T3FmSzlUbHRHNmlCR3RxcHpTelFiMXdIbC8vcnBmTlhPZG0ycGd4bERjZUJSMk9XNmZZZUpHN2gwaDZWem5TUnBMbGhkQnBoQXRSVFNPYmRKTFpCRmNtZXFtSnZ1bjQ0b0NBdWFlNHhrdFlya25wNWZINmlWTW42cGFSdFBKRjNVOVU5bFlNclg2NHJncDJJT21LNnVsTjNkUDB5bDcwdUdheWFuV3lWUGFIWE1VZ25tc3ZOMDA1ZmVWVS9VUWQvNDJYYzFrbmwzZXlyWmZobThTbm5UbHdhb3Y1UnFyaUQyRVJ5bXBZaVVSMkVKK0xmT3JuU1V6Q0d2RzFQWW9sZ05wR2pyL2ZiYnQvWFJHMWNURlF3U2tRaTJrSGdGNmYzc0RaUXhJZDdYYVAyemxLc0xFUkZnaFFmcEU2MHE5dUVCOUlFakdiclRBU2U5NVBzRHhhQkN4dk5iVFgvQW9qTWhiak16bG1DTC9CYVR5YXZaSjVHTDlIM0IrbHhteFFua0xFWGFuaXp3YU5NbGhxRXZja3pHNDNSS2trU2o1K2Z3M0FOcHl0K0hHY0J6cGxFQjhpTng4d2lKUEVLTUJCd3lHdm5MeGlLVnhDZzBXMmdKYWZSRkZ4WWxJSHBRajZ4cW8zckJkK3p4MTBWVGRqclZRSzVUS2tZMWxySlQ5Y0xLRlRwV0ptWEIvMktxOHVEeFpQMlFPZXJ1N2FsMHpabVVDTFdjTUR5VHlSOHpRajV6c3BGbkdWa2VqYytKWHBRam5ueFkyYUdmZXkyYVFiSEM1MEhhSExEbktHZE1CUGNwcXdseE1WTG5XQWwvYXA3NHdPTDlmNGc3ejJibE04SkRpL2ZFQXl1SVBjMi9hcHdrSHg0NUtTZE03cXZqUXNjb3JFOGJKb1hVRVdNeDZSNG9hZlFTamhhS3BGejltR3JCRXNlMVV4bnRXTUtCbXVrOEw3YVJBVTVFNXIwb2lRQktxMERjUXkyK3hxVFJxWEFTd1czZTUyRmZIN0pNWGE3WW9XckpnV1pPeFVjcVRDSVRibCtEbURydXJra3dQRDBibDl1MVRkRzdBdnV0Sk5ack5lM0t3WmNhOXdPT2c2eXBVTGFiVEVjNUxDaVphcU9RbUVNcjRSbDFvdmgxcGZZWWt5UFRjcytmcFpKNmxJbVJjWVExRkpYUTN0MlNpcHdkb0c0SjQ5aGI2R3gyTWlzNVlxbThUMmxTS1RNTURZd1l3aDhXRWdLekcvYzQvWG5uUzhlMHk1a2tZejZZcDhwUFVucGk3ZGd5ZWhleVI5NHNsUGRpVFVUejRaMUFlTHRYSkMrNUptZnZLVEp0NGxRcnZYZlhodUQ0aVBmZVJiVWVsQ3VzZVBuVVNsR2cyc1ZnRCtsYUJwTkF1c1hjMTRxL1AwODF2UjQ5S0NJcVphM3B2bmZ3Ti9nczhhY1hFUGp4NXVuYjRFM2I5ZTlUTHpWTE91YTh0V01WaWF4NSsxcnAzNkIxeHlmWm1NclNHUDRRQytBQ3AyRTBEd0g5cDYvQ0NFakVMUHJJV1A3Z0tqZi9QOG53Q0svdng4cE1iSG05Wlo2cTZLSC9rWEFMcEhiY3Mrano2RzY0dkZwaEpIbHBPNHZzV0RNZFNzQlgxNXhSTHVTdE13TktCM1A4d3Bzd3IzY0JKYTkxN1lEQlEvV3N5MWoxby9hb29jeS9HekRucUxMTGZ1a3dSU0VtOU9udXlrMy9jaDE5WjAvVU9NOE1KUFh2ZzYrbmYwSkg0UE9md21KcG5YazdncWxXS1p1bExqcm94Zk81MUN3ZGk4RXBUeG1BU0wyb0hJVVpmRENnMVQxREV4cVBTaDMzYWJHbXlXNm9ybmh2Nld3N1BTdm4zTFZ4L1haUi9TKzNGNlFaZGJSeURNNWUyVFNOaDk0aFBXL2ZoMzllUVlaSDFGWjlsc2tPRkVUbVBaVER4S1pGaFd3MG04bDlqZUVsbTJ1d1NieFNYUUw1b2VIK1BGbHl6Y2ZleFN3K1VSVGwrOWNNK3gxcDhpYm16eWRuVHBidlBqMXp5QWZ3aGZBMW1zaG0rYmpVY1BDYklzZm9qRVp2cnZmWTRTSENPKzhOTVgvaFR6UlovSE05NTI1b293a2pUK0VzQjNyRExKRm1HRmtjN3pPeERCU0c3T2doVjRqYjZUR3NDUU51dWtmeENNMXFCaXN2Q0o0bDQxaFlxVG9LQW44T0dCQzhOVHJWR3MxTm8rSUdqOUFmdXRrb3owQTdmdG1HL1c5MG15YVE0SWNtTjAyTmZUcnM4aWxSdFRwZnFRRzBpcUxQTEkvYlltMnJabkRxZUdkRFhQYXdwaXhSdW5mVnNRWjBjbTZydGZGcDhjZFFlVVc1ZkUxMEkwU0hDRVdENFdRNXE0N2JwNkxudlRYR09tV2hGOVgzYjlyQjJJMDBQVEFzc2hTZEJ0ZFdpYjRhYk1OTXNkdm9jYnJDWXVsMjF1YXVEaTB2aGxRZkxndHRiZkMyemNHY3dQdHgxTHlGb0Y4U1hNa1lncmdBbTJTREE1cGxEa2loZCtQSmdmcUlVZzA3ako0cEEvaFRyb0Q3aUJCaVZ3TE1PakhRemRRZWVNMHpHSGFCc2dyUXFBSGJKQ29tak1MY3pONHg5bStGWXVRNjgzdFV0Qzlld0hyalhHYThIZVN4TzUxeXRTYXZ3Z3pmM1pZcmlLRDU2R3Q5MWg2TDluMk9DQzVqMEQ2NWZ3ODB0bzl2YzRqbE4ydHI1TnRiZUw4WlR4aGwzdUlKdDZMYzJZRDMwZEY3djhLdm0yWFlXSlI2ODhqRi9OTG5PSzJYcEZhZ1NsRFRuL3p4cTFvMWpUOUsrOUQwM1NJK1hMY1BTL1Z6c0dGQjlUYzhyN2Z2YUd4TWFzYUIydTQwYzRnZm0xNCtmMkpaU21aenBXTUNFKzI4YThnS2dpYzlCMTQyQ2xzb1hySVdmcWltbTZoZ1F4WU4vWGZmRGV6TUpDUnRaVGlqdFRpeWtwWXd2dnhOT1M0WnFtb3Bza0pIUFB3UitWMCtteW51RDFwT01rZFQ2Qis5d0wvMEhxK25rc3YyUndLNCtTYUtwNGxDUmZLQnZrV0dBSVdEeCs3U0ZDUndXbkdzMTRKZkNsS1RUcjRqR3pPY0JXOEtpT0IwWDBmZWZRSW1iRTUxK1M5ZHVweGZwNDhsQUYrWUt1SHBxZjJ2WEZxZmxEYXRsc2xGRGxVSktQajEwMkhtZDNJS04yNmFqdTMvTGdmTGgvazdqeldMdzBOYXArdXhHZk9wTHl2TlNScVhpajN2cTJXTjlUaWg5ZHJ1N2FWVVZ1K0s0SVB2eWRvYmZVSlIzNzNIUHJPTHQ4eU1KRXN4QytWZEFTMTRpZEUzbS9JWm84dUc4VVlVZVIzaENEZVdYaVNsZ0Z6cm1kUEV1WFVJN1RuZFZhSi9qaUJ6SzJ4MS9KZTNibUFCd1dDV1JKdGJnN01abllIUjQ4cytGV2tOeEZGMjhXNkc2WkFKRGJpc3R6bmtMUnlLc0UyZ1NjN0VraThrbCtpdGdBVFRPekJMc08vRThxQUNZZVRWNjRGd1pTZjVpcVFJeTNnd05PNDhObXBVbGRZWUptZ0g0WXFCbGpsaGZVaEZreFQ1a21IS3JiN0lwNWgybVd6R0c4czdlcGdxaW1qSkx4Y3JOMVZlbU8waWNENjI0cnVDM2gzTzBFeUVxb0FqOXJaTlRBeEpjUDQrdEZBVitQcnh2RzErTmRCVitQVHljTmZIbWw5Uy80K2xGeS9ha0FYNStBZWtrdlBJL3J0Uy9FV1FBL25oejFUc1FNRks1SlFBeFd3VTVSQ2pDcmd4bU5TazBxQnJVQTcvQUx4UUw0cWdSUlJwREg2UnptZFlTVGZITFAvdm83cjYxL1plZTIrbjZ2dnQvNXlrMEwrK3RvVFhpUEpMVStqVm1lcXlUcFBVSjFFZjVWVjFmLzdZcFZ5bE9oUEZwZ1pDejFNRzByL3A0UllTVUVSQ2RZUDVmQ0J1VXBsbUkxUEw2MEl4ZUNUOUk0bHZMM1kva1hPUFVpRE9wRWpLSHVRTjJSMi8ydU1FbEV6QTluUWVqcEJPY1czSXd4TlZ3RHo0aU5tdDhrWHZ5TkducDJwMWNmeWlYajZYUThtUnVxZXp1SmFvWUtlS0NVK1U2UTFSUWRwTnlyWDY4cldqWmdyOFlIemVYVnp6Mjd1dnorenlFN2tSK3FPMWE1YkRuMW9YekNWSmRWazBBd0xwQ2tPMWdRQk9pbWdsQVk1SENpdGJwUVhYaG1HZi9JV2gzNGJIQjRYa3ZpTVlZQlRTem1lQU9YQk1zS3BWc2kvamFsQ3ZxWnBLaXR2S3BJMzc5RHQybUFkbHUvNDUyZitoVDZ1T3k2Y3F2MVJWc0hSayszdi9oUGEydEVEbzNHNmhpVHdEMml5SXhnVHE5T29zYjMrdGtFeFRMWUpoWm5LN1c0VUc3V3dNcFZBcDVEeEdjQVdUaW9pRkp4TitKcWNUeFdCN1BOV204UXJEdXYxQlBEdXdkdjRQa2JNQjA4ZndmUHkyWStiejVDY243Vnl1ZXRWeVQwSzJPN0Y2N1Vrc083djVQVWNMcmJFV2QxMjZReCs5aHcrSzk2MGZqNFJjczRjUUlTdDAxdUc1cHQvVHVVMkFmSkVNZHVEYTNpL3I2SHVaUzVqam5GM0VOaTlMTEFPVVhBRi9GZS9ocUd1aG9kK2JxNTdCRHlhamNaekFDMnZraGo4QVVlY1V2RHN4RzBUUGVCMUgyQVZwczNMQzF1UjJod29CQmdVWXZJUG9WQVZKUTFXUldEQWpuR1FsaFF5QTArTTNaa3JKajcwa0J4N01oMXJxblp2QkZvZ3FvdmRLWG51OUpuNTI2Y1kyZHZtSnRZeUcwUENnSkg5WFZCZ1JYemVaRXRCUFNZRXdyQmpzeWwveE1peSt5THgvZFZjT0lkcHF1cnZCb1l2SjN1Skk5MmtreTBUa3l3QUQzaTF3U3hGN2hTdWUzTTNIUm55NXdFRmsyVmNuTzZvNG5wMHNuTUJrSU9zYTh6UllON3NQWDYzR1FwamFaaUEvSmZjdndmemZKcTY4OGdHdmhoR0swUDA2MG1vNU95aEg0UFMrZGk2NGNYQytYY2I2ZktubzErWHpSYW4xMVNORUdtQXp6WnBpVVY3V1BOVUdaOEVQMFNzV2M2QkpST0V4ZzJVT1BCT2lVVzEwT2I4UVl4VklOeDJTT211QlNQZ1NqSmlOS0VDaDhWRVlTUEFjVGUrRUkrLzRJVmkxa09Rb1RCNHZrcXo5c0FCSUZxK3RIbXc4MmoraTM0L0NQYWljYllXTU5RWDJYbjdWYzlFSXUxV3ZpSHhpOVQxY3Y0WkM3Smk3TEtXekdMdngrV011N0hTWk5YN2N2SDRwWVZIK011RzRBeVh6TThXYkgzRFFyQ29DNktsMXlDZnh0cytqZkJrOXhnTDc5SlFNdjIxQjFPNGx0YXpkZEpaMXpweU9nMGVVNnorU0VpOFY5L2ZWdjRKOGxRUDRrM3Q2S2JNQy8rU3N5RDl0RFQ2TU00QU9QQnpmTDZuWU1hWUZRWXgyOExYbkFZV0dxRHBJemI1Y09TY0FkUWswN0RsaVlmNlVyM1phUDdzZ0szbjBNOExQemxpSmI2NDBSZkxWM2t3eDV2ZmtDMlpIUDk5WjEwYnpaS2NjUlJtZU55WCsrSTFZZ0wvUWp3NXVYb1ZxYktQSUJIbzY2NlJkRHh4RWl5VEFROGtGc0ltbnc4UWk4VC9qTWI4TS9lRHJSOUVVL3B5TlFDSTVQWDNFdzhIN0JnSnNaeXNsNjRibnZHR2MxcXNkYlRMNjRsajVNYWk3d201NUtlcDNseDNSMU81bm5FV3ZqZWhqN1FHS25rWTFsWGN3b3ZxbUhiL2VsMjNKK21tUHNKY2dDTXN0UmJIZFJxWUwxSFpOenlIcmJYUmN6Q1ROdC9adXV4cC9aTVplc3VCUG5qVlg2Z21DaVlzVUZINWlST3VFaDlOUkQ5YVVGaWo1V25XdlVYMTNnUGplK0t4emlGQzNqRVpiSmpwaTFia25oTVEyRlh3cnpyQ1duNjloZlpjRndiU3dQOEtiZWRDMmVIc0xWZGc4WXN0Wm15a0Y4Z3VKcExHNUd1TVcrUlZGN3FCQitCQWZ4cTNXTloxMW9kelYrTjdvbkgza2NDQVBWajY1eVE1U01tVVR0YVdMWktIVncwNzFOeVRHUlhQSTk1dWl5TWRJQ21VeXhFbjdaRUdSNWlOb3RmRmF6eUVyaE5vdHVtdElaT3JLRXZNNEc4WmlmZXJlWmpyVzhGaGFuQzEySjNEZFVMd1VNOGYzSzl1dXlZdHhqR1E1d1FPSGRaQ1RFaHhkMy9aYmdDaDhxRzlDNzlWNzluTzRWQUxreFY2ME40T2kwZmZtQm9LV0VsaEFxdW9oTTQ1bnhzd0RWa1R0QytGL01qdmVrYStqcm1xQ0hlSmZoT1NDQ3dFa2VHTW8wY0V3OHBKRXN5dUVNV3dkSTBYR1dhN1daRXpuWGdvM3NTRmMrWW10TDhjc0lxbUhIWmZwM3FmRWQzdUp3d3lmTHBQM3FOcEhoU1dvckhYRVdTUkRVV1UwVkpVdUJJbEJRM2hpN1Q0b09Xa0xCamdXQU4rcitBeFFpN0dmK1VZV3EvR0E4ZXlvMzhUOGQ1M2FOWVFsTExpcVQvaWE2bytnZmcxWDBKVWs5QzZrT1EraUNramhtS29rUGRmeEt1dFJXSkxmZ2tRY0hCcndwaVlrRzk0ZGMySXlDNjhjQ0RvWnQrcUxNVTk2aE1RSVBQM1FBTlV2K1hxMFZ2Yk9lWTRtcHpjd2x0TG1HWlRXVWc5c2RCU1VpenlXRUhwWkVxL2JFbU5Ibk1IdkFjT3krNkdYRUhyK21pbWt6MnRRVmpPOXlKZ2JHeGdSc3V5eWJpYzlsM3V0WGt6WFlzRzd4T2tnL2labm83eStLVWNyTms4bkZPRlQ1aCs2ejFZY3hjLzY1dEdQYnZRaHRrZE53R0dVaEJJclJOK0RMbTFlZVkyNW03R0NhZzZ3UHhXYm9zUUpjUmRxRnVuVHBBUFV2VEZJeU9NUFF6c0NqWGhFNU1mSWFBSytsTURVMkNTMGYrdzdCVU1SSDhBY1o3QklEMHBjRnBYYlVMNW5CTkZuU1o0MlZILzRIdXlKcmhtcEtWMFdKVFE3bzJQV2o2c21YSWhobFRaRVd3WERrV2R4U2RQWU5FWGxGNU1aK1ZDcVl4cFB0dm9PcTErZW5CSVZaa1pSVTFKdjBnYVNac1VaTTV4WmlIV0Y3emhzSUpodTRvbUo5WDdjVG9ESHYxNEhUVk56K3F5cHhvNkM0dmN2Z1ptbWRwdG1QWWl1T3JNZHZQcFFSZGtVMmtYbWY2YUNYQ1ZvTDIreTZKYnhPMlg0T2lONGh4NnFVZXJkZDJzK3dTVEFIVDVXaUZKcFQ0QWhnUVNIczM2cDNsR1FwNUY3WTFNWUxDTXl6K3c3Y1FJbG4wdjZXcWYvZGY4SkpDM1FXTkQ5UmtibU9XZXVSaEFuNEtYMTIzWFZJemFoa3kwbU5wWlphYWhVbkZ1Q2lSdjdGbzhhdlM2SFJCMHFDVUtmR0pBQzIwTFdwLy9XcDJaalJocTZiTUs0NXVDTjFOSjJ1aW5UQ1RnVC9aUUtxTVczbG9jSHA2OERvVm1iS2lDNm1jYjhkVTMxRnN3N0UxeTlNRUJiY3E3K29HYmxYMW82YnZ0MzQxaE5XWjFmU2hxWmlXc1NUVE5iU3c4WGpNc3doeWJkZ3MyS28rdlgvNnRmcVFZUmFrYkY3a1ZZVVgwUmxXVjV4NFRIWXRmR01sWnVLV3RXUS80eTlIdlkvcCtuN0Q5blA5c0V2UnJqTU42NnZkbkdZbCtqS0pQZ0VQZlFSN0VYYy9mellla0Q5Y09HejhZcm5TL3QvcGxEV0NPOXZXaEx6OHY2Qm02SlgvRGUrRXhJMmliVGZZRld1QXpJTjBRbWhQaEwyVEFZVTh1YUFac0VIU25ia0RNMzNuOGJIclAwWXZNeWQ4TFdkVm1oVTZlYjVTemRpZklYTkhlclQxbCtlWU4yRmErWXdpdmhKUHJ5K1RSVkdVeVFZOE93UkZFWER5YUNjWEdURlYwVFR1U0taU3lYeU1UckVmTkN3eXIxd1pGSTFYd3VUNnJ6QmovQ1pNSFVWSUZTSGxROHFQcHBNcmVWeGUvaUNlamQ5RWVLNnROaEZXR3RqRTVabDVab0d1V1lNN0x4aFNrbWhHbUJraFhzbTR1NFVzaUVCblorSmJPemlGd2xjRUNrMVNDcmRRcjRZVGRKbnNvdUZleTV1Q2dablRzc3pGVS9LMjFLcjJDdFZ0TGNxcE9DZVhzZmhrQ0NaL0xZQTl2VUpkVFgzbUpqV2wzcVFvWktlKzZlalJvMmpaTmQ1ekIxZ0w2bnhOUzJIdStaTEJzV1hlTWQ1c09OOHkzRStvdkozU2F2aWtJWWgzdkFkNjZiZklPWDU1YlBEcG14WGxaaVd0ME4ySm8wZU9oRHpqZDRrZWNCVDNPdExqeW9QQWVGSG1DelFBdVc3cm5rWVBHMEtoK25CZmlqcmFpMkRJS0QveUFXZGJNajRmRCtwRkZJeW0vTmpOTEhLTm54a3U0c2FVZ2VxQU1DYi90WGRUa0VvSmt1eW1Vcmh6U1VyL0R0MlpOTXdnTUpSeVdyQkx3YmJraEgwVksyb20xRjQxZVZrODZTZnVTbFdNTlZNL0dRUG5JZWNxTDdmTndreklpTXlMa3F6ZGJldTZrNEwrTUdMcmhqME1xWFE3RHdwRzdjU2dUMkErN1FhR0VXcmRNUG5nNzJFaTNGUWtyT0lPaENkY1dHc1pMTTkyREFES3M5MktzdWdBK3Rjczllb2gzQ3g4YVJhTG1JT3k5TG9nRzdOdlRsYmRkMmJuNG9uc1pUY0FxM1dDYzJ6SkdveERCKy9sb0NLdVN2Mnd4ZnIySndTVmkvT21kTE9DYjhUbjJiUlFDdjQ0TnFBMFRTc3hweVhtNWpSWHdXeWdWMVQ5NFdTMS9aMlNqeGNZUFYzamQ0Z1pWNXhuT1Q0dGNIeFQwUDVZVXZGbkhPbTFubUo1eksrUE1LOEE5SlF1M3B4OExFVmk1VUZBUEdHbGxVQlFRZ00xcDRraDh1d3V0a0k0VmpxVWhleHJOSzd0Um5FYTFMdHpRQ1JRelBEWC9RY1Y0NTlWaDhzTEtBOE1PSi95MGxYUmlZdFRhZHgwZnNFU0J2eEdpYTJMbHRpUTNTSnIrMXdPS1hoY1VkQW81M2pjQkN1TGhpaXpvNXh2YzJWV2xWUjhrTWJ0eFExd1hPYXZIeEQzM3FjWTZpdHNweVNLditSWEFqY25TTm4wN1ErbHM2SXdHRStVdmRNT1g1a2JFNFVaM0cwTzhJOW9wcUMvV1pCMCtYY2c5WFVRR3YrSEpwajYrMlZkRXU3VUJWTjdzNmFYVkdYeEh0R0tkTzZBZmJtTjJjdThpbmtMczBKOHRxVWlOUjZXeXRTYXVOaGorOXlFWmVtWjVrekl2dEptSWt1bmJRQkNFaWVROHJLRTRTVmlYUU82S1BRekV1YzFoNGdIa3RnczRqNFhqbWVEWkhXYmVsTFcyc3UwN0ttcUpnVjVhemlZU2dXcFRENCthbGRTa2tianRNZzZGenZtemRSOGI4ak1lVVYzbU5ObE9QUDg3NGY0MnJoSmRFNFBMRDduR0hFblpobkhGVDJSTnBSeE41MlhsWEVIeGV6SlNUdDFzWUl1VG5pWGNwenBpYlBxZ0NvaGNidnBUeVdkeVVvMXZOT2lQT1M0cHVuWUZjd3RubFZOUmRydkpUVGJVbElTN3ZBazZ3V0dtdldKS2tLODVCbklja1FETTRzWHk0L2pCN0kxYjlaM1RkM05MV281WnlBNEpkazZLKzNXRGNtVjl0dHU0Mmw2TWUzUEZIT1Myam9TbVQxMGRzSnZvNU1pcHQ2aExCMm1vbzVhNjZRaVFScDRRYW5ZcktFbmVWenVHaGR2d0k3YmUzVTc5Vks4SWVlOEczZ0piVmtxT2dlbGZuM0pXMEpzUWxCZUxpZ2kveXE2RlhtY3NVUzJtMlMvZHFtOVZqbVBIbVI4SnNsa082alFSV0lBMUEyd1dTb0VCYUhRS0VnUlY5cE9zTTNiUlY5di9WRDN4ZHNWYXR6WHVnYVpsN2F1Umw5djVkRjZHRHM3alBmOEYrOVROVTE5bjI2OUZUU2ZiN1ZPTDUxWm51K0pKczFFV0hXZ256MktEOGlDVWIvTmxMTkJQZG1vYmFLeTdMc09qWmUrVjRJUGtnQ1pEQTIxazV0bm82VkhIdW1vYlZ1cm5YUjNQaUFDZFJ5RVFGNkFPZUZqQkM5OVAxM3hJWk9nMS9sS2dSNHBES09RUlQyb3hydFJvMG5uVXM2SEJnNGFGRHowNEQwSGRHK2dsa3ZBSjVmSTFheTV4YVhGT2F1VE1lRHBCKzc1M1ZTNS9CUDhRNnNIN2prNFkwcGFiaVpucW1kVU01dU16eTNPNGI5NE1rc3k4QWxOTW1md2JWdG5sOHYxOGpKc3dybi9yOWdSOUNrbURpaGhBbVd0Z2JPR2RUMFFVQ2oySXcwS1FlUWdzQ1dLNU1RNFFvOTVUdjc0b2RudDIyY1BYT0hGY2g4M2hsWWVmVFF3bmRtWjdHQXN6Zk1wZHpBN00rdFk2WSs1cWVya2djdG5abzRmTEpXTG1VZU5QL3ZvUjRKa0xqM1RTSmdwWE01SU5tWlN1WFJIaHYwWW96SERzQlpSQXZhcVNKWVZpdHlnRkVwaitQRzFadWhtRnhyZ0JzV09CMkN4M0F3RG9rV21PbkdrWXE3b2xmdmZFYXZIVmc1NGMyTmpjNlZpT1o0czM1T2JFengrSnY1UU9Sa3ZGNmN1eWZBZVA3MWQ4UG1oblJtZTJ6V2VqTVVIazNsVGM4WjNjZmdVZjhldnhHSy9ndkxGWXN3YkxFM05qUjkrbzZMY01qNCtOMVVhOUdMclRjeGJ2VWxScng0Y0c5NmhhSVZFd0hFN2hzZkN0djVUZGhyOUZoTVFyNHUyNTRqWHhkSFhLM2dxd09NOStvSVVOOWFOdUxna2lYZUtOSG1uS0g1d2ZXbHBmUW05SDN5SjFyUVUvb1dKYjY2UjJINXN1Qjc1ZVdZUzFoOUxvZUVBOVFJS2NsRjRjakNuN0FFNGc2YktJWWxFL0c2YkFXTzVBajIzNzY1OVUxY1hlTTdoRlQ2OXYweHNSbVpITHM1TVl6YjlRVUd5eEluQjYycTQwQ2ROanVYM2s4L2lCSyt1NFp6QkhLZmh5N2hFbXBpSURHU3FnSFQyUnN6Z2p3OVc5dDM1RVk5WDJaa1YrSlFlbitjUWZlOW4yUUo2SjBIV2d4Z1k1RDJEaGljQ2ZRazFRRzVYYUJhY0xYVURHQ0w3ME03NTB2QndhWDdYdzd0b1l1Y0hkdDcyK3R0MlRsOTcxVlhYVHEvdnVtMG5PZHg1RzFveHpVeHVkR1ZpY0NCbTI3R0J3WW1WMFZ6R05GdG5VK01wL0xjM3IrTi9lVFkrTkQ0VUp4dEdETEVydmhiNi91OWlMbVl1b1pqYmhBc01vY3U3QUxmSi9OMFpDMHJOQVBmTlJpMEFFUXdHdXFZYnVGUkYwQXhtZGlBSUY4K2UrUEtka21wdHN3YmtRNGZrQVp4UXBUdS9ES3ZqWDB4UE84NTA1Z3M0M2RvOWRrWG04L244bnl0Ri82NWZVU3orUFdQTnU1QnBKTTBoaEtvM3p1ZnpLOTh5ODFJVzMrajBhWHlEckpRM3Z4VTR5MDZROFAwRVNUenJmN1R4aDB1SFhYOUprVkhHYjkwcmFKa0RhR21wTFJOTUUzd0tnc3JlUWVQdTJIRHM2ZklhN2FCd0UvZDBxbHVPa0x6SlF1REVCRmx4ZkorVzBYN0VzUjRyc1pZaVBjNEo4d0wzdUtSWStOaGpGeGNGYm9VVEZqOHRDSi8rMDlKSlVJZnZ2RjlSbm1aRkxza2lWdjhEU1JHNDVXVk9VS1EvMEhGR2toTy90QXlsbHYva1laNS9tUHByUXF5U1h2eVpYd1N2bGxMZmZGSHBPKzVIbW5peDU1dkZmdnY1alY2MXZXVzZzSEQ2cklPNlVYTFFqelp4T3ZuNEJlYjlWb3JIemNxbllLbXhrL3pyZS9QeHo4Yno5OEtDTjBFa2Y1empQc3ZoTFFVbkwrUTdkMWo5K1pJcmZVOE1rL1pvUEkrNXlVTFFXaVd3NVl1Y2NDMkgvMTByY0ZGT1VHanJrUWpPRnRqQTdUcG54T0ZpTDF6OHhpNEpNUHQ0NWp0d3o4T3dPVWhteGlYWTVIdEIyY01rV2d0TDRrMnJHaGJGRzRSNzZzSkNHMks5blNTMlFlMllvMUcvZXlsekQvTUJHb1c0VzM4UzlQRW8vVzZPL2VjRG43cFpiZEpGOEtaVTYyUTVYU0EvRjlJWGx6dHY2K0YyZnpuVXlUeld6dng4YTU3NE1KMHcxU1hWdkVheFhNd2VyU3lSazNkZVJETG52N0JwUi90Ryt4NWRuZkxLelRJZkFENE0zYS9vTkphZnJyUitTWkwzd2NsOTZFYks5RlEzNzFOaC9CdndMWjBtc2NiYjYxMDBITGNZTVlvZGtPVTZEVkVUOFprd2Z6UUtNSGZjRGVoYWtzQW5VbE5UcVFRUGFRQzQ2c241ZkhISElHSUdkd0JDSnA3czlqUjM1bkk3bTNzNlhHRlB6ck16Vjg3Z3Y2aFBSM1EyU1ordVJiREFGMHB4eFpPSzVZWmIzQTBXQ0V1RXZ2TlFYRFYrWVB6YkQ2dzlSL2FnbFMxSTdNa1pMWmRIVzJlbXRtMWpldHAxMjgvVHJseUJmcVFYMUt6YlhtQ0lRZUdGTld1clN0cTFwMDIzRWUvb0Y5Mm1wUUxsSmxCRTdRVzFhK3NaRk5MTFJJUmZVUHNTc2x2dm90UlQyZWNwRW84SWN4RXU1YXNKbGJQVXFycjk3VXBoL2d3eEZJdEh0UlJoTWF6TFdLZ1o1bVBPYVRreDVCZmg2WU54S3VNTUVmdVNvaitVMlBJTWVpU2pVT3NxcEppRHl5UzEzRVRVdmtySm5PdGt0NCszUlhDbW13eVRSQjByRzNnalFodTlLWWowOVVFRklBK2tYdjlCNm10TS9UM1FBbzFKdHBJZEdkaytNdkxLZ1NDYjhnYk1tSzc4cnFMSDBFcXJnOU5lYjcyWjJPRzhmZ0ZLYmg5NWwrd2daTWw4M0xJVlhWZHNLOTdHT1NMWWlWUUtyaktYZ3c2bWYyYnV3bzhydGpVakVyRm1BRGRHQVM3b2praEdRams2WFc1MWJINE5WZ2pjTmRCQ3NnemV0djR1bjdlSkpYUmh6NElUckFab1pDa1ZUMlNxYzlWTUlwNWFPa1BVMFdmUWNoNHV5YnRHYXhrU0NHL3QrYk53MldTaEdqaUpoQlBNSjVLaldyYVVxV2J3WHltcmpTWVRhSkdnelJFc0o3SHRlMFBuSTlBMlhkMGZmOTRUZzc3Wlp3T1lmNk1RV2tpV3V0N1hodGVGM2tNK2pWTjBTSS9TaTIwSGNZaHowSUk0MSs4QjF5QS9teDNOWmkrTk8yVXJyaHFLK0NaUk1mQkhiOE5sZUxNelNraC8xZ0hYejdUK3I1LzhCQ1lVdUhRMGUwclFXZkM2VW5WUlVVUmR0VU9iL2E0NkQxOEllbXNuYmtlaEN6eW1CL3MvZEVJQzB2bldaNmxaOVRTYVA4R3AzTDNEZURQY0d3V2dONDdlYzlSdSt1bUZFeHlVNW9hai9rZjlNZFBNR0ltMWVid1hIWGNINmgyczNMN29KMDFLZlB0RnRkRjRwR1liNnNFdm9IVk1Gd25EWTZ1a0JuZXovTFd0aDZNa3o1TVBqQlM0bDVKNW1OVG5GTjRjYnEzbmJWSWxocUNvL3dpdVV1RkxKQ204cVdhOEY1aW94Qkp0bGp1aGhxYzQ3dkJDeUwvQk4rYmpiMnkralpUZng4UUVnR0JYOUF0TnZ5dW9CdEdDZXhhcVlmbStWaW1INFpEUnc3ZndLbmNMbGpyM0VZWmhueXkrOGQ3OG1meTlDSUJ4d05WVWZ4a244MG1XM1hWNy91Nzg3YnQ0UHNrcDNNdDBKTjNDODdjSTFnZWdXMzNBZW1KK2Z1bFZyd0xLWHhVejcrSkZQb2tFOXNEOC9BRmNIaC9kWlhiWitzVHhWM01FajhzVVBLUFBwcjhwZEJQZHhlUkpsUERPcDRhdmxjS0svczR0dUhWUENsMlZFTkRERWZsbXZBNnRXOTlHS2pEWElBZHg4MlY2TmF3b3V2WVdEamRCVkJYaHArMTYyRHc3eFBMeitCOUoySGVaTnE1bkdDc20xUGxsbWRJNTlIMkVRQUhDUVdIaXQ5THkzWThKdXg4VWZZU2dqZHE5K2ZrenkvUHpvZTN3MzJGKytNTnRmdmdvUmJXbUFUVnB3d1dGM3JtYTZ6dHU5aDJEZ0ExN0lsOEtpT0Q3dFU0STBoTVU5S0FGenZJZjZtUkxIKy9LSDErVVBFOWFGTkJTSHZKZzh4YTZnODBMVENlOTNFbmV0aWpMMnBvbXk0dTgyVzB2bjJRcUlXNENRNVptZTFCZU8yTU5tUXlJa0x3SDlNVWJBTmZQZFl5Ky9iYWsvamJDVzVzcWVrWTFrMEZyY1I1bjRiK2RiUWI2bHpaSm9aMG45cHVtZk9JeHVMSkZyNithWnVzYmFQRnprRTlPUG5sdVBJUFFqaXlxNndYWDhseFVvd3g5OU5lNjZMSXhYZitJRnIvWnBpdnl2ZXFPVjNIUnVhUy9Oc1pwc0xWcElraExXNFN2bUtXaEZDNldCT2d3Z2s1cysrY0ZDZSszQ21HQndtQU5yWkN6bXcrWnZKT0F4OUFmeStMUStXTlpYSEFOdGc1dGNlWWN0ZGd5dkFXYVBVYzlxQjBIUTNDdUp3QVpvUWx4SVhxWkhSQk9lL21BRHVEc3VhdXk3bVN6TTl0bnNvN2pPWmJsbEZQTHFiTHo2bVN4T0ZNczNrNmQrU1RiRGxmbjhmN0dCNU94Z2RIc0RMNHFtMC9KQTI0bGxsVUc1Wnd6RElDencwNE9iWU5MWjRvdEVwNXdXRkx1VktRS0pCOVhwRER1SlBDbEVXYm5qZ2dudWNQMEZkcDl1NFo1bmhwRS84VjhIOWVnNkoyMVJqUUtGZkZaZGduVFZGV2tOVWxwblNVdWcxVTJYMVZhUDE1ZVhyKzNlbStWR25maVBMU21TQ3NyUUFmZHR1eDhIcDNGcDVaYVo1ZnhQNElSdkxxK3pvU3hLT0I3ZzBqc05hNjl1aFN0SkxtMVRvUVJPSFBOeVA0SlFTUlJkeDZoaTBQQzZQN0ozaHg0OXlURUR0bWd4VTY2elFOL2xRbndHNjR5TzhHNkhOV2J1MW15WHV2em9OelBFK1ArTWpkSVFxVE9FRXpQU25zdUhJeHdHS2xlQXd4ME9sRlRCenNLUTJLdU05c2RLUlhXTWVOb2p1ZGpzaHhUNHNuV2Mzc09vZnFoUGR2M1BuYjN0bjM3dGowTG01OVdXWVdyc3J5d0tQQ1BkcVUvSUFkdWpnaitBM3NIeUQ3bkJqS3VmdjA0T2FwZVBRQjRMQnllWTJNeG1WZUdIT1d2YnAvYnMyZnU5bHViZTFyM0RJMStiWFNJYko1YzRQa0ZYcGI1Y0QrYTltSjZFajZQb2lRVllaL1VZMTZhT0d5bGlicEIxMWlSaVdKdUlzSWZOQWx2RTNub1ZhU2lqLzgzbXVWRzZLV0ptMUhxMWtuQnBoa1B0ZkJTRktrTXpkT3c3Sm5VYUw2NitHWVJKK3NuNnV6OUVnRkJTYWptc09kUjNBL3FzWXBXaUF1WE9sckZwWDBmRjYvaWM0Wnh2NlMraWFoS1ROVWI1Z25XeUVvVTRZeGh6SkFYV083UmpWSTdvNDh5djhrOHhmd3A4OTFOZU9iZTRjc1grbVdHRjNuY2YzM3BQTWN2OXY3OXgvMGF0cDRnMmJyQXRZajZENjF6UXV0ZEhTVGd4Zk1sVzJjNmFZQkpiK2N2djRpYmRDVnY3b0JGOVVzVWhENUM1VWZhb01YbjNseXlTZDZuTHZEYXp1WURiVWtzWER0K0VDM2l2bE1tWHJwM2Jld3B4QXU4S0ZGMHZNaXFJQzdDUXJJUUZQZWc2VGpWaG5aTEFKVDN3VU1hR0tqQ3dna2VMZkJRQW9zcFlPdFFwdllKTk9RMG5rZllVOCtUT09ic0FrQTV2UzZ1Y01wT0JVbDhYSlRaN2F5U1YvQldScmUzbmtXSjFvSlcxbVRocTNnbUpKV1loOHFZV29vM0RaN2pBRTdWY1dJeFFXVmxsdVV0ZkUrT0ZVeGU0V1RWQnY4RHRJaTVsTE9VU3lGbUJnTUR2S0NLajh2eTQ2S2FPSHRycVZUd0ZYeGIya2JrQ1FNRGdvNEo0azE4ZjgyMmRJN2o0WWFLYmtIa2VuaU1ybnR1TytZTG5aTUdpQXg0dEIzak1wbzQyMXh2Vjh6TFdyZ3FVQ3YxY2NadUwyUGRZTzl1L1pEbFRWd1RFOC8yUHhTa2pNZmlyaVNOUEwvK2pLVXNLTll6clR5TmJFY2wzVkMrSmFFSXNad2VnMnJIV0I0ekEzRDJwQ0F0eld1K3J5MFE3QTJ5UVVTbWhOanliS1RiWE1jeTA4ZndpSGdqc1NKcjI3ZUMxZVlVQ2cxb2kzUXVJY3ZKbFhLdlhUWUpwOWlNSWk1S2JZUHVvRzNXRGJnTXMzUlNJdjRxdTJGeW9VQlU2RmxQVXlZcWUzZnN5QldDZUl3WE9Fa1ZWTVZTWlUyME5GN2tPSllkcSt5eVV0WmcxUjh5Wlh4U1Q3cWFKWXFCV1I3Mjh1NGwxVHJuYStaVWNTaTd2Ym4vNEtXVHMxNnk5YUh5eWYyS2pRejErSDBUSW10N2FLbVNTeDdaUHBOTEl4a0NqZkNxSmFxYTRtbVNKbVBoVVpCbDNkZzJQdXdLZUhwQW5HQklDaWRVTmRFVUJKWWxxSm1KK3JhTEhkdXgzQ0JYSFltamdlTE9BOWZORGxkYmYxNGJGNUFCNW5UTm5iS25jOVNQK21jdlBNbnk2R3Q0ZnI2QmZHODBqRjhGNEVQQUJ4UHdLNkNOY3l5MWhXMFMxQXBRRTVOMkxkTVM3Y0xrT25FeUxORXVUSzRETFAwNExzamlzcVFFbkl1ajcvdXpjZGxTZzdIa1dHWHFLdC9tRU04S2hqYTZhZTZZaXV2TUljNXdEcFlIaHZ4SzNrellXczRXTjg4K2cxUWxkVkdWUTRhaklpR2JXUmlTRGZTWXJ4a0NyakpuKzFkVnkvaitnV3JKOGRuUlRYUHJkc0xNVi95aGdmSkJ4K0RnR1VnVjdaeTJlYmFIYjg5Vkwwb3BLbXZJUXlPVmJRSlNJLzNyRk5FRk1xVzJqc0lwaG9sd25RV04zSVRsZG9nSHVQK2t3T1ZGVWNiUzFYNVpIRnJrU1NEQkJUNHZXSGk4V0xGQXB3dit4Z2owQjRYMlBVTVV6cDc3UnNEak8rL0c5NzZiNStPY3htMjdsOTcrYzZxNURSL0crVGw4NG01ZWdRaEF1OUZ0NFdQdTJ3M3c0Z3JUUjMrNE5rdnRaU0wyc1FGV01WdlJqNjZuRldpZG9YZEdTeGFsL3lsMEVlR1hHZFJqeE5wejN4Qms1dHowbzhOZEZXaDlJSHpNVzZJS2lGMysweDdSVUV5QTNrNmdEQktWK2lyTitFd3pFQWVia1pvcnFBQmNRTnlyZ0oxcVpYWkdDa1RNWnBYcjNUTGVVQ05SVHpTbWxrN1RXTm5YTlZTMWtiMHB6UHc3Y2pUWGtlOHVJUmxQMDZqYnAzdEtSZGZRTWZzcGRDZHVhOEJWMnMyOGxHcnRwTFpTQ0N3UzZOUUdFZllvRGdkRjMyZ1N0MmY2SFJiTEJOR3FpME9rcHZIVVJpQWFERUhVUXJhQ09VQTgwMGtLc1ZCYUtSTnIxT0U1eFZUbWl6c0daU0V2VzhZTmhpWG5CWm1pT21peWJ5dVd4dXJ5TDhnNnExbUs3Y3ZhMUhFdkkrdWNBcU82d3VreXpPMy9rU3JqdTh5Qm9ldGI4S1ZaVnlzWjhXdzJicFMwV0s1SWNCMnF3eWs3NVpsQlJwSmxLUk9ZSGo0Y3JsS01CL2FGbjc3d1JWWkFYOGV6RnhiYVN6bkFRaFZoL3A1a3lZUU4xU0tCbVNtNEEyRGpRVDRlYktqaElYaFNrSHFUVWI4U21haUEzbytNYW5IUUE1YlI5cVJueElYeWFQcnc0Vm5YVGU4UkxRRUpFOG5wZzRsamlZUnF5SWcxZUVueWZoMmZUNCtXaGJqaEpXMVBrbmlEUmJLaEpuQ3BnOVBKQ1h5TkplNUp1KzVQa3Z2MnAwVjhPOWVkeFZmc3dUM1ZkVVZoRWtvZFRSeE1xaUl2eHd3OGtxdHZ4MFh3SGNYMC9uMUpXOFU1QmhZbVJEVjVNSEVVbm80bExkZVZSWHpUdzRjSkpBT3hINFI0SHZ1b3BZRlAvR01hMUdzSlZDZWRWTVNPaGtyMFBjanZwRUlXRnZOU2R3OEpFamM1ZmpUelBsNVF4SGZTTFZIT05DRTVUYmVTY1B6VzEvTllFdVdQalF3L1VTQlF3ektibjJxbjlnQjdjb2tlSG1wVDdkUWY0VW45WkJ2am12cThkT1NDRTh4TnpNdlByeit2OVBsSE44NXozRFlqOURja3RsUzZqNGVRM1Z0c2Z1Ym4vTDYvYy9sYVh4OHR5RW5YYlpKeUxIS0xWL2ZzeUhvS0hoT3BQb3kyMFRIbU5jeUhTZnRFcnBMdDlaUnV2czN2TzBZZWJnVjhBU3pWRVo5UWtkclJTSDV4MEtmKzllUnNtODJCaFR5Q0VWYWJnYUVHT0NHS2Z0Y09oNE52azRYYk5zbk40QTRlc0FpQWgvTWp1b2FKd25XWnJxT3VkSXZUOSttNnBldXk1R09PaGxNNEhsbTRsd2o3ZGIyQ0RGdkM1MklwRTNNN3NneVF3ckl0RzZMdEpRemRNaDFSMzY3cmhxNkxJbzk0V2JBdFNWSkZMREh2NytoUTM5UFd0MzZvblVJRi9EajlTbDMwWkFEQTRqbDFXUCtVSUdxS2pyazJ5YkF4SytmS2tpVEt2TXlKZ3FaWS9pY1VVNC9wTHUvaFBBMlhZMDFKbGxqWjRVUkZWVUxzcW4vQjcrZWRZVnp3TUk2MTIxNFoyUUMzZzg3enF2cVBGNm5vSGNKUmVXSFFnQ2UzYXRidU5ORzk0ZElQMFZ1c2hrSThzMG5MZEZLMFRqL0NkWHA3ajd6KzR2dGNuL3pybitmNEFydk45VVREdU9YbXZGMmcwUzcrb1UxU2RJNEIvaGZtR01EYllSQm5JcnJ5TXRzc1lYNlZjNFVhK3VsVDJuanBUREtseE5HcVc3Si90TlphWEVjUHRCYmpTaXA1cGpTdVBhVlk1ZFpOYUhVdGtybUlqWTZPWmRoSmlCUFRwRTFKRzdKckVZb0lxYUc5Ym1obUF3NjVRc0V2ck91Mm5iRHR2NGlHbUR4UnhZQ2N2clkydHpDSGJBQXFIYkwxZVZ3T05rOUVFbE1WZER6N0tsT1pUQldBeVJiWE8zWk9zRTRHVW5VenNoL2VZS3ZRQ0ltTXoxQnJZY2t2TklKdTR0RVpmUHV6YlUydk45OWMyR1o2Wm1Ydm9kYnFiMUdTMFJvb2lqb2kzTlR3dHJuaE9XQUttcGl1cyt2clQzU29ibVBqdG1sN01aU2RpNWp6VWhIcW50Y0lUd3NhVzdJMlA3bnA0MHYwNFNTMEcxcHB2NHBJM2YzWCtJV3MwVGVDbUNsOCs5NUhrL2RRSmRIVmdJLytQdk5EUEFmNnhKdGxodXBhMjJoMStMbmV5WERwN2hEcHdZZGs4ZGhKRG1kWXFFNCtqVzlZbEIvSG16VTBSZENaS0Vaalh6enlPL3F1UWlPM1lQWVlGallQNHh2ejhpR0lNMG52OHlTOVQ0bWlPSXBaMVA2c01hT0FycVEzb3FqU3FHNWRIdDNua0l6WmJJaFpIc1lOeHZYNk1LR25JeDk0SGRuZ0h6ZlVDOVg3N2h6ZUIxVngrMlJKM0RsOG4zYmI5TG01b1hFSVEzNHBVU0Zkd3BNdzVBOXhLditML0gwNGRSeGRRNnI5eWVNa1dqbk94WDlxcDkwVzRQNWJ4MHlIWjd6ZjY3Mk5oOGwvaUR5ajNubndwVnowWUh5TzZicy94YzVzdDZYVW9aM0VtUjZHQjdRK1NlcCtUYzhEMExHdG50RFRQaTdwUCswMkRqcjNoanA0Vzl3RHlWcytON1RGSW12U1U4U3VtMkxwdG0yTlFiRHdBQm0zTW9zN2I1T2JiYm81UkhFQlFKQ3ZBNmhvWlpwTWhzMU9lTXhySmljYWhBS1dtNXc0a3BTazlPVXpyN0hqSDg5bHY1ak1QTjk5NXJkVHcxNEFZVFAzM3pVWTN3OEJNNDBGZk03RVpRNTQrOGEwbERaNXlQdDRPdjUvY3l6U0hiMzE3dWlrdnhlZmZHTjU0T1l4TUh1eHhjUGJ5anNpZThtbjBKZHhmV0xNRUxQQVhNVXNNbmN3cjhOdFIvMG5pREFVQWdHRHRmY1l0ZmVtWTdJdmpZSi9XV2ZTRWdsQWQraFNDT3NOWFVhVVVod1F0d2d1RlF3VlVrRGh5b0F0cURVSmNCbFJSNEpaK05pUnNXWDgyM25iYTNMMTNETCtFVWk3WDBjOEVzY3krd1ZwcWhCWGhjUkFPZjBMNmZKQVFsRGpoU25NSm1YR2xKUnhxVEZMNEN2Wm04RmdoMWp0ckdXOFNUYmpWZEhhenR0MndYM2g5dmdwclZVYUZuMlo0dTZ4MlJMZ3pNNDROamVVZ09pUmlTSE9kbWFLQTRKVU9wak1aSVlHNHRwQVhHRkRqNXIzeGdkWUpUN1F0amtsNnhBVWo2N0tYTXpjREtndUFlall3aGhaRWhJSDNZb1VRRVR6aWtYRFVZR2tFY1JuR3hCMXNRamRzbWxGY2FySUNVQnVvaWNzZHZOOGdYYTduaE5UYkhud2lrTzZqazdwQlIzdlcrL1hDNjJkLzd3VDNiRHowcDAvMGxPNFM3aUN3QWNCTHdndXgvSXBIY2szeVRHV1pRMVFJTmsyYUhnTWZCaVRFZi9sclU2Z2oyNTFwbjRJUHhjL1hJYzlmamdxUkE5L0pNRkxYQ3lGSlFCZHgzSkFLc1pKZklKekxFNUFob043ckl6RlNNNHhrTUJaSExkcDd2ZHNGajlQajdFY1VoVEVzVEY4SDhUYUxQa3VueWErS3VOa3JaZkcvS0xHRlJKNDF4RkxjWUt5UVBwMXR5ZUQ1RWttT3hnQ1d0UjgrSDVueUprYWFyR2NGanZsYWl5ZmpGOFVKSGs0aW1rY1B6eTBhL3Y5TzNZT1Zhb3haOWVSSThleWVTZTJVSTVOelV6Rnlndm90Q0NZTmk4cFQweWtFNG4weEJPaUpwaW1vSWxmT3J4ak5wL0w1V2QzSFA2UytOWHhjckdSemFiU3hjclk4Zm41RVJjUFNDUEVab09zYXlFbWpDKzZIMytMN2VDaTBYSnZ0STVGWmRsS3ozSnZQOTVsRFZjVXkzZC83dXk0ZklmakozeW5uS3FueWpoMUtvd3Jxa2h4UmFwTFNoei91ZTZ3R3d0UUtabURlS0s1cERhU3VNYk5Td2RoZmZlZ2xIZXZTWXk4Tm93cGVsWlN5Q3J2a2lKZFl3ZXlITmdoSC9VbGd1TWZVQVJvbDZoVzRnSHhLaVdxNWQwRVZJYUQ5cDZNdURzcVUxVWk1SSsxK29rNjVsUEdkeWo1dkxKakhDZHhSckk4ck1jMHdscG9qakg4RHFwUVFsQTJPemtVSEh5cHBXbldTdzhtaXBOWm5OV3FEdStZOTNQRmdLN29CWU01Zi80SnFsZUtlS29PblMrS3lnc2g3c1ZRUlhFNkViWFJHaVR4MWFMbGZUeEYrR1RXYXV4bWU1eHJLb0FYSlJLWm5YaUp4ZEg4Mk1WWEh4a2YybDAyZUpNM3lydUg2T2kyRXpiNDlUcUJZaXFqT1VsQmVUb0NWZzZNaXg5TFNWTHFZK0w0Z1l2RGduaHpSbElDQjE1cmJsUnAyMHIvR1BmRkhYaStnNGg3MFJ5Nk1Vd0JNWmNMdVlQTkFwazFBcjlRYVZZYWhVQkNqNnZTbklUL1ZHcXNTOWFTenF4c2x2bisxbWZ5K1JpNk5KOUhERDdud1ErbVpvOVl0K1REckxzaDYyNmF0VENmenkvakgxbmZ3VzM3MTNpK2ZvelltRkl1VnFvUVJMMFFNRGdnR2k0U0twcXJPQUZ5bWs1SmNwcm8rVGYrcHVPc0dMWS9ZTFZUajYyc3RKNitGNTI2OTE3MDRXMDdCR2xlVEppdGRZQ2lqNDVRSGgrMTdxbWlmTFgxVFpSdnROYTFCdDZGOGdWODB4bE1BNnd5QWRCcXZEMDc0akVjTXhLUmNVMDdCQ25vTmFlUVJNSllBT0pzSll4YUJnYlQ4YUJab1Nwc2xFL1BXWUlsQ1h0a1ViRG1TcE1SNEdnSVFJb080N056YVp4YjJqM01Kd0syZWRuY2JGbGh5N2s1RTdPcGV3VHA3R1FwU29aRkNUenBOb3BXK2xEWGZRZDNETEZLZVhidXNpWWJKUGc0ZVM3VlErS1cvVnQwRmJYOXg1eHBqMVVIMGJXYWJJNkV6cTMxZUNzUnRhUVFxZ2M4OURjVG9sVWtyMzlVem1lT0hHbDZYdlBJa1V4ZUhpV1pSVXVjNExqV2YyUUlZWDg0am1uMmFYZVlLS1JKVVh4QnVqQkI4M3haeE1WVjdsaUdWQ1RVbDM0YmxkQlRlSllHOUxCeVYyQUFTSVhNWVh4SEZ4S2ZEMnhOanQzTmxxV0l6SC92ZnNJNDVwODNKMlFYSmZNdjgvSVloY3EwQkV6OWhHQlJwTXl4cmhyK1NwdkVFRnYyUWZRZ3BSRStyeDdBK2E2TzBxaFhldERtcWZWUDFIdlEzZVRGQlNabWRCMmVzd1k2UFNNOVlOSUFZV1lBYi9BZndvNnliRUZ4R2pMTUhJaTZRV1d5TkdEeVhBeTNKRDVMdTBuckRPMGJQZlJtcUpUWTM1MGJuYjdlVDl1SkxwSk85Rk55b291QUV4dWZ5N2YxcFVrUzVlSDQrYXpIdVY2bGFmR0NZdUE5czVUeHNCQzcxTmFKdHY1eGNmR0RiYTBvKzNJQVZnU0JqUUF0dHBOb2tkanQydDBXQkxiZGE1Vzh1dUVxU0c2Q08zNzBQd1YzSExjSStlN0tMeHB4L000VlM5Y3QyTHg0clBIUEpmQy9NRTVuQWM5eEI4R3Z2MFJHc05rdy9DWCt2QWo0SWFSaENxWno4Ym1qWXVJKzFUVk9vbnd4eHd0NUVUNHJFUW5qMjhjRkpJSitIWWw1SlZjOGdJVmhhTnh4OHRuUkpLb2ZDSWZIczZWNWx4UFNGVkVXaEdCZ0lCQUVXYXlrWlhlKzFEZ3VzK3hzMTBVa09jdXk4dkd4ZGpjTVkrQWc0bStSeHp6UFllWjZab2w1aUhrLzh3U3pScitIYmo5Q3JqY21tdVM0blc3WXFQV1lZL3g4ZWREVisvdHo4LzlESHJyemI2RUgvNjJiemJvOFIwd04vaGRtdTFkNE5rYmpCOFVnNi96cFZ1NUZGSVkwc2JSc0wwYTBtaHpQYytqZDVPdDVKYm9Scy80aXkxZDVWdVJ2dm9DMFRiWXN6Vm04c0lQSS92SmUzRzl0UEsrOUNzOFlrVFFjeWNka2lURWVkUE5BRzFMRStidlJoRmxjMmdTSGM1THRzampPaGZJMk9WN3JNSEdENVpSZmtLYWhHOWJyblcyTkh3cFM1ZWRHTDU3QWdyRWluWUVseXYwVEY5UFpzclQ3eU80U2RRWEhOenBONVYzWVBaY3FKMTFpSzVQbzJzWno1ZFRRME9SbGRhRU1walJnL0NsSVphRisyU1QxVGlydEx1RS9TSWQyTTRqRUxoeGdib1NZSG00bFZOUjZVb1ZBRkhSN3RVakJiRUJXNE1VTGFJRGFUTE1pRWoxRDVEQ1BCZWdwZ25vKzg5VWhzNzZybmtOVHVEa0cvNFg2UEpYcy9XRFlzMVNhM0xRTlNzT0ZXQkszNGNNOEQ4WFFYL0gvZEVVNXBhSmJobElEMEI2eU12VnkzQjYvU1N2cHhrckZQN1o1L3RWcGNjdFc4R01XdnZEZzIvRVVpa3UyUmpqMXQ2K0lwOHBNYjMvSk1BdWI5eGRhLy8rRUhsRXY0NytmNDkyWFU2ZGhjNEh2R3VyME5Ib096MGNXcnROSVcxc2ZtY2dYbSsySkNiQUwydllDbU9xSDRWNEVTZm1oem1SUjdVd2hqM1VXSnpLYjJvVkh1dmtPWHNQRStSQWJoUDRJeE9kQ2NHZzkwYVp3Q3pDSFRJZEVKb3FwQVAwK2djZjZhaFN6a3lvYTZMSWZCVitxQUVwU1l6TnlmbmphY3QvaG1XODE4Wis3NGxxblRYUHc5RHZlK3RaM25HNDkyU0ZtRkdkM0ZmVGU0WnBub016cGs3MzA5Tmk1VDIzeWJzNWo5WDVIKzVGM2JHblczdldXdnJHVkZYdEh0OHY4RGFhRktmVWF4dFhRWjRtaW1OakZQOVpUaFhBOWFCNWZLZU5XSFFaODlyYUpTYk12VG8zcjlNNmVYTi81TmFxZHE0YWdNbmpUWlN0WERRM2w4Q1pQVVcrbXVqeFQwTGF1aGUvVzVSMURQTDZIeG1nTmtHa1d1d0tiWXJMT1IxcWxiMzN2K3hHRjBrczJKWEUrakQrSk53dFJQRkVnRk0xdlJlY3dLU05IMzJ3M3ZSdTVrRDdxSzMxK01jaU9TTXFrSW9yNHd4RkJVdC9VWE8wMlhNeFRHbURUUlFkOXQ1MDNlNEZ2Y3ZsY3J3L2RjbzVYRnZvaGdseWk0MUZyRzNOeGZ4d0lEejhQMTNrSFJKd2dscTdVVmhhWUtMKzV3ZUlDZCtZR1RoZHduZyttNGdTYnBBNmJ1TDVQMHl6RThUSXZ5a3BjbEdFZC83a3VBOW03V3N0VGhjSVVvdHRxUjl2eUdLeS9ENnNjai9DVnNpZnFWK3IvYUtxdDN5TG1ycGVwWnV0TVlZcGN0RHpGdEdNRFBFamU2ZmhHcXhDaFE1NFA1RGJiK2lJOE92ZFk3RDcvK3hFMVFObVpzQjU0ZzVhN0h4OCtHbS9tTzlOTzZJLytqMlJkY0J4c3hEQW5EeGFSTkE3bmJnU3dOcVNaM1ptQWFyR2E3WGc1S05oeGFzaVU4djdJeFJPbEFWZjJ4eE1IWG5zQS83bnU2TXl1azgzc1ZWVUNDekUvTStFTUozZzV2M2RrYUhkTUhTN0tCQVlDUGNNbHJweVp1M1pVSFJxWnUvR3VHK2VpOGVNRmRobTN5MUhtV21hUmVTMUJyT2xhZTdEQ3dNcjB5NFB3SCtTUTlMT2dMYWdDQmd6K1ZjcXp6YUFkWnhSZ1Bja1NCUzRvRWs2dVdZUjRJQUZSdkRXRGFIV0hSbDlobWNBdlhBV3RONkZKbGFTb2tXRG5GK1hPaUZKbVpnNGlYYy9sWE5uelNTeWc0dGgrL2JpaUk3WTBxQWNwNHJvK3VLUDFVb2dmcXFrMVFkZXVWOGMvOHVqZWR3ZXBQeGlxMjhZc3F4S0Q1b2F1NHlLSWtlZE1OYSthOHRpSVNwaTN1aVI0dXExN2xrUnVWUi9XbFpIRGdSZHI1TWpUY05ZMzY0ZnIzSFdxRjJTdnZ6ZTUrdzMxSVhmUXVJNmFZUFBYY3Zoa3FCZjlBcnFQekcrVFJJL1RVWlJGZFFXdkNha1lFTHpOTXNRNEo5OHdDWng0NjcrNk5TeHF1NG1ZTnBVWVM3aXE2NlNIMFB5MVZjeE9qNG82TzNGRWNsM3BYMlY1N1o4OHRwaHUvVnE2eUxxSkVWelEwYXFKOFZKdCtOV2l4bUwyWDd6OXNDeXI2S1dxTFAyekZLTjZQT0EzdjBhMGVLTkVTeW9RU1BJaU5TVFpoVXArbEladlFSSWFwUTRxWDF0Ty9NdldNNm9lVHhIQkQ5bGhJaFZ2blVWMmE0VjZoS09SY1AvVUl1K29mNmROSDV5ZUxwNjU2Z0dhUU1kczkzVlg3NzY2ZFVOcUtJWC81dWt1MGltdll4bDNsY1JCN1doeGUvVDFYU0lyVVc0Y3FCRWVyUllKbzhpbXF1SEdndklJZEo1SGxJVkkxS1N4b2kvQy9keGwwb1Q3cURQN21TdVprOHpkZEN5UStuUWVBTTRHdzYxUWFEb0ZvUS9RQkNROTZUd2dzLzJPa1g3ZmVYYTRkZGhLQ21PcVdRZ1EyT2cvMzdJRlVVRHJyUnNSV20xOXVEM0RGUllXaGp0VDhsckhOMzJ6RFZxT2dXZmkyYUFRaG12KzNIUFBjUUtXeWxIaThUQWNNOTRzREo5c200dDFOdTl0cC9hMVV4MGVBK3o4NGQzTVlRa2R6NGhrVWFXdnpiclhVcnI4d0R2Nmg3Z3ZYUUNvQzFwWXdLejVRdHR0L2pFS1lQeEJxdmpCVXE0a1BDNUlXTlNkMnp4bTd6THc1OTBNV1lLQ0U3ZHVpSmd5eXFiejdQL1lQSGd2UTJLTGgvaHRUV1lINWxqMk1ZZXdwSFlmOHdibXphQlA2dW9OaFI3V3BCZmtyOUFGM3pPR25BcnVOcUJnY0l1Tm1vQi9GSDJKM29EaS90RUxwRjRnb0s2YkVCeUhFRnV3aG40VWNoUVFLNXh3RjlScDhqQ05GVTV6aHZQNTFtSWUvcUhWZkg1WXA2V2hJSlRSaDY0TXJSRERmZXRmVmxiT3J1Q2hkNjV6aStpbTRHRGM5eGhtSHQrNHRRcTNEMi9LMFAwOEViRHhhNHIyaWFWNUxDZ2ZpM1ErMzhYZjRpcHpGWWxwZVJOeksyN1hCNWxmWXo3SmZMck4vVWE0VzdYZXc1Nkc2V25zV3Y5aEQ5UWl0RDBFOGlvVWFWd3ZLbCtITGVsMzdvYmJ2bGJxOHF0czlOMkhIZ2JoWGRoNjJCSW5vaVpaNzIrampXZWVodVpxcmVjN3JiWk9kL2c5b1VSNGVDSXFmWUsreEh5K2ZYMmkveEdyVzU5WnplUG5yT2VmMDBrcFBkeWRqaDZjNktaeUhSZWtObXZkY3RyNXBiUnpTR1ZiaTJJaGhzVDUvZXY3aHQ3L2w3bzNnWlBqS3U5Ris5UjJhdXRhdXFxNmV0KzMyWHVtdHhuTm9wbVJaSTFrMlJwTHNpM0oyOWlXc1RER2pCMGJ6RDRZREU0TVFTRWtjYmdoR2Jqa1lSSklCSS9GN01PVytDWCs1UWxpYmh4Q25rV1NlMFBlQmFJUWJqQUpicit6VkhYMzlNeElNcERmZTIrV3FsUDdPYWRPbmZOOTMvbSsvMzlMZkgzZjhiSm5MTWNLYm05OC9WUGY5Wlcxei9aRTEzK3RzL2ZMUDB0cy9UV2JZdXU3ODFTbHdBeEYzL1lDZ0FqWmZJbk02OWdFd0xEWm9IRXJ4QWVXcFVUZDJNVitITy9ENU5BQ3RBUS8yb2hJUzAyZkF3aDhLdW1XcDRaMFZ3NnFZSDhxbm1mbHZETlQzSGNrWExTMFZENmNITHFRcU5iam1xQzdOcWRZUmxRdXVFRFQvNjdrSnEyUXBoclJnbXByNDlNRHNxT0JEU2MvVWRLY29KNjI1WDB3eTNKOC9OQjRJcm04eUVVaW9iSEprVWszV1drZmpKV3N1S1NwcVdDUWNkSkN1QklFUi9jUFZDTmhVU2hHTmNmU2h1cEZLU2lxQVVqYURaNFh0bEhMU1FUbTBRaTdST0t1ZXh6dE9nbzA3c3J3UjhuM1l4MXRCVGxxNE03UzlmNVhBWWs0UGtPWlpDVGdycTVlMk5nQTUvSE81OG1oS29iZWhReEJScSsyVitmbjBYRzBYQ2ZCemxXZmcrYnMyc2JHbXNlOGloWXJQVW42NCtFa3Zvbm9nUkgwUm1sNUxzS2E4eUpMY21ZYkVwMk55eWxHRDVIT2NpYXpmSWxpa0Jpc0x6QXNrdi9jUUl4d1BmSUU1UnYxWkFSTW1lQXhXVWdOQVkwMEtHTjlCQW45UmZCRWU4V1U5ZEI5bVFGdGFGV1NWY1htcGxtbjBQNXg4ZXg3M3M0TEJ2ekx1OEU2K013Rk9aK0QxV1BoT0d2T2pMR0M0b0szV0NtcFBiS2dPN3YvSE9xODhPbVJDOVQzN2pOSTcva3F0bEM0bzRCZ1lxY1lnc3pxQnhhUnVBa3YySUpPMkpHMGQwUURwYjFKMjA1K3g1bWVIamFNOE9jamk5WEkrMWc4TzhldHkzWmMrb0pWYnRuZlNVNGZUWDJGek5seFgwa2V1c3BPWEhVbzhYZU9ZUXhOVDRlLzRJNHRva3ZJRE4zN3BMaUZMbW1WcmUra2prNm52a3IzZmhVOXdjTlJYa1BqVTQ3NGpQbzZqdStkWmRaNlhRL3B6SnhIYUhyL1g0d2NHaG0rY29UMERwWE96TlEzYWRnL1dCKys4c1NoWVdJMkFxOXJ2NFd1eVZudEN3Uk1nTWEwRTc5UktxbGZTU0oweXI3SHdDam9TcXE5Z2tHWklHMmgwYXdqZ21GdmZFOEFJeTQ1RlBNSjZkNzVUWElaa25IQngrb2FscFJtWVNLVGdMT0VrWkxZREc2ck12TXk4em1vS0pxaVJBOWk0YWxGem1reDNBcU9uaVFXaGJzMCtUalhybXRWTzZHRlFocWRzOE1lNXZiMzdGU1ZZZVQ1WDhIWGE4cXZiTkQ1TzN3V0V1SVM3YWZvOW5GWit3UEd0eE5SV3ltZXV4c2c4N2M3SXliMlIyWDBiZStBbFRHSXZpWHlRVUZwdFp2Y0VTWWpRdEVOTmkxSVByK0QzdEg3dXZhc1N4bGt3S1VNTm1TZWxDeXFIRU1zZzJnQnF0dnZ2bmRIT0l3YkwySmlKTDUybENOaENrbXp4d0szQlY2QnBObGZKK1BVVnNKVXVrSmprUmUzMmlUb0NiUzNxSmVwa3crVytISHdKbTVUcFZZVHBrQkxjRW9DckpmRHpUSUpudldJaTVvdzU3R2Q0SDA4UmtzcmtjR3gxUFJ2VElnR0tHd3pQZ2Q4MWpTa3dWd3lFbGJWY0NTWkc1UU1NMTJLRHNjaTVZSVprdTEwUElrVVg3MWtSNkp4MTRtVzNoelVOZDNTTkRUVTdkRWFDV25reUlnVWJ4NncwVjdOUW91V25XWDVvSk9SVWVOeGdvbHlmaUFaZEd6VENjZFM5VlRNZFl5Z0ltZWNJTTltVVcyNDRVTGREaVdUSWJ0ZUNMdHdPQk90NVpsU05wN25XRUdXQlpiVGpJVVNFekpyMGN6dzFSRWo3SVFqYUxSMVg1NnlsYkNUQmlrbnJOaVBvaDE2QkIweUluOHpGQlpoY05oUmpUZEJqc0dtRElZTkRrZmpwbTJiaWVqSTZ3elZHUTVDTVR5RSsrcm5YL2k4NSt1U3hkNVZvQXZwNWJ2NFlwNW9qRlBUckFPSXRscXc3RWRoZnE5cFQ5clZJclRoYjNHY3ljcmNXKzBmQjVsMGVCVWNzTnZ2dUVuNW4wZU9WSTlVQlVOb0N1Q1ZUUnVmaXM0a0RnNXZzMys4R2s0elFYVG1aUHUzbFp1OFU5R1pQaTZaWnlzUGtubUVXZUloYk91TVVOck5OQ2Y2YVVJdVpUbi9jWXRoSHBuaUpTQTh3dkNuVWlqRExzTzBHSjV4Q2VMYTlxWjBvT0V6SGhHQXhPOTZHNk9rSUxxSVIxZWhpK3lMTmZ4dW5RWURJY0tlaXhzZmRmemNxUkxibjdwWXZiVS9kZEc2ZXFHTnhsc3NQd2NKTnQ5NC94TjU4aFloVWlEeUxSY2lPYlc4RzQwdU5RZUM4ZjVzZkNYS2hOVGZBTk4yKzBrWWdxOUtmS2c2OEFlSlZ3bXJDVFUwV0EyQjhlcnhLcXE4aGtpejliWGZVRU5NRk16YWs5OFNoRmNsL21DZytxSEVxMkRvdHhNSFE5WEJFS2poczJFVDJwdnppR05XSzF2eTJDSVp2S3lzdmZvUGpuK291bnlwTEozNzBIR1VvZC9abWhmcUY3NkkzazhsMEVUNUlMMERiQktFYjJ3Qk12MWhqamhBZVVJeXNacGl1SlltaGNhRVRDbzlkdFVOdDU0VTFKVHBaa01hd2NFZG4wb2xtTm1EcWNLQkNaR3pudGczZmYyaEU2ZmZjS28wRnJHQUJHRnd2TUZiT1R2ckdnbWhmUjgyQUJ6S2FwQmhEUmdxenNrUjdmVTZ5dzg5WjA3dVpmTmhoZlNoUEtxMzgrQWg5QjNRR0swOGZyc3Rpb0NDUk1FT0RGSTNWTXN6V1ZtVVQ3RkZRZFpXUEhackdsUDE5S2F0ZyszUGNud0JRZzdzNDRROGhPZXBDZXNNamJnNnQya0x2QjZwTVVFQmFUUkIyczZ4M3ZhVlFCajE4RGlHMHlXVDU1UmZyMGxJY012UWJmSkUwTXFWZ1Q5QjNHeDU3Smw0UnBBQUhwUmRBbTRBWFFGelBiOStqeG5od3B4dTNDbTc0dUZ3dkhXN2N4L0tISmtSYmc5NE04T3lZMVJVVVJnV1VzWXR1cDFLTldmalk3SDREWU43RXlPNVF0bldiekZTd2pESGk0ZUQ2dDdCRzRCSzUzL0JYM256d0QrT0pqTnlTcnZEME5HVEl1YXhxNjZjbVkwM0Z2Y2VkRzV2emZiUDFjMWRCdit0M1ZkMnBIRDFsSEpINnR2aHVaZnQ1aUJRQWNkTmNpSVRUWTVxYVpaaElnems2eHgvVVFiY3lPNlh6ZkZjbllmb2JJWk5hNlBKS0NPaXUzRG9icEMwbmYvMXdoZkFsOEJueUF6RWZPQjQ0RzdVZGtqOFE2bEZJY2NwQ3crQlBQQk14aERKeXVoVExBdTIyM0l0ckVsaUJDTU1Kb2dwWXRIRkxSbzFnZDFyU2ZkTGVJeEpkOXh6TGhtelM3bS9Ud2h4SXl4SllTTXVKQVJGbTlTeXlselljY0p6U2hadEtIZlZDNFY2S3pGaldUT0pPMVFXc0RKNnNhektLYXhsc2NyMUtzdUdJNUV3eTZxc3dzWlRxVGlyakN2b2hFUUNMUlIwVnFuRUt2bjltZ0dZb1NFR0dOcCtQU3ZsUlZhZFBYYk5OY2RtVlZiTVM5bEMvZTJQTm5MN2hQcDFkV0VmT0lCMmNscEI0OUJaSE9DajgxRWVvT2RJbUZaK2Q1U1QwS080MUZYSHJrcHg2RWt5bXoyZVJVdUY0MFplT1VLbnFBZ3ZlZ0MxK1RTMnVWTytIb0UyZFQrd2hEaEZVRlVicVRlWVNnRXRDYXdIK0Z2U0tnVlJyUXhmMDlQOGpGZWZQalU5YTdkUG9NWjM4RVFPdGRkbTQ4U040RVA0RzdoRFM4bVphNFo3MnZyc3JqdnVmSTBSYVYrSkdudnUrSlhvNjNqWmpTY2FUU0xMZjR1NUFzbGJCdW9weWtoU2JQWEVodmkrRFVnVHBNQlVEay9kUExHdnBDdVErSHEzM01RQk1lSFZIc2VGTlR0VUQ5bmcxdlNSSTNPT00zc1VMMy93bmtLNTJCVDR2L1RXQURzd242ZHVDM2gxZmpXRnlRRlN1OU9PTTBldVE4dndlMXlCYnhiTHg5N2o4Z0phZXp6Zk9EN25BUFpKQWZudU5KRG5ZT1pWcTVlMDNRNVpUTmp0NVkyaDEyRExERzJpR0RpeVJZanYwTHBjYzBrL2p0WmszZ2Y4MlV0aU10YUVSbU9jSVRWTWg0dGFvUVN2UzJYVFp0VndXR1Vkb3l6cGZDSmtSVG5IYkVnR0Z4dkY1OHV4bDhSYnBtV1pyZmhEdHlhelVsRzNTd082YWVvREpWc3ZTdG5rclE4bEJnZUJQazRDenNkRUtXYStqV0VHMGRxWTBUUDZqQkdUeEVHR2VadUoxbVBrbkhITHRLcm8vNTZQbmdVTUVIWmZlKzF1QVNYT2Z0U0tXSjIyaHV0bmxEQnc1enRWMFUxdFM2UkRYUTFKSmRBSzZCYit5ZU1uY0trTmg0M1dJN3doamFIeWgwS29uR09Td1VmcVVWUjRYT0lUeHpPdGJMYVZlUUFWOUpGOHhEUWorVWRRQVI5SURnMEI0L2R3MFI0dTRJTGRjQU11VmVGaFhLYmZDeGNIaStIVnMyY2IxMTdiT0h2V2p0aWV6d1BWc1pSQWhHSnBkdkVvM1Y3M2syTHZCQ2k0LzZ3YWlhaG4xUWUzVjVTKzhUS29hZWMwRGQ0QkU4cE96aWcwYnVBcjRNc0JEWDBQZ1JIZ3o0KzFpbk9neEp1WUpSNTFXTHhRQW8rMzE3VmN4RVdkMklxaEtPMEhCUlpjemJMdGo3SENQNTJUK0tqZFhnbkZCT21jbE1uOGQvQW95NEkvWVFUbVR3RHJ6MVZnRzFRY2FaRDltTjg0SnFEV21HTTZvT2w1eDJmaHlEZXlaUzhNTk8rdHdlazJtZlVWQzNPbGFtbXVJS0tOWElaOGh4bVFXZEpzN1FLbW9hd1NlQXNjRTNEa2lEQzhyMHcybDZ2MDY2dG01ay9qZTV5bXk1NzZ6d2VxV0lvdVhvWWZyYnVqanhBRzdUcE9EQWpFT2FTVGZIQmJqNkZ6Vzg3RFNXZW45N1haZDJqaFVyNURsK1VSZkRGL29wWHR5N0tEYjVHeGJXRUNXL3lNOWw2R0JSdGVUdFozdG5Jdjc1RHhIWTNma3p2bnZTUG41QU0xSXNOZFJ0WXVwVzJCSFdwMloxVnIrNWJ5WDNaV3NrQlB2Z1BGeTVuaysvZ1Q1TlpQNEZ0M2s5L3UyL2FTSG03TjkwbmMrd1JCOWdqZ3VBZHNXNWpBRW11NVBzZFEyWldhRW1nSWtzYVF3S1FtUll2Q1F5L3FsVW5VSUVGejhYbzRERWdCa2ZCT3IrbUNLd3dKQjRNUXJrSDQvbVJ0cHBGT3NJeklBc2k0MGNIOVIvWlZvaTREQVlzMCtjUzlDM2NqbGVud0Fzc0w3R2c4MlRoNTE4bkc1Q2dyOE96ODRkMTNMOFNMeFdheE9PQldLeVB1OExBN1V2bHVxcFppMHJYMFlJYmpGSTFqV0djcU8zREZBRE93YnlBejViQU1weUVCSndOQ2MzZlBMNzBxZ1FUUkxNdEVSOGJ1UHRsb25Mejd4aWpEWnBGSW1YaGdhZjd1K1hWODYyWXg0T0dEWXF6VDRjRFJ3QzJCWHdxOHpmTjdod1R2SGRYTStFUllnSGpRUVUyREdHQXhSaFplRXFXcVdmYUlzbEFONG45cThzelNZTlFtK1NOMXh1WUVMOGF2bEM5ZnB2YzhDQVJURHNmQ1JEamxaaks4bGN5a3d1MG53M0UrSEU2WXBnQ2pTVXN5UWlEdERsZmRZRlRLR1RxTXlTSzAzY1JvREV3T1RJY3R3WW1JcFp4aXBDdjM4QnhyTnVlYUpzdnhGVldSRk1WVUJBSk0wYnNCem9UaVNVVlVVdUZFSkRkaEowZFNpWEtHRStCQUtDekthaWt2UWlQOWttckNsRVJHejJWeVppWWUwd2Fiby9IcGdjaVFscDQwS3d1cTR5VE5jSHRkNGlMeGVJU1QxZ1IwYi9RRWxTaHBtelkyejVGVHpOelppL0VHMEs4VXZtajJBR292UFVNajhWNWZpR2RTYnNHd05mbWNyTm1iT0FSNm9XY08wVmkvRDBvV0FLYkV4UXdMajBTV0VmTytXWXpoUHVzekMvVk10M3FtT0tLVmxJbWZ6K1pndFUwekc2Q2U0dUY3VHVFUDlsUTVsMHF6RW11emdCdXFsM2JuS1JRam1YSUhHSnNaZFNsVHYwRzhDNjVLbGl3R2NCR2tQcWJUcmR3eTJZa094VDAzaFVDWEMyd2pVQ0JzV3ZnYnA0TWh4bC9GZmpPd1l5RXVlZm9kN0RlK1B0eVkyM1B2Mis3Yk05ZmdaUVlqR2c1T2tGRnVZcEJEdWd3am4rNWh4bnRYN2hVTGVFQzg5K0ZYNUJpR2MzaUpTWnk0QzQrSWQ1MUlNQkp2ODh4M2V4d2Z1KzhlMit6enFDWVhjS1JmYjV4V3o5elhwajZ4SzVkMDFOZ081NGlaYldVYjJVZTI5MitJWTBZRkNScFdFTXdITFFOSzFtejdQTUR6OEdCbGJYdVBCakJ2QlZlZzFENUxxQmlXSmJnU3ROcFZNRit0ZHZ5dU56d3VpZDI5RWxOL3pqQjRDTWh1RHZ2YWtzcUM5UzA1Ykw4WnJLRDh6YmZQSDhlNU90NjdCQm13c1RWNzFXcjdUSVVZY2FvOXk0bzNiL3hGMHRmbDBaYzJIRmdpMFVzTkdsaUpjOTR6NXRBR1d2TzlKMXpxUG9GMXJnNFdNbXJublJPeGgwb0h6R2tkN29MeWY1TzF5cVFtTDFFSXpTVlptMncvK2ZIaDgraG5wVXJCTmFzSm14NjBFNkxIVEI2NFIwYlhhdkxqazVWSDBQV0VEVWlUSDZsTW5obCs5L2xsZys1WXRST1VFd2lURy9qazQzeG56ckZBWW9CbkF5YzYzMlpmczk3a1hvTDBTUHhha0JLNXhSYUZkQTFLTUlpUERIbjJaSzhOTXVJNTB6M2ZaWTlpTW1TVmFaWGJGNTVNRGJhWGFWK1RwUzZqN0gxRlZtT2I1aXR4dG8vVE5NYUVQdWVhajRBSXZrWDdERjVXS25oNUJ1a3JaOWNHVXhIYUFhMVNuOVF6QndYaDdod3FMVm1UaWNxdXp3SEc2enNSK0dOVTR1cTRBSE5vMk02amtiMUwyK2poek5tb3V6UjlDQ2tQaUs0NTRVRjEwclBRWUQ0Tk1GNGJCYWJ6VHNYMGloNlJQYjZkaS9Fa1d4MmNLdjhCU01iR0hYSWozTG05cDZEMzNsOGdOOFd6K0VTUCs2VEM2SkNUbVllakRnL3IrWEk2TC9HS0FPYUtJK3l1b1pJYjUxa0RWV3N1eFRGUTRvU3g1QzdYc0F3UTExaUJVdzNKTk5HcjFFT0puQU5GWGdxS21wNHlURWsrSkhNc0EyVmVUQ1VPSnRNaXVpSExLamszTmwyc2t2dUZyWlFhUkhlVU9hR1dueEVVclNnclFsaVF3NGJ4V1FoYXlZR1lCWk9TYm1ZSHJIRE9EaW02eUlaRVRrWGZvYTdwR1VXR1lWNldGTU9RVVcrR25obzBoaVVCaVRqczRSREhNRkRoeFhTeWtJbWxCUEUzOFVOWTZDWWFqQ3loTEN1NmJCb295N2FEYml0ckltUkZBUGpuWlZrZHBuZTFNUkZ6VUJBNVhCaWpva0E0bGlyeXFNRnc2UnpCZlZBNzhpSWJnRWdYcGVnUGNUUjI1Z05qU1BKdEJRTFl3OGF0T2ZrV1V0bXdWdzd3dDlHLzZYbnk0TzBHUnF2R05tclBvV0JqbzdLNitneGV0RStUZEthS2ZnRDZyMlRXTXBtVitVd0cvWjFIUng3YjJIZ01uMVJaWFNiSG4xakxyR3pnY3pKOStQMzdjVFRLem5PUkxhOWg5TGorZVVpd0dIdUErSDlnZ3V5V1IxRFo2V0MybjZKc0dMS3JjdGdnd2tORGNoZ2RDVWhwUlFxeUVwZmdBR05WYzVGcWNvSGkzdTgwY2ZsQzNGS0NrT09oZ0VjcXlUVWtGVWc4bEZRRENpYUxKRTVXNXBCWVU5bWdvUHY5bVA5WFlaNmRTMkgrbDMvR1V1OU1BYkR2eFpSOFIwNkF2Myt4WmFkeCttL3dlQUp1d2pZNmdacE5hOFJoUjNBNm9iaCsrY3E0QlhpVy9aWno4ZkkzUGVaV3YvdDRjdkxhakNiYVJkTUpHVEZDbXhRTHNrTEp5c1pqeHhyVWZkYVY0QXlVYkRYSjJGRE9EdWlLeVFYNUlzOXdrWFIySkRObk9lRmd5dVFsc0RFNjVrem9pV0N5b0VSRHlRb2xVcW9rZFljTk82WG1TTGs0M0s1U3hxV3pJcDYrVnRLT2FnQlZrRlhEa1VVSDNUREJxWHpCdE5LeFJLWVkwVUlTRnJyd0dQUUY0c2RURE94QytqTnREY1NjU3FmNWZGaGpIWVI5MUdQczI0emVORGxHUkVhZGdQYTBzQzdSOHZIMjRkWnBFZWIxTmgvay96SEhLZHl1UXJhV2NSeERWeVRZbXIrL21IWjE2WmpBc0lWLzVKbjJ2ZHJReEpWUUhHVTVMaFl1WnVLWkdVazE5NVlqRE04TU13enpyazB6S09COVVWUzBqdzN4L0FFQTFhZzVsSzhWS2xrVzlhUFIwWFMrd3FqY3lNZTRZUHMrUlpSQktsNWdKTUR2U2ttUXZUSVpTYTlOcFBGTXBBREdKZzlQb3I5M0pzb0o5T2ZiRlhETTlBZVF6TkhDaktJdWhuUHUrZ1kyUFhoTURKRzZlUk1QdFVXTUV1MGdaUXoxVXQxazlXeEkwMEpuY1V0MmdtSGR5b2VYWDJxcHVwZStjeFdwZjhNajE1L2diejU3d1Z0blZEVmhvd3RraUdUNUJUZkI2VGNmRkRzYjFqdGZ2bVluenQ0d05XTXN4SStkWGZNVGZ2Ni83ZUc4a1B4anp2WWVkMHJCeXlrZTFUWnZFdEhQSnJOdExkenJkcFBnM0tVSzBQNXBYd0hBK3M5WUFqcG4rV2J3cDRRQm8wb1FOVWFCaHd3OVhxTElGQlNMc2xsdXV0aXBBT21wY3d3MittUEd1VFFRaWhxRlU4Q05kaHJrNlZqUG5JN2Rzam94TkNucGc1eWd5SzlGQTE4T3hwVFg2Y3pZcUI3UzFOTGg0c1NNOFB4WGpOdjBBVlVURlNZS2dzbkY5RVFpeGtRaUk3T0xFTklrZUhNcEdjNmxEZy9NdGhnQTRQWG9IbFYwcit1VWtBN1FqbGcwZit2dDdkOE83d3VQR0JGZFpiaFJwQVBFSWxkWGh0S0RJQnE1ZW1BdzBNc2I3YUNSY0EvRlhpWjJINHhSZ0preXlSUXNrbVJiM2JnTWpHVkc5QXJJZGwxZ1d4WVdheW1hMlU4T1ExdFA4OXpKOG1GVnQrRmgyRlp2WEM2ZDVQaFg0SENrSDNwSEx4QUd2VmVnQkQycGVnQ0pzQlh1MXNIcnE2aEQzUS90ZjdsdTRGYU8yR01HOTVORDdaK1NMUTV3VlZtREI2RHQ0Um0wUFg2R1M4N1NnYjlvMzBaNjhkOGxXdXM5WkNSNEYvWmt1UWdoV1FmWEQ3ekowN2NEZk4vWVZPeUZLa0RQQkc5Q3QzdVczQzZMYnZmSDZIWU91ZDMvWkRpakIwUSsxaHNHUmNyQ3JCRytnRXhYSy9KMVh0YURXWFN6VGVxdHlpdy9UM0tNVWVvVHNlZUp3czZRWElPVnBFV2UvcXlWYlA4TGk2T3dBT0RZYjdBYy9TNy80NFhQTXp6NEUxU1MzUmdkMC9LR0R0eXRoakVYV2hpM2JMb0hOVjZCYlJHOEtuOStDMlBIZDNzaEpKZ1VPMU5mWWNMUVRMMWhLWW9mbm8zNHF4UWpjdzdLWENvMFB4OGF6a3NtRTJZVTRiakNTcmxoS1pQNTBFUk9NbG1IVWVCeEdlMGF0OVJHWVM5dUczdERNUUY4TlkvR1l3ZHB6bmxKaUlWV2JEalA4L1BRWGlrMFZQRHFjWFJYUExVN2prRnNEemk4cWx3UElicDdtTGNQNklyUy9xY2pEaCtVand0NG55TTQxNlQzalJLOTI4ME43RUtYQmxIR2RoazV0NktJNGp5bmNmT2lxRlJHOTFINzRwOFN1em1PWVlXZE1DazZ4NFRyQW5iaXBQQm82ODIrRU52RVB6UnlOMHdRVVl1eWdOc29mN0U5eFFhMnB6VXEreE10WGhEZnlVTWRmS0NSTCsyNTcyMzNVdFp2RzBuQ2tSaXg1cVhpTFF3UjgwNlJVQktTdktCdjlOT0VuUTg3S2JpWHpFOTVNODh5K0ZHQ2gyenVudms5OXkxdW02M3BsY2diY1kxdjRBLzBDY2pmWHB2Wk5tZTc2NnhIZHJGQjdDWGNKdnlMRnRIbWQ1WmJTeGhhYnl2cHNFdGpMckV4Q09zMjI0dXBrNm9SRFlVbjZvY3gvVXlaaDVrcUM0Y2d2RGNYZHcxako3bjBTRGcxTEpjakE4T1FmNDVFSFp3VTFMZlA2eG5USDUvK0duV1VId3hrVWMrM2duSk9zSHVJOWR1RG55ZjJiaUtKMFdsOXZvNzFQQThKaDhKTDVpa2VPWjA5Ui9yZXRpR0txTENvekEzd25mVGdGWU9mMVBuakhIZWMxeitWcUNZdFZMY21wN1NQSkt1SlQva0hQb25PU3JNS1o2S0Qxdit1NnVqYlJXcVFLQ0YxamNBTzcxRkJZcUErc0c5Z1hoUUV6S3A0WEJERWVTU0xaZU9jaEc0SFZsQjYwekYwYm4wQTlac20rcGJpU2w4WUk3cXBQeGZ3NTZnK1BoNm9CSzdCK0FsRlVoc3VkZC9vQXZJVG5rSDhlanM4STN5SjFFc2ZLQ1R0QkRiVlQrdGl0Y01FQnE0WWVMWkYvVHRPYzl3cDZxcFJleFlWUm1kUU5mRUtHMjN2MXRIbXN6VjYxaW1PTzAzUGFqMkxMbzZ5Q28vcTdQM2IxZGdHT3Q2aTUySzJ4anVvQTI0dFVaMktjQ0t1TTc1NGUyU3FtcWhSckowN1dKSUgvSkFXdW5LMHlPUEtFNFBiVkIyenFSMzlRbHJSejlSUWZxNDI0WTF4M2ZmL24vRDIrMTl3NTlWdDg0SzNPYXY3Z3Z2ZXBmK2V0cnpMYmM3cGVaZCttLzgyMGozZUYwZ0ZKa2lrdUVzQ0ZMRVhCQjduV3ZTMTRYaHdVcUxkd0NGZXFVUzVJaEQ4ZWFlSUJrd1h1bmpFTE5WL2RWMHZKM1pOc0t3c2hDdWhjbmw1NXY1RVdWL1hxdXRYRGUzT1ZrTEJ1QjIybTRQTDdTK3M2NVhnbDc4Y3JLQ0RmN1N1eFozOWpHM3BXU2N2QjJOWGpOMDZtT0VPT0hGdFhhdlk2dzhLVWl3OVdVcllvWVY4V3BVZS9QSzZ6dUJMR1hScGhkcXlQa2N3aHpHaWpWOENZb2NpUmZETVRSY3BROW5SenFKczc4OWxCQzRvT09YUWFDeDJhdi9ES09ObnRlclprL1ZENWJHb2xZbEVuZDMxRzc1d0Z1WDFhazdYRSs2UW5WZlUxUEJvODc3eEhIY055dTFabE51emE1S1NMaTZPRmxQT29lRnlTRU9pbWRlMi9wVjVCWGdIR2lWcXFHMkZ1L09MWFVZMHB6YmhkbGpZS1RBZHdhZWl5TUxnTGFqUi9sVFdsa1NCOTVrNWxwN2kyUjh0YWZKUFVidU9zUHhUUGNkbU1HbkdOM1dla25WOG5uTy9LV3M2SCtFKzcrL3k4dlFBeWxQV2wzeTd6YnpSWlIxSkFzOFJrU2ZBZVAxTkhHOTdodEV5czlyYjFsRG1JalRQdENHMm4wTlozS1pOMHZ6ZjB0dld1UWpPL28vcFY2QngyM3dPUDhiRkNRaElSM21CMmVQRm1ZOEY1cEQyZkNOR0E2YlR0V2svV0JTSEFKVTlleTZTVlhxM2RTK3F5ZHZHaDRsWVlSSGlQTWdLNFN3T3RXYnB4VllLL0JnTnBKaEhENjJtZVRFOHdBbTh3S1hSRWdoS2t1WFJyNHNFYW9hRExvc1JSeDBCeVo3dGYxL2dJTGdkZGNzSkRzbThFUHhnQWNsazd3WjhnbVZQQVJnOHpRc0NmNW9YeGNjRS9oREg4OXdoWG5pUTV5b1lScWpDOFVzY1k3T3NnSVRiOWpyUGdWV0c1OXEvSVNpS0FGN0c4V3o3MXppZTJMSjl2OXNLa3RybTBEczloQ043S1N3a1VsWW9QeUNXWFFXUElLRGwyTFJubWdWTnZsVVRvTnVrckVDZHo4UEZlbWZETjIwekFRNHljaktkdk9uWUd4V2JueFNFc0xZb1NSeGNnckxyaE9MQlZWbGRhVGVxMXlZVFNuWDNsUWR0S1loNkszRGl5bGQrWnFVeDVCa0xscE9wbE1SQ2JrV1ZWNFB4a09QSzZISk9raGExc0NCTThyYnl4bVA1bGNIbXlWZGVlUUtnUGpFbzJRZXYzRjB0VncvRlUvK0RlbUY2Y3hLOW5KbXpnYU9Yd1R6UklZTVpaVHdCc1lZNk9vOC9vMmNmNCszYjBXdngyNVQ4K0daMitPQVFldkhjMkQ2VzUrS2NjSVRaODRvOUxOclJQTmxpQlBTdUwrckJlSnhTSUk4TkhSeG1CWFE1eis2dGNyekFMcTd1UVM4NHdRcE02MlFUN2ZEa3pHZkJsMUEvamYxZ2g3QjNTR2ZDb2VWYmVYaGlhZmRMUVJsaXZBOXptOEl0MDBtR0lKMXlBSWZabVYyM25YcUF4RFdmdUw3ZVlJbWU4QWg3NUczTGFCKzM5OTU5ZE0reWgxcENaeG5lL2NBZHQrNmFvVWZZUnYzNkV5UXcrcHEzSHZGMjdidDNMNGRuN1dpOE9SNW5xZ1F6aGM2TjlBTnk3b2lnUm9LWjhhZjhyM09IRDg5OTBBdHo5YkNsaUM4WmdXejUrRjJWMGJIS1M5OTY5UnV2Z3Z3emtFL3hzRVR5UWJVcGtpejkvY2cxWTBTbmVOYWZpd1g5Z1dTOUdGbWFqeGxOUFZtYVl6NzRBczFacWV5QnNoTWl2cHVUQTlKSFNFN1kwZEpOU0ZQL0pNZk5TZ0o4WDNEbWFwYWNOeW5hWU5XYi8wU3FmTlNsQUVoRGtNOEw3SHRaZzMvMHlsbXlLeE1KYkdyblpzQUpqSHJja2VWTnlqZHE0bVVuMzdDMlJvQzd0Tmx2c1FLQ2p4M1Q3UGFQL0ZaNWR1M2ZhZHNlMU9TenNuWTF3MzI0VUs4djFlc0Yya0RCM0RHdDA0cFZlMzU1dWIxTzJ6SHhzanAxTmNPMGY4cHdUK0pMbHVwcjlOc0lCTlNPZjZPN2lUdnkxWUUzQjM0OThON0FSem82ZnJvN2Rkanlva21kYktQY3lMTDV6WHBjclcrN2ZLbmovVUFDZnJMV2srcERtL0YyTitqZGVvK2c3Z0RUekxxVXdOeVZwSExtaFVBR3pEOHhqK2ZmOE9MbG5kUXZiYlB2c3lUYUVDOStpOHdTejgvVGFhcm5xdmdNdlBpdmVDOC9hK0J0ZzhUV1MvQlRRY245SFZ6MXYrTkt3VTlCYVNOejltem16QXNCZXNYbXhjcDJPNnNTek9BSG84VXplRmVFVEIxR01tamd1RUJvSW8zdTN1NmVRRURzZTMvWXgvMW80SGJDK25xcDk5Wlg3OVpsMXZ2MjcyR25lajlQU0gveDRsVTcxT2Z0blpyY1EycDI1L3BzbjVNZ2lXbEZDL0RZenRYVVgyVTR2djZGbjNweHVGM09sWHNDOTZGMi9xYkFyd1VDNEJKdEZsNWl1Ly84WXRaRDZ2QmN6WDBmWU4vUkMvc0c0cTZ5aFd1NGhQdUQvaHd3RHhKNjBCZXphUCt2RndLcGVtbzRmMEJXekpZU0M4T1pQWFlDeC9PMUw3U09Iandxd1dvaFVUMlBrU0RPZzBybk1yRFdiWWIwNVpERmVuZnZSbmR2enduWWlibzRMYi9CTE1zWklhaWNUdGdlZGZKcTVneDY2SHkxVkMrMXozYnY0dmw1WHZEc01MbEF3TG9JQnFuWEhUNjNMYkxvbmhnR3FpdnRBQjc2Qk1XeG8zTllIbzcrS09hR0x2YkZRMXBVbXA0RkhiT1VCOHBkSTZJMHU4bXJkQkx5MVBtT2gxOXprWmo3YWk1eFJXbnFsa2tDR3hTUGFCejNHdmJNME1Ick1CbzJXdnkwQXhmUy91c3d4NzJhNWJWSW5KdzdlY3RVNllvRTJpT0QwSkIzOXRCQkh4dWI1RGNmV0NTb3BwZmg1L2hpeTdDM2Y2emRlL25sMlh3VlRsNTIyWmhPMlZJNGdvL0hobnJxVzlpMUVUb2QzYnpZYTVFRHo3K20vd0hzYTVDQzRiTHRjOTFuT0s5aCsvUC9hc3hGS0ovdWxvSDBBeSs4Y0E3bDQ2T2RXS1g5Z1N0UlhSOUZHc2tkMko3Z1NaK2Q4YmdqdU9VN2UyeUliZHV3QThlQUp6azdDNDlMR1ZQalpoM3l5L3JlSjNrL0FSNm5QakhIcVl0TGs2NE8wdFgvSnFBZmFucW5LUXFJQnRiYks5My8rVTFYVnVsS28zYzlRMWYwYnltb0tNRVZzaUJCczMyYksyZFdxaXRnc3ZlS2Jld04zbHdLcFd2RjdLemxFcDRQODZkU1lJT0VyYm9kMnRkYUF4dmdTK1ZXR1FjV2hXM3dRMnh3dUg5bXVWd09WY0tDekxJVHU0akI0ZHp5WU5NTzIvRmdxSkxkUFhUVit2dDc3QTAveFBhR0ExeG04TmF4SzJKQk9lOWtkY3RtOWxON3c4Y2ZsTlIwZmlGa0owcVQ2WmdrUExpZTIyeHYyQndidFhDWmVzY3NLQXQ1RDU2cjFmRFlBOG93akhTdWlmQ09pc1lNVW5mMnFUbytwcXY3c1BwVDFoWTRia0VySnk2bVdaQTNJT1JFZElHSVdnVldtb0taSVBwTDlQalBiWGd4N3pOZTIwUVZYS1pOMUcyVituUElkcFFNUDlHWlhBYVl3NHE3TFhIMTVPVFZpZHM0UERHTTFwS0U5M2dzWnUzdjBiVzN5bUFTSlYyYmpXRkFxMWxOcDhoV3M4a2syZ09XTmpHZXJYZFVQZy92WThHejg2elFDRXJhZG5ac1BjTG0xdE5xdUJBN012cWZseDhmVHBnM01QbGk5MFhpNzQyWk9JTWExNEZxSTFVWXFZVEtEaElObUlGeDFMek9hQnRMbFhFVEtVS0dYVXJQREZ4eDVsV0tMS2orQzNrTEQwVTd4TExYK2UrUkI3a3pxTWxOc2JxWnJVeVBYQmxWbEx3VER4b1cxMFNON294VytjQnBJQWRUbVYyR215elVrcTRzZ05Obi9nRXBoUkFPK1c4WThvUm9tdkU5T0dLY1FQdSt6M1hxcEtkR3FPc1dxWkFtVWZSM3FKRmF3MlVtc1BIcjRmMm5ZckZSVkVnaHlBbVozSDVpL0RwL1EzMjNFNDFrck9oWStWRDk1Rm5BWU92WE5WeHUvTDdtNkhCS1ZmTDJrSnZRZGU1cWF2MzY2aHJRUXVYaFEwNnFPTHBZVEN2UzJsbGY5OFA0RGdrY0gyTGwrNEx6ZXh4YVNsUW9wS1BScG1rUy9GMnR6Uk5WRC9Ldm56c00rWVNzalQ2Rk51Y3JvNXFjNE9IaHVkZmp5WnZUSHM3RDQyalAvT2Q1cU1rZkhSaEZnMVA3TGFNREg1VTF5SDkrL2pBOTdMZXB6NEovQVY5RG1sYVNzR3UwVEZRM1JjOTNoUHF1b1c4QjFSMmU2WVpsU0YzaWlCdkd2ZStjS1ZiQXEwdloxdWhFS0RTRm1rbk8wRFpDb1EzTnFHNXNKR0lqUXhQamc2T3hKTWpNdFArc3VIdngvanV2VzJxTzJLTG8xbG9Iajk2c1IvaGxVVnptSS9yeThqVkxpK05qamowNnZuQ2dKMDh1OFFqQmI1V1FRSGlzcjEwZ0c1bzdMN2l1dGNsKzU4Y09mNFBtSjVkcVZLZENvWW5SVnJaa25KOFlHb2tsTmphU3NkSEIyeitDaHJzYldEeWFzVFB2UUF1WEJYZDcyYnI1NkVFa1M0cWlQZEpjdXU1T1BkTCtaV2RzZkhIcG11WGxvd2NXeGtmYmY4aHhONUFyMk5tM2svSFFhNDlJRHZzcXlYdWdKN01vYTkxQ1dEVExrQmJnQjM3R3RDOWFmbWF2SkxrYkp6bWQ2V2FCNzgwYStBVE5pRTJ6NWZzR2Y1RlpROThEUmhDN09uQURaa0tiQStqcGphMCt3WkRBc2hETUgyb2JtU0JvUU1RYVJKd1lxVmtnVnk2eEdJQ3U1dUQzNFBxTnRkeHlJZmp2QnpYZU5DYzF1YXJKWjJROFdrNmFKcThkRE9XTERkd014NHVWTkQrU1BKTWM0ZE1EQllLSTNTam0vM2wxZGY3Q2FjTTRmZDRLbmdsYXA4K2RPNzF2VHMybEJQdU5YZmZWTjlwQ0txZk9WY0xVUktBYitVU3BsTWdiT3AzQWRjRHJJdFhyQzRKUStDZnN4VHQvZkducGVJQmdBbTBRWFdRZkt2Mnh3RTFJOG5nZzhEQ05FZG1CQ2FYSEE1MGlyT2FSNUFRYmVSSk5nUG5qOGRMelIrNkVWMk1STU85MmZMS0lnYkZSSy9aTmJyWTJxNEUxWnRWd2pqbXBRdGE5NEdhSnZ6UlJweDRoNjljSGgydHVGWTBFYStpZnFCWUQzcWhSa09HQk44elRqWm5nWUxTUVFQcWFkeTFhUkRvM1dyNC9oZTVmY2JOWnQ5TFZKb2g3YlB2SmNDdzRzb1pISHZ4UElYdThxTzU1ZU9BQ1RkNWh1OUVEa1k3V09OMjlDZVc4cFhVcm9yNEMxKyt0Z1RzRHE0RUhpUWViTnlqMmd4RVNIK0dldXZjTk45UGdJclhieW52QU0xMHh3dDIrd3M4TnpjNWVOenZyYS9zR3FRelFxZVgyT1Z3VjRqWjEramxVMi9YaG9FTzBXV3drMkthT3dXbDg3K3RtMTBqVmV0N3RqM2VyR045OXUvcGNDY2RpWVhwYm5qMitxVzVQYlBKL053TVJ6S2pwbzAvbU96SVV4am5KOStBYUV0Y2FEem1PWXZHdEVKalFsYkVzeUdUSHptZkgxc2UrYmdYYjU0TldGY21aNitpL0N1WXBkR243WEhZTW5WWmRwaEN5eE9VOVFEOHl1dlR0YkJnajczMkJnY0FJR3FYMlVZWU96QVNEeE13c2hqOFE5TzRuNDlKWW5VNzBMY3lXczlDaFloNHhNUGVrZS9jejlRTnZFbXlkZ1M5cGYvY2xrTkZ0NFUwSGNKOWd4ZGw0Q053ZFFpc0xiZC9lZm5jY3ZQL1RWR2hlcGF2enZxLzdZNUFKMnVLREQ0cDJrSUdQa2M3Z1Q4MUl4UHhUa3J5QWhERmNxcDBXdnZ4SDhCOUdBazJDdFlnazJISXZONTVGb1VucjVab1hVa1JZMzFBWlNRQmlxWU5WV3VzMFIzU01xYlJQaTB4UUlsRXB5MWVFaXMyaTlDNEpMVzNBNmtyN2Y4aGdTZ3d5STZ6ZWZpL1ZLZjZOcm9MdGI2VEJLbGdiRVJWU2d2YnZoQnJGWXR6VWRST0hjbG04RXFvcTRqa2wxRDdkcTBzOHVZN2ZtK254cXJ3UGpUYlVmLytLRGhQMUx3VmVoM3ErWHczOFZtQTk4S0hBeDZnZmkrZks0cGcxazRqaUFyYWpiSnE0aFNYaTlOWDVvanNPL2x2b2dGMjZ5Z25iSE5wNjFjNzNxVzNaMHcyS3UxT0tMS2FzOFVSaHJsQ2R5R2NpS1NZdDBybXdQeWFyUjBMRnVsVkhIN1ltU1ZOMHRaK3VQa2hYQTNpaFNjdWJkbTQrODg3dHRyeFR5cHRXNExRWVVWWExLY3dXMjM4Q3BnbzFPM3NpSTlFWnVUOG1xMGVzZWpFMFI1K1oyVzVsMER0SkZ6bGxmcnVkMiszRE5rck05d3NJLzF3K1VFWnRvQnBvRWV3NG4xL0hHNUYwQnZNaU5YY3pIZzJkQTFzUURlQld6WUd1anNaeTFDNWFybEJxbFhjRGZLUUducW00NXBKcjVsV0x2M2ZCMXZWS3EyVXYvS3NjZEY5NlEvTDd6aEhuYUhpdUZ0c2ZLOTVqQVAwYWMvU2RzZjFISjk1L1hXRUNCSlpNdDJLNlFmbGZGK3hXcTZMcjlzSzl2S1htVFhkK0xubkRYNk5Md1dzbkNyR2orMk5YZjk4WU5hOHhtQlBvUHRkZFdabnorc1lYVUh0K0U1S2ZVaGgzdytxZEZpR3VscmlSYWhUT3B0YXd1bERvL2tpN0NRbjNETlhGaWNxaVlXVm00OHlaTStlUEVWOGdmSVNtVUFjT2x1c0orN2lkcU50eGdCVVNkREtJLy82WlU4ZFB0YytTenpKaGIyQWRCS1VtS3h1VkRwY1N5dXNhUlFqSlhpSXIxRUdpVTVyK3J3NnNiNU9yOXJNV3g5MzdFN3o1azNzNTFrYk4vdmRaOUNkejIrVUp2QnlmY0E5eDBMcUgwcVIrQUswK3dISTBYcE53aDQ0RjdrRWo5a09CUDhDMmgxRUdrdENVa3NhNEd1WTR4Zk0rT0JZempEc0dJZ3JTNlZFa1EvYUFFcGMyRlhMckJpb1FzVTdnWXVzVWlLWnB1Umlab1l3T1FGZXczVHhPdVdYZkJXYk9jNlRGZnQzMDJtYWpYTUlSZDdZT2tJYk5nZHlJT1dvbUlrWXc3cW9nTE91bW9HWmpXVmJSZ2dxYmpZQ3NlNk5wN25OaVZVVnQvMm1URlFUMmJsa1VwWmZqMUZ0dzZtR3lUeEl4WXgzSHgwWFdnSGVKSXR3WFZHK1VSV2xxUVJFZHVTSmdkblFvc2ttVStPTVRQTXV4ekRVQ05JVWpERVJwd0N6aWpST2NDb0NoQTA0c2dTODlIRWtEY3pac2Nwd1owNE1UdGpZVUtzZGdOQmtWbzJYZ1pqaVR6em5IaTFMOFF6eUhmZzFqODBybGJNR1VoTU9DOGxxb0FwTTFETER2T2xGZ3VZWm9jTmRKU2t3cDRzUUNZSEV3OEYwb0xiNk14UnVRdlI1djNDL3dRazVHWlhwWWdTbG51KzhIWFB6N0tYZjVURHB6ZjcySTBzRDQrVCtnNmtXL0grQi9QOVlsc3NKZi9QdFoyUzVQZXUvbmc4bVQvYzhIQXhsc3paUzE4L2REWkliSlRYTWNnVllmR1V4ckUzUnZUdGl5M1RlNzA3OXRkK3phcis1R2lLNWRLam5mUmVNdUVLcDV2TGl5QXpUN3NqYUJud1U0cHY3Uk5ya0lmSmRFa3RLNFJpelBkM0dSL1ZqNlJ0OEVsajg5dlZWcDZvTkIzbjRmNytRYldTYy95OVFjREViTm5LNjY1aFBZdElxVlJxUThQbUc2UFZ0bnQwMjNVeXRnZm1YbC9NcktXaFdOTU40SmFJRUdxbXJQVm1YN2RCV0RrNktMMnhzcmdmNzRvejFJajdtMEZmTXlaZ3g2S0w1MkJuYllFUW9LOHUvV1pCellpVitTVFpMdjdrdDJUcmlZOWZOSElnOXBxQ2NoOXZDU0QyKzcxOGVBWU9hUkRJa3Q5aS9iTWpmaStaM1hzcjJsS0djdmdyblE4VmkvOURrTWFyN0hTS0hhRktlVWxoQjl3bXI3RUVsU0p3ZVM5SWhwdmtjMm5zYnBwK2wrWEdOZjNiWjhIOXk2Q3lmYkc5dnZEL3pudFEzM2NrQS9kbW9iSDk0bXJ5aTV0djN1aXpXTzU3WTBKZHpBZm1XYlp2ZHVyVmRYOWRvR3hVSHRXREMzTDJrM2RIaEhuNWJXWldCMjdGQzZSN2JicWYzbXRudkJFbTVaaERnS0hQTmJGbTV4UHdRazBmNXc3MDZjWEtlZU5DUk5BTzkvUkpLZWpyeVo2L0dhWHdqWFk1TTQ3NWN3ZlFjU3Vab3Ztdkh4dzVJYWs2Sjc5MGFsbUNybGJyMzF4Zk0rZmxLTmNHbzJFc21xWEVSRmR3d0VoTTdZa0F6c0Nod01uRVQ2NUQway9xbDNWSEJUbXpBa1dxV0xISFMzREJPYnR6dnNVMW5mRGFCUkE4OVpEZ2tRejhaTml5UlNya1RXdXBZdWtNUm95WThsNTQ5MlVyZTNUNVBHL3hoR1VEcDNEa3dFaStFNWZIQXhNMm1wQlNlRjA2bnMxQUZCSWJ2bnpKUmtMNWJvN3ZIcmY4Q3pKSzU4MHlKaHo5c0pRbHE4aXBXckY5cm91L2d5cXA5ZnhuSTBZZExCYWhTZWNpaVIwRVM4VGMwbVRBT3Zjem9nek9CSlBFZUJqU29PanRyQUNmemlrYUNMaVdzeGRRdmN2STFkZUpIYTV1QTE5VFNsbmswVFdGUnVZS2taSjhoendTY1hweVdKMWFScmp4eTVWdEpZV1p4ZWhKeG9pSXNPSXhvYWF5enRFMERRRkVwcVNDMEpaaEFJKzVZTVZqTkV4bGxFWjNGd2NWcVVML055YUtyOWw5OVlsaG5ka0pqMDRHQ2FrVXlOa2N1Y3FmRmNhVkkwZUNpZUhEdzJMUmdLSEwwS0k5SmVOUW9WUTVnK05uaFNoTHdoVHBZNFhqTTVkQWZOM080T2tuNTVkNkI0cU0rLzhDeDRpTVMwRFFmR2tYUVQ4T1lHVUJmVm9kSENPRWJFdDgwTFJLQXV5T2lzZktzMkJpRGJwSmhOdmZHS0ZOR3AyMkxmdTVlVHViMjhJSHBjcGFKd0J5TndTUUV5VTR4VUVOa3BCZ3BKaVJYcndaakVjWUJqcjJBZy8xb2N2N0xBY1RpOWh2dVg0U1dPVytKMXZ6L1NuK0I0V1hoY0ZCOFhaQ2sxbkRLTTloYzQ0WFlXYVJMb3VNdERUcmlONVVMZVJuZTgrbEJ2ZWEyVzcxUGQyMVB6UDJkNTgxdktDd3dBT3dXV21QNENjL3RZa1hzdHp1cDhUNEhCTVZwaXYxdldYL0xpU296OWZKOGxYTUpPb0Job0JQYnQvSWF0UHZhR2ZoS2RmcEtjMlQ0U25hMXYrR0FQR0F2MHVFeklva08zMXFITzZYK3hBSGFGOW1NZFVmK3puZFFkUFN3NHVJem52YmpNVGhtM2Y2dnV6MWxHZGtzWmYzRDVaZHp5THQzTEx5T09XemdIRmdJWTQ5a2dxQ01raEpEaThjTnlEZFBhSVYxeUZlbVNxMXI4NGRYejYwZ0xYZFcwVmFTRnJxL1M3L3piNE5Xb2pyS0JtY0FWaENkb2t4ZFNvenNqMkpGTjJKeUgyb05odWdnTkd2WDR4cGhlZUFhTTlORndrd0RUQ1VCNEFQSXZ3OW1QQzZ6TUdpdzN3R0hvSUtRc0hyY01qbWNnSS9KR1ZIUktFZE5LWjhPUmFHeFFVWFhkZ0k5MGFwYjM2aHF3cnRlY0QvSXNaeUFsczh4Qy9tSFkvaWJQU0Z5RTR3RXZCZ1V0RjQ1WlRpUjZYVHJ6RmttRG1pVlhPbzJKcC9YdTkzZi9PZlZRM01RODRQT3QvOHoxMEw3d0M2dUlaem9OcmxzUnFEMmhraStBczdROXRXcGtpUFNZSFZwdXZ0clhuTTV2Yms2RXQreGM1L29VcXMydGJiTGNmOU10amZUOHhScnRhdDhqaVYzdVBKS3oxZ05OSkU4ZUNseUhrZWFBaHhsRGNXTTZBRU9ZSzVDdWZZQjgra3RqUUVkQmtRWXU1RXY1QmxLeUozQThBL290WnB2MWNuYkNkWVN5cDhkTmhBWHdaSzJTU1ptcHVCYU5wa3Zack83OVpMT2xkRFNxeGRHaGJMazJmaXdhcTEzYmZtMHE3NkFDbjRsRUxDc1NPYU5uQ2s0ZTFOcmZnUkNrOXhZS3cxaEFzZzBEUkJRcHBFUWNXUmVsWEdveXFDRE4zU0RMeVZST0VuWFppU2doU1FsYlRxM2lIZzhwOFlob0xMWFhsd3d4RWxkQ2ErR2FhOHdiQ3MvdVl2bGkwY2Zvb2J6RjR4Z2xBM2hSR1VKK0hBUHhrYnJBZTJpQVM1TTY0T1p3R093NEJmL2ZEU2g0QkxaNzRRQjF3UXRjeGs0aFpkeXM1NWhHczB4d1lrc2dNREp5ZzJMVUNzbTRDM2lPRERmaXpVaXdNRkd6NUlFYlR4WnFobkxqQ1VzN2VVc3dXcGdyQWhXTmZveWVETjBjU3VxQUVSU0ppWTJYSEJBRndWdU9DUm80TXpSOFVnOG44aE5CbDJIWmFGdzJ3b0t1QzJGZGlVZFpsZ2xyRS9sRTJEanh0dUQxTjFuNW9jSnNBU2lxbWJhc3RLa3F3QzZPeDRmeTFrMUhNTXkyeDlYNjcwanZjSW5ORm91VmpQOHlVeXdxTVhnS3gwZUgyWW5yYWh3VStibTdkN01KVmpxSWNZMUg3amp1aFRKd0N5OS80eVRIVWw0R0d0dnMrK2tOb3hFRzJ3cDlENzJPczFPTFR0bE1OSXQrb2pONzA1a2d5bmIyVktqbmU0VjZ6ZjhqM1dxdjBMV0Q5aUlWQTRRTnBHZTRidnYvOExiUDBMUGJyNktuUFU0M1RicDZDcCtTZGR2ZndwZVFKRnAyNHZGSnJBL0c4d2xFUWRiRUtHWk1vSXBkK01CR0c1MkJIZnY4Yzd2Ni9LVXhBbmJTd1MrbVZmdHkyT2VaWWZBVnd0L1R4SE13Rm8wZ3d5QmZ1SldXT3o1akxlaUdjY0FnWnVJa1FmWmtaaWFjWmxKQUdHTjBwQVcwM1BMenFDVzJXQjd5N0NETGdTU3Rrbis1SzhvRUk4cWIzNnhFZ2t6MExnbm93WGN0Q0s0ckxMd3JxSVBGUitmbUhqM2x2dTUxTGhMTWVKNDdqZ09vWEZxMVY5ejVhMEZIRVBidUZRUkhmZGVkVXNSbW5MZW9vcWkreFdIc0NHdS80UTMyYlk4dUxqN3F4NXgvSGdPbEJjSTRNZzVQQ3pYb0pGS1lBZ0RzQmlEek92ZlVvM05JTWlkUGxyeDg3VjU4OURiN0RYc2xpZHhWUXM5RVE4cGUvejNRK2trR3l1Z1JXUC9aZkV1c3hSRGxxUVRkTW5sb0dqQkdUL0drTFlWL0RKZjFGQzQxY0hwS0k5MzVMblZ6V1IvRlJic05GOUxQeTdOZ0RZMlpjY3ovU0ZtLzhPTlJTOENhVzZQcmp3L004aUgwK1h4YmlvWkNVZW5iVkhvQjBtY3prUC9VNTBRbUZBUnJ3UkFqZnA1NE1HT1dML0NHOWxkL3QvT01OL25Qb0hhT0hwSk9wMnY5QmFZTDdrZjMvUnNaUDBUK0c4KzcrY2VmQmV2K1U5bzlUOEhlVyswM2crbjM5dmora21pM2x1TWpmVk1IWUlFeVducVl3M1RxRHdjY1U4eHliMksrTlFkOGNBZUM3dUhIVlQwNGN0V05WNDFFTXFPTDFYUTAwMXBzWldyN2VPNEtYZ1FDRUxqQnljTlRneHhLSVdIeENvN2ZCMTVHNDZudW84N0pRNmZnWUN3N3hvemw0b1B3RkFVbkRrbkxqZC9uc05JZ2NCRjBHK2x0NVYyVGxVY2tkSWNJM2MxL29MSDhDUnBnNWZ1WmZvbkUvbURPaUVCeE0rb0dHcE5obytaTkVPYk5IcUFuMWRhT2FXdUhjSGpPK1ZOQUpYQWI2QWphT1hNSURkaWFmQnFzOUdKVFUvNmZRSEZIUE9wKzczYnczQTRFUHBVdWNjL0d0akFHYiszeStsQWNxSStpYjJ3dzBBcnNSeTJrNWNlVmxzcmJHT0F4dXF3SERBVjduYmkzMEVIL2lrdUQyNTN4aFlRM013RDVSTzNZT1BIZjduSHNUbmVrY1NDNk5PN2RHUkxIdXlMOHVMRHJoanB4L0o1YS9MdXVzL2RxVndIbytGTUV5QngwSmJDWFlMa1RUQ3JzaEVuYlZDK3JLcGwrN21DUmJtY1RyWVVuV3RqbGgvakk1YWdIWWd2ZFF3T1F1S1hOZ1JhcW9HWXJESTZhMDBlbVRTZmltS1ZZUFZaQ3FkUGhGRkloVXkrUllGaUNkU2lGMFo5bFZheVFlN1phM2xPN283NVlIcjlKTWxKRkZoNWFtQm05ZVo0VDVnM3BKbENNcGdhbXB3ZFNVV1VnTW1WbFlBbUhjcFJneHBxS0RMd1MzM0U0ZFFFU0x3SzRMTUVwd3hWRjEvaDBJV0xKRU1wV3BEQVJDMmtLTkNWSFY3V3dhbW1LRm9wNXR2Vm5VTjA4anNhRWtjQkIxTVk2MW5UNnNtQzRoN2JJZjlzK2dPQVl0Z3I2RkVXK0hsNzJvUW5CajNxbWM3NFpWYlR4U2k2YWttQU1TbU9EdXhZSFI0eEhpb1l6bkUrNkVWbUlRMm13M0p3ckQyRmVWdi8xR3FwdXVwbUNxaWNJaDl0SVBKSXR6T1ZqeTVwbVRXVmtOWVQzaG5PT2xjek1EQ1pwZjBaMDBqRXlTNUFuRHNVK1dxTFFZWW5Bb1lvZDVNSXVWRXl4TzF1R3krVlBETk9XMitwcHhPZ3Vick9qcStBTElQalIvWXdtaHd0NnRER1FHTmNZaG9DNGhpSWhXNWVpSlQwTzBHaUhwN25hejZkdzBXWUVyc21obndZbnpKSkF3NFdaSWw3dkViZ3FHaEM1Y1JZdTRPM2lyQmtNeWhxSUdJbDhzUnAzT1preEdjQkZuWVFtaFdLaFRGbFFPUUh5VVI3K0hxa3Y0WHBCRk9GMUF0azRkU1BkZDVVZ2lmQXF1dThHUExaQThsMS9pZmpKbVVpeXdoaXRWd2VPNFA2RitwUjNmV0ZJTkluckcyS0lBM1pwTnpXeUVrUkpqT1BHWjZsckVxdzE4bndXKzQ4U3owSlVwM21uQmlKMGJIL01pMVM4Wm5Kb0dwV3d5ck96cjV0bCtTb2EvYWNIcHh4clB2ZmgzTHpsdEg4Sm5JUzE1SWVURThwamoyR0UxSFFpL1dGcktLZy85dGlEOUE2ZXJBQ1lmeWpzVXFaWnlNM01jSkNkVm5ZVi9pRWRpeVNUa1ppSnV0TjNMNjh0eGl6VENPcWhMeTkzNGpTSlRTWktSdmNoaWxYVGErUHZsYmt3R1dPWDFSNTEzalVyaiswMVJQNDZ0MG9ZeUZhN2JQSGZXMWxaSFNRQm1xajNQbjl5RUtmQmlvRlBNSHB4bXd6RFIyN0NBTFg0MzBkd0lySVorREdTUFU0RUhnMDhGbmdmR3ZNSmFoR1J2ekMyTklHb3BsQTZLTkgxWVdoNnFFaGs3anlGcjBDYVNncDBVT2xSZ3BnSUNQeURRSGdEVzI1cmp0aDEwYlZsckhZVFZadWduaENrSlVMSFRSY3BZaVVPdHpiMTU3NlErRzBic015SW5qSTVGVEJNMDdBWmRRQ0FBWld4alNiREFKVXpVL29JdzZKUEpKVVNOcDNiTVBHNURJUFBOUnY5NXlxV0paYk5JWldQMkxXeVlaUnJkb1JYaDh5eXVHay8wRHNINGo0dGVXNDZUOE9sSytOSTZFaElVc3lvTTBnMmpXYmtQT0JBWHM1RUFjY3lkU01tU1FrQW1IRmRWZlhMUDNWNWJNeFNsZGk0blFWY0JtblFHUTVrN2ZHWUVnenRkTUR4c29VVzUyaEVkdURuN2FmNC95LzJVeCs5ekg3cWZTK2luMkk2ZWlERnJmRmNBNkVubHM0eGZjQldlQVlIQ1NHb0FyQTdwQytZN0NaOE54amF4ME8rV2xqZHd4RVhDclo1dk5ZRGQ4VnUzY1YzemlkWVdMdnZuaGNnNUdyWGpuY0JzUDZwYjV2M3ovUHlUM0N4QmdqNlFROHlscGRycnd4OVlGaHN0eHp1MXJtb1J0a3JUOU5IelhyNS9NeWRWeWpvbmtrT3lxMXJSbnV4c3N4dDl2R2JydkxRdEJvM1R2RVN6dy90cjJ5QzBHcC9kK3UrN3ZtK0RRUmpUMDlpcExZdCtEcXdRNFFIS1RTYno5bUhKQWk4OUU1dllhMnkxTHRqMnhUNE5nTVpsMkVPc3dJYlp0bHdiaS9kVnAvUk5GYWNRUW0wUFYwcUNJWFlNd285dERmWC9nL05xZ3VNcGliNElLL3dmQ0szTlhFWVhNV2lzeUd6ekpDVmkrNU1Fc296V3NtK1locWxWSWFaNXJqWU15bzlnTzc3RnhvajFDMThYM1NUSUxsZGYrSnd3TFBiZlJGMWJWOUMwdWNreGM3RkJDL2xVY3FIakx2a3NGYy9sSURXRGJkU0hpSVRPMEV3R1V1WWd3emJrRmkwS2hOWFNBTGMzUEUzQjMvdml1bDhldmw0SVowT0ZjSlIwNHdHRHdhWjRIaXdvTTZ6amxNWk1ZYWlTTVg1bTl6dVNFV1Bsa3B4NnpOcTFxM00zbFMrZXlMTVdodXFGTFBVOUZkcGNPMXJCbTg1bVU5bmRUVm1GTVBSUFh1andYbTFnTzdGQkEreVlkVVJRemE2MVNCb3hpS1ZlOFlOVmJRK28rUzFXUHYvdkx0ODgzaDRkM1FqbXcyS21aTmVLRzdQMktzamJUMkd2dWJpTmxZTzBtOFJFbkhzZ2VOZ0ozc01wOW1ENHYvVGp6SGNFMDg4OFhjZmU0SkQ2NjNXam9lcWo3UTNIbmtJbmZSSVR3d2Q5WWVhcEpKdHJ4M0Z1aFNlYjhkdWRJck1OUEJrMXVINkhkRjZ6MUw5Y3RrN2tVeFBnUG1lL0xlUDlLQXBIdksxeU1DV3ZPNytHZkxhRjlkeG1WbGU3YnBtWFdhMksrUWNrY3lQc0gzNXZyUVhTcjhpdUpNbDYwRS9WNUFveloyOHRLc2VpUVBKVElabWhMakZVUHpMTDZHOFRHUFdkREpWT09aTk9qblF3MExvVzNzWmJkRnpPMnQyYzFVNzRGTUUyZ0JMY1M1SytmOVVvdk8zcWg3OU51R2lCZ2tPWTVVVHZWNmxTYU52dmQyaDlnVnlBd0thMEltbkpQVXJCaUtZa2JJVG9YeXA1Z0FDcUdtRjR0Yk8wTklaMUZnVHBnVnUzK2xGbytkVHZ1KzNnajhKcUFFN2tQRDVvNnhOVGlRMVR3WDJXR3ZCanB4dDYxMjEvckZ2U1puVW9WUkc4bFpnNzBYSjJ3SmR4ZjZKd1VnNEhEbEpsb01nZWxINk5oSVBoUDNHMWxHdlErTm9jVXpROVVUL3ozWEVLbHhmUGhpK3BRRmNyVFJJRlpVSDU3dWpGTG0rVFlEM1gwUExUM1QyNk1BN2g5QjVBNUM1ZXM5aXFXd280Mmx3VjNwY01jcWx4VDN2NXFONit6ZjFLRytMMHVKRS9UV044VVZKYlAvZnREODRUenVSOWtmbzVpUmRBWU91VHhTY1lyTllpT1c1a0NXQzlYSjVZYy9WRTZQSmZENDVPbkgxbm9WeXVYMEdzMGxQN1pxOE9aNUl4RytlM1BWWDlINi9UcS9QMEszWGVzaENkRlc4MVdvVmk0MGlXSkZGR09yeHQ4UDFoa2VzUzlaV3cwY2VLTU93Yy9ubDErWmY4ZEFyNW45N0pJektsSThOYzZZbDdWeW04c0RDUFF2b2IrRFRhMVl5VHZLN2hyNFRNK0R6VzJIN2pvbHluUGI0d1gxTUlCcFdXMjdVM003bkEzNzR0R1kvWlNlMHA1R28vcFQyMDZlZmVycnR4VUQ5WDA5ckNYUUlIVUVIS3VmUmtmdHB5TldtMk1VZ2VnckdSaWVZYk9YeEZxajVkTzBVajhFWHYyMmtORHR1WjdhQ3VRL2RVL3RCK3ovRzhRTitGVzkwSGxmdFB1bzlUMm5hRHdEbjVVN3I1dFZHNTREVlRzQzE0T0Z2Kzd6YmU1SHVlQnRoL3Rqa3JPUmNZaHRzRjVlNkdWUFIyOW1KZW1FQ1BxQVNZYkRaSWQxKy80MFkrWlpqZzJpVjNJOFdLc2R0M2ZVU0QzZHNQc05UekNYNFg3WkpnYmZjeUxJVFNGa0pzaXk2RU4vZ0ExdjIvTmRPM1VCaW0vMFhWRGZqU05PbnlFYW5BL2RpRzBkcGpQQzI5YXIrbm1tNWF3WHNNb2swRzRERWxtS3N1aXpxRnVCbTgxaSszTSs3M3NFdzY0aG1GMEtHQ2FzcGtiajVpcWtxTkkyUW9ja1pwREJseU1wb1A3TzZXajJuT1p6Yy9ndVpjeGFoNUpwZzNuUWxlTHByeWZ5Y2d6R0VuWi9xZU9rOFp1ZVV2YWtpalpBcnB2WXFPWHZKTmNieFppYURsK09HQ3lxUnFoa2NIQXlhRnlTNFpMcXV1UVNsR1FQZkR5OEF2Vk9OM3BmS3FVK2lPbnNpa0VMOTVTTHFLd1BGNmhRWVpjcmpKUThuY3p6RnVPTmhEeXkwaUxvRXJLWkFWQ3RJV1oxakd2VVc1a2RINXpLT2piUTFGM1VVV01OcGFRRDhNejkzYWlZSTk5eTNCM1JUN2U4eGtlS3VoS1RJTjUrR3dlS2hXa3BaWEpFNnFXK3hybmYwNlpsVGN6eEFsOEJnTi9VeFJVcnNLcnJzd3MxL3BhUnFoNHBCS0swc2RsSXY3Unp0ektlZ2IvZDMwVWhXOExpNk8wMjhUTnQ1LzRjeitIV08renBxWHpiSGZlSVRIR2V6TW5NU3RXODZ3N0dFcEtUM2ZJT1YyVyt3QktrWW5ZSE9aTnVIRTU2R0JiMW5zcWdOamdRT0JBSm1vOXRzUEhPeVdldDNlekh6WG5zcUVoV3gxNzFqQ1BoT0R2Nm5GdWZoRVJLeVROenF4NDlDUG9aeTlVSGlLOVBqdzlEWkFJMWI4SWxrTWQxZTcyRjVXcGxHcWJ1WGVQMkZnTyt3QUVqS24rZitXekxQc1ZNNW5DM2xhUGpsNEFtZlpuWVQ1bmJXZzVhbEUwV2tITy9xS2NldjAzSjhicHZzYkNyQlJyY0FHemovUDk2eDRQMDZTSkt3Q1cxaEpITWR3bjZFZVFpUWJPVVNMU1RmSXJEUGppY2pFV0gwdTA5d2pQQUUwa1k2aVUzc0cvWmo3Mks0Sng5RGgveUUxeDk1ejdlUURwUkNPdEF3UmhyZHdvcVdiV1FwK2tVRGs3ZTBHcVNtaXpSbkxNMVpiMTdBTSszdkF3czF5NSs4OTRFSDNnc2c2bmEvOWdEazFRZGVpcXF3TjFjL1dubmtHQTlYSGtHL2tEKzJnc05SMmhkUU1oQ1FOK1hOWjUwWkpEM24xRFk1UkJXQ25WOHhWeFROWXMwcGI4b2ZqL2FZNkl6TitVVFplK1VyWDRseitjcmY3ZVJ3K29FSEh1akw1Z3JLSWNubVNqZVQ2c29LTUZhOHNYNERBQ0lUSndpYWJFY1k4MkNOYzhSWGlCSWdzVWhPR2ZQZFdqMFVFdHl0UDBGSlFDcVozSFFlNUtaem1jbmxTVkVXZ2l6YXlRWUZ1VllBaGZvODVSNlpLMWJ6MDduOGRMNWErSE1jU04wK0g3WVVqZnNXRHJEK0ZxY3BJYmRRcjN2NXdqS0loVnJXTE9waDZFTjk1dzdTWVpLQWNlTDQ0VEdxZWc0akxZcnUwbXg1dTFNQWM1eWp6T1VBZW5SbUJSUnFQWm1yMnlnUklsRzJJWUNKMHl0L1hrQlp6S095VklzZnFSZmNVRy8yckhDaGZoeHZtSEg0ZlR3dWZCL0dOOVdqaVZyaXJGZVBtL0x3WWl2VXk5S2xLeFZuNVFHY2xRZGdmTzlsMWU3LysvbHQ0UHcyL3YrVDMwL2cvSDdpOHZOTDdYZ2MrRW9nUkJCTjhFd0IwcE1KS2sydE5VY1FUdktON2ExeW5SUjIxclBCM3lhdWl2L2tCTlJzZU9KVU82U0o0c1NGeFd5QzA3RDBsOGo1aWF4dmU4dHFaZFNPUCt3S2lYKy80d1MwTlhqaStWQTltamp4ejN1eThSME5hMW1OVS9RaFgvWUg1NUZNamlQbGZ3bEpMRTFNelZraUdnQTFuZytCVGFhUkZvYVU3U1ZCdzlEQzlRNjBBNSszaWRxSDBYWHpwWExQTHhJWlBhYzJkQnMzREZNQS94RUo3eHZRWUNRWnhKT1Q0Y0dDblRaRlZWRWtkWjdnZmtnYUQrV3F3dkdTWkNSR29qR3BVSmhvcjlEUWVqQi9tbWMwbGhlVU5NOHhMTWNLaXVpRUZTdW9tTFlhU1JueFdER3BHYndxaXpwUW9CNStOcHN5Qzlwd0pDN3hRY2h3b2hXOGdIa0ZwZDBLRnkwWWlXaTg0YnIxWEd5TVJ1Q2JhaEFteEdBd3BscUNJdWkyYkNoaUlxWFluK0ZaU2VZd1lBbk02M3BaalNRaVhudkY5VGlCOU9OWDRIb2tBakpSOWZLMEpqWFFDMzNZOG1DSXNlY2FwdllwTjJGWWdHRXlSK2k1QmpaNnZRQmI1QXBVcmRqNjdSQzQySHhZNkdqTzRCdmFSS0VneGFJakNVT1NlRTZweXJlVCtsTk1WZzJLb1pTZEh3eFBKdU5BbGhoanJ5aXJ2S0VsaTdHNGtZcW90cWtFTFNYc2lJcUFJMkk1UHEwSVBLc3gvR2tqckVNRnREOU9LK1I5a1ZpdTdycU5lRFJoRktLY3Nsc2lGYWpKSEF0VlhvcEhocldDbVhKMFZDOEdacStUV1A0enRwSktpSW9oMnpxcVEwdU5CWU5pQWdaeG5hbmx1em8waFpTdmovQ3ZER0N1TnVBRG0zWXhhNkZHSFdxUzFNaE5nb2hRRmZOellEZW1HWFh5dU5tQkNUNk92MXpNbzZqSmNiNDRnSlFHZzFFWkE2a09BKzF2QzZXNHNldjhMaU5lRWdBL3BNbTRIZUhGVVBUQWtLeWRacXM4WDJWUGEvTFFnUnNUbzlxRDFlcUQycWpQeDRveU9RL1drSFp2K1V6SzZJUHVDMnJCakRwZW5qMUEzdzZBS01GR0s1UFFheWZiSVBTaWpTdzRjLzQ1bWxkTStLaTlWVVNEZmNaT2lGalhRR2x3bnFaZEREalN6dUFsT0g5aFphVW5ISEtTUk1LY2RuTnVKMUZTQmljR2xjVkZ1dkxqY09kSkhPNFl5dmVMekNNemVUbTUrdTZsODdIWkgyZjJZa3dpRnV3b0dMQlB5K2hDUDIzUEkxS2RtMk5aN093eU4wZXhtL3EyZDZJU0FjSU9GL2piTDVhLy9CTFoxMGxuZnpIKzh0ZGNwQlI0ZXdjaTg4TTdGNEZzL3d4ODVwZFZsSjM1ek8rNlZFRjJKRGIvclV1V1pRdS8rV1cwbkV2eW0xOXhpVGIwcWgzdHd1MUxOS0o3ZHFZODkveUE3d0gzWU03ejdqUmdkd2F3Ty9sSEpJYnlkeCtpejNqb0lmcU1oL3EyTjNiWTcyLzd1S25nTmVCclNHdHBZTzNVcGVJVUhYRG1xRTgyRmJNMVVPN3dGbnBEZXM1bjduUDlwT01CNjZDREd4UFhqWnRLT2hGMFZUZzBCSU51RUEyZTV2aDFueTN1UHJpN3FFdnhwQmJWZ0FDMGlKNk1TL290UUFhOEpqS2NtM0U1UnRUbUo2NmRHQ2k2d3hXM01oZ0pXZTdRZ0ZzWkNoY0gwTzVQRjNjWDBWODZaWlVHb3NOVmxoMGJqZzZVclRUSDg0WXQ4NkprdUs0aGlieHM0L0todm0rQjhDZGdDM3pBSjFhYTlyb2R2dGNOa00vamVjV2FoNTI2dGxFL1hrZC9kTlYrWFhueDZzVXlXWURsaGFGVWFtaWhqTGZCV3YzNGFYd0dXbXlVdlRQS2l5OHQzWFZYaWFRREhTd0VuQStEZURyNmtpdGhWa0hQSy9kMmhjeDg1NmxrMVhOWHVwYzg3c1p1ZnZ6N3Z3bmNpbnJXWXhpRHNEOE95SThvSXNCbVliZlc4ajBiSElzZUlZYlhQUFRjSWNad2xHUGVzWFdLRDE5cVdmWG1TMjhpNGJKNGNSUGtjeno4NXlHUm5ZRVM0QVZ1aGhXSGVCaEJ1emtJVkFCNHlGYzVNU2R5VlY0UUFOb0R1WndBUVFTQ1VXS2RJSXQybTVpQzZ1SnZXZ25EVW45VEZMRDFFeTBmRDlwbXlGRWVnUEFCeFFtWmR2QnhYaEN4MFVid2ZaRjgvNnRoZ3JlL3IyZHVwM1ZaTGxlTmJNdHp1d0tOSHA4cklGTDNxQ2N1NFdhMWluMnJXTi9YQ2x6YmRiUmFwVzVXWDkvUnZlclhscXY0Mi8vM1JjL0J5dWVlUTcxWTRJYkFLZXJuZ0Q1MjlFV1ZPLzZpbXgweXVvaE9MblVBdmdpelFJTjhyNWpnamJoR2RJeXFUKzlHOWF3Zkw5NVlqRmtjWjNJU1p5VjBWTXU3ZWFnTFdzS21IcVoyTEw2dk5reWlHR2xrRDBuVzlzV1A2N3dPLzRteVpJSU50SEU4SG8vWjFNWFVUdUNEUEhsQXdrSjNOam5PanBWR0c4dFNqdHlGY0xjWFNESW5MVGRHaThjMWdUeTVmUmJmYjNteWw0OXZ5bU9XSkhXUzk2REJmNVlTMysrVmVCUjlUWmRkS0hUdWk4azJ4UkVoYlpOaUMxeEo0dnI2Yk55dHZsRHBWczlIU3NlbHp1ZnJOZGsweU5lb1N1Wm0vUW5pSHZQZHFZNmY3eHN4QXFoTloxdHREQTU2TUlja2pGUEJNTXg5OWUwaGhyMlpaYjdhUGs5OTZBQkhwaHFlb1ZHQWZucEZRN29CS2hJWnBwWWhVcDYwS1VWVmxha2t5MTdWL2lRZXNEcHpxeGNJYmdEMkJpUjhybFFZNmhUTzhxYTdMRitXTDliY3ZKVmxzK0FOblV5ZHhQazFNa3pjQXFJVlp6SUd6blA3MzA3WmIvK3o5bk5wY0FWWXBRK25tZnF3RlkxYTRCakpWQ2JUWGdQTDNWZ1JMTStNQkY2SzU2NEpDaHJxYmtvRThvaGFrQ2hiTHFseVBEak5ldjRoT0F5OU81RlJJc1lsRHhJVmUrV21DYnRTSjFHanBPQTZVWUJSay9wdk1EbWRWNXZ6VFRVL25ZUjJPRG1Sdko4VkhKYmpWM21PZFFUMmZyUW5mTjM5aEp2Zy9tamVsTU04SndBMjY0b2lyd2NCSytuN0RKRURRWjBYUlRmTEFvSGp3N0taQjB4dUxzZW44dmtVanhMR1NCVGRSaC9RWFp1VFpjNTJqYktCZGtSSEhvcmdxZTVJZnNLVVpGWUtDbEJ5c3d3akNIelNTQ1gxbENBSURJTzVmNFdneE1xU09aSEhlaGFPYTMrSTFOVWludW5Ec1FHZGlEZmlEdWJTTUtyTjlkWEExUVc3VmRYQ3YyNGUvWUpYNW5WZXpSdU1ka0liUlArTWtWZDVQYTl5Y1d1VkZ5eXZMaXlCWDdYaTNQdEpUYXdlbjcxMjZzU0pxV3Ruajk4ekhDd1pvOEZCZlVWSGY0UEJVYU1VSERZS3NhUmhoWEJoUTVhUmpCVTBXdERWMVpXVjFWVlVodWZSKzk0RHZoTFFNRDRlNFd4bEJkTFlrQnJOeHdFNEtHV3owajlqT2tsd1BoU0QwdlAvZHVFQ2VOeFFGS085WXVBWUl5T0NzY0M5K0x3dkl0MW9BOG5DaHdKSEE3Y0dUcFBJRlZRZERIVzR3djB0WnNkRVBYQ3JvempSTnU0WlFuQm41TWQ2a0E2SWlFNE1hZko4bzJhN284RE4wVFpIVzJFTGpWRE5SZzNjT1dTeEttTVBDUnlYRVlITWw4dThETVFNeHgyVllQczhxaWNvRFI0WXNaTHg1THpwRWdSUTE1eEhXOWJJZ1VGMFJtQlpyZFF2eE91R2VUNmt4NlBmckZmVVpkQVFLanhmRVlEQ3BZZFF0VGdPaTRiQU5LY2N3dUNZc0NyQjJkVDBpRGdRYzhXanJva2orMHozcU9qR0JzU1I2ZFFzbEs1SzdoM1g2aCtwajlVV2w1YjIxTVppMGErRTY5cjQzcTRmRnE2cldtQlhZQWtqSklGZmNJMXMvT3dGWC91NUN5aDA4RS9MU0tyWWc2VGhJNEdUbTVGbGY4SG9wc3d2Q01oMCtlZkNMRVZTZjBCSC9jSVhHUVk4aGRKWlZQcjV3SEpnSmJBYVdBdWNDYXdIemdZMkF1Y0M1d01YMEJ0M08yU3lTRUloVHM2RTdaRW9EQzUydHNQZEJXYldhcFZSeHdsZHZrOFVyYjNJN2Y3cnMzM2J4Wi96L3YzYnNOL0pLdkNUb3B3MUR1b213OFRIWXd4ajZnZU5yRnlVT0hYeHhQWFhuVnhVdVltcFExZGVlV2lxZUZDWXVuRktPTmoreTg0YzVnMFhUYlgvc0pNRXIrM3VmZTFsWHQ1TjNka1p5TUhHNzgxb2lwQVM0a1lNd3BnUlIwbEZtOUd5NnFJYkRydUxhbGFadE5IUDVIUnF3YllYVXQvMzNGSXZ1VGl5M2M0UFhPN1YzY1h2MHJsenZQQmxlZXIvaXVXbFk0SFhCdDZJdnJnK1JBTzNMMWFxbk90UlAzV0dLSjRrVkRqTkVGMlZXRTEzTTZSSlVsMjFSZFFmSjEvT292RytFNWRRcGtpb0xmeE5ZdExMTU15YVdYQ202eGFuZHJ6MTBraWxVZlY0N3JaYzNGQjQ5S0ZnQm02eVlCaE9OZUs1MjdQa0FObk5rTVhiRXJaUlZkci9wbFJKSU1NN210aWtmLzMxMkVUZmZJZWRJSUdzVDNVZXNMLzcxRjhHM2JzRGhoTVZPN0lVc1JVa0ovUStGdlFjR01EaVhnYjlVS2U2RnBrR0lGTUlMU3dLQm53T2tUVVN3OVhqYVVoaDM2aEE2Y1BDYmVkNTZGTlJQMGZNam9DZzdaNTVybytXbXZnYWJxQ1NVV3R4RldVR2RWUHRNMGphckJNN3gxTWUxN1kzZm44SlNTRFhvYmVOUFhuTDNwd040VjdIcEpZMTNKbUVteDY0UDVuN0lRRm5QdmNsTnJpUkxxZEdTQURRVmFSUHhYMFBsZGlZM1ZxbGVNOGN5c2pjeTBzVmpRMjZNc2hua3drcEthcFNVRU5LR2pwVVg2b2JLbFFZTVNrbFVwazhrTjNnVWo2VGlscmppVllsbXN1a003TlRiNTJhKzdQcDBlRTZaK0pTbTF4OWFIUkdRV3BOVnBTR05CQzBaSTMvSTJ3WnhVY0w5WHJoajJCUU5Oa2cwSVpFS1l2VXFrazVHRXk1OFltTXFvaU5WREtaOG1YV0x4Si9TeDFiRXAwZW53RENMKzVRM1liRWIyNk5GTFJKRzk5MHhQY0ZJQUdxWWNnUFRMNmtWZUY5SkkrQmtjRjNEWThNZU52MWJsamc5OUh5TDF0VHJjbW51OXJFMDRjSEJ3YUdybjdheC9FQUhpN1dwN0hIbHVWaUFtcGlJTUVPOXRpeU5rZmdvcW5wQXNkZnVPR090cFA0UlZKbGQvUFJvR2lTRHJ4a1hscWJIU3ZVL3lTYTdENmU3S3R3dTc2SWRUdU11eXpTaU1NYU5yVGdMaXJ2dWJLVGVDWFVzdkZYTVFkOFBvUncyWGVqM0dUMjlqbDdKbSs1SG9oaUs0MFVDSlhqUkNRN014S0xKM01FVm1Ld3N5T0g5Z3NnM1JKRlZrUG41WElvcVgwOG5BbWp2MDBXY2Y5K2FBSFNvc1lFdWIxNU55bkxJU2hLMEZIdGFOUldIU2lKTUNUTFNUZS9sd3N5bWlHQ0lBNXpDUUl4YitBN2hrbDlQSVAwd3o4a2VPTkwyS2ZZUjU3TU8vbmUveDZFT0g4V0paOXRaQzA4WTlyVjhla2gydDc1bGd1ZUVUWFpxTklmUTlaRTlCR3k0QnpMYTR2dERUQy85TmU2L3RjaVVvVFJWNEhhTzFLRTI4c2JHK0trckQzbS9XanlKTG9CZ1pSSHFpVEkzOER6TjdBaWVxTXFmcWtxZXJsaVpHa0p6NC8reHd1ZlpYand0VUNTZWtZWHc4UW1Oc28wdTNUSmRKb1hkVHBsYnlqeHpUTno2RHpCMzdUd1lPUUZkcmhvRzFRNWJpRyt0TlMwclBnQ05jd3VSR3Q3SXppZG5ZL3VyMFlYcUpsMklXNVp6YVVsZEJLSE5uOFk1cmoyR05xTjF1RHJyRHk5NVF6T3YvamJuZnU1L1k5cS96WW14QUJmSjdRV2JIdU1DL1JpQVJiUlcydGlMM3B2c3AzMnVqUjZlc3ZiZ3VodFFSOEEzbk5MdjlCYW5rTGRLekZPWnJxT1BlMTFzSEpXTll5SVlaeTdwVEkxV1NGb2ZtNTVUN204V0Y1SjJNVG9nQmJuejU0eDFFbDBJbDU0dGlBL1h5OGlWeGZQeUNWeTRNYzl6eE1lb1FxWkg4ZHR1QWNnaHRnVitwNWJSRm94YXRnZ2k3MmZmTk5VeDZtUk1jN01PM0dBZVphMGRSM0VuZmt6SkZONGNHM2Z1TDYrdWdJeTdjd1pFaDk1cGtMSDBmVU00WHZTTUE4VUd1RFg4QVZvc2J5T2ZsNElySkZTWlR4U3E3NDV0bE1YNjRYSzNaQnR3aDVOUTVIeHNEc2VKakQ0bEZLYURqc2VzY2w0TjVxNVBFNWdCb2krdDhOVTNKVThtMlM1UkRHcVpmK2YycTQ4UnBMcXZQZXJWL1hxNnE2dW82dXF1N3E3K2o1bXBxZW5aM3BtdW5mbjJONWRXTThzN096c0FkNkZaVFBjQm9NekpvU3dCSHNYQzVFRUIydHRFUWNCa1Rjb3dZQmtRSXF3Z2hUa0RaWWo1eDlZWVZzeHRweXNwVmhHbGhPdEZHd2hHWnE4by9xWTJSTkhXWWFxVjlmcmVxKys5OTUzL2o1SFVzMndac2dpRklFSlpjVnllWHhOU09VVFd0NldGRjAxWXJJRUVZY0pWVlJ0NzJKR3VnYVpadExDeUZaTERaTndDMHNHc29DNUxwZ1RaS1JDbjZCaFpGRFp5OFRDRWNKT3FhcUtFSjYyZlFFdk5CcS9PYmZWM1ZjUWMwRTVUYnF3VExLY0tkUzZNY2wwUkswK3ArclEzcUhob1JUVUowWm5kNklsRWdQdDM4eEZ3elgrMmJOVkVROWREa0ZKamhtcXJvaE9Ya3ZrVTdUL1hGTkJrRE1CYm8wUkRadXE1SUJjSkZGSzBRNjhGR2JKREs5SklpOWtNRk1xSWtWVkpDUkltaHJMZUdXVUlSMlY1bFVCOFVJT0FnRXBpb1Y1VHhCV3JhMGpBdTNHbm04STRWSFNvVEx4YWlsVlpvT3NjNWdZQ0o4MlJQaVZRY3kvMVUvdGhza0lNeXA0UmJiQnJXcWNEc0s0V2tqa3hueFE5OGV5M3ZOTTEvcmpxTko5UjRsbXZXTHBobExSeS80TUZtdlU1RkdwRmFHU0trd2Q5c2ZHL01OVGhkUWJUTkhhUGFaRW84cmg1SmlvSkJLS09KYmNzUDVXUTVNMDNuRkRuQVdoZVpxT3A5ZUVtRXNUOU9EaDRQWkdwemd6ZUdOQzhwc1dXMHpZS2FRWm5rWERVUzNQMEZCcTlzaGpMQ3oxakJsTlpGWXlpYWlaM0w2MGZaaCtHN05IN3EwN3VpVmxTalRNZGlraldicFR2L2ZJN0FzczF2YW5xV2lDRjIxYjVCUFJsQk9QOTJKWHZrTnRBc1NiNUVIbVQ5THJlbTBZZUJPenh4UlhGRFBMTThSZTN5SitPVGE3aFFYRTRRVzFRbWlWcEFVVFNRd2xzU0VFT0Ewem0xQTgrek5WcTY4M3Z6MVozcjY2bzVKczc2VDZoUEZDREk5ZFYwK09PcWFVTCtjeXFhS0lzaEFCQ0huTDBkMkN4VU1ld1N3U2l5bTlNRTZmMmZtYklLTWUrOTQvSzQrWGQxVHg1eDB2eS91bWp4Tzl6ZkhDREZwRFJVZVA4eWlmdE5MQ0hTQ21Ud20xZEJ2SkFBRWU2aER4STJZS0NtbDNERmV2UXg2ZmxsRTdYUk9tb0RCYllMVk03L3NuTmhHK0hHamtpYzZLK0MyZm90YS9CWUsrVlJvaWdRc1E4UkRjNjRVSXVYVWxLTC9yVXB5RzI4U2xFY2RneEc0NHIxT1FsSG15ZVlzUmZNSk8xKzZycGUzRU9WRzRsbkxiMXhMdW8xOThFWmJyTk9ybmNCbXF4VlRHSWNQQXdSMytUbEFQM25SZkowUEJzZk9DWEN6S1F0NSs0cnhxU0RFMFpKdDRNelFmT2tMejNQNEp5UjVGTEV1ekZVbzhMSlU2QmRXcVVCeVp3RzhKMHh4eXFRbUcwVlYvc1hQc1FjcXVxVjRCVTF3Z3N1RmowUzIwR0dJaHJxQmNZb2xiU1ZUWUV4RThLMVZVZnJLVVF4RlZGUjFGTlpBa0lVTlZIRHh2UjFDdU5NbXIrQlU0TFo0ZTlVSERIMDEyZjRvNEpDTkZVNk1TcDNGaVZOVlVmTXdoL0ttM2xzdU8zdEZQbFpLbWcrVlRzS1lwcTQ2WkxMMmNSMG91SDlFVkE3bHhSOFBMQmFZb0NESHRDSUtzT1hFWEdZb2V5ZWRVbEkxTytVdis2S2kvbEo0NkJqbkJsZ1FJc1RpRGtDMkprRU9TTFhCUUlvcTFMeXRLYVgzOTBGS3lkRXBURkEzL1prOC8raC9jdzlRWG9ZTmxnSnRaZk12bEhDZitiL1RJUFVqc2RMT3p6UFNHOTNEVGNmYzNuNUFZajEyNG52NXg3ZmVoeWxBL3pnaFF6T0ZSZ2tkMjZmVUVYcTdwNEp0MnZuSGdsZ09OdkYyUFcvVXN1QzFidCtJL0tzNFhpL05MWlBPK0VlaytHekg4ZUwzeFlLTWU5LzhHVFd5ZFBOQm9ISmpjT29FaWxVd2hrYTNYczRtQ1h3V2g0Qkc4Nlg0eFloaVJSS0lxUm9yRmlGaE5CR01IQyswbndDTlltcmtSajVzVG9TZERvUlliL1VSWVkvWWlwb1JBRkw2UHBYOFRlM08xSFNzeGZBSXM5eTB5eHl2TVJiRlVlMndPcHRPSzJBeGFMdzVzaHF6K0lFU01pSTJWWGw0ZWx3VGprQnlXZ3hWaDVyRWxyNmpwYWJWZDlSTVJEamswVkJMTGEwZ1JZb2F1bVJMYUFiNTNxYXVJVnZCUU9mbFdzcXhidVREOW9PR2NwYjlYbWkzaHYzOTB6SWkvMjQrWWppSytKU3BadkdCN3JxZkc0dFcya1VncDRWUTFoZG1ZcU1rcEF1OUdzMGlLR24rMzZhSnVERjNVV1FYWExDVEw1ZVJDMmt1SDR4N0RrL0xpNGJUM3h5UkpVcW4wTFRNdDhJN0RDMmx6UVZRVXNlY3pTSDF1MHpSbXRRNUl2aE15WDduOVlIQ21RYXFEWUNLcjlJZGltVTVVRFBCakFQMFJsTUMvOHI0cDVFYk5heEsrRVg3YTRJeUdNYUUvWGw1SmU1TVJNYU5GdExTVzJKbDVqa05jZytPK2JmT2VObExHM0JhOEFXSXU4MlpTT3NoTFVmNEdYcFBCZGFiUHh6Sml1Sm53OTVRZjF5ZHdYWnp4ZE1SS2U3dk4wZHdPeXhyUlBONytOb2VyUXR4ei9sVUpMWjJFc29ZZmprcjhRVkxobWhCVTNXc3owWmM2MU9xS1d3WlFzTTQ3MUdPSHNLYzB0U050YWgyMHdDd05nVWZnYmIxdWRMOXFjbWJUbU5UL2RHYWtrZmN6YW1TWFh5ODAvNUtUWUJNQ0R2d2hGS0dOUlh2d2lzN3AzZWZ3dXpaTVlENkJaRFdYWHExVkNwVmZwcEdnL0MwSEo2SElnYU9ZdFl6dEg1MFlmSXZ2aGVLWSt3cFJ0SE51dzJlZ3FJd2JQd0Y5WDhxNklQQVRmNkoyNDQ1WTVDWDhmalZ6VW45cWRDV2Z6UXNvczlYZlhuNEZ2MVVOd3U5YUVQcnhxekw1RWNnbHdUTStFdkk3VmthZjBpZnhFNXo1VXNUS1o0K01UV1Ira0paaTM0WDRBWWw3cFpUSlorSWVCMGNLbVowOVBjMTN1QjE0RGF5SDl1R1JmRThvWkJEQlpvQWVRRWtBRDZ1QWNDcU1xb2gyaGdKM0N3U2VjUU81T0Jzb1NFUmwwUTJhMklJazEydy9HaEFMVGFYcTNxdmluSnQwT3ZhdXErMXRqdWNBZDY2YXNjZkRmTUxDQXdKbHlqcllIaXZDSjkyNVVYREU0NU5xSVFmRGlGdUJLTXp2UndhL1RBcDd5Q25YQzN2Yi83NnhXM0lrVDVLWG83WUU3cEVrVDNTa0Y0K09WY0FEaDlzTHhyemRjVHlYaSsvZDUrRDduVzEyRzJYczdYbzVJMGJpZ3BuZ3crTjJvZjRYTmpmNnVyY0RWK2RDTVF6MzhHRUVsM2tEN1NlRkZRNkZZYTRROXZqNUxRZGwvRXVPQ0xhcFViSDdNbTZtSjBuZm54b2YyQVp6bUM0em9XdERmeEM2bjJTOXF6Q1ZiRjVrc0N4QlRuZVdRSWlrQ1lyMW5YTm1xT3FPdXZVUDhIaW9kRVZvRzArRnZRZHBFQTJyckVYOGVRSk1JU3BmdFFqT1oxYUgrYmdWMWNwYTFJcm5vVjdPS2x6T25YZHpuSkl0UHhqaDRUem1ITU81aWlnQlRTTi9ZbitEL3lTeDhvYkc1Ukp0WWtvcjdrMmtHcmExeGFXWkFhR2c1dzBiRkRLck1keHMzTkd4MVd4NXdYak56ZWZkMTR5RjhYZUoyUFV1R3M4WnRSRUJDMUQzQ1R3djNFZmsxVjRKQ2lNMU16dCs3VmZpaGF3RG5uU3l6V3B0WW5rNW4wdVhnNkJ4N2lYWFNRWHh3eUdhcTIrS1pxZm9MWktYZFh6cGF3a0YrMUxaU2tpNE9SRmw2WHFFRDVvczd6bklVaEh0Z3M0eDV4aEREUTZkZDYyWTFwVmtrYkJGeGFTaVY2YUlldzNRbWZ3MnN5cHZIYnFWRnJmS3F6Tk1EcmpqL0d2SXRadzR2aFozckF4OXZxZVg0anFZdGtoLzNOREg4ZnNrL1VFQS9qQWpSdDBZOGJxN3VmbHVxOEtRUEsrZ0N6ZzlpclEyOFF5YXFteHNlYjNVRGp5Q3psMUo4MzlOSFpMYTFDRXBNMmgyc2szY2tQcTRwam5NVDQ0TVo1SDhCSzIra2c5NlJWK0tmb016NE9mVTk1bEV0NFVHYnFsVS9kbnFPYVVLUkg0a01TK0ZsZ3YrL1FWT2hBN0hoYnRkZi80NmZLdEtqN3N2Ni9Xc1B2VnM0OWx2ckFEMFFvQVUwLzNZdjM3ZUJ4d0RpSGxmejliMXFjWTNWbGpPVjVhcmdzVFc1WEZmN0E2dFVMOHFBbDhkZ0ZkdnNwQVViQko4V0o0Uk5qbm9nOHMvc2hUSFFqbE51WG9HYjY3cGREclpMSGp2STVvbmdsdkgyKzUvWGVpT2s5MnpOQTlubHFXb0lKdjF4b21ZcnNkT0RNNkFVeGU5cTVmYmkvbnBGd0pmMWVpdzF3RnJoTnVmQ0FraXJrVTl0RGs5SE5OdUdZWkt1MFdMRWQ3dWh3UWs3WFQ0MFVmRDRJUjJTNGZxUHVrOW5WczBkbVAzVllLazltajhVZHJQM3dmbnFBNGwzcytkZnRVbXhBb0wwZGtEaTNaTjFFSWtXSWh3cEFSamh5aFhNSHVLWjFPOHNvdUxBTitFV1dETTN6b3R6T3QrTU5Da3JHNVpuL0NyVzdmbE1sd2tuazd4cmxkT2pUMVhMUEQxRWJpbGVzZ00xNjlKNEltMkhWdVpqbkxYanlZN2F2VDZ1eVphMnpab0JVL0lpV3d4a1JWNVdENGtjTTNiYWs1cDd2SGE1N1pJN20zN1JkZE5PTHRxaTlQMWQyZXZTOVFtcG0vTTd2RGljNEROclIrRFJ6QWZiMkd1RVhNcTFpQW14M1ZZdCtaaGhabEN0eEhWRUVId3BaQU5kWTR5Sy85MitBNmlNcjZEeEZwcE1hMGxLb2NPS1dMcjFaZ3B4VlJlTWhTVFZ5dzU1b0JqaDJtQXhtR1JHVXk3NzdURU5iSDFPYWNjUnJ4dW9iQ3Rta3JNNElVd1NkQXE5V2s4R3ZKd3oyOE5iUXN0aGRiSTdDK0FBTWdkK0JURHRUSk5SWFhDa0xTb1JPQXkyVjBEenVaajRoWFZjaEhOTkRMYkt0bXNYWlVOTFY2QTAyUWtjMGMvK2liUHdTaVc5N2pEclBDbUU1TXRBWUpGdnlCVUk0MnFiQ244WEhQZUtXZVhGMGg1SENoUnFRcDVpUTlicHR6OUxlbUtUeTlNRGZXT21GMEVQNktKMWpqWUhXT0ZqL0R3cm9ZRlh1YlJuTGxZdE14TXJqQjVJQ0h3Um14UDVxN0Y2UWwvNGFyZHg4dmt1UHNQa29hSENBZUZtTTZIcGJkdnh6M1k2SGZxUTE5WlVqUXh5K2JKajBFbytLYVgrYUlYK1h3WCtWcFVaL0pEYmp0NGpkYmREQzBUcFBKTC80TFFveG5xWDhpc2VENjR3Q2s4MjFTdW1MN0FlbWVMWklWNWFXSm12aWtURWx0WWZnVlRISlJTbVlKUFQxUWJvN05YU29WWFAxVEJWQmdUY3Jkdldid3JJeEE2TEIvL09TVk1hejVYWERUcHFjU0J5ZkhWTDF5SVludTU1ZjRsRk1OelJTcVVEZTNxVy9pR0p5dVc1NGVnVXJrRW1TcEk5RDdJaTlkTFBEOTBxc3pwcjhyaVdZcmxRM0IwZjBrTUhhZFBucnpqUTgvNzBIS3BRbEZFdjVPa0R3V1JIcmhyNitSbWhoOTBRcFRYOFlSOHVnUHlkNm5xWFZMZTdyNUJxOXFKRlBnWm52OE1WRkR2akowUDVBSFNEb0pybVNNb3ZhWGNzSGZ1QU1tQzJaVElmNjByYWdiNG9IdlNZSzhMMXRpTEpvamRpZngvOGJhY2M0MFBxQ01iZFdmN3dIRFBkTEtkcjExSlV3TDlIc0ZYU2VLV1ZFTFRlQVlKZ1NFVHprYWNYa3lJVFJzejUxWmhCcS9mbFdIVDBBQ0VoUVJaczJrSGREVGxqS0w1K2J6ZksvejIxWkdqSTYrU3pTSE1RWlIzcnBBTldCQW80c2dvSHZNbVZNRGV3NFNjRHlkM0g5eWRIQlJ2RzdmdDdoZndKam1JWWxnYTRkSG5DZmR4UTRyWTVLbWY4UUI3Mk1Zci8ySm9EMWtWQS9lNkRYYWJDeW5LbUpjUDZxTXFWNmpQUUpEdW1ScmI4UUE1dmQzWmVlMU9aenZCQXdZbjhQWW5BOVhZZjh0aWw4SkpWU1dxUXBPcW9ud21Za2t1REpzd3Jtb1dPRUg2byt4MVQ5UEhPMTVaSDFLQ1ViSUVIVkgySElhWjdTWmtjZDJLSzd2a0NKUjNRU051YmZSZnJsSWJZOStwcmtDaU1xWm5mUTZKYnArZGR5bVVDdkVJS0JCV2xzaE9zNjBLYzNNbW1TTEEreXFlTUxmSkZyL2psS3lCYkxycWNYRlRwaG5mbmtEUFlBRnZZWVJYWGxmbFQ5VUxjM25mRTJzekUvc2EwOWM3RFZ1UXVSd3Z5bDhMeS84VFMzTjRVWVpMbEE5c1NBakxpTEF3UHBlZksyVGJadE01Mkd6c20yalhXVzZTYzNqOC9GVklDczJGZGhMdjJRR2lRRUE1RTRDc1FJVThoYk5xMFJmR0hEZjFyMlorUExpMVdNb2pvblNKUUQvbmtTT1F3SWRBZ2JHdDUxR0lGelRxM05HaUlIK3pyZC9GU2F4Ry9MMi9GamgrTHg4V25ncHJtVDBqV3hyMU5vU2VHaTRuMDdIeFp0SDNrbm9oQVNGUU9FeFRRbEpRdXJ2Vm1DWjdGdUI4QU8vTThRcC9OUTlCWk1GSmxRdGorWXpqWk55NTdId3Q3cUZURUhGdnNvQ08zREUrSXR6TlEvaHBNK3BuVXNrajArMm03RVc5c3VzcXNxV21MVjRXZklHUDhkRGd3S2VpTVZXeUVyL0FiTzEraStOYlVCRUtqWWdvUzNMQlAzZ2c0OFpMOXFoOEk4ZHhsTDZKZmVJVmlpVmNJYjVBZlh6MmZpb0dUSzJWT3UxRTRrZkFvckx3UXRQckZYcVNlVjhHaVd3NkFVQVZzeTk5aXdmOGxpZWYzSUozSksvMjVNTVBUK0x4OWNWRDk2OS8vbzhPUVhKUzV2ZmVlZnZ0ZCs3RkJaMEhxd3pzcXNFTVcxbW93dWxpY1JydlRBakhNcGt4Q0wrK1A0WC83U2U2WVI0dWU0bUV0d3h4Y1JOT0NPTWhwOCszc1lvOSthUnlYZ0gwOUx5NURkQ0Z0N0ZYV3R1d0F6b1RtOEdwalZiUTFRM3dYTUd1K3dNaVgvK3FaMXZydldPR1pZZmZaQVBlaEdCSDFmU1hpMFlkZnQxWVQ1NG5nSENmWFZ5RXZJUDdhbUVCOTc3RHc4VUZudnAxMEdNWGJqTGhQdEEzQzNQM1h1U0pma1JxSUNNR2JVbGN0Q1didXpOMjRZNWp2LzJyWG42SXN4ekE2N3FLUDJxT2tDUHBpaGdDWjdzMExoK2N4dHRzSDRRUjl1ZnBCTFVXMHpmWkFBdk5BcmFwMURLVGN3TmZJUEpheEdPUXZrR0hGZTRuSGp4cmpWVHNMT2dRbDhJRzh5cWtCZXBRMkRpemprV1l4djhYcmYzbkJXbnQ1TzlIYTRpTzcrMzRIVWtPM2x2eC9IaGY2QUdTVlRLUVBvTzRMaEpvMjQrZkNVcER1WkFIdVJYZFhwaHhjMURxMTVWcmlnV1gxb0RYamVZMnJwa0IvYU5Xb2RMa2FLclZ1a0d5Y1FnSW1GK3lBT0t6dkFpczR3Ykw4d2FNQm9VR1VuZVIzYjRHUGt0eVFFd3RUT0ZTRGQ4NXVVb3VYSzEySDdrN2ZLQUJJUWM0Q08zRlJTVG82cDA4Unc1NWQxRzlUdjBzaU5PMVkxbFFFTCt5d2lPMmxkRXlXMUxvOW0yU3d1UnR0bVduRzErTm1wcG1SbTl1ZU02ZzNHQjhHbmlmNHRZUSszNW5hSjBwMGNWRlpJb0haaWx4U1BhVk1VQ1dUU3FaVWlTT1ZvbkVaZmRUUU16K09UTktnMXVkM1dPNi9wSzNOTzI5Q01rNjc4aWlaOTRrQ0RlWm52aUxvdjEwMk0ycllNK3hiUFpZdExsQUZ2ZUZab09abWI5ZUdvTXZldFBMaVpkMG5TenhKWjJFOXJqNVpidjRqSnAzdzc5dXQ3MkFtZWpGbXJCOHpNVCsrbWVoTDVNc1ZrUEtuQUtiOFZsY3djWTB6UmNzblo5aE5TaTUwN09ZeE11NGkzQVBPZFptTEFWams5UFNHS0RaZFY0NHNVWjBFbXR0R2x6UUlSRUNzVFk3ZFlKc2c4dFVhekU0UGFmamY2Zko1c2ZrSEZPVXROdDlkUWxzVTFmbnMxa0I2bERJMGxycER3UW5oclpWY250MTZNUkpSWkppa3FTd0haZ2RhRTI2YXh1MEt2Z0gySndGN3NhbFhZSHVCSE9KMUk2OWVUaGRVbi9XYWc0TlRuQ2tKdkxMUkRPc1NzdThXQk5GL2lnZFJYdWlSOGp1aUNoVUJKRUd4dDRVWFNHNzZhTjRtSnhDajZVTGRzSjhESVhSODVTeVBZZnVhQTdrZTJqUjhlanVlUlFPaGY0WDEzNDFRSGljWTJCa1lHQUE0Z3ZpajZiRzg5dDhaZUJtWWdDQmE3dVVic0xvLzEvLzcySnFZendENUhJd01JRlVBd0IydGc0d0FBQjRuR05nWkdCZ1BQRC9BQU1EVThQL3IvKy9NN1V4QUVXUUFkTlpBTHNSQ0VZQUFBQjRuSVZXMjVIa01BaEVqc1NoS0RSZEpoZUtRNWtRNXVmcXFuYkc0d01FcUpHMWV4K1VKQnMzejBZbUlpb0gwVVpENUp6a2NiMjJ4dS9hOWQ3cTlTbjF1Z3FmVldUUFFxd25JbnZFR3BqeURZdGo2aDdPS0F1OU81N1pQeHg3Z1hQTWVtT3ZHSWhYN3o3ZnhIV2FDL3ZWdW0rSy9lelAranJyTHFTYUw5VmlSS3lSMzgvSVg3ZFJubElQMFpWdkRLUGRmZTNZRmwvN3ByWUxTVGk3ck4ySGxIK3ArWU0zandXRzlFQjEyOWQ1eDhNYTlQN0JYT216NDNwSjdGei8zbTkxMUV2M2M3ejBRM3hXNi8vRkd6bWZzVmUxbzk3UDZxK3NkZFNQMTU2dnFud1JPVlBNQjhUcTlpdUk0QlMzbit0ODAzZXV5RXJnaDR2bjFuRnI3eVdQVFhrTHZaSDVZTGI5SGNjeDh0anRqbmZnWDNVZndiN0ZVdHlQbHZQOXJSd3dhMzZRWk9PUXZnRS8xRWVwQS9USTgvcGkzUmZ5aHAvOTlkcHFySHRnOXZyOTlyem1HanFYTGJkdmxxK1JTNTlsYkgveWM3UDRQSGZkN2pScjlsRTMvejdOQnhleVBFRE03aFA0bHVhb2MyT0wzZ0VmTUM3aW1LcnkrdlIxekJUbXFmZDk0cnJrQVcxUEhDVGpzWjlCTC95amZNOUVUOGs3dnBQS0xyWnovZm5abGVaZGcxd1EzQ3MxeStDMThiS1ovbTUrTFhDTTY4WjdyaTlSM0YyWlQ1eTN3L01qczRGRk1YVi9Xbi84MGZjMWVITmlyVmN4Ukg4MWl2c3J2VFArb3orSzVYZUg5cURkTHgrV1h6SGJYbm11Um4zSG5LNjlmMjBQY1hpOVltYjRUSHJydlRqanRtbHVWSnI0N0xVQjNsWHM4NTUzdnlOVDc0Tit6b3ZxeXQyQ2RUbjdmdzJ2emZZeDArKzhDUjhtN0h2dDErZWNXN2ozSndudTE1R3YwSC82ZWNGdDZweEcyVUJLd3AxNnE4RXNnVHlXaDg5a3NDUDlJNzBhZGFieHY5Qjc0MXpIenR6RnVrZjh6bStLdXczL2RUQUcvVzRmOTF2WngzZDZmblp1OVBrMllobjhEcDZjdC84bmxCcDZpdmNQMlRWd2ZRQUFBSGljUFpaN1hNOW5GTWMvenlPVHlRcGxvU1czQ1prUWhVYTJYTWVXNnhvaFkrNjVUS3dSMnRiSTNFS2prZDBZSWJUV2FEUWFiUm1aVUlSTUxOTmNRNXRRcy9kZjgzcWQxL2Z5bkhNK2wzTitYMG4vLzZ1VUxCYzdVNnFXSkRtRVNOVWRpRXpwR2Q0NStrazFZNlZhNVpKVHNWUjdFbEVtUFJjbE9WUG5QSUJJSURoejhTSElxeE1uMVhVblVxUjZRY1NYa3FzM3diTWIvZHd5cFBxdUJQMmZkeUZTSlhkdzNlbmJnTDRONmR1UUhvMDRhelJOOHFDWFI1YjBBdGlldlBPa3pyTkNhaHdqZVRrUjRIdUIyMlNvMU5TUmdIc3pjcG8zSjhCc0FXWUwzcjBZVEd5Uld0Sy9aWmpralU3dmVLbVZoOVNhbkRiaytzQ2pMWGt2K1JMSmtpLzgyK05MQi9BN2t1TkhUU2M0ZENiWEg4MEJYTHNFU0YzaDJJMnpicm5TeTF5N2s5TTlXK3FCN2g2SlVoRHZndURVazd5ZStQbUtGd0huWVBnSG83czNlWDNRMXcvKy9mS2svdWp1WHlnTmdNOUF6Z2JpeSt2d2ZJT2FrQ0pwVUYrQzZ4RHloc0p6R0Y0TUoyODR0VzhTYjlGL0JQTVlVU3FOWEM2RjRkRW91STJCNnhpOEMrZCtMTnJmNW5rY0hNYlJkendZNzlCM0Fqb24wSHRpdERUcHFEUVpQeWFqZjBvZ3dleW1VRCtWdXFua0E2OXB6Q29DdlJIb2pJRHpkR3Bua0RNTDdyUGc4aTd6blkyZnMza2ZpUWVSWU0yaDUxeDhlSTg1UklINVB2em4wWHQrdmhSTjN3V1Iwc0p3YVJHWU1mVCtnTG9QNGZNUitiSG9Xb3hQaTltckpYQmRncFk0Y3VQUXVwUzhwV0IvUXU0bmNGOUc3VEpxc0VETHlWOEI3b29TYVNVOVZ2RnVGUnhXTWNkNDltTTEvTmJBWXkwMWErR1NBUGRQOFhZZDgxOFBuMFRtOHhtNEc5ajVqZlRaeUhrU1o1dll1MDIzcEMvZ3ZabTkzc3gxQy9qZjRORld0RzFsdnR2b214d3FiY2VISGV6QURqanVCRE1GNzNhaGNYZTZ0SWU2VkxoK0M2ODBacDNHekw2akxoMnU2ZVR2NWYwKzVycVBuY3VnN3cvbzNZLytBMkRTU3BuTTg4ZnhCUG9Pc3VlSDhPSVE5MW5NNVREbmg5RjBCUHdqekNpYmF6WmUvMHp2WDlpYkhNNXpNQ21INzhGUmRQMktwbU5vUFliKzQ5d2Y1MzB1L1UrQWZ3Sy9meVBuSkdkNThEc0ZoMVAwUEUzOUdYTFA0R00raEFyUVd3RCtXYnc3UjM0aFBNN2oxd1htY0pIZEtJSkRFUm91TVlQZjBYb1pUY1Y0VTB6dEZYeTRDdjVWN3YvQTZ4SjBYZVBzR3IrcFA4RzVEdTlTbmt2eDdBWmUzUVRuRmo3ZTVqZC9oN283Y0NoakJ2ZkF2b2QzOStGNW54azk0RnFPbG4vQWZraitRenlwd0t0SDlIOU1yeWZ3ZW9JdmxlaXNvazhWNy8vbEcvQTBWa1krTXNhUnlKYXgrVElPcmpMVkJ4RGxNcytreU5SSWxuRk1sNm5KY3kwL0dhZEltZHFwTXM3VXVYakwxQW1ScVJzbVV5OUJ4bzEzOVYwSWFwNGZMK1Blbk1pUWFSQlBVTitRdWtaRFpUd0NDWjQ5TTJVYVQ1UHhLcFZwUWs3VElLSkVwdGtXbWVZelpWcTRFNVV5TDViSnRFeVU4WTZXYVJVZzA5cUI0TDROMkQ3MDhnR2pMYnhlNHI0ZFd0ckIyOWREcG4yb1RBZjQrS0duVTVKTVo3RDhzMlM2d0t0TEZBRldWL3AxQmE4YnZRTFI4VEk1M2RIVmc1cWdXekk5eVgrRmVKVStyNUlYRE1kZzhIcWh0UmVZdmREUUd6Njl5ZThOYmg4bmdoNTljbVg2Z3RtdldPWTF2QmpnUzlCdklENjk3a1ZROXdZYVFxZ05nY2VnNVRLRHlSbE0vaEI0RCtWK0dHZkRlSDZUM0ZCbTh4YjFJK0F5RWc0ajZSOEczekM4RzBXL1VjeHZOSHhHNDljWXRJWDNKZkpreG9iTHZBMnZjY0VFdWVONS93NXpuMERPUkhwT3BtWnlrY3dVY3FZUzArQVVRVzdFVVpucG5FM0greG5nem9UM0xEUyt5L1BzT0psSWNpTFppemx3blFQL3VjenZQVHlKd3Y4b3VNMkQweng0ejhlTGFMUXR3TjhGdkYrSXJvWHdXZ1JPRFBzVVE3OFAySmNQcWZzSTMyTzUveGhkaTBYZzl4SzhpMk1uNDhoYkN2OWxoVExMNGI1aWtzeEt6bGJCTVo3K3ErRzJCdS9Ya0xlV1BVdGdkeExBU0lEYk9ucXZnLzk2c05lakpSR1BOb0M5Z2V0RzhwUFFzUWtkZk8vTTU5UitBZTh2NGZFVk8vYzE3NzhHZHpQNnRvQ3hGWXh0MUNhekE5dmh1eDArTzZqZnllNmw0UFV1ZG1zWG1MdVovUjU2cGJMdnFXQjhpK2RwekMyTitYMUhmTTkrN29YLzNncVpmZVJua0x1Zk9CQWprNG1QbWZROVNONGgvTXRDU3hiY2ZvTEhZWDQzMmV6RnorempML1RJUWR0UmVQeksvSS9CNHppZTVUS2ZFOVNkWUo2LzhlNGtlazZpTlkvZjFDbThPbzBYcDhFOGc4WXo3RUErM0F2b1U0RHZCV0NjUmVkWnVKd2o5eHk0aGZRNmorWUx6UEFpbUVYTS9oSy9tMHR3dkF4dU1UbFh3THFLUjMrQVYwSmNnOU0xZXZOZE05ZmhmNTJjVXZyOGhiWWI2TDdKVEc4eW4xdjRlWnZjTzJEZnBlZGQrcFF4MDN2YzM4UGorL2ozZ0YxNHdDeksyZDF5L1BvYjN2OHdsNGQ0VU1IMUVXZVB5WCtNTjAvb1dZbWVLanlxWXMvK1pRNVB5WHRheHArRVVVU2hMTjg2YXhOa3F5WExPb1RMVnU5TDVNdlc0RS9HR3B3NXVzaldESlI5MWtPMmxydHM3WGpaNXlwa25XTmxYZUprNi9nUm1iSjFRMlhyVFpKMTlaVjFJOWN0WGJhK0QxRXN5MmZjTnVDK0FYZ053V2tFdmtlbHJHZVliT05vV2E4QTJTYTVzazJ6Wkp2UmgwKzhiY0dWditWc1MvcDRwOGp5cmJPdHVHK2RKTnVHL3Z6M1lIMFNaZHZDbGIvbGJEdDQrOExWdDBpMmZhcHNCelIxREpIMWcyOG5kSFYySVBKay9iMEpldnVERnpCVHRrdUdiRmM0ZEtNdU1QRS8rdWVrNXdCNG5HTmdaR0JnT3N0b3dTRENBQUpNUU13RmhBd00vOEY4QmdBbGZ3SXpBSGljclpJN1RzTkFHSVJublFjaWlTaEFpaEFGMmdKb1FFNFVZWW8wS0UzU1Jpa2lVVHJKT2cvWlhtdTlTUlFxTGtQSEFUZ0dKK0FVSElBL3pzOGJCQVcyZHYzTjdQeWpMUXhnRjQ4UTJEd1ZXaHNXNUZlWUhXemhrRG1IQXh3ejU0a3ZtUXNvNDRxNWlDcEd6Q1djNHBxNWpEM2NVb1BJYjVQYXh6Mnp3QkVlbUIzczRJazVoM1BoTU9lSkw1Z0xxSW9aY3hGbjRvYTVoTDY0WXk3anhISGFPcmF5dFZTcGp0UjdscDdzR3QxVDQzbm9tNjhIOHRlVHZqTHBWTWZTYyt2ckVHZTh0OUtPaXBYeHJSckp3VXFtaTNIRDJrQUdSa2R5blZkaHFHVmk5RXdOclR1eE5tbldhZ0g3N2xCSGFFTWpob1ZFQzBzb3BLUWordjdrUzNpMHVqQ2tlNlRIbUNPRVQvb3ZFL0lmWnZxa0RDV24yZXc2NmFMKzJ2U3h4L3YycGgxU2NkYmkwNFNpUDBoaWdCWHRLUmFVYTVCckVaQU9zdW1JNktWZlVVZVkzU3JKem1ia0RNbDNNY21tRWpSUm96ZjRsSGNwUlUzUGhncVJDZ0I0bkcxWkJianMxQkYrTTdNdVY5NTdPQlFybEFLTFU3U2x1QlJwb1MwdTJlVHNKbSt6U1Y1azkrNmpBc1ZkV21oeGFRdTAwT0x1ME9KUWQzZDM5ODQ1SjluTlhyamZ0OG4vVDQ0a1IyYitPWGNKTHRGL3hTV3YrWWN2QXdKQkFZcFFnakpVb0FvMXFFTURtakFEc3pBSDg3QVVsc0Z5V0ExV2h6VmdUVmdMMW9aMVlGMVlEMTRINjhNR3NDRnNCQnZENjJFVDJCVGVBSnZCRzJGejJBSzJoQlpzQlZ2RE5yQXRiQWZid3c2d0k3d0pkb0tkWVJmWUZYYUQzZUhOOEJiWUE5NEtlOEplc0Rmc0EvdkNmckEvSEFBSHdrSHdOamdZRG9GRDRUQjRPN3dERG9jajRKM3dMbmczSEFsSHdkRndEQndMeDhIeGNBS2NDQ2VCQVcwd3dRSUJIZWlDRFE2c2dCNjQwQWNQZkFoZ0pZUVFRUXdKREdBSUN6Q0NWWEF5dkFmZUMrK0Q5OE1wY0NwOEFFNkQwK0VNT0JQT2dyUGhIRGdYem9QejRRSzRFQzZDaStFU3VCUStDQitDeStCeStEQjhCSzZBSytFcXVCcXVnV3ZoT3JnZWJvQWI0YVB3TWZnNDNBUTN3eTN3Q2ZnazNBcTN3YWZnMDNBNzNBRjN3bDF3Tjl3RDk4SjljRDg4QUEvQ1EvQXdQQUtQd21Qd09Ed0JUOEpUOERSOEJqNEx6OEN6OEJ3OER5L0FpL0FTdkF5dndPZmc4L0FGK0NKOENiNE1YNEd2d3RmZzYvQU4rQ1o4Qzc0TjM0SHZ3dmZnKy9BRCtDSDhDSDRNUDRHZndzL2c1L0FMK0NYOENuNE52NEhmd3UvZzkvQUgrQ1A4Q2Y0TWY0Ry93dC9nNy9BUCtDZjhDLzROLzRIL3d2OXdDUUlpRWhhd2lDVXNZd1dyV01NNk5yQ0pNemlMY3ppUFMzRVpMc2ZWY0hWY0E5ZkV0WEJ0WEFmWHhmWHdkYmcrYm9BYjRrYTRNYjRlTjhGTjhRMjRHYjRSTjhjdGNFdHM0VmE0Tlc2RDIrSjJ1RDN1Z0R2aW0zQW4zQmwzd1YxeE45d2QzNHh2d1Qzd3JiZ243b1Y3NHo2NEwrNkgrK01CZUNBZWhHL0RnL0VRUEJRUHc3ZmpPL0J3UEFMZmllL0NkK09SZUJRZWpjZmdzWGdjSG84bjRJbDRFaHJZUmhNdEZOakJMdHJvNEFyc29ZdDk5TkRIQUZkaWlCSEdtT0FBaDdpQUkxeUZKK043OEwzNFBudy9ub0tuNGdmd05Ed2R6OEF6OFN3OEc4L0JjL0U4UEI4dndBdnhJcndZTDhGTDhZUDRJYndNTDhjUDQwZndDcndTcjhLcjhScThGcS9ENi9FR3ZCRS9paC9EaitOTmVEUGVncC9BVCtLdGVCdCtDaitOdCtNZGVDZmVoWGZqUFhndjNvZjM0d1A0SUQ2RUQrTWorQ2craG8vakUvZ2tQb1ZQNDJmd3MvZ01Qb3ZQNGZQNEFyNklMK0hMK0FwK0RqK1BYOEF2NHBmd3kvZ1YvQ3ArRGIrTzM4QnY0cmZ3Mi9nZC9DNStENytQUDhBZjRvL3d4L2dUL0NuK0RIK092OEJmNHEvdzEvZ2IvQzMrRG4rUGY4QS80cC93ei9nWC9DditEZitPLzhCLzRyL3czL2dmL0MvK2o1WVFFQkpSZ1lwVW9qSlZxRW8xcWxPRG1qUkRzelJIODdTVWx0RnlXbzFXcHpWb1RWcUwxcVoxYUYxYWoxNUg2OU1HdENGdFJCdlQ2MmtUMnBUZVFKdlJHMmx6Mm9LMnBCWnRSVnZUTnJRdGJVZmIwdzYwSTcySmRxS2RhUmZhbFhhajNlbk45QmJhZzk1S2U5SmV0RGZ0US92U2ZyUS9IVUFIMGtIME5qcVlEcUZENlRCNk83MkREcWNqNkozMExubzNIVWxIMGRGMERCMUx4OUh4ZEFLZFNDZVJRVzB5eVNKQkhlcVNUUTZ0b0I2NTFDZVBmQXBvSllVVVVVd0pEV2hJQ3pTaVZYUXl2WWZlUysrajk5TXBkQ3A5Z0U2ajAra01PcFBPb3JQcEhEcVh6cVB6NlFLNmtDNmlpK2tTdXBRK1NCK2l5K2h5K2pCOWhLNmdLK2txdXBxdW9XdnBPcnFlYnFBYjZhUDBNZm80M1VRMzB5MzBDZm9rM1VxMzBhZm8wM1E3M1VGMzBsMTBOOTFEOTlKOWREODlRQS9TUS9Rd1BVS1AwbVAwT0QxQlQ5SlQ5RFI5aGo1THo5Q3o5Qnc5VHkvUWkvUVN2VXl2TEdrWWxoV0tLR3ExZmI4M0pxWVJXaVhEV3BGRWNkMXdqYkRmTWwzZjVPZXUwL1ZhcHZCaUVUWTFrV1djenFpbW1TczZzb2FFb2RPMTQ2cmh1aUxzT2lLcUd2MTI0aHFlS1RZMitpSjBUTU5yUmFxSzRYVVRveXRham13MUNFWHNlTjBTRjdUOWNKNmZ1YUpsK1VsYjNZYmV0RVYydDNUS29ucWRuVElsUVMzalF5K0YrajBWVkRVcUdpZEIyUWhOMnhtSTFZd3c5SWN0dzQxYnBoT2FhZTFYVzJWRHE3L0txdHBjOWlwekVzeE1iSXZhNjRSK255Y2hqdjMrc2tWVzJjZnlSVGJWdzlKRnh0alBkeUNyelU2b3FwSHJNRnFaR09HclBpdTFMdnFzMUxyNHMxSnpFdVJzc1o5K3hmeVVUYzlVM3FJYW01c3k4ZnMzSm9Za1NKdklUY0MwSmRkb2Z1Qm5wMHh5K2hYUDFjOE45bXpPSXR1YnkzSFYya3pPd0MrWU5xWVhrSUtxVk5wd2JsQ25MYmxYelEvbTdKUXBDVkkrSHNUbW1Nc0dac1pNVlc2TUtiOVhSWk1rSGNGSURhR2RKNFBhaEZSU2FHZGdVTkpnSFNPS0hON1JBMzVsdmd1UE4yTXJHakhxUnhXRGI2RVQ5ZERnNzAwc3gyOVpJakpESjRnZDM2dTBEYk0zWk1kUmJ4c1diMmZURm1hdnFIQ3piYWlkMzRwTXd4WFVObVJoejJvWmppd2NtcjRsNUVzMU1od0t3eG9UcnVPVlUxTGdlOFN0UllKYmRGdnlVc25ZTElPZWlNY1A4dHoyL1lEcnhqYTNHdk0zakhoNDNiaVpFZEVQNHRINFVTZHgzVEd4RGJjem14RTVTOUx6WlR4eWpjaGVQV094SFFxUmxZbW9MYXhDVzRpdzFoYjhCcXBvUWNKeTJ6Rkh2REJyYmNmelRYYUo4b3VjTUxZdFk4U090eWVLYmRmeHVLN3Zxa3ZNbDM2N0lQMXpSVjc2UnRocnRQMmhLMmRHZnQyWUJJNFhWZHYrZ2g1NllsVGtuNGk0d0lKODNuWDlnU2kzUThOaHB6emZEaDNSTVhud1duMWhzVHQycTJNTGwrR2xJRUpxSjkxS08zRmNpNnN6Y0YzMnlaNENrUmp4YkNTaHgyV2lHdGVXWHhMN1lVUE9zR2Nab1p6UW1URlJiOVFjVSs0d1hqNWhDNlpyOUEyNWlDWTErbzZYUkpNYWdadEVrNGV4MHhkUkphUGNQVWNVUXkyaEZISVVDZjJTSmx3dWlCSlhSTVJoYlo1L1lzcW5UMXZVUHAyeTZIMDZaV0tYb3JtS0tCb3FoNkNoZGdnYTV4M0NsQ1hYMFpSRG1ESWxRVVZ6OWd3TTR0YkVrMVVWbDhOU04wWElJWmluTUJZMTA5YkZoRkhWc0MzSFJ5RmVJeUkxQm81b3FDbEp2eWdsdXRlaUluTjhsYkxBaVd3LzBFT2JNOVJUNHZOK245VllLUVJac0o3ak14cjM1UExqUjdVSlRkdnZlZktyYysxclExb3ZNSVplcnA2a2FXOHJFeUc4WEcrS3A3VkMzaVc1V3BJV0ZWekcxMEhvZS9ucFgyeFR3WGFSTFozUWFTTkh2Y3lTMHllTGJWUE41VFhLL0NJak8rNkpaZWlOaVd5Z21SRWRnRE9XVzF1TGJWUGQ1dGZYL0NLalhNcXBKUWw0bEhpdk45SVA5UHpZdEV1YXpKcXVFNmpaMWx0NVpzSmxtS2lPYVZGTnU3eDZZcDZ2a2VBYWhnb1FQT2xMMlpKWTZvMWQzN0MwajVneXpXbWFCTm56UnQ1UVZLUmd1a203cm9JRE96TVdpaHFiZnIvdjhLUkx6UHUrS3dvU2xreS8weEdDVEwvTHZCdVZUZDlOK2g3dkdpN09RbGIyVVU1eEpiM0xRdjJBSTJGRDNwVWk1bExOTVJrNmxxaGtiTjcwdllFWStXR0x2WHVjRnN4WnVOZGdWSldYZEFKQzZmMlV4RzYxT1N6MnBpd3NNenhlMHhOTG1lT3J5WEdzWUlZc1B2Z1NSYmJoaEZIQlROcThWZm5DYjV1RU1nQ1FtY1FWeTRnTkdSSUxsakE2ZFk3UHZWanYzM0tLcTVaamREMmVtS2pNcU85N0ZsbWVVYmQ4bDBPUmt1UUtwMUZ4WHVNT08zY09hTEtkWmRNV1ZhbzVaU3NxVnJQOHpHRldzdG10V0VtL0xZTmdRWDVmVWF3UVpqekQxQWxZZExSc3RXa25kUEprTVAxazBCUTh3SzRmaUJiL3ZOa3gwNHU2a3ZFU2UzOE9ZMVdSaEw3NnNnYUhHcHVsdnBJYmxZd3N6UVdnOUkyblRMclY1WGxUSERvcVk2am5qRFd4RUNoVjQ4YnpHUndMcnVhVXBaNHl1WkJLR25NVmxnMmU0VW8vcmR6WG10T1dkTVB5ZytXdjlhQTVaYXh6ZUc1WnZHSUMrZm1NbGY0Z1JzME9xN2hXcHRVYWluWDhVQkxxR0F1bGp1aHpXRzEwSE9GYXJKdDQ2WTNxSGJsd1JkaGFJZUpLeDNHMVdOTkFaMHMxVGFRazFGQTVpYXFHdkFrMWtuT3VIL09vQ1hjdWcrTUJWQWFuejhtZ2ZwWUtrMGwzcVVFWFZBcEJ2MDlnZFhRWE1oN09hdVFQT1p2ME9hblVwWlZrMEhEQW8rN3I4a00vdEFvU3lYYjZzaVBKK2lXKzhBZlBkNXhRdnFITVNCT09leUlzU0F0WERYblVXTDNPOElydjZvOFZ2R1VMa2hiNUV2WHFIWlp2UEdSeWZaWTBMblI0YXpjN3ZwL1RxR05tQzdjdlI5Y1BlNjdUaWN2cGxCVFpId3k1Z1NSbUpWanVzcDRKMkF0MkRWN2YxQlg5V3BjRmtBaFoyMFNGTGxkcmRybnZxTVVTa1YvWktiTGdhNHRxMTNjN3FqZU5wUE9jNllhR2xhUUwzZ2dxZHJxSTBONFc3ZTNRM243T2xzdlQ5cFh5NHpDL1VGY0cxMW5GTDFWVE9EQjRiYVZRR0thWTFWQ091UExtZWE0U3F4eFhuckNaTTNEMG16QVJ6aWdTQ2xNNEEzNkJxcWE4R0hXZHlIU2l5QThqM1hzVThBTlZoRDFqVDVSdFh1bXgwU1hic3NvMlp4TGNRRTNlQTV0alVsUmtHTVpWZFcwTEkrWWlDMGJYOThvMnh6RS9ITlgxbW04RmlleE5ZODZIekY1VXNQMithTmgrRkRpeFhwU3pZeEtOK2p4QmxZeHp4U1RVYzhFVE5ETmhLcDJZMENoVzc1THhpdE5pVjg1ZlZuRTROc2pNcWU1WU9pNUlCNTdpb3RvaEpYWGxLcDVVL0k1WDFjQlA0cUpDSmM0aE9KUTErSlpFTWFjbjB1TmxwTzU0SFQ5MWRScnIrUzlJekMwTnVDYVBSVWwraTJQT3JHQnYwZkxsU1kxME1jUkRVdUdmaXZlVjdQaW01SEtVNXl6TDViQlRkQVhIbFJsWDhESlZhMEc1N3dsdGFKaW91RlRKU0pVWHZsUXBQTit1WEIrY1pyUUwwcGt4WlVrdi9YZEZpZzAxRmdyd2xsRDN4QzNJK3d4TEQ3Mm1sWmV0WklLMHFZRGNpWkpWeDZ3ZzBUSldLdDNXOUxITVlwdFNVNHRzT3Bndk1ySk16MW5VTHNoeHRRdHlYTytDbklIRm1NdTNnUlBKZk5wTk9EeFpmbGpraVhiTUVsODlsZ0hTTzgvMGpVQnVjblk2YW1RbnRDd2g1NEZWZVpjakZoR2pPaitNVXFIWlZKZ1hnZDhUTFh1S0RlbzVWcEM0eEE2MzU4VFVGM2FaSlJVdnpsRzE3N0FJWWE4ZnpDaWtkcFY4aTdrY1ZkR21OakUwbEs5T0YxeFRrM1RmcGN3M1k4blNnbWtpb2tpdDc3ZlRtTE0wZ3g2SE5rZkx4MmxUU1ZPMmVyeHZHYnA2Z01hMDBQYzUwUFI5WHQ0cUMyLzIvU1FTbWQ4cDlwT0loOW9UQ1pPcUo0YVI4bkpObHNJaXlxSlB3MjlMM2RMcWhuNFN6S1FrOFJRdHA5OVI1bjBvdDE4OU1LUjdhNGNKajBjZ0QwUFY4aTFwV0ZldGM5QXlPRE5UV09wb1JxSEJEanF3aTRFOGNXa0VobnhGUFhoRlJZZ3pvWEs2bm12eXJnZU1HRXBxT3E3dVJVRlowT090VzVidHEzZWF6RkVqeGFwNlNnWlNJSE5Ia2hRREhyT29xdDVRTmxsVXFNN1hVZnBDQlluNWtuVHJNdmhtQ2FYQzZSUnJrbzZNTHBXNkc0bkxnVytaL0owVStINGw4TU00TkZnbUJINGlYVHV2NEtxSzVDMVc4V3RJdlowZE42a0RNcjBzbHIyR3ZSaUVNdlFIdkZTRmxmRHpScENzV2lWMWdjTlJwYlJTSFNmTmN0WVk1VlRmaEtkQ011UFZsWWxqc1hveDdkcktoTmVDenZZMVZMdTRIQm9tRjQ1TG5JOVlmbjhaaDY0NFBXbVdjWWxqckZnNnNXVmZPVE14U1NWWVppclhaSVdsaEsrMGlBUzFVSFRsU1J6alJpZzQxTWF0YlpYZnpFZ3RCWExHTmF6eXpaVWUzeTBxVkE5RlBCUjY2WlZUWEFoWmo1ZGtUQlZ4TFl5eUtTR0d0VkJscEhMd0dRWkN3MExFcW1OT25zWjVQQjJaLzErV0dXS2YzUlhQQXFmaDVkUldZWnF3M0E4YmtaQkNVU3UyZWtyazNKYzA1bHM0NEEzSDhWc3BYSGN1UTlsSnlQaFIzTkFvOVJDSzFGbVo5VGlFcUJlT2JLVmNkVWtGbFR3cmFWTGdXOUNVbDBBS0c2bCtaOFpNU2tTcklZODNBbjIyMXAzTkVYbVkyQnh6ZWZyQ2JjcWx5ZDBuY3NtWlBKWjE5UzhOUjIzTWNvcWJVLy9tYUNqRzdrSE5ZVVpLRWhndVY0bFpmd2R6a2N2cklaUXBVZmI5bVdIOGFMRDQwYUFZOWRuM2xhTytMdzlZcXBIbkQxbUw5c1FzS3dyWlhXQWJLaVkxY3p6aHZoUmpQNWdLdDVtOGdjT3lvdW9BU3lFdlVmKyswZEZ0eXNMdVQvRWtLTWg3azUyblBQUFZvMU5rWmdtMk9YcTUyQTdudGltcnA3bU5QSGt0YVR3bnBWRStPYWdxZzlSUEJZbWF2Q09DU1JxaldLcVo2MHhpVm1LY2N2UFNrTkp0Sk04eUpPWk1XTy8wcXNSRGd6YzBXME81TlFhT0dIS2pvY1BUYkxNcjc5clZLR2xydDFKaU5EUkdsU2hoRjhBWkpVV0pWNDk0WjRUNmVTVWFlYWJhc0JLVW81RVVNYUxCaWJoTVBOajdPbEZSa1pxNnFxbGZtc0ZjTEpzMk5WTWFKdDJ1c0VxYWxmVXQ0ckttMUtOeEtnRW1sTmpORnZnbnU0eFl0Y2JHZ2xQWEw2RVB6TGtNYjBURFplTkN6RDVhK3ErYXd1eUVZcnNTMjd4WXc2NG9TOENlQjJON1B1YmNwNTkycHpMK3VieEZ6dHVVUVU3VHNyd2hQUlZmTzIrYlBpK3Y1eDR4VHZydFNKOXpwcGdYb2tMOG9iMWFySTVFbE1mVHNLSFN1MHhnYUpJSkRNMHlnYUZaNmo0VUtjUXlVc1IrVi9waERqUFZESExmbkNZSnFheUswbDk3czN6MUlwMXpxYlBISEpkbEkzV0NVVlNvSXBlVldoTVNWTElEZzFvc0pkRkl2N3FDWEp4VERZcmpVU1VlNklOcmpBY1YvdFJRdUs1UlRWU0c1M2lpd2tpSEJRbm1FbzhUN3pDU21ZaHBjZ0pZU3cxT1BDb2xudFROYk1ra2NFbkRrajVHcXlXUmxZNlZnbW0wWTJHaFAwc0IvYnlzY04rcXFyczZibFlvRXV6cTQ1ckNlaFFsTE1wTDFHRDE1RVdzUVdRMjI4eEl6Mk41UDJhY3RQRmtwRXovU3lvakRjNCtra3l1MWpTUllyU29ZR0hnR0c1Ulh0Z2dFL2xaMWlzdVI2TXNwNjVyL2FJV1Q0YjczSFl0eFhLR1U1Z0VUWFlZd2xZU1VLWUdZMVpVdnFFMDFKdGphQXZobXZMWXJUeVVhU0tybnFIVGNXcER6cWUwOG0ra1VKMTR6cWFrenp1djc2eWFjTTdKSlo5Sk9hc1NscUdpcEdsbDZPdi9pSmVHSWVzMnU3alFDdG5uaklTMkxsbnlmLzBEQnZFPVwiKSBmb3JtYXQoXCJ3b2ZmXCIpOyB9XG5cbi5mYXIge1xuICBmb250LWZhbWlseTogJ0ZvbnQgQXdlc29tZSA1IFBybyc7XG4gIGZvbnQtd2VpZ2h0OiA0MDA7IH1cblxuQGZvbnQtZmFjZSB7XG4gIGZvbnQtZmFtaWx5OiAnRm9udCBBd2Vzb21lIDUgUHJvJztcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xuICBmb250LXdlaWdodDogOTAwO1xuICBzcmM6IHVybChcImRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBUXE4QUFzQUFBQUNUeHdBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkhVMVZDQUFBQkNBQUFBRHNBQUFCVUlJc2xlazlUTHpJQUFBRkVBQUFBUXdBQUFGWS91RkQrWTIxaGNBQUFBWWdBQUJTWEFBQXRDQ2p1NzJSbmJIbG1BQUFXSUFBQTE4MEFBZWNJODd3N21HaGxZV1FBQU8zd0FBQUFNQUFBQURZUEM0WTVhR2hsWVFBQTdpQUFBQUFoQUFBQUpBUTdCUVZvYlhSNEFBRHVSQUFBQW5vQUFBczBXRUgrdG14dlkyRUFBUERBQUFBRm5BQUFCWnhiSXM4QWJXRjRjQUFBOWx3QUFBQWZBQUFBSUFQM0FRSnVZVzFsQUFEMmZBQUFBVmtBQUFMdUlzWGlPbkJ2YzNRQUFQZllBQUFTNUFBQUpXaDgxejI2ZUp4allHUmdZT0JpTUdDd1kyQnljZk1KWWVETFNTekpZNUJpWUdHQUFKQThNcHN4SnpNOWtZRUR4Z1BLc1lCcERpQm1nNGdDQUNZN0JVZ0FlSnhqWUdSOHdUaUJnWldCZ1hFYVl4b0RBNE03bFA3S0lNblF3c0RBeE1ES3pJQVZCS1M1cGpBNGZHRDRNcDN4d1A4RERIcU1aeGpjZ01LTUlEa0FERklOUEFCNG5PM2FhYnhQWmRjSDhOOXZuWU9pcEpFa0lVMktaS2FTZVNoRWhrU2tJczJsUW1rbU5DbVNVaUhOczZSNUVocWtvdkZwenEzU2NHdTQ5N1gzdnJzYjlheDFmbDQvYjUvbnhXTi92cTA2NS96Ly83MnZhMTNyV3RjUmdHb0FLdHdCcmhLb2RTem8vNGFhdy95cnJQcDZCV3BXZmIyeVpqT0FqZnlMTmRBb3M2eGFWanZiTWRzNTJ6VnJrRFhNT21jOXNnSFp5R3gwZG1aMlNYWlpOaU83S3JzbXV5NmJrODNMNW1lTHNqdXlKZG15YkYzMmJyWSsyNUJ0ekg3T3lteHpxcFZxcCsxVGc5UXdOVWt0VXR2VUtYVk92ZEtBZEV3YW5jYWw4OU8wZEdXYW0rYWxtOU10YVdGYWtwYW14OVB6YVUxYWx6NU9uNmIxNmR2MFkvb2xiYzZaMThocjVRM3o1bm03dkdQZU54K1FqOHBQenlmblUvSnI4bG41RGZtOC9OWjhVWDUzZm4vK1ZQNXMvbnorWXI0cVg1ZS9uMytlLzV4dkx1b1hEWXNXUmVkaVFER3lHRldNTHlZWGx4UlRpNW5GMWNYc1lrR3h1TGluZUx4NHFWaFZ2RnFzS2Q0dTNpM1dGeHVLYjRxZmlyd29pNzlLbHRYTE9tV1RzbW5acnh4VURpdUhsemYvL1RlUUlhdk1hbVIxZklUcVZvMVE0NnhMMWpzYjZDTTBKanZiUjJoYTFRak55bVpuYzMyRUZtU0xzN3V5cGRtSzdKM3NReCtocjdMdnNpejdOU0Z0bStxa2VqNUNqVkxUMURLMVQ0ZW1McWxQR3BoR3BqRnBZcHFhcHFjNVcwWm9RWHJJUjJoWmVpYXRTR3VyUnVqenRDRnQ4aEg2TlVkZW1kZk02K2FOODlaNWg3eEwzajhmNUNNMEliK2dhb1JtVjQzUXdueHhmbC8rNUpZUldwbXZ6dC9KUDh1L3pMTUNSWU9pVWRHeTZGSU05QkVhVTB6eUVicThtRkZjNVNOMDI1WVJXbDZzckJxaHRUNUNYMndab2N4SDZQZmlieCtoMmxVajFLb2NVQTcyRVJvUkkvVC9mLzZIUC9TVjFwUjdzdzA3K2RXNTZqcWZsL0U2M3UzWENuN3UxMWRWMTBaK3kwMSsvY3pNcWx0TjI5djJ0UTUrSFdLSDIxRTIyczZ6U1hhK1hlYlhGVGJmN3JUNzdVRjd5bGJaQi9hcGJiUk45cVBsOXN1VzYxZmJiSnNyVUZHOW9sNUYvYXFyWVVXemloWitkYW80cEtKYlJZK0tveXBPclRpNzRweUtLeXBtVkN6eTY4R0toNnV1cFZYWHNvcm5LbDZvV0w3bFdsR3hydUtEaWc4cnNzcHRLcnRVOXFnY1UzbFI1ZnpLSlg2OVVMbmNyeFdWcXlwZjhldTFMZGZybFc5VVhldjhlbWZMOVlGZm4xYXU5K3VydUtydFVxMUJ0U2JWbXZnQTllVnFhOGl4TnRBZVpHczcxeWJhZWJqZHB0dnUxb0NGdGNNSFBCV3YyZmI0blZPc2hoM0hHM2dyTy9KRWU4NmVzZWY1R3diWmFYWTZUc1ZwL0FVemVTakdjNnBOc0hPOHVsWERWcWpPZVZ6SEMrMHBUdUlYZkFBVk5nTi9vcnNONHE3b3crLzVrZlZuVjlhM28vQVhuc1Z6UHY3UDJ1Vll5Tjk1Q2I1RFA3UkdHeHlLRnRhVTIrTUxuNXNYMFpOYnN3K3ZaRHZXWTEzVzRyZTQySWlQZVM5ZXdqTld4MXJ3RUI2TWJ1aUtXekdEVitDLzhJa2RhVzN0RXU1c3JXeXUzY0dyK0RXL3RNWFlhRHZ4ZUp5UCtSek9vM2tNaDJGL3I5UE4wWXlIMnh0MkJ0dmdQSFN4aHpnYmE5a0pQMkFEMzdlNjFoOUg4VWJPdGVGMmk1M0FlK3hHdm96ck1BL1hZelkrdE43VzNYcXgwbTVqVHpzVkoxdDdtOC8vNHZYY0NtL2dMYnZYQnR0SW5JRDNlUVpxY2hrYllnd0g4Q2ZVeG5hb2cyMnhBM2JFVHRnZS8rSk1HOCtWM015LzdRaXNza1BZalkrekI2ZXpnNTJOOTJ4YjNvUnY4Yll0NHArZXk5dllLRHVHMWZncm4rSFR0aSt1WUZ2YkFZOWhHUjdIVW14anQrTUMvRTNhanZ6T0x1TUxuTVZyc0lpZmNpZmJFNTlpRG03RVhGWm5qc0oyc2Jkc1oxdkRnN2lISFdaZHJLdDFzeDdXMHk2MmkzZzc3K1JpM3NFR3ZNK081U3ZZR1pOd0EzNnpGWnhqZlZoaEM5bWZNN2diSm1NRlA4YjMrS2RWdzFWMnBzM0dqOXlmTGJrWG0zTWZYNDJOZVNEMzVIVll5ZmM0bmlmd0ErdG9UYXd4VG1GM200ZXgvQ2ZYMkNwY2hPUHRPbnlKWHR5RmIyTWNic0VDM0dZejdVcWNpQXZ4dXUyRm0zRVRrdTFuOS9OVk81cmo3SEUreGlmc1dydkdIdU1qdG94TCtTaVg4SFgydGozc1Buc0F4OW5WTmdJak1Cb2pjU3lPNFdzOGgyL3lMUnVDMVRpQ1ovTXNuc2tKUEpaRE9JcURPWm9qT05TdXNxM3Naa3pGNVppR1MzZ3hIK1JEZkJnZjhVTWJhZ2RZYzQ3aFAyd0JUa0p2Zm9WejBBTzE4Sk8xNWwwOGp1YTd2dGs5UEpjVGJiSk44Y3B4Z2RlUEEzRTAvMld2Mm11MjJxN2drOWJabHR1ejlyQTlZa3ZzVVZ2cVZlVXV1OVZ1c0RrMnk2YmFOSzg2dzJ5QTliVTJkcER0WTd0NVhUS3JzRXIrd1l3LzhFZE85dXIxR1QvaFdqN0g1M2tiRjNBaEYvRm1UdU9sWHVVdTRFazhrZ001aUUzWWdzMTRnTmZCcHR5T3RWbUhOZkVFbnNSVGVCcWZZeDFleGZONEFTOWlPYTdHTmJnV3N6QWRsK0l5SEk2KzZJekQwQmJ0MEI0ZDBCR2RjREFPd1lGb2lZUFFDcnVoQVhaSFEreUZ2YkVQOXZYT3B6R2FZRTgwUlgzc2dVYllEN3VnTHVwaFYrN0FIVzA3MXJCdHJKYlgxcTJ0RVlaakZDWmlEZDdFTzNnWFgrRnIvSXpOQkZ1eEZ5L2kxYnlXdDNBKzcrZFRYTzUxK2lXdTRnWit3MlMxdlRKM3NJT3RrOWZsRTIyY2piVlQ3Rks3M202eXUrMTFlOWxld1dmY0ZrTXdHRU14REtmakRFekFvN2dEaTNFbjdzWmR1QmYzNEg3Y2h3ZnhBQjdHUTFpQ1IvQU5OdUVQN3U1N3cyRThndjE0TWsveDNXRTkvekpZUyt0bng5dFo5clN0eE5ib2p3RTRFZ054RnM3RTJUZ1hVM0FsWHNZcitBZldlNnVTNDFlVStBLytqVis0SC9kbGUzYmhVUnpKMDNnNnorUGxmSVB2OGgzZmFmN05rdit4K2xiUGRyVm10cjhkYW1Qc0pEdlpMclFuN0VsNzBWNndsK3hOcjgzVi83ZTN6LzhEZjdhSmZ6UitXUDloYTZNakZQYjFTT0ZxanliVzBHT2xjS3pIYW1JRFBkWVFlOURqVnNMV0hyY1dPOWRqVGJHSkhtdUo3NG5JdGhIYzduRmJzZWtlYTR2dDdyR09XQU9QMndzTGp6dUk3NmZJZGhSODRIRm44VDBXV1YzQmF4N3JpY1Y3N0NyNDNXTUQ0UlNQRGNYaW1ScUxIZWV4aWZBR2ozc0tiL1hZVk5qUjQxN0NFejN1TGZhY3gzM0Vudkc0cjlqekh2Y1QzKytSTlJNTThyaS8yR2tlRHhEdkJwQTFGOFJ6dFJERXp4d28zaXNnYXltWTZmRWc4ZjRCV1N2QmVJK3RoVk05dGhHYjRMR3RlSitCckowZ3hxRzl4SGtzNnlDSWVlNG84QldWZFJMTzgzaXdjSjNIUTRRWGVqeFU3Q21QbllXVFBIWVJmdUd4cTNoWGc2eWJ4Qmt3Nnk3ZTZTRHJJZDd6SU9zdGlPLzNFWXN4N0N1TWVUNWNFTjgvUXZpOXgzN0NqenoyRjRzNFFCajNNbEJZMytNZzhiNEsyUmJlWVNFYkxONXJJUnNpaUhrZkt0emtjWmd3ZnVabzhaNE0yWERCUW8vSENDTW5SNGgzYk1oR2l2ZHV5RVlMNHQ3SENHSStqeGZFZko0Z2lQRStVUkQ1TWxZc2NuYWNNTmJDU1lJWS8vSENuejJlTE40ZklqdEYwTlBqcWNKWTM2Y0pZMnhQRjE3cDhReGg1Tkdad2xoL1p3dGpYVTRRUmowNFI3enpSSGF1NEdLUDU0bEZUWm9vK05qakpQRU9GZGxrOFY0VjJmbUNXR3NYaUVYOW1DSVc0M0NoTUhMekltSGs3TVdDeUx0TEJKRURsd2xpdlU4VFJCNWVJWXc0WGJ3elJqWkQ4SW5IcThTTzlIaU5XS3l6V1dMeE9kY0pvMjdORm92MU9rZHNyc2N0N0E2UE53cmp2ZWNKdi9ZNFgvaWx4d1hpSFRteWhZS05IaGVKN2VSeHNUQnk1dzVCak45ZGduaS91NFdScC9jSUkzL3ZGVWJPM2llTUhMOWZFRFhzQVluZjMyUVBDcUtHUFNTSW12ZXdNTmJvSTJKdmVGd2lGbm0wVkJpNS9aZ2c4bUtaSU9ySENyRjQ3NVhDR010Vmd0ampYaFpHclhwRi9BU0M3RlhCQm8rdkNkLzN1Rm9zY3ZWMXFhb1Bhd1JSQTk0UXhweThLWXk1ZWtzc3htMnQyQzBlMTRuRkduMUhHT1A2cmxpOHo0ZkN1TitQQkpFakh3dGl6ajhSUHlFaCsxUVF6L3VaSU43amM3R29rVitJUloxY0w5Ykw0d1poN08xZmlkM204V3RoclBlTllySHV2eE5FYmZoZUxQYUhmNHBGem13U3hscjRRUmozK2FNdzlvNmZCREYrUHd0aXpES3h5SzhrRnZVMUY0dGFXQWhpREV0QnpOZXZ3c2laM3lSK1A1ajlMb3g4K1VNWSsveWZncWlqZndtajltOFdQMFBDUDc2S255YVJLSDZ1OUVPUytBa1RxVUw4cklsVUtYN3FSS29tZnY1RXFpNStFa1dxSVg0bVJkcEs4QytQV3d0OTcwNDF4YndXcDFwQ3orbTByZER2TDlVVy91MnhqdmpKRm1sN2dlZDlxaWZtdFM3dEt2VDZsdW9MSC9lNG05RDMxTlJBNkxVc05SVDZmcDhhaVorVWtSb0wzdlBZUkN6dXE2bjRPUnBwTC9FVE5kTGVncmM5N2lQbU5TanRLL1E1U1BzSnZjNm1aa0x2QzlQK1lxTThIaURtTlNjMUY4WVl0eEQ2M0tlV1FxLy82U0RoMHg1YmljVm50aFo0M1U1dGhGNlQweFlXYzlkZS9NU1AxRUg4N0kvVVVSRGoxa25ndFNrZEt0RlpwODVpM3RPbUxnTGZoMUpYUWN4WE4ySGtWSGV4eUpNZVFsOWpxYWRZakVrdjRRc2Urd2g5LzBoOWhiNnZwTU1GTWJaSENMMHVwSDdDeUwzK1l0Ni9wZ0dDK0ptQkF0OXYwaUNCMTZKMGxNQnJXaG9zY1lKS1E0UytKdE5RZ2EvSk5FeHNGNDlIaS9tNlRzUEZmSTlMeDRoNURVMGpoVEZYeHdyMzhEaEs3RENQbzhWaUxNZUl4VmdlTHhaamVZSllqTitKWWpGK1k4VjhYMC9qeEh5L1R4T0ZNVWVUaEhkNm5DejBmVEdkTC9SOU1VMFZ4dnFZSnZROUwwMFhpM3VmSWZSOUpjMFV4UE5lS1lqUG1TUHdjMFRhQWw2bjBsd3gzOFBTUEdIODdNMWlNZWUzQ0tQZUxCRHpmVDF0d1pqYmg0UnhMdzhMWTMwL0lvam5XeUtJejFvcTlIMGxMUk40VFUrUEM3eW1wMmZFWXEwOUsvRGVJejBuNXIxZGVsN005NkMwUXVDMVBxMFV4anBlSll3MStySXc2c1Fyd2xqVHJ3cWpUcndtak5xeldoaTE1M1dobjNuU0dtSGs4MXFoNzVWcG5TQSsvMk5oMUt0UGhWRlhQeGRHN253aDlQTmpXaThXYTMyRFdOUzVMOFhpSHI0U2VFK2N2aGJHT3Q0b0ZuUDRqU0J5OEZ0aGpPY21ZZHo3RDJJeE5qOEtJajkvRVVTTy95b1d6L1diSU83bGQwSFVoaitFc2U3K0ZFYTkvVXNRdWI5WjREbmt5N1lLUElkeUNuemZ6eXZGUEhmemFtS2V1M2wxZ2ErcnZJYkFlK2k4cHNEbkk2OGw1bk9hMXhWNDd1YjFCTDR2NUx0S2JLcDVmVEd2Ky9sdVl0NDc1ZzJFbmdmNTdtSmVSL0tHUW4rV3ZMR1k1MmplUk9pMU90OVQrSVRIcG1MWGV0eEx6T3RrdnJkWS9QdytRbDhiK2I1aXZnYnkvWVMrTnZKbXdrYzk3aS8wOVpNZklJeG5ieTcwWGl0dkxlWjFMRzhqNXJVaWJ5dm1QWEhlVG5DY3h3NWlWM3ZzS09abnY3eUxJUDY5cThEcllONU40SFV6N3k3dytwUDNFSGh0elhzS2ZmM2t2WVIrdnNwN0M3MVB6ZnNJdlQ3bmZjVzhwdWY5QmI3ZThnRUMzMHZ5UVVMdkFmS2poR2Q1SEN6ME9wQVBFZnE1TGg4cWpIc2JKb3p2SHkzMCtwNFBGOFo3SENPTVp4d2hqRGhTR085M3JKalhuM3lVbVBkUCtlbGlrVzhUQkY2djgzTUVmdGJPenhWNDdjN1BFL2o1SzU4bzlEMGlueVQwczBvK1dlajFOTDlBNlBVMG55THd2ankvUnVqOWRqNUxMTzV6dGxqa3lCeXh5SkViaEw2SDVmT0UvL0I0cTFpc3g0VUNQNVBuaXdReGI0dUZYbmZ5T3dUeGZIY0tZdjd2RXNSYXZGdmdmV3grbjFqazV2M0MrTmtuaFpHSFR3bTlyODJmbGZoNzl2eDVRWHo5UlRFL3MrUXJoVEd1cTRReGxxdkZZdnhlRjRzeFd5UG1lMnIraGxpTTY1dGlNZlp2aVhsdHo5Y0tJbC9XQ2IxUHp0OFJpL3J3cmxqaytYdGk4Zm52aTNtUGwzOG1qR2Y5WE16N3MveExzZVVldnhLTDUvNWFMT1o2bzFqVWgyL0VZdTEvS3hZMTRUdXhxQlhmaThXYy9GTXN4bm1UV016ekQyS1JDeitLUlk3OEpCWjU5TE5ZNUhBbUZubWJ4R0tONUdLeHRncXhXSytsV0t6cGY0dEZIZnBGekh1dC9EOWlVZjkrRllzYS9KdFkxUHZmeFdMZS94RHozaVAvVXl6MmlyK0U4ZjNOd3F5cUZheENmODZDUW4vT3dvU2VHMFdGME9lanFCVDZQQlhWaEg2K0xhb0xQUStLR2tMdk9ZcXRoSjZYeGRaQzM3K0tta0pmUjBVdG9hK2xZaHVocjZWaVc2SFhpcUsyME1lMjJFNTRxY2M2UXMvVlludWg1MnF4ZzlEWFpyR2o4RWlQT3dtOWh5NTJGbnF0TEhZUit2NVUxQlg2V2FXb0ovUjlwZGhWNkxXaXFDLzAvYWxvSVBROXJOaGRHUGZZVUJqMzNrZ1k5OXRZR0dQUVJPRDdZTEdud1BPL2FDcndkVjdzSmZEelViRzNJT1ppSDRHdnQySmZnYSsxWWo5QmpIa3pnWjlIaXYwRlhoZUtBd1MrcG9ybUF0L1hpaFlDcjVWRlM0SHZ5OFZCQXMvNW9wWEErK21pdFNEbW9vM0F6MEZGVzRHZmM0cDJBcy96b3IzQTEzWFJRZUJuaDZLaklGN1hTUkN2TzFnUXJ6dEVFSzg3VkJDdjZ5eUkxM1VSeE91NkN1SjEzUVJlcjRydWduaStIb0o0dnA2Q2VMNWVBbDlyUlc5QnpITWZRY3h6WDBITTgrR0NtS3NqQkRGWC9RUXhWLzBGTVZjREpQNS9xV0tnSVBKaWtDRHk0aWhCNU1WZ1FlVEZFRUhrNEZDQjl6REZNRUhrMnRHQ3lJWGhnc2p4WXdTUjR5TUVrZU1qQlpIam80U3hoc1lJWXcwZEx4YTVmWUl3MXZxSllyRjJ4NHJGbWg0bkZubCtrbGpVZ1BGaWNaK1RCSEdQa3dYeCtaY0lmSjhxTGhmNG5sUk1GZmcrVk13UStCNVR6QlQ0SGxOY0pmQjlvcmhhNFB0RU1Wdmc5YnE0VGVCMXNGZ2cwVm9YaTRXUkEvY0lJeGNlRjNyUFh5d1h4bnUvSkl3MXNsTG9mWHV4U2pqZjQ2dEMzOHVMTmNKWTEydUY4WDdyaENzOHZpMk05MzVYR08vM2hkRFBPY1Y2b2U5enhRYWg3emZGTjJKUmMzNFNpenpNeEdMdEpMRllJN2xZckoxU0xITDVkN0dZMnovRVlqNy9GSXQ1L2t2TXoxYkYzMkplQitMWGZNR3U5MGd4UDFPVTFjVzgxeWxyaTNuUFVXNG41dWZNc282WW56UExKZ0xmYThxbVF0OFB5bFlDWHdObGE0R3ZqYktOd05kRDJWYmc2NkZzSi9DK3Myd3ZPTU5qQjRIM29HVkhnZmNKWlNlQjkyM2x3UUxQaWZJUWdmY001YUdDZUpiT0F1OGZ5c01FOTNyc0l2QWNLcnNLUEFmS2JnTHY4OHJ1QXU5anl4NENQM2VVUFFYZTI1UzlCTjdmbHIwRjN0dVVmUVRlODVSOUJUNzM1ZUVDNzJQS0l3UStmMlUvb2RldWNvQXc3djFJWWR6N1FHRzhicEF3WGpkWWVMTEhJVUtmOTNLb01NWmhtTkR6c2h3dTlQd29SMGo4R3JZY0tlYTF0enhXTE41L2xKalhsM0swbUo5Wnl1UEVmTzhyeDRqNUdpdVBGM2c5S1U4UWVHMHRUeFRFODQwVnhQT05FOFR6blNTSTl4OHY4RE5SZWJMQXowM2xLUUx2bWN0VEJkNGJsNmNKL0t4ZG5pNkl2RDFERUhsN3BzRFBDK1ZaZ2hpVHN5WCtBcitjSUhHNEw4OFJlRzlYbml1eGdNcnpCTjcvbFJNRjNpT1drd1RlSTVhVGhWN255L09GdnIrVUZ3Z2ozNmNJSXg4dkZQcStVbDRrakRtNVdCalBkNGt3bnU5U1lkekxaVUt2eGVVVzlMTkJPVlhvZGFxY0p2U2FYRjRoOUw2OG5DNk0rNThoakdlY0tZeG52RkxNOTdYeUtqSGZtOHFyeFh4dktxOFI4NTZtdkZiTWU1cHlsbGlzeSt2RUlsK3VGNHM1bnkwVzh6eEhMTWJqQmpIdndjcTVZdDZEbFRlS2ViOVV6aFB6UHFxOFNjenJjM216Mkp2L0RaYnlZRUFBZUp5MHZRdVlIRWQxS056VnIrcnVtZW5wbVo2Wm50ZnV6bU5uWmwvYW5kM1ozVm05Vml2Smx1V1hMTnV5TFdQQTZ3ZTJBTnZJa2dNR0c3UG1FWVFKb0FRbk1TOW5JVHhFd2syY0JCSVRTRHpHQ2ZoK2x6OFJlZjNrd2cwaWw0RHZuK1FpQWtuTUR4N2RjNnE2ZTNvZXU1SU5WNXF0cnE2cXJqcjFPblhPcVZPbkJFa1F6clhJMDZRbGJCRVdoY3NGZ2N3dDdpVHoxVW15TUY4dEYwdHFNcFpJTllvWTJQQmpPcjdhWENxaGxxcnppMDVDblNTbEtnUXY3aUlwSjlWMGhrbVNmRmFoVkVua0UrMVdJcDlQa0JYd3NoRHVuaTdPek95Wm1mbW9hWncyeklRMTZnd1hjcU5XZ2hTb01xYlFPbjdTWGtXM3pnSld1RnZBYi9iTVBHZVlwbUZiV1ZtUEVXTHJjdFlTVkFIK2lRSlpFNkpDR3VxelU3aFNlQVhVS0ZDTGhkaDhWZGtVNW1ZbmNEdVpTeVVYenZOT1RuTVl5VHE0N2E4T2pZOXZHeDkvVDFqL1F6MGNOMGNTMlNGbnhJeXZVK1VJVm5rRGg2eEJUYyt3WEFxSi9FSE1ZZHY0ZjlQRFlkMktwbVF0U2toTWsxTlJCNU5yNkN3TjhHSFZoWE5mSVQ4bW54ZkNRa0lRbW9saE1yZE01cWRKeVNST2JHNllKRXlpN1QzMmk4ZjJNdWY1dWV0bVo2OXI3WFZmOXg3N0NUazZlOTN0MTgxaU04cVExMU1pSVU4TEljR0JrWEVadEdOQ3BkT2t0Z3dESVZXWkptVm8xVVRLV1NaRUxjMFFFOXFrUnJGWmQ1SHF3dnd5Z2VLU0NlcWtFak00a3FESjFDR1NHQ0VwYU9yRnFpaFlVZWVLbWNoa1pteXAvWHZzZ1FIa1dLZ1VtaGkrL0pyTGh5ZENKU2RjeisrNDgwMTM3c2pYdzU5b1VxV3VVT1dnckV0RGtraFdFNVhJNUM0cmtWNEt3OThZZTJ2dkQ0Y25zdmw4ZGlMc2xFTDF1VzA3Nzl5eDQ4NmQyK2Jxb2RJbnh0NkliZlNZS20yVGlGeVREYStPM3lBdDhna1lMeVBDakxBTDZwanM3bDZseUljNnpnU0FQMlgzdkZmSy9MbmRuVFprVmFkbnFNNmM5aE5rSGIzdFZYUURmbktKbDBRbmo0NmhGNTJuK0FPZGMwTEgvMnpIMjRINTZTRE1zWVg1UlJqYktZQkRCYmlxem5sZ2J2YThCMkd6TmdDNUMveTdmSmpmTlJqbXRVRXc5N1V6d29ydGpMQXJTUS9MY0xqNjJ0bDllbWxJUWFmbkJBWVl1TzB6RzlXQkJGSUZHL3VkdnEvOTlJdHBhN3VucmVtTGJPdDFGeFFHMXNrTkd2aFRuU1F2dXJHMWN5K2Nld3BnZmxyWUE5ajhFT0MvTzRUWENmY0xEME9iTXhDODRWMDkzMXR0R2liMUNCa21PTFpoMG1LNGhHZ1QwV2ZOOHpnYmgvaWVwdWNoNnhGYmtTeEpzYk45ejdSZXpDbkdtMmt5OUdVckorVVUrd1dvbEFuMTRvK3RnOTR5WFE5eTBJN3NseFJGZWl4aTI1SEgwUGNrK3A3MHczNVFqQ2gyMGZ5TVlTU3RleE9wSnlKMit6UithZXFyL0xIVzlWYmdqNVd1T0doakJkZE04V0ZZTTJ0Q25iWHhyWUpRS1MvTXo1RHVkWE03OURpc09RM3U4cEdnK0syQ3plMmptN0tIY3hZNDRobENMSnUwL2NUbGhZWWpIclhNMjgzRWxMZWVXa3NIbDliZ3I0N0RlQnhDeHZMNUJ4VnBTWkhxa3JLRXRmYTlUL0RZSFNlbmJsKzlLd0c1OE5VVnNobGJXaHJEUDUwV3FINFVFNDNsbisvOW5IbmJYK2V4cDQvZURuUGpYUHZjbDhXM2tqOFc1b1dMaFRjSjc0YnhOVTNvSEN5amFua3VSVTFTaHVXZ0NpMnl1RXRjSnMzRllhSlNsUzc2bmhRc3RpYWhiQjBaUnRxaUNRdExxVnBKcVZFUnd0VnBBbW1icXUrcHduaGNKdkFSaktaYWRSR1M0Z2RPRXpLaUpSWExtOE1zSWFOcFFzcFdLVG95R2FLV2FWbzBOSmw5NVY1cVNsT1NyRzRiVjhaTFdzb1V0VVNrTkJhS1MyYklTU1pta2dZMWtoVTVia1NUSkdrYWNWa09hMXFZSE8vN1FrOEV2OUM3aThtL0hJdjV2UGU1N09aSEpDb3F1WFFrazRrNGViMG9LK3FOTkNJWEw1dThJay9GV0lyR2JFY1J6VlJNRkNPS2FnQW1wTHVOVUhJNEVkS3Bway8xSjQwNGdhU0tScnJ6dm9SOVJuWE1BY2toNktlV3VBZndBV0lEb2RuQVJwckRGb1dXZ3Q0cFJZa0s0eFM3SkVEV0xjTXduQ1pzZlUvNksxd1MycjBXK0lwNGRGU2tFS3FPSHJucnlHZzFWTkJVNVNMSmtDNVNWSzFzVHRicTg3anN6dWRIbXdlM2p1YjVTNzAyYVpZNzZVZ09wbWJXdGxkbnErVXEvR2FqRUFNUjBWcldVZitVMFh5S01UZFNXeEszam8zTUdRb0wrVlBWeWRhOGhLU0EzMmR0UnY2ZE8zZnVlYktibkFBS2FCenFXME9DWkhGdUJFWWdPS2tFQUY2Q1FUUFBLMUZqTlVHeVpPNTlKeWgxYUlLdXJvTGpVSHFDSm5JOFNMMmxFOVNDUDVxaW1Bb2VDUWo2ZkY4STBtRXdHMDZSV3pnTXZId3MydUhsUTluelFCbk5RUVRBNFFPakpzNWNRTzVmNndjcTF3OTZMd3hOeW92ZFJmd0dTU1dhZnZVcGJ3TUU2RUpnK04wTGFxdSt2dkNyN3dPek9GZnppL1licEZyNnZRdXE0d1gxQlRsM0R0cGhoWXd4aW5qUWFCalE4YXNEOHNIMkZKNWo3VG00UndzWDBsWGQrUXpzbGY0T0dORGNicjEyODNyWmcxcDJRQ09TZmhnUkd1UUJ6d0N0LzFHWHprR095YWZNa0N5UVl0MjhZSzNjb1pBeG5qelhyaU03Um9DUE0rT20wVDdLM2s0YTVtZDhQb2VzbUFaTEJFNzdTV0todDMwVzNMOXkrUmR3Qk03RFBFdWVKMDhDRDFPQ1ZSVllsdEkwNGZ4RUJYR1JPMDc1UW90c0JYbSt3OUswdjNtSnBxckhBYkVjVjFYdEVxcXNLRFRBNE16ZUYxV09TOUp4SlhvZmxOaGJsdUlYQklYYXNKeFhYZHpRNFgySnNGRm1TeDBneUNnQ2NVd09BdEZibGxzS0wxRnFBS0oxeHo3Z1doZmg5cFNsSHBPa1l5b3Jpenk1ZVkyRi9uWnMraFdESXBXRkx0eWY1T3lMdG5rTldodEJJK0NZUHZjdDhtbXlEcHlpWURkYzRzV2ZHSnlvZVdMVk1JOFlKbjBDaHQwVDFEU09tR1RkTko0MThRMER6V2NOMDRYN0RGbUR2S0pDQmZxa1p5VFdCb0pPanJTZllDUHVJTGpIRGtjTS9USFZVaC9UamNoaDA0Q3dnbW1rTVI2YyswOWtJQkxpTWljZ1JIRHhaSXZKREtDOGhaakwxc2M0WWRZYzJEVWJaWmRtQUJnTW1BRmd1UDBDNVQzdGxVZmNjcnh5NmVCaDE5cW94UFBWdkxjOTdRRHZndTNxREp4UzU2a0hkdHhHN1FsNDZkeC9RbnVld0xGUVNibzBybytVK05EQStuVDMvTm0rMFNId2NmVTh0Tlc3TUMrZk92WVJONmVhZTNNNjJaOFRiNE9XMXdiWTVsaC9iSFBPZXc1RUt5MmdqOWVaVEdZMWtXLy9xSCtha2FPZCtQekJidFRTVzZZU0tBL0hsalM0bjA5dW1HUEJEV1V3a2ZBQUROTlhwdTJXNWRYVkhqaVc2NTFzc2NnZ21say9Yd3YwbHhtc0k1WmJHVGhmejFjWGEwT1l6b2NmcE1GOUdad2wvN1lwZmlDbnVnZjBlZkJEWldBL2JwaGRjR0lOZ09QOCtFRVp2RlFFOEVQNzhNWUlZbkNSNThNUjlzQStQRTlWZ2ppaUJ5UTJyOC9BZXZGUm5OZEsyWjNJUGdIRVVRYXgraVp5WVlQMXdsdm5KbnJvaFdoSDhoZ2c5RDBpTTBnM25OeHZHa0NSN0tkSkdxTDBIVkRpT3lqNGtvRkZyM3JGSDJGMS91Z0tqRWpRdDFQNEpjRGJEME1YSFRIVEVac0hDSDBQanVBYXYxRUJTK2NIc3grR0x2cGloUGc4SE8xdUE0VGxRbUFJVWh3YkE5RURReGZOc2NzYk56dURoTDdYRnRyUHF5dGNXdVFMTUphSFlEUUV5SE1vTWpWQy9PbmJYQ2JrSTBBSmZ3bSsvQkluaG8rYlJzRXdqOVBFUHpvODhFdU1jQ2IwZmpMQ2h2cTM3NmNrT0Y4K0RmTmxTejhPSXMzTnF0bzFJZHZQN1dFelpBK1VGR01rT24yblJ1UFVEbUlrYmZmWDBQdTEzWm9Xb3pZa3duUnFUT3ZDRlZ2NmNaUHRiTmJ0blFMTzdYNFdmYzkyOG4rblpnTTR3UmxPMGgxQUxZMEJDdWxpbXNkeiszQk05K01zcWJiWkZLaDFJYTg5SEpROVZMTTB0Nm9JQ3QybzFkUzQyMm9BREtUa2ZmUC91cmhzdWgrWEVib1pTamhmbGQxU3VuRGJqL2Z3M2dtQ2pKMnBjVnJvbjJEdCtCQWJpd0hXRE1wVW84UUh6UmttUk54a3pFa2JqRk52dlA4VHREMHJ3dzZ3dFV6eTFtSGthdFBrcVZTbmlKUUdSYlMvelpwMEJJb2diOTZrak9BYXY2V2Zmam9QbXUyaW8rN2ZZSFozMFZLZjJtUis5OERTUzFlZEI5MmV2SUJTdWlpdGplRHRoYU9YMXRvYzVRWnBybzNBNkthK0xoU09YdnByYzdSN0lUVzFMZ0RXSGhwaUFFNlVOcDEzWGJQN2lnMm1YUkFsWmphWWROMzgzUFFBZW0xelhIUytJZ0RkYUVFY2NjV0dpS2dITi9mUmNadmk1aTZVK053RzZQODhqZWFpNTU1KzZhUHRObDJyQmxlMWU2WHFRb1lid1NxNE5OOFhnT1liQ3NyaEdLNnF6blNhQndYNUc2Q2kzOWdFZjNGNW1FaklqRENDdTR0SWx2dlZRTUljcXVsWFR5VnYraEhRa2RkVCtDWE1nSmVrcHFlQjRnUXYvSmxHOE1YRHRVOEozeWRQWXhtNEl6UFhhUzRraktGTC9hNnMvdDJHV2UwYlhEaGZMNTRTWWRRSWV6dnJCVEs5NVFBTFBVeUFoVjRvTTVLcVF5ODNBb3p4TkFGNk90a0Ewb3VzWGdWRlhnWGxOMTVsMnRwVmxGNmwyZWFyR3FFSTBUYU1TZmt2QURKTHBaRklxRHRaYjR6QTVaclEvcnVGU1dpYklzV3R3NjRCQmNSWEVZaXVuaWxYcmIyR1RFMVRvaG1RM1cyNmZoczhET2piNmZiZkRBaGRuMkxvaHQ1cVpJMWJPUTZhNmcvaTdVZ0lhVEZZWXJDODlneHNXQmhqc0NEMm9DSDFBdk9mZUJFUTh6SEQ5Q2h1NnFVQkZzcmQ1S25iZjQwRjJodUU3OGxHclRjSTM4dEpkODBudDF3R0lGN0djRFoxSHNweVdDL1Q5Y3Q0QmJJUE9SeTFYMWd5K3lWL09TaVpJS2pRSnkxb2gyZUV1THN6ZlVTNEMzVlVWSmoxdU1lWlpIdEpNRG1iSlJNWHJibkZqaFlKN2djbVp3RnJ3UVJMTmVad2Q2cUpXMWlMdUV0Rk1SQm1ZdFgzVk9ZWHBzVmFGYVl6ZEwzRDhsSnExUG02bGJabTlzeUFheWJNZFAxcTlCV2FlNXFGRUIybG9lRlUyTExDUTNORFZBNDdlbXptNmpXK0xmVWUvaUIvVFdhdVdRd2xxUkZhdVpyQWwrMFBIQ3dkL0NKK1U1eVpLY0l6WlpxZm5MbTZ6a0thaFVLem1MRkQ1VkE4a3hxRzFKQ3ZaaWhoSnpZMEJnWC9DOSt2V3VPUEw0clMwcDFYeEdVamxaUlRyN3RJaGh3K0JYbHpmTk1pL3dwalp3SEdUbzNOSGh5MXpVVzJsSTdBVXFyeW1VWDVUdjB1YUNlR3pXY0Ftek5GRy9JUDczMnZyaWkya3REZUxSRXpWQTJaUkhxM2xvQVFSZDg0NnRpQkE0cXRsM1JGUGZTeGtHbUdQblpJVmVEVlZqWUk5M1NQbmllZkZ5NFJya05kQTVNa2NEZldCWnFxWlpjclRqblExVlNsMVZxVnkyaEswTFhWTXU5MDNBYUdCSTNaT2V4Ym1LSVNqbzdtSW9xVG9ZNHVxN3Izc3AyNlRBMDFybTFabkRzME4zZm9WWWZTbVdnc0c1WkVLUzJhNFMyS0ZwK29yRlRtcHhJVEVUVVZIcmxpckZRcTNIdVRsYkJqVGl5dTZ6bVhueDFUazNxWVNzclEzS0hiRDgxVnk1VzVrWFJXSXBvYWZXTTRScFZVN2VLcDJhMnBtRVBsTGJWZGUrZG5sOXFuazNZaFphZkc0dEU0MHdOdzljMWs0SGp6UWdOR3R0QjB5cnRFUkw4d0VKdTlrc1lhMXBlTFVWQ25vdUV3VDlQWGoyS3Z2NmxuZGZtM1ROTkpaejdxYWNDaGRsbjczN2VLK3FnbWJSV3BPaVFEcnBuWEpIMUlwWCswTUwwVk4xQzJUaTk4YlhqWXNtN04xRE0zZDlUSjhqODZwV21uVkVPUmg0ZDE0L290RGFxY1V1aThTN09kQS9nZkZreUFIdmZuWUdiRjVqbGlkSXBkcitHV25vbkhNM29ySEFMRTZ2ay90YTZKOFFoWmljUkZiZDBZTnJwZlBYcTl4ZkJmVGRnQm96aGxpaldtSzZaT2kwMFlFWXZONnJMb3NIR3hPQ3pTWWFCTmxFSGJzK1FySVgxc01hTnZXZHFpWnhiSDlGQ21VTWowQjdWLzhxU2lwSlNJOG12N3dFa3B5aEhadkdlVDlKMmdoU2Y1Qi9BaHkrQ0k0dUp1b0NhRk1ZQjh2bHBibkJicE5QUVVyWnFpQXdNODVhakRZcFB0cDZlV3hkb3lFWVhOQy9HQ1d2bE5hK0VGb2E0Snc1dHIwSDR6d2o3aFVtRlZ1RTBRaW8xdUttNDdpVTJUenFZY2EwMDN5U1FxV1NoMUlJZHdHZ0s2TUlGKzRJcUJDelduVERlTUlhdW5HTzNIdHZKT3hkUHltOUJ6SWxTcWxrSW94VFBlSktmanBHQU1UZXVsa3I1bDJDaHQzN2U5dExiLzVKUDlRWXl6WUE2cDBSR2IrYUt4V0pSNTdCSDZSMFJQYlgxRkxCeU92V3lIbzVIVWFBcCs2eWV0d2NGc3Y5S1RNeVdGWVIvYmNHVkhCeFZNb0ExU0VtcU9RSzI2ZHUxMkZiS1JkUHRjK2ZwcnY0TStRc0FYbEc2OXZuRHQ5V1ZDMHBGcys1dm9iWjhETC9RRFp6NGZKcXVDTHRpQ0l4U0VjV0ZPMkM0SU1VWkF4MkJwcXBSam5oeS9HQ3M2dnBhcDU2bjFoVlN6cTZ2WnFyaUNiclY5QnhIT0NVaHFKNkN0K09QNnJqZFNhR1dyWkFXU3RxcFo4TFpiWk9Vd1JpVE0xVUVQQkZsbDgyOE54ckNudzNhVmNITy9UaXpwWmsrUzlzLzRMaDU4Z1NFZ0VSRlFld2ZUSTJMT0N0UDNZazdBdTlaSkVQQXkwVUVIL1IzQllNSWkyNmRmbkY4UWRFWmJQOHphWVZTWWg1bDBvL0JxNFNIaC9jSnZBbGZVbzhYSmRtZUNLQmtEZXhQUlJwZFM5R0I5ME41TU92SEpZSEdsaml6Zno3NEhoQ2U5VmxFbUR6SmRMWjJ1Z1hPTDE0VEtQMFBZUVMrWXZNOVBmcHVmZ2l4Z0ZQVStENlovUTZEVm9WL09vaCtjZHN0UGdjbURVWVZPUmhCZDZFUjBuTFd1TXRyclhWK2svYVJDeU8yYnA5bmNHb0tWWWhabTFzVXdVbThFYkhjY1JxdlhGSTJhNzVPOHBpcDNZcHNEMHRsK09zWDNPYjZQK3I1K0RWTStYbUU4SHBTVTFWWCtJT3M4ZEpVL1dxeGhDM3pNcnJUUCtLSDQ0T083UU5Jdm5NU3Fpa2V4QzdneUlsTk9mS3g5aWozSTRVQllWOHhqZlc1Z2RnaUM1ZE1mRXVDbkVJeHN4RXc1bU9kbGFNTkptTzBOb1FrdHVVc1FabU9ObitrL0VFMXhmVlRQeFhNNi9zdkdjM0g4cDhkekdCQW5hKzIxbitXUDY2RDhsTFRJMnowZGxGNU4ybDZ0NXQ3M0M5SmMzdEhSbFYwZjZCVWtHSXZQa3JPd3Rvd0JmdDhKNjM0VGRkeGg4VmRwYmJISlZ2K1VBOVFyVy80WG00NUsyZnBmblJFWGE5VmFreDBqVUtrS1NZQkJJZmZtWTduc1VENmJ0NGJzUXVuR1cyOHNGZXdoSzQ5YTZ2bllVSUlIRmUzdkRBTlZaWXlBODlWaGc1RFFjQVNjUTJZcFY3enErcXVLdWFKWkhTbFdLc1hoYXJUSWcvSkZzOGFDUm1vRm8xUXVqUmlqMWZIalJxRTRXdEpyNDlVeTA4LzhVL0Z0d0cvRm9DYlRNQTRFd2xsZW9MMEJicUErbHdtcHdiSmZoWUJaemo4Z1MxVURCK0pycXVLeFUrTHIwNUV0OGIvWk1wYk9MOWVHWnFmL0prN2IwYWw4Vmd5WnFxcUphbDFOYUlva0cxSkduVTdtbDRBVDVlYzZ5SW1pVFNNZktkYlNoUnRpVnE3NFlYTkwrd003MHJZWUpVU0diM1pRU1ZWb09DekdWMWZDNXBYSktEL1lJUWdhVzkreEQyUVkxUmFNNlJIQTJaTkNIVVlGQXU4MHNmbHBEZFZKb1cvZ0xTb0Nvd2MrQnpWR2F5aENjbmdsL3ViaWhRTVQxY2QzWFV1RzhyOHlaVnpaL0ZMcCtybzgvM2pwOFpITHg4aHdMaGkyNytLRkt5ZkpIeHBUVnk2KzgvRjV1WDU5NmNEQ3hlTGtXM0xENU5wZDhFVTJMN3BoRXcvbGh5SG9QNHlwQTlDdUFDUFhCMzRTUnZHWU1NWG0zYUt3RlViUGlyQlh1QUYxWXBLQWZhQ3RtMlZhdy85bEIvcGlnZk93eU4wNE1HeWNaQ3FwT00yYTB5eVBrQ1p3Y0UwS2Z1QmJnYXRybGgyRzJ4YUtuam9tVzdoUG56bERuckN0SS9wSS9QSTlleTZQaitoSExKdklvY1RJUkhQZjlhKzdabnZOMWtuN3F1bXBpZDNqMTZ4TVRkZGJZb1VNeTQ5UFRrNGVsNGVydGNwdGlyUy9mWVlwVFpNbkFQVVg2Zy9IOG5UeTVKbjk4Ty9NeVVtYWo3MDFsS3lNVEdaR0dxUGJoOUtpWEw5cGFtckNIbDhCTjFVb3ZDMi9rSjJjSERNWDhtOHJ3UEo4OEtDN3BMdnlQcVpUZGdEbVVCSFY1dWNjRlFqbTdnMlhhVmNET0xEOE1hVlREeTBYZmQ4eTZhaEpQTmMrWWtmaWVrUzJKQ2tzR2ZMTjdDRkZ5bGFvbkNqT2FFaHNhaTU1U1FTWDNNVFExc21JSGJWbllwQTRMRWszeSt3UjFtUUlLM0lxdFpDc21BWDJQY3VsWUZhU0JSYmg2OGs5VE5hRkNJekh2YWhOUzMyaW01YVZzc3VZY3dZUFdIRW00V3B5WWdMSUJhZVJoSUdRTEhkUkRpdC9ZSDRPU1p6N3RKZVR1MStSbDhMNjNUUkVzaVNzM1Z3Und3bjFsOVRRRTFvKzhTR2psTGIzRndxL01QcnBSQjVCVzEzSko0REVXaW44SWtDbi9aMGUvU1E4L3lPVUxGaUpmTjFhZ1gvNWhHVWFKdzFYaDRIUnJsUW9vblFVb1NndWRLOTRIZVZmbVBFRjRLUUs1R3hiWURTY3dFczB0RHdwUUw0dFhyS1hQWlRIMnlaUVJ1VkNTcUhGWkhIRGtpNXF3MXE3UVhHcmF5K3BQQVc0OGczTGEvOFU1dExHeGYzOHkvdncydHA1eW5OcG9naGdrKzI0bCswemUwNDU2V3RXVFJJSDl4TFZjcW5HTnZ4Z21vM3duY1VHMHlZck9vMkZCaG1kYWY4UExHTng1anB4Qll0UFhET3FTbHFZd3EvOXU1NXZoZXhpOEswVXpnbnZ1N2ZnamJEV0tRNVhYVXVvdW1LUUwvUG45UWp5SE1EL2MrLzdqeU5qYzk2KzMwMGVGdUpBN1VCNUZheHZHWkZqekZOS2JYcXJsK0pSZ2tWeHpEQlgyMnVyVEFWMTFWMmpibDRhQXo2WEZOYUJ0MTFaSVVmWTluT0xyMFJyWTB1bWNZU2ZBenBEbmdaY2xoRktnTjEzUUEzTGZjY2ptNGlob0dhSktCNlFUQ1VwN3k2WFV3KytrS04xVi9mVlFEM1lxNVBabVpqZXJGUDlDWDZRNVU3M1BNdnFXSWNEbnhnMWF1bUhpek5mTStUTWt6bzkzVGxtMW5HWUxpK2pwWGZEdUlrQkpiMFBjSlRhT1lkU3djVmZkVkRPbG1Jd0xTZ1VXSEtDZXdtb0pvSnJxU3VNcGNOaU1zR1dwUlFGanZxQW1Vc2VyU3hXaXUxelJLTmgrdHVtZ1hnKzVwQTlLQVYrNFNkVVpPTGdZL0c1SWRYTzJtcDFaeG5UV1hGbEt4V3ZpZGJ5dVVvbDl6KzNqR1RqeGkyR3FhaUtFNXNLdzBma3o0QVNRTS90cVNGRk0vQ1VqcUdwV3k2cXpaWHlkamdhVDgrcENVK3ZuNTlUbllDMVZhamdXWVFxaW45cmk3alZvd0t3cHNnRWl5YnBWQmdHQVBXcTJraWt5TzliQUpOVzNsa053ampNcTNZMG1UdkQ2MlNaMTBURGRyNDBWN3RvaTlvSDB6Q3ZTNzUyRTZzRjRGZVUwWnlEOGY4d1cvT3ZFSzRSN2tDWkJLMEZHRGpIWXluWmxoK1RkeWI0c1pjRzZyNmo5Qk1GR09JMFVWSk9tYUowQUJZTUpzNDFnV3dBeXJMaFRJdE50cGVCSWxVbUVsVkZra2tkb0pFVkhBQ042REdkM2hDQ3NUSTduSEJLMjh2d203bzROQitoMTBmdFZIbmJSZHZMWW5sNys3R29QRmxHa2JXdWJkRk04MnA5N04yajZtaDY3WDBqVTJKaWl4UlJJNm9rYlRHTTRzd2NFYlEzaDNScUFiTUdmMmJDckd1bDdSZHZMeTlPaE42ZGpzL21vSURpdG4wN3lwZFpxVldZTHVLbDRVd3F1MW92akgxZG5GcE9Yd0w1NkpEZmZuRm1ieDNsSnk0OXdIbThHZFpXVnlIdjdaNTRTalo4bnMxbmc4czI5aXhsdzVidGNUVVdPdnljQkNGMlk3N21EZ1g0T0FtNXRQajhQc05uZVJ2ZTdqZk1VNGNOVTFmTU9BMmRNbzNIZU5EYXdmcXBFSTJiaWc2VEhGREFZYWFkempUVTIrdE1YRVZnK2hmeThaRnFlbndlVXF5M24zU0QxOWZiWitiSDA5V1JlQjVvQlVBZHJwd08rSmNXY0Z0M0N3OEs3eFkrQ0tPMHhJRXI4UnBzOXNaYllRRW9CTzhQY1VWeFlZNlRpSnhDVEczMjFpQk1WbzVuclJad2JEUTJmU1V0VFpPMUVJMk1SR2hJVTZpbHlicWhoUXRoR3RKbEdxTUt4SVVMR0NkcnNGd3dnbUlGOEc5N3hRcXpENEpKMk9lWVdjR0xZNWxaN2ZXSUxRTkZxQnFwK0xHQjNoVlpVblZaVldWZGxXUlpwTnhQUlRrWWZqQ1JQOG4rNVJPblY5MmtYblJQVXA0RldZRVpxeW9SVlk5V3FzbU4vQXl2L3dsQm1aQU8yREtMM0o2Q205SEFWYVRVR3FLOVpWS1RjQkhCYWV2VXF1WFpjaW5LTjZjQTN5ZXBPa3hneVYyb1ZSZVJld0orNmtGSkZkK3NLUStKNHRuaXFKSkpoNVI3NHRuc2FEYjdYKzZuMkxZN1lSSlppMG80azViM2pFaXFkQWUxTFhHWEtFcC9JZEhUa3ZyTXl3NkhRMFltVEI3RWIwYXpuMzVNMTYrNkdhZjB3Y1F2L1dva3JZZkRuN3VyQmhWK1dBUFNrTkVJM3lKdmhEazFDdk5wRzR3MzNCbGpvNnFEZUdJZHVWS1RSd05lR1haSkIzV1NyMVV3SG1ZeitkRkNQQkhML0RFaWsySVIzVDhieTlYbXFuOTJrV09HSS9uTWxmZUdFMWRmTjFTeXYybzJSa2FYd2xRU0lTRmxKMmdMVk5kQ2U2ZHFTeCtrYWphV0hXa3BENWVHa25qUUFmalFwOGhGc0I0NXVHcjJVc2lOdWFhOVdDVmp4MHVTR1Q2aHcwSk16TkFicHVFRkZUL2g5YTBoTzZ5ZkRWbGZDc2ZEcEI1T0Mxd1dDL3dXN3BObmhTcFFSN3VFeTRITHVoUHlwMnhIRmVyanFUNUNYZG4rNkM1UzVxZ1hlN1BHVzRTVEkzZ1l6TjNDbjZ1bDNCMTk1RktxN203KzRueE5RV1FNeWZpUjk3bEY4dm41TEtXeCtOTE54MjVlV3JwNTY1YnhHS3g5MmZrcjA3Z1BnODV1K0RNb0hZcEoxSkJpc3FhdnlBYVZnZStnMG5XK3IvMk9hcGJKSFpaZ3VTZEg1bk9vV3pHK1pXbDFpV1VjajFISU00VDVHSFFIenhlZFpreldOWms1a0xHTXVjc04zL2ZKYkJWeVcwS0JobmVHdWNYT0F6dENUV2dLdTJHVXhIcEpGOENoODgzRlN1ZEFENVBsSm52ZWtRREZmU3l1bjlKK0VrK05rdjJBV0FIUHQxdXkrRGN3RmJ1ZEY5ci9FeGRQTWtRT295YkowbGk3aFNTVkZkSkNVSy8vamFrUzZFejV2dS9DdWh5cEN0N2VKOHF0QWJrbWZhMm1HdC9UYXEyUTAwd3JxWDdVclNPWEYvRDlnQnFzS3NFZEFlcWZvdVdQVXRVL212eDhaMmZnR2I3UjIrQ2JzblYzMnpld05mQWtqMW5sTVcvcm5EbVV6LzBFWVAxemdEVUc5RzhET1VQQ1ptR1Q3M2N5RE85Z1NKbmgrcFRUV0NZVmhydHJUS0NrSXY0ZUlZRlkvSnBzSjdvaVNvU00xRWNJa1VSRkowMDFhU3ZYS0haUzFTejdyWWxvKyttK0pBZjhhTnZTSURrcHhQS1daa2FRWm9tWWVqUWZXODlNMUZLcDJrU21lbCsxZXQrWGc5R2FsWThWTUtwMnZGbzlYb09FZ24vZUdmdUNBc1U5QkJUWUxpNHpqNHFOSnRRQUZsNmNhWFMrV1diSCtLZEpzMnREcGt1ZndWVlhPUHNlSzZQTWlkLy9aMHZKV084cDNkU0l2SkQ0RG5RdTJUSi9kdjd3L1B6aEkrZ3N2dzFJaUNza0tRdVB5VnZBeVVxa0ZZOCtSdStaamNZL01qcCtkbTc2YkNKZnV2My9kOU9EOCtoYkplbEtsaEsva0xLeXp2QWt4eGRVaUFJTnp5UmhxRFJUNFhXZ3Z2RUIwbTRnT045di84QUY3eXpmZXlEMHNXaTh4VW91bk1XQmQ3WkRhNjlBdStENXhtVThBNTZzMFlVZVFYN0Y1M3NDa2M2Z2xHTDlZS0Z3MEtQbzIyOWtkTDBiZEVrd2FuMDFtVnpWYVF2ZndWbGhyaCsyMGgzcjdzRXkydmxxNFJjUUM3UGx6R1ZNcGxHWkFyaEgzais0SVoyRWNRbGNJNmZHa29BRC9hMUV2NTE4cVFlTVlFZ29VVlIwOTQ1N1krdHlmcUtKS3RmSW5xS0c2OXBJWXNpSlM3SWlENCtMNzVncFMySllWS1ZzNmYyeFRIVElXQm9EMUdCWlkwaUJqd0hLRUNJMjkyK3ZrdXF2R3BDeVhvZkYxUkNKTkRZbUViRXZoQlJ5MWJ6RTVFL3lsaEZOR3hFcEZDQ21ZUGpKcElDNGF2WG1XL2krRStJa0xwemZYdDBoWmF2dDc0WWh4OUZSeUNrc1VYRjRXS1JTWHdqMGQ1anBtS0V1bmNib2hiSXdKU3hBdjE4aUhCUnVGRzRWWHV2cXN5QnE4WlZSSk0vajlPbXAvSXhSYThDMHdHK0Y0eU9jd2ZEK0R2ZXRLL0RQQndYMnBPU1BGby83RUVkdVpKVVgwZUt2Nnk4aGRNVkZrOTRjWElmNU40U3JFT25zc1pXNzl5SXJqV1RadVFEakNPVDB3WHdDSnVmQmp2bWRiNjZ0clE4MmdFQldtTVdEZXREUVRxSHc5WUdHRGpwblloRmVtKzJsQ0FDVnQrSGVjSVdTQzgxa2NhRVhyRm81MlNBcjdzNWxpNTE5YmJXRmZNS0h0UVV3bmtRUVRqSXJTRzgvQ0dFdWJEc0tnWEk3WjNHN3JSZjEyQi9xZmUrMlIvUmhkbHFlT1dTRktzK2pINXh1NWVMNzNCUkJ4K081VVhldEphd0lsK0xaR3RZblNHTWhRbGM3SFZqeUxmL3drenpZSkxVcTAwaHNOQmZaVVZEa1p5UlU4bW5BaWlBS2lValQzS25iV1dOeHJNR0ltc2JZb3BHMTlaMW1NNUt3STBzekxPNjdMR3htS1dLZkc1NGZQak04L3h1UnVGVVkyb0doemNLUEVNNGZGWnFZZE1kUXdZcm43TzNUTElvRlRXKzNpUTJmd1UvZ2V3cWNEckpoM3VJYWpiYWg3aGJlakNlUWZJS0lJV1RvMHlvNUh5M1Vjd0xhOGJuWUYyMC82ck1Kcm1FTG80RzBhUHNyZlYwQnpyei9kc2xLd0JiV2hrNkJzSE1VN1NWdWE0czg2a2N1K2I2N09zblhENkhuOElCRVM4RUJnZXZJbjdMMWJwdHdFZGVJUVNrWVoyQTdISWVLdEF5cTNqVTVIUU5yUkpXcGRXRTRGK1dqOWxkdEFTa2djU1Z1Vm5MNlpIWmlzckdOamNqSmtDcEhGWWxhMisyd1lrU2hiRWtPeDlMek03VXhaMXpQVmN6NDZ0eVc1YjE3bDdmTW5ZbG1sT081aWxhSkQxdDJQZ0ZER1VpWEdWT1hEVWxUTW5vMFlzVlVOVDZ0U2JZMUZDdHJsZHh4SmZQbUNhZWc3ZE1LemdTakc5RmVGdEtOWExMWGZXNnFpNHFobnRKR1Z5Z1JtQkd0MjlHWjY5Q1NlN1BWNm55MW1pMXZMekVkbU5KMmNyK2JDcHlWQUUySnllYXJLMjRxY0R5ZEtZSTZQMHd2eTBiaGg2dVlBNVM2cXhMWFpJcDBhdXY2K2NYWkc0N2VNTHU0Y04zRW91bHMzKzZZaTZSMTVkV0h0aTJ2TGk2dUxtODdkSFg3UFFzVGlmenN5c3BzUGpHeDRQSUViRjQzMmN5KzBiTjdsZXpHdXQzNE40Q0VtVjRtdzNiK0ptSFI4elFYT251eWlMTkV3VFEwOXFzYlpvdTVHdnRCR0xQdUJkNzIwWmpqbEJ5SFJQa3pDa1AzTkJPUFFtb3lCcXpES2NOa3d0QXg3cHJHS1hiS3NNNTFndXJtNytObjNtL3BKQ1k2eWM0ak0xNlJ5V1dDK2krdkMvSVVISzJUSHJpVkh2MkwzdmRLejN1ejV6M1o4OTUxNW5XTkt1MnY0NndpTUxmT0NRRWtIZkFIdzljR3pYS0w0WGl1SWtQcXZxV0ZCL3hFRDV4QzM2bXVEOS9SaWZWOVhmaVJZOGRybWViRjI0VDNkNnhCQk5lNTRJcUgrRS9wT2YvaTlLdStCTjhYZnRaNDh0azJvQ3ZQTXVDYVp6Q1F0cThscHpBY1c1bStjVkNqRFd6SmdZRm9oM0EwNFJxdGNlM1lKRVlCdVVMbi9aU3RuYkpDditwLzBXbm13eGNZNXRFWmZIeGl1KzkvYWEydDFIcTBKZGxocHd0cEluSk5YakxrMTB5RGs1Zmxhd0J4dmsrK29IcXY1bVhwTlRPU2xJZFBEa25TZTlHaW50dzFobmJCQ3Z2U3hnNUtoM2FKZU9UWXRWQURWYnJnR3YzdHpRb3FQTjRzeTlQeWF6SnFUQVZHY0VhV3N1b0ZWZXVlbSt2UThRcjdPcGRSNFdNWktwbFZZOTJ5Rkt6ZkR1RUtibnR2czdwaG5aUWVMV0Nma3E4NUhoM0pwV0w5TlZPd3d0NEpPc0FXVU0wekhFVXV1WU9JYU1xaW9wR3BRVFdqalU3RjZOTWNONzc3cUtLcXlsRkYwN3l4MTVuekwyM3NkYy9PeG9VTnV3V0U4a21HQVMra1cxcWRXU24wd24zRFM0Ujd2bU1mb0Z2N2dDT2N4b1ZpR2JLYktqdFkxQTRFMGZkZVVNVitxZmNyNXYyNTFiRmZrN3JYM0ZMdHd1cW8xbVVaTVVXOUR2TWRNRVc5NS8yQ0tydSt3Y2ZldTY4dkR2andhVml2Ry8zbkt2bXEyK20yM2c3RWxUc2NCUHp6QXlZVnh1TkMyNEZzOFBUeDV2d1psMit0dXJZckEvQnNSeUlYKzRCSlNTaTN0Y3BwdFpvdkN1aVJIb3VDcDlaNk9LeW1vdzlGMDJyNGNDSi9ncDFGNGM3OC9ubjQzVzlIVUliREJMcWszdUZiaTJZc1poYnpIeTk2eVp2RlVVdy9QeHF4SVNrVEtudTZ2eDFlc3NGb3ZaZWhiTFNMb1N3cmpRNWpneU5NS1hha094NS9Jd1Z0R3RRNk1va3FVK3hoTzZ4UU9iWHVjNTVRdzllZ1FQYytVZGJKNzdXdlFQOGp3NkwwQXRYbGIvWUJmb2h5cUNsVW9KczNMYmlDWVlQcXE3STRLc3BiSkoxZUpzcnQ1enZOZFpvMzF4RzNxYkRWQW53MDc3Y1gzV3NYM0VzWDFETXVQSHNCbnBJd3djL3pNTVVucHY3VTBiemZTVks0bGNUT3pURGpJcmdaN3lEL2hNMDhRc1RKdDFseitkRnRFWEZsQytOdGQ4d1BxNVNGRFdVelN2dTIxZnhZL3BrOVlSb1BXNUVVM2Yzb0Y5S1o4ZEtXWmM0K0l5LzhxMUVEd3BMeDVvNTlSeEhzajd3eU5oN1dROFlybVUxSG1JQWkyOGZlQzNUeXkxRkt3MFNsdUdQRERhdHNKN01NMmtFcVdtd2hxTTAybU5xVDRyVncwUlcvNHo0dWRBQ0tHaGRjYzZBL2Ftcm1uckUzamUweHRhWktSVTNVaDZKeGkvRUlxTFlGRHlzZUhkSWhncmJmUTR1Sk55V0tOTm8rVzBCWlZUbXFKOGdWUkVybzBUSUs2dFBKeXZSMEpXbW9hVTBmaXRmVDhlVU92N0FjVDlmalE3cVdWZzNSZGh5N2VyK2R0Y3VSa0NTS1VpaFNSdmxVMEhaRnVzZU9pT0o0OW1SNnJJMjk0d0hBV2c4b3F2WWZtaHF3VDFGN1FJYlFhTFRYRGxlNnh6YUlSRDI3TWQyV3hienZnemJGSG54QU51UTNxYXlvM253elBYeXIzZlRzd3lSU3pXREdZdzlJMGdOcU5LcDBXUkFMMW1KUTNsMTJQQ3ExcW4rQXFhYjFBQWlaczF5VTFvQXkzVE9pWkN0aEdwTTJzeHpBN1JUQXVJNFkrc09xcFQ2c0cwVElnQmQ4R2ZmTUxmeDdtdHpJdm1Fbi9Ma3RqNWFYaXV4dXR6dGZkNzc1TlArR244Ym41NHk5VDNZRnkrdTJLWkFiWUI4cTJQM2RWcUUrRW1pNkxoTUc2OTRRNk1tN3p3NVVjQWdFclJPc1B5aEpEMElHM1hhZmJuOVFNaURZSFFVOWVmZlpld29NZzZERkFTL3JIdnRPSDk0czd6NjdUb0Zoc0NHRTFvQkMvZjZCY2FCai8xU1lsUUp1RTRNVWcxMjVHaHdIWFBhRWRrenJxTlZVS1Rwcy9MQ05iQmlXelRLYUlKNG1pQ21sZ0d5TzZjTGgwYVphRjZuZ25UNG1QMjUvUXlXUmtDbXEwVmh4dWlERy95cFdUaWRIQ0xFaSsvWWg2cmhUaTRnNmVWZllsR2JFeUQyVFRGWTUyVEZldWxhSWh6STBaem5Gd2t6TXFoY0pHVWxhZVkzY3dIUkdROXFXZU9pMGJxeHh3czZ6VjlwYm4wTS9jMzM2YVZjMm9GNWM3VjVkWjdvK2FFMllkcndYVnNQSHVBSTkreXJneGYzL0Y4NzlpU2lSWjVnT0l6QTZhUEMwR3VXNjZPejhLamp1QVZiS2pySUM3MGVZbWhNN3dnck9EQk1ra3Y4MmJXaVJYWEU1WVM1YlVzN1lza1hQUzlheW1aRGp1eUlhSHJEZkpMYTF4Y2dGWG1kbURHb0dFM2RpVFlwWkJXTmRteExzbkVVQzlXY3JIZGF1WTE2aVFsbGxrbWhvaFJJbW1tNm5QVUhDd25YWHlSSHBCckwyTWpFa2U2SmJ3Z1EyN2E5K2Urc3hoU2kvZk9TTGlpUUh6NVFtMkRtbGk5am9HRlJpcjhDcDk3MTJudmdlSUFNaWtBQzN0VG93dExjS1Uvdnh5WndUdnZPczd6em5PVUozV3k1dVVEUENEU25RTG9HRzR6cDhaUGMwOEltamhrbUwrNWNBRzc5QmtvYmdjVTBUbHFON2lqUmhtcjNRa29LWm9NVkxseVRwOVpCd1NKYXZBZS9kUldvYVI3azlOSW1kdVZ3Z0xjQlBLVHo3aWJzWGkzaW1IQllBQU5Ba2JML1RTVEd6MDY2c0dDdENDdDlScUxSOHh3N2d5SFdGaWlONVdMUS9lb1ZNcE9LMVczYmZzM3Zua1dXSStleDNOR1hISGNzU2JYOVBVOGF1R0pHSi9ORmZCbWlIQzd2dldidHJ0MHlWNzNUdWNzQTF1TmhMand3OElCc2tUUDY1L3hSc1lFbis4cE95S1R2OHFLc0QzaU5LTjc0ZjdWK25hZ09MREM1WTMrNHZzbXZ0dW5YZytWbzJGdDR5MERZdk1KMmwzL2tVcFJXYTFJNmUxWkxnb2UyL3B5bjlrelJGUnpVTTAwYkIyLzd2bXFjdlRhclFaem5nMFlCZmJyckNiQ2ZsbElGNkRzaXY1MUkxUEdMUVlGYXVhNzV5UXJXMlREaXRDN0Vtc2YzcFFvTml5TnEveTJKZWxNT1BoTmxURmg4WDVkK0t4ZTZ3NHZhaXFNQi9jYXNWcHdZeGpad2VOV2g2N0NsWmZGYVUwNUlrdGVIdm1ad2swYUhZU0RZN0VzOVRTY3BCRmxlbEhObXlaQ2MxWEowUlJVb1VzWkVMaTVHWWFjWWlZdXhBKzYrSHNaemhxQ2d4UFprcFNYVFhqNmZJQ3F3Zlk4SVNyUDNUbmxnQXFvMEhsTHhwd3cvYko4c0xWZFR4V1diVkNvcTVId2hIblZqZFNrZkRvNFg3UmRHRUd0dzdaRVdHbmh5S1dERnI0VXhRVUUyT3ljbEl6SEZpa2FTYzJYby9KRFZGOGQ1ZGpXclMxclp0MCt6a0ZUTlRCOXAzKzBwUTJMMEZkOSszZGQ0emFudUZTNFRMZ2V1NEZucnZKdUZtNFRiaFR1RzF3dXVFNDhJYmhBZUV0NkExMGZLQ1hVNmllbVM1Q2M4WVBPR1hWTUNKd2JzQ2ZzZDdoMFRVL1hQZ3ZaWnM3QlRMU1hobHRsRXdDV1pGNGJrQVNWQ1Z0T0txWHVJR0x2Nnh6eUE3TEFMOVJHQTZrQ3RyM0dtMzhFbndyYjNpL212NUNURHhHdmV1clp3VHZNOHd4UnBQMW1LSld2RGYvWnkwM0M5YUxGZlB6NU8yM0d6UkJ4NWVPTXVWLzJmL1hGMGRwb3VQZG9mMkNnZlpIbWV2dloxU0pSazhPOTY5azRsTjJoMHl5VFp2bFNDWFhPbGltWHNXbGxPcUxEY0FzeXJzUWY3V2liMXdHa2ZON2Y0aThTOEozNXU0UCthMDF4a2Z5eHhTNlBoWE81YWhmMFVGZXFzaFE1NzRlT1FzNWdkT0owRWg0SFhlNWJIR3crNlBlYlArS3VXMzB4cTBFOHBGK0Y0d2NMczl3c3p5UXFOMzh5RjRBSXN0UlVHT3JoaDhxZlMwWTZXbkY4VERHN2FJRXhQcjRMWXY2VUJQeEk2Ly9XV3ZycFJFdTF0N1pZTW1pWGxOMWo3YmFlQ3VwdlphUit4cWFtK1A0aW5oZWNBMU9SaFROOEY0NmlnRTlhTFhSczFwTUhIMlF2QzRSeStoQ3I2TjhPdXppT095b2h4NktNU2VzbWlXanBRa1RXMms4R1ZJa2xLd3dxTTMxVkMxSjJYeDkwVTVKY25pZDBSWitxNGtKU1JKSDh0TWw4cGJzaldkdmQ1NTg4MnFNU3lMamlnemhKMW4zbUdqL1FSL05VVnBBajBUSEsrZSt3bmcxVDluOHNjbURKT2VlMnFrOHZucWhXYU9nTEZZQjhUNW1FZDFhT3R6V01JY0UyQng3M295VGE4bjF2VTBuZmZ4SmRsVkQ2UmczbnJKL3VFUDdaSzN2aTNDZUIwVFpsRWJvK25nbmdqN0pST3U5UVpvZWp3UzRRN1dwTU5hdHVsdFhOdEpKMmcxWXBlM1lsZ3pzcFNXaVM3U3VLRlB4aElqZnp3eWR0SDRmWklTQnNJSmFQbUlydi9RRm1IOStrZEpFbTFaL0pFay9kY2tJUWFSQzVxa2p4dVdrdFNMZGl5Zi80MnhpOGNVV1JMRkRGWG9jZVhWK0dWRWIvOS9TVmk2NmxpbnVpUkdrN0FLZXJwelpJM3BMcyt6YzdaTWwyWVhPK2RIVVVFWWZqT0VBMXBqS2lVd3EremVROXFlSkpLc3RsdnB4TmFJbVRLa01GR0hGR1VIcGJvcFV1WFIrY1B6aVU1WDBQWVh0SERZQ29mUG5KbEoxWXdoMVRIblFrcG9Sa1Zsc1p5a1BXNVFQUy9yZFA1dys1c2RsVnR5RUQreHdwNThlcEU4REt2WExyUUM1czF4V0lDcnk0UXR2NDIrNlZGemVrYTdwM2Y3Mmp3MGh6VHRESkhHL3ZraFp4cmZZRmlHZmlra1MrUzNKZWtNdkVJUUdRYm52OGhpUVpLTWllem92RGcvbXAweUpLa2d5a28rTmd6VVJDejdnUkorWElvUmIvejR0a3FmSW5XQWR4STVzR0xaTlp3VWhOczF2OVNCTzhGMU5Yb2JXenV0aC9XSXBoY1kyWjNLenU2YnphWVlhVjJ3UWpHZDV0dE12NGdnMXRIRHNmUndkWnExbmpHZUtjL09salBqQm52ZFBsMXdRb3JWYWQzTzNsb0Y1cDBHTk1NMllSVm9HazliZHdOVU1jTVpYcVJ2R25nQ0pJQ3FZVm93ZzE3TXVCU0dzT01XWEo4UmZPd2M5QWc1d2Mxa1BDeUxYeGJsREl6d244SUEvenJETHBGZmlqQmNJMG5ya3ZRbzBGMldxQkE5cmtpU0pZdHFYaFh4NktrUzE0RllnNEFwY29wYjZHamZWY0MyTDFnaU1OVGdtWkhFSDZkRmVTSS9XeG1kelUvS0l0S0I0YnNVVVJORk1XcEVKRW1PeFdSSmloaFJrUkJOVk83eThTMzVDZE5aU09PZWNKODFSVjg3RU91SUVsVnU3NEF5eXpxOG5sNEUxdFVramwyMEY2dTQyZE9aQ1o5UEZ3b3p4ZUxuWkVOTU9na1Z0MDNITllsbUNoa3FhZU80RGFvbXpMQm1TTG84QnJQNjFhVHdhbEZDOXRYck4xRW9UaGZoOXlHb1J0VU13YkRRRXNsa1FvUHhFSUlQNHpMaVgwMXBueU5FMFNTdlhuZkFXSFJnN2x6U2hWMFpOdUwxYzFLd1VuWVd6c2FBL1M1WVB4TXdzWmlXS3RTVnZBcXcwNWVnODJCcElDYXNFR0w3SnpWWUV5WWxhVlNTcm1IdUpLd1BOZnU3OXY0NmRKVFV4TjVwaW1Jc2paNTBUUHgrVnBUdVJ2L3NiTWU5V3hLenQxeDlqVnJYVGJ6NGljT1BPS3ZHZDRLYUtpMVdhODBBaFZBZXNEVUZsRGcvK1ZkMmVsYVRxMG1CRkFwa2k4ejNwdGp5eTNlcjVBZnRyTDF5SnJpSS9LOEg3cm5uZ1FsWnVSOERwcVk2N3YyS2ZDMVRhZjF3Z1BKVzNUSGtyZGtQQys4U1B2cC9kK1Z1T2dtWWlBdCtjL2h0ME5VWWp0Y1d0Y0haL0N6ci8wV1o4S1BoREJGSlhuWkVjUjZkUEJFdkJhdzFmRCt3S3I4RC9BMFJ4YStLNHM5S0tEd2VXNTZmWDQ0UmNaOG95aU1qcmlQQzY0S3E2K3J3RGFFb3ZrWkRSQ3lqcHl6Mnl0VjdlWHA2UHA3K2U5eWdKNzNqRG1aUlUzc25UUVJZK3M5eCs2Y1k2NW9yN1MrdmErK2hOdWorb2VCZWdadWo5aW8veDhCMnhQZTQ3VThPRExkODJsOWUxNTZFTStpdW9kN3lzRjZ2ZXBWbk96UzRTUkdzdld2aHRLKzhybjJLNXFCN2hiU3VHckJpV0liY29HbHJNMkM4L3ZzRytRTDVoSkJBKytiT29OdUVPcFltQS8zWS9FdlhsdW1IUHNUdjMva1NUZVQ2ZytnUXQvNnNmZUNES3VYR1RyL0NRK2dIL1JCWE52OVA1Si9JaHphNVg2cGpaU0hRditYQitVUHBuWkN2WFJDb0FSaVNURHQ2MEUxR3RHTnlNOURwTmZJUHp6QUxydG9IUDhqemZVYWxUL0VnK3FGTzBPOE9hS0RTZ0xCZ3Z6QllCdDZHNVBSSUVsMzdFeis0d0VMSTQ4L3dGNEJaZGJwZ0RsYkQyOXY0QXJtNEk5UHFuSVJnWUEwWUMzdDVMeEFNSTd3Zk5NR3o3VjFoL2V6Mk1sNXF3QS84czVxVkIzdzRvQU43OCtLOWhhYzBhc3htQURjZ09qUWdzd0dkMENjcjdOMHZrd2Fpc3E2TnM3K0UyV2Z4Nld5REI1RloxL1paKzY5TzhBaWNnRjM0YkJNWlpXVWdTanU1ZWJaZE1zb0JZQW45NWZidXN5bURVRnR3dzQxTTl4WGJ2ZmQyWWVYMjdzSFpnMURjZWFwamJRNVd6L2psTTZsenRvZk5wQUZUaHV3Y09JQTlQZVlXMFBTVEFYcStpZTFWcnZFRGxqRi8wOG83VlJHRDdydC9Zc2NFL000WldlUDZPNjVIcGY2YjdZZ1ZzUzNtM3F5VCs0Y3hmbUpJMTIrNEFiWDlYOW4rZDZTQmpoNWxCdzVEcnpTeWZNeWpEUDJ6aUNXWlhSbmNYbVBMQTFDU25yMEdOQnZnS2xmamZwdEtDb2EyN1FxbXFIM0ZOczJ3UXd2WDFmY2VlK2U5ZSt2WExZVGo1QU14TFNKYXQrNWlldDl6dTI2MXhJZ1dDNXVTdWUvMnJSZmR1d2ZXa0syMzc0dEkzdjFGM3ZyVWJhTXd1UEFGbHpsUDd3dmJERTh5TmxBbXhVamNuak15SFZ1Q05IaTloV2NMK09EQjZuejFvRzhCOU9PY08zbmIrM0JqUkpaUlozUDZOVXozaXF4bHE5VnNjQ3ltT1ZQMDNIc2wrVnFtRlVxazZWZXpQUlZYUjlpRERlOCszZXJhMGRzQVN0SjNPYXp2NlVnbFh1eDVpWjY2dFgvYVpTT3gyM0RpSTRyRWJLOXQ0UFRYdnYzWUlFT0tMZjVvbi9RczZhRXR1RDVmVDk5Tjkrb2NNVFliVHdqNTNGdnZqcHgvRGJoYnhaWmJHVm44TEJLZTRKQ0RIVmdaN1BNY3RHTUo3d2h0RHgxVzZCbDVVcEMxY29ZWmN4Z2NqY1poaGQyMHZRTDlucGVNTGtXUmo2M0lLdE5lZmdUMWhhdXl0dy9CNWZ0UlR2TjFvY1pHako4Y0NKdzFkZy91c21vV1orcGVQN0wxd2RlamFxL09GRTk3QVhXWEovYnZkdC9DN3FudlBSZkZoajV3d013WUJGNEx5L2ZKcC9GazkySnowOWp1TTFQL0lhb2tJY24yOXExeHV6aDhLQ09KTVZHUjdDM0RRNU4vTFNxaURjeUNHNVVGQnBLb1lnS2lwcnJ2Y0Q4alNqbFpUa2JpVG1aME9wc21HVWthbG9ob2tlejBrQmpmTE5KdDAyK0p5R2ZtaFRuT0o1U0xMdEphNERhVUZ4dmNTTXNHZWczaVdtbDd1WDJ5dHFlMk9ERjUyUTJYSmRORFkwdnExTGIvM0swRGc2bnZEbW4wTmJJcHY0WnFxK1h0SlVnMmZYbFVtN3hzY21yVVdocUx4L1I5OGFPNGlYODBBY2tnVllLZkJUdkR6ajdtbWFVQnRMcFNSdnRkVEhtTm15K0JybUFXQnJwdG12dE11NHVjeEt5Nk5EYVVUZ0pZa3hPTFVEWTVDakJzZS9JVnNHcThncHNONXhhM0NzeWMrUCtJeGNlV3JORXBnRTZMWGo0TjZhRnEwL3NPdlp6U2wzUEQ0K1dIVUpYaG9iSnJhZnpGdFYvZnZWWk1lMktqOXZ0bnQ5VkNmanR1MEg1YmVMdTVyU2k4bFBielQ5LzBtSVBmcVAxNkc0N3lCdDJnL1JaN0c0N3lCbVhMZndEV3pTSGRBSllOeWhTOGMvME1YOHpDeXlMTDFhbTZ1YzR0TnBteGQ1UGZPcjVNcWt3RlpnR2orUHBNN29zNnU2L2Y3VmlWM2JYaTFsS3VIaE1sSjJPRWxIaG9QUlJYUWtZbUpZdXhlcTYwdFZqYkRVem5WWTNHVlRWbFpFY0ZBbEoyU284a3duTENNYzFVVWc3YnBnNUJrRXRseDRnZ3UvTG9wOTB6VWRjd3E2Tk1ZOWRCOC9Qc1A5c3hkZ09UdnBWNjNEakcrNVM1TmI5bFV2R1hObSt4czcwUXNqYXpaNmFRSmNsMGREUnZPbFptQk41SE11eVJkNVNFSGNxUXlXVFpUcEwwY1B0MDE1WG5mKzhhaGFxajdaN2NoSmJPcWlpZWxPbEpPcEhqWWZSWjE1c1oxelVERUxpc0drNTJRcHQ0RGIrNnZPMWVZVTVXL0t2TUJkbmRCN3VGNlNjV2NkVnFKanFuRzlWS0dmZzRWeUJVOFE4dUJEbjdOZWtOdUNhOFFTSS9lb1BFL08ydnhES1pVaVlUZy82ZnZPeDZkRnFXeFk4c1dkRWk5eG1Zb3BSNXZac0FITGNQME9ZWnQ2MThFYnV6bnAwVjNLRGhGeHozem04QXJxL1ZPOWZPMS9OVDZud2hvNldHT3MwOWtsR21MOWZITXRCZTdYTURXMW9vNTdUaGRFVWZ6L1EwTDNqdlVhYTBWQTV0aEhVMzdiclhzcEp2MHhacDk2M0FyY0JRYnRyTHpNNG1sV0RwNGJwUTNUZGlWSnJCK3pMY1N6U0lzMU5SeEJPaXByalBOMHhDMzk1MGswVGtTVmlIVDhyd004aGw3S25Md2JoZE1maUkvSjJpa0RoNDJoT0tjbXdheUw2REIrR3phVmw2cDJ6STc1VGNoeHlJWWZzemJZWURQaXJZUW83ZDN0eGdCclVZRWVFcEVMQWJ3Q2ZKZ2wxRW1UcGpUbUNhdEZwalN3VjI4ckhjdnQ4d2w4Z1JwRlFLQjl1Q0ZRa1ppaTd1MXhVakZGbFpHbU1ISGszanViRWxVZ0NLWjYyOVp1aVpSQ0tqR3d5SFAwMitUNTVpcCt1RkNuUXpzKzAxUTFTS2V4V29ITGNUOEFNd0puakdGTGpZS3BxaVlCTndoQ0NlUnlzR2VFb3h4ZTZJVHpHdU9WWG10bnlBMXZxVENWa2lzYXFreVJPNWtpSTNtN0pTeWszSW1sU053Y1NaVU5YenhCL25OdUkra2hFMWVXRWNONzJjOEt4TVNUaE1xRHdiZGpLaUtJMHZ5SnFZS1pjdklBMDNSNGYzWk9COTdXK0ZjWE9KY0pYdzY4SW5oSDhWL2gwdDI1aUVDZk5SVHdXdG1WV1pCdnRpazZtR00rbkNvZ05CYkQ1QVBkSDhleEw0TU9nZGxhS2lrc280T0xXV3dqTzVnTkIrVHUxSkZ4bUdwaXJldEpGU2ZzNVFpb0ltNm5MY2xJbW9HYXFsVU9nU3FsaXFvWWxFTnVPeUxtcVcxWnRFN2syUmpWZENKdnpkVWRKVVdTK3FNVHFVR1E1cjFhb2VHa2tQYVRHbFlNaXFWbFRWSXNRYkJTV21RWHhJcjFhMThIQm1pTWJVZ2lFcFdrbDlJQ21LMWZ4d0xpbVNXZzdnLzNuQ1JvaUozNGNsWFRiRFVWV0oyN0lhalppeUxvV29LTWxSU1lyS2txaXkrRWhVbGUyNG9rYkRHQittTUJ4TmFka01WV3d6WFBsTVRJNXAyVEZWa21QSlVFbURucWJFMUVxaFpFeVcxRnBPZytqQ1NFeXh0RnlOU29xVk5FcDZCRWFDR05GTG9ZU2xTTFNhMXl3bE5yS1FHODdWUkRHRkR5SitiQ1Bvd2lwQVo0cm5oeTQ4aXRBSlhmWU5iR1lUcXRjU2ZUbldzT0d2bXliLzZmcjZtZlgxSG8zbE5UU1lUd1MyYm54TDNBMTVlalk1T00xWHFxbVUzNVBVUk12TjdybGwvOGh5bzg4anJsejVqZ09YN05wNXRVeEZxc1cxaUpvZk9mRDJENy85QUFObExKKy9xK3R4ZXV2TlMrbTZKbXVVV2hGbk5MZFMzb3Jtb0hTTTYvNXhtc3FEY1RQb05nUmhnOEk4T3czZkV2Y3grNVJROXlibWpIdC9QT3ZxZ2k4WFY5amNyaUZkeFc3VnFiR1RKaWtIbFhqT05HZnJ1NENaSWFvU1ZRMWxtcDNOM25FbkdSYWxpS3JMUlhOOHFsWjkyeFZEVjA4M3BxZTJvNnJialhhRnFyS2lSRUt4b2NtbHFjdW5waTYvOGZLcDF4SXBiRmpaa1FPWFp1U2RjL1dtNk9SaUpWVlNaZDczbms1am50bnRETzZBMU5pdVA3dXJhUmNTaHY0eHllQXV5Si9mb1loRktaTFUzZWNPMTJ4Smg0Rzk2RmFaUGhLS1NacjdmRjNIVHBNblQ4TjdaMmRRb3VycUZiQXRzWTY0bUZrUjg0VU9IZkcrY3B1ckkyb202TWh0U2tUSktPUUwvV0hKMjBaUTY5UmdLcW0zS1JBU0lUZjFoL20wRjk2L3d1MEhYWXNXaElJNlErNkdmS1YvSDY3M2ZIblNPNVRlcDYrRWlyNFBRckZJYzZHWmgvYW5mSy95SU5ML0Q2THZrSHY2M0F0bXIyZTZJdE1Cdi9tUHdTeTlRSlphNk5oTFhlL1VpMXh3dldLRDZ0VWNXSy9QZHRYcmV4dlhxOVZWTFR4YXRGRzkydit3U2NXOHV6U2VadWZwSnBuZXlqNU9HUVZoSy9hOE84dzJBdUszK2FyaTBhU05QczlCMzVZcnVZU1pyRWZuMTlzcnpNd2FrRlJMN1NVKzJQK2c2OUVLR29IMXZsdFpPcmdFUC9lQ3FlRFAxUkYwN1hrbE92ZVlOSXNEekZRcEZ3YjZTY0lzN1I5ZFdVR0dsMXdvMEd1RndocnpiQUl1MzNOL210bFdROXd1RkpOQm1Sb3VIUFpDbDlnUlJsb1RkU0RRWGloWjhRenQ3aTg2cDA1NUZuZVBHT1liOTFCRDVRWjJDY3pLOXRlZElqbDhCRkl6MnhGRU04ZjMwRlhWNk5MRFh1eVJwZGxxNTFvckpJaVlyQnd4TE9xdk8yamJjTkhkOXdsSzJPWU11ekkxdnFkUzNYMXRLYTZqemtKSXBxRlVxalJtSjhwcEo0eTJwekppbCtEdEUrRlFxcnJuNmoyVnVHRkl1bFNXUlZsVnc1TzduWXlwVVpuSUpVbjM5RWErTHE2UXh6YXlIVVI2WktsT3o3dG90UXRzZFVVNVZ2dkJqazVncTZQWVR4N3JXb003bG1VNmp1RGFremdEc0t6MzJOMTR5d0RKWFk5dEhkb0RWYTlGblY2b3p4ZmZLMEh1cnVXSDJZM3p6Q2wwS215NUZodkFlYUpUOTBJbjdWb25BYk5FNGw1NkhteWJmL0ViWk5YVDFneVlnVGd4SUt6ajNNN3MwS0xqbjBIR3R0UmhoUi9IWFlFRlQ1eGFkSHBhcjlielRwaGVIYkptdk1ZdnRBS2R1UlpRK3hSZWFQRVVGbGJnaWJzR1FFVXVxcVBBMWpzajhSVHdLVitDZVlFN0FVSkZZZUpVS0w1Wm9lNVZFK3htcWFqb2NDNlhLZmY1cWt2a2srM25vWm1iRjh0QW9kSVI4b3RSTmFHZERHVzFwQnhSa3lPL20xUkZPYTBwb1pPYTlNdWNPWHJMNXhVSXVuV0haaXFmZjRJb0NVMVNYa1hsMEFna2pQN3VTQlErS3hzNWVvZHF0Ny9pM1NUaDJWSEgrOGY0blF5d3dpNzRUUGFBTTFSc1hQWWVwQUtFNkRTVDVMbXhyVnhVdHZXSHJITThXelJFODErZmV2K1c5Ni8rY0NzWFRHNzFFa0JrKy9sT2VqU0U4LzczdzgrSEQrVmhNekEvamlCODB3R05hcURmZmRENFhZYmViUWplcXRPNUp3aSs4MWVlNWNBbDVQQ2RuNGZaT2VCTWZqUWNldFUrMXJQN1hoVWF4djd0RGZoNzlqSzF5eGpIMkhGajExUmZBRWZUWnpiS29SUHd1WTN6Y0FQZXpkY0dQcmIrbk5sclRBR2RXQkFFbTdJenh5a3UzdWI3ZHRDRFNTZEphd3YyUWpQNS9kTm16SXljTmxMRzZRajRUc2RhcmRhWmRmTEhCOVIwOU51bW94NVJsQ09xWTM0N21sWVBxQmZ0SndjT2tQWjNmblgzTDNMN1FOK0FzbjZUblVmWUlzeXkwd2hvSmJYR2JrYXJjczNhRGdDNDIrckJBT09pV1dzaUZEYjRGbWh0dGpsQ1BKOUQvdGN0RWVQMlNPUjJJM0tMRVFucHQxdldrU09XZGJzZWlyem51dXUrZWdmOE8zVGRkZmc0eXg5ZkhyMDdGSmVyaWxLVjQ2RzdSMlU3ZEk4UmwrYzBiWDVlMCtia3VIRlB5SzRWTHE1VXFsVXlQdDcraDhtcmFwV0ppVnJ0cU9keHh4T25VZkpDRmVjbEtTSUxqanhBQnkxVVdYVlFxZDlISTl4VVA1bytFeWZhVThic1NIMTRmcGpkK3pRN2J3L2xuaGlaZmVFTVg5SmZXQk1MdU1DTGEwdEV5STlha0k1ZkRrV2taTm9hL1NrdS9ZV1RTMk9XTmJZVXRKM3Z5L1FxcVFTanRLbDc1eWNhT20vVzFMSi9UTnhoTnExaE5hMzEyVHowemZxVEw4cHllbC82dmd4RjJtR01xc1dpU3NlUWlxQ1oreUJDbGovNWgxMldEVzlUbUVYZUxONVRrem1lUVFrMUpDYkZJbUVaeEdNUW1KRU0rWk91NWNKekFuL2V4ZTN2ZXJna2FFdEs4SGFUZHhMUEpKYjN6cTF6TzhudWQ5Snl1U3JQS1M5dmUyVGJjam5nSjIrWVRoUVQ4T09QQis3a2IzZW1JK0Z3NUVUWFc4Q09GOTZwZW8xdzY4L2xQdFZtcngyaG5qdXlYK1ExcXQ5RXl4NDNjRU5CTjhqdFQ4dTYvQ2czOXdHUGwzaC82bnhlaGl3TnlBV3lOTnJQeVpBWHN5VHlLT1R1Nmp3ek8zVjR5c2luTjdZelhPcVJzNU1NV3lMOUlSVVhpaDVOMExMMmUwUWkwSXhXQzhKRzJ5dlk1N0N5dzF1ZGI3ZldZYVZjQWVybnpCbGZ4L3JGbEJkN3FlV3RFOENHQXZYdnNrTTdwSXRBVyswWHJoWnV3ZE9VcnEzeW11ZWg3RkluSUlWVDdvV3dOYnc2cWRyRUhSM1VBa1FSb0tQMDNWQkl2ZStWWGgzd3MxdzQvbWx1MXVJTXpZUm1sODQwNTBJWkdxZHl4TW1iTXdYbDRoMlhYWit0UnVPaE1KQ0wrN28yNUgrTmZ5N1NGeGlySWlMZjBPSXk4NFBjbk1ZWFE0bzZiTjkwa3oyc0txR2NrZFBNU0Vvc1pWS0ZSRTZNR0txV00yalgzcnpHdjI1MUxyVmpzaFp1T3ljS2EwZlA4UDAzbXFMUHF1cXovRUdlMUxUbkFQVG4rRU53OXlEdzJ4MndDbHpDYkZndGVoclZ4V2tSZmN6ZVBsNzVSUnA4WDRpZmc0ZUdMcVpjazA1TXpnSWhGSlZzNldLemtYSmlLaTFYYTlDMUJpMm9oaWkybjVXSW9SYW9RWlJrWVdlMnFHanlXOHBUcjFzcWFTeUZUa1NSTEltaXJoWWhpWnFmT0hSb0l2L2ZSL05yK1p2MThEZkR1aDcrUmtRbnYwTkRtcW9aNGJBV29sTlRGODNiTVluS1E2bWxsMi9iaVRHNmJrQjBpTTQzRGphYkJ4di9rRWluWVFXeUxMS0NycmNmOXhTWmhMRjBLZFBRd2J1bytFRHBKa09ZdmpES2VCT3VYam0vZXRqcEprclFQaUVUQ044N25LbU15U0V4TFlwU2JEYkRWL2lGdURVVXZ5UmloNk9aVkRxWmxFSzQ3UzNaalNHdS9yd3RIczNITG8wa2lSTkw1aVZSbVpRMUtacVFacEJNbURPMjEwcVpwS1hudFVnaEhERU1TeUx5dUt4TDhReHFLMUJsUnRzOVZVamJVVWhnZWpLeEw3THo5U1dtbjhnSVVvQk04by9IQU5BMkRQNWhjWmxaSy9iWlczR1hJWWJWdjR0VVU3ZExNWVB0NE43NDhrUkNWaWEzejQrUXYxWFY5bE5jL1BlbVlWVVZMNG5aaEV3WVlUYnkydjlzemVTR3AwTE9UUDRTS2ZRMlQvWW5zL1BFT0YrM0NEdlpXVE9oVW93RmhSa01XNmd1bHE0MU9yNk9DZWtGOXdQRUxMMFNCNmZuWFR6YXRuUzY2aDdrdjFZQ0tLUXZNL2RhTkN4OW95OWUrQjVMc3hvVUhlZ3I1S2c3a2RvbnFhNXBpS1k2VHhheG9xUDlKUENmRTlqdGVWNHVBYSszait6ViswWFdlUE1hWEFDSTNoamc1U2ZZemN4RnJ4VmRDUWMycGZLaXdEcE5HRWwwc2w0L2lZS09UMjBHNUJwdkpDN2t3SWE2SUtnbGY5ekdtVzFwb0pZYy8rSnZoOVlZdnI3d3dVeXFPZWVqTUV4M3dKRGVXZHhaWEFZL09YQ0JBL3kzYUd4QkROUFB3VGVKMnhPM0plQ3IweGM2NW9OeWsyVHZEYjArQ3hJUWkwUTR6eGFVZXp6dmJvckpQbytVZEtWdWd0MXc1WWllQ1JsbUZvMTBuV3RsV3BITXZwTzc1OWYwUEY4SFh2MXd4TkFmVXkzMU1kMklIRGJKbkdtMEdiLzkvdG5vUkhUMi9ZYjVJRC95dGNJZmVPWEJxUXg4QVI5a1RnRS9kNEpkeXdUT2JEUTZhOTdLRDVWcC9PSHl4M2hYSE1ya21mMDJ1KytXTzY3c2lQZUVMWFNtZGpmZldRNmVKRWtPVUpXY3J4NEJxTk9vZnBibUFnTlJkVDJHRy9FSDhGenJCTGxlc21vYVI1alY2eU1lQWJMR2ZGeGN4cU93enNGYm9Ma0FEYStVYy9tTTNkQW5FV0VJTlZxWThybW9WbmVKaTNPOUpLU1VMTWE0VmFpZWV5ZFExWVc4LzJXUzlJMlhHeEZpZkVQU1BqRWJMb1JHSmVsbGtpYU5obHJ0MW5jVmFVeFZ0ZlkvZW1LVnFESW1rN3N4L2hzR2lSZ3YvNGFVbUEzQkp4cDhBNThVMnYvN0RySWlqU3RSVHhienVLYXFZNUtuZzhQazBsR0FXYWowbk1hcG9GS0x1L3MrREZTMUhXbXZNVzFTY050SG9laWNhRDVoVHNDZm1GdmhSdVRCYWVScVpzdXlXbVl0aHppSEdWQWl6eE90eTBhOFVPbFlEL2FVLy9wQ2xMNFFJcWd3b2pSTjVjcXV2OUwxMW41cjErdGZvRCtzYmVPS3M5czJlZU82ZEFFWTBiSTNuNUIreWI0NVg3S2ZmM1RFSzVRL1cvd3h3U1BkZkZFKy9xeHdDdVo4VjkyYmZmV3E5WVZJZlNHclhiVWIzdVN0dSthdjczcHIzOUZkZFg1M2VBQkd3ZGZOcWZGeVMyck04NndPcUNUUkJyYUhyd2Y1Tk14MzFQYndoZFI0MHlxL3BBbU5ZcWVTMUwyRUZXZ29QS0xJTlQwNGU0aVl1K2Jabll1UFA2Z253c0NBaGhQNmcrUHhQYUlxSFhmZmowdXFxSXRFdk0rSnBzZlNVZWMrOERPaEhhRnBzL0F5YXFuaHNHclJseFhNOUI1UkZLL2o3OWVKYU42QmlvZmltbWxxOFVQZ2RYbGFUOGU4akpEM1NtY3BnT2tmeldOYmRLVmEwNTg1QWRnWHUxVHQvKzFBVHVkb1JjOGRVUFBwL0xNY3RhUXVwWllSRzQ0WkZyMjBXMXo2M2FVVXpTQ0N5ZERVa3BKTXpyNFhYOTRiVzFEQ2VLWXFyQ3dJWGZaamNtajNnaXdHanpRdk9rRjRLSC9zSXNGN2drZGNrTWwvU0pRM05KV0tielRTSm10SjQvVi9GYkZEQ2VPaFNVWG5zVHFkZXNCSWhHREJrMlQ1cXdqclYyVkp6QnpXNDFvRVdsRzc3bFhZMURlVlpCcTJNZFlPVTZYRXVzRFQrUlBZZmlQVHBPTm5UamhpYlBqN0xUV0hsbXZrMzB4ejNSd3p6d2ttY2phRW1RWTQrZEZITGpwMjhIY2dlTjNFbURHSVlyVHkvL1BJM29QdUhhdGtOK1IvR2VRK1RaQXl4K3VkRnJtMXNtclQ5N0tMa0R3R0VLME8rdXVRMnBFTnB0aVdCUkR4cEVsMHhVbE43STRla3dGYXlQY1hSZkg5cnZjUmEza3NscFExTVV4VUpaZlovN3BVRVVGTmlTVEo1SDEyYyt1Vkk4T3lVbEpVb3M3VUZEbXY2bzZ0eWtPcVhnYkVyU2hUaWs2VWd5dVFWS0hBVFNoNWhlNmJtTktJcG5pODlIK0toTHlMNzlIRzJOQmJtTzhjc0lKK1JwdTZLS255MXhnVVlQSFdoQ0YzeEV6UWd4UitDYlA5bUdHUzUxQ24yd3RoRnp5U05BeExXQVF4QlA1Z1FUVGYyLzNLTDN4RldMNFBzSnlFMVdLN0IwdVBFUWV1bWNrZ0NwdzY2WnkrNnNEMTBMREdoTWZYNnZxMVRENnNEYmZmeXVCN2EzOE1lY2lETTg5bHlkY1lXZU1hTG4zT20rOGRGTWhoNW52c3o1UFBNN3FyZDQ5OWdPbmgrVDZ6aHMvYnVWdzFsOXVsTVVWd2pXMTNCRGJZZndFanE3bFBuSkFwbFUrb2xIYmhrQkZtTDZrWGg3RDdNRHNiRkw2S1hoZksrTTRLSzQyVldlRXdkR09JVmFwNmhiYi9qVU1CZE5ZTGdIZjNrbWNFazkxd0JmU3lxKzJMeW5ZcFI5cW94dUkyVGMzRzI0VjRWdFhPNnNXaVBqR2cycHBWZEp5aVJkYXRVTWhxLzJGZnpWMzlkK0VKZG00OUhiai9SWEx2S1Z5d2VYRlBjUEwyMXdHbDdZR3VOWTFYR3FibDNrSDZla0NNa1FnaXk0N055Ryt4OW1Sem9MbUJQc0pHK2d0Lys0cUFUc0lyWkZQT3l2SCtvSGU4SXFDUzhBb1pRc3hqL1VFTXgzeUx5Vy8zY29vSjRjQmpmbjFBc1R0QXZFMDJQSXpZN0FVUDVib3BKS1N4Z05IWHZuYlVoMm4wcnJ0Ry9hSzdZL0FsWVI3cGV0czRYVERHeFk4SSswMGQyQkhDRVFDL3VkaGw5QmJoakVJbG5GUlhFQ1poVjNHclBTWngwR2doUmNPc0dJUzA0Z25EakJwN0huaGdqeEUxalJNUjJ6U2lScFNJRHp3Z0V2QVk1dmxUbkhoSlgzV25HS1JUMG1QTGgwTmZTWFpaRE9TRDFDbjNLR05naE5KdGNwbEhkS3VOckhacFNqd2FVTU5nNmlhQnVIOEpxbGU4SjVqdzd6Zk93N01Qd1hHTVg2L1l3b1hXeTM2SjlTcHNVcS92ZGNXUjhJWVY2MG5aVXpQUjU2TWNwbCtRVEhRZFhQV21rSVJuNUl1eElsdFZlcm1vYVNLdTRCVDRJVDhyL0NPY0ZXdUcrV21MdGx0RU02Z0Y3KzJ2ZTFnVWlJdFRhemhKZmtRcG5tVDlJWnMzN1hNV05VNlNGVWljTUQyayswUW9RbnJPSWRiNnozdFMxMXhmNERRaWx4VjNIZms4akJPejhJd3NqMGlHL0V3QnkrdzY4amtLTllCb1F4cVJNZG96eGhjc2U4dUFzZ1BHbWpwSHZxbDNTMFFYQkN2eHlOdVJwRno2UzFWTkFPZi9GeUxNSmIwYmlyMlJ1S25EckJML0FoSWtWUFV2bDl3OWVLK2ZuaGFHOGY3blNwY1dDa1BITVB4aVFKVWdjWkJxWGlCWXovUE9lZDV0OTdWVTlEZkNWaXk4OThlVXBxRnIvbE8wd3ZHdzllblBlL0N4Vk8zV0I5aG56MFZUTEZyOFQwaWFwdlRIZThNeE5GSGp3aW9CckNHa0FKbzRkZ0Q1QWdjdU9rR3F4VjFMMkFXRnYvY0lMUlNXbGczNnlLMHhTc2NoeDQveFIremE3T1c1dkNpbWYvQUlOWmFYQ2dXV0lnRnhrSUk5WXRma2NzVktNY1BrbkhnLzBKZUVPS3hiKy9GK2hJcmpTb3R4ZzhsaDE5aFVVUHVZSFdHdXVsZVdvMXB3ZzJ2UTFGQzd2RVNkeFpRenkxZnVoZG1VQ3UrMHBxYklTQ0ZxM1hqNVpaT1VqdTdZcW8wdWsxM092b2tKUmRJaVdrSnQvNG5yYVl4UHNrU1BWWllyMlV6Q25yRGptY3hveHBUamR2RmpCNlNwcFJreU5YbHBLQnRhSHI4bTVVQ2lvK01yeWUxYVFqRWdBL0lWMTNOcGlDV0tRTHlSVXlVRGNzakVzenN5dWVyYzYyckxLTjloZDVDL1ViQ0ZBdVB3dmJ0OEUvN1Z2UE5kRmhmY3Jibm1MS2RIeXJONEJrbmNPbm5aNWIvUHF1UjUybWVneU1yeVplanMzWG45empBcjJjbE83dno2cFpOVEhITFA4NnR1T25CT1RPN2NPWmwxV0ZYRE85bmFkNDZ0QXpWK2N0ZzdnNFc3bE9nQy9rRHQ3NlRyTXVUSnNOUm45RXdjLytJWi9UUDR4d0xEM0hqbVl4L1JSSmhGekcyM0luRlIrL0RibVB2cnFDRFhWU2JPVk8vODBqVGhMc0NCMnVRTHJzdGdFdmt0Tjc5dFpPTDRGODhZdisyWFN1N2o1aytDeFpLVjNtTGQrMkFKMisrcENOT3dPaHdRWGluY3crMUZNNXJUcmI4UzY1MjFRd1FHcEd2eHJtei9qSmZTck9VVGJGTVBqelBpYWNDemlid1QrOHRZdUI0MjQrM1cyYlJodGxiN2RHckdOcnA5cG83N2YzemZMMy9vbk1EOHAySU81QmE3VE1tZy9DN2QvcmoveFNuZk4vaW1HVTZuL29UdEdWWURVZytiMlhjSG5yN3MzY29iVkg1WjQ5Y0Iva3BkakdpaGVEVWUwaUppWFRMRGVERzJZUzZGVGRMaXQvNjFIMjlwaGdhL1Zqak94SWhINGtGZGhKQnJnNy9oR3UrcE5SY2xKQmp4Z0FId2NkUzkvaHo1OWVveThlODhGR2YzS2xUYWN1K2w4bXpqM3UrWnBaQ1pudG1UemczTkh6NHk1V1FrZmZMNkpOdkZYeUl0cXJ4WllTbmIvNHBKdzhXb3MyZkd5ZStyenQvWXlKaFphZmE2cVNiWE1uVDVabmErRFcwU3o1QnlyY0YzYUpPTlpMbFdwbWhpTWttVFRyS2NSTk9QVFFoTnVpbWFEYTVVdmNpdUhSY0xhL1gwTDR4cGtZaDIzS3J2TFlXMCtzcEtYUXVWOXRhdDR4ZzY5Z3ZwK3RvV3gxWmtXYkdkTTViMXFLUks0WThmREYxc1NkcUVKbGtYaHc1K1BBeGhqMXFXUVJWWjFFU1oyOE5TWEZ0RC9FN1pXV0UzOHZqOW1vN24wM1ZiU0hZSE5KTm93QTRHL2hsMlFSemV5Z3ZrNDRvN1ZqWndWdGRVZzk1S3lkSUpUMGhPOXB2LzZPdXZMZm0rRmQ4czRkM3FHbnpSVlkra2tJR1Y4MktZbTFnUGdLTzNMalZvWnh2cDZnVzB5c24vV05ON2YzUHNObEdmeGVyVVphVndKRkNidFVLaGtCbFI3RUxubnlPckpDNlBhSGJPaHQrMy9Qb1VDb0VhSFN1MDEydnBXd0tmRlZUNWhreDFJV1JaS2N2NnJsZWxycjRwUTkrdzJ4SDcrMFpDMWlGd1Uyb3E2ZUN3V2VhYnFERDBoMUVPeUtZQWhtN1FOVkZsTkkrdG1oOVZva1ZLRFQwVFNpUkNHWDBWcTJKazlWQXVGOUt6eHdkMVVidXRxZW9vNjZDS29tcUhxVTFER1MyVTJKNDB0TXhhL3RKTGN5RXRFOG9meUVQb2E5M2FlVGF1a0ovTmNoMFhGeXphNk1LZVNYWWorb0JycDlZNEtDZE84R3NOVGVOWjgvSUJsMHp0WXdYVzIwOHlZRSt6eXQ0ekpFbXZudWE2SXRmSzdGSXBwcXRNdUs1RGx1bVJIZ3JDMUhPOGZDR21kQitXWlRaeGdFK0R0YWM1ejI1cFJ6bEVjNUMxR2g5d3cvUTdvUDBUb3BEZElxenpDa2tRY1d4TUpBV2doWmJSOWkrNGp3ZkNFeXlsVnkxZzFUb2Q4UU5DZG9xeXVKT1FwS2lRMFZHaWlKZG9SQmIvR21nMDkzazBHSmxrNlRuUDg1UnJQd052T3AvZnREZWk0Z2EzWmczb2tMa05MOGthMkMyYlhJb2xCZVlDbnB3ZGhLTW9aNnBubUUxSHpqcHp4cGtwVXZCTFp1amc0YjlqeHc2WjBqS1ZLa3JFbHNCRFpTOGtyRk85d29OdUh6VDZWMS81Q2hwV0x6YXlSVFdzdnZJVmFrUk5XdUhFeFdxWXZ0RWQ2OTN0TzhHc2JYaFFKSHVidDBGN2J1dHkvS09FYmdOM210ZTRtUVp1NTZKWDhhdTNCcmJ0VHY4K3JpZjV4VjYrTFVSdnpKZVpGdDhtSTk0M0JWSmNhUHJpb1lHaitRZjIwRkF0bi8vT09XRU1qZnJkQ2ROc2JPQ0l0ZmcyN3RuNm1DU05IWUUvZmhjc3U1ZHBsdTMyTGZTdzFHNnhEWDRpbEZ2VkxpY0g2dVFYQUNCMjFlNTdGREd4VlRURThqN2NnMzVaaXZ2OXZ2L0FyZFJRMTFpblBzZnZkUjQ3SmlzWDY2WStkYThpN3p2bDl2UDRyUlNxS25TTlJXeTNaYnpuMnkyVDlnL0tucnN1Qjkwd1RON0lJRmp2d3NjYlhDOThBNE1pSFJ5QXY5YVhDcjE5Y0U1c2ptTjdyMWNiTUp1bmNYM2dsNmtOR21KZGw2ZFJ2MnhGQ0FzSndDcFhDdGVqdGMxbWRiNHhoN1kwOGNnWVRTQ1JROVZtUHp4bzc1RGRXOCt2clZmcHJNcE9mL0s5QmxqVDVuQ1B3ZTl0aW04VTVubnpEMlZSeFZPREkvSGtYWWFxRzNMMkk0RTZpRU1tSUZCSmtwSXBVWlpFNnNTSHJGUllqaWlSSVRzNmxiREtXWk9vMWxXc1E2NFdWVDBjajRVMHVSVWFyVFZyYVRVc1IyOGpWQXRGcGZTNXJycC9KajVLa3FGRXlEU29FVW5FY29zRkU5WnlSUmtxS2xGSk4vNFBjMjhDSjhkUjNnMTM5VlY5VFUvUFRNLzBYRHM3eDg2eDkrek96czZ1enRHOWxteHBaY3UyTUxLOXZrRFl4aXdHR3hPTXN5YU9FWmpFSWlRdmhnQmVBaVRpRFFUaEpHQU13V3VISkNZdlg2S1FCSnhBUU1tUEVFTklZdDZRRDNPTjNucXF1bnVPblpWa2gvZjdmZEpzZFhWMWRYZDFkWFhWYy80Zkt5b0h2MGJmM0F0SVJqekNBa0w5eHRGNTNzL0ZoSkhyODg0MmJSQTBydDhMM0NoSVhIdit3cHpGNVFHdnVPRjZaRGZPTS9MSlN5NFhldWpDcHdObU1KRDY2L1hqdlY1eEtncVdCdUdtaDNPVlQ0WlNvYTIvdlg2cy8yWTlwUEh6VU9rWkNZLzEvUlkzN3NNKzJJZnJ3OVQxNlVOMG9hQjAvVHJ6SW9MUUNWM3o3MnhuMi92T0k1MWdIUjFnSnpHdnpWMGR1bVRhdU1HazFwQTBRQ25GMnRuVm9RK0N1S3hSY211WldxbUJUYTVudmQwUFV0QSs2MjJOaFlpQkJwRnVKZk93M2JITCtJS1lRN1hOa0NjZk1UWC9uWm50dndUUHgyV01TZ2lMSlJFalhTZDh0aEFqZTBXeVYrU3huQkN4emFPSWltUnBnRkRaaEM2U2d2aTJmZ3Z5SGFwOFNwUWtjV0xVMEZUOTVaQTlKYXVTZEgxS3ZiUUVlNjhMQ25vb3MwZVVIbVFMTk4veHJNbCtUOXEvd2F2OWJoNTMxM3pzNjQ4YjNEN3VhdTZWM0J1NHQzTHZCZzlGL3gzbU9wWUYxK3JHWHhaeUhRdEVYNStxQytGWDljWnJ2eURlMVhNSy9leGJiQnBuZ1pPWmhLRHBsN1R1NkNkQzZCQW05QlV4ZEI2bitQTTJTLzE0NUIwbGxINW9CN3Z0RnlIOHVmTWVKZDJ1YnREM3Y4TjkrdjgvL1g5Qmp2ci95dnV4T3VQbGVNbnkvd2N2alNKMkw3aytZRzd1aFF1OFNFUnRGQkcxVWFTNlhqSlhSMmtZTTRyZFYwTFB3V2VIUDZNdEdzblBZQk90a1Nudk0zOWhLSE5LZ016dW55RXpIdGhHdEZ3YjdUbnd0cUVZd0FVWERvaWFWR2VZbkFXNGd5aHp2dkZrYnVWNkxTcDdRZFBhbG82UG5kSTJTY1pBTWFQaFFqd2NFSlZ3UkFnRVRUdVFEUTRPMDNEZ3c0TVZwSitTRmFYMXJBdng4dHRwUG9qQ3VhaFRDS3RwTzY5R3NLSm16WURJcDVSNjdvZndLbC9JelNncEZPVFRoSlIvdmFSTWV2Z3VpUE5pdEkrQjNYU0p0cG55TTh6emdxcGxjSGZrZHZiL1dTc21seVFwcEEzRUZMTlVMNUxPY1lLaG1hUEhqODRFQTRsZ3RtQkUwU2tqd0d1ekkvbDBLQjB6SXRGVXNaUzZVZzhnSlo0dERjOGNuU0cvc1ZKbUlKVEpodE05L29FQlFwOXY1cmdFczJZRnRPWmNpUGtJOWdhTDdhWis2OFZDeVAyaTBqWjQrYTBnaURLeUFiVzdTUDBBbWVZRXJhVmJ4OURhTS8ySVhlR0ZWcE5wTGpqMi9idHlXdUFoZGxHVXBhUGNEV1FlZUxWbnllTVpsNE9WQ281NjBsc0szVVd0ejdHcktBQlRGU2s2MjZoRHZ6dGtYWXRDWVRrNjY5UkxZQVFFNFc3S21CNHZ5cGhVaERBSmRjaVZvekZTaXY0Nm1ERTNiNDhuZyttNFlZZTJ6YkJvWm9GOG5KeU1wRnpCTzFKdGZYa3laWnBxN0Mvc1FrU3owOWE3S3JsU3ljc1h5dmtLV2k0WHdoRWpKbVJIaW5lVUNrUG96VGdjL3MrUU9pd0xtaUpJem5WMEJYcUxFamZqT1lReTBZQnV5S0pLamd6dERZbjdrQ2dvUVZISHV3V1prQ0Y3QmJ4YmY1ZG95THQ1cklwSERIRkJDRDRTa2hjRUxLcm9vYjIydkNEKzZtNWQyaWY3T0ZwUFVSeXRkcDh4UEJZS2xPU2JpM2IwR1FQbnhqSzZMbVFiOFhRd0dTL2tKSVFHWS9GOFFLZDlNTFBOTzdKOXM1a0o3a0hYU29LaWlyS2hCNklaaEhMa01aUVdCUTY3emlGSE5FRWVWa1AvR1E3akxQbW1mMHJXNnkrUU5nMVFTNHh5bitncDhHRlQ5TEJpZ3hteWt1Nyt3N3ZvckhtR1RwMTNtVW81aGFaVFphWDFaMVc1S1ZmSFAvZHUyakNhdlB0enpreStVTHYxb0tLdHJtcktRVW9qbk9OM1UxekFRVUMycGRZZkpTQnVtRTBucGMzTGRDRnBiRVA4MWt1VVRLaTFiSm9ZTXVna21adVBvSVcwdmRva1EzbFBZT3g5OXdaRGNRT1NPVExFeWVCdGZmZnVXSkx6WTFXdEVGb0VvcUlXdXUxWTBabTE1cW9QVjRLYVRROE1rQ1MrUGNjSHVYR1E0VFFLalpwVDZOVWp1TGJjV09nNUVwbHRrQ0ZaZUNTZWVudlNBVDc1QkNTcHR5Q1Z6TmdxZWt2S0s1dVhCRjRldmlsNytIRGJGUWJkQmRLRjFrTWRKVmFJL0x1WHpoblBvT2ZSWjZnZDVBREY4SVNSVXlZTUhuaU1rbytKL0J5S2JGWUdmN0hpT3BCcDNDKzNUckRXNkpORC95VGFabTMyL2Noc1RRZ3NGOUNlM2ZYNlVrV25LYXJ4c3FEemZKcFFrN29nOHdNeGxoSFN6Z0RQR3p3bVI0VE9Ha0o2ZlEzMFFNQVdUZlQrK2t6ckhpLzMwYi9UOXMxdDJVL1RLWUZjQVBNRGFaSVlQRC9nZUplTWRWLzdmRFU0VGpyM2szTm55TGg0a2xxbWcrZm9IdkRoTFVQSVFvcU1aQXJ3NVlFMU9yRE40RE5FSnJKQjVINkovdkxWb0poTGcvUWtDRHhWUTJmdnRkNkdGV1Jjdm1ucnp2bzFtNE9tT1NncDlhc2l3OEdZZ0RSaFZNUDFvZkdncWtSYWY4eDhxNDdxc21YWjV2dUg3VUgxbG1YNTdwVkx3MGlYdDkvZ3hEVzgrWnBicDZ0bGVWeVZnK0JQSjAwTzFTUkoxL1RsUUtUQy9LZ3FTVFBGQ3dzbkpTRWF5bWRkakFqbU93R3g3bmNDNWlaWkkzcE4wY2x5UERPSlBEOEVkK3dDVXBnSDBkYnhoUFdhTStCRHd2TExpKzZvQkplS3IwcmdxbnZTVHBPUGJtNXhEZ0FoUWtHcUFLdWswKzlZdW5zL3k3a3VGSzBsZHpTL0syQjhPbUNsN2VXMGZRYjhUdUV2V2d5OGdZbXZ6aXd0ZlR4eXh2Tkk0Tnk1QXZTVEpyWC9Cb2dwOGlRVWNtYW1YT2plUmYrMVJ0V1I2bE82Y1k1bHRUWGQrTHZWdHU1elZjdG9QYnZVQnJydDk1RGhwcm05M0ZXOThmczhBMk5IZGpPTlBKNWlZcno2RlBNNW9aaUw2OG9jS25iSkFHd2NHVlRiVUZmUXY5ZFhvQU1xSDBSc3U5dlFWVjBQNlRKMHdCOTA3bng4NE1nVkdVa05TODcyN1k0VVZqdU0rNFEwbkFvOUJodGJKcWVRRXczYSsxMDdmenVlelk0clFWNHBKQklGaFE5NnZLbjM3T01lOG1iYjluQUtseHRrZG5ISVJzWU5zcG15SGZDWGprMDN5b1RSbjRYRHVQT0pxc250b1h4NW0zbmdnTG10WExDMkowdktsY1ZNcHBuSkZLOVVTaTlrRGg3TWREUjlWMnpURVdFMk1qZ3lNaGlaRlk1c2l1MmN5ZXVYaFRVdGZKbWVueEdQemMwZDQ2Z3Zsb3QzR09YbTJhZ21GQ3gxVGdINHlScURtaVMwbTNSaCtXRFVXUTgxZUxhMVJsRVBSM09iWThkaW0zTjBwL1ZmV0pxaDVETUxMKzlsSDJlamVndmJvQ1VLZzVod25BVE4vRUZ2ZFpxOW5ZM25SWGRZSTljM0JuQXJPUmFWdDd6T0VOWEI1VjY3MUliVEdZZmhSMkFJSkwxV1lzamViMmFHUVZMbHNLeW0xTmVwNmdUYnlJY3JNaHlLS1BmaUg4VXdQWUZhSE4yclJHQWp3d21rWW9xY1FEZmtCTGZHbXdGWmxPSG5OUDFZZ0NIT2dlOFFPV1E1ZFhLTlFnMUQyTDJZUElseWdwd25ZNktHNVJMNjlqVzM3S251YVgxMzc4cWhQYmZjOGlZa29YMG8vallrb2wxdnV1VnJaRzl0RmY1bGY4b0xoS2Q0bXVkMy92UWNMekE3Y1pSRmkyUjlpM2JvdXh1ZGprZ25tUUZtcnJ5elhONTVFQkprTVR2TnBydFBFbysrUm1UOUh1WHEzSGJROWhGZWhjR2lzZ0R1NVB0ME9tVi9qQ3p3dkhoWThIWmJMcFNCRHFOKzdrN05JMjdSY3pzU2M1Vk1uQkJzWXdPVnVjUU9TZ1V4b2huSW9yKzNIQ3NFemlacklaSmJJTG10UzI2RTlGU3hNaGMwVXVua1hLV1lvZ0FrTktMN01zMW1pNVlPTVdSMHEwZzJLNCs3ZGt5STJzc0sxRStCY3gxeUJtbFlGMDlZVHdXYTZDZUtvcmV5dXFMODlUSERZdUVmTGVNWStnaTJiZnczMzdFTUdJMkc5UjFLMHpPc2FabXpLRjVEbnF1UWIzOGU0dU9nV3N6R0JYQ0NqVGsxU29QWHlQSVd3d1daN09JQ0lUTktaQ3JZQnBRQitWK1FxWHVCN2RRb2Noa2hPdER0RHlqS0E4cG5WU3VTNUpNUlM4M2VGNzl4MjRqK2lLSThvbnlXNWo5dmpXeTdNZjRCdjhaSDRRUkZvcVdJRzl3NTJGd2FLNDZtMDZQRnNiWDVSWDNMUGMxbWN3a3lSNDl1MFJmbjE3eURXYWphek5KQ0h5TUpmWkQwazhNTkVScDdHOHdValJwOWFYS0g0V2lKR2gzYU1pNzQ4eHhiOTJJVVhzM3hjelhxZjliZVdUcExvZXpwdDAxenFGa2YrNGZ4K3R6MWQxNC85d2RteE5BazNRbUkxaFl2bzV1UlprYytDMk9DTWZvazl3K05hOVBwYTVjQkVlNldpS21IaElDamlab3g2ZWZzeTlwWjMrK1g0cmVBdmJiQXFHWi95SFlIQVpwMUpCZTRsTC92SzhwZ3VQVlh5ZEk5d09EZHc5S0pESHJ3ZmlFZ203S0lmcXUxMDdKTFNVVVNzb0pVcFdrcVU1SXVRZVFnSVpvQ3pDL3paeVQ1SmZUTGhFdUFHTUNTRENpVUdkS3AySlcrMUJ1a040SDdCMWpSUnBFMElJTmtxVEJGS21LWG55N3pyMmw5TDVYNm9zWXJpb290VWF5S29rVjl5dlV4TW14MVpLZFN5Q2E1MXIraW9hRjNCMmFQM1g1c052Q2pLeFZsbTVrUXpYQlFmQlBJSE44a0JrbDJJQklRYkZzZ0I2OGsyemRvMnVTUlVDWkVma2M2Y2VQQUJySFczLzZ4SzhSUmo1ZmVlbHZJWlVLNnJMUnBjamZiWllpNFc4V0xpejZ1bDU5MS9WK09rL1hyQUkzczJTVjQ3aGU1czM4MHoyN1Q1em8xcmlEeldIdU5pSzVqVU1qem5kTGtPMlZOazZOUlNGbjJGenJ5UGNYb2ppSVdkMHRpVEF4SWtXa28vcC93R05QcS9pUnNTZklsbXRKa1lhR2Q3eWpldDA5RlFYR25GQkFkU1F4L0FCem1vZE5rN1huWHg1Y21kNkJYY0ZYdVhqS1dPcDZOSWIwM2dJVmhjN1ZKM1dnYjJ4QUQvNllpRytubjJZSC9lQzgwN2dudzNROGFNYk9oQm1OV0lrSytqTFFrQ0tIWjNNVFdBV3NrcHBxRVluOVJIYmxFSDF1UkE4cGdNbVliSlRWb2hzSXBpUmZEcEdkVGcvWHhjamFTQ2lwRzdrWDFxOXQzdDVPeE5NbTlpZlRkREEwZFIwaUg3ZDF3ZmJZYmx4NXNkQ2FvZnpHSUVtWi9ubDNIRDRXRGNVc1RWUkZ2ZmJrN1VzVHQrWkZtTFYyM0pTUVEvazFLRDBTVHJRZGVYTTg5WU91cUdsR1ZmZTdBaWN2aWZuV3FNTDQ5RWhFTmFVRG1KU2M2OHVKNnJkTVcyS2IralgzOXlpbkIxU0Vwbm1WbUF4QWlubUlZTFhkajVuMUpTYWpYaHB3UHdJUjZsV0h6ZkNTNE9wSzlDdDBWQzcvYlFLdTl2dVFWUmRsdlVxVjQwRENkNU40bDg0MXF4cHZYei9MZ0UxWWlpMWl0UGdOTzRoNWVNM055TUR1Y3hxbXBBMXBaQzM1SWpobXR4elF6NTN4YjA0U1lhS24zcG9xbTlpN1RXTmF6cjA4N1NOQU1VN09jbktYV1ZMMllJcVFKM2djK0ZrQlBVTHVBS2tYclpoTmh2eTBaT2laZFJLQXpYS2M4OUo1UVhJbm5ITzh2cStaU2t2Wm1ITlgvMUVvSktjbEJ6WGpvNnRPaGVOejY1RmNoZmZZVGtINXZqRXdvT2ZOam1oYTFYaHQxL29jVkorMzRxWXNUQ0ZnREVJcWt0eG51L2ZINlJqd1NjaFFuN3lpRW5qYjNLRU5GQ3g4WUpBUk9VdzdyejVzeElZdWM1NXhRRnVMblptbndpak9QaGEzZ1VPVHpDWFVnc0t6cUlmT0VLQzJHSEJZM251S1hqektrSTZkT0RieGNkQjFmM1ViL3cxZFFKc1FBK1VYZElKZGQ3aVcrcy9xeGdHRU4yZ09SaEIyUTQrYkgxQUFTSkFIckFoNHFLS1ZRY01STUZwSzJxVUdzRUVqK2h2bXJSMzVEbGJDYUNLVU5wWndaREFRTk1FYzBiY09PVzVXeWJCcGFHQVZ1RHBNbDh2MmVZN2laOTV6WDRUbk9FWHIzZnU4NUloQmZrL2tRVWhRUWFLTUxpYy9hU21aVjhxT1VyZFR6aFRzZWxNejRTMjRSR25wSlhlREdESUhuR0tPV2grRG5QSXBpTXFhL1VVOXFTcEd2WjF4dFEyMmFBbU1ETmxhUFR0ZUhFZUM1VlBqbUFBcVREMEl1VjZ3NGVRUVRuc1VJQmdZelpjVkloeElxbHRUZkNLZGFTMjIvK3pScjFBdWhwRGtTREpXVXdoQVdkRXllQXdYVWo1bHhPV0FuSWdQMm9HVUVrbUh2UWN6SHV2QUUyTmh5bnlVQzNUd2JjK2lQU3M3cGY2Ym5aUThHZHRaVXV6c2I2WDBwbm9YdGlaZlNITFQyMytnQXlvUC9qT3ArMWlqZVdwMmk4a1U5SGZVa1dBREhCbEdJeFltczFYdTJzSkhJbXRGdy84amNreFZpNWhuYldOR2tWRTdOd3BmYzhYZU9VNVNqOUhkbVNSSlBtQ0hydEptTFNJRXhaTU1YL1V3RjBrb2NVa2h1V0lKL2JkdmxOUzdMTlFHQjNvMVU2Y1pObTUyZ3hteTBYZTQwSXJINXhRdk81azQ3TmpVeWgzbTRGeFNCWHdwRXJpSExXa0JFUWtrUllrbGxQcm1xMzZaRldrdEtNaVlvSlFHUjFkMFVyeUhzR3lsZVRUNTJnNWJVYnRBMHRrRXJrY0N2M3k2VDB3MnhwaWN0VWJzc1A3b2loZ0lQQmtKL0g0ajh0aVphU2IwbWdnbU5mUHV2QTdQdzkvU1l1REthZitaR1ZiMlI4T2RzNDhiN0FQNTIzb3Q2c2VFazdqMVdqRDZYVHgrU0I2cnpYTG84b1BUOGhZTExscWs5cjVsS1ZVSGI3WUcwUFFoSmRoTFNLczJmd0ZYWTdJeVdBamNGb3hpR2l4QUp2ejdzOHluZkpHMzdNTXpyRFVKdzEra3N3K2dOdWlXZkw0Mnd4emdVR09YdXd2dnN4VXpheWdYbmZxYnZmSkx3ekg4TTFEKzlUNzNNQm1uTjI1SlNRTFQzdGpJbG10enhQSUYwUFdkc0xZdmhiRm9zYUZXNm5RbFd4WUZzU0J6VEI4VjBOaXdPQ1dKU1NsaC9GekYvMlVDL1pDQjlmdkYzcmJRU3R0N3psM1R6ajA5YklXWEErcjM3cmJDU3R0Nmo2eU5tNEdYQlNPQStQY2N3Si9qN3FRNGtUdU9ESCtCZTZ5R090RWw0N0FtcGloc2RLRHZSd3V3a1NEOUwxRDJIUlM5a3F4WUQ1eS9ERnRZc0lBYkpJS2ZHbXlCS3lvQ2ovVUx2ek0xWGUwdnVISW1nNEdHZWwrUXQ0ZG1RWWV6U0JrSVQ0WnlxODRhaXF4YVB6SUJwU1lWSU1CRXRtZGR0aldhS3lValR5b3lNQkt0bzBkVVJrZVJiYkRMNTFycVNIMVovM3duZHhHTmVGSm8yaXBwRDVtV0dHZndibzZBcEFvOTRKWVlWRklySXdaQzU5SGd0R3RrZnJnNFplbWpheHdiNUlPbTdRK1NWVTJyTnRmU000b0tiQzFKWkQ4WDd3cjdEaEF2L1ZXL1UzTngyYXB2QXJrQnk1T3dhK2d3bTlRNEVTVElzWXV0RzBLaFVKQmtGRjBVTXJ1OEhuRU1pcVhIaE9vL2Q1TnlFdElxa1hpNnBzbmdWUzJXUkZLelF0RS94Z3l1Y2h6WGVwR05rZ0hsajlPS2ZsS2ZCVGhwb3hTQ2FyZmt3K1lVMk9qN2hZWDNrM0tvVnZBRm94aDhZTWZtR29JVk9NNWpGVjdQTlNZcmREOGtXK1oyYXJtdnZsSmU2Y0oyWlgvSHpoS2NHQ1d3MzVuZGh2ZDR3dEo0ZHJhMW5VVUdEalo1M3NheEtYeXI1dUZiRm9wL3RMVWJMUGh2ZXdaSzNPdkRrT3N0UlUvV3cvQ0dHd1J4RE5tTHpJU01xdlhianVvY0oyUW5TTk8xR3VLY3hBUGZldFVkVFRIN0hlQnpHY053WnRxZ1ZnRFhzc0lMeEhieXBhSHZ1UXF0Nzd0cGJWUzBSajI4M3RkT2FHYlo0WmdYQVcyRmFzSDBjRTRxOVNpN296WmxmNWFmUVI4RnFDbUtmWTRiNkFCaHU3dXBEV1dMMGFLR2NTaVpUNWNMdXkvTGgwR2R4R0g4MmFtVXZRNmZpVmlKaHhRL3NuSmhLQnY5UWx2L1FqaytPN3p6QVpEYy9KV3VGaUQ3Q0JTaWx6WkE4QzlSTXJ3RGlHako0V0dwQ2ZJKzJRWEp0R3lxaDVwUmtpL09aNno0bEJlVlB2Zm9CSWJGN1R5S2RUdXpablJEaVlUUDZpaUV4S20yYUVtMHA5WWFvR2Y3U1RhcjZpd3RQeVBJVFh4RVNrVWhpWUFCU0liNWpWL0lxVFgwTFdiMGF5VjA3MlBQK0pYbmVUOUo0RXF5NzJVcnIwL2t6WmZRRWpnWE9CbUx5TXBaZks3UHNhMlVaUGFJSEF2cWFuaVIvYnNiSHJ2b01lY0x0WHJTR1R0YVhCY0hKeTdqRFczeVFnbXpRUU00VU1jVWR2RTVzRmxRYXUwWVhjK1FiMXVVSW5tNnkwSkZET3hJMXJPanZ4S3FOcC9OSHAwaWxQOVJrWGhtbWl1NGRDbzFIUEpERVVYSVdraW8wSUdVeVhzTzJpdCtwSzNnNk43VHJ0YjltS0xiTW5GOU8xR1FYNDhpbGVRMHV4WEdoenBqSUE2N2tleXNva2NxbFBYZTk0NjQ5N2FUeHlodHZmQ1hLSnNlU3liRVpTT2J1b1Bua0haV2dhWUtDUjNKeEo1L21WREt5aHJnSm9CZnFWTW9GYkMvWUhXQ0JNZm16amNoc0NUZTg2UE9JT2xBeHlGeW1EaVVucUxoYUpWL1VQMitTRGVGM0pHM2x2dkNnOHJlQytKUDZac0dRTjhtaWdMNE9GZFJ2ejRxRU9VamR0Nkl0cmdER0hEcVFGa1M1OVppNkdySFFSK1hBRjIrN20xUk9Dd0c1OVRlclZKMm8zYVlrOWZDcWh3RjNsc2JkeUhVaUdIVE1MdDYrNndmU2FLTWVVb0tOeFdCeUQxSU1LL1NjcWIzZXQ1aDZ2V2FLbnhNVjhuZmtDRFdUZXBtWkQ3UUVKQUNZN0wrU0EvOEtpTE1DZXV2RDRDQytES2NzZ3l2NHc3TDRYa0Y0cjlqWTh4Q1VYYkpmMS8rS25ERW9DazhKNUVjeTFLWmRjYkZGbjZMSTN5emU1cHU1WCtIZUR6cUlUcnZqOCtHOHYxZ2J0OFpGNkw0dUZMZVR6eElDZFMwUVdRbEVWTXlUcVRQU2VsMC9LN2JWZm9XV3lDZHBPRXNhQU43UG51eHJCcmZFc0xnaUFZRFZVekZhRGtSYUh6dXZPMlM3N0MyOXQ2RFoxdE45cW5weUg3QmZNcGkwb3pNV2dOOWI2MHlCYTNYUFZCQm1mUGVERzZGbVVrczA3Y2lpdGZZSDJUb0JoNDRlaGZUNWR0YjFkNlV5bHdHS0tNbHNLUjhpSDJpVW1VZUcxcjB0c2pMR2VpMUxjQytLSkQxT1dsdHE5TmJzY1hRdDF6cnQyMzN4Y0pjTkFGcHJOYWtSNGxGcXdYeVUyaWErdzM5ekgvZHpyeVpKRTIvMjk5L1lmclZhdjBFZ2pvRjlJd0Q1VU9qY0JWTnJQWUpSdVgxV3M4dXo5c2dSQ1hkNDNScisrL3hCbnhkdjgxNzgxRFUvRGgzbmRvSW5SS3ZSaUlEUmJsemNBbzBDQ1BGODZqVXkyU0lHcFVmdDFIZlg2N3M5NjJTMmR5cGRUWjlKVjlGSzI2NXAxMjNoOEcyN2V2WXZLKzhxbFhhVmZYdDBhTThrU0J6UmhadFNaenRDQWNKZE5nb2wwaXgwZktNR2tlMlZUd1NtdDB3SG50RFBBRURMUmkxaSs2MlZvYkd4cjJmeStaNittbnB4TFdOTDAzbGJ0WjkwMDF3MWZSRk5hcEtPS3UveTdESlplMTdFbXp2L0M3dmdtM0o1UkFSencyV01uaTIwNlM1NnUxa1ErWFhvaUwxeVFBcWdwbm1zTlhLNVN3czNBeFF0aDZWQ3RKQkk1S05ETUhBSG8xbTZIYUl3SWhzZFFmQ3RTVW9pb1Voc21sU01BV1pRdkZ5bG00Mk9lZjVuS3k3T2VRWHdOdGNoT3ZWRW1mRFJERHVXbHUxZ285S0FtTnRvc1IwWk4vMHRMQjJIUnBLa3lmVHZINlFNbkcwTk9abHNhc2l5cWJMTUQvNDE1cnNYMzg1MDg4OUJ6MGVzcEtpR0VJcW9ZdEx5Y2UrYmRFNWt1UGNkTHNaZGt5SEQ0UFpEYzNyVFZvM25WdFpvUE9pbDZjSlZoZWtsa3YweGE5OGdSWHBjUVN0TFM2VmtheTFaMGd2VDB3VzlsRVROWkttMTVnS1hMc0VxdEFScmR0dkhBR0kvZXBpL3IxN2ZpMEsvemlwN1lkSmZyS2RBbzV1ZGkzWkZVUHVXanQrSDlhQ1JDc2ZpZHNvSXZxOHdYU0EvZEt3ZERLUmZrc1ZTaXk2QjZCUVluSGZGYVA0bnJPdllOR3dCQnhBS1lzRTJiazdBTlF1SC9EYzIxeWQzMU0rNU5rTitYOFVCcldRWXRUV3I0SVNKZklqSVhMM3RiOXdkSGU0ZFRpNDNrY3Z0UXl0SEJVMDRNVWVTQlhlMDBRYWpCVGc4a1d1OXNIeFVnT1BDZ284cFJHbEQ4TEVmb1JZMDBWNjN6MktvRzIvSHg4ckViZDRtbWtObnlaMVc0SDdXWkE2ZDluWVFTVnRyekZSbkNacFZPVUdTbzYzVkxNTnI1T3owbWR6a0lxTG9EaFRqNFZ2TUZ1akRwSTJrcm5CMDJjY3hCcnVaR05oMjk4ZStyU0dYMkI1RUJWd29GNWdSRUJOUytyTmQrU2U3c2JZbm9LbjN5Q0hwVGxVTGJOTXcybks5b0l0cFFyR09IY3N1WjQrTmd2KzFMbHluTXo1ZlIyc2FmamhCenBEdjBlSVBZNjMxOGJ0RkpBNElxdGhvTmh1Q0ttVEk3dDJCMFBYd0ROZUhBcDM2c1lJcjIvVUc1bllxcWdOajBScmdLbENiUjBwWVUxUGhkYkdZUFltRGZoMXRvVEJLR3poR21nb3R2Rjc3empieUtIZEtJZmtlOGloN05MeGIwUTU1ellCR1pranJvSkdpS2d5STB0MkJxWWZqR2p5SG1pRFBvYm04MGc0eTlxTE1IdENUZm5SMldiSG0wUDdrNTI3MXhCMjNLcXhyV2pmKzlNbzNrUmE5NlV1UGdvampVU040UDl6OC91REtTclBwOGt0ZlEwOFJYdG1MZ1hUQVF4R2M5bUVyblZ6M0lpWDA3RGQ2OXVHbHdoYVlXa0xzcm5yMmtLZmJpTnpxZTlyRjZ1OTBsRThzZ2ZuT2tvUnVyMEFaSkc5akcwak9jZTM4U2p2N21pVkZJWHl4b2l5SlpxY3RsTWVQY0FqVG1OVWRLTVgrS3JGTy8zditmZlMxaHhMR1E2N0hHL2pySmE3d3ljSmY3cE5ENmFPN1RWTTUrb1UyUmpHeVRQTmI1L2ViY1hXazdCbk8wL3IxcmRuZ2ZtM2JSdzkzY2FhSE84Qjlsc2RlbFhtTmNnZ2Q5b3dzaVBJbDdveHBVTXExU1NuWVRwRHNPMWdjNVJZY2pWUGlOdzdabThuMDJvbkxHSWZaYmQwcWZySE42b1JwL01KNTJ0VUYxM2pWeGkzejhHaEFCNVFCWDRGR2JkMWRPd2RJeEZzRWJOdFdERU5aVmd5NmZZUWtSeGdDYi95a29WU2g3Ry9jTFVuUUtRLzJsMzZMVEovamNDbXExenhBb3hLNlFXL1l1Ni9WYzlHYUd4R2szTU1kQ1gwaUVIYnU4eUJIYkhFTUg1L25tbXFqUlI3eWpBK3cveU0vOXp0K0RxMnArQ1JsV2x0V05ndXhOVnBMYTB0dEVIMzRJdHNJL1Q2MFBwT2RqcER4V3dCdmdvZ1A4K3BKcEFWZk5zMk8vRC81YmNPU2lqQlNsVlZab2R2OHRvcGI4aWpaeXJ5V1JVMHNaN0ZCazlaYU8rOTk4eEFqS1VyV3lYR0lYNEJBblQzaHhrVUh1V0lXSklwc1NXUXlzWEpIWHFMQjA3Mitrdk9kSWhheUJqaXhkZ3dKc0pPSW9SSXZCalE5YmppbUlaeWRheUtyT2ZjdlZWNFZxcnhJR0dYeEF4MTVOQitZd1lvZ0VOWnRjT2NnM1FabkRCNUxNNGNKUHljSTFhc3paR0JlenlNNW50QmtOUndLNjM5d1RYVjJ0bnJOSnoreUtJcUxvcUtJN25iVFdGSVVFc0FLRmpBdXdEYUJrMk9Takd3aFJSbEVRK2RscmxNT1FDTVNJaGJORlhzeWsyaUhTTWtMdmxyd1RMNTVidkp3TldURnNWNmtzY0RBemZlMzFNbkRTNGNuVHpNNkFWblZ3NU5DU3FtNEFjTU9hdmkzVW1sU05ubVkwUVpjb0VPVzN4MWI3Mkh1VWU0VDNKUGNYL2FobzNyczB4ci96WDNwNTN4KzhRTDF1NlAySFd0UDUwc3ZJdHM2L1JJckF4UWs5Vzk5cnF0S0Y1RnBuRy9SNlp1OC9PZFNqNU5jL2Q4U3AzSlphbjE3SjhUYjhONC9wdjFINkFacWZ1U3JxTXJnVmtTWVR3bGdKZWtRS2ZlSmh3YzhyQ3ZFQmJBSFpqekRXRll2bnRDc0Y0NEVWVnVVTjBQeE53b3FxY3pQQzJwV0ZlWjVMRHNpbVdxMlpFUlJMK21DaEo1dFBZZEF4ekZCRmdXTExBM3dLSGVxVVExREJHbUpGMVRETUVXZVYzaE5Db2RDWVVraldWNDBqYXl1azZwWkJpeitRMVdUUDZvb0g1VTFTY3plSHJKS0pTUDZ0MTdFejI5WmNFMkxYajRhMDNTUkZ4UkJFd01CVmVVMTBSUUZRVGROWFJCSWxseGNLeFJvVFkrUHZKL2FxRWNvL2xFb0Z5cjJySnVSUWo3cUdsck0rTWdjTHAzR2M2MFZzbDYydVpQRmY1ZjVzTkUwd3J6ODd6QmllREppQ0NzRmthdWJYZnpVa21RRWcyUVZsWWFnYUVqQ3Z1MHA5ZTJjNHdqVFVxVCtrWk5VcVNNelowa3ZkRmZaTTNoMC8zdXc4dzYxZFN5QzVnSUNQNWVZYnkxNmFNKytZam1kc2lWWlZIWEN5WVVOTFlBakFWRWhYU1BNVE80UFp5S1ZUWW5Sa0VZT0RocWFMSTVPdEg2Nyt1WXJaWTFYOGJGZnFZdThIa2psTmNYUUZDa1F3UUZUVDVwS1VBUE9UdFdEb1lXNVdsd1dFT0lGT2FRYW9weXdzNG53VmJ2MkRlN2VKQ00xb0NHODg0QVVVSGhQcC9RNVhrUmZJSHo3YnFyQkljK1doNmp5TkZJWitOVkdvZFU4ZVN6eVFLNU5KM2hUMWNHcVRqSjVhdllDcHAwOFFCdks2RHVoRVNzUUMyVEhFMk9saWF2c0VCazhQRkpVTmQrL3VQWGpnV1lWODZva3ltU1lOdmJud2JZSWZUU2txZ29pVmZpUWZkVkVhU3d4bmlVbld5UDUvc1Z6dU5vY2tEQ3Y0L3orQmxsYUF6cm4ydHMvaVlBWFNubmFNbXEyRUNya2ZUQUdFTTdhYU5OeHhWYU95NmJXUENJSmM3S3NFQ3F6cVpsenk0cXlqQ01tc3NRNUtVZ0c5K05teExQalJ6ZVE2K2JhMTJYTVZOZWxYYXhvOUxJVDJNWW53TDhqaXVmYU41Z2p1ekc4K0RhTTMwYU94N0N5QlJYZCszeG9pd0xlSUwzUDRHRjBNS1dzTjUvVVFmVTZzOUV6b0FYM0lWclBzNHVqQlhnSWR0MGJ5TGVXYTErWGFWbTZMdTFpZ0p6L0dWQzE0eUZhWDNQdmM2MzNFSjErV1dIeUhEa2E3YkVuTGcyWjZ4b3gzeHBDSUZOWWVWWWdVeDB1U1dXQUwrMGt6MjlyaHRMYmsrOWwrSU9udHFkRFRkdW1SU2hKZHpwcDlIdG95WThaL2lBeWFiWFd0enZPOFhBOWxxbS9RUjJpU2dQWGpIMVNncG1vd1NzdGU5WmQ1Vkk3b0o5bisxVW9Rd1F2cXJSM2cvNGhTMlVCYXJGS0JUb1BLd2F2QjFVcnF1aVU2TkNWcUtVR3dmcmk0Y2tjRUpnUXp0RlU3YlJpQ0NwTTVxcGdLQUJBVjFadzJqSHRwSldzVUZxa1dpRloyM1RTV0RtVEE3ZDRjaUk1bjMzUFB6NzNCQytqUHlWcjBlV2tqek5NSFR6QlU3QlhtSkdvZHBnQnUweWdlb25wVlJ1KzJ0aGRYTW96SmRkbGxCcFZVZE5EcUZwQyt3WnNlMkQzd01HRG04bTJoQ01JcVFJT1JOSElsdWl1YUZReWtCRVRkVWwvZCtiZ1FWS04xTkhJbmhnajVWS1UxTmd5Z3FJQnN0WWdGTUVsY2hoaHIrSm1zaTFoUlVzbFNiZEZONDlDNWFpa0tHRWpLaUpCZWNDN2IwWlZCQ1JHamJDaVNGRzQ2ZWptS09uaVpFcFR5QlVQSG1RMlZlaCtNbS92cGxIZFpmYVdDdlVHQ3gxS09NNTJ6bHQxM1NpajIxRzBuWE9wSWJLNnZyNHE0YmhUTG82L1ZaUlUrWDZXVXNsYUE3SlRMTVhTNGkxdkV2RWFGcXREMlpEMWFBWmhjWmhNYXdNWlAxZURwWEdQNGU3cUdULzNsSVNYYjJickRuWnBmc1k3Z25Sc0U3ZWZ1NFl3VXJrTjVITjRYYWFYcEl0ZVlMOWJxUGMraG9jVzZ0cWdZRCtnakhhU2RabFV5b2FpNHd4NGJhbHJjeUlMZFNGNWVaOGNQTHRNNWlVV3R5UE43ZUx1NE83amZwWDdBS0E4RU40WWtPQ3BoVHg4ak1DbmtzYVRaNmhqNW1wUW53RzVQMkR3VWFkNzk5UDBhcFhxVG1NV1pQMHpucDA5SVhOeElVK0dBYjJhYTJqUDF2VklqK0NuVjFDMFRuQmtCSkVvcUlLc3FGRk1HT0NnWWV3eVVFQ3hGQURaVVJSRmxjMWttQlJqSzRES2hyRmJ3cUlrYXhnSExVa1JrU2pMaEprUEdNWW1RdzZaUVNNUXR5M0ZEZXplb3VLa0RmSm94cWhvQWx4QVVXelpPR0tRZTc4L0dsUjFTUllVVVpFeFZpS3FibHNCckFGb255NUx2NmFwc2hCU2VLeGdSVUk4S2ROSlBWdU1HR0hESk5lK3RDMThXdTJiNWRoOC9oL2tIYjNUamVQRHhpY1g4YVd6NjBaanJ5RHRRdjI1eE5peEttTzZiTGE1OUdJNlpJblZmWUJkWUpWdHZuZmhoNEpuZXA0ODA4a3V2bzZMWEVCaXVHNGdYQ0E2WU8vK1NtZnJyUTBlNm8xTnlHNlVvRXQ5Z2VKSCt6NGNtbW5YWHUyYnBYUUcwSUVTK2hPSTI0a2tzaEpRU1REWWtrd2c5TG5XVWt4TkprNFh4L1FuVmF1SVB2dWtQbFk4blVpcU1iUWFLUVY5M0M2SXo1dmdpdFE2cVFBQmJhbUJWcUdiU3NjdVJnc0V5bTBVV01CY2RESSt2UGZ5dmNOeFg5VDFQalpqWkUrT2JCazV1ekM4ZDVqOEZ0STJ4V1VteVNtd0xxMUNjczlDWm1Ra3cvbXlBZEJEVlR3cDRMcWJVNSs2NlU3ejJRa2tkRFFJblJyWk0zeldiNFZkSGRrOFNnR1hoL2QrMFlXU1hCdlpPN3l2M1pKOW1kR1JERlZYTHBJbXR1N3hHK2JpaExEMlhIeHJ6dE9DODkvYTFRZXpkNUE3M3h0d2I5dW4xKy9kb0x2OVBxYnlMKzQvYUh3VXJ1RkRFckF3QkRFM1JNSXB1akpPRU1MbktrSVVYa1dJb0ZjZ0NwVFkrcklKKzFCc1VyMHRTZGJRSkwyVy95VjFSUmVxUDdqK3pFZldYZDdGQ0VGUHNXc1YvY2k1UUljeHAydXdyRWFiV2wrbUNyV0o5c1dlVzM4eEtxTW16d2l4b3dESHZJUEs5bnk3WTdXajY4NUR5ZlZYZCtPZ05NbTFRTXVCL1E1YjV4UmV5aU41cDZrUnpud25qcENGUTNrcnVleGJGWktMZkhBSG90S28xck03TUE3aENORGhKOGdtaEwwK2ZBb3R3ZlViWmI4VCt3UkVlbXJEeTF5endZMDVyMS9YMlBVamp0K3h1THZ0Y0o5ek8xclBVaEZFcGZmNnFMVGhEYnI2Wnp2eU85dnB2amJjYTlNR0Yvbm1odmQxOVhlZjUzZWdwN2twR3FtTElmWDQ2anFnRUtaa0cvQ05nTXVJTlFReTR6RktkeElCcHp1RHk5dFFlY29ObGo1RjJPTXk5Vk9KMmpSOHdNdEdLblhaVmdLS0lJME9GNGJpR0ErOHJQSG1nTFZhcm53K2JQL1VPelN5TjQ2ZmlJUWxrOFlUQ0kvWWtYaXl1SzBJUVFXMEJWSkJrMnhsVTNRd042SW45ZWxMSW85RlF2OHNpU2dZVUZ1LzZSL2RNYXduWDVsS2JFblJNQU9hSUtkVmNva2FwWm04dU1rYVp4RzZxY3pOYzdlQWRKcDVGWlBweGFtVnlvU016OHVzZThrQUtVZlpVa1ErWEJvcGZiUXpscnByYzRSSFVLSFRnRmFtV1BIc0JRRjdRSU5xZjM2Q0FvZGt5NEZrTXBBQVBUd04zSmpsV1RrZ01xeVFQeHBtdlltbDNlbFJHWWxJSGswVEdtZ3lGOU9rK0dBcGRWK3FOQmlYdEZodWNtMHdwZy9HMUozcFJDS2RaZmJLdDZrOEZLSVZCdTZ3c2hVQ3VLc1NMZzRNRkxFMFdKZ09XY0pRUEZVc3B1SkRnaFdhTG5CdW4zaHhDU0xjR0xlSHU0NTdBOGM1SUxOeFFhY3hrdk1ScHpHSm9HTUdJVUlJUUY3TzFzdU4yVklCQmw3RFBTQ3pBNVBJT3hEays1ZExiRkIxSFpqa1MvbGJyc01ZM1VrR0xObTJmaFhiWDVpNlp1cWNrUlI1SVNKSm91T0lraFFSZURGcElPVUdKY3p6ZklBd09MeGw4WVR2Q1pEZHNJTEVwelk2Z0I3ZDZNajhkZVNXNUw0WXR1Uys2QVp5MzB4Y3hFSTRLWXE4WWZDaW1Bd0xXSXdMb2FBZ29VQkk0SkdpSUY0SUJaQWtCQVdoYitrL1dUeTVsUkhtQlVTb0Q0RVBrK3NnM3VLWkhvN3E5b0NHMmtlOUlMcDBqTDFNQ2FaWkdvK3hUUlRGY0R1S1IzMkd6bVlmZmtUQzBlRHhZQlNqcTlsV0lpVWZsbkFpdHNOSjBCMkVLa05iTjcxcDg1YWhNcG1CczRRVEMwYWp3VVVKRzE0R2t3TXo0Nmw0UERWTzhUekNTWFZoODJ3Mms4bk9ibDdRc25wYjVyZkdyYTJMMWVBVVdKeUc5UkN6ME1JbEZxdmhBSTNUWUVNOE9GTnJhcWFsbVdrdlNzTkpSVW5iSnloSUpvVjdQbUg3dURnTVp6TUdHRm9PODRuenBRc01saUhmOEJ6NVBwWWNuclljMTFiZHNhWjM0V1NBR2NyTWxqWXRKSWFtc3N3NFBUczFsRmhZMHA1bjlqRWU1b0I3bjQzdTB1ZmlmYS9LK2ZUZUZPMG5HdXV1RWFXQ3NIb3M1TnM4azh0alh5YkNZSFRXWXFJaHhySnQwSS9oa1F3WVZnN05TTEwwcm8vbkpDbjNjUm5WMmdnZ0p6SWo1TWpNRUtua3ltbStSMlZoUmJER2dLaUx1VDRXc2xUcTVyOGpRbU1Xb3I1L3ZZOGE5dHdVMWxxL0JtOWpsWkpYOTJsNFNtajlHODJ2cmk3U1hZSFVRWGVRT3Vqb0ZCUGx1QmlUVTRMVytxOTdJSC9QeVdvVmRnVzNndXN2K0hXeTVuelk1U1VvYWdFNDlRRHZEbUlZRENoeEllckhSV1hhRUZrYTltSFpnWDIraWVVVnc2SEpYNXcwWW9vTXliK3V5Tmd4SUVFbldxZXhMalJsTTRBV1dhYlJsTXdBS1RVRXlKQlNZMmRUMEhIcmRNQ1VJWU1XQTc2dUhPYkZOV3FyZFlqcFljbVVSYVZXUGx4aXc0c2pKWFQ2TFVHMU12WFBaQVN6akROOHJlY0VkT1NRSWt1aGFtSEVlOGV4cVpCQU9OMHZ1Z0gzZHJIakF6a3lrOUNpVEU2c2JDdVdvYUlsa29wb0xTaUZwbUx1RUNpUEZLcVdpS1ZERW02ZFphTjVCWTZIaFZ5RzRzZVF5d3h0em5kVlpIS3duNUJuTzR1dVpKanB4WEtwQ3llaUFPUGY1RE04aU9zN0xHcWp6TGlqTExtc3JJMitQaWNGNDB6aHBBNms5Kzl2Mkhaai8vNzBnSnFtaGZHZ05DZUtyWCtMMDZaOXNTSExTcHdoZzFReUtWcVZuSkRLVkZoWlhKRmxNRVhhNGRCSFllMDg5elZVUkU5eVZiRFhhWlE2Z1B0NjdITGFzdzhzeEJsK0cxL0NYalAvMzg0N05FUk43TitRQmRiTXJ3eW9TZHI2aEVtYUk4ekpab0x1Smp1ZThKZjhKcnA0UHZlaisxa2IzUkhUeG90ZVAzWThuS05ZOXlCQ3I2Y3ZQMlJTMkdjaEdPNFlKV0ZUVkNGRWhSa09TVUg4SFhlMHdMc21SOGdCbFJ6cEdCUzBVTkNnT25sU0dCMXIvbHpYYm04YVpxYU5SbmpmdGkxMk5PbHdiMHNPZHpSZzBWcDNYOG1YMndXNEVKMmpMaUZ6YlM3VU1ld2dubzFFSXlPRkdPcUhhKzBtWFFRay9oSnFadFAyS3FHMWxsWldVRE50VzVhZGJqV3BOWnVGc2lxdVVnTUljTnRvWjdOb3FVcTV5R3kyQ2tadWFDbmQraHl6Zmp1NXJqSmtPYTR2anRyaXp3OUhqYndPK3JtVlhocUMyanRXSWRnUkpDOEZPKzJNUmY3NXR0TTVzcGJzb3JIU1poaTJQcU43V1lqb01xTjl3VytMMHIxT2RNUDFuM3lyaEV2d2pFZFJOaFhISmNsMUlSUkR6bDRuSkNJc1ZtU01wQktPcDdaUE1WTmgrdEd4N05SMmQzWjdQamR2eTlsSlNaSEZTTkMyZ3hGUlZxVEpyR3pQNTJvSDlabU9VeGcwbVg2d3hrWm9KOFlyeEpOdWNBZTQ2N25YY1cvbGZwUDdSRHNtbUJlUHF5TUlRNzNXWmZiejBzcUs0QlBZTTNRYi80MHlzR2Z5VUR5WFJENHM4aU1qdkJnR1c1QUw1MXVaRjFFWjhsMWE0NE9Fb0pWNXNTcnlzbmpqUmVRdG12S3NaT25pZHRxMDMzSHl2bXB1bEZRVDRUNG9MUk44QnhIdGVwRzV1QWdkcGx2dG5PY21Ucmd6dHd3ZEwrMnM3SVpSUTBOVjdLN3NMRkdMc0d4alJ5TkhjMi9adEFsNndrM25EODNOSFpxSC9QZkdSdlpOeWhOa0dhRnJpWVFuNU1sOUk5UXVmRFE3bDhzMmNwQVBaYW4vQmtzcmMvT1ZEMVRtNXlxZVQ0Zmc0K1RwaEJlN25LTFQrczlUcHNRaEhrUStweCtsbHZtT3pCaFNqMkVnSEhvZlhLUlpiN1ZCSHhtbno3RXdWNGtQbTU5NFQyc3pDOVA4bnZsS05CSk83V2hrNmVIdWJpaGw3NkMxUGpST3d6eU5CVDlSbVl0RlB2RUQ5Q2Nzc1BON3Bpdnphc2pLeldWSDZmSGVycEJpZDlDSy9ydDhGYUdyZFBCYmJIaHlQVElkdUI0OUpycVlCOXJHVTM2Q3FTdC8ydldLMXIvQ3RWVUEzWVJrcWV0MXJHK3ArOUpZT3hsbW5BRngwYnQwc0VMYmdKM0t1enRWcm45R0pWdlVkTHhUdTlvNjY1cVhrNFJlMi9NRnBkR2dPMk1mdE4zWmhSN1BFSDVFbHBmWE80alNrT1l0aW9mK2JLZUxLTTJjNHpydlMzMGpFZFhmUXZSREJwc2tNejBQOHk0RVQvbEl6MzBoN1B1SllPUmgyM3liU1g2Umt4RXoxYjRuR3VrK1JES3RiM2ZjdEFlYmJIQzloU2ZxN2M1T1M4N1c0eDBkMm1XNjJYcWg4eTZ1L0kwN0IzTDVZdThUbkdvYnc3N0YxQzZGN2FWYW04NUhUZXBIRXFmeTUwSWJPcmJMQzZQUnZTNUVrZVZOdStrSG1FUDVUVzBkWDdkN1NNdVYwTnhPbjJLdXc2L0F2emZqZjNydjNjL25zWDhUanJpdW5ndlVpSFdEWm16eDNSb1dPbHZDZDdYamdxM29mOWNOYjlWOS9maDVlbmg5ai9idnhyYi9DdGlUQlRtYlMzQjVNcUxIcUtWM0QvSWRqSU5vcEJDZG5wVThjQnlIM0w4V0twQ0JJWjFQWGNxdm1OclBxTGNWVC9qVm41MHRwcHJOVkJGVkdmMXhKbFZzTm91cDFxZjBJQkpFaFZBZmFreDJWWm82V2dEN0xtWUNacmIrblZSRlhMTjRDelBFaUJkVGdJdDUrM3FWSktNcCt6elhpM3VxaTJyNHhUVFJsNGM4UjNVbG5FUVJ3ckJNWlNLUUxYdk1Ba3B0UGo0a0tjcld1Y2F1eGlRV0ZDZSs1KzQ5ZSs1dVRvL0xRVjZQT3pkdm5iMHVLVm04U04xR1Bmd200RDB1Sld2NmF5a0dRSWM1YzVDR3hmSm1mWWV3b1hTWERob0hsN0RKVTVEMmFXclhWeTZSNWMwTno4bHdjYWtRR2pBL1NIMFQ1V1F3T25NOGNUVUFuUkxHa0VjeE8zYzVkTUc0amt1a2hPSVg3clRmRzR3bXlnMGRnakJuTGNPTzV1WnlDT1czRk1iMjZFZTBJRUlENlVBMG50KzhaMHUrc0tsMUxhRXBjN0k4akUzenNGcEJ0K2VuWTlOQ1FESmxRWmhTbEh5VjUwY1JCN0Ywc3BxcGpKUU1GVnVFMTRob3VtbWJDVExpVVg0K1Y5aGFtQjBKYWtNN25XaTROcERmVk1odjJiT3BjQWI4dFE0WThWaVNyK2F6enVYa2lpcTU4bUYrT2o4NHl0N0w1OUZ1OUFWQWppMFczR0RGQUc1T3g0aURZakthdUhWT0FMRzlLZFN2Vm1JeEJRMG82aHRPWUZPSWtlTDdYNlpxQnZvOVExVmFYMU1jSDZ2L0N4VHRWZ0k1aTRlcXNSVVZvMTZlenRkZmFaM1JqRmlTRGhWa3Vaa2tlbkpKREdtdEg2cWxtVklwK2Ewcm4yWVp0R1JGL0RVZ1I5WUE0SlE0eERSdWxGdncxblh3VGZWbWdpeGxJTGRQVWRwOWFyc0xnb3NzeW5PV0NZSFBZdTdxQndkY3JoSzc5c1lRVTM2ZzE1OXR2Zk01bGZnVHdyelJJM210OWV5WEwzUTgxNzE0OFJVSUsxSUJqRHIwckowMlc3SWdXZEozV0d0SjhyLzgzTi8yS1pOWUtHRWF4eGo4T1JXd0UzVnlaUGFiMDh6V2FVbDQ0UVVCN0VVVmYzTDFrcVVOQ24xL2tyYS9KUFQvVG1yelZHQXdTdDFkVS9hajdsNkVnLzI2UURPTGkrU2xML3ArbEI5bXFPKzM5Zy9SSVFtbjNRUlJwOGJPMVQzT0VOOWJaL3FHN0RnSlc0dDVtck4xOUp2VUZnYnNUNjhCMzlZdTg0RmNsemk5RzZZbEYrMGtLNHM5QUhlK2UyT05NYkhrQ2MvYW51bTFGNi9JOWtyOENFWTJIRHNGdVZNc3hBN1pMR2dtZUx3MnM3MW50ZFo2Uzk3aHV6ZStIREl6cHJiZys2TjhrK0ltTnNCNitueTRxcm11QitubWxScmR2VlBvUGxxSW5xZC9taUkvUTcwTXFETTZ5YUpzYjhtYWx6bE9SY0JOelR5eHZ2S0tYM3ZkNlY1QjA2KzhRSzlDdm9hRjNzcWNoM3ZGYUZyT014OW5rR2FrMlF6MnJJeHU3YUpSZ3lkTUV6M1dSZFRhRDBkTUtwZTZzQzljcjg5TnJ5OWN6L0d5SzBBRG5xM1RGKzdNV1E4NTl6TWRubkIvNXBkKzRhWDR3YjJzeXcrTzkvbkpDSGlhRjJNVUg3VmNxcnRhbzBZR1JmS3VWV2JVZGZPZXBjR1JUUDZTYmJ1SGNsbzVLb1lHRXhWajdPK2o0Y3FXVGFGNHNGNGNqQ2Z5ZzNPQndTdFViY3Z1cWZHOWVFQWZEUWRSY2dpOXdocXExNng0T2xva2swZTkrcXBrS2VYanNUeEYrM1FYdDQ5aFZIZjNVYTdYK3FlN1M5c3kzUTdEREtsUXJ6bmtiOUh2TWJSdjFVTk4raGZJL0l6dVVuZ1d6Rk1yb1dycjdPb3ErYTI1a01WbmZaU2wxUzZ3NDJaSEZ2NXhGSk9mUGdmRW1wamp0a0FVMlliZkdCZFRGVm9vdllpbW4reUdWNzJvUmpONDFiTVhhcTZQQi9jbjhGMm9TSTROb3VKc0RBdk0wTU9oQmtzbDlQWFdsTW1idDZKQlVSRytINHppN1cvV292d0NuMEIvMVBvQnpzaGpQeE93MlByN1JTT2dYallqR1RvNkhRelJhLy80M0JQb0M0UldtT000WndKUnZLZ01EeFNJdThQOFp6MzdXZGNVeEFPb29VZEtvMms3T3ZCWHNjMmJ4b0xCMktkanpWRVVlMWdLU0k0a25SUVFWb1ZQQndjcXdTOG5hd3VKajdIaWp3MGNPaGdlV0R3MDhOV1laWTF0M2h6N3JJUEd0OGZlSlNJcFJtcThTOVN4K0lRMWtnbCtKWFdnbmp3dDBkTFRHVHZxMms1OGtzeWJlY3A5c0VnS1VkOWVwZE55aGVwbUh2bjIyUDZ4MGYzTW5DaExVN0FJUWF1amwxeTlmNVRGOFQ3YVlzRmRqOUxEN3ZyNkZKMkhzdHcwOVlGbXkyVUpyUDd6TXZhNW5yYXUxQWZZOXp5NS9XQ0JLem5uaEtrZFZqTDVqSElZN25NOHk1YlNwNDlUcEVKUWpkNjVKR3Q0SjBhS2t5T0xTekFVQ2pKMENIUVBXenRmWUFFSENUMUNXbHlTbDBoZHRsYTI1UnBqdlpLTkM0RHdkRW82cmlCRGs0NVByQzYzczExQ2o4Yzd2eTgzY2RleGY2U3hoaWkvNlJRNldGckM1eFI3QXJpMGNkcVF1NFZrc05PS3R0ck9wanYxQ3lZM1FyN1ZnK0FOMk1nVHJtVUd2RTB5b0VxWG1BVXJoTC9KVXcrT1FwNnlOSEM0bkM4elFOd2E3SUd0S3dTZWRJMWxYWThXeDJiQ2IzWk83RXBDdXp1R09VbFR0TnMyQjB4TEs2ckJwS1dWdFhCd2JuNTRkR0YwZVA0blRpUnNtMVk2SGdtUnpUWTdGSW1uTGRNT1J4eXllZDRKUnlkTmc2VjNXY0hKY1NzU2dqUjhhMEpUUkNFQXExNUFFRWZ6aDFPWlRPcnlaOGpCV0NycWtFMDBiY2NYb3BQQmtCTk54Y2dtYnU4akd5dHNqWk9kQ0pYam4ydWQrenpQVVI2OFREWENYVEhJdTROdk9LQkoyNDVBWFBpL0owUk5lSTBvVHBnVmM0dDU4d2V4alI5aVFyL1hCTDRiUUpaeEp3cUthSHBDRkY4amFLUVdxVlM1NG9PWVZLSml4ZGVZMzczVHNGQ0FWTks2ZkgyQlJsOW5weTNRKy9MTW5La1hpN1JMTFBTcEV6SlNwVTF2NWZrR0w3MHFBd0U4YUpaM2VzeXJKMDdNZysvb0NYS293ZXNaVE9wQmp0U3pPL29rd0dKOGdLMExZYURneWFmWDNYNmM5RUxyKy83VFBFTWUxUFFmR3gyRGJldjdYby9FdHBobXUrZm8rdEh1L3dFeUtxZld2NE15TTRoeHJibXc2MVZBZzFiaFdoU1hHN1dldC9HdDFvOWpmTmo0QlNUVFpueFlGTjhyR2dva2xXb3phd3oxdkpaMDY4ZS9ZSVQ1R0trT0YvbUJhSkNxQ2lTTFEwYTJDVHg1Wnh1SEx0UkM0V0lhOWN4RnRLVDFPTHMvbzFkMmtqazBTYkVmZmZ4bThrNWdDbUtnMU9BOVZjeDNSbytyaDBCVldlSTNUKzBycHJidXpsdXBRY0k1eVpjZU9uYlpWRUUxK1ovOTBNbUZUUnJud1F6bnZqNlhEVW1HeEF1U3pxdktqMlFOQ2VWeFhjRzhIdnBHenJIU2N1dE9ZQ3pRcjhwcHk4bHgxQy83cDJSdS93TEYxSXFTTldTVWFxRFpqTWxtejRZL3BYZDUxUHNBTGlCeFlJQ3ZEVFM3bkpuSlpHYTJRSkpoVnRnL1dGY3lsRFZOcGZWT2JPUk5VMFhMK0t4N21DU3VyZmI2RXJTV05BajNtVFRRR1kyT2JhQ0xuK1pDTko2YlEvRUJ3ZWNLRENzR1dlQkswbWt1L2tZTVRQeGN6WUxqdWIxOForL2NXL1lvSm9yejRCa1ZsS2VDdnorYnlXanFjY1Vpekpnb2I3RUhXOTlsM3puNkU3YTlmRyt4M0ZFQlI3ZGZ1bmhWNXlYR2lpakc1by9XWnJidGxnOVgrOHFIMisyR1FDd001SEFRZVc1RjNRTGpKeVNGRHlKSjJpdXA0dURRZktnb0NueUcxNlFkRXE2VWR1N3FFU0lUUm0ySHBKRUtnbGdNelE4TmlpbzVVVUpCWHBFTzdkcFpxbEFNbG5NL09QY2tlcEM4L3l4WEl4em1NV1laUkowcEJpbVdMbmcxa1k0anc4QUZWeTVGeUZ6aXhuS1laUkFpTVVKdXkrNEgxUUQ0V3ZwWjRZNTZNMjdGRzVxeFdNelpUZ1pwVXhhRkxLL0pjOEhnbkt6eFdkS25UY2w0cDZvS3VpVHpQT2xVa3NpU2ZuM0d0ak9DTGtxaVVDd0taS09QcGxKa1h4WVF4QXhCZ2l6cW01dFhIemx5TmVIZ3hJcGd5SWNsV1I2N2RsU1dwY095SVZSRUhxMWFlVXRDb3N3cllqQW9Lcndzb3F1R2poNGRncEFvbWpEKytuR1N5c0pVNFdnQmhKYUNLaVIzSnNHVlEyU2lkNGlWU3VhT3Awa2ZnWitjTzZqSXl1cmJrSUs4emgxMTZOLzhJWko2K2VZcE9ZaVh5YVBFa2FuY2QvdXJ0bTNYME8vNEEyYlRzZFFXMGd0VndWS09xOXIyYmErNi9UN0Z4Zmo0T3IrYjBCQVdGK2RLRUtNbHdsQk9QY1hmQkhKY28zbUhMdkhVaG1XbTNLRGh5ZWkwM2dCZjA0NnZNUXp1Rk84UXNCQXpuTVlsQjhCUlB3MGIvcThGekR1R2swYXJwUEpaZWdMZG5LV3hqQzduaGNFRGx6UklCUjRMMzA0NVJveGM0c3NDRktZcEhjNXdabmJRbUhzK3A4TUVtdkRaK1RtYkNTeW5BV2ZKeS9uMUc5UStERDE3YnprSVFvR3BRUkhQeXdxZnE0NVVCRHhDUGw0ckVySEkvRHlDaGNwSU5jY3I4andXQjZlZ2JyQjg3K2pXclM4c1VPSENKbG1WUDhQTE8yVlZ1a0tQNjFkSUtzbnpueUdsbStoeGdDRnkrUWZXN2dwdHQ5dEdQK08zcjZPaDBMemw0Nks4aWJRbWYwZEJsRWRKSmhvbGRVZGxzWEJIbm1RMnllTHhaV2pNMDlBTTBoYnAxbHRKQ3piQi9aK0dPM2ZxM2VLOStJWHVPa0ROMWpvbzBhblRSanh1bkRhNmFNL25iOEdtZWNZMDhXMDQ3Y3F4L3dqOU1SbWZaUENNSXkrTVhxTUlybnFuV3F0bVB1NlEyVy9KMHZYdm5GR2xoTjFhQ2lkbDlZeWF6WGJFV3NkY2dSdWwyR2xVYStua09nd2RuR2l0RGdQUEF4RjFVY2dSRjBsR3FzeFh4YnFrMFd4Y0FoR0Fma2dLVVhVWkxJQ1hMY3E1WlRjZDFXKzZTVCs2S1V0M0xYYXNxei82NGpsZVFFTFgyVStYWWVrWVZaY2RnMUhoWjd1NjdYdTlSMm1XNjlKWmJ0NVlaNG43d1N4MjI0SFVOOUJqcXYxYnQxNm4rYmtObXRpbDM5eThvWDV6c0M4VVpFOGIrK2c4eXh2MDNucjk1MWZPMDRlZE1acDZrVzR1NW5WMkxuVXpHN1NvYTRYN2FmL0dJTDh0QmZJMjZ4ZnVFc0EzZkR0Vm03NGQyRW8vKzk1MUpaQ2w4L09URlAvVElIUHp0ZHdyQ0JrbHMzaEgwN0JxbDJtUUk2RGxZTSttZnJNMEhpbFBRMXphTVJxTGxFellFYW9tb082MjVWSVpmSEZkdUdCS0Y4YllnZ0swbHV0Q2gzUjVmd0RqRll6dk1pM0UxNHVwaWRRQUw1aUUvdUtkT0VLbDdhWEs3a284eHNzSW04S09yYS9jVXNqUEMyQnJMd3lOVkJldlAxd2xKSXFJWkdFdVA3VGxsVnVad2ZLd1U2Mk1PMk5qem5qbEUyWXBXcXp6S0RHZXFnd1FYa0lMQ29pUHptV0x6Uks1K0s1S3BtSHpTQWhxdklRSzVQeWRqVHJnc2lRaUFoOC9lQXlja3E4N0dMZFRoSk5MMVJzN3lkMVhtZGt6cktHS0h5ODV6Qlc1T2U1MjdpN3VmdTd0M1B0b1ZKQThLTEVBZzdFK1U2WXFyUFZGMGZWRkVwTmFnajB0VmRxeFRRTWkzZFU5djJ3V2FtcUtiY0JFeWJkWkE2K0hESXNMNU1kNktYZGRuOXB4QVd3NmtqUXlyNGxTSUxMU3RkZTFnN0tsWkdzbFVVN0g4OEdZSFJzS2hFdDhNZDJ3aWtsSjBBckowa0FnV1VycHlWTHJCQVBEZTNhTlVEU2gyVzJ6SVVHTXVFVmRsMTZGV1ZJU3lkeXFTU2dTT00vZXg1T2w4blJPd3ZLUUZSOVFEQ1ZoMWl6Vkx1Mk01VUtSZ0dhV2tvVUIrdmNndytsN2d5ckdVNm00cUM2eGZjZS9VRElTOFhYM0s2NU9lL3ppY0tzMlFKdjg4TVZBVEs1c0RDelo5ZzNheHZ5NHdZSzNNemJlZEJzSWhTcHNPei94SHZFa21obVg4SnNvYXVlUmZDTURxSFFDRXNQUndXeWxPVVN0ZjlMVXFnNkNMWUtDcWZhTERNODJuaU1qWEJnaS9GeEFEV1EzRGUzMHNHMnBhdU80NU1sOUFIOXNqU3RUcEM4WWZ0VGFoMHBlS09tTWZUVXVlTTR3UWgvM3VtQ2ZyTTd0ZXUxYjc5dzFWMVdqa2lXS09EczBmdG5MRDQ0UFpiRW9XbEwwZWlxU293bDZlLzYycmJBQ3ZuYjMxbHNMc3FTbWxiQVUzenM4Zm5COC9PQkVlVjljQ2l0cFZYcVdpdFFnYWR0bE1KbDF3a01XN2Vvazd6VmZWTlI2RHoyV1lyVzJmaThTUUZ3Z3NuSGMrclYyT0pvV0RhQ0lsazcxVllKMTROclMvbXdIMEluMnkvbHRMdlk4VGJZelRpSkx2VGFpaFk2bUk0N3EzSnFkS1d2ZlNydkpIbWJsR3BVakZDazY4V2FHQTA0VzRVS3VkMzNwaWtJS21HYkZPcFBNdGdQWG9qTVczb1MxMW5jMTA3TFRWQjhHN1ptUmNQcG1RS2c1eDVFdXExU1pmQlJ4ZDJpa3RxbWRTdHNQU0pqS2FvOWo2UUU3Zlk1YldsbXRhT2JTQWhPUE1oc0VwcHNZY21OSHMrYlZ1K1dQWFVxd0NWU3NVVk02aHhLOG84akYrL1FHYU1UelFPRXRnRFBzQ05IQU05eTF6RXpybXZ2U29pMU94MzRCanJ5QzVtMWUraFhTODZsa0NaVG1aMVY4OHZtMml6UFRCZ0R2c2RKUTFadkdWRk9GYlVXazcrQWNCNmZNbEZ5YkFPcEhld3ZFRjJ2RDd3RFFEcVo0K21UcWQyTU41aGttR3NQZUlSUERWSWdKVjhpODdnSjN6TkwxQUdTalVMRXhXeXRUcHBjS1JTa1lNS25KNDJCUU5UWHlqZHN5WVRzVlpYQm9jRFNSa1lTSUlCZG1JellXTkprWGo0Nk5wWFBwc3BPV0JNVVFsYUhaZ2t3cVNHUEo3UVV5UVNPRTFhaXU0emcyek9TQWFUMHFpNm9zQ0tsWU9aVkw2d0Zaa1hIYTBPVzRZZ1RnY05LQ080cUtQQ2J3V3V2M0pSa2hSWXZMaXFpWnFtbWxCZ1lTcGtHdXBldURvcUNJa1Zna0dZeTQ3UW5iMVBhWDBUMHN2aTk0dlRtRUJpb0RYVit2MVF0T0xWcG9FRklla3lrVXVmdGdzd3UrTVdSb3duL0N4VVVMYTJ2TlpwTW1yUlc2UVV2WnBXeHpxWm5Oa3Q5WlVrS0tWK0FneWExa2w5YXlLMW1YbC9Bd0dOMTRYeDNXNG1YNjBxaS9Dd3YwUmRFWmdzQ3hkdGcvdW1CS1hWUlBoNG40OXlzRHFhakFpd1hDc0Z1cUdRNE5xSEtJVDJoaFNnRXFrcG5VSS9uWlFpU1ZLcVZTSGJiaE40V0NXVExmSjhsOEg4RmF4TlFWU1VPbUhrbUt6QVJQRmhYTGlHYlRrNmtYNE14U3lwc3IyL2lOQzMzd2czMzd1YmE2MmdWKzhoQ29QZmxIdy9VWVpRTzNHOUNSdFRaS0h5R3NKZmlRckE2RXdxWnFrWWNzaUx3UVRRMVUwclA1aUo0MEphVkh4bk1uYSs0dklYZ09NUm5SVGFSSmltNUdOQndoWkY5U1VNVnNNSlNhVEdlamhxV0lzdS9maG42QjJoeHZBZGxDejR0eHp2Tm02RWNFWnFMdXkvbnpUYVBsckN3b28wcEVqZ1VqcVVUVUNhZ3B2bVFsVFcxQkk2TTFtZ3hFRFRPVk9Gd2ZxRlEyVlNwb0xSNGJKNVZ6NUtTa0ZqRE5XTkJRZ3locXBTc2FUR2l5cnNsR1VBdEZFN21SWW42NDlkRHcvREQ1ZWUrRHpXbURaTzRsYTFmUmNUVzhzQUZQU3lBRWdzaUQ0QnIwc1ZFS0VTcXBvYUlicHdHR1VpUkI2Q3BCVXJSQWFIaWlPRk1jemdtQ2RMMGdpMXNTQTlGTWZDQWFEZjFIZm1KaTE4UkUvbUdJZnZsY1hqU0V4TlVRRnlQL25NVC95NnREdHAyT3BiSWE1bm5FQjIxN1djUW90dDhKYVlwSStMUzN1cWpVT3hJU0x6NDJTb2p1MlZjRC9NM29ZMktnalNzR21JNEo0SmZjL3FYckdabVRPcXdXSkovWW1YRUJhN0Q3WHFyVFMzcEV4Y2NYWURDczJHbTBTREdQRjQ1ak5hSXZUVmZUMXNxcjl1eExDcWFSeHdHK2RDdXRsR1oxYnkzeEFadzNUQ0c1YjgrcnlENXR6ejlRdlJKdGp6dFNLV1hYbU8yMHYyZ0hyN0pka0J4b09FTmU2MjFSNjNSUGk5RHlpMmlTcTVmK0pmUm5aR1lESFBRNWtQVXlnOGJaUnBHQ1BrSm5sQ2tlR1FUK01wRUVoRlZaeHJPdThsK20wV0lJaVgvZi9CdmxnRkFVZVpuWGhoWkxrbGxNakUrTTF5eXRNVEw5bXV0bnhjMnRKM2xlbHVWQUlOYWFHaThOSkZScnNqNThlS3RoVGI1aThRcHkyb3dVRUc5SnBKRElpNkhtbGt0R0RtVUtUdnJTbTI0WTRYbU1qWGdJSXpzUkhjb01URzh2N3loT2IyL2I3b0F2YkpUTXdydGN5WUxNYUNkd2phSkI5Unl5NkRiYWkydzNYTUVBRFFyY3RsclpqdENQTUY3RXRybFpFdmZXNjFuVHhxMmJqdFRyZTBYcE5XQlo5VVpTc09qWCtEb2xkbDlETWkvRFVFNW9DZkhBcG5sQ0tlQlh6bTg2SU5JcEIvWVcvY1BmbzJYaTl6eS9meGNiZkQyZVpTZFlVQ2NPb3hjRGdQRVBYTFRqSE9EV09xdGE5R1RHQ1BqM1c2SDJvUlEvc2N2NmJQRm5sS3NBK0w1MHR1MFhRbjB0ZjNMdWp3aFArcWRrbEd6anJpT2pCR0xZZ3hGbGg3MFQwTnV1RE5xQlVVVG5Pelpmc0hoSmZna053K1VHbmdFeFVKMFp1TUJSb09hMm9jL3dZYlZTdzJMWW9FN0VNME4xdzY0TnE0SitoMnlnZTRjck5LZnpDWUZVR3dsdjN4NE9reFVyTDZsa2YraWJLVUVUODJSU1Q4SDVTNlRYSllsMC9oSzV4aE5hUUU0YzFoeUxNaGFUZXdZUEo2V29rQ0RENjVLZFh1NE9xTE9UVEU0REE2TEd4M2hlSEFqKzI1akk4MUZ5MlRGeWJsVlhsRVhSRkJjVlJhOU83cUh2Z3EzSllJTTlUWjU5dGoyM3pBREg3TmtNVEx0OENueldCYlpxSTI3cWFINklEQ1ZUZTVBTWtoRm5jNVp3RnVPWFRRek9Pd0NtTG9pNXF5YnBJb3NlSDhvTllWcU5ETUNSYUh6ODRNc3ZHNDlHQlVScTZVSW1UOWRoVjFiNURQVTlyYnZXMGs1M0U1aUMwRzhDbVFtZGNyZUhCUHJCSkJtZ2hSdm42SjEzVFY2VkkxT3lxSXJPbGh4RFJodS9MSDZMN0lKU29UVXNYejQ4c2V2T3Q3NTJWejVEbXBJWGhhaERvZGRHQ0xNblRiclc1TjczeW56ZU1HZkRMRmkwbVhPVDAwbkg0QktnUXRSbnlsMk1HeGtaRHVQZ0J0SVpKMnArclUyei9BcldrMlE1UzgzdVV3bEI2V2htY2d5YmNkUDgvc0NjMFd5VEtMOGJzS3Q2eFJseDRxWkdPZUdGS3dKeFNzZC9sZlRYUjdrOG9haHVCTWtmZzJvQWVZaW52M1RqS25nNkZzbTF1T2llUnFpb2lka0psMHZPK1l6RDBiK0h4L2FQZmFBOWt6eGFtVmNGWHRiVmVPdm9mT1hSOW9FUGtIcGhPYTdxTWkrb0grb0xnS1VQVmNZV1JpZjE5aHhUYlZUSUlBdEtoaW9lcVRTcTdkbEhueHhkR0tzTWFhSnFTRUZzTy8yTXlPRWQvUzh5Si8waFdROE9jM2N3R25NVTFOc3VHdjlNMnhLbnMwK2NtRlNpdkd3ZjBKTEI3dDVwbk5kd25odmRQL3FwQWxQdkhhTzlRTEpLN0ZPVk9VWGdwWUFTbDBPdEJXV3U4cW1ZUXV1UW5qckc5SWVGVDVGVFE0VFdEMGo4SS8zNkNuQXlzamdLZGE5bFo4SUY3TGxLTk15NlM4OWZGbzVXNW14MlBiajF0VkFuaXJQa3pGSmVweDNIOTdXOTU3dkcwYzlwRkwzRWdmTGZHQk9VVG1tLy8vOExiNy8zQmZzdmI5MEw3bE9uL1lKNzNxWDNudGE5eXo1MU90NGxlMi9mNEVIK0JUNjRYQVNreWdNbzVrSGJNUlZzR1Y0bVBEMEdqTm10aU9wZmdZZUM1enR4V29rRWJxczNFMDRCQjFVaG5Va2RDVVNVMDhvOVVQNXFHakdTN0NIK0Vjd0h0Q3VVMHZpeHNiSGhoQ1FZeWpXalplMklGdUR4SXpnMlFBOWIxMWt6NU04dDgyenh2a0h0a3dmN3Q2N1UwVHdGYnZtMlhVZmNwc1NTMWRITE8rKyt5QmZHWHVYZGZkL2hrSVdPZXJkaVFMV3ZJclRJQVBYbGo3bW9ENFY4KzUyN01pSEN6NE9ZQStReElIbG5jc0EyTWhVNm9hcUIxczgwczJPVWFkVS9selZlUEZNMXRkYlBBbXBJNURYNXp6dU9OMVhIMUo1cEQrZFZMT21OWnpUVENlc1NYbTJYTTdyK3AveWIwUVBzTyt0R2hxMFhXSGhsUnBhNDBMQVN5REg3UUIxNTJKUGtRK1B2dm9XMDR4WTJQaXFmVXhVTG80RDJBODJzME5IVGVsNVJQOGV5dUxPaVNhb0VFRDUrTThZM3N4RTYraWxzMGVYOEc2TjA4TWJ3cDFnR2Q5VDVCbDNET1M4MkRPQ2NNNThEcmlpQU83UXI5SzJEVHlNV1pOcktQSmtwR1g4QWtzNEMvZmFLRGMvU2pxSFFVMXU0UnR2NmptKzhUVER3RW8rbHRBVDJvSWJ3TnRYVXZnSkFtRmhjSk55VVJqN1hyMmhtNjBrQlMyU3RGa0FETE9QZHV3bWpUNmd1U0p0b1dsWWlrcUpJRVVWdS9VVWtxcG1LZEZ5U1paSW9waFo5SVF2NUxLbXdva2dMa0YrUUZCZnZHSFFSRTFSVzY4cU9zZHlPS2NzWVlvcTBIV1dZSEZzWlYxOXVSK3RGUCtLMVdDeVFYR2lNbDQrYmpqd2xtNEhyTllYbmhhYWdpMmJjTVc0TW1Gc0dpd2pkd1F4ZjBNZEJjNEtLbWEybWNaUGh4Q3hSSjFVSi82QmZIekNsYWRreGo1Y25aaGNTWnV3TnpPckZsVGUyWlJBVGRPNWViMFBDR2dRT0hQVUp2dXdTemhuZVdWY0dId1FwN2JZcStSSnIzdHNMSWhhR2Q1WWxHVXV6eCtZRWZCTVU3TDV6RnhSY3ZtL1BGUUx1TlRCaHpaU2w4czVoZ1pCa3BQcmNzVmtKeTlLdU8zZTdCU01qRDExT3lDdWdZNzVKNC9zcVpDWURUczVEaW5TZ2RVeG9DeTJtUkZTRElleTZ4VlNRNXg1WktkWkxwWHJ4dEhobzVWS3NxWExqMm5tUkdtZWVGRGR2V3JycGRWQjIvZUxCYXBXVlpwTlF1N2ovMHBWRHJFQ2N2N1locXhwKzNZMDN6Rzl4aTZyVmc0dlhrOEsyUCtjS2FXZVZ0cElKUXJzbHUrZUJBS0NPRlBCOS9FZno4T0htaHlUTU9BU1dZbW16aEQ4STJROGVMRlFxUTVldEhGNDVoS1cveE5JNGpmUlU4YXJUYlBacmxUM0RicXdKd0I4SFNYT3ZBZmEwNDdmRjlFQzZtSGZBTElVdTg5dFZLaU42NmRhemtGNDViUDhhYkIrVnlvT0VReFEvSWtoWEtMTDg3dmxMcFRxVWI1WlU1RG5Za0thbGFEWkZXbGlYaFBjSVFma2hmdThjTFFzRnUrVmtnQVE2Um0xa0N0MkR0QjN2cXpzOEkya3NldXlJYWJkKzRBMnFzMHdydWNmRisvOW5VU1RFekxZanBqL3dETHYxUE5Ncm9xbGJYQVVNcVVQYW9mdDJIUTdWR3JDNGpLL2wzc1E5eFAwRzl4RmYxekhZRnM0enlVV3ZhZkJMaU5mWkZmbXI3QWMxYS9neEhXczlucUc0cTA3bkVmSnhybUJWU2pHRWpwU2tmbFVTRmtGMTBaV3M5Q3ZNU2tLTGhxcEVsaGZSc3ZrSUpOTDd2VGlYMGsrb1pEMzdpT1g1R2FFbEZiOE5TNm5UMEwyblV4TFpVVnVudk9vZHljaytaWXQrYnBXcWJrRHpRNVU0N1hZbzNvRjJFY2Zocm5jMVJVYjNIdTVLa08xZjRCMzV4dFFkZlh3UnZkMnA4K2pieDFlcmVBMDBFU1Jwc241aldxRHMwWjd1dStuOC9YYWE0cmJTa0UrMEMxbG45T3VXN3Y1UTZKb0VzczBZdFYzZndsM0tIZU51NSs1bFBXTEgyaUlMVDZFRUc1enJnUThvOSt6M0JoMTlzY2ZSY3V2NXlseWpmRlRUUTQxd1NYdndaZVRSM2hDSVhJRisxM053ZXdrSldwazdOSWNlQ1pXMUxMbnVjOVI4dnJVU0NTeWY3QXJJNm5VMXlyYUxtKzNpMXRsMmZxVmR3N1VyZXQ3RnJxRzJjNTM0Qm13aWVxRWowaFBUVEhYWkNqM2pLcDdhdUJWQjhsYm1xV1MwNitPUE1BcHZLNUlMdm9pQW1ob0FiU2Y0VnJUazdxamFkcHo3WXByU1hITUw4OWZQelYxLzUvVnpZNVpHOWs4VnQrM2ZWcVFKNG54TTdOWTMwa0NkYWRZWXJUcDMvZnpDSEZCclNDNjZsWXZiMnZKeGpzYkZhZEk0bUJlQktQVGkyajlIVzhTZ0NienNSVDVMOTBtUXZkam5hdnQ2cGFtdkYwaGVadXQrMDJyVGhFYnp5UHVpL3hBUUJ2WkhmYTZPMDdoMXByQTVuOSs4RnhKcGZjdEpEZnRPOXpCSk9KWEdzRzVqc1FPYTJDN3VDdko5c3ZtcVMwNVo5blVPWHNiNU9kUkFaMXRNSDcxRzBxMU1IYnlmYlY3eEVvNmdMQTJwU1pPalRHWHMrdFc4eUhMNmJyNUIvVFlwZjFvRXBvL0dOM2RpSnZKRG9nREtJSXluQmhoQURUQitIV3docVBQQjQ4QVZIa2xsMG9JYXhBVW4wYXpmMW9kQi9RYmxFSTlvNWRGckZFT1FFc05qWThmR1M4b1ZGK0JQTyszU3B0WmpEZUE4THMrV0c2NU5VTlIyTUxNRWFqZ2VWQlcxVlBGSjNwTXhhN2NvN3JiR3dYQ0dwOXR4YXpjUFZqUmtwbXpUMU44TERwdm1jSkJhMTJCTU04RmhqS205allzN0FQaVNRMVNYVFZ0UTYyZ0NmZTIxemtZczVaT3ZFTVZYSlBQVUg1MW5tUW9wNUFIU1lDWGFqSklmWkN1NlJqUFJwcWJUdXA2K2o2NjFHYkNpQWM4SGl0d0hNWVhram5ma3VzdEVjeUZtek95dm1qNXFONmt0ODNNbmNjUzh0REtXc0VWYkhZekdMdHQ2bnhuQko1VzExbHBORXFNWlJWTGY2SFdFSm9kQ3NvS0NKd2lQdllETTRQNWRSZ0RIUzhQRE53MW4wUUpoc0U5Zys2LzJvS1lZQzBwaHI2TmZKbU5lRnBEU2xpOGdKbDlBYlBqSW5ub2ZaRkN6bEVWemg5SUxMMTNBNFBrZzA3R1NocGsrVXVpQnkrcUFaQ294b3EzUUZjbmVweTcrNXpVdWZNdXA1bUVzalJFKy9WL0k3alVGd3BHUFNmaHdFMVlCdE5SNkI5VTlrNTFEemNjaEpQMG44NVVtSWRIZlVjbC9FbUxWUDk0OHhBNTdiZnNzK2o3MWVRU01BVmVSN05zemtNY0hmbFdZZ3Y0b28rZEx1Y2JFZERnOFg2MW44cGE1Rmc2dm1kYnpCeVpuK05PbytjcXJGbWJIYlVWeGFvMzlWMXdYakV1TGlySW94VnUvWDd6c3l0djNkOTlyYk9ON0lSOWZ1c09kcVArZFd6OTVuUGtzL28rOUpJbEowbkhSM0xnZC8vazRxMFFxMDVPT1MweHY4RG15cG4rQldrNlhTMEhrbVU3U2dFUk00MTVHZjcwV2dmdmxNL1hxZkRnOFBkSElsU3dUM2M0dUhMenVpdjJObXFNbzl2anN3bFd2SkRmMDFoYWd1N2JTU0NHQTFvdjZtSXhpRnltNkhUYWFhcGRtRzM3azZIeTVoSEpSYUJuNi9sNURDWTJRMmRMVVRtb21tVE5IUW9xeE41REpqb0ZjLzJoRHIyWldNbFc5Y1JSMng3SURyYWNRZDdlbTNYMWdiNkFnbWU4SVJDaEdkeVVTZUljcEZRSjc4M2FVaHJyZW5NemxrcHRwTm1vajUyaEpGRXVjNjcvTFltWmR5VjFIT0o3YkdlNDdqVGhXbitrMlRQS1dtSTRodThFK25YcnFOWmF5WjVRODRpbm5HejZBdXkrL2JKazNtL1lZQzZFNzF5WndLWDE3cGp2M0NKbVRWc2dmMlAyMGhsM0J5QmpiYmprNWR2UFM3VGE1R01NcmJKTjMvWklWbUFMaGo5b2VMVE5aQlB1ZFdiN1p4VEJjYy8yYXdSN2xjdTdsM0JKODF6MUdkL1RSZWpxTU1Rdm42WUpHSjZIaGRQWEhDM0cza1VDUm9ydTh6bWxSSUgycnovT24yMzRhLzd2ZEV5Zzc1M05ZNUhKcjdZNkJLL1Y3K05OdHY2blRIUjBodWpFQndGYytSU05pYzZnZEZzQm4wb3ZNOEwvZ1AwekJsM1F0VVVKb2FUS0hzcm5KMWxsQ0dLK3NNa3JpenoyQ0lrdEpxa0syOVR6QXhpQUxKQy9KYkRleDRNcXpBT2ZodHdnbFYrZDJVS2tpSlZCQjVaY0RpM3VmU3FVcS9TQ3FsVXZiRUdGOXdPQzMzb2ExYTNUa3l4MTVubngwU2xKSWhWdS9IazRKU1FyVXNPczJKUmtUbGNYdkxTcGlMS25jdGtzeld5K3dOaTJ6elZtMmVZNThXcDhPTzA3NDAvUXJlNWN1V2tuOTFhL1drNWFvdjh0OGdvSnNiWlM0ZW05K0p4bHZrMndtS2VUS25kanBFVGNtMUV5NXhnQm5LT0FrMU1wQmZNVkp3VFJhYjFENWdQSkt1T2JldlFFZ0cwSmZEa0VhbEhsVGIvMm5qSXBLNEYxbjlQQzRvdE1tdGo2cUpJT0VySmkwckVsQ2ExZ3BuTkREV2NDQTU5d1lPa1VxNVd4eWw5RHhmelAzYXU1dTdoZTVFOXc3dWZkeUgrSSsxdmFFYkV4Tm9FYUpyV3NoVi9VNkczT21YTExBbDlkNUVKZStCTTgvMU9pd0MrNDUxT2VzamErei9uUS9neDc4QUNIaERZd1RmRHdTeTA0MFN6dktxU2s3TlIranhRSFZWTWt2eXpaTGJMUEtOdkRGa2N6VlhZWGROVmU2OXR4TnM2dW11MEZ6SDhEa2ZqYk9IQm8wSnJLdHYwRFQ1UjBsTzZUb1lWcCtpTjBNZDIzS2JLT3lTMWhkaFgxcm5tL1AzWEJjaHp5N1JpMTZDOUVZbG9OQ21ZbXQyVndYNU12YmVjOW5IM1lkNzZoRTNjZTJvekw2RnVHOHRNekxrd2VUKzM1Rk15empPdDBTeC9ZbGkrTUQ1dHovcWU1TG9PUTR6dk9tK3FqcWU0NmVtWjVyNTc3M210M1ptVmxnZ2QzWnhVMlFDNEFYQUo0Z2FJcWdTSVVnNVVqVVFYSXA2b0FrUzRiNWFJa21GUWV5WDE0Z1dSWnBtWlpNVzdSV0ZDTlRGc01nTVNQYk1TM0JpdjBzMlE0Tk9iRkM4MW5EMU5IZDB6TTdPRWpMTHdrd1cxMWRmVlZWVjFmOTUvZURnTmFSRFA1bnE1K3F2bzdrUUc4NjdQZFhPNTB3L3luZ0E2WS9LWTlObGhLN0pvU0FlaE8rVXZuRUxueVg2eWZEV2tCR3IrTnJmcFkzcEk0VytIaTQwNm42L2ZncWg2YjUzOVMrSkVQazhMbStsWkdEbURHQVIrVHFJUHZTVithOWZJcVpkQlAraE9Yd3ZIandOQW83T090aGRKcUJ6NWc2Wm9Wb2JyNjZYcDMvMW1sTWRCM0JQOFhBUDN4UzJNWU54blY2eURkRyt0THNPT3BFUjQvalZySlNuaHVLb1RxOGtMWS9TZ2JsWXdqL2FGaTgxWFZTbi9WVkNUd3dYOTFZWjNCbEZLRlA0MU0valZCVUNxTmQxTXA3RjRyOERhN3JjUDBwdjIvSGZIZ096emNMdmx0OVBzc0J5eG5lRXBVVG5vb29FMFlxNmJjZGRwdkVWWVdnWUFOTHJNeVZDWTFEOXpMVXRkRzdwZDFBZEZiWEIvWEZCN1JnVUgzd2NaeHFqOSt2aGZEWStGeEdFWXlZL0g3RHIrMFBCTzdVQW51S3FzSHB1aFFMOFFoMHhaQVZCT0IyeVRKNTZRcnhaa1MyTndtclpJdm1GRXQrWDJpclVkU0NNQmdMd0tBVkpIOVJGRE41ZUowUytvUm1jcVlRZUZWU0NtcFE0ZjJXTXZHWUZnQkJyZndobVRkaXlsSGh2WFQ3SHY1V2ZEUW1iNFBvT2kwYWJDaDBmTDBCWHNQdjBpTGpxNFRnc0JTRUtlQmFBMk50UTVScDhLT2hzZFI3WVhpMGtiZjU1SWJSOVBtTlE4Nmg1WEVDNkxqSFkyd1lkMnQ0UkpsOUlmOEk5ZlhUenZNOWRickhIV2xvWUFTeUtneU9KRER0ampQa0dYOG93ckFtMXJsak5yNE5pNGRGOEcwR3NHazdBeUJLZWJoaGYwZ0tPN3hmZEhBdTBYdjZtSmRyRjh0MnFkaWZKa1VYWW15dkV5RVkzZG1qZ2paQUlxUi92RWZEbmdOU2JtUCtVWHIvR2tZbGw4ZUhFTFg2S3A2TnlLek5FV2l0RzhxNFl3MHIrTnZVYWVBazlSejQ3YURsMlh0cVpINnRFYlNxZGpGT3FsYXc0ZG1yanM0UDJTZzNmUWRIMkNoZkt0VFptL0hPSzFKUEJVeCtQRTI2OW1tYW5Sdkt1aWNNS1EyL0tpSVNlbGhoZ1BwTzlyNlJwYXg5ZjhwMXdXZDhCZDh1MzUxTXBsbklYYUN5UktyVHAvQzlVYUFHZEhVb2R3R2ZRQ2VXTUdISDc2THRZQjhZellKSFJhU3hiSStobmo3YVA2WDN0elQvTXNtL3pFNG4wR2ZnT0c2VkhUZEM3R2QvYVdNUnlaNGFYVHhza3o3eWZhUENoVjhrK1hhdE4vdStYeGw4TFhiMmk4T3ZpMlVIMy9mNjhCQmg0K0xZOENpaDUvUmp5SDNkZWQ5TVllaEtZa1pXMWlwNGc1Q04xczEyUmdUWEhqNW5iVVNuNCt5SlVZWEdwMGFXZ3Qxa1dIeUJEb3VydlNQbjd3RWJIMThZSGs1cm5ySGl5UTVoOEtjb0hiL2l1M2JJcXdLMXB3anJWQ2FTTVNzTjJwVzNqTW52ZGJONEg1UkRZbkwzN3FRWWttSDJ4aHQvZEtuQS9CNlhpMDlLZms2cXBWSTFpZk5MczhYaXM1Y0t6MC9iN2VDcVRWQThzcHVvcGQrdzZtcEE5bWFsZ2ZjZ0duSUVJeTR2NWdEMjl2QVYxdkEwZnArcjg3dFNwbHUva1NuU3pOU3Y5S2hoTzFqRE5IamxxYWNPbVJGYW5rc0dUWnBKUjkxcmo5aDZVNXdBR2FxTEpMOFlUTXZobFRLTmVwT2VPZmhxS3R3TnAyUzh2c25IdTREVFMxRjYxa3AyM3RTS0VYWldidE42LzBZT0pnVjREdmZSeDNEUHRLbDNRNGRHR0tlK0RXUy8weVoyelZ5TGJZSE5JOXYwWElTNHBWQjZEdzhjekYwVEVBbXdCQ3cwdUU5amxTOXhFYlpsN090V1lFVm5pUTlGaTBnQlNjWjViaHM4S3dnQjVlRDI3UWVWZ0tncTB5MUpsRTI1RmVKbE04Ukh0eXdqemdqRE5HYTAwekJzY0doNVM1UVBtVElmYXVHelJLazFyYWppeU11VjBORGx5QngxdWZxSVpLcGN2RkNJYzZvWjVGQkdORU9pbUptVVExQ1dEeGQyZGxGWUI2aThTRDdaeFRJQ2VoaDFkeFlPeXpJTXlaTVpVUXlaWWdaeHdaSDNVSUtqN2lHTnZnV1J5ZjNramUrQlg2TzIveE9ZZHRxUEtTZkdaK05weXdVRXczTlhoeUVOT1A3N1VlYlNYOENrdWRrWm9rclFFT254dTY2aE53dmVvVXAzQXlnVUllSTI4VkpWNGpkeENCWmxUaDczR3dodTQ1RDRma285N2VDUitBR1MyOXBpeHVlQXhnRHRyWWQvWFJBVmVGcVNUa05GVHMxYXZUODR3Z3NVZ24xTVJFZDVJV3BubWN4eFEvdHNYbWxvdGhiZmV2dkVEZTBEclRmWFFMQ1h0YkJIZGZ1Z0c3NytVbHNva3ZaUitRbUpiTldpMWdubmVZUERnWUxSRU5CcXBMVkJmVEN3di9FMVRqSURBdUprS2N0OXd3UnYxTmMxT3hsK2hhRFk5OG84N21Ua2YzUnpIM0Z6NTJuajZMYzRITHozemJaeDQ2djhuNWZleGcxdk1YWHBiU1QwL211ZzRmdXNUMmU4aTh2S3QydXZZamJ0M1pqZmVUY3lpQTNudXhIWk05allmZ1Y4SHZkTDFyY0o5OHIxVk9OZ1EyeDRYYUZkV2dTV0VZWGZpMFljNkQwN3BEb2syQUpFblVlY1NqdVZBVHJGNXVUS29CWG1oWEZCeklnb1FjYmZPMGdTRjVWOHlGeUtKbUtKZWpRb0NFQUJzaGd6eGladURNb1E4Y2l2Z2VmY3ZuUThQc0JxUkZENEdoNytEOUpoVEpQTkl2aWJSRGdTVFV6VTAzbkVTVUphRklDc0MxVXRFRkVNU0d6Rm5jRmpPNk00My9lL1NCK1VCaUFwbmRCV2I3VVBlci84VStxRXYzQUhWNzhUR1BoVEE1d2dZNmMwWUdrTUxNL2dPZXNaUEJ3YmIvU2E1UENJSzltS010citPZS80QTdLZFVYQ2haekRlWVc4Tko3N0lXWTdZSm02aXVxb3BVTWlWSzAzcThsWW1McnprMjh6ajE5S01zQlNUUDVnOW5hVnUwWjFDbTN6RU9FOWljak56ZzlrbzVBN0VsM0s5N3lQNXBlbEtiSGVrVUErRVUxbjhMeFVPMUF1UjNiSEs5RXU0VjlLNXBYZzBIbitRMEI5K1RUdW42Z3BVTEdPTEdscGJLeVc3c1dvc2dQKzZ5ZExhV2tqZFlsajRxSzZxOFZqOENwSHY4bUsxYXN2R2lkOFBRZm9wVSsrOGlPM3pReDJ4Q2IxQnJaMVpjMW9FTW9XekhiWkJFSGZPbDhheXVVMzVaQ1BJOGRHNHFvb2g5WlFhd2xSQ1BNcnpvZGxVcnBQTkd2dTdzK0FaaEQ2ZkxVemxOK2VqWmxUV3c1b1FpUnIrYUZqUVRFT09ocU1BNU9kempVTGdpc1ZwOXgyL2ptbHNFak9ZaU1QYVUxeUZFb3B0SzgzamFvRVhrbERndzhMa0ZaT1l3a2VMZHl3S1NkNjRQTUJyc0hiOTZneVBxYm9zVW9Dd2ZPZjc1NkZneDIrd01RSlliUFFDWGlGYlZQUHVTTEZkOTltT2svR0dPbUFsT2RmMnc4MDBCa0tpZjVWdGV1OW5wYnF0U3d2WnhkKzA5MDhPbm5abTRCNzd2Rm96VUhiTmpsM00vSFhDa1ltNVlJN3o5ZkFBN0hJK253ZGZ4ei9DR3RuTE53NnlnZzcvK2l3M0FiNUJVVExiK0hxS3BadWhsT1lTcFNRcEFWdWU1Z2lZR2VGRWtiME9WUWdFb2FPUjRwY2YwZjFBZm51YzAyUHF3dytyTVoyTHYxMEdmdjJSWldoWmNsY1FKRXAvUzJJaFNDSjJXK0NMSDR4dzRaaDgreTlna2cxdTN3NWhSSHZrZGprVzVpSWYxQ1RwY1ZFNHpnc0NmMXdRZjhCaWZEdTRXbG5jQndTSWhBak5QVFVGV2RrdkRsUUNyTXZ5d0RPY2ZuVGFlK0cyWHFSSmJ2MGYwU0p3WS8yZFozMlAyaTdqbWNkeWpSWW9FRkdRdW1EWVBIOFhpUTBSUFMvSFE2RzQvRHpkQ1FNcU1YdnF0eVF1cFBmVzlCQW5QZjBrbFpnTjNkY2hDN1lDWXVyVENsTExIbnYxSnlEeCtGN2ZVTWlObFcvUUhmQm83MUQvenNCN1o4ZXU2em1HVUVHQWhHbk1CQXJuV0dIYWlUNkdZNFFGbktUZTI4dy9rekZ4SElYRW82QXFmZFA4cnlXS0lPaFB6NlVubDduT0hsVmFVZ0tjd0tsS1puN2Zwb3lzY2p3WFVKWWtkVThIRUZpa2FYK3duR0RxRkxDL2xBaWxwWHRTamRUbW1uWm8weE95enVsQWxRUDRCdkM5bGMzejFmZEJmRzBBMzBQamRQbUpUWWZWaWIwVGsxZE0zU09sZzhuU2ZxYmE4ZG9ka1JuQWgxZTlPWTlOTk80dkMwRXFQQXlEK1JOTy9CNGdHUjgvaWhTNHRnWWtKNnJQQ2NYb0hFVnJVTGx3M0NiekFtakdZMzJNNHZOQUdEdXhxMzREODVOMTZsL2pnTmZncGFPMVFUNGRvVzZrVEM4UzNRQmg4eFExcFpzNk1FTWhkZTZqdURyekUwbThLSS94bUpGOXFoKzU0U1MxdTl2VVBMd1pGZnFsZWJtWVpJRWQwODJqandtU0pEekdCaUx2bVZkcDNGTFRVU0ZlT0RLdkJWR1U0Ti9haUNFay9EUHhNSEROaUd6a3hrclpEdE43ZkVRSTN4VmNsbXRNRlJjYWhlck1wbUs5a2NPbk5ETGpNOVdWdWFOeks5V1o4UXhZWTZickxSTGw5eGdWY1JuS01md0xwNTROeVZBUDFnSzZCSkdrQjZwQkRja2hOUkRMRm1JbWlXUm94Z3JaV01DWkg3K0QyL2p2OGR3NlJiWGpRN2FCaUhwWDBZWjR1Q2RLV3JXcENRTXo1MkwwbWNOTU1mY1czRnB3cmtlSlkwRGc0YjlycVhxdE1CWkp5bWdTazFBVGl6c25Hc3JqU1QxZ2hsTHB2QUtua0R4WjNiU3ROcTZmNmhQY0FWVXp6UGlZb2tVNVVtSTJVb2w4c1RzV1BhS3AvbWhNVThNNkxVK1hvK0ZNYm1zdTVzRTYrQ3h1MGM4UWFZWFQzd1V2OGdTaGxKaWhFZlhGYzlqQVFzV2xORW1VYnM4bzczZ0NtR1M0am1kOElndDhYTWdXL1lsTXFwS0p4d3lCRjlOUUU0eVFycXZJTEFkU0FDL2FwMTJVL0VWWm5JTVRva3pKNE1TbVZwcHNkOGhDRlU0TDhuYXlrMm90WkxXd0ZSZ3IxdU1Sdng2Rk9oL2hPVEZrbUFvMEVtWnVYRmFnUkx1SDlSUzZTdG5OOXErNmdtNmtaV1V2SzdqOGFoWTNnTnIvSlgzanZnVk15MTFCNTFVODcxbk1yMjJKZm54a2JsMmdRcjZoVDZ5ek1ZYjJNTTJ3WHR5U1h4SjQyRHNEZVdFcHY2VllXc2l1WjdjVVg4UGprWTVMeFhpaG43V3BnZDdmMmpURGtUZDg4Y25FTEsrcS9HeGlNZzU4aVlsRVl1SlhSbGc5VEhrSkNNZGZhU0QrNlNWR1A3MWdaTk1MUkRCMTdKNHA5dFkrM3cyK093amFOYlVIakxLRkl3MXM0elJvTy9WRGUxSEpzNFdFZ0dJVHE2OHBZT3ZWMml5V1VybnRBQUtZWGpQb2lsZjhDc3k0NEVlYlZVc0ljSXEwWFpmVkprSk5WZGEzU3dvWEVDeDFNL0lMY1RFbFh0cHA3KzNiVEdkVGpmbEdpaWJnTnhjbFVTaWlnTDRpNlVBRUNYa2NCdUM0bk1CNVhWclJBNmdvaU5LaXJsL2FhVy80K3ViVnBaVDlqRlREaWNIeVZyOVQ5UC9HZDdyKzAvdE8yWHBMNU8vTVo1b0FGUkNyV2FvNlgrU2F3MmdLSFpGeGU0eXJZVzZleU9BSU1jTlV6M050OE03WVFuYno5UWFBNGliaTZMano5aTBERUF1OVA2SkFDK2M5Q1N4RXJWM3pnaWlMbTI1b2VTRVhDTzVIZmRReDEzNmU4RjdVWnhyWWlBc00zWlpVZEFUSUF2bGFlVnh4YTZNK2ZKbzJrS0txa0dMQ0lqMUQ0QmkyM0w1VHhUZWRFUkF3Ymw3MGdqQVFsSVZuY01IYlJMY0F0MnZETmVBM3I2eE50VzdZaEZzZ0xGdytBTStBZWdjSDk2SDNWTnUvbmNXOXJSQmEwblJkd2xFL1IrMFozRGdBNU5PdTlKSHcwUkFtUGcxZFRYTi8wT0Y1bFVQYy9LU1RTZWdhaDdaeG1BSkUzRW8zbE5lL2ZPSi83ZU1oUHNpbEppL0RoWG1PK3p6YjdKbE00WXpHZ2VBODNxbzhQei9WWVdmT0ovVjhxTHRDajNMYmNLcC8rU05qKzloTlU1TjdPSHcxd25laG04c21VL1RSRHE2YkRGN0FOR0FPMDJyNEt5MHovQkpyRWROaUZSZ2RhS05GaUFGM1VUZ1hpMDNYN3I2N052OXlkUHRsdi90S1JCNHIzSTVnQ3diaDRlSllUVDNKQXVROXR2RGdkRzFzREorVlNZdTN2WkkvTUZZNGpFOXBRWFI3TVNVbXhrS3JMREtwSnhZRlF4cExqb3lBV1NESVk2Mm1hVzhIY0dONi8zVHFGQTBBYytyVXNHdnBrUzVlaEhEaTYrc0UrM0VzejR2RE5XamRQNmpFZko3RlhmeFZKTnFCTnpkR2RyeFFMTXQxVHl6TFVUcjJqZjZBbzZ2eHdiN3B3dkVMVk9XQzhTeWR1bHkwSnVkNzhnVWlXanJQK0RwK3hnTGx5OGdNTUcwTGZ5UEk5czRiMnRwVjZMQnozZTJ3MXg3NGlpeGJEUHpId2pubmo0RUNPWHZkZmdnamtCS1V5eFdCS0FiREdzc0docmFqRGxHcE1tSWhpQWI3TEhhQjBUTnF0Snd2U2llenVmNGdlTjVuWUY2TVJrMGdmbWFJM2JZeXhSSDg3QWhsVGp2NEk1aWk3aFowQWNYOGZxa01iZEIyVEU2Y3FtNmZnaUlQR2p3RWNHcjdjUklXRG0vM2sxSVFUUktRZHNEYktPMjlIdHQyOXV6TmNvQUh2c0ppbVllUUx5OFducUlwM1FmTEtRYlkvb2Y0eXN6ZVBSTGIyQ2p1VEQ3MVBhNXJ4eXVzK0JxNDlpdStxekNsbG5lY1FZZ2MxMklRaVFWMy9xZzQrSTlvZy9qS0pUeFJtVkpaekx5VldMZGVibGd3VnltdmJQdk10cFZ5SlFjdFEyTTkrei9ZNWcvWnBtV0VRa25jM2RONE54a0szU2FIK0tsNEhyTlQxaFF2WncxdGNmY3F1WjdjYUhYM29tYXNzeGR4YW1EenkrUVd5UkJMTTd5cy9EeFhtaXVWa21uenBCeHk2QnZXN3NyNVdzdDdHMUFlM1lJUDRkcTFhZTEwcFQyeWV1Qm0vUFFuMmRQOUNmbEo4bmpiRDRmd3IxUW0wSGVCZGlURWJuZW13aStHalpjTjQwV2ppamZIR1ZYKy9JdVlKWDBabDd4bzRNMlp2cXlPK2YydDJmY2R0ejNrSEdkdzJ5M09IdU1paWV3elF6MDNtSXNmK1B1WGpYRC96ajM3WWVCVjh1d3ZKaEwvWVliVTVMc3ZHNTQ2N1dmUC9qQ3V5QmVUbHlXZko5Y1Nld1g4VFp5ajlDT2JKK2N4UGY0Mi9GME02WTZzaSt5NzNtL21JS2lMTFhKQTF1amlNNEN5cUQwNmRad24vOUh3MkJpdStwNDlma0VScGdVK0lDaTgxZVVWSWNnTFlHVGhsbjRBdWxNanMxZmJzdFB4M1FHZWIrQ3IvSUlRN2ZKOFVKQ0ZVN3Z4RHFaTkJYd291aVRnR3lxQ2krbndHdTRuWXErN2swZ3lTdFJRM0d1aDRncTQra1pKbm1paXBMOUtUWUsya2NOemlHc2RMYnBtMGk5RjBYaFNwVlppYW5JY1JVMUxWeW1JTGZEUmphcGJ2YWUvSThvZzJQdnJJSkMxU0RxQ2Y2REx0aThlVE9hWkQwbytlUkRsd2cwOGh0dDBuNWEyNVlTL0VjNWRqMFFDeHZHVW4xd1M4Yk9OejRuRGRRNDhnM25BU1JvdHJOeWhHSTF0SzRwcmE4MTIybFRHVDUwRU9ib2xxS3NFeVdhUnM4clVlUkJSblFYOFUyQnV2VE9iNThmcTVXSys5bExNSHhOQ0J6Zm5kUm1BN1B6ZUF0Mi9kc0haenhkMlJxTUFoTGZlbWNPWGdIdnFZL3ppWEdjNXpBRXJzdk45a3A3ZmZEQWt4UHhXY2U5OEZyTVdlbjdoV3JJZksreWR6ODJDZXI1UXhsZHNuZXVzbUpTZVBNczlCSjd3aGFtWG5vdmpVdWxyZ2NTV0p3NDNIc1NBZTQ0RWEwTG84Y2NSM29UUmN3aTgyMUI2WjV4WVpVOCtoNmhCNWhOUFVITk1mRHo4ZXc2YXMrSE1UOXZ3dUpnazBaN05uRmZIVmdodVVMa0ZDeDVmWkpHaXJCRDhHL3Z6c0UxL1NXVUQ3Qk1vSUxtVEo1bVRKTWwzYUlrTXZrLzFzZ1BBY2ZZT3dPUGNqdFBuQWZzRlhZclppdzhRUGRsWlIyRkdNd3hIRXRNT3AwYTJJYkpSYmVodEF3SG9aQmpGSHNBOWlyL1NuZ3V3U0pLNHh1LzJ0T0hkZGh1K3RLRW0vYnA3b2dtdU9UWHYvZHA1RyszSU1JQTdqeTFobW1HbzRzUHVRL3lRMWFzNFpGSUtxc3dpRnljNzNkejMyWVlrbnVQZ2xLRVE1NXJCcFBlYXUvdGN2NVRaaUEzV2RaL3Y1dUg0cVpnTkhhcWZPV1RzTkR4SDg1Rys2UlFwR3o3K2k0WnlHNmtEVGp6Wis1Mk1zUk1rcVFEN0wzRktCcis3Ri9NYytBRkIzbFpJOG5rM0IxYlpsaVM5Ymo4UFRydW45Rjd0RnpQTTR3M3R2OXYzb08vbkhkdkJmaTlZdzNLMG9WNFpsck9ob1Y0YTdzWFNjR3pQNGZpb1ErZDd1dXJMaHZJMmtuMGJEY0xvbEdiN3BTKzVmZm1SL25Id3NGdmFUNTd2WHdST3VMMzArb2pjZFc1dXF0K0Z2ejJxOEZRL2U4dzk3dmdjckFOQVpmQXBHbjNMZGY2eEllV28ycURESUxiNXVRcHpwNlF1bEZSa1JEdkVGclJucy9tRkFzZ3Y1TE9ZblF3b29pN2dsVlRRUldVNkMzTFRYU1pPMzF4cUZCYnloWVZDby9odFl1cmVPeHNKS29iNFo0UW0velBSVUlLUmJHUGFyaGVoclV4TUFSSFBEZlpRcW1SZVlLRDdGVlNnSVNUYVMyNlFHeVpNNzdEWUVzd0hHaGVud1ZsY0lWeTVQTUNQemg0QjJXbHY1VEs0V2tFL3BqZjlRWENFVk9uYlJWekZBbTVMby9Udkd0bmg2dVdtOStPV0pJTnA2WWZFUVArSFVucWdINE8rRXFudnhqcTgyUTYxcTNUeFRpVlZ1WU5VNVE0cHZmMlNldmYvZm4xcnBMNjEvMy9xK3psUzM4OWRlbjFaVENvQmZJUFpSeEI1emdnSlZqK0grVzdxL3RUc1VDREdQMHRka1p4cU11SFI3T1FzeDZrODVEMlp3OGdJbzhNLzB3c1prZ1MrWU1IVTFDd1RQRFZIWkc0N2pNSUdPdnlUMEZ6YzVTK1liSTN3ejZzK1gzQm9Ybk9kKzBTaVhtc3g4SzV5eFRZeWFWT1JMeWJ4RVBzMTAwd1BiZVB6STlpZmE2ck1EUk1FZEVXRW9nQ1ZRR3dzTENBeHVDT2N6L0lUa1VJQ2FnclVCUWxJYWlGK0c2Y3FBa3lHd0FrM3hNVi9ZZTZvUDQ1cUZvZ3FRY1ZmcUVkNDhUc2l5a0JWZ09XRVVUZURFNmFjTUt5Q0Vna3BvVkFqckc5c1gyZDQzbmNsQkV6eXpjTFJvRUlVSXZZanEweGx5cmFrZDREU095MGJUYjAvZzg3YTNySnRLQ2dxZDF1OG9PS1dDRHBVTkpnb1JDYjRiRDY4SXlnaUlUd1dDeWhRd0gyZzZNbFE4cXdkRnhjbnR0c3ErRWdJMXo2aUZDd2pJWnNUUWJOdUpNcFFVR0VHNGRieWtYckJqMXNmQlpZVzFjT09EdjlyTko3R0pPRTJtb1BMK1VKL3JMdFFLbHNkQkUxUTErcDB6YVoxcUd0bEsyNG9KMENNVTdnWU9LRVljZXV2MzlVUGt2R3UwRmltaUZjTmptc0lRb1BqamhsS0taT3lzUVNYd1JyT1pja1lOM09SWEFrVEdSRUhPNHZhcGJzQnlmT3dNa2hjdDlaQXQ3Y09UcWJDcVhBdmk1TVV5WUd6Sk5kZ3dZRlo3QXlRWFQ4U1RyRlF1dmpMdEROWGs4T1VFSGR3cGtsZGtpdytGSHNPZFhsMjZSN3l5cm51eG1lbHpnM2ZtakxoRjR4bDVuNjFHNWdJVjQzdTFkZDNlTDZLbWNibFpZRmdMUE1ySzBQN0Ewcjgzei9QU2M2Kzc1TGptL0ZVNkwwQjA4RWpUWjd0bkNlK1dZYm5sNWN2VU91TmdjNTYzL0djTzN3dDJmZGRhc3d6eTd5RWVvK0llUmE4U0oxSEJEL3JmZldpbGI1SUhEVCtVb2FDVnd4NTJjWEd3cURZL0hzWEd3MWtuWGtEendNUDBkaG9uWXQzSGRqV1J1aVdXeEJxWTU0VmI4Tm80LzU1RDVDdEkzOTlKMTdiNG1UMnNkaUNTeG44UmJvS0VPNmZyTVdWY3Q3UkxETDVJVjVEMWh0WE5rTHFVaUJoaVBHRTRJOEhsdFJRNDhycmdRUkVEWEs4bVRKNURtcGRmRmFsYkYyWG5KdzFWTldZblVvZXRrcFZYUGdGUVRDQ3NvQWtQUnpXSlNUSVFaODdGejJFM3hGRmxISUF5QmZzRDFaMGdSMXdWY1VDc1VsczJvaFNhK3R6aCtid2oyMTZQOWVIaVFMZG1heGxaV2NvRGdKWW16dDBqSnlCay9VKzJOU054UnR1S0RKUUtkY1BsTlFqUUt6RFNnNDE0cWo5Szk1SmhPdTZUNlViejExWktYM2M1UjdZS3Z2K0Q0RmJjTDhmSUxnWEcreDRiT204U1VXQkdVeE10RzBEMzRqcEdOMFJuRmY3bytNS0ZoNmV6alZ6N1Z1dUlScURmeVRKdFVoc2kraUh5ekkvamhjdEFLRXd3Y3ZMSW9yUmNoa1RZcUVNTDgzS2ZEcUU4eklTT3lLS0l6Q0d4SEZ5T1U1K1JMVWNjOUtEZXNRMEkvcURFaVJnbFRqOWtEOFNhbDhqU2RlMFF4SC9oMFFva2ZoY3NPLy83TmhSekYzY2hzSzducUNMbWtvMHZLS2JwMWlvdEl0YVJyUlpKRGQ3ek9PWmdHSXVVS1I3L0YzaDhWM3BmMjYyQXBYVWlIamV1QjhkamY5OElaVFJGdVZtT2xhVXlSNWM2dVRsZmJpL2d2c0xWeGNDWVo0ZjR4WEJOQU1RU3Z0RTVJY0IwMlJXVmVGQWRHbUdCam9yVW5zcmxwMVppaDRJUUQvNklRdllCdGI5WXZCQU5Cb0lNN3V0c0JrVS9VaWtEOEEzWW1XQlFyMjVxcWJvWFZqOE5KWlZWNXYxd243N3liMTFGZ3JGbVFjSUhndlJON2g5d3VDMzMxcUxmOVp1Y2IyeVVqbFBvMGk5Qnh1RnozMHoxV1orME9EcmVCMks5MUZMZ2kwYm8yU0JnaDdiOGlFeThNUWhqREd4RDA3UzZwd25qd2VQekd2b1hxVHg4bkVDL2tTTUp1bmNmcGFFQlFQSGNJWE9qUUtuQUhlbEZNT0VDRUhUVUVoam1yMnYwdFZnTzg3dmNVMG5SaVcyelovVHJndTFpR2ZrUW9WbkxScGQyMzhiQmluengyWUtFOGtpZUJzdUdLN2FYTzkzekVUQ0JEdEZ5Y1gyWXJoK0RlckR4cUVwSW9RcEc1eGxBSnNZUmE2ZEFoVVoyMFJwdVFLK3FhUDhURnpvWE5ZUjRqTjVaQ1N6ODlYamdNT1R2YVNlVkNVNWFIRGdlSFUrbTN3dDFpeHBhbWwydHFScXBXWk1iWXhWNTdXNDRvOFpLQkpCUnN5dnhMWDU2bGhEWmZXaE5QS2NUU05UTFVuZjE1NTU0THNwQ2RYRHFrWVVTZVJFOEo2cjhyZy9yc3dwQmp3bWhhVmptTGZKWFlrTUpYOFZUdTRMaEp6S0llVSt4ZGh6MEREUklmeDNuTVNETm8xRCtPK2daQnF4TVQrdG1oNklHeWJ0cDU5Zy9tUWJYajhOYW9WQ1VMZlRBTDhJelBxQnkrUmNUdjQ3R1NaQzRHd29nYWZhMHdGVkRmU09CSEtXbFF2WThlb0k5bHZIdCtUYlJmQ1BRS0UxQ0FxVnBuS1F6SVo0aWVORWowc1dhWTdpaExTYVVSSWF2RVI0b0hhblNUaFVHbWFsekFLcmNKaCs0ZEtBcXg1anJNSXh4WmplTjJXRU5GMXRKRXNzcW1JcDJWQjFMV1JNN1pzMmVrYVhVL1BSQ0ZpUFJQTXExMzJ3cWdBTnpjeEFuWk1yVUVTZE9PL240MjFKQUd0TUZXRW84N25GdWhnemRVWGFuVTVvNU12VkV1bmRrcUtiTVhGOGEyNWVNZllISm10cU5CSUlSS0pxYlRKUzdpQ1pUOFFGR1hYS29oOUlNd2pOU01EdjhyUWtudHdtMi9wNHVGY1k2dlFGdXFWdHgyTVNpYmNBNlpzU2pkdUt1OGJiQjlsMFkzRjBKeXcyMGxtak54TU00WDZ3d01jaWhtbXBCRzNkYlcxeUxwcEhvNXVMOHRHNUpHN3ZRM3BDd1UyV0Z0V2txa3UxU2Z0OVAwVGpVQks5N3VKR0xMQ0xRbHVkRDkzci9BQlc1d0h3T2g5T2xRZWJTcmRwL0JjcFY5ajE3Y2NqOUxodnpYZlNkOHIzbEcvZGQ4WjNGbE11dUxNcG1VajRGbWFvaDFkU2kwV2pKNnFPRFlMZGYrYSsrRk8rdm5TeDg3ZmZlTjExTjI0WE9HRmMwT0JCUEhmQzZWdW5JRURpUWFqaE11N212bm4wa1RlUjdUMzFGazhHV1J0Lyt3Y0RwNEJEMjJQNDMzWkJoenRFZ1N0d0N0d1NERzZCQ3M0SzRnNm92K0NjZWNuSjlUK1Y4OXk0bkYvM2xYMDMrdDdodTU5ODBSMWlyMEQ1R2hibXd4NzZrV2FuYVRYSnNLY3NHU3pBdm1uNE5GZDJMTVRKbE9ZRXhNUHpBRWVuQXlZQTZsd0VFQnljdWI4b213bGx6eDRsWVNxRisrbDMwNGo4T05JZzlxdzNBRTdVUTluSzVybGlLcWlKSENELzhUK2FFYlZncWppM3VaSU42U0x2T2JMTE50QVpTTUNSR242QWZNMDE1R0UxUmkwdzd5MWlUOU43WWVET2dxeGJxU3RUbGk0TDNQa09ISFh2UHQ4M0NXSjJDOFMrSUVPNFJ1RE9JUkVHVkpwaklQbHVoeEp2SVR0YTF6L1FJTVpnamFTbi9vWWdoeEF2SW1wVWcrY0cyNXFHVkxlTHEzc0taREZOMzhQendRcU5yenFQS1MxZmljYTd5MVBEZG1hSFN0OFRYbmJvQkR4TDN3b3NVZThRQnFCS1hkVEwwQUdJYTNPVDFjcDRpZGQ1b1BsVGhVd00wOFk2WDZwWGFzamdBaFAxK3g1K1QzM1N6eG05RjFsdGlGUTNQMHVxOVhRUndqYUVJS3duVEQxRjgwVlJRbHNtNjFOVDlja3RTTmFmWU1Zck9wbmducERBaXlIU3poRHY4OW9jelJKYXQwUE45VWN3WUxTeUk4b1JGSE45QW93Y1BidXJOakVHRlFWK2pDUmoxZDNWRktIaVBrcjN4dXU5SHpJRmFZOG9QYmVVcTN0K3ZhLzIvUFZLdFZyOWdtZC9kNjI4cGIvcnlBY0oxZ1NMRTRhcHNFcTVQejNOa1dBQ05nZE1yRm1wOVRReC9tMHkzdlJmS2s0WXJzL1hTWnl3emtBSERWYUZTay82VlNFV3VqYmwraksxTkcySXFIQkxlL3M5eTl2dTJiNHhWTmo0WlhFeTVNL2FacW1ybFhFN1VwaWdDSG5laVJSV3lkSDcrR3hld01Ia2lPTzVacHJHNUhLRkJjUmZ4c3UxbzRFZEZ4NFBvakNoTEtJR2dVMGdFdzZaZ3NqaVJtM1FPKzFXbWFKMU9lQ21hUUNCejhHb25yOTVrd2U2dk0vNnp6SDdpdysxeHBDZzhodzBkSjVIZ29qN1h4UVF6K3NHNUhoVlFHTXRURDZxYUJiUEU2bFpwUElJbkxSdmk1TnFYN0E0M3hkZ1REQ2prS09hc0ZTTXBpQXlSQWlScVJHY1JNMUVFSW9HZ3Fsb2NVblFPRlZIbkViODZEUU82WnFMVjNNT2ZOYVg4Tlh4K3Q3SEpIZmo5ekJKSHU0TmZnaXpvOFFvTHdiVVEyUFVrajl3VHVSam1PVWdpRUc4S1A2QTUzOGd4bnI3RlFOUGwyZDQwZWc5VUNTc0UrYit1aVJ5YlRmQWk0eDJFdm1BeUIzaThLLzNiVU5oS0tLS2NXNGRpZUd3aU5iSlB5SlRlUDJOMytFZytLWnZqRmsvMnRMU0thN2REeTNGVkM4a1VDRGJzakxHdlMvaVU5bm5RUVJyRlp0enNBZzBia01RSnNkV1Z4ZkM0YkZKSnBlYmpOUzNSQ1pKTEZ2OE54blpVc2M3dUZ6QjU0WERDNnVyK0R3QmhDeUVlcnVZWlFsNEJvWHJnOGVybmt0ZjhkeXlPdmkwM2ozRUlvVjR4NUl0dmw5L2ppSTIwMDFHSjdZSDNJWWNpTkFoS0pXd2JjeE83VXRmcXkrTVV3T1cyczZyZHRSaXJ1RHlNOHlMY3YzMjlIZzlIU0FrYmFDMnMxYmZXYnVkZW5uUTVMR2daUVViSkxGalJySzZYSEpOenYvMEN6N1d3U0g5R3JYRmkxQkx0V1htNFUwSHBQMmkyVER0UlBwVDhJQmtJb29jbDkyT2t3RlZQQXdQNllyOEdBekF4MlJGUDJTOGhCa0JxaG81a2JQMlc3a1RpdkYrTGFEaFg5ZmVHTXJwT0Q0Zm54NC9yUmlTSTBpU3JGek9rb3lqRWpsSms5akc1OFNaWi9QUE5jTllRSXgwWWRhTU5MWWwwY1k1bENiMEJzVzJxUjAyTmttWjJ6QVNndEVMQmZTbFFIVk04VnZWc0FJRmlRdnhpbUphbE9aS0JLMnhZQzFGZ21CWk1RM3hFZ2xIaVRUTGpoWVR0RHhZUUx0MHZ5b3BpYUFxUXA0VE1xS0txZG84K1NnTFV0REtGaTBqb0NKRk0wSTZramgrakllY0pQa2hQU0dQelBpT0lSejNReU53M0g5cVRSK0FlMy84TFRkK0FBMytoWDkyODVsL0E3WEpKbmIvUHRPNzRwZ1ZnczF0UitOMXZvMno1VzY1M0wyY0pNKzJwdWZuYXExc2pWV25CdGJ0QXpqcGZkZkljMXpha09aeUIwaDlEK1RtUEhFd05TWWY3M2psNFhpdHhVTitDdk5obUJMREQrMjQ2eHYrUktYK3dObWR2dkh0TjZiNVpEaGJlM3N0RzA1dTdZTVRlMGJHUXIzUnFJY3pvbHdveUdMbThUNFFzbXQzVCtSVEpJN0hMU1Fhay9NYy9FemtJRjExS2hHSzVFUzVRZUlsM2lTa0grME9pN2lQTTVhUlloVzJ5TXVQcEprdk1UVUdHTzYxdmxUOUdxWnBmVDJmS2lLWTVhSEFDMmJCQ2tSTmdlY0I1RE5RS3FZeXVYbzVGTTFONWF4Z3FOWmloRzVydlMrRFA4MzB2WjhVTytMRTJEeVU4VG91NExrZUN1UFJNWUZQaFdvQ3hMc0NFSUFNTjQ5TmlBMGplb2M0WnBKdjN4d1QzOGFqcGRvdGhLUzhwYlpreTdzSi9zTXBPZ1oyWE1vb3VCVFVNODlJK2VZaUdTbUxxV0k4Q080S3hvdC92QU9KWlJIdElFT3hud1duUE9QbmxRQVpQd0UwTlpZTnh1UEI3TmpVMjRkT3Q3TU9EalhCSzkzc1c4UlU4VjBNSlhrY1VKUFdPV1kwUUQzeWlJT2VIZHFiV3NCYVZGUTgyRFJVeVJCTTI4WU04VWx3OE9uelRtYWF1aXdzZ0xZVmJYYmFWbk0yQWo0VTRSQmMwTkw1VWc3cXFvcWlTc293VWtvVXFhb09jNlY4V3RzTUVXZWw4dXd6eWYxVm94R2JqOFVhU09TZ0RGVkQ5U1BPNENSRE14Uzh6NGxBQWRVeUo2SnlGU2kvMUlGS1BLWENvQm1FVml4cXlDSW1pakNoSk1wR05HYlJZalVWVjJGTG5VbnZKOS9aL25UankrdXg2dHBhTlhZY3MvMVJoR2NHS0VVaHRDUW9jQkJGY2FITUN6SUFzc0MvdFhmZlJ3a2RxZGdqaHlzWGVQZFBZWElsZ1FtSG1SbE1ieVFFb1RHMGY1RlJzUGM4bHpuN3JzK1d6NW5Ud0VWYkJFaHN6dkhMcmlYSjkzZTFsaGVtZDlGSjdSU2QxT3dET09sOUtWVG11SHdJVDJvbDB0bWxISmxPZk5EV2g2M1p2bE5OR3NWbDhMbldxT2RhanVORHpzbFlyYmtPZE05YkFDWGlUVjVoRVZScFRidGp4S2R5TTBrK1dTM1VLK2xxUEIzeEE4a2ZTZThjcTlVMjEycTkrOW0ycFVlblFzbEFHQy83NE9Wa09CWU42M2o5RDRNMSszS2MvSW1TNExpb0FpdnhyWmpJOTIrTlYzUnlwZk03dmpVV1VVUWRDWWxBVFRIdVJuNEFsR2hzMlZCcWdVUmZ6aTZBNTJrMEJ5cXdiYnVPcjFQQS90RDZDcWlvYmNDQ0didnYzTXVyNEM2b3h1WDdPQTNjaTdTWUhFM09Cak5HNEZ1eTFKUXQ2ZW5DWmVsUUtSeUFXZ3pzdVJkbzNIMEtYZy92NURUdVhqbW13VUM0Rk14Y2x2OHR5Wktia3Z5dGdKRUp6aWFqK0VqZkpvWHdlR0dmVDdZdGZ2SGoyZFBKMXd3KzE3dExsbWZraFBUb2p0WlVPaW5MZ1lnY0ExL3AzU1hGNVliQ3lVL0tzZkI0WlhicTZvanNiV2VDUlhXazA0S25YVlJpVUNtRHM0bngyclhaSWtTUlAyS3RXSy9VSjRxWkxCblVTVUhJWm9vVDljbzZxL01mNGRtbG1MMjJOdTc0VVJJNWZKdHdNcWJWSWRGSGNCOVNEK1BvWU1idTFVcmZaaXRQdkUzd3lLYmZYZ1hYcXYxM2pZQVVpMXdCcENDRUI0REFIWkdDQ080RElyZ0poaEFSRWVueFRjbmFFNHFjVlpMeWY3NjMzUWdseHJKS1NuN1hwbytwNEN2ZkhVL054OE1kSUtJZ3VnbGZ0QStpb0hRRXQvOEFoRUVwR0IvWDQxSmc2dWVWcEpKUmxCOHZkdTdVUTF5dm1wWFZEMjU3cit6WXJId05uTUx6OFRpUkU1dU5HV3JXWklmckpMSEI4U2lmSVNyNkNPTnNDTXM2MjJuaGpHbHJQb2k4aDdEYzBJcWVDWlN5T3ZBclhjVVA5R3dwd0VVdGdLZHNUQmxGT1FsbjhKenpIc3hKcWZQVTRIMlhHVkUxOEJzMzU4c2Q3VlhGNzFkZTFUcmwvTTJ5SkNtZjRMbFBFbENFVDNMOEovQzI5eWZQRUJ3R2NFWXh0a3pPTk9adG5wTDZtZFI4c3pRR0V5TUtMa0dKV0hFdDFmcW02Q09BVU11VnRoMFRDQk9XN1NZTmlRVkJ0ckt5ZWg0MTQxbW1MQVQ3Tnh6TEpDS3F0VzE2ZXB1bFJpcXpSRTBKQWpobE9zZzV6NGtzL3FPNjJtUzZ5anMzSGtQaFJDYUdqOFd5OFF5OTN0VmpMT001dE93NzRMdk9xMVZGVVlzMUZzOU4wZWFzbzBGMWhQMlhxSFFsTWd4YkhjRE5VVzFybzFDZnJRdzFLam9UNUJYaXBYcytQU3d1OStoZ1o2S1pnYWJVQzQyQWdNUjlJdXBlb0dQd29iTmVYZkpaa01QcklSa0RiMlVFWE1ycnZLUTNoZGV4bjd4eEJ2dzUrQTA4NzZRcFRwcXozRkpNMW1aL3ZVV0ZqZ1crZTVxSFBGNHUxYjlQdzZTL0ZoMVAvMWlsSmIveWJ4N2RCK0JwdkhKaEZrRDdVZnFxVENoRWp1RkRhUHVqK3hodUJNVkZ0YWpGd3piZkx2elZObTBoNGdnUWF6QWtVQUVYT0hjM2ZSMU9tSmE5M1M0NCt4TXFVT1NJUUxIM293MkgxMmlnajNPZWdIMjlzeDRua1kySDZYei9CdEZ3VWMvVlF0N3YxVWl4T2xydXJNSUZ0TEJ4bEltMG1UajdxQkVtenA1Z3pUamFwZG9sZXFSNzFHQ0hpZi9aUDJDKzVSeDQxaWRUN0lreWpkVG02NVFyQnNBZnd5S2dPYnkxeU9LQ2lOb1R6OUUweUM5RVJNeE1ZdmwwOFBwdjR1azdTcGlJNzRISWpwdURlQTI3UEJBdDdOamxqOS84T216T05SdmpEVzVtMTNSdThaR2RhYTFldWVxTFVXWExqc2tyYzFkY3R1bmhlZ1ZPVHQ3d0grZG5zdmZ1bkM1c3VmVjBKVnMrdVgveDFvL3MvZmdzTkNiZnVaUU1qSTJQeDhPMUdRV0FoZkowTVpOU28wSHdzZGJETzRBZjduL1FucGVaalphSjIwQjUzYnczTGdvTnAwRVJmNmxDZ2lDbjRYVU4rSWlKTC9NRUlBYThhN0dvbWpDZzVqZFV3WjlRelNnNFJvd2swV0hxRkhZWUdWK0tUK2g0NGs0Z3VTQ1QrQ2pJcUpFNGxMMDNmby83QUY0VG9FK25HRjFiOFNoYjlkM0VrQ0dKelR6UncwUFVvV0VDTGFxTUp6VkJRL3VpK3hteUtjZHFGR2hOMjUwS3BHZzE1Q1hZNEU0V0lUbGVTWkpLYzdHd0VwUGVNYlBaMzByc1hTSU5LS2R5b0tQTTFrbSs5OS96YnZ0K0ZmQ0s2RTlFbFBzNW9sQ0hmNGpaNXA4OGc4SlF3Umx1Rjg2QW01TElVSmFPV2xVTkNzcS9UdCsycFZhcGJscTYvT0VLYWZiaDRPYThKSStQWlpvSEUyUS83UFNMY3Z3Qmp2U0hJZDJzcVFhL1I4SjMrZ2ErcDQ0enZhMDQ0OUF1YndBZmZVY2ozOUR3NnhqdWZWc0c5VzA4ZHorTDcxSHpMZnV1SG4ybkRuM1JkQWx5M25XTHhvK3REQnlnblVybXQ0dU9qQy9UY1RHenVUbEZPbERkdkxJM3dycFhTK1hHRXFxSXUxT1JLaE5ITGphQXR0UFJnN3UxY3pSREIxRHQvbDJYUC95ZjdQNUV1SDh6OHlFcG9Sb3dlZlgwaU1FbTJEalB6L3NLTGkxZUtpUFJBSjVRcmN5RDNoTTBvREtNeTkrOFNBaFQ3dGJlMzRWQ3ZYTkdnTTVERFB5SVpnTkc3eVVIR1V0K3hvRWJsWC9mTFFONzc1R2tlMkRNNkgyT1JyV2lUcCs5UDZiNWcwWU05djZyRjYvVVNkYjZXVThibVgvU1ZSVFJhVkNlT3JSZkdkcnZEUGFKQnd6SzB5ZXY5U2c0TkRoT0E4dDY4NzhnNEgvZ2Jwdy8xdStIL2J4b0d1QUJ3NlRaZ0hGa0lPNnFrMTN2Wno4KzBCR3ZFYUhFYTI0M09QSlVjQStWMVNReGI3VTR4S0Yydk41WG1Bak9sL3ZPVVFaZ0FEeDlwVGhoQk5hcGh1WUlWZE1VVnBMVWVqdTVVdWhuUXliUENUVWFVRlJjRUJSdzNENGJKN0ZZZEpVTTk5Vm9ySGU4bi84QVlUelRONUpGL0oxUUdPZEJIMVBzNjFTYjB5THJVdFN1dEJPWDJiWGQ5VXFmQ0RsTXFIMWJvd1BXRXdtcUswa2tTTndyc0liVC85Wm5Wc2R6dkthSlhGNk41U3dMckUzZVRqUXJ0MCtXRTcxMWVubzNVWDdEMStkZkgxdUZvcWpCZlNxeDRZblorbGNPejhrMTRvdFljZzBmQ3NTQ20rQlVjcGhxZCtsWmkvb0ZkOXJSU29Ib3lLYUk0S3RpQUFkdEU1d3plQUV1YXdtNCtITmFpTXRXay9FQ2w0MkpIeUJEOWozaUIrV0FzS2tFdFMvSDRGSTlQWmZPeE9YWnJmZ1Z0QTVHRmxOUTUzTlExajRjVVA4eVdRYWdPRnZpYzNTNXp5clMrMHhPU05VNjZibXRUZitLZWJpRFg5L21hWi93eG10di9CVWUvNC80Skx3YVU3dS92c2VZYTlHQkdRZ2krZWtRam9QbzI5c09iQk1lQ0hoc2xBalBiYlU3bGlOby93R1R6ZjNUcDBST1dCVTA4ZFBGeGMwUFRNeVlhVlVySjlMbXpOM1RCd1VPS0p3UUY0V1UzSHVmRWplbGNQd2I5UzExL0Z0blFybnFmWUl1M2lGeS9MV2RXRFErTWZQaEJUbGhKTXBXWEV3dkNiS1lGdmtJendmZzNaSVpseFBtNlRTNXRHN3pIZytBSjUwNDlpVzNOUXlJaGNFOHpETEw1bGxiRWwxR3JKelNHbTBxbys2QU5lWUU5MUVSaVBNblQ4N2pUVjdVeE5xeFl6VzhlUVR2WHZ2T3UrOSs1N1cwWEJkMjMzVDk5VGZ0eGxYT01yZTRXMFJEbkMwVVp2RW1Md2lGZUx3Z0NJK0tobkFnaGY4ZEVFZ3BFRmNzL0c5RkJJSUhsNHZGc0syUGlCeXhJZnlXbXhrQWJma0xwaWMvTXJBWnRFUHYybnJ4Z1kyTEEvZlBzWTMzVnVTWUlGVHhCNzF0UlZCd1J0aTJ6ZDdmeHJQOUlkdjQ3NTduTkdkL29IN3hFZjJUYXpsNEx0NWFGSHRyekVCejhIRXNLQlhEU3NVM1BrS3dVb2RuL29IN0hFbUZzMlFuNjJLYU9WZ1JPWUxwd0hBMzdjaVVUT2N4ckFOeDQ2Qnp2bFM0TVowN3d3ampOUzhSdlIySmZ5R2lmd0luU2RHWjNEU3gwM3EwZnpqVklMV2U4MTNLZUJFdmNiejBQblB4QVhOazVJQ3hZMkNRZUlHbmZOZjREdnR1OVIzejNldDdGNUhaMlF5TWJVUHRCd1U3MUY0L2wra1RDdjNZRGpaaTJSSm85blB1dlhKTlZMRG9IZkM4Mmx6aW1oa0NyRlJva2IxT29kTGthTWlTaGttZ1QwVUlqSDhWQmxDY0VDQUl2eU1Ja0ZDSENJUm9CeTVLTzhubTZocUF3aVlCZ1hwbm5PVHdOWFZxTTc4VDlYN3hnTFJTRVlrUkRzZXI1VlZPMU5BZFBKN2tlVUdyNk52UUFlQ2piT1lCZ25CMTdiV0N5RkpaUEVDTHN6VDlDaW4rQ2t0WmNmWmRaa3d3Z29GMlY3YXk3d29FRFNGbXRydFpCeVB2SEpXMXBhbU9sV0NUT2JyREtKWDVNR1FOOHMxaC9zZlZhZjQ1UW9LNXZFb1k0ZFZsVTBEb2ptcDE1VnVoZHNsOFFXczhhWWVIMW1DMlhGNVozVllwWjZFMlAzL2pDMmFwSGZwV3B2RnBOdGY2WE42VllTTG44RXI3Q1dJVjR3VEFkdVNxNXRBWHdoZUN1ZUNRMXJjU3RvRU9iUEZOay9IekJGNkFqVDhHZk9EZ0M0eklEWVhEWWZlSW5HTUlzTC9FTm4vbDRYNVJvK2RydUh1ZkZ2a1R4d2p0YzZ4THJSNjd4Snd4M0dWRkowaHFINlpoTzkzaXdUQ0N3QU9wMmV1Q0l6M1AvZ3M4cG1uSXRWbDZad0tFaUROMmtTZWw3SGpNS1hCd21kOEJQdXZiYWZQWEVOR2hYQjcrSEM0b0krazBQUjhYdUhsWjRqdCtqWk1VdWNOTHl3angremVUSVh3b1RGR3k3cUtXWWl3YnBrQy9tL2Z6eFB6aW5rTEpTa2J2UVJyOEZDWFJTa202dVlHY2NnUE5FbnRZdlBrVTFIeSsvd09sOUdFTEFBQUFlSnhqWUdSZ1lBRGkvbXZILzhmejIzeGw0R1ppQUlGcnU1UnV3K2ovWC83dlltcGhQQVBrY2pDQXBRR1o4dzc5ZUp4allHUmdZRHp3L3dBREExUEQveS8vdnpPMU1BQkZrQUhUV1FDNjFBaERBQUFBZUp5VlZ0dFJ4REFNbEsrU0s4V2xVSXBLb1pTVVFnZmNCOHd3Z0dOc1daSlhUc0xBaHlieFM1RjJWM0tJaU5KR2RLTnBmUnl0bGh1M05hNzdMZGM5NVZwOXJiOTM2K2Rvak5GWDhNbmdVOTdCejdhdXhmZmYvVFUvLy9ZM1l1NVA4VWNXOTNuOFlxeHJiTmJHT2llK0h6TGUwMFBYdzk0VHl4cUw0SW0rTkI4V1BQZVE3MFBXdjl5L2N1R3h1ZWw4VnJ6NGl0dWpCVDl5ZnNRUThHL3p0QTA3K01oNmJwd3QwZC9FeS95a0hMRktBNE12V2VPdXI3alBzTG5TMlVISGR2NUNHNzZmTDN3NzF3dm5PcGRzamhVbmUvWmN6VERuRFhLMWVCR3p3T1hVWE9BSDlnN2RENXprV3d5RzlTampvUytiTXc0amR1cHJ4VFhYc3ZJOTEyRE96dWJsK3pTNDlkei9ZbGdMdjFqVWZhdEJoamdreHZwdDQxR3JzbmZXRVdLaytLYTcreFFOcDJmWFFrRU9yWllWMjlLL0pacWdxUlB2b2Robk5MOFpwNzNQV01jKzB4SEV2MkpBQXlmTStXWjZ5TkJqRms2RmUxNzR6a3RlTFo3V2gwcDZhcWJQMlZQcVozSzlZcTIzTXh2aTRuVmQvVDNET01RNC9CSG1hZkZaTGIyMC9uQnZ0dkJ2bkhtL1k4aUo4TjZLNXZsU3hFUDg1WE0vcmhmbHVzWCtlYWlMZ2NXdWQ4N3VsbFdUdXRZd2ZMUDV0V2RjNXJETkhFOTdvOWQ3MUUzUVBQU2F1ZGJxQW5RU05Pc2NXRDhFald4UXIvWmR5NFhiK21PcE5acnh6YjRCMkhxTWhqUHN5KzdqRzJxOHhqTW52WWxzdnVNdXRWcUdicnUydlg1TDBBVkZDekVzdm8vY244UjJ3QmE0WHN3NDlIeDU4akQrTXlMSHM4LzIvNXRvK0cvanZjTDhBdmJTcjNDZGxkY1g2OG4ydmI1UCtDMjRGKzhzK1Y5YytTVHRHMXVNMi9Rejcwajh0MUc5b1JhejltU05QOTJsTHhUSDVMVytEMDIzR0FqaTQrWE80UHB4eG5Qb2g2VHh0SDAvRTA1YUZ3QUFBQUFBQUFCbUFPWUJEQUYrQWRnQ01nS09BdWdEbWdRY0JQQUZhQVdxQmV3R0xnWndCcFFHdUFiY0J3SUhTQWQrQjdRSDdBZ2lDRWdJZ0FpNENQQUpLQWxPQ1hJSnJBbm1DaUFLV0FxUUNzZ0xBZ3M2QzJBTG9ndmtEQ1lNYUF5YURONE5JZzFvRGE0TjRBNFNEbGdPbkE3Z0R5UVBhQStzRC9BUU5CQmtFSllReGhFa0VXb1JzQkkwRXM0VEpCT2VFLzRVTUJTT0ZOQVZXaFdVRmZBV2RCZENGOTRZUkJpSUdPd1pTaG1pR2l3YWxocnlHeVFiWEJ1VUc4d2NJaHhhSEpJYzZCMVVIYUllTkI2a0gzNGYzaUF3SUZvZzhDRk1JV0lob2lJU0luSWluaUx5STVZa05DU01KTWdsRGlWMEpoWW1maWJLSnZvbmNDZ0VLTUFwSmltV0tmNHFXaXJNSzBncmtDdnVMR3dzdEMwR0xZUXRzQzNjTGdvdU5pNVFMbW91Z2k2d0x0NHZEQzg2TDFRdnZEQXdNSkl3eURFNE1Zb3h6RElFTWo0eVpETGNNekF6NkRSOE5SSTFpRFhVTmp3Mm1EYndOMFEzeWpnMk9KWTQ3RG0yT2U0NkpqcGVPcFk2MmpzY08ySTdxRHZPTy9ROEdqeFdQSkk4emowSVBTNDliajJ1UGNnK0ZqNm1QdW8vSUQ5VVA4cEFGRUJxUUxSQkNrRTRRWVJDQUVKR1FxeERERU5NUThoRk9FVmlSYlJGNGtZMlJuWkd2a2NxUjVaSCtraFFTSkJJNWtrc1NkSktIRXB3U3NCTFNrdUFTK2hNTUV5V1RONU5hazJpVGRwT2FrNklUd0JQYkUreVVDNVFibERJVVN4UlVsR3NVaHhTZGxLb1V2cFRKbE40VTZSVUFGUllWSzVVM2xWSVZZNVY2RllpVm1CV29GYktWeEJYYmxmb1dGUll3RmtTV1ZCWmxGbnFXaVphbkZyc1d5WmJZbHYwWEM1Y2Vsek1YVEJkbWw0SVhsQmV6bDhnWDM1ZnltQVVZR1pndW1ENFlZcGgzbUlzWW9waTJHTk9ZM2hrTm1VYVpUeGxuR1hpWmpabTNHY21aMkJubEdleVoveG9vR2tNYVhacHFHb21hbmhxNEdzMmEyeHJrbXY0YkNCc2pHejhiVHB0a20zWWJtQnUvbSthYitod0lIQmtjS1p4Q25GdWNkUnlPbktNY3dKelVIT1NjK0owaEhUMGRUeDFtblhxZGhoMlluYUtkdWgzRm5kd2Q5QjRsbmphZVlwNTBub2dlbWg2cEhzS2UyUjdxbnhBZkg1ODBuMHFmWDU5cm40WWZucCtwSDd1Znp4L2RIL2FnQktBbW9EYWdlS0NpSUxRZzBLRHNJUGNoQktFUG9SMGhNU0ZLb1dzaGd5R2lvZGNoOGFJUm9obWlLaUk4SWtvaVZxSmdJbW1pY3lKOG9vaWlsS0tnb3F5aXlTTHJveG9qTXFOQW8wMmpWNk5tSTNzampxT3JvOENqMVNQckkvb2tFeVF2cEVva2dDU2RKTG1renFUYUpPa2srQ1VFcFF1bEd5VXNKVGdsUXFWZHBXK2xlcVdpcGF5bHVLWEVwZWltQkNZaEprT21UU1puSm5lbWtLYW1wcklteUNiVXB1bW0raWNHSnlpbk9TZExKMWluYlNkOUo1QW5wcWU4SjlBbjlLZ0NxQmVvTHFnOXFFaW9VQ2hmcUhDb2hTaVpLS3FvdHFqZEtSS3BKQ2s1S1U0cFl5bDJLWXNwcFNuSnFkbXA4Nm9PcWlXcVB5cFJLbU9xZTZxVHFwcXFvYXFvcXN3cTNpcnhxd1FySml0TksyWXJoQ3VZSzZVcnVpdlRxKzZzQkN3ZExESXNSQ3hZckdtc255ekJMT3FzOUMwSnJTU3ROSzFZTFd3dGZxMk1yYVF0c2EzRkxkS3Q1UzN3TGdpdUs2NU1ybDR1ZWE2TExzaXUzNjd5THdldks2OCtyMU92YmkrSUw2UXZ4aS9pTUFPd0lyQkhNSHN3bHpDek1NK3c3RER5c1JNeE03RTZNVVd4WFRGd01YcXhrekdXc1o0eHM3RzhNY214MUxIZnNmc3lCYklSTWlXeVFqSmNzbjZ5bWpLb3N0R3k4N01Nc3lrelJqTlhzMlN6ZExPR001S3pyTE8zTTg2ejdiUDl0QWkwR2JRK3RGcTBjelNCdEpvMHNyVElOT2cxRmpVcE5UODFWVFZyTllFMWxMV3d0YzAxM1RYdXRmazJETFlqdGpvMlRqWmN0bTYyZjdhTHRxZTJ1emJkdHZTM0Q3Y2Z0ekczUkxkTU4yODNpamVnTitrNEZMZ2lPRHM0VVRoak9IWTRuRGl5T00rNDRUanZPUVk1SlRsRk9WSzVZN21GdVoyNXhUbmZ1ZTI2RExvZnVpbTZOYnBQdW1hNmlEcW5Pcmk2eGJyZHV1bTdBcnNTT3pjN1A3dGZ1M3c3bVR1d084UzczRHYyUEEwOEhid3h2RHc4UXp4VFBHUThqVHlkUE1tODRSNG5HTmdaR0JnT3N2d2pVR0JBUVNZZ0pnTENCa1kvb1A1REFBNUJ3TDhBSGljcFpITlNzTkFGSVhQOUE5c3UxS1JydVNDVWdRaExZVnM2cXFiZGxzb1pDbjBaOUttSkptUURDMTlEN2UrZzQvaFUvZ0E0dHExTitrdHFFVVJ6REF6M3oxejdtR1lBRGpGQ3hUMlg1UG5uaFhyVGVFU3FyZ1VMcU9GSytFSzg1MXdGUTFNaEdzNHg3MXdIYmRJaFJzNHd5TW5xTW9KVnkwOENTdGM0MW00eEIxdndtVjA4UzVjUVZlMWhhdTRVSjV3RFRjcUZLN0RVdy9DRGJUVjY5REVsZ1piblpsSWYyWnlhWnlhaVFtRHhiRk12K3FlVHJQQXhPUTYzZHdpRHZjUU45S3hUcWRXTDJpMm8yeXo3Rm5yazUrYWlISzNEa05EU1dyV2VtNmRsYlZKdjlQeFJYZm1Kc0lRQmpFc0NBTnNvWkZ4SGZIK2swNXdlWTc1aFEyL3ZrR0lBSXMvdWVrZmZvL1BVbllGUlYvdWN2aFBIVksrWnJoSHR4dXhHaGNKVTNaclZnZ3o3SGpOc01FU1BWWXRmSzc5b2pOaU9tUnJ6Z2lMMnlURjJacVZPZXNPVmtWWGdqNDZQUHh2Zm9kZG5QUUJubytMaWdBQUFIaWNiVmtGdU96VUVYNHpzeTVYM25zNEZDdVVBb3RUdEtXNEZHbWhMUzdaNU93bWI3TkpYbVQzN3FNQ3hWMWFhSEZwQzdUUTR1N1E0bEIzZDNmM3pqa24yYzFldU4rM3lmOVBqaVJIWnY0NWR3a3UwWC9GSmEvNWh5OERBa0VCaWxDQ01sU2dDaldvUXdPYU1BT3pNQWZ6c0JTV3dYSllEVmFITldCTldBdldoblZnWFZnUFhnZnJ3d2F3SVd3RUc4UHJZUlBZRk40QW04RWJZWFBZQXJhRUZtd0ZXOE0yc0Mxc0I5dkREckFqdkFsMmdwMWhGOWdWZG9QZDRjM3dGdGdEM2dwN3dsNndOK3dEKzhKK3NEOGNBQWZDUWZBMk9CZ09nVVBoTUhnN3ZBTU9oeVBnbmZBdWVEY2NDVWZCMFhBTUhBdkh3ZkZ3QXB3SUo0RUJiVERCQWdFZDZJSU5EcXlBSHJqUUJ3OThDR0FsaEJCQkRBa01ZQWdMTUlKVmNESzhCOTRMNzRQM3d5bHdLbndBVG9QVDRRdzRFODZDcytFY09CZk9nL1BoQXJnUUxvS0w0Uks0RkQ0SUg0TEw0SEw0TUh3RXJvQXI0U3E0R3E2QmErRTZ1QjV1Z0J2aG8vQXgrRGpjQkRmRExmQUorQ1RjQ3JmQnArRFRjRHZjQVhmQ1hYQTMzQVAzd24xd1B6d0FEOEpEOERBOEFvL0NZL0E0UEFGUHdsUHdOSHdHUGd2UHdMUHdIRHdQTDhDTDhCSzhESy9BNStEejhBWDRJbndKdmd4ZmdhL0MxK0RyOEEzNEpud0x2ZzNmZ2UvQzkrRDc4QVA0SWZ3SWZndy9nWi9DeitEbjhBdjRKZndLZmcyL2dkL0M3K0QzOEFmNEkvd0ovZ3gvZ2IvQzMrRHY4QS80Si93TC9nMy9nZi9DLzNBSkFpSVNGckNJSlN4akJhdFl3em8yc0lrek9JdHpPSTlMY1JrdXg5VndkVndEMThTMWNHMWNCOWZGOWZCMXVENXVnQnZpUnJneHZoNDN3VTN4RGJnWnZoRTN4eTF3UzJ6aFZyZzFib1BiNG5hNFBlNkFPK0tiY0NmY0dYZkJYWEUzM0IzZmpHL0JQZkN0dUNmdWhYdmpQcmd2N29mNzR3RjRJQjZFYjhPRDhSQThGQS9EdCtNNzhIQThBdCtKNzhKMzQ1RjRGQjZOeCtDeGVCd2VqeWZnaVhnU0d0aEdFeTBVMk1FdTJ1amdDdXloaTMzMDBNY0FWMktJRWNhWTRBQ0h1SUFqWElVbjQzdnd2ZmcrZkQrZWdxZmlCL0EwUEIzUHdEUHhMRHdiejhGejhUdzhIeS9BQy9FaXZCZ3Z3VXZ4Zy9naHZBd3Z4dy9qUi9BS3ZCS3Z3cXZ4R3J3V3I4UHI4UWE4RVQrS0g4T1A0MDE0TTk2Q244QlA0cTE0RzM0S1A0MjM0eDE0Sjk2RmQrTTllQy9laC9makEvZ2dQb1FQNHlQNEtENkdqK01UK0NRK2hVL2paL0N6K0F3K2k4L2g4L2dDdm9ndjRjdjRDbjRPUDQ5ZndDL2lsL0RMK0JYOEtuNE52NDdmd0cvaXQvRGIrQjM4TG40UHY0OC93Qi9pai9ESCtCUDhLZjRNZjQ2L3dGL2lyL0RYK0J2OExmNE9mNDkvd0QvaW4vRFArQmY4Sy80Ti80Ny93SC9pdi9EZitCLzhMLzZQbGhBUUVsR0JpbFNpTWxXb1NqV3FVNE9hTkVPek5FZnp0SlNXMFhKYWpWYW5OV2hOV292V3BuVm9YVnFQWGtmcjB3YTBJVzFFRzlQcmFSUGFsTjVBbTlFYmFYUGFncmFrRm0xRlc5TTJ0QzF0Ujl2VERyUWp2WWwyb3AxcEY5cVZkcVBkNmMzMEZ0cUQza3A3MGw2ME4rMUQrOUordEQ4ZFFBZlNRZlEyT3BnT29VUHBNSG83dllNT3B5UG9uZlF1ZWpjZFNVZlIwWFFNSFV2SDBmRjBBcDFJSjVGQmJUTEpJa0VkNnBKTkRxMmdIcm5VSjQ5OENtZ2xoUlJSVEFrTmFFZ0xOS0pWZERLOWg5NUw3NlAzMHlsMEtuMkFUcVBUNlF3Nms4NmlzK2tjT3BmT28vUHBBcnFRTHFLTDZSSzZsRDVJSDZMTDZITDZNSDJFcnFBcjZTcTZtcTZoYStrNnVwNXVvQnZwby9ReCtqamRSRGZUTGZRSitpVGRTcmZScCtqVGREdmRRWGZTWFhRMzNVUDMwbjEwUHoxQUQ5SkQ5REE5UW8vU1kvUTRQVUZQMGxQME5IMkdQa3ZQMExQMEhEMVBMOUNMOUJLOVRLOHNhUmlXRllvb2FyVjl2emNtcGhGYUpjTmFrVVJ4M1hDTnNOOHlYZC9rNTY3VDlWcW04R0lSTmpXUlpaek9xS2FaS3pxeWhvU2gwN1hqcXVHNkl1dzZJcW9hL1hiaUdwNHBOamI2SW5STXcydEZxb3JoZFJPaksxcU9iRFVJUmV4NDNSSVh0UDF3bnArNW9tWDVTVnZkaHQ2MFJYYTNkTXFpZXAyZE1pVkJMZU5ETDRYNlBSVlVOU29hSjBIWkNFM2JHWWpWakREMGh5M0RqVnVtRTVwcDdWZGJaVU9ydjhxcTJsejJLbk1TekV4c2k5cnJoSDZmSnlHTy9mNnlSVmJaeC9KRk50WEQwa1hHMk05M0lLdk5UcWlxa2Vzd1dwa1k0YXMrSzdVdStxelV1dml6VW5NUzVHeXhuMzdGL0pSTnoxVGVvaHFibXpMeCt6Y21oaVJJbThoTndMUWwxMmgrNEdlblRITDZGYy9WenczMmJNNGkyNXZMY2RYYVRNN0FMNWcycGhlUWdxcFUybkJ1VUtjdHVWZk5EK2JzbENrSlVqNGV4T2FZeXdabXhreFZib3dwdjFkRmt5UWR3VWdOb1owbmc5cUVWRkpvWjJCUTBtQWRJNG9jM3RFRGZtVytDNDgzWXlzYU1lcEhGWU52b1JQMTBPRHZUU3pIYjFraU1rTW5pQjNmcTdRTnN6ZGt4MUZ2R3hadlo5TVdacStvY0xOdHFKM2Zpa3pERmRRMlpHSFBhaG1PTEJ5YXZpWGtTelV5SEFyREdoT3U0NVZUVXVCN3hLMUZnbHQwVy9KU3lkZ3NnNTZJeHcveTNQYjlnT3ZHTnJjYTh6ZU1lSGpkdUprUjBRL2kwZmhSSjNIZE1iRU50ek9iRVRsTDB2TmxQSEtOeUY0OVk3RWRDcEdWaWFndHJFSmJpTERXRnZ3R3FtaEJ3bkxiTVVlOE1HdHR4L05OZG9ueWk1d3d0aTFqeEk2M0o0cHQxL0c0cnUrcVM4eVhmcnNnL1hORlh2cEcyR3UwL2FFclowWiszWmdFamhkVjIvNkNIbnBpVk9TZmlMakFnbnplZGYyQktMZER3MkduUE44T0hkRXhlZkJhZldHeE8zYXJZd3VYNGFVZ1Ftb24zVW83Y1Z5THF6TndYZmJKbmdLUkdQRnNKS0hIWmFJYTE1WmZFdnRoUTg2d1p4bWhuTkNaTVZGdjFCeFQ3akJlUG1FTHBtdjBEYm1JSmpYNmpwZEVreHFCbTBTVGg3SFRGMUVsbzl3OVJ4UkRMYUVVY2hRSi9aSW1YQzZJRWxkRXhHRnRubjlpeXFkUFc5UStuYkxvZlRwbFlwZWl1WW9vR2lxSG9LRjJDQnJuSGNLVUpkZlJsRU9ZTWlWQlJYUDJEQXppMXNTVFZSV1h3MUkzUmNnaG1LY3dGalhUMXNXRVVkV3dMY2RISVY0aklqVUdqbWlvS1VtL0tDVzYxNklpYzN5VnNzQ0piRC9RUTVzejFGUGk4MzZmMVZncEJGbXdudU16R3Zmazh1Tkh0UWxOMis5NThxdHo3V3REV2k4d2hsNnVucVJwYnlzVElieGNiNHFudFVMZUpibGFraFlWWE1iWFFlaDcrZWxmYkZQQmRwRXRuZEJwSTBlOXpKTFRKNHR0VTgzbE5jcjhJaU03N29sbDZJMkpiS0NaRVIyQU01WmJXNHR0VTkzbTE5ZjhJcU5jeXFrbENYaVVlSzgzMGcvMC9OaTBTNXJNbXE0VHFObldXM2xtd21XWXFJNXBVVTI3dkhwaW5xK1I0QnFHQ2hBODZVdlprbGpxalYzZnNMU1BtRExOYVpvRTJmTkczbEJVcEdDNlNidXVnZ003TXhhS0dwdCt2Ky93cEV2TSs3NHJDaEtXVEwvVEVZSk12OHU4RzVWTjMwMzZIdThhTHM1Q1Z2WlJUbkVsdmN0Qy9ZQWpZVVBlbFNMbVVzMHhHVHFXcUdSczN2UzlnUmo1WVl1OWU1d1d6Rm00MTJCVWxaZDBBa0xwL1pURWJyVTVMUGFtTEN3elBGN1RFMHVaNDZ2SmNheGdoaXcrK0JKRnR1R0VVY0ZNMnJ4VitjSnZtNFF5QUpDWnhCWExpQTBaRWd1V01EcDFqcys5V08vZmNvcXJsbU4wUFo2WXFNeW83M3NXV1o1UnQzeVhRNUdTNUFxblVYRmU0dzQ3ZHc1b3NwMWwweFpWcWpsbEt5cFdzL3pNWVZheTJhMVlTYjh0ZzJCQmZsOVJyQkJtUE1QVUNWaDB0R3kxYVNkMDhtUXcvV1RRRkR6QXJoK0lGdis4MlRIVGk3cVM4Uko3Znc1alZaR0V2dnF5Qm9jYW02VytraHVWakN6TkJhRDBqYWRNdXRYbGVWTWNPaXBqcU9lTU5iRVFLRlhqeHZNWkhBdXU1cFNsbmpLNWtFb2FjeFdXRFo3aFNqK3QzTmVhMDVaMHcvS0Q1YS8xb0RsbHJITjRibG04WWdMNStZeVYvaUJHelE2cnVGYW0xUnFLZGZ4UUV1b1lDNldPNkhOWWJYUWM0VnFzbTNqcGplb2R1WEJGMkZvaDRrckhjYlZZMDBCblN6Vk5wQ1RVVURtSnFvYThDVFdTYzY0Zjg2Z0pkeTZENHdGVUJxZlB5YUIrbGdxVFNYZXBRUmRVQ2tHL1QyQjFkQmN5SHM1cTVBODVtL1E1cWRTbGxXVFFjTUNqN3V2eVF6KzBDaExKZHZxeUk4bjZKYjd3Qjg5M25GQytvY3hJRTQ1N0lpeElDMWNOZWRSWXZjN3dpdS9xanhXOFpRdVNGdmtTOWVvZGxtODhaSEo5bGpRdWRIaHJOenUrbjlPb1kyWUx0eTlIMXc5N3J0T0p5K21VRk5rZkRMbUJKR1lsV082eW5nbllDM1lOWHQvVUZmMWFsd1dRQ0ZuYlJJVXVWMnQydWUrb3hSS1JYOWtwc3VCcmkyclhkenVxTjQyazg1enBob2FWcEF2ZUNDcDJ1b2pRM2hidDdkRGVmczZXeTlQMmxmTGpNTDlRVndiWFdjVXZWVk00TUhodHBWQVlwcGpWVUk2NDh1WjVyaEtySEZlZXNKa3pjUFNiTUJIT0tCSUtVemdEZm9HcXByd1lkWjNJZEtMSUR5UGRleFR3QTFXRVBXTlBsRzFlNmJIUkpkdXl5alpuRXR4QVRkNERtMk5TVkdRWXhsVjFiUXNqNWlJTFJ0ZjN5amJITVQ4YzFmV2Fid1dKN0UxanpvZk1YbFN3L2I1bzJINFVPTEZlbExOakVvMzZQRUdWakhQRkpOUnp3Uk0wTTJFcW5aalFLRmJ2a3ZHSzAySlh6bDlXY1RnMnlNeXA3bGc2TGtnSG51S2kyaUVsZGVVcW5sVDhqbGZWd0UvaW9rSWx6aUU0bERYNGxrUXhweWZTNDJXazduZ2RQM1YxR3V2NUwwak1MUTI0Sm85RlNYNkxZODZzWUcvUjh1VkpqWFF4eEVOUzRaK0s5NVhzK0tia2NwVG5MTXZsc0ZOMEJjZVZHVmZ3TWxWclFibnZDVzFvbUtpNFZNbElsUmUrVkNrODM2NWNINXhtdEF2U21URmxTUy85ZDBXS0RUVVdDdkNXVVBmRUxjajdERXNQdmFhVmw2MWtnclNwZ055SmtsWEhyQ0RSTWxZcTNkYjBzY3hpbTFKVGkydzZtQzh5c2t6UFdkUXV5SEcxQzNKYzc0S2NnY1dZeTdlQkU4bDgyazA0UEZsK1dPU0pkc3dTWHoyV0FkSTd6L1NOUUc1eWRqcHFaQ2UwTENIbmdWVjVseU1XRWFNNlA0eFNvZGxVbUJlQjN4TXRlNG9ONmpsV2tMakVEcmZueE5RWGRwa2xGUy9PVWJYdnNBaGhyeC9NS0tSMmxYeUx1UnhWMGFZMk1UU1VyMDRYWEZPVGROK2x6RGRqeWRLQ2FTS2lTSzN2dDlPWXN6U0RIb2MyUjh2SGFWTkpVN1o2dkc4WnVucUF4clRROXpuUTlIMWUzaW9MYi9iOUpCS1ozeW4yazRpSDJoTUprNm9uaHBIeWNrMld3aUxLb2svRGIwdmQwdXFHZmhMTXBDVHhGQzJuMzFIbWZTaTNYejB3cEh0cmh3bVBSeUFQUTlYeUxXbFlWNjF6MERJNE0xTlk2bWhHb2NFT09yQ0xnVHh4YVFTR2ZFVTllRVZGaURPaGNycWVhL0t1QjR3WVNtbzZydTVGUVZuUTQ2MWJsdTJyZDVyTVVTUEZxbnBLQmxJZ2MwZVNGQU1lczZpcTNsQTJXVlNvenRkUitrSUZpZm1TZE9zeStHWUpwY0xwRkd1U2pvd3VsYm9iaWN1QmI1bjhuUlQ0ZmlYd3d6ZzBXQ1lFZmlKZE82L2dxb3JrTFZieGEwaTluUjAzcVFNeXZTeVd2WWE5R0lReTlBZThWSVdWOFBOR2tLeGFKWFdCdzFHbHRGSWRKODF5MWhqbFZOK0VwMEl5NDlXVmlXT3hlakh0MnNxRTE0TE85alZVdTdnY0dpWVhqa3VjajFoK2Z4bUhyamc5YVpaeGlXT3NXRHF4WlY4NU16RkpKVmhtS3Rka2hhV0VyN1NJQkxWUWRPVkpIT05HS0RqVXhxMXRsZC9NU0MwRmNzWTFyUExObFI3ZkxTcFVEMFU4RkhycGxWTmNDRm1QbDJSTUZYRXRqTElwSVlhMVVHV2tjdkFaQmtMRFFzU3FZMDZleG5rOEhabi9YNVlaWXAvZEZjOENwK0hsMUZaaG1yRGNEeHVSa0VKUks3WjZTdVRjbHpUbVd6amdEY2Z4V3lsY2R5NUQyVW5JK0ZIYzBDajFFSXJVV1puMU9JU29GNDVzcFZ4MVNRV1ZQQ3RwVXVCYjBKU1hRQW9icVg1bnhreEtSS3NoanpjQ2ZiYlduYzBSZVpqWUhITjUrc0p0eXFYSjNTZHl5Wms4bG5YMUx3MUhiY3h5aXB0VC8rWm9LTWJ1UWMxaFJrb1NHQzVYaVZsL0IzT1J5K3NobENsUjl2MlpZZnhvc1BqUm9CajEyZmVWbzc0dkQxaXFrZWNQV1l2MnhDd3JDdGxkWUJzcUpqVnpQT0crRkdNL21BcTNtYnlCdzdLaTZnQkxJUzlSLzc3UjBXM0t3dTVQOFNRb3lIdVRuYWM4ODlXalUyUm1DYlk1ZXJuWUR1ZTJLYXVudVkwOGVTMXBQQ2VsVVQ0NXFDcUQxRThGaVpxOEk0SkpHcU5ZcXBuclRHSldZcHh5ODlLUTBtMGt6eklrNWt4WTcvU3F4RU9ETnpSYlE3azFCbzRZY3FPaHc5TnNzeXZ2MnRVb2FXdTNVbUkwTkVhVktHRVh3QmtsUllsWGozaG5oUHA1SlJwNXB0cXdFcFNqa1JReG9zR0p1RXc4MlBzNlVWR1JtcnFxcVYrYXdWd3NtelkxVXhvbTNhNndTcHFWOVMzaXNxYlVvM0VxQVNhVTJNMFcrQ2U3akZpMXhzYUNVOWN2b1EvTXVReHZSTU5sNDBMTVBscjZyNXJDN0lSaXV4TGJ2RmpEcmloTHdKNEhZM3MrNXR5bm4zYW5NdjY1dkVYTzI1UkJUdE95dkNFOUZWODdiNXMrTDYvbkhqRk8rdTFJbjNPbW1CZWlRdnlodlZxc2prU1V4OU93b2RLN1RHQm9rZ2tNelRLQm9WbnFQaFFweERKU3hINVgrbUVPTTlVTWN0K2NKZ21wcklyU1gzdXpmUFVpblhPcHM4Y2NsMlVqZFlKUlZLZ2lsNVZhRXhKVXNnT0RXaXdsMFVpL3VvSmNuRk1OaXVOUkpSN29nMnVNQnhYKzFGQzRybEZOVklibmVLTENTSWNGQ2VZU2p4UHZNSktaaUdseUFsaExEVTQ4S2lXZTFNMXN5U1J3U2NPU1BrYXJKWkdWanBXQ2FiUmpZYUUvU3dIOXZLeHczNnFxdXpwdVZpZ1M3T3JqbXNKNkZDVXN5a3ZVWVBYa1JheEJaRGJiekVqUFkzay9acHkwOFdTa1RQOUxLaU1Oemo2U1RLN1dOSkZpdEtoZ1llQVlibEZlMkNBVCtWbldLeTVIb3l5bnJtdjlvaFpQaHZ2Y2RpM0Zjb1pUbUFSTmRoakNWaEpRcGdaalZsUytvVFRVbTJOb0MrR2E4dGl0UEpScElxdWVvZE54YWtQT3A3VHliNlJRblhqT3BxVFBPNi92ckpwd3pza2xuMGs1cXhLV29hS2thV1hvNi8rSWw0WWg2emE3dU5BSzJlZU1oTFl1V2ZKLy9RTUc4UT09XCIpIGZvcm1hdChcIndvZmZcIik7IH1cblxuLmZhLFxuLmZhcyB7XG4gIGZvbnQtZmFtaWx5OiAnRm9udCBBd2Vzb21lIDUgUHJvJztcbiAgZm9udC13ZWlnaHQ6IDkwMDsgfVxuXG4vKiFcbiAqIEZvbnQgQXdlc29tZSBQcm8gNS4wLjcgYnkgQGZvbnRhd2Vzb21lIC0gaHR0cHM6Ly9mb250YXdlc29tZS5jb21cbiAqIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlIChDb21tZXJjaWFsIExpY2Vuc2UpXG4gKi9cbi5mYSxcbi5mYXMsXG4uZmFyLFxuLmZhbCxcbi5mYWIge1xuICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlO1xuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICBmb250LXN0eWxlOiBub3JtYWw7XG4gIGZvbnQtdmFyaWFudDogbm9ybWFsO1xuICB0ZXh0LXJlbmRlcmluZzogYXV0bztcbiAgbGluZS1oZWlnaHQ6IDE7IH1cblxuLmZhLWxnIHtcbiAgZm9udC1zaXplOiAxLjMzMzMzZW07XG4gIGxpbmUtaGVpZ2h0OiAwLjc1ZW07XG4gIHZlcnRpY2FsLWFsaWduOiAtLjA2NjdlbTsgfVxuXG4uZmEteHMge1xuICBmb250LXNpemU6IC43NWVtOyB9XG5cbi5mYS1zbSB7XG4gIGZvbnQtc2l6ZTogLjg3NWVtOyB9XG5cbi5mYS0xeCB7XG4gIGZvbnQtc2l6ZTogMWVtOyB9XG5cbi5mYS0yeCB7XG4gIGZvbnQtc2l6ZTogMmVtOyB9XG5cbi5mYS0zeCB7XG4gIGZvbnQtc2l6ZTogM2VtOyB9XG5cbi5mYS00eCB7XG4gIGZvbnQtc2l6ZTogNGVtOyB9XG5cbi5mYS01eCB7XG4gIGZvbnQtc2l6ZTogNWVtOyB9XG5cbi5mYS02eCB7XG4gIGZvbnQtc2l6ZTogNmVtOyB9XG5cbi5mYS03eCB7XG4gIGZvbnQtc2l6ZTogN2VtOyB9XG5cbi5mYS04eCB7XG4gIGZvbnQtc2l6ZTogOGVtOyB9XG5cbi5mYS05eCB7XG4gIGZvbnQtc2l6ZTogOWVtOyB9XG5cbi5mYS0xMHgge1xuICBmb250LXNpemU6IDEwZW07IH1cblxuLmZhLWZ3IHtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB3aWR0aDogMS4yNWVtOyB9XG5cbi5mYS11bCB7XG4gIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcbiAgbWFyZ2luLWxlZnQ6IDIuNWVtO1xuICBwYWRkaW5nLWxlZnQ6IDA7IH1cbiAgLmZhLXVsID4gbGkge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxuXG4uZmEtbGkge1xuICBsZWZ0OiAtMmVtO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgd2lkdGg6IDJlbTtcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cblxuLmZhLWJvcmRlciB7XG4gIGJvcmRlcjogc29saWQgMC4wOGVtICNlZWU7XG4gIGJvcmRlci1yYWRpdXM6IC4xZW07XG4gIHBhZGRpbmc6IC4yZW0gLjI1ZW0gLjE1ZW07IH1cblxuLmZhLXB1bGwtbGVmdCB7XG4gIGZsb2F0OiBsZWZ0OyB9XG5cbi5mYS1wdWxsLXJpZ2h0IHtcbiAgZmxvYXQ6IHJpZ2h0OyB9XG5cbi5mYS5mYS1wdWxsLWxlZnQsXG4uZmFzLmZhLXB1bGwtbGVmdCxcbi5mYXIuZmEtcHVsbC1sZWZ0LFxuLmZhbC5mYS1wdWxsLWxlZnQsXG4uZmFiLmZhLXB1bGwtbGVmdCB7XG4gIG1hcmdpbi1yaWdodDogLjNlbTsgfVxuXG4uZmEuZmEtcHVsbC1yaWdodCxcbi5mYXMuZmEtcHVsbC1yaWdodCxcbi5mYXIuZmEtcHVsbC1yaWdodCxcbi5mYWwuZmEtcHVsbC1yaWdodCxcbi5mYWIuZmEtcHVsbC1yaWdodCB7XG4gIG1hcmdpbi1sZWZ0OiAuM2VtOyB9XG5cbi5mYS1zcGluIHtcbiAgYW5pbWF0aW9uOiBmYS1zcGluIDJzIGluZmluaXRlIGxpbmVhcjsgfVxuXG4uZmEtcHVsc2Uge1xuICBhbmltYXRpb246IGZhLXNwaW4gMXMgaW5maW5pdGUgc3RlcHMoOCk7IH1cblxuQGtleWZyYW1lcyBmYS1zcGluIHtcbiAgMCUge1xuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOyB9XG4gIDEwMCUge1xuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH0gfVxuXG4uZmEtcm90YXRlLTkwIHtcbiAgLW1zLWZpbHRlcjogXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmFzaWNJbWFnZShyb3RhdGlvbj0xKVwiO1xuICB0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7IH1cblxuLmZhLXJvdGF0ZS0xODAge1xuICAtbXMtZmlsdGVyOiBcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CYXNpY0ltYWdlKHJvdGF0aW9uPTIpXCI7XG4gIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7IH1cblxuLmZhLXJvdGF0ZS0yNzAge1xuICAtbXMtZmlsdGVyOiBcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CYXNpY0ltYWdlKHJvdGF0aW9uPTMpXCI7XG4gIHRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7IH1cblxuLmZhLWZsaXAtaG9yaXpvbnRhbCB7XG4gIC1tcy1maWx0ZXI6IFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJhc2ljSW1hZ2Uocm90YXRpb249MCwgbWlycm9yPTEpXCI7XG4gIHRyYW5zZm9ybTogc2NhbGUoLTEsIDEpOyB9XG5cbi5mYS1mbGlwLXZlcnRpY2FsIHtcbiAgLW1zLWZpbHRlcjogXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmFzaWNJbWFnZShyb3RhdGlvbj0yLCBtaXJyb3I9MSlcIjtcbiAgdHJhbnNmb3JtOiBzY2FsZSgxLCAtMSk7IH1cblxuLmZhLWZsaXAtaG9yaXpvbnRhbC5mYS1mbGlwLXZlcnRpY2FsIHtcbiAgLW1zLWZpbHRlcjogXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmFzaWNJbWFnZShyb3RhdGlvbj0yLCBtaXJyb3I9MSlcIjtcbiAgdHJhbnNmb3JtOiBzY2FsZSgtMSwgLTEpOyB9XG5cbjpyb290IC5mYS1yb3RhdGUtOTAsXG46cm9vdCAuZmEtcm90YXRlLTE4MCxcbjpyb290IC5mYS1yb3RhdGUtMjcwLFxuOnJvb3QgLmZhLWZsaXAtaG9yaXpvbnRhbCxcbjpyb290IC5mYS1mbGlwLXZlcnRpY2FsIHtcbiAgZmlsdGVyOiBub25lOyB9XG5cbi5mYS1zdGFjayB7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgaGVpZ2h0OiAyZW07XG4gIGxpbmUtaGVpZ2h0OiAyZW07XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgd2lkdGg6IDJlbTsgfVxuXG4uZmEtc3RhY2stMXgsXG4uZmEtc3RhY2stMngge1xuICBsZWZ0OiAwO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgd2lkdGg6IDEwMCU7IH1cblxuLmZhLXN0YWNrLTF4IHtcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cblxuLmZhLXN0YWNrLTJ4IHtcbiAgZm9udC1zaXplOiAyZW07IH1cblxuLmZhLWludmVyc2Uge1xuICBjb2xvcjogI2ZmZjsgfVxuXG4vKiBGb250IEF3ZXNvbWUgdXNlcyB0aGUgVW5pY29kZSBQcml2YXRlIFVzZSBBcmVhIChQVUEpIHRvIGVuc3VyZSBzY3JlZW5cbnJlYWRlcnMgZG8gbm90IHJlYWQgb2ZmIHJhbmRvbSBjaGFyYWN0ZXJzIHRoYXQgcmVwcmVzZW50IGljb25zICovXG4uZmEtNTAwcHg6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNmVcIjsgfVxuXG4uZmEtYWNjZXNzaWJsZS1pY29uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzY4XCI7IH1cblxuLmZhLWFjY3Vzb2Z0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzY5XCI7IH1cblxuLmZhLWFkZHJlc3MtYm9vazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJiOVwiOyB9XG5cbi5mYS1hZGRyZXNzLWNhcmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYmJcIjsgfVxuXG4uZmEtYWRqdXN0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDQyXCI7IH1cblxuLmZhLWFkbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE3MFwiOyB9XG5cbi5mYS1hZHZlcnNhbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM2YVwiOyB9XG5cbi5mYS1hZmZpbGlhdGV0aGVtZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM2YlwiOyB9XG5cbi5mYS1hbGFybS1jbG9jazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM0ZVwiOyB9XG5cbi5mYS1hbGdvbGlhOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzZjXCI7IH1cblxuLmZhLWFsaWduLWNlbnRlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAzN1wiOyB9XG5cbi5mYS1hbGlnbi1qdXN0aWZ5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDM5XCI7IH1cblxuLmZhLWFsaWduLWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMzZcIjsgfVxuXG4uZmEtYWxpZ24tcmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMzhcIjsgfVxuXG4uZmEtYWxsZXJnaWVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDYxXCI7IH1cblxuLmZhLWFtYXpvbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI3MFwiOyB9XG5cbi5mYS1hbWF6b24tcGF5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDJjXCI7IH1cblxuLmZhLWFtYnVsYW5jZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBmOVwiOyB9XG5cbi5mYS1hbWVyaWNhbi1zaWduLWxhbmd1YWdlLWludGVycHJldGluZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJhM1wiOyB9XG5cbi5mYS1hbWlsaWE6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNmRcIjsgfVxuXG4uZmEtYW5jaG9yOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTNkXCI7IH1cblxuLmZhLWFuZHJvaWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxN2JcIjsgfVxuXG4uZmEtYW5nZWxsaXN0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjA5XCI7IH1cblxuLmZhLWFuZ2xlLWRvdWJsZS1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTAzXCI7IH1cblxuLmZhLWFuZ2xlLWRvdWJsZS1sZWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTAwXCI7IH1cblxuLmZhLWFuZ2xlLWRvdWJsZS1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEwMVwiOyB9XG5cbi5mYS1hbmdsZS1kb3VibGUtdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMDJcIjsgfVxuXG4uZmEtYW5nbGUtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEwN1wiOyB9XG5cbi5mYS1hbmdsZS1sZWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTA0XCI7IH1cblxuLmZhLWFuZ2xlLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTA1XCI7IH1cblxuLmZhLWFuZ2xlLXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTA2XCI7IH1cblxuLmZhLWFuZ3J5Y3JlYXRpdmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNmVcIjsgfVxuXG4uZmEtYW5ndWxhcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQyMFwiOyB9XG5cbi5mYS1hcHAtc3RvcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNmZcIjsgfVxuXG4uZmEtYXBwLXN0b3JlLWlvczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM3MFwiOyB9XG5cbi5mYS1hcHBlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM3MVwiOyB9XG5cbi5mYS1hcHBsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE3OVwiOyB9XG5cbi5mYS1hcHBsZS1wYXk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MTVcIjsgfVxuXG4uZmEtYXJjaGl2ZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE4N1wiOyB9XG5cbi5mYS1hcnJvdy1hbHQtY2lyY2xlLWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNThcIjsgfVxuXG4uZmEtYXJyb3ctYWx0LWNpcmNsZS1sZWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzU5XCI7IH1cblxuLmZhLWFycm93LWFsdC1jaXJjbGUtcmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNWFcIjsgfVxuXG4uZmEtYXJyb3ctYWx0LWNpcmNsZS11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM1YlwiOyB9XG5cbi5mYS1hcnJvdy1hbHQtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM1NFwiOyB9XG5cbi5mYS1hcnJvdy1hbHQtZnJvbS1ib3R0b206YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNDZcIjsgfVxuXG4uZmEtYXJyb3ctYWx0LWZyb20tbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM0N1wiOyB9XG5cbi5mYS1hcnJvdy1hbHQtZnJvbS1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM0OFwiOyB9XG5cbi5mYS1hcnJvdy1hbHQtZnJvbS10b3A6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNDlcIjsgfVxuXG4uZmEtYXJyb3ctYWx0LWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNTVcIjsgfVxuXG4uZmEtYXJyb3ctYWx0LXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzU2XCI7IH1cblxuLmZhLWFycm93LWFsdC1zcXVhcmUtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM1MFwiOyB9XG5cbi5mYS1hcnJvdy1hbHQtc3F1YXJlLWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNTFcIjsgfVxuXG4uZmEtYXJyb3ctYWx0LXNxdWFyZS1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM1MlwiOyB9XG5cbi5mYS1hcnJvdy1hbHQtc3F1YXJlLXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzUzXCI7IH1cblxuLmZhLWFycm93LWFsdC10by1ib3R0b206YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNGFcIjsgfVxuXG4uZmEtYXJyb3ctYWx0LXRvLWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNGJcIjsgfVxuXG4uZmEtYXJyb3ctYWx0LXRvLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzRjXCI7IH1cblxuLmZhLWFycm93LWFsdC10by10b3A6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNGRcIjsgfVxuXG4uZmEtYXJyb3ctYWx0LXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzU3XCI7IH1cblxuLmZhLWFycm93LWNpcmNsZS1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGFiXCI7IH1cblxuLmZhLWFycm93LWNpcmNsZS1sZWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGE4XCI7IH1cblxuLmZhLWFycm93LWNpcmNsZS1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBhOVwiOyB9XG5cbi5mYS1hcnJvdy1jaXJjbGUtdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYWFcIjsgfVxuXG4uZmEtYXJyb3ctZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA2M1wiOyB9XG5cbi5mYS1hcnJvdy1mcm9tLWJvdHRvbTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM0MlwiOyB9XG5cbi5mYS1hcnJvdy1mcm9tLWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNDNcIjsgfVxuXG4uZmEtYXJyb3ctZnJvbS1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM0NFwiOyB9XG5cbi5mYS1hcnJvdy1mcm9tLXRvcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM0NVwiOyB9XG5cbi5mYS1hcnJvdy1sZWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDYwXCI7IH1cblxuLmZhLWFycm93LXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDYxXCI7IH1cblxuLmZhLWFycm93LXNxdWFyZS1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzM5XCI7IH1cblxuLmZhLWFycm93LXNxdWFyZS1sZWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzNhXCI7IH1cblxuLmZhLWFycm93LXNxdWFyZS1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMzYlwiOyB9XG5cbi5mYS1hcnJvdy1zcXVhcmUtdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzM2NcIjsgfVxuXG4uZmEtYXJyb3ctdG8tYm90dG9tOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzNkXCI7IH1cblxuLmZhLWFycm93LXRvLWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzM2VcIjsgfVxuXG4uZmEtYXJyb3ctdG8tcmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNDBcIjsgfVxuXG4uZmEtYXJyb3ctdG8tdG9wOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzQxXCI7IH1cblxuLmZhLWFycm93LXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDYyXCI7IH1cblxuLmZhLWFycm93czpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA0N1wiOyB9XG5cbi5mYS1hcnJvd3MtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGIyXCI7IH1cblxuLmZhLWFycm93cy1hbHQtaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMzN1wiOyB9XG5cbi5mYS1hcnJvd3MtYWx0LXY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMzhcIjsgfVxuXG4uZmEtYXJyb3dzLWg6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwN2VcIjsgfVxuXG4uZmEtYXJyb3dzLXY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwN2RcIjsgfVxuXG4uZmEtYXNzaXN0aXZlLWxpc3RlbmluZy1zeXN0ZW1zOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmEyXCI7IH1cblxuLmZhLWFzdGVyaXNrOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDY5XCI7IH1cblxuLmZhLWFzeW1tZXRyaWs6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNzJcIjsgfVxuXG4uZmEtYXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZmFcIjsgfVxuXG4uZmEtYXVkaWJsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM3M1wiOyB9XG5cbi5mYS1hdWRpby1kZXNjcmlwdGlvbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI5ZVwiOyB9XG5cbi5mYS1hdXRvcHJlZml4ZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MWNcIjsgfVxuXG4uZmEtYXZpYW5leDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM3NFwiOyB9XG5cbi5mYS1hdmlhdG86YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MjFcIjsgfVxuXG4uZmEtYXdzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzc1XCI7IH1cblxuLmZhLWJhY2t3YXJkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDRhXCI7IH1cblxuLmZhLWJhZGdlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzM1XCI7IH1cblxuLmZhLWJhZGdlLWNoZWNrOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzM2XCI7IH1cblxuLmZhLWJhbGFuY2Utc2NhbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNGVcIjsgfVxuXG4uZmEtYmFuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDVlXCI7IH1cblxuLmZhLWJhbmQtYWlkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDYyXCI7IH1cblxuLmZhLWJhbmRjYW1wOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmQ1XCI7IH1cblxuLmZhLWJhcmNvZGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMmFcIjsgfVxuXG4uZmEtYmFyY29kZS1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NjNcIjsgfVxuXG4uZmEtYmFyY29kZS1yZWFkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDY0XCI7IH1cblxuLmZhLWJhcmNvZGUtc2NhbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ2NVwiOyB9XG5cbi5mYS1iYXJzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGM5XCI7IH1cblxuLmZhLWJhc2ViYWxsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDMyXCI7IH1cblxuLmZhLWJhc2ViYWxsLWJhbGw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MzNcIjsgfVxuXG4uZmEtYmFza2V0YmFsbC1iYWxsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDM0XCI7IH1cblxuLmZhLWJhc2tldGJhbGwtaG9vcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQzNVwiOyB9XG5cbi5mYS1iYXRoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmNkXCI7IH1cblxuLmZhLWJhdHRlcnktYm9sdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM3NlwiOyB9XG5cbi5mYS1iYXR0ZXJ5LWVtcHR5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjQ0XCI7IH1cblxuLmZhLWJhdHRlcnktZnVsbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI0MFwiOyB9XG5cbi5mYS1iYXR0ZXJ5LWhhbGY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNDJcIjsgfVxuXG4uZmEtYmF0dGVyeS1xdWFydGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjQzXCI7IH1cblxuLmZhLWJhdHRlcnktc2xhc2g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNzdcIjsgfVxuXG4uZmEtYmF0dGVyeS10aHJlZS1xdWFydGVyczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI0MVwiOyB9XG5cbi5mYS1iZWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMzZcIjsgfVxuXG4uZmEtYmVlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBmY1wiOyB9XG5cbi5mYS1iZWhhbmNlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWI0XCI7IH1cblxuLmZhLWJlaGFuY2Utc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWI1XCI7IH1cblxuLmZhLWJlbGw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZjNcIjsgfVxuXG4uZmEtYmVsbC1zbGFzaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFmNlwiOyB9XG5cbi5mYS1iaWN5Y2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjA2XCI7IH1cblxuLmZhLWJpbW9iamVjdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM3OFwiOyB9XG5cbi5mYS1iaW5vY3VsYXJzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWU1XCI7IH1cblxuLmZhLWJpcnRoZGF5LWNha2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZmRcIjsgfVxuXG4uZmEtYml0YnVja2V0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTcxXCI7IH1cblxuLmZhLWJpdGNvaW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNzlcIjsgfVxuXG4uZmEtYml0eTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM3YVwiOyB9XG5cbi5mYS1ibGFjay10aWU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyN2VcIjsgfVxuXG4uZmEtYmxhY2tiZXJyeTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM3YlwiOyB9XG5cbi5mYS1ibGluZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI5ZFwiOyB9XG5cbi5mYS1ibG9nZ2VyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzdjXCI7IH1cblxuLmZhLWJsb2dnZXItYjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM3ZFwiOyB9XG5cbi5mYS1ibHVldG9vdGg6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyOTNcIjsgfVxuXG4uZmEtYmx1ZXRvb3RoLWI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyOTRcIjsgfVxuXG4uZmEtYm9sZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAzMlwiOyB9XG5cbi5mYS1ib2x0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGU3XCI7IH1cblxuLmZhLWJvbWI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZTJcIjsgfVxuXG4uZmEtYm9vazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAyZFwiOyB9XG5cbi5mYS1ib29rbWFyazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAyZVwiOyB9XG5cbi5mYS1ib3dsaW5nLWJhbGw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MzZcIjsgfVxuXG4uZmEtYm93bGluZy1waW5zOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDM3XCI7IH1cblxuLmZhLWJveDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ2NlwiOyB9XG5cbi5mYS1ib3gtY2hlY2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NjdcIjsgfVxuXG4uZmEtYm94ZXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NjhcIjsgfVxuXG4uZmEtYm94aW5nLWdsb3ZlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDM4XCI7IH1cblxuLmZhLWJyYWlsbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYTFcIjsgfVxuXG4uZmEtYnJpZWZjYXNlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGIxXCI7IH1cblxuLmZhLWJyaWVmY2FzZS1tZWRpY2FsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDY5XCI7IH1cblxuLmZhLWJyb3dzZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzN2VcIjsgfVxuXG4uZmEtYnRjOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTVhXCI7IH1cblxuLmZhLWJ1ZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE4OFwiOyB9XG5cbi5mYS1idWlsZGluZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFhZFwiOyB9XG5cbi5mYS1idWxsaG9ybjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBhMVwiOyB9XG5cbi5mYS1idWxsc2V5ZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE0MFwiOyB9XG5cbi5mYS1idXJuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDZhXCI7IH1cblxuLmZhLWJ1cm9tb2JlbGV4cGVydGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzN2ZcIjsgfVxuXG4uZmEtYnVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjA3XCI7IH1cblxuLmZhLWJ1eXNlbGxhZHM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMGRcIjsgfVxuXG4uZmEtY2FsY3VsYXRvcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFlY1wiOyB9XG5cbi5mYS1jYWxlbmRhcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEzM1wiOyB9XG5cbi5mYS1jYWxlbmRhci1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNzNcIjsgfVxuXG4uZmEtY2FsZW5kYXItY2hlY2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNzRcIjsgfVxuXG4uZmEtY2FsZW5kYXItZWRpdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMzM1wiOyB9XG5cbi5mYS1jYWxlbmRhci1leGNsYW1hdGlvbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMzNFwiOyB9XG5cbi5mYS1jYWxlbmRhci1taW51czpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI3MlwiOyB9XG5cbi5mYS1jYWxlbmRhci1wbHVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjcxXCI7IH1cblxuLmZhLWNhbGVuZGFyLXRpbWVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjczXCI7IH1cblxuLmZhLWNhbWVyYTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAzMFwiOyB9XG5cbi5mYS1jYW1lcmEtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzMyXCI7IH1cblxuLmZhLWNhbWVyYS1yZXRybzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA4M1wiOyB9XG5cbi5mYS1jYXBzdWxlczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ2YlwiOyB9XG5cbi5mYS1jYXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYjlcIjsgfVxuXG4uZmEtY2FyZXQtY2lyY2xlLWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMmRcIjsgfVxuXG4uZmEtY2FyZXQtY2lyY2xlLWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMmVcIjsgfVxuXG4uZmEtY2FyZXQtY2lyY2xlLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzMwXCI7IH1cblxuLmZhLWNhcmV0LWNpcmNsZS11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMzMVwiOyB9XG5cbi5mYS1jYXJldC1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGQ3XCI7IH1cblxuLmZhLWNhcmV0LWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZDlcIjsgfVxuXG4uZmEtY2FyZXQtcmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZGFcIjsgfVxuXG4uZmEtY2FyZXQtc3F1YXJlLWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNTBcIjsgfVxuXG4uZmEtY2FyZXQtc3F1YXJlLWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxOTFcIjsgfVxuXG4uZmEtY2FyZXQtc3F1YXJlLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTUyXCI7IH1cblxuLmZhLWNhcmV0LXNxdWFyZS11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE1MVwiOyB9XG5cbi5mYS1jYXJldC11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBkOFwiOyB9XG5cbi5mYS1jYXJ0LWFycm93LWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMThcIjsgfVxuXG4uZmEtY2FydC1wbHVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjE3XCI7IH1cblxuLmZhLWNjLWFtYXpvbi1wYXk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MmRcIjsgfVxuXG4uZmEtY2MtYW1leDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFmM1wiOyB9XG5cbi5mYS1jYy1hcHBsZS1wYXk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MTZcIjsgfVxuXG4uZmEtY2MtZGluZXJzLWNsdWI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNGNcIjsgfVxuXG4uZmEtY2MtZGlzY292ZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZjJcIjsgfVxuXG4uZmEtY2MtamNiOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjRiXCI7IH1cblxuLmZhLWNjLW1hc3RlcmNhcmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZjFcIjsgfVxuXG4uZmEtY2MtcGF5cGFsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWY0XCI7IH1cblxuLmZhLWNjLXN0cmlwZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFmNVwiOyB9XG5cbi5mYS1jYy12aXNhOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWYwXCI7IH1cblxuLmZhLWNlbnRlcmNvZGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzODBcIjsgfVxuXG4uZmEtY2VydGlmaWNhdGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYTNcIjsgfVxuXG4uZmEtY2hhcnQtYXJlYTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFmZVwiOyB9XG5cbi5mYS1jaGFydC1iYXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwODBcIjsgfVxuXG4uZmEtY2hhcnQtbGluZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIwMVwiOyB9XG5cbi5mYS1jaGFydC1waWU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMDBcIjsgfVxuXG4uZmEtY2hlY2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMGNcIjsgfVxuXG4uZmEtY2hlY2stY2lyY2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDU4XCI7IH1cblxuLmZhLWNoZWNrLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE0YVwiOyB9XG5cbi5mYS1jaGVzczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQzOVwiOyB9XG5cbi5mYS1jaGVzcy1iaXNob3A6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0M2FcIjsgfVxuXG4uZmEtY2hlc3MtYmlzaG9wLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQzYlwiOyB9XG5cbi5mYS1jaGVzcy1ib2FyZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQzY1wiOyB9XG5cbi5mYS1jaGVzcy1jbG9jazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQzZFwiOyB9XG5cbi5mYS1jaGVzcy1jbG9jay1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0M2VcIjsgfVxuXG4uZmEtY2hlc3Mta2luZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQzZlwiOyB9XG5cbi5mYS1jaGVzcy1raW5nLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ0MFwiOyB9XG5cbi5mYS1jaGVzcy1rbmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NDFcIjsgfVxuXG4uZmEtY2hlc3Mta25pZ2h0LWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ0MlwiOyB9XG5cbi5mYS1jaGVzcy1wYXduOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDQzXCI7IH1cblxuLmZhLWNoZXNzLXBhd24tYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDQ0XCI7IH1cblxuLmZhLWNoZXNzLXF1ZWVuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDQ1XCI7IH1cblxuLmZhLWNoZXNzLXF1ZWVuLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ0NlwiOyB9XG5cbi5mYS1jaGVzcy1yb29rOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDQ3XCI7IH1cblxuLmZhLWNoZXNzLXJvb2stYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDQ4XCI7IH1cblxuLmZhLWNoZXZyb24tY2lyY2xlLWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxM2FcIjsgfVxuXG4uZmEtY2hldnJvbi1jaXJjbGUtbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEzN1wiOyB9XG5cbi5mYS1jaGV2cm9uLWNpcmNsZS1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEzOFwiOyB9XG5cbi5mYS1jaGV2cm9uLWNpcmNsZS11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEzOVwiOyB9XG5cbi5mYS1jaGV2cm9uLWRvdWJsZS1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzIyXCI7IH1cblxuLmZhLWNoZXZyb24tZG91YmxlLWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMjNcIjsgfVxuXG4uZmEtY2hldnJvbi1kb3VibGUtcmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMjRcIjsgfVxuXG4uZmEtY2hldnJvbi1kb3VibGUtdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMjVcIjsgfVxuXG4uZmEtY2hldnJvbi1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDc4XCI7IH1cblxuLmZhLWNoZXZyb24tbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA1M1wiOyB9XG5cbi5mYS1jaGV2cm9uLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDU0XCI7IH1cblxuLmZhLWNoZXZyb24tc3F1YXJlLWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMjlcIjsgfVxuXG4uZmEtY2hldnJvbi1zcXVhcmUtbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMyYVwiOyB9XG5cbi5mYS1jaGV2cm9uLXNxdWFyZS1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMyYlwiOyB9XG5cbi5mYS1jaGV2cm9uLXNxdWFyZS11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMyY1wiOyB9XG5cbi5mYS1jaGV2cm9uLXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDc3XCI7IH1cblxuLmZhLWNoaWxkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWFlXCI7IH1cblxuLmZhLWNocm9tZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI2OFwiOyB9XG5cbi5mYS1jaXJjbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMTFcIjsgfVxuXG4uZmEtY2lyY2xlLW5vdGNoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWNlXCI7IH1cblxuLmZhLWNsaXBib2FyZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMyOFwiOyB9XG5cbi5mYS1jbGlwYm9hcmQtY2hlY2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NmNcIjsgfVxuXG4uZmEtY2xpcGJvYXJkLWxpc3Q6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NmRcIjsgfVxuXG4uZmEtY2xvY2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMTdcIjsgfVxuXG4uZmEtY2xvbmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNGRcIjsgfVxuXG4uZmEtY2xvc2VkLWNhcHRpb25pbmc6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMGFcIjsgfVxuXG4uZmEtY2xvdWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYzJcIjsgfVxuXG4uZmEtY2xvdWQtZG93bmxvYWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZWRcIjsgfVxuXG4uZmEtY2xvdWQtZG93bmxvYWQtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzgxXCI7IH1cblxuLmZhLWNsb3VkLXVwbG9hZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBlZVwiOyB9XG5cbi5mYS1jbG91ZC11cGxvYWQtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzgyXCI7IH1cblxuLmZhLWNsb3Vkc2NhbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzODNcIjsgfVxuXG4uZmEtY2xvdWRzbWl0aDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM4NFwiOyB9XG5cbi5mYS1jbG91ZHZlcnNpZnk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzODVcIjsgfVxuXG4uZmEtY2x1YjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMyN1wiOyB9XG5cbi5mYS1jb2RlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTIxXCI7IH1cblxuLmZhLWNvZGUtYnJhbmNoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTI2XCI7IH1cblxuLmZhLWNvZGUtY29tbWl0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzg2XCI7IH1cblxuLmZhLWNvZGUtbWVyZ2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzODdcIjsgfVxuXG4uZmEtY29kZXBlbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFjYlwiOyB9XG5cbi5mYS1jb2RpZXBpZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI4NFwiOyB9XG5cbi5mYS1jb2ZmZWU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZjRcIjsgfVxuXG4uZmEtY29nOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDEzXCI7IH1cblxuLmZhLWNvZ3M6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwODVcIjsgfVxuXG4uZmEtY29sdW1uczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBkYlwiOyB9XG5cbi5mYS1jb21tZW50OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDc1XCI7IH1cblxuLmZhLWNvbW1lbnQtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjdhXCI7IH1cblxuLmZhLWNvbW1lbnRzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDg2XCI7IH1cblxuLmZhLWNvbXBhc3M6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNGVcIjsgfVxuXG4uZmEtY29tcHJlc3M6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNjZcIjsgfVxuXG4uZmEtY29tcHJlc3MtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDIyXCI7IH1cblxuLmZhLWNvbXByZXNzLXdpZGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMjZcIjsgfVxuXG4uZmEtY29ubmVjdGRldmVsb3A6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMGVcIjsgfVxuXG4uZmEtY29udGFvOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjZkXCI7IH1cblxuLmZhLWNvbnZleW9yLWJlbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NmVcIjsgfVxuXG4uZmEtY29udmV5b3ItYmVsdC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NmZcIjsgfVxuXG4uZmEtY29weTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBjNVwiOyB9XG5cbi5mYS1jb3B5cmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZjlcIjsgfVxuXG4uZmEtY3BhbmVsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzg4XCI7IH1cblxuLmZhLWNyZWF0aXZlLWNvbW1vbnM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNWVcIjsgfVxuXG4uZmEtY3JlZGl0LWNhcmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwOWRcIjsgfVxuXG4uZmEtY3JlZGl0LWNhcmQtYmxhbms6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzODlcIjsgfVxuXG4uZmEtY3JlZGl0LWNhcmQtZnJvbnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOGFcIjsgfVxuXG4uZmEtY3JpY2tldDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ0OVwiOyB9XG5cbi5mYS1jcm9wOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTI1XCI7IH1cblxuLmZhLWNyb3NzaGFpcnM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNWJcIjsgfVxuXG4uZmEtY3NzMzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEzY1wiOyB9XG5cbi5mYS1jc3MzLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM4YlwiOyB9XG5cbi5mYS1jdWJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWIyXCI7IH1cblxuLmZhLWN1YmVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWIzXCI7IH1cblxuLmZhLWN1cmxpbmc6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NGFcIjsgfVxuXG4uZmEtY3V0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGM0XCI7IH1cblxuLmZhLWN1dHRsZWZpc2g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOGNcIjsgfVxuXG4uZmEtZC1hbmQtZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM4ZFwiOyB9XG5cbi5mYS1kYXNoY3ViZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIxMFwiOyB9XG5cbi5mYS1kYXRhYmFzZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFjMFwiOyB9XG5cbi5mYS1kZWFmOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmE0XCI7IH1cblxuLmZhLWRlbGljaW91czpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFhNVwiOyB9XG5cbi5mYS1kZXBsb3lkb2c6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOGVcIjsgfVxuXG4uZmEtZGVza3BybzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM4ZlwiOyB9XG5cbi5mYS1kZXNrdG9wOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTA4XCI7IH1cblxuLmZhLWRlc2t0b3AtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzkwXCI7IH1cblxuLmZhLWRldmlhbnRhcnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYmRcIjsgfVxuXG4uZmEtZGlhZ25vc2VzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDcwXCI7IH1cblxuLmZhLWRpYW1vbmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMTlcIjsgfVxuXG4uZmEtZGlnZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFhNlwiOyB9XG5cbi5mYS1kaWdpdGFsLW9jZWFuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzkxXCI7IH1cblxuLmZhLWRpc2NvcmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOTJcIjsgfVxuXG4uZmEtZGlzY291cnNlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzkzXCI7IH1cblxuLmZhLWRuYTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ3MVwiOyB9XG5cbi5mYS1kb2NodWI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOTRcIjsgfVxuXG4uZmEtZG9ja2VyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzk1XCI7IH1cblxuLmZhLWRvbGxhci1zaWduOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTU1XCI7IH1cblxuLmZhLWRvbGx5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDcyXCI7IH1cblxuLmZhLWRvbGx5LWVtcHR5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDczXCI7IH1cblxuLmZhLWRvbGx5LWZsYXRiZWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NzRcIjsgfVxuXG4uZmEtZG9sbHktZmxhdGJlZC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NzVcIjsgfVxuXG4uZmEtZG9sbHktZmxhdGJlZC1lbXB0eTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ3NlwiOyB9XG5cbi5mYS1kb3QtY2lyY2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTkyXCI7IH1cblxuLmZhLWRvd25sb2FkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDE5XCI7IH1cblxuLmZhLWRyYWZ0MmRpZ2l0YWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOTZcIjsgfVxuXG4uZmEtZHJpYmJibGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxN2RcIjsgfVxuXG4uZmEtZHJpYmJibGUtc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzk3XCI7IH1cblxuLmZhLWRyb3Bib3g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNmJcIjsgfVxuXG4uZmEtZHJ1cGFsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWE5XCI7IH1cblxuLmZhLWR1bWJiZWxsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDRiXCI7IH1cblxuLmZhLWR5YWxvZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM5OVwiOyB9XG5cbi5mYS1lYXJseWJpcmRzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzlhXCI7IH1cblxuLmZhLWVkZ2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyODJcIjsgfVxuXG4uZmEtZWRpdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA0NFwiOyB9XG5cbi5mYS1lamVjdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA1MlwiOyB9XG5cbi5mYS1lbGVtZW50b3I6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MzBcIjsgfVxuXG4uZmEtZWxsaXBzaXMtaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE0MVwiOyB9XG5cbi5mYS1lbGxpcHNpcy1oLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM5YlwiOyB9XG5cbi5mYS1lbGxpcHNpcy12OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTQyXCI7IH1cblxuLmZhLWVsbGlwc2lzLXYtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzljXCI7IH1cblxuLmZhLWVtYmVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDIzXCI7IH1cblxuLmZhLWVtcGlyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFkMVwiOyB9XG5cbi5mYS1lbnZlbG9wZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBlMFwiOyB9XG5cbi5mYS1lbnZlbG9wZS1vcGVuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmI2XCI7IH1cblxuLmZhLWVudmVsb3BlLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE5OVwiOyB9XG5cbi5mYS1lbnZpcmE6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyOTlcIjsgfVxuXG4uZmEtZXJhc2VyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTJkXCI7IH1cblxuLmZhLWVybGFuZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM5ZFwiOyB9XG5cbi5mYS1ldGhlcmV1bTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQyZVwiOyB9XG5cbi5mYS1ldHN5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmQ3XCI7IH1cblxuLmZhLWV1cm8tc2lnbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE1M1wiOyB9XG5cbi5mYS1leGNoYW5nZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBlY1wiOyB9XG5cbi5mYS1leGNoYW5nZS1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNjJcIjsgfVxuXG4uZmEtZXhjbGFtYXRpb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMmFcIjsgfVxuXG4uZmEtZXhjbGFtYXRpb24tY2lyY2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDZhXCI7IH1cblxuLmZhLWV4Y2xhbWF0aW9uLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMyMVwiOyB9XG5cbi5mYS1leGNsYW1hdGlvbi10cmlhbmdsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA3MVwiOyB9XG5cbi5mYS1leHBhbmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNjVcIjsgfVxuXG4uZmEtZXhwYW5kLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQyNFwiOyB9XG5cbi5mYS1leHBhbmQtYXJyb3dzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzFkXCI7IH1cblxuLmZhLWV4cGFuZC1hcnJvd3MtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzFlXCI7IH1cblxuLmZhLWV4cGFuZC13aWRlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzIwXCI7IH1cblxuLmZhLWV4cGVkaXRlZHNzbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIzZVwiOyB9XG5cbi5mYS1leHRlcm5hbC1saW5rOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDhlXCI7IH1cblxuLmZhLWV4dGVybmFsLWxpbmstYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzVkXCI7IH1cblxuLmZhLWV4dGVybmFsLWxpbmstc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTRjXCI7IH1cblxuLmZhLWV4dGVybmFsLWxpbmstc3F1YXJlLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM2MFwiOyB9XG5cbi5mYS1leWU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNmVcIjsgfVxuXG4uZmEtZXllLWRyb3BwZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZmJcIjsgfVxuXG4uZmEtZXllLXNsYXNoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDcwXCI7IH1cblxuLmZhLWZhY2Vib29rOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDlhXCI7IH1cblxuLmZhLWZhY2Vib29rLWY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOWVcIjsgfVxuXG4uZmEtZmFjZWJvb2stbWVzc2VuZ2VyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzlmXCI7IH1cblxuLmZhLWZhY2Vib29rLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA4MlwiOyB9XG5cbi5mYS1mYXN0LWJhY2t3YXJkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDQ5XCI7IH1cblxuLmZhLWZhc3QtZm9yd2FyZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA1MFwiOyB9XG5cbi5mYS1mYXg6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYWNcIjsgfVxuXG4uZmEtZmVtYWxlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTgyXCI7IH1cblxuLmZhLWZpZWxkLWhvY2tleTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ0Y1wiOyB9XG5cbi5mYS1maWdodGVyLWpldDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBmYlwiOyB9XG5cbi5mYS1maWxlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTViXCI7IH1cblxuLmZhLWZpbGUtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTVjXCI7IH1cblxuLmZhLWZpbGUtYXJjaGl2ZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFjNlwiOyB9XG5cbi5mYS1maWxlLWF1ZGlvOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWM3XCI7IH1cblxuLmZhLWZpbGUtY2hlY2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMTZcIjsgfVxuXG4uZmEtZmlsZS1jb2RlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWM5XCI7IH1cblxuLmZhLWZpbGUtZWRpdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMxY1wiOyB9XG5cbi5mYS1maWxlLWV4Y2VsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWMzXCI7IH1cblxuLmZhLWZpbGUtZXhjbGFtYXRpb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMWFcIjsgfVxuXG4uZmEtZmlsZS1pbWFnZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFjNVwiOyB9XG5cbi5mYS1maWxlLW1lZGljYWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NzdcIjsgfVxuXG4uZmEtZmlsZS1tZWRpY2FsLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ3OFwiOyB9XG5cbi5mYS1maWxlLW1pbnVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzE4XCI7IH1cblxuLmZhLWZpbGUtcGRmOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWMxXCI7IH1cblxuLmZhLWZpbGUtcGx1czpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMxOVwiOyB9XG5cbi5mYS1maWxlLXBvd2VycG9pbnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYzRcIjsgfVxuXG4uZmEtZmlsZS10aW1lczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMxN1wiOyB9XG5cbi5mYS1maWxlLXZpZGVvOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWM4XCI7IH1cblxuLmZhLWZpbGUtd29yZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFjMlwiOyB9XG5cbi5mYS1maWxtOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDA4XCI7IH1cblxuLmZhLWZpbG0tYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2EwXCI7IH1cblxuLmZhLWZpbHRlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBiMFwiOyB9XG5cbi5mYS1maXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDZkXCI7IH1cblxuLmZhLWZpcmUtZXh0aW5ndWlzaGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTM0XCI7IH1cblxuLmZhLWZpcmVmb3g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNjlcIjsgfVxuXG4uZmEtZmlyc3QtYWlkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDc5XCI7IH1cblxuLmZhLWZpcnN0LW9yZGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmIwXCI7IH1cblxuLmZhLWZpcnN0ZHJhZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYTFcIjsgfVxuXG4uZmEtZmxhZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAyNFwiOyB9XG5cbi5mYS1mbGFnLWNoZWNrZXJlZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjExZVwiOyB9XG5cbi5mYS1mbGFzazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBjM1wiOyB9XG5cbi5mYS1mbGlja3I6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNmVcIjsgfVxuXG4uZmEtZmxpcGJvYXJkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDRkXCI7IH1cblxuLmZhLWZseTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQxN1wiOyB9XG5cbi5mYS1mb2xkZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwN2JcIjsgfVxuXG4uZmEtZm9sZGVyLW9wZW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwN2NcIjsgfVxuXG4uZmEtZm9udDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAzMVwiOyB9XG5cbi5mYS1mb250LWF3ZXNvbWU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYjRcIjsgfVxuXG4uZmEtZm9udC1hd2Vzb21lLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM1Y1wiOyB9XG5cbi5mYS1mb250LWF3ZXNvbWUtZmxhZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQyNVwiOyB9XG5cbi5mYS1mb250aWNvbnM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyODBcIjsgfVxuXG4uZmEtZm9udGljb25zLWZpOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2EyXCI7IH1cblxuLmZhLWZvb3RiYWxsLWJhbGw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NGVcIjsgfVxuXG4uZmEtZm9vdGJhbGwtaGVsbWV0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDRmXCI7IH1cblxuLmZhLWZvcmtsaWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDdhXCI7IH1cblxuLmZhLWZvcnQtYXdlc29tZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI4NlwiOyB9XG5cbi5mYS1mb3J0LWF3ZXNvbWUtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2EzXCI7IH1cblxuLmZhLWZvcnVtYmVlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjExXCI7IH1cblxuLmZhLWZvcndhcmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNGVcIjsgfVxuXG4uZmEtZm91cnNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE4MFwiOyB9XG5cbi5mYS1mcmVlLWNvZGUtY2FtcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJjNVwiOyB9XG5cbi5mYS1mcmVlYnNkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2E0XCI7IH1cblxuLmZhLWZyb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTE5XCI7IH1cblxuLmZhLWZ1dGJvbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFlM1wiOyB9XG5cbi5mYS1nYW1lcGFkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTFiXCI7IH1cblxuLmZhLWdhdmVsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGUzXCI7IH1cblxuLmZhLWdlbTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNhNVwiOyB9XG5cbi5mYS1nZW5kZXJsZXNzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjJkXCI7IH1cblxuLmZhLWdldC1wb2NrZXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNjVcIjsgfVxuXG4uZmEtZ2c6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNjBcIjsgfVxuXG4uZmEtZ2ctY2lyY2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjYxXCI7IH1cblxuLmZhLWdpZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNmJcIjsgfVxuXG4uZmEtZ2l0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWQzXCI7IH1cblxuLmZhLWdpdC1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZDJcIjsgfVxuXG4uZmEtZ2l0aHViOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDliXCI7IH1cblxuLmZhLWdpdGh1Yi1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMTNcIjsgfVxuXG4uZmEtZ2l0aHViLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA5MlwiOyB9XG5cbi5mYS1naXRrcmFrZW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYTZcIjsgfVxuXG4uZmEtZ2l0bGFiOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjk2XCI7IH1cblxuLmZhLWdpdHRlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQyNlwiOyB9XG5cbi5mYS1nbGFzcy1tYXJ0aW5pOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDAwXCI7IH1cblxuLmZhLWdsaWRlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmE1XCI7IH1cblxuLmZhLWdsaWRlLWc6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYTZcIjsgfVxuXG4uZmEtZ2xvYmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYWNcIjsgfVxuXG4uZmEtZ29mb3JlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2E3XCI7IH1cblxuLmZhLWdvbGYtYmFsbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ1MFwiOyB9XG5cbi5mYS1nb2xmLWNsdWI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NTFcIjsgfVxuXG4uZmEtZ29vZHJlYWRzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2E4XCI7IH1cblxuLmZhLWdvb2RyZWFkcy1nOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2E5XCI7IH1cblxuLmZhLWdvb2dsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFhMFwiOyB9XG5cbi5mYS1nb29nbGUtZHJpdmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYWFcIjsgfVxuXG4uZmEtZ29vZ2xlLXBsYXk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYWJcIjsgfVxuXG4uZmEtZ29vZ2xlLXBsdXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYjNcIjsgfVxuXG4uZmEtZ29vZ2xlLXBsdXMtZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBkNVwiOyB9XG5cbi5mYS1nb29nbGUtcGx1cy1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZDRcIjsgfVxuXG4uZmEtZ29vZ2xlLXdhbGxldDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFlZVwiOyB9XG5cbi5mYS1ncmFkdWF0aW9uLWNhcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE5ZFwiOyB9XG5cbi5mYS1ncmF0aXBheTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE4NFwiOyB9XG5cbi5mYS1ncmF2OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmQ2XCI7IH1cblxuLmZhLWdyaXBmaXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2FjXCI7IH1cblxuLmZhLWdydW50OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2FkXCI7IH1cblxuLmZhLWd1bHA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYWVcIjsgfVxuXG4uZmEtaC1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZmRcIjsgfVxuXG4uZmEtaDE6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMTNcIjsgfVxuXG4uZmEtaDI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMTRcIjsgfVxuXG4uZmEtaDM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMTVcIjsgfVxuXG4uZmEtaGFja2VyLW5ld3M6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZDRcIjsgfVxuXG4uZmEtaGFja2VyLW5ld3Mtc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2FmXCI7IH1cblxuLmZhLWhhbmQtaG9sZGluZy1ib3g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0N2JcIjsgfVxuXG4uZmEtaGFuZC1saXphcmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNThcIjsgfVxuXG4uZmEtaGFuZC1wYXBlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI1NlwiOyB9XG5cbi5mYS1oYW5kLXBlYWNlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjViXCI7IH1cblxuLmZhLWhhbmQtcG9pbnQtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBhN1wiOyB9XG5cbi5mYS1oYW5kLXBvaW50LWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYTVcIjsgfVxuXG4uZmEtaGFuZC1wb2ludC1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBhNFwiOyB9XG5cbi5mYS1oYW5kLXBvaW50LXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGE2XCI7IH1cblxuLmZhLWhhbmQtcG9pbnRlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI1YVwiOyB9XG5cbi5mYS1oYW5kLXJlY2VpdmluZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ3Y1wiOyB9XG5cbi5mYS1oYW5kLXJvY2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNTVcIjsgfVxuXG4uZmEtaGFuZC1zY2lzc29yczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI1N1wiOyB9XG5cbi5mYS1oYW5kLXNwb2NrOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjU5XCI7IH1cblxuLmZhLWhhbmRzaGFrZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJiNVwiOyB9XG5cbi5mYS1oYXNodGFnOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjkyXCI7IH1cblxuLmZhLWhkZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBhMFwiOyB9XG5cbi5mYS1oZWFkaW5nOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWRjXCI7IH1cblxuLmZhLWhlYWRwaG9uZXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMjVcIjsgfVxuXG4uZmEtaGVhcnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMDRcIjsgfVxuXG4uZmEtaGVhcnRiZWF0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjFlXCI7IH1cblxuLmZhLWhleGFnb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMTJcIjsgfVxuXG4uZmEtaGlwczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ1MlwiOyB9XG5cbi5mYS1oaXJlLWEtaGVscGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2IwXCI7IH1cblxuLmZhLWhpc3Rvcnk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZGFcIjsgfVxuXG4uZmEtaG9ja2V5LXB1Y2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NTNcIjsgfVxuXG4uZmEtaG9ja2V5LXN0aWNrczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ1NFwiOyB9XG5cbi5mYS1ob21lOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDE1XCI7IH1cblxuLmZhLWhvb2xpOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDI3XCI7IH1cblxuLmZhLWhvc3BpdGFsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGY4XCI7IH1cblxuLmZhLWhvc3BpdGFsLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ3ZFwiOyB9XG5cbi5mYS1ob3NwaXRhbC1zeW1ib2w6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0N2VcIjsgfVxuXG4uZmEtaG90amFyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2IxXCI7IH1cblxuLmZhLWhvdXJnbGFzczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI1NFwiOyB9XG5cbi5mYS1ob3VyZ2xhc3MtZW5kOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjUzXCI7IH1cblxuLmZhLWhvdXJnbGFzcy1oYWxmOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjUyXCI7IH1cblxuLmZhLWhvdXJnbGFzcy1zdGFydDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI1MVwiOyB9XG5cbi5mYS1ob3V6ejpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI3Y1wiOyB9XG5cbi5mYS1odG1sNTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEzYlwiOyB9XG5cbi5mYS1odWJzcG90OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2IyXCI7IH1cblxuLmZhLWktY3Vyc29yOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjQ2XCI7IH1cblxuLmZhLWlkLWJhZGdlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmMxXCI7IH1cblxuLmZhLWlkLWNhcmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYzJcIjsgfVxuXG4uZmEtaWQtY2FyZC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0N2ZcIjsgfVxuXG4uZmEtaW1hZ2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwM2VcIjsgfVxuXG4uZmEtaW1hZ2VzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzAyXCI7IH1cblxuLmZhLWltZGI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZDhcIjsgfVxuXG4uZmEtaW5ib3g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMWNcIjsgfVxuXG4uZmEtaW5ib3gtaW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMTBcIjsgfVxuXG4uZmEtaW5ib3gtb3V0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzExXCI7IH1cblxuLmZhLWluZGVudDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAzY1wiOyB9XG5cbi5mYS1pbmR1c3RyeTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI3NVwiOyB9XG5cbi5mYS1pbmR1c3RyeS1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYjNcIjsgfVxuXG4uZmEtaW5mbzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEyOVwiOyB9XG5cbi5mYS1pbmZvLWNpcmNsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA1YVwiOyB9XG5cbi5mYS1pbmZvLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMwZlwiOyB9XG5cbi5mYS1pbnN0YWdyYW06YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNmRcIjsgfVxuXG4uZmEtaW50ZXJuZXQtZXhwbG9yZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNmJcIjsgfVxuXG4uZmEtaW52ZW50b3J5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDgwXCI7IH1cblxuLmZhLWlveGhvc3Q6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMDhcIjsgfVxuXG4uZmEtaXRhbGljOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDMzXCI7IH1cblxuLmZhLWl0dW5lczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNiNFwiOyB9XG5cbi5mYS1pdHVuZXMtbm90ZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNiNVwiOyB9XG5cbi5mYS1qYWNrLW8tbGFudGVybjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMwZVwiOyB9XG5cbi5mYS1qZW5raW5zOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2I2XCI7IH1cblxuLmZhLWpvZ2V0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2I3XCI7IH1cblxuLmZhLWpvb21sYTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFhYVwiOyB9XG5cbi5mYS1qczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNiOFwiOyB9XG5cbi5mYS1qcy1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYjlcIjsgfVxuXG4uZmEtanNmaWRkbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxY2NcIjsgfVxuXG4uZmEta2V5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDg0XCI7IH1cblxuLmZhLWtleWJvYXJkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTFjXCI7IH1cblxuLmZhLWtleWNkbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNiYVwiOyB9XG5cbi5mYS1raWNrc3RhcnRlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNiYlwiOyB9XG5cbi5mYS1raWNrc3RhcnRlci1rOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2JjXCI7IH1cblxuLmZhLWtvcnZ1ZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQyZlwiOyB9XG5cbi5mYS1sYW5ndWFnZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFhYlwiOyB9XG5cbi5mYS1sYXB0b3A6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMDlcIjsgfVxuXG4uZmEtbGFyYXZlbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNiZFwiOyB9XG5cbi5mYS1sYXN0Zm06YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMDJcIjsgfVxuXG4uZmEtbGFzdGZtLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIwM1wiOyB9XG5cbi5mYS1sZWFmOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDZjXCI7IH1cblxuLmZhLWxlYW5wdWI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMTJcIjsgfVxuXG4uZmEtbGVtb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwOTRcIjsgfVxuXG4uZmEtbGVzczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQxZFwiOyB9XG5cbi5mYS1sZXZlbC1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTQ5XCI7IH1cblxuLmZhLWxldmVsLWRvd24tYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2JlXCI7IH1cblxuLmZhLWxldmVsLXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTQ4XCI7IH1cblxuLmZhLWxldmVsLXVwLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNiZlwiOyB9XG5cbi5mYS1saWZlLXJpbmc6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxY2RcIjsgfVxuXG4uZmEtbGlnaHRidWxiOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGViXCI7IH1cblxuLmZhLWxpbmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYzBcIjsgfVxuXG4uZmEtbGluazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBjMVwiOyB9XG5cbi5mYS1saW5rZWRpbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA4Y1wiOyB9XG5cbi5mYS1saW5rZWRpbi1pbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBlMVwiOyB9XG5cbi5mYS1saW5vZGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYjhcIjsgfVxuXG4uZmEtbGludXg6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxN2NcIjsgfVxuXG4uZmEtbGlyYS1zaWduOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTk1XCI7IH1cblxuLmZhLWxpc3Q6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwM2FcIjsgfVxuXG4uZmEtbGlzdC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMjJcIjsgfVxuXG4uZmEtbGlzdC1vbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBjYlwiOyB9XG5cbi5mYS1saXN0LXVsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGNhXCI7IH1cblxuLmZhLWxvY2F0aW9uLWFycm93OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTI0XCI7IH1cblxuLmZhLWxvY2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMjNcIjsgfVxuXG4uZmEtbG9jay1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMGRcIjsgfVxuXG4uZmEtbG9jay1vcGVuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2MxXCI7IH1cblxuLmZhLWxvY2stb3Blbi1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYzJcIjsgfVxuXG4uZmEtbG9uZy1hcnJvdy1hbHQtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMwOVwiOyB9XG5cbi5mYS1sb25nLWFycm93LWFsdC1sZWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzBhXCI7IH1cblxuLmZhLWxvbmctYXJyb3ctYWx0LXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzBiXCI7IH1cblxuLmZhLWxvbmctYXJyb3ctYWx0LXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzBjXCI7IH1cblxuLmZhLWxvbmctYXJyb3ctZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE3NVwiOyB9XG5cbi5mYS1sb25nLWFycm93LWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNzdcIjsgfVxuXG4uZmEtbG9uZy1hcnJvdy1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE3OFwiOyB9XG5cbi5mYS1sb25nLWFycm93LXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTc2XCI7IH1cblxuLmZhLWxvdy12aXNpb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYThcIjsgfVxuXG4uZmEtbHVjaGFkb3I6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NTVcIjsgfVxuXG4uZmEtbHlmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNjM1wiOyB9XG5cbi5mYS1tYWdlbnRvOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2M0XCI7IH1cblxuLmZhLW1hZ2ljOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGQwXCI7IH1cblxuLmZhLW1hZ25ldDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA3NlwiOyB9XG5cbi5mYS1tYWxlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTgzXCI7IH1cblxuLmZhLW1hcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI3OVwiOyB9XG5cbi5mYS1tYXAtbWFya2VyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDQxXCI7IH1cblxuLmZhLW1hcC1tYXJrZXItYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2M1XCI7IH1cblxuLmZhLW1hcC1waW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNzZcIjsgfVxuXG4uZmEtbWFwLXNpZ25zOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjc3XCI7IH1cblxuLmZhLW1hcnM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMjJcIjsgfVxuXG4uZmEtbWFycy1kb3VibGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMjdcIjsgfVxuXG4uZmEtbWFycy1zdHJva2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMjlcIjsgfVxuXG4uZmEtbWFycy1zdHJva2UtaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIyYlwiOyB9XG5cbi5mYS1tYXJzLXN0cm9rZS12OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjJhXCI7IH1cblxuLmZhLW1heGNkbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEzNlwiOyB9XG5cbi5mYS1tZWRhcHBzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2M2XCI7IH1cblxuLmZhLW1lZGl1bTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIzYVwiOyB9XG5cbi5mYS1tZWRpdW0tbTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNjN1wiOyB9XG5cbi5mYS1tZWRraXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZmFcIjsgfVxuXG4uZmEtbWVkcnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYzhcIjsgfVxuXG4uZmEtbWVldHVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmUwXCI7IH1cblxuLmZhLW1laDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjExYVwiOyB9XG5cbi5mYS1tZXJjdXJ5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjIzXCI7IH1cblxuLmZhLW1pY3JvY2hpcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJkYlwiOyB9XG5cbi5mYS1taWNyb3Bob25lOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTMwXCI7IH1cblxuLmZhLW1pY3JvcGhvbmUtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2M5XCI7IH1cblxuLmZhLW1pY3JvcGhvbmUtc2xhc2g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMzFcIjsgfVxuXG4uZmEtbWljcm9zb2Z0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2NhXCI7IH1cblxuLmZhLW1pbnVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDY4XCI7IH1cblxuLmZhLW1pbnVzLWNpcmNsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA1NlwiOyB9XG5cbi5mYS1taW51cy1oZXhhZ29uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzA3XCI7IH1cblxuLmZhLW1pbnVzLW9jdGFnb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMDhcIjsgfVxuXG4uZmEtbWludXMtc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTQ2XCI7IH1cblxuLmZhLW1peDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNjYlwiOyB9XG5cbi5mYS1taXhjbG91ZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI4OVwiOyB9XG5cbi5mYS1taXp1bmk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzY2NcIjsgfVxuXG4uZmEtbW9iaWxlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTBiXCI7IH1cblxuLmZhLW1vYmlsZS1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzY2RcIjsgfVxuXG4uZmEtbW9iaWxlLWFuZHJvaWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzY2VcIjsgfVxuXG4uZmEtbW9iaWxlLWFuZHJvaWQtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2NmXCI7IH1cblxuLmZhLW1vZHg6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyODVcIjsgfVxuXG4uZmEtbW9uZXJvOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2QwXCI7IH1cblxuLmZhLW1vbmV5LWJpbGw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZDZcIjsgfVxuXG4uZmEtbW9uZXktYmlsbC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZDFcIjsgfVxuXG4uZmEtbW9vbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE4NlwiOyB9XG5cbi5mYS1tb3RvcmN5Y2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjFjXCI7IH1cblxuLmZhLW1vdXNlLXBvaW50ZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNDVcIjsgfVxuXG4uZmEtbXVzaWM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMDFcIjsgfVxuXG4uZmEtbmFwc3RlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNkMlwiOyB9XG5cbi5mYS1uZXV0ZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMmNcIjsgfVxuXG4uZmEtbmV3c3BhcGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWVhXCI7IH1cblxuLmZhLW5pbnRlbmRvLXN3aXRjaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQxOFwiOyB9XG5cbi5mYS1ub2RlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDE5XCI7IH1cblxuLmZhLW5vZGUtanM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZDNcIjsgfVxuXG4uZmEtbm90ZXMtbWVkaWNhbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ4MVwiOyB9XG5cbi5mYS1ucG06YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZDRcIjsgfVxuXG4uZmEtbnM4OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2Q1XCI7IH1cblxuLmZhLW51dHJpdGlvbml4OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2Q2XCI7IH1cblxuLmZhLW9iamVjdC1ncm91cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI0N1wiOyB9XG5cbi5mYS1vYmplY3QtdW5ncm91cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI0OFwiOyB9XG5cbi5mYS1vY3RhZ29uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzA2XCI7IH1cblxuLmZhLW9kbm9rbGFzc25pa2k6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNjNcIjsgfVxuXG4uZmEtb2Rub2tsYXNzbmlraS1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNjRcIjsgfVxuXG4uZmEtb3BlbmNhcnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyM2RcIjsgfVxuXG4uZmEtb3BlbmlkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTliXCI7IH1cblxuLmZhLW9wZXJhOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjZhXCI7IH1cblxuLmZhLW9wdGluLW1vbnN0ZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyM2NcIjsgfVxuXG4uZmEtb3NpOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDFhXCI7IH1cblxuLmZhLW91dGRlbnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwM2JcIjsgfVxuXG4uZmEtcGFnZTQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZDdcIjsgfVxuXG4uZmEtcGFnZWxpbmVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMThjXCI7IH1cblxuLmZhLXBhaW50LWJydXNoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWZjXCI7IH1cblxuLmZhLXBhbGZlZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNkOFwiOyB9XG5cbi5mYS1wYWxsZXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0ODJcIjsgfVxuXG4uZmEtcGFsbGV0LWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ4M1wiOyB9XG5cbi5mYS1wYXBlci1wbGFuZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFkOFwiOyB9XG5cbi5mYS1wYXBlcmNsaXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYzZcIjsgfVxuXG4uZmEtcGFyYWdyYXBoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWRkXCI7IH1cblxuLmZhLXBhc3RlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGVhXCI7IH1cblxuLmZhLXBhdHJlb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZDlcIjsgfVxuXG4uZmEtcGF1c2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNGNcIjsgfVxuXG4uZmEtcGF1c2UtY2lyY2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjhiXCI7IH1cblxuLmZhLXBhdzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFiMFwiOyB9XG5cbi5mYS1wYXlwYWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZWRcIjsgfVxuXG4uZmEtcGVuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzA0XCI7IH1cblxuLmZhLXBlbi1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMDVcIjsgfVxuXG4uZmEtcGVuLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE0YlwiOyB9XG5cbi5mYS1wZW5jaWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNDBcIjsgfVxuXG4uZmEtcGVuY2lsLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMwM1wiOyB9XG5cbi5mYS1wZW5uYW50OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDU2XCI7IH1cblxuLmZhLXBlcmNlbnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyOTVcIjsgfVxuXG4uZmEtcGVyaXNjb3BlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2RhXCI7IH1cblxuLmZhLXBoYWJyaWNhdG9yOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2RiXCI7IH1cblxuLmZhLXBob2VuaXgtZnJhbWV3b3JrOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2RjXCI7IH1cblxuLmZhLXBob25lOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDk1XCI7IH1cblxuLmZhLXBob25lLXNsYXNoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2RkXCI7IH1cblxuLmZhLXBob25lLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA5OFwiOyB9XG5cbi5mYS1waG9uZS12b2x1bWU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYTBcIjsgfVxuXG4uZmEtcGhwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDU3XCI7IH1cblxuLmZhLXBpZWQtcGlwZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYWVcIjsgfVxuXG4uZmEtcGllZC1waXBlci1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYThcIjsgfVxuXG4uZmEtcGllZC1waXBlci1wcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFhN1wiOyB9XG5cbi5mYS1waWxsczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ4NFwiOyB9XG5cbi5mYS1waW50ZXJlc3Q6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZDJcIjsgfVxuXG4uZmEtcGludGVyZXN0LXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMzFcIjsgfVxuXG4uZmEtcGludGVyZXN0LXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBkM1wiOyB9XG5cbi5mYS1wbGFuZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA3MlwiOyB9XG5cbi5mYS1wbGFuZS1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZGVcIjsgfVxuXG4uZmEtcGxheTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA0YlwiOyB9XG5cbi5mYS1wbGF5LWNpcmNsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE0NFwiOyB9XG5cbi5mYS1wbGF5c3RhdGlvbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNkZlwiOyB9XG5cbi5mYS1wbHVnOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWU2XCI7IH1cblxuLmZhLXBsdXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNjdcIjsgfVxuXG4uZmEtcGx1cy1jaXJjbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNTVcIjsgfVxuXG4uZmEtcGx1cy1oZXhhZ29uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzAwXCI7IH1cblxuLmZhLXBsdXMtb2N0YWdvbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMwMVwiOyB9XG5cbi5mYS1wbHVzLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBmZVwiOyB9XG5cbi5mYS1wb2RjYXN0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmNlXCI7IH1cblxuLmZhLXBvbzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJmZVwiOyB9XG5cbi5mYS1wb3J0cmFpdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNlMFwiOyB9XG5cbi5mYS1wb3VuZC1zaWduOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTU0XCI7IH1cblxuLmZhLXBvd2VyLW9mZjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAxMVwiOyB9XG5cbi5mYS1wcmVzY3JpcHRpb24tYm90dGxlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDg1XCI7IH1cblxuLmZhLXByZXNjcmlwdGlvbi1ib3R0bGUtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDg2XCI7IH1cblxuLmZhLXByaW50OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDJmXCI7IH1cblxuLmZhLXByb2NlZHVyZXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0ODdcIjsgfVxuXG4uZmEtcHJvZHVjdC1odW50OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjg4XCI7IH1cblxuLmZhLXB1c2hlZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNlMVwiOyB9XG5cbi5mYS1wdXp6bGUtcGllY2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMmVcIjsgfVxuXG4uZmEtcHl0aG9uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2UyXCI7IH1cblxuLmZhLXFxOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWQ2XCI7IH1cblxuLmZhLXFyY29kZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAyOVwiOyB9XG5cbi5mYS1xdWVzdGlvbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEyOFwiOyB9XG5cbi5mYS1xdWVzdGlvbi1jaXJjbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNTlcIjsgfVxuXG4uZmEtcXVlc3Rpb24tc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmZkXCI7IH1cblxuLmZhLXF1aWRkaXRjaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ1OFwiOyB9XG5cbi5mYS1xdWluc2NhcGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NTlcIjsgfVxuXG4uZmEtcXVvcmE6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYzRcIjsgfVxuXG4uZmEtcXVvdGUtbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEwZFwiOyB9XG5cbi5mYS1xdW90ZS1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEwZVwiOyB9XG5cbi5mYS1yYWNxdWV0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDVhXCI7IH1cblxuLmZhLXJhbmRvbTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA3NFwiOyB9XG5cbi5mYS1yYXZlbHJ5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmQ5XCI7IH1cblxuLmZhLXJlYWN0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDFiXCI7IH1cblxuLmZhLXJlYmVsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWQwXCI7IH1cblxuLmZhLXJlY3RhbmdsZS1sYW5kc2NhcGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZmFcIjsgfVxuXG4uZmEtcmVjdGFuZ2xlLXBvcnRyYWl0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmZiXCI7IH1cblxuLmZhLXJlY3RhbmdsZS13aWRlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmZjXCI7IH1cblxuLmZhLXJlY3ljbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYjhcIjsgfVxuXG4uZmEtcmVkLXJpdmVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2UzXCI7IH1cblxuLmZhLXJlZGRpdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFhMVwiOyB9XG5cbi5mYS1yZWRkaXQtYWxpZW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyODFcIjsgfVxuXG4uZmEtcmVkZGl0LXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFhMlwiOyB9XG5cbi5mYS1yZWRvOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDFlXCI7IH1cblxuLmZhLXJlZG8tYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmY5XCI7IH1cblxuLmZhLXJlZ2lzdGVyZWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNWRcIjsgfVxuXG4uZmEtcmVuZGFjdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNlNFwiOyB9XG5cbi5mYS1yZW5yZW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxOGJcIjsgfVxuXG4uZmEtcmVwZWF0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzYzXCI7IH1cblxuLmZhLXJlcGVhdC0xOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzY1XCI7IH1cblxuLmZhLXJlcGVhdC0xLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM2NlwiOyB9XG5cbi5mYS1yZXBlYXQtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzY0XCI7IH1cblxuLmZhLXJlcGx5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2U1XCI7IH1cblxuLmZhLXJlcGx5LWFsbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEyMlwiOyB9XG5cbi5mYS1yZXBseWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZTZcIjsgfVxuXG4uZmEtcmVzb2x2aW5nOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2U3XCI7IH1cblxuLmZhLXJldHdlZXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNzlcIjsgfVxuXG4uZmEtcmV0d2VldC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNjFcIjsgfVxuXG4uZmEtcm9hZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAxOFwiOyB9XG5cbi5mYS1yb2NrZXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMzVcIjsgfVxuXG4uZmEtcm9ja2V0Y2hhdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNlOFwiOyB9XG5cbi5mYS1yb2Nrcm1zOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2U5XCI7IH1cblxuLmZhLXJzczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA5ZVwiOyB9XG5cbi5mYS1yc3Mtc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTQzXCI7IH1cblxuLmZhLXJ1YmxlLXNpZ246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNThcIjsgfVxuXG4uZmEtcnVwZWUtc2lnbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE1NlwiOyB9XG5cbi5mYS1zYWZhcmk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNjdcIjsgfVxuXG4uZmEtc2FzczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQxZVwiOyB9XG5cbi5mYS1zYXZlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGM3XCI7IH1cblxuLmZhLXNjYW5uZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0ODhcIjsgfVxuXG4uZmEtc2Nhbm5lci1rZXlib2FyZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ4OVwiOyB9XG5cbi5mYS1zY2FubmVyLXRvdWNoc2NyZWVuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDhhXCI7IH1cblxuLmZhLXNjaGxpeDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNlYVwiOyB9XG5cbi5mYS1zY3JpYmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyOGFcIjsgfVxuXG4uZmEtc2NydWJiZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZjhcIjsgfVxuXG4uZmEtc2VhcmNoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDAyXCI7IH1cblxuLmZhLXNlYXJjaC1taW51czpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAxMFwiOyB9XG5cbi5mYS1zZWFyY2gtcGx1czpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAwZVwiOyB9XG5cbi5mYS1zZWFyY2hlbmdpbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNlYlwiOyB9XG5cbi5mYS1zZWxsY2FzdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJkYVwiOyB9XG5cbi5mYS1zZWxsc3k6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMTNcIjsgfVxuXG4uZmEtc2VydmVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjMzXCI7IH1cblxuLmZhLXNlcnZpY2VzdGFjazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNlY1wiOyB9XG5cbi5mYS1zaGFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA2NFwiOyB9XG5cbi5mYS1zaGFyZS1hbGw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNjdcIjsgfVxuXG4uZmEtc2hhcmUtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWUwXCI7IH1cblxuLmZhLXNoYXJlLWFsdC1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZTFcIjsgfVxuXG4uZmEtc2hhcmUtc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTRkXCI7IH1cblxuLmZhLXNoZWtlbC1zaWduOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjBiXCI7IH1cblxuLmZhLXNoaWVsZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEzMlwiOyB9XG5cbi5mYS1zaGllbGQtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2VkXCI7IH1cblxuLmZhLXNoaWVsZC1jaGVjazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJmN1wiOyB9XG5cbi5mYS1zaGlwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjFhXCI7IH1cblxuLmZhLXNoaXBwaW5nLWZhc3Q6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0OGJcIjsgfVxuXG4uZmEtc2hpcHBpbmctdGltZWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0OGNcIjsgfVxuXG4uZmEtc2hpcnRzaW5idWxrOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjE0XCI7IH1cblxuLmZhLXNob3BwaW5nLWJhZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI5MFwiOyB9XG5cbi5mYS1zaG9wcGluZy1iYXNrZXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyOTFcIjsgfVxuXG4uZmEtc2hvcHBpbmctY2FydDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA3YVwiOyB9XG5cbi5mYS1zaG93ZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyY2NcIjsgfVxuXG4uZmEtc2h1dHRsZWNvY2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NWJcIjsgfVxuXG4uZmEtc2lnbi1pbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA5MFwiOyB9XG5cbi5mYS1zaWduLWluLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJmNlwiOyB9XG5cbi5mYS1zaWduLWxhbmd1YWdlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmE3XCI7IH1cblxuLmZhLXNpZ24tb3V0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDhiXCI7IH1cblxuLmZhLXNpZ24tb3V0LWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJmNVwiOyB9XG5cbi5mYS1zaWduYWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMTJcIjsgfVxuXG4uZmEtc2ltcGx5YnVpbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMTVcIjsgfVxuXG4uZmEtc2lzdHJpeDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNlZVwiOyB9XG5cbi5mYS1zaXRlbWFwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGU4XCI7IH1cblxuLmZhLXNreWF0bGFzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjE2XCI7IH1cblxuLmZhLXNreXBlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTdlXCI7IH1cblxuLmZhLXNsYWNrOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTk4XCI7IH1cblxuLmZhLXNsYWNrLWhhc2g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZWZcIjsgfVxuXG4uZmEtc2xpZGVycy1oOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWRlXCI7IH1cblxuLmZhLXNsaWRlcnMtaC1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZjBcIjsgfVxuXG4uZmEtc2xpZGVycy12OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2YxXCI7IH1cblxuLmZhLXNsaWRlcnMtdi1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZjJcIjsgfVxuXG4uZmEtc2xpZGVzaGFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFlN1wiOyB9XG5cbi5mYS1zbWlsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjExOFwiOyB9XG5cbi5mYS1zbW9raW5nOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDhkXCI7IH1cblxuLmZhLXNuYXBjaGF0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmFiXCI7IH1cblxuLmZhLXNuYXBjaGF0LWdob3N0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmFjXCI7IH1cblxuLmZhLXNuYXBjaGF0LXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJhZFwiOyB9XG5cbi5mYS1zbm93Zmxha2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZGNcIjsgfVxuXG4uZmEtc29ydDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBkY1wiOyB9XG5cbi5mYS1zb3J0LWFscGhhLWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNWRcIjsgfVxuXG4uZmEtc29ydC1hbHBoYS11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE1ZVwiOyB9XG5cbi5mYS1zb3J0LWFtb3VudC1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTYwXCI7IH1cblxuLmZhLXNvcnQtYW1vdW50LXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTYxXCI7IH1cblxuLmZhLXNvcnQtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBkZFwiOyB9XG5cbi5mYS1zb3J0LW51bWVyaWMtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE2MlwiOyB9XG5cbi5mYS1zb3J0LW51bWVyaWMtdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNjNcIjsgfVxuXG4uZmEtc29ydC11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBkZVwiOyB9XG5cbi5mYS1zb3VuZGNsb3VkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWJlXCI7IH1cblxuLmZhLXNwYWNlLXNodXR0bGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxOTdcIjsgfVxuXG4uZmEtc3BhZGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZjRcIjsgfVxuXG4uZmEtc3BlYWthcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNmM1wiOyB9XG5cbi5mYS1zcGlubmVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTEwXCI7IH1cblxuLmZhLXNwaW5uZXItdGhpcmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZjRcIjsgfVxuXG4uZmEtc3BvdGlmeTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFiY1wiOyB9XG5cbi5mYS1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYzhcIjsgfVxuXG4uZmEtc3F1YXJlLWZ1bGw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NWNcIjsgfVxuXG4uZmEtc3RhY2stZXhjaGFuZ2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxOGRcIjsgfVxuXG4uZmEtc3RhY2stb3ZlcmZsb3c6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNmNcIjsgfVxuXG4uZmEtc3RhcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAwNVwiOyB9XG5cbi5mYS1zdGFyLWV4Y2xhbWF0aW9uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmYzXCI7IH1cblxuLmZhLXN0YXItaGFsZjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA4OVwiOyB9XG5cbi5mYS1zdGF5bGlua2VkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2Y1XCI7IH1cblxuLmZhLXN0ZWFtOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWI2XCI7IH1cblxuLmZhLXN0ZWFtLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFiN1wiOyB9XG5cbi5mYS1zdGVhbS1zeW1ib2w6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZjZcIjsgfVxuXG4uZmEtc3RlcC1iYWNrd2FyZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA0OFwiOyB9XG5cbi5mYS1zdGVwLWZvcndhcmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNTFcIjsgfVxuXG4uZmEtc3RldGhvc2NvcGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZjFcIjsgfVxuXG4uZmEtc3RpY2tlci1tdWxlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2Y3XCI7IH1cblxuLmZhLXN0aWNreS1ub3RlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjQ5XCI7IH1cblxuLmZhLXN0b3A6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNGRcIjsgfVxuXG4uZmEtc3RvcC1jaXJjbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyOGRcIjsgfVxuXG4uZmEtc3RvcHdhdGNoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmYyXCI7IH1cblxuLmZhLXN0cmF2YTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQyOFwiOyB9XG5cbi5mYS1zdHJlZXQtdmlldzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIxZFwiOyB9XG5cbi5mYS1zdHJpa2V0aHJvdWdoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGNjXCI7IH1cblxuLmZhLXN0cmlwZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQyOVwiOyB9XG5cbi5mYS1zdHJpcGUtczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQyYVwiOyB9XG5cbi5mYS1zdHVkaW92aW5hcmk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZjhcIjsgfVxuXG4uZmEtc3R1bWJsZXVwb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYTRcIjsgfVxuXG4uZmEtc3R1bWJsZXVwb24tY2lyY2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWEzXCI7IH1cblxuLmZhLXN1YnNjcmlwdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEyY1wiOyB9XG5cbi5mYS1zdWJ3YXk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMzlcIjsgfVxuXG4uZmEtc3VpdGNhc2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZjJcIjsgfVxuXG4uZmEtc3VuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTg1XCI7IH1cblxuLmZhLXN1cGVycG93ZXJzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmRkXCI7IH1cblxuLmZhLXN1cGVyc2NyaXB0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTJiXCI7IH1cblxuLmZhLXN1cHBsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNmOVwiOyB9XG5cbi5mYS1zeW5jOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDIxXCI7IH1cblxuLmZhLXN5bmMtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmYxXCI7IH1cblxuLmZhLXN5cmluZ2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0OGVcIjsgfVxuXG4uZmEtdGFibGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwY2VcIjsgfVxuXG4uZmEtdGFibGUtdGVubmlzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDVkXCI7IH1cblxuLmZhLXRhYmxldDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEwYVwiOyB9XG5cbi5mYS10YWJsZXQtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2ZhXCI7IH1cblxuLmZhLXRhYmxldC1hbmRyb2lkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2ZiXCI7IH1cblxuLmZhLXRhYmxldC1hbmRyb2lkLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNmY1wiOyB9XG5cbi5mYS10YWJsZXQtcnVnZ2VkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDhmXCI7IH1cblxuLmZhLXRhYmxldHM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0OTBcIjsgfVxuXG4uZmEtdGFjaG9tZXRlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBlNFwiOyB9XG5cbi5mYS10YWNob21ldGVyLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNmZFwiOyB9XG5cbi5mYS10YWc6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMmJcIjsgfVxuXG4uZmEtdGFnczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAyY1wiOyB9XG5cbi5mYS10YXNrczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBhZVwiOyB9XG5cbi5mYS10YXhpOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWJhXCI7IH1cblxuLmZhLXRlbGVncmFtOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmM2XCI7IH1cblxuLmZhLXRlbGVncmFtLXBsYW5lOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2ZlXCI7IH1cblxuLmZhLXRlbmNlbnQtd2VpYm86YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZDVcIjsgfVxuXG4uZmEtdGVubmlzLWJhbGw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NWVcIjsgfVxuXG4uZmEtdGVybWluYWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMjBcIjsgfVxuXG4uZmEtdGV4dC1oZWlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMzRcIjsgfVxuXG4uZmEtdGV4dC13aWR0aDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAzNVwiOyB9XG5cbi5mYS10aDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAwYVwiOyB9XG5cbi5mYS10aC1sYXJnZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAwOVwiOyB9XG5cbi5mYS10aC1saXN0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDBiXCI7IH1cblxuLmZhLXRoZW1laXNsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJiMlwiOyB9XG5cbi5mYS10aGVybW9tZXRlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ5MVwiOyB9XG5cbi5mYS10aGVybW9tZXRlci1lbXB0eTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJjYlwiOyB9XG5cbi5mYS10aGVybW9tZXRlci1mdWxsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmM3XCI7IH1cblxuLmZhLXRoZXJtb21ldGVyLWhhbGY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYzlcIjsgfVxuXG4uZmEtdGhlcm1vbWV0ZXItcXVhcnRlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJjYVwiOyB9XG5cbi5mYS10aGVybW9tZXRlci10aHJlZS1xdWFydGVyczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJjOFwiOyB9XG5cbi5mYS10aHVtYnMtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE2NVwiOyB9XG5cbi5mYS10aHVtYnMtdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNjRcIjsgfVxuXG4uZmEtdGh1bWJ0YWNrOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDhkXCI7IH1cblxuLmZhLXRpY2tldDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE0NVwiOyB9XG5cbi5mYS10aWNrZXQtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2ZmXCI7IH1cblxuLmZhLXRpbWVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDBkXCI7IH1cblxuLmZhLXRpbWVzLWNpcmNsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA1N1wiOyB9XG5cbi5mYS10aW1lcy1oZXhhZ29uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmVlXCI7IH1cblxuLmZhLXRpbWVzLW9jdGFnb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZjBcIjsgfVxuXG4uZmEtdGltZXMtc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmQzXCI7IH1cblxuLmZhLXRpbnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNDNcIjsgfVxuXG4uZmEtdG9nZ2xlLW9mZjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIwNFwiOyB9XG5cbi5mYS10b2dnbGUtb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMDVcIjsgfVxuXG4uZmEtdHJhZGVtYXJrOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjVjXCI7IH1cblxuLmZhLXRyYWluOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjM4XCI7IH1cblxuLmZhLXRyYW5zZ2VuZGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjI0XCI7IH1cblxuLmZhLXRyYW5zZ2VuZGVyLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIyNVwiOyB9XG5cbi5mYS10cmFzaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFmOFwiOyB9XG5cbi5mYS10cmFzaC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZWRcIjsgfVxuXG4uZmEtdHJlZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFiYlwiOyB9XG5cbi5mYS10cmVlLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQwMFwiOyB9XG5cbi5mYS10cmVsbG86YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxODFcIjsgfVxuXG4uZmEtdHJpYW5nbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZWNcIjsgfVxuXG4uZmEtdHJpcGFkdmlzb3I6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNjJcIjsgfVxuXG4uZmEtdHJvcGh5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDkxXCI7IH1cblxuLmZhLXRyb3BoeS1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZWJcIjsgfVxuXG4uZmEtdHJ1Y2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZDFcIjsgfVxuXG4uZmEtdHR5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWU0XCI7IH1cblxuLmZhLXR1bWJscjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE3M1wiOyB9XG5cbi5mYS10dW1ibHItc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTc0XCI7IH1cblxuLmZhLXR2OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjZjXCI7IH1cblxuLmZhLXR2LXJldHJvOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDAxXCI7IH1cblxuLmZhLXR3aXRjaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFlOFwiOyB9XG5cbi5mYS10d2l0dGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDk5XCI7IH1cblxuLmZhLXR3aXR0ZXItc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDgxXCI7IH1cblxuLmZhLXR5cG8zOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDJiXCI7IH1cblxuLmZhLXViZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MDJcIjsgfVxuXG4uZmEtdWlraXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MDNcIjsgfVxuXG4uZmEtdW1icmVsbGE6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZTlcIjsgfVxuXG4uZmEtdW5kZXJsaW5lOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGNkXCI7IH1cblxuLmZhLXVuZG86YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZTJcIjsgfVxuXG4uZmEtdW5kby1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZWFcIjsgfVxuXG4uZmEtdW5pcmVnaXN0cnk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MDRcIjsgfVxuXG4uZmEtdW5pdmVyc2FsLWFjY2VzczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI5YVwiOyB9XG5cbi5mYS11bml2ZXJzaXR5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTljXCI7IH1cblxuLmZhLXVubGluazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEyN1wiOyB9XG5cbi5mYS11bmxvY2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwOWNcIjsgfVxuXG4uZmEtdW5sb2NrLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEzZVwiOyB9XG5cbi5mYS11bnRhcHBkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDA1XCI7IH1cblxuLmZhLXVwbG9hZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA5M1wiOyB9XG5cbi5mYS11c2I6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyODdcIjsgfVxuXG4uZmEtdXNkLWNpcmNsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJlOFwiOyB9XG5cbi5mYS11c2Qtc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmU5XCI7IH1cblxuLmZhLXVzZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMDdcIjsgfVxuXG4uZmEtdXNlci1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MDZcIjsgfVxuXG4uZmEtdXNlci1jaXJjbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYmRcIjsgfVxuXG4uZmEtdXNlci1tZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBmMFwiOyB9XG5cbi5mYS11c2VyLXBsdXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMzRcIjsgfVxuXG4uZmEtdXNlci1zZWNyZXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMWJcIjsgfVxuXG4uZmEtdXNlci10aW1lczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIzNVwiOyB9XG5cbi5mYS11c2VyczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBjMFwiOyB9XG5cbi5mYS11c3N1bm5haDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQwN1wiOyB9XG5cbi5mYS11dGVuc2lsLWZvcms6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZTNcIjsgfVxuXG4uZmEtdXRlbnNpbC1rbmlmZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJlNFwiOyB9XG5cbi5mYS11dGVuc2lsLXNwb29uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmU1XCI7IH1cblxuLmZhLXV0ZW5zaWxzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmU3XCI7IH1cblxuLmZhLXV0ZW5zaWxzLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJlNlwiOyB9XG5cbi5mYS12YWFkaW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MDhcIjsgfVxuXG4uZmEtdmVudXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMjFcIjsgfVxuXG4uZmEtdmVudXMtZG91YmxlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjI2XCI7IH1cblxuLmZhLXZlbnVzLW1hcnM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMjhcIjsgfVxuXG4uZmEtdmlhY29pbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIzN1wiOyB9XG5cbi5mYS12aWFkZW86YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYTlcIjsgfVxuXG4uZmEtdmlhZGVvLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJhYVwiOyB9XG5cbi5mYS12aWFsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDkyXCI7IH1cblxuLmZhLXZpYWxzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDkzXCI7IH1cblxuLmZhLXZpYmVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDA5XCI7IH1cblxuLmZhLXZpZGVvOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDNkXCI7IH1cblxuLmZhLXZpbWVvOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDBhXCI7IH1cblxuLmZhLXZpbWVvLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE5NFwiOyB9XG5cbi5mYS12aW1lby12OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjdkXCI7IH1cblxuLmZhLXZpbmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxY2FcIjsgfVxuXG4uZmEtdms6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxODlcIjsgfVxuXG4uZmEtdm52OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDBiXCI7IH1cblxuLmZhLXZvbGxleWJhbGwtYmFsbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ1ZlwiOyB9XG5cbi5mYS12b2x1bWUtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAyN1wiOyB9XG5cbi5mYS12b2x1bWUtbXV0ZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJlMlwiOyB9XG5cbi5mYS12b2x1bWUtb2ZmOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDI2XCI7IH1cblxuLmZhLXZvbHVtZS11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAyOFwiOyB9XG5cbi5mYS12dWVqczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQxZlwiOyB9XG5cbi5mYS13YXJlaG91c2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0OTRcIjsgfVxuXG4uZmEtd2FyZWhvdXNlLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ5NVwiOyB9XG5cbi5mYS13YXRjaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJlMVwiOyB9XG5cbi5mYS13ZWlibzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE4YVwiOyB9XG5cbi5mYS13ZWlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0OTZcIjsgfVxuXG4uZmEtd2VpeGluOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWQ3XCI7IH1cblxuLmZhLXdoYXRzYXBwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjMyXCI7IH1cblxuLmZhLXdoYXRzYXBwLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQwY1wiOyB9XG5cbi5mYS13aGVlbGNoYWlyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTkzXCI7IH1cblxuLmZhLXdoaXN0bGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NjBcIjsgfVxuXG4uZmEtd2htY3M6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MGRcIjsgfVxuXG4uZmEtd2lmaTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFlYlwiOyB9XG5cbi5mYS13aWtpcGVkaWEtdzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI2NlwiOyB9XG5cbi5mYS13aW5kb3c6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MGVcIjsgfVxuXG4uZmEtd2luZG93LWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQwZlwiOyB9XG5cbi5mYS13aW5kb3ctY2xvc2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MTBcIjsgfVxuXG4uZmEtd2luZG93LW1heGltaXplOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmQwXCI7IH1cblxuLmZhLXdpbmRvdy1taW5pbWl6ZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJkMVwiOyB9XG5cbi5mYS13aW5kb3ctcmVzdG9yZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJkMlwiOyB9XG5cbi5mYS13aW5kb3dzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTdhXCI7IH1cblxuLmZhLXdvbi1zaWduOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTU5XCI7IH1cblxuLmZhLXdvcmRwcmVzczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE5YVwiOyB9XG5cbi5mYS13b3JkcHJlc3Mtc2ltcGxlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDExXCI7IH1cblxuLmZhLXdwYmVnaW5uZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyOTdcIjsgfVxuXG4uZmEtd3BleHBsb3JlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJkZVwiOyB9XG5cbi5mYS13cGZvcm1zOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjk4XCI7IH1cblxuLmZhLXdyZW5jaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBhZFwiOyB9XG5cbi5mYS14LXJheTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ5N1wiOyB9XG5cbi5mYS14Ym94OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDEyXCI7IH1cblxuLmZhLXhpbmc6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNjhcIjsgfVxuXG4uZmEteGluZy1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNjlcIjsgfVxuXG4uZmEteS1jb21iaW5hdG9yOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjNiXCI7IH1cblxuLmZhLXlhaG9vOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTllXCI7IH1cblxuLmZhLXlhbmRleDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQxM1wiOyB9XG5cbi5mYS15YW5kZXgtaW50ZXJuYXRpb25hbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQxNFwiOyB9XG5cbi5mYS15ZWxwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWU5XCI7IH1cblxuLmZhLXllbi1zaWduOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTU3XCI7IH1cblxuLmZhLXlvYXN0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmIxXCI7IH1cblxuLmZhLXlvdXR1YmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNjdcIjsgfVxuXG4uZmEteW91dHViZS1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MzFcIjsgfVxuXG4uc3Itb25seSB7XG4gIGJvcmRlcjogMDtcbiAgY2xpcDogcmVjdCgwLCAwLCAwLCAwKTtcbiAgaGVpZ2h0OiAxcHg7XG4gIG1hcmdpbjogLTFweDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgcGFkZGluZzogMDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB3aWR0aDogMXB4OyB9XG5cbi5zci1vbmx5LWZvY3VzYWJsZTphY3RpdmUsIC5zci1vbmx5LWZvY3VzYWJsZTpmb2N1cyB7XG4gIGNsaXA6IGF1dG87XG4gIGhlaWdodDogYXV0bztcbiAgbWFyZ2luOiAwO1xuICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgcG9zaXRpb246IHN0YXRpYztcbiAgd2lkdGg6IGF1dG87IH1cblxuYmxvY2txdW90ZSB7XG4gIG1hcmdpbjogMDtcbiAgcGFkZGluZzogMDsgfVxuICBibG9ja3F1b3RlIHAge1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICNlOGU4ZTg7XG4gICAgYm9yZGVyLWxlZnQ6IDAuNXJlbSBzb2xpZCAjZThlOGU4O1xuICAgIG1hcmdpbjogLjVyZW0gMDtcbiAgICBwYWRkaW5nOiAuNXJlbSAxcmVtIC41cmVtIDEuNXJlbTsgfVxuXG5wcmUsIGNvZGUge1xuICBib3JkZXItcmFkaXVzOiAuMjVlbTtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjhmODsgfVxuXG5wcmUge1xuICBvdmVyZmxvdy14OiBhdXRvO1xuICBmb250LXNpemU6IC45cmVtO1xuICBwYWRkaW5nOiAxcmVtO1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7IH1cbiAgcHJlIGNvZGUge1xuICAgIHBhZGRpbmc6IDA7IH1cblxuY29kZSB7XG4gIHBhZGRpbmc6IC4yZW0gLjVlbTsgfVxuXG5odG1sIHtcbiAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgSGVsdmV0aWNhLCBBcmlhbDtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBsaW5lLWhlaWdodDogMS41O1xuICBjb2xvcjogIzJCMkQzMzsgfVxuXG5ib2R5IHtcbiAgaGVpZ2h0OiAxMDAlOyB9XG5cbioge1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XG5cbi5iY3gtZG9jLW5hdiB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgYm90dG9tOiAwO1xuICB3aWR0aDogMzAwcHg7XG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgb3ZlcmZsb3cteTogYXV0bztcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YyZjJmMjtcbiAgcGFkZGluZzogLjVyZW07XG4gIHRyYW5zaXRpb246IGxlZnQgZWFzZSAyMDBtcztcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2U4ZThlODsgfVxuICAuYmN4LWRvYy1uYXYgaDEsIC5iY3gtZG9jLW5hdiBoMiwgLmJjeC1kb2MtbmF2IGgzLCAuYmN4LWRvYy1uYXYgaDQsIC5iY3gtZG9jLW5hdiBoNSwgLmJjeC1kb2MtbmF2IGg2IHtcbiAgICBtYXJnaW46IC44ZW0gMCAuNGVtOyB9XG4gIC5iY3gtZG9jLW5hdiAuY2xvc2UtbWVudSB7XG4gICAgZGlzcGxheTogbm9uZTsgfVxuXG4uYmN4LWRvYy1uYXYtYmFja2Ryb3Age1xuICBkaXNwbGF5OiBub25lOyB9XG5cbmEubmF2LWxpbmssIGEubmF2LWxpbms6dmlzaXRlZCB7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgcGFkZGluZzogLjNyZW0gLjVyZW07XG4gIGNvbG9yOiAjZmZmO1xuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgY3Vyc29yOiBwb2ludGVyOyB9XG4gIGEubmF2LWxpbms6aG92ZXIsIGEubmF2LWxpbms6dmlzaXRlZDpob3ZlciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbiAgICBjb2xvcjogIzVEOTlCRDsgfVxuXG4ubmF2LWRpc2FibGVkIHtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICBwYWRkaW5nOiAuM3JlbSAuNXJlbTtcbiAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC40KTtcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDsgfVxuXG5hLmxpbmsge1xuICBkaXNwbGF5OiBibG9jaztcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICBmb250LXNpemU6IC44NXJlbTsgfVxuICBhLmxpbmsucmVtb3RlLWxpbmsge1xuICAgIGZvbnQtc2l6ZTogLjc1cmVtO1xuICAgIG1hcmdpbjogNHB4IDA7IH1cbiAgYS5saW5rLmRlcHJlY2F0ZWQsIGEubGluay5kZXByZWNhdGVkOnZpc2l0ZWQge1xuICAgIHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoO1xuICAgIGNvbG9yOiAjNjY2OyB9XG4gIGEubGluaywgYS5saW5rOnZpc2l0ZWQge1xuICAgIGNvbG9yOiAjMkIyRDMzO1xuICAgIHBhZGRpbmc6IDRweCA1cHggNHB4IDEwcHg7XG4gICAgbWFyZ2luOiAycHggMDsgfVxuICBhLmxpbmsuYWN0aXZlLCBhLmxpbmsuYWN0aXZlLmRlcHJlY2F0ZWQsIGEubGluay5hY3RpdmU6dmlzaXRlZCwgYS5saW5rLmFjdGl2ZTp2aXNpdGVkLmRlcHJlY2F0ZWQge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM1RDk5QkQ7XG4gICAgY29sb3I6ICNmZmY7IH1cbiAgYS5saW5rOmhvdmVyLCBhLmxpbms6aG92ZXIuZGVwcmVjYXRlZCwgYS5saW5rOmhvdmVyOnZpc2l0ZWQsIGEubGluazpob3Zlcjp2aXNpdGVkLmRlcHJlY2F0ZWQge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM2NjY7XG4gICAgY29sb3I6ICNmZmY7IH1cbiAgICBhLmxpbms6aG92ZXIuYWN0aXZlLCBhLmxpbms6aG92ZXIuZGVwcmVjYXRlZC5hY3RpdmUsIGEubGluazpob3Zlcjp2aXNpdGVkLmFjdGl2ZSwgYS5saW5rOmhvdmVyOnZpc2l0ZWQuZGVwcmVjYXRlZC5hY3RpdmUge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzVEOTlCRDtcbiAgICAgIGNvbG9yOiAjZmZmOyB9XG5cbi5iY3gtZG9jLW1haW4ge1xuICB6LWluZGV4OiAxO1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDMwMHB4O1xuICBib3R0b206IDA7XG4gIHJpZ2h0OiAwO1xuICBwYWRkaW5nOiAxcmVtO1xuICB0cmFuc2l0aW9uOiBsZWZ0IGVhc2UgMjAwbXM7XG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgb3ZlcmZsb3cteTogYXV0bzsgfVxuXG4uYmN4LW92ZXJsYXktc3Bpbm5lciB7XG4gIGNvbG9yOiAjMzBBMUMxO1xuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDA7XG4gIHJpZ2h0OiAwO1xuICBib3R0b206IDA7XG4gIGNvbG9yOiAjNUQ5OUJEOyB9XG5cbi5iY3gtZG9jLWRlbW8ge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LXdyYXA6IG5vd3JhcDtcbiAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7IH1cbiAgLmJjeC1kb2MtbWFpbiA+IC5iY3gtZG9jLWRlbW8ge1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMi40cmVtO1xuICAgIGxlZnQ6IDA7XG4gICAgcmlnaHQ6IDA7XG4gICAgYm90dG9tOiAwOyB9XG4gIGNvbXBvc2UgPiAuYmN4LWRvYy1kZW1vIHtcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgIGJveC1zaGFkb3c6IDAgMCAxcmVtICNlOGU4ZTg7XG4gICAgbWFyZ2luOiAxcmVtIC0xcmVtOyB9XG4gIC5iY3gtZG9jLWRlbW8gLmRlbW8tYXBwIHtcbiAgICBtYXJnaW46IDFyZW07XG4gICAgZmxleC1ncm93OiAwOyB9XG4gIC5iY3gtZG9jLWRlbW8gLmRlbW8tY29kZSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGZsZXgtZ3JvdzogMTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IH1cbiAgICAuYmN4LWRvYy1kZW1vIC5kZW1vLWNvZGUgLmJjeC1zZWxlY3Qge1xuICAgICAgZmxleC1ncm93OiAwO1xuICAgICAgZmxleC1zaHJpbms6IDA7IH1cbiAgICAuYmN4LWRvYy1kZW1vIC5kZW1vLWNvZGUgZGlzcGxheS1zb3VyY2Uge1xuICAgICAgZmxleDogMSAxIDA7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cblxuLmRpc3BsYXktc291cmNlIHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxuXG5zZWxlY3QuYmN4LXNlbGVjdCB7XG4gIGFwcGVhcmFuY2U6IG5vbmU7XG4gIGJvcmRlci1yYWRpdXM6IDA7XG4gIGJvcmRlcjogMDtcbiAgY29sb3I6ICNmZmY7XG4gIHBhZGRpbmc6IC4yNXJlbSAuNXJlbSAuMjVyZW0gMS41cmVtO1xuICBmb250LXNpemU6IC44NXJlbTtcbiAgYmFja2dyb3VuZDogIzZkOTBhMyB1cmwoXCJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGY4LCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA0IDUnJTNFJTNDcGF0aCBmaWxsPSd3aGl0ZScgZD0nTTIgMEwwIDJoNHptMCA1TDAgM2g0eicvJTNFJTNDL3N2ZyUzRVwiKSBuby1yZXBlYXQgbGVmdCAwLjVyZW0gY2VudGVyO1xuICBiYWNrZ3JvdW5kLXNpemU6IDhweCAxMHB4OyB9XG5cbi5iY3gtb3Blbi1tZW51IHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgei1pbmRleDogMjtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICBtYXgtd2lkdGg6IDEwMCU7XG4gIHBhZGRpbmc6IC40cmVtIC42cmVtIC40cmVtIC41cmVtO1xuICBjb2xvcjogI2ZmZjtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzVEOTlCRDtcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IC42cmVtO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgY3Vyc29yOiBkZWZhdWx0OyB9XG4gIC5iY3gtb3Blbi1tZW51IC5mYS1iYXJzIHtcbiAgICBtYXJnaW4tcmlnaHQ6IC4yNXJlbTsgfVxuXG4udGV4dC1tdXRlZCB7XG4gIGNvbG9yOiAjNjY2OyB9XG5cbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDcyMHB4KSB7XG4gIC5iY3gtZG9jLW1haW4gPiAuYmN4LWRvYy1kZW1vIC5kZW1vLWFwcCB7XG4gICAgbWluLWhlaWdodDogMTAwcHg7IH1cbiAgY29tcG9zZSA+IC5iY3gtZG9jLWRlbW8gLmRlbW8tYXBwIHtcbiAgICBtaW4td2lkdGg6IDMwMHB4OyB9XG4gIGNvbXBvc2UgPiAuYmN4LWRvYy1kZW1vIC5kZW1vLWNvZGUge1xuICAgIG1pbi1oZWlnaHQ6IDMwMHB4OyB9XG4gIC5Db2RlTWlycm9yLWZ1bGxzY3JlZW4ge1xuICAgIGxlZnQ6IDMwMHB4OyB9XG4gIC5iY3gtb3Blbi1tZW51IHtcbiAgICBsZWZ0OiAzMDBweDtcbiAgICBtYXgtd2lkdGg6IGNhbGMoMTAwJSAtIDMwMHB4KTsgfVxuICAgIC5iY3gtb3Blbi1tZW51IC5mYS1iYXJzIHtcbiAgICAgIGRpc3BsYXk6IG5vbmU7IH0gfVxuXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMDIwcHgpIHtcbiAgY29tcG9zZSA+IC5iY3gtZG9jLWRlbW8ge1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IH0gfVxuXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3MjBweCkge1xuICBjb21wb3NlID4gLmJjeC1kb2MtZGVtbyAuZGVtby1jb2RlIHtcbiAgICBtaW4taGVpZ2h0OiAyMDBweDsgfVxuICAuYmN4LWRvYy1uYXYge1xuICAgIHotaW5kZXg6IDQ7XG4gICAgbGVmdDogLTMwMHB4OyB9XG4gICAgLmJjeC1kb2MtbmF2Lm1lbnUtb3BlbiB7XG4gICAgICBsZWZ0OiAwO1xuICAgICAgYm94LXNoYWRvdzogMCAwIDJyZW0gcmdiYSgwLCAwLCAwLCAwLjMpOyB9XG4gICAgICAuYmN4LWRvYy1uYXYubWVudS1vcGVuIC5vcGVuLW1lbnUge1xuICAgICAgICBkaXNwbGF5OiBub25lOyB9XG4gICAgLmJjeC1kb2MtbmF2IC5jbG9zZS1tZW51IHtcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgei1pbmRleDogMjtcbiAgICAgIHRvcDogMDtcbiAgICAgIHJpZ2h0OiAwO1xuICAgICAgZm9udC1zaXplOiAxLjFyZW07XG4gICAgICBwYWRkaW5nOiAuNHJlbSAuNXJlbSAuNHJlbSAuNnJlbTtcbiAgICAgIGNvbG9yOiAjNjY2O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2U4ZThlODtcbiAgICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IC42cmVtOyB9XG4gIC5iY3gtZG9jLW5hdi1iYWNrZHJvcCB7XG4gICAgei1pbmRleDogMztcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgcmlnaHQ6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTAyLCAxMDIsIDEwMiwgMC42KTsgfVxuICAuYmN4LWRvYy1tYWluIHtcbiAgICBsZWZ0OiAwOyB9IH1cbiIsIkBmb250LWZhY2Uge1xuICBmb250LWZhbWlseTogJ0ZvbnQgQXdlc29tZSA1IEJyYW5kcyc7XG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgc3JjOiB1cmwoJGZhLWJyYW5kcy00MDApIGZvcm1hdCgnd29mZicpO1xufVxuXG4uZmFiIHtcbiAgZm9udC1mYW1pbHk6ICdGb250IEF3ZXNvbWUgNSBCcmFuZHMnO1xufVxuXG5AZm9udC1mYWNlIHtcbiAgZm9udC1mYW1pbHk6ICdGb250IEF3ZXNvbWUgNSBQcm8nO1xuICBmb250LXN0eWxlOiBub3JtYWw7XG4gIGZvbnQtd2VpZ2h0OiAzMDA7XG4gIHNyYzogdXJsKCRmYS1saWdodC0zMDApIGZvcm1hdCgnd29mZicpO1xufVxuXG4uZmFsIHtcbiAgZm9udC1mYW1pbHk6ICdGb250IEF3ZXNvbWUgNSBQcm8nO1xuICBmb250LXdlaWdodDogMzAwO1xufVxuXG5AZm9udC1mYWNlIHtcbiAgZm9udC1mYW1pbHk6ICdGb250IEF3ZXNvbWUgNSBQcm8nO1xuICBmb250LXN0eWxlOiBub3JtYWw7XG4gIGZvbnQtd2VpZ2h0OiA0MDA7XG4gIHNyYzogdXJsKCRmYS1yZWd1bGFyLTQwMCkgZm9ybWF0KCd3b2ZmJyk7XG59XG5cbi5mYXIge1xuICBmb250LWZhbWlseTogJ0ZvbnQgQXdlc29tZSA1IFBybyc7XG4gIGZvbnQtd2VpZ2h0OiA0MDA7XG59XG5cbkBmb250LWZhY2Uge1xuICBmb250LWZhbWlseTogJ0ZvbnQgQXdlc29tZSA1IFBybyc7XG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgZm9udC13ZWlnaHQ6IDkwMDtcbiAgc3JjOiB1cmwoJGZhLXNvbGlkLTkwMCkgZm9ybWF0KCd3b2ZmJyk7XG59XG5cbi5mYSxcbi5mYXMge1xuICBmb250LWZhbWlseTogJ0ZvbnQgQXdlc29tZSA1IFBybyc7XG4gIGZvbnQtd2VpZ2h0OiA5MDA7XG59XG5cblxuIiwiLyohXG4gKiBGb250IEF3ZXNvbWUgUHJvIDUuMC43IGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tXG4gKiBMaWNlbnNlIC0gaHR0cHM6Ly9mb250YXdlc29tZS5jb20vbGljZW5zZSAoQ29tbWVyY2lhbCBMaWNlbnNlKVxuICovXG5AaW1wb3J0ICd2YXJpYWJsZXMnO1xuQGltcG9ydCAnbWl4aW5zJztcbkBpbXBvcnQgJ2NvcmUnO1xuQGltcG9ydCAnbGFyZ2VyJztcbkBpbXBvcnQgJ2ZpeGVkLXdpZHRoJztcbkBpbXBvcnQgJ2xpc3QnO1xuQGltcG9ydCAnYm9yZGVyZWQtcHVsbGVkJztcbkBpbXBvcnQgJ2FuaW1hdGVkJztcbkBpbXBvcnQgJ3JvdGF0ZWQtZmxpcHBlZCc7XG5AaW1wb3J0ICdzdGFja2VkJztcbkBpbXBvcnQgJ2ljb25zJztcbkBpbXBvcnQgJ3NjcmVlbi1yZWFkZXInO1xuIiwiLy8gQmFzZSBDbGFzcyBEZWZpbml0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi4jeyRmYS1jc3MtcHJlZml4fSxcbi5mYXMsXG4uZmFyLFxuLmZhbCxcbi5mYWIge1xuICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlO1xuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICBmb250LXN0eWxlOiBub3JtYWw7XG4gIGZvbnQtdmFyaWFudDogbm9ybWFsO1xuICB0ZXh0LXJlbmRlcmluZzogYXV0bztcbiAgbGluZS1oZWlnaHQ6IDE7XG59XG4iLCIvLyBJY29uIFNpemVzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIG1ha2VzIHRoZSBmb250IDMzJSBsYXJnZXIgcmVsYXRpdmUgdG8gdGhlIGljb24gY29udGFpbmVyXG4uI3skZmEtY3NzLXByZWZpeH0tbGcge1xuICBmb250LXNpemU6ICg0ZW0gLyAzKTtcbiAgbGluZS1oZWlnaHQ6ICgzZW0gLyA0KTtcbiAgdmVydGljYWwtYWxpZ246IC0uMDY2N2VtO1xufVxuXG4uI3skZmEtY3NzLXByZWZpeH0teHMge1xuICBmb250LXNpemU6IC43NWVtO1xufVxuXG4uI3skZmEtY3NzLXByZWZpeH0tc20ge1xuICBmb250LXNpemU6IC44NzVlbTtcbn1cblxuQGZvciAkaSBmcm9tIDEgdGhyb3VnaCAxMCB7XG4gIC4jeyRmYS1jc3MtcHJlZml4fS0jeyRpfXgge1xuICAgIGZvbnQtc2l6ZTogJGkgKiAxZW07XG4gIH1cbn1cbiIsIi8vIEZpeGVkIFdpZHRoIEljb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4uI3skZmEtY3NzLXByZWZpeH0tZncge1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIHdpZHRoOiAoMjBlbSAvIDE2KTtcbn1cbiIsIi8vIExpc3QgSWNvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLiN7JGZhLWNzcy1wcmVmaXh9LXVsIHtcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xuICBtYXJnaW4tbGVmdDogJGZhLWxpLXdpZHRoICogNS80O1xuICBwYWRkaW5nLWxlZnQ6IDA7XG5cbiAgPiBsaSB7IHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxufVxuXG4uI3skZmEtY3NzLXByZWZpeH0tbGkge1xuICBsZWZ0OiAtJGZhLWxpLXdpZHRoO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgd2lkdGg6ICRmYS1saS13aWR0aDtcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XG59XG4iLCIvLyBWYXJpYWJsZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiRmYS1mb250LXBhdGg6ICAgICAgICAgICAgICAgIFwiLi4vd2ViZm9udHNcIiAhZGVmYXVsdDtcbiRmYS1mb250LXNpemUtYmFzZTogICAgICAgICAgIDE2cHggIWRlZmF1bHQ7XG4kZmEtY3NzLXByZWZpeDogICAgICAgICAgICAgICBmYSAhZGVmYXVsdDtcbiRmYS12ZXJzaW9uOiAgICAgICAgICAgICAgICAgIFwiNS4wLjdcIiAhZGVmYXVsdDtcbiRmYS1ib3JkZXItY29sb3I6ICAgICAgICAgICAgICNlZWUgIWRlZmF1bHQ7XG4kZmEtaW52ZXJzZTogICAgICAgICAgICAgICAgICAjZmZmICFkZWZhdWx0O1xuJGZhLWxpLXdpZHRoOiAgICAgICAgICAgICAgICAgMmVtICFkZWZhdWx0O1xuXG4vLyBDb252ZW5pZW5jZSBmdW5jdGlvbiB1c2VkIHRvIHNldCBjb250ZW50IHByb3BlcnR5XG5AZnVuY3Rpb24gZmEtY29udGVudCgkZmEtdmFyKSB7XG4gIEByZXR1cm4gdW5xdW90ZShcIlxcXCIjeyAkZmEtdmFyIH1cXFwiXCIpO1xufVxuXG4kZmEtdmFyLTUwMHB4OiBcXGYyNmU7XG4kZmEtdmFyLWFjY2Vzc2libGUtaWNvbjogXFxmMzY4O1xuJGZhLXZhci1hY2N1c29mdDogXFxmMzY5O1xuJGZhLXZhci1hZGRyZXNzLWJvb2s6IFxcZjJiOTtcbiRmYS12YXItYWRkcmVzcy1jYXJkOiBcXGYyYmI7XG4kZmEtdmFyLWFkanVzdDogXFxmMDQyO1xuJGZhLXZhci1hZG46IFxcZjE3MDtcbiRmYS12YXItYWR2ZXJzYWw6IFxcZjM2YTtcbiRmYS12YXItYWZmaWxpYXRldGhlbWU6IFxcZjM2YjtcbiRmYS12YXItYWxhcm0tY2xvY2s6IFxcZjM0ZTtcbiRmYS12YXItYWxnb2xpYTogXFxmMzZjO1xuJGZhLXZhci1hbGlnbi1jZW50ZXI6IFxcZjAzNztcbiRmYS12YXItYWxpZ24tanVzdGlmeTogXFxmMDM5O1xuJGZhLXZhci1hbGlnbi1sZWZ0OiBcXGYwMzY7XG4kZmEtdmFyLWFsaWduLXJpZ2h0OiBcXGYwMzg7XG4kZmEtdmFyLWFsbGVyZ2llczogXFxmNDYxO1xuJGZhLXZhci1hbWF6b246IFxcZjI3MDtcbiRmYS12YXItYW1hem9uLXBheTogXFxmNDJjO1xuJGZhLXZhci1hbWJ1bGFuY2U6IFxcZjBmOTtcbiRmYS12YXItYW1lcmljYW4tc2lnbi1sYW5ndWFnZS1pbnRlcnByZXRpbmc6IFxcZjJhMztcbiRmYS12YXItYW1pbGlhOiBcXGYzNmQ7XG4kZmEtdmFyLWFuY2hvcjogXFxmMTNkO1xuJGZhLXZhci1hbmRyb2lkOiBcXGYxN2I7XG4kZmEtdmFyLWFuZ2VsbGlzdDogXFxmMjA5O1xuJGZhLXZhci1hbmdsZS1kb3VibGUtZG93bjogXFxmMTAzO1xuJGZhLXZhci1hbmdsZS1kb3VibGUtbGVmdDogXFxmMTAwO1xuJGZhLXZhci1hbmdsZS1kb3VibGUtcmlnaHQ6IFxcZjEwMTtcbiRmYS12YXItYW5nbGUtZG91YmxlLXVwOiBcXGYxMDI7XG4kZmEtdmFyLWFuZ2xlLWRvd246IFxcZjEwNztcbiRmYS12YXItYW5nbGUtbGVmdDogXFxmMTA0O1xuJGZhLXZhci1hbmdsZS1yaWdodDogXFxmMTA1O1xuJGZhLXZhci1hbmdsZS11cDogXFxmMTA2O1xuJGZhLXZhci1hbmdyeWNyZWF0aXZlOiBcXGYzNmU7XG4kZmEtdmFyLWFuZ3VsYXI6IFxcZjQyMDtcbiRmYS12YXItYXBwLXN0b3JlOiBcXGYzNmY7XG4kZmEtdmFyLWFwcC1zdG9yZS1pb3M6IFxcZjM3MDtcbiRmYS12YXItYXBwZXI6IFxcZjM3MTtcbiRmYS12YXItYXBwbGU6IFxcZjE3OTtcbiRmYS12YXItYXBwbGUtcGF5OiBcXGY0MTU7XG4kZmEtdmFyLWFyY2hpdmU6IFxcZjE4NztcbiRmYS12YXItYXJyb3ctYWx0LWNpcmNsZS1kb3duOiBcXGYzNTg7XG4kZmEtdmFyLWFycm93LWFsdC1jaXJjbGUtbGVmdDogXFxmMzU5O1xuJGZhLXZhci1hcnJvdy1hbHQtY2lyY2xlLXJpZ2h0OiBcXGYzNWE7XG4kZmEtdmFyLWFycm93LWFsdC1jaXJjbGUtdXA6IFxcZjM1YjtcbiRmYS12YXItYXJyb3ctYWx0LWRvd246IFxcZjM1NDtcbiRmYS12YXItYXJyb3ctYWx0LWZyb20tYm90dG9tOiBcXGYzNDY7XG4kZmEtdmFyLWFycm93LWFsdC1mcm9tLWxlZnQ6IFxcZjM0NztcbiRmYS12YXItYXJyb3ctYWx0LWZyb20tcmlnaHQ6IFxcZjM0ODtcbiRmYS12YXItYXJyb3ctYWx0LWZyb20tdG9wOiBcXGYzNDk7XG4kZmEtdmFyLWFycm93LWFsdC1sZWZ0OiBcXGYzNTU7XG4kZmEtdmFyLWFycm93LWFsdC1yaWdodDogXFxmMzU2O1xuJGZhLXZhci1hcnJvdy1hbHQtc3F1YXJlLWRvd246IFxcZjM1MDtcbiRmYS12YXItYXJyb3ctYWx0LXNxdWFyZS1sZWZ0OiBcXGYzNTE7XG4kZmEtdmFyLWFycm93LWFsdC1zcXVhcmUtcmlnaHQ6IFxcZjM1MjtcbiRmYS12YXItYXJyb3ctYWx0LXNxdWFyZS11cDogXFxmMzUzO1xuJGZhLXZhci1hcnJvdy1hbHQtdG8tYm90dG9tOiBcXGYzNGE7XG4kZmEtdmFyLWFycm93LWFsdC10by1sZWZ0OiBcXGYzNGI7XG4kZmEtdmFyLWFycm93LWFsdC10by1yaWdodDogXFxmMzRjO1xuJGZhLXZhci1hcnJvdy1hbHQtdG8tdG9wOiBcXGYzNGQ7XG4kZmEtdmFyLWFycm93LWFsdC11cDogXFxmMzU3O1xuJGZhLXZhci1hcnJvdy1jaXJjbGUtZG93bjogXFxmMGFiO1xuJGZhLXZhci1hcnJvdy1jaXJjbGUtbGVmdDogXFxmMGE4O1xuJGZhLXZhci1hcnJvdy1jaXJjbGUtcmlnaHQ6IFxcZjBhOTtcbiRmYS12YXItYXJyb3ctY2lyY2xlLXVwOiBcXGYwYWE7XG4kZmEtdmFyLWFycm93LWRvd246IFxcZjA2MztcbiRmYS12YXItYXJyb3ctZnJvbS1ib3R0b206IFxcZjM0MjtcbiRmYS12YXItYXJyb3ctZnJvbS1sZWZ0OiBcXGYzNDM7XG4kZmEtdmFyLWFycm93LWZyb20tcmlnaHQ6IFxcZjM0NDtcbiRmYS12YXItYXJyb3ctZnJvbS10b3A6IFxcZjM0NTtcbiRmYS12YXItYXJyb3ctbGVmdDogXFxmMDYwO1xuJGZhLXZhci1hcnJvdy1yaWdodDogXFxmMDYxO1xuJGZhLXZhci1hcnJvdy1zcXVhcmUtZG93bjogXFxmMzM5O1xuJGZhLXZhci1hcnJvdy1zcXVhcmUtbGVmdDogXFxmMzNhO1xuJGZhLXZhci1hcnJvdy1zcXVhcmUtcmlnaHQ6IFxcZjMzYjtcbiRmYS12YXItYXJyb3ctc3F1YXJlLXVwOiBcXGYzM2M7XG4kZmEtdmFyLWFycm93LXRvLWJvdHRvbTogXFxmMzNkO1xuJGZhLXZhci1hcnJvdy10by1sZWZ0OiBcXGYzM2U7XG4kZmEtdmFyLWFycm93LXRvLXJpZ2h0OiBcXGYzNDA7XG4kZmEtdmFyLWFycm93LXRvLXRvcDogXFxmMzQxO1xuJGZhLXZhci1hcnJvdy11cDogXFxmMDYyO1xuJGZhLXZhci1hcnJvd3M6IFxcZjA0NztcbiRmYS12YXItYXJyb3dzLWFsdDogXFxmMGIyO1xuJGZhLXZhci1hcnJvd3MtYWx0LWg6IFxcZjMzNztcbiRmYS12YXItYXJyb3dzLWFsdC12OiBcXGYzMzg7XG4kZmEtdmFyLWFycm93cy1oOiBcXGYwN2U7XG4kZmEtdmFyLWFycm93cy12OiBcXGYwN2Q7XG4kZmEtdmFyLWFzc2lzdGl2ZS1saXN0ZW5pbmctc3lzdGVtczogXFxmMmEyO1xuJGZhLXZhci1hc3RlcmlzazogXFxmMDY5O1xuJGZhLXZhci1hc3ltbWV0cmlrOiBcXGYzNzI7XG4kZmEtdmFyLWF0OiBcXGYxZmE7XG4kZmEtdmFyLWF1ZGlibGU6IFxcZjM3MztcbiRmYS12YXItYXVkaW8tZGVzY3JpcHRpb246IFxcZjI5ZTtcbiRmYS12YXItYXV0b3ByZWZpeGVyOiBcXGY0MWM7XG4kZmEtdmFyLWF2aWFuZXg6IFxcZjM3NDtcbiRmYS12YXItYXZpYXRvOiBcXGY0MjE7XG4kZmEtdmFyLWF3czogXFxmMzc1O1xuJGZhLXZhci1iYWNrd2FyZDogXFxmMDRhO1xuJGZhLXZhci1iYWRnZTogXFxmMzM1O1xuJGZhLXZhci1iYWRnZS1jaGVjazogXFxmMzM2O1xuJGZhLXZhci1iYWxhbmNlLXNjYWxlOiBcXGYyNGU7XG4kZmEtdmFyLWJhbjogXFxmMDVlO1xuJGZhLXZhci1iYW5kLWFpZDogXFxmNDYyO1xuJGZhLXZhci1iYW5kY2FtcDogXFxmMmQ1O1xuJGZhLXZhci1iYXJjb2RlOiBcXGYwMmE7XG4kZmEtdmFyLWJhcmNvZGUtYWx0OiBcXGY0NjM7XG4kZmEtdmFyLWJhcmNvZGUtcmVhZDogXFxmNDY0O1xuJGZhLXZhci1iYXJjb2RlLXNjYW46IFxcZjQ2NTtcbiRmYS12YXItYmFyczogXFxmMGM5O1xuJGZhLXZhci1iYXNlYmFsbDogXFxmNDMyO1xuJGZhLXZhci1iYXNlYmFsbC1iYWxsOiBcXGY0MzM7XG4kZmEtdmFyLWJhc2tldGJhbGwtYmFsbDogXFxmNDM0O1xuJGZhLXZhci1iYXNrZXRiYWxsLWhvb3A6IFxcZjQzNTtcbiRmYS12YXItYmF0aDogXFxmMmNkO1xuJGZhLXZhci1iYXR0ZXJ5LWJvbHQ6IFxcZjM3NjtcbiRmYS12YXItYmF0dGVyeS1lbXB0eTogXFxmMjQ0O1xuJGZhLXZhci1iYXR0ZXJ5LWZ1bGw6IFxcZjI0MDtcbiRmYS12YXItYmF0dGVyeS1oYWxmOiBcXGYyNDI7XG4kZmEtdmFyLWJhdHRlcnktcXVhcnRlcjogXFxmMjQzO1xuJGZhLXZhci1iYXR0ZXJ5LXNsYXNoOiBcXGYzNzc7XG4kZmEtdmFyLWJhdHRlcnktdGhyZWUtcXVhcnRlcnM6IFxcZjI0MTtcbiRmYS12YXItYmVkOiBcXGYyMzY7XG4kZmEtdmFyLWJlZXI6IFxcZjBmYztcbiRmYS12YXItYmVoYW5jZTogXFxmMWI0O1xuJGZhLXZhci1iZWhhbmNlLXNxdWFyZTogXFxmMWI1O1xuJGZhLXZhci1iZWxsOiBcXGYwZjM7XG4kZmEtdmFyLWJlbGwtc2xhc2g6IFxcZjFmNjtcbiRmYS12YXItYmljeWNsZTogXFxmMjA2O1xuJGZhLXZhci1iaW1vYmplY3Q6IFxcZjM3ODtcbiRmYS12YXItYmlub2N1bGFyczogXFxmMWU1O1xuJGZhLXZhci1iaXJ0aGRheS1jYWtlOiBcXGYxZmQ7XG4kZmEtdmFyLWJpdGJ1Y2tldDogXFxmMTcxO1xuJGZhLXZhci1iaXRjb2luOiBcXGYzNzk7XG4kZmEtdmFyLWJpdHk6IFxcZjM3YTtcbiRmYS12YXItYmxhY2stdGllOiBcXGYyN2U7XG4kZmEtdmFyLWJsYWNrYmVycnk6IFxcZjM3YjtcbiRmYS12YXItYmxpbmQ6IFxcZjI5ZDtcbiRmYS12YXItYmxvZ2dlcjogXFxmMzdjO1xuJGZhLXZhci1ibG9nZ2VyLWI6IFxcZjM3ZDtcbiRmYS12YXItYmx1ZXRvb3RoOiBcXGYyOTM7XG4kZmEtdmFyLWJsdWV0b290aC1iOiBcXGYyOTQ7XG4kZmEtdmFyLWJvbGQ6IFxcZjAzMjtcbiRmYS12YXItYm9sdDogXFxmMGU3O1xuJGZhLXZhci1ib21iOiBcXGYxZTI7XG4kZmEtdmFyLWJvb2s6IFxcZjAyZDtcbiRmYS12YXItYm9va21hcms6IFxcZjAyZTtcbiRmYS12YXItYm93bGluZy1iYWxsOiBcXGY0MzY7XG4kZmEtdmFyLWJvd2xpbmctcGluczogXFxmNDM3O1xuJGZhLXZhci1ib3g6IFxcZjQ2NjtcbiRmYS12YXItYm94LWNoZWNrOiBcXGY0Njc7XG4kZmEtdmFyLWJveGVzOiBcXGY0Njg7XG4kZmEtdmFyLWJveGluZy1nbG92ZTogXFxmNDM4O1xuJGZhLXZhci1icmFpbGxlOiBcXGYyYTE7XG4kZmEtdmFyLWJyaWVmY2FzZTogXFxmMGIxO1xuJGZhLXZhci1icmllZmNhc2UtbWVkaWNhbDogXFxmNDY5O1xuJGZhLXZhci1icm93c2VyOiBcXGYzN2U7XG4kZmEtdmFyLWJ0YzogXFxmMTVhO1xuJGZhLXZhci1idWc6IFxcZjE4ODtcbiRmYS12YXItYnVpbGRpbmc6IFxcZjFhZDtcbiRmYS12YXItYnVsbGhvcm46IFxcZjBhMTtcbiRmYS12YXItYnVsbHNleWU6IFxcZjE0MDtcbiRmYS12YXItYnVybjogXFxmNDZhO1xuJGZhLXZhci1idXJvbW9iZWxleHBlcnRlOiBcXGYzN2Y7XG4kZmEtdmFyLWJ1czogXFxmMjA3O1xuJGZhLXZhci1idXlzZWxsYWRzOiBcXGYyMGQ7XG4kZmEtdmFyLWNhbGN1bGF0b3I6IFxcZjFlYztcbiRmYS12YXItY2FsZW5kYXI6IFxcZjEzMztcbiRmYS12YXItY2FsZW5kYXItYWx0OiBcXGYwNzM7XG4kZmEtdmFyLWNhbGVuZGFyLWNoZWNrOiBcXGYyNzQ7XG4kZmEtdmFyLWNhbGVuZGFyLWVkaXQ6IFxcZjMzMztcbiRmYS12YXItY2FsZW5kYXItZXhjbGFtYXRpb246IFxcZjMzNDtcbiRmYS12YXItY2FsZW5kYXItbWludXM6IFxcZjI3MjtcbiRmYS12YXItY2FsZW5kYXItcGx1czogXFxmMjcxO1xuJGZhLXZhci1jYWxlbmRhci10aW1lczogXFxmMjczO1xuJGZhLXZhci1jYW1lcmE6IFxcZjAzMDtcbiRmYS12YXItY2FtZXJhLWFsdDogXFxmMzMyO1xuJGZhLXZhci1jYW1lcmEtcmV0cm86IFxcZjA4MztcbiRmYS12YXItY2Fwc3VsZXM6IFxcZjQ2YjtcbiRmYS12YXItY2FyOiBcXGYxYjk7XG4kZmEtdmFyLWNhcmV0LWNpcmNsZS1kb3duOiBcXGYzMmQ7XG4kZmEtdmFyLWNhcmV0LWNpcmNsZS1sZWZ0OiBcXGYzMmU7XG4kZmEtdmFyLWNhcmV0LWNpcmNsZS1yaWdodDogXFxmMzMwO1xuJGZhLXZhci1jYXJldC1jaXJjbGUtdXA6IFxcZjMzMTtcbiRmYS12YXItY2FyZXQtZG93bjogXFxmMGQ3O1xuJGZhLXZhci1jYXJldC1sZWZ0OiBcXGYwZDk7XG4kZmEtdmFyLWNhcmV0LXJpZ2h0OiBcXGYwZGE7XG4kZmEtdmFyLWNhcmV0LXNxdWFyZS1kb3duOiBcXGYxNTA7XG4kZmEtdmFyLWNhcmV0LXNxdWFyZS1sZWZ0OiBcXGYxOTE7XG4kZmEtdmFyLWNhcmV0LXNxdWFyZS1yaWdodDogXFxmMTUyO1xuJGZhLXZhci1jYXJldC1zcXVhcmUtdXA6IFxcZjE1MTtcbiRmYS12YXItY2FyZXQtdXA6IFxcZjBkODtcbiRmYS12YXItY2FydC1hcnJvdy1kb3duOiBcXGYyMTg7XG4kZmEtdmFyLWNhcnQtcGx1czogXFxmMjE3O1xuJGZhLXZhci1jYy1hbWF6b24tcGF5OiBcXGY0MmQ7XG4kZmEtdmFyLWNjLWFtZXg6IFxcZjFmMztcbiRmYS12YXItY2MtYXBwbGUtcGF5OiBcXGY0MTY7XG4kZmEtdmFyLWNjLWRpbmVycy1jbHViOiBcXGYyNGM7XG4kZmEtdmFyLWNjLWRpc2NvdmVyOiBcXGYxZjI7XG4kZmEtdmFyLWNjLWpjYjogXFxmMjRiO1xuJGZhLXZhci1jYy1tYXN0ZXJjYXJkOiBcXGYxZjE7XG4kZmEtdmFyLWNjLXBheXBhbDogXFxmMWY0O1xuJGZhLXZhci1jYy1zdHJpcGU6IFxcZjFmNTtcbiRmYS12YXItY2MtdmlzYTogXFxmMWYwO1xuJGZhLXZhci1jZW50ZXJjb2RlOiBcXGYzODA7XG4kZmEtdmFyLWNlcnRpZmljYXRlOiBcXGYwYTM7XG4kZmEtdmFyLWNoYXJ0LWFyZWE6IFxcZjFmZTtcbiRmYS12YXItY2hhcnQtYmFyOiBcXGYwODA7XG4kZmEtdmFyLWNoYXJ0LWxpbmU6IFxcZjIwMTtcbiRmYS12YXItY2hhcnQtcGllOiBcXGYyMDA7XG4kZmEtdmFyLWNoZWNrOiBcXGYwMGM7XG4kZmEtdmFyLWNoZWNrLWNpcmNsZTogXFxmMDU4O1xuJGZhLXZhci1jaGVjay1zcXVhcmU6IFxcZjE0YTtcbiRmYS12YXItY2hlc3M6IFxcZjQzOTtcbiRmYS12YXItY2hlc3MtYmlzaG9wOiBcXGY0M2E7XG4kZmEtdmFyLWNoZXNzLWJpc2hvcC1hbHQ6IFxcZjQzYjtcbiRmYS12YXItY2hlc3MtYm9hcmQ6IFxcZjQzYztcbiRmYS12YXItY2hlc3MtY2xvY2s6IFxcZjQzZDtcbiRmYS12YXItY2hlc3MtY2xvY2stYWx0OiBcXGY0M2U7XG4kZmEtdmFyLWNoZXNzLWtpbmc6IFxcZjQzZjtcbiRmYS12YXItY2hlc3Mta2luZy1hbHQ6IFxcZjQ0MDtcbiRmYS12YXItY2hlc3Mta25pZ2h0OiBcXGY0NDE7XG4kZmEtdmFyLWNoZXNzLWtuaWdodC1hbHQ6IFxcZjQ0MjtcbiRmYS12YXItY2hlc3MtcGF3bjogXFxmNDQzO1xuJGZhLXZhci1jaGVzcy1wYXduLWFsdDogXFxmNDQ0O1xuJGZhLXZhci1jaGVzcy1xdWVlbjogXFxmNDQ1O1xuJGZhLXZhci1jaGVzcy1xdWVlbi1hbHQ6IFxcZjQ0NjtcbiRmYS12YXItY2hlc3Mtcm9vazogXFxmNDQ3O1xuJGZhLXZhci1jaGVzcy1yb29rLWFsdDogXFxmNDQ4O1xuJGZhLXZhci1jaGV2cm9uLWNpcmNsZS1kb3duOiBcXGYxM2E7XG4kZmEtdmFyLWNoZXZyb24tY2lyY2xlLWxlZnQ6IFxcZjEzNztcbiRmYS12YXItY2hldnJvbi1jaXJjbGUtcmlnaHQ6IFxcZjEzODtcbiRmYS12YXItY2hldnJvbi1jaXJjbGUtdXA6IFxcZjEzOTtcbiRmYS12YXItY2hldnJvbi1kb3VibGUtZG93bjogXFxmMzIyO1xuJGZhLXZhci1jaGV2cm9uLWRvdWJsZS1sZWZ0OiBcXGYzMjM7XG4kZmEtdmFyLWNoZXZyb24tZG91YmxlLXJpZ2h0OiBcXGYzMjQ7XG4kZmEtdmFyLWNoZXZyb24tZG91YmxlLXVwOiBcXGYzMjU7XG4kZmEtdmFyLWNoZXZyb24tZG93bjogXFxmMDc4O1xuJGZhLXZhci1jaGV2cm9uLWxlZnQ6IFxcZjA1MztcbiRmYS12YXItY2hldnJvbi1yaWdodDogXFxmMDU0O1xuJGZhLXZhci1jaGV2cm9uLXNxdWFyZS1kb3duOiBcXGYzMjk7XG4kZmEtdmFyLWNoZXZyb24tc3F1YXJlLWxlZnQ6IFxcZjMyYTtcbiRmYS12YXItY2hldnJvbi1zcXVhcmUtcmlnaHQ6IFxcZjMyYjtcbiRmYS12YXItY2hldnJvbi1zcXVhcmUtdXA6IFxcZjMyYztcbiRmYS12YXItY2hldnJvbi11cDogXFxmMDc3O1xuJGZhLXZhci1jaGlsZDogXFxmMWFlO1xuJGZhLXZhci1jaHJvbWU6IFxcZjI2ODtcbiRmYS12YXItY2lyY2xlOiBcXGYxMTE7XG4kZmEtdmFyLWNpcmNsZS1ub3RjaDogXFxmMWNlO1xuJGZhLXZhci1jbGlwYm9hcmQ6IFxcZjMyODtcbiRmYS12YXItY2xpcGJvYXJkLWNoZWNrOiBcXGY0NmM7XG4kZmEtdmFyLWNsaXBib2FyZC1saXN0OiBcXGY0NmQ7XG4kZmEtdmFyLWNsb2NrOiBcXGYwMTc7XG4kZmEtdmFyLWNsb25lOiBcXGYyNGQ7XG4kZmEtdmFyLWNsb3NlZC1jYXB0aW9uaW5nOiBcXGYyMGE7XG4kZmEtdmFyLWNsb3VkOiBcXGYwYzI7XG4kZmEtdmFyLWNsb3VkLWRvd25sb2FkOiBcXGYwZWQ7XG4kZmEtdmFyLWNsb3VkLWRvd25sb2FkLWFsdDogXFxmMzgxO1xuJGZhLXZhci1jbG91ZC11cGxvYWQ6IFxcZjBlZTtcbiRmYS12YXItY2xvdWQtdXBsb2FkLWFsdDogXFxmMzgyO1xuJGZhLXZhci1jbG91ZHNjYWxlOiBcXGYzODM7XG4kZmEtdmFyLWNsb3Vkc21pdGg6IFxcZjM4NDtcbiRmYS12YXItY2xvdWR2ZXJzaWZ5OiBcXGYzODU7XG4kZmEtdmFyLWNsdWI6IFxcZjMyNztcbiRmYS12YXItY29kZTogXFxmMTIxO1xuJGZhLXZhci1jb2RlLWJyYW5jaDogXFxmMTI2O1xuJGZhLXZhci1jb2RlLWNvbW1pdDogXFxmMzg2O1xuJGZhLXZhci1jb2RlLW1lcmdlOiBcXGYzODc7XG4kZmEtdmFyLWNvZGVwZW46IFxcZjFjYjtcbiRmYS12YXItY29kaWVwaWU6IFxcZjI4NDtcbiRmYS12YXItY29mZmVlOiBcXGYwZjQ7XG4kZmEtdmFyLWNvZzogXFxmMDEzO1xuJGZhLXZhci1jb2dzOiBcXGYwODU7XG4kZmEtdmFyLWNvbHVtbnM6IFxcZjBkYjtcbiRmYS12YXItY29tbWVudDogXFxmMDc1O1xuJGZhLXZhci1jb21tZW50LWFsdDogXFxmMjdhO1xuJGZhLXZhci1jb21tZW50czogXFxmMDg2O1xuJGZhLXZhci1jb21wYXNzOiBcXGYxNGU7XG4kZmEtdmFyLWNvbXByZXNzOiBcXGYwNjY7XG4kZmEtdmFyLWNvbXByZXNzLWFsdDogXFxmNDIyO1xuJGZhLXZhci1jb21wcmVzcy13aWRlOiBcXGYzMjY7XG4kZmEtdmFyLWNvbm5lY3RkZXZlbG9wOiBcXGYyMGU7XG4kZmEtdmFyLWNvbnRhbzogXFxmMjZkO1xuJGZhLXZhci1jb252ZXlvci1iZWx0OiBcXGY0NmU7XG4kZmEtdmFyLWNvbnZleW9yLWJlbHQtYWx0OiBcXGY0NmY7XG4kZmEtdmFyLWNvcHk6IFxcZjBjNTtcbiRmYS12YXItY29weXJpZ2h0OiBcXGYxZjk7XG4kZmEtdmFyLWNwYW5lbDogXFxmMzg4O1xuJGZhLXZhci1jcmVhdGl2ZS1jb21tb25zOiBcXGYyNWU7XG4kZmEtdmFyLWNyZWRpdC1jYXJkOiBcXGYwOWQ7XG4kZmEtdmFyLWNyZWRpdC1jYXJkLWJsYW5rOiBcXGYzODk7XG4kZmEtdmFyLWNyZWRpdC1jYXJkLWZyb250OiBcXGYzOGE7XG4kZmEtdmFyLWNyaWNrZXQ6IFxcZjQ0OTtcbiRmYS12YXItY3JvcDogXFxmMTI1O1xuJGZhLXZhci1jcm9zc2hhaXJzOiBcXGYwNWI7XG4kZmEtdmFyLWNzczM6IFxcZjEzYztcbiRmYS12YXItY3NzMy1hbHQ6IFxcZjM4YjtcbiRmYS12YXItY3ViZTogXFxmMWIyO1xuJGZhLXZhci1jdWJlczogXFxmMWIzO1xuJGZhLXZhci1jdXJsaW5nOiBcXGY0NGE7XG4kZmEtdmFyLWN1dDogXFxmMGM0O1xuJGZhLXZhci1jdXR0bGVmaXNoOiBcXGYzOGM7XG4kZmEtdmFyLWQtYW5kLWQ6IFxcZjM4ZDtcbiRmYS12YXItZGFzaGN1YmU6IFxcZjIxMDtcbiRmYS12YXItZGF0YWJhc2U6IFxcZjFjMDtcbiRmYS12YXItZGVhZjogXFxmMmE0O1xuJGZhLXZhci1kZWxpY2lvdXM6IFxcZjFhNTtcbiRmYS12YXItZGVwbG95ZG9nOiBcXGYzOGU7XG4kZmEtdmFyLWRlc2twcm86IFxcZjM4ZjtcbiRmYS12YXItZGVza3RvcDogXFxmMTA4O1xuJGZhLXZhci1kZXNrdG9wLWFsdDogXFxmMzkwO1xuJGZhLXZhci1kZXZpYW50YXJ0OiBcXGYxYmQ7XG4kZmEtdmFyLWRpYWdub3NlczogXFxmNDcwO1xuJGZhLXZhci1kaWFtb25kOiBcXGYyMTk7XG4kZmEtdmFyLWRpZ2c6IFxcZjFhNjtcbiRmYS12YXItZGlnaXRhbC1vY2VhbjogXFxmMzkxO1xuJGZhLXZhci1kaXNjb3JkOiBcXGYzOTI7XG4kZmEtdmFyLWRpc2NvdXJzZTogXFxmMzkzO1xuJGZhLXZhci1kbmE6IFxcZjQ3MTtcbiRmYS12YXItZG9jaHViOiBcXGYzOTQ7XG4kZmEtdmFyLWRvY2tlcjogXFxmMzk1O1xuJGZhLXZhci1kb2xsYXItc2lnbjogXFxmMTU1O1xuJGZhLXZhci1kb2xseTogXFxmNDcyO1xuJGZhLXZhci1kb2xseS1lbXB0eTogXFxmNDczO1xuJGZhLXZhci1kb2xseS1mbGF0YmVkOiBcXGY0NzQ7XG4kZmEtdmFyLWRvbGx5LWZsYXRiZWQtYWx0OiBcXGY0NzU7XG4kZmEtdmFyLWRvbGx5LWZsYXRiZWQtZW1wdHk6IFxcZjQ3NjtcbiRmYS12YXItZG90LWNpcmNsZTogXFxmMTkyO1xuJGZhLXZhci1kb3dubG9hZDogXFxmMDE5O1xuJGZhLXZhci1kcmFmdDJkaWdpdGFsOiBcXGYzOTY7XG4kZmEtdmFyLWRyaWJiYmxlOiBcXGYxN2Q7XG4kZmEtdmFyLWRyaWJiYmxlLXNxdWFyZTogXFxmMzk3O1xuJGZhLXZhci1kcm9wYm94OiBcXGYxNmI7XG4kZmEtdmFyLWRydXBhbDogXFxmMWE5O1xuJGZhLXZhci1kdW1iYmVsbDogXFxmNDRiO1xuJGZhLXZhci1keWFsb2c6IFxcZjM5OTtcbiRmYS12YXItZWFybHliaXJkczogXFxmMzlhO1xuJGZhLXZhci1lZGdlOiBcXGYyODI7XG4kZmEtdmFyLWVkaXQ6IFxcZjA0NDtcbiRmYS12YXItZWplY3Q6IFxcZjA1MjtcbiRmYS12YXItZWxlbWVudG9yOiBcXGY0MzA7XG4kZmEtdmFyLWVsbGlwc2lzLWg6IFxcZjE0MTtcbiRmYS12YXItZWxsaXBzaXMtaC1hbHQ6IFxcZjM5YjtcbiRmYS12YXItZWxsaXBzaXMtdjogXFxmMTQyO1xuJGZhLXZhci1lbGxpcHNpcy12LWFsdDogXFxmMzljO1xuJGZhLXZhci1lbWJlcjogXFxmNDIzO1xuJGZhLXZhci1lbXBpcmU6IFxcZjFkMTtcbiRmYS12YXItZW52ZWxvcGU6IFxcZjBlMDtcbiRmYS12YXItZW52ZWxvcGUtb3BlbjogXFxmMmI2O1xuJGZhLXZhci1lbnZlbG9wZS1zcXVhcmU6IFxcZjE5OTtcbiRmYS12YXItZW52aXJhOiBcXGYyOTk7XG4kZmEtdmFyLWVyYXNlcjogXFxmMTJkO1xuJGZhLXZhci1lcmxhbmc6IFxcZjM5ZDtcbiRmYS12YXItZXRoZXJldW06IFxcZjQyZTtcbiRmYS12YXItZXRzeTogXFxmMmQ3O1xuJGZhLXZhci1ldXJvLXNpZ246IFxcZjE1MztcbiRmYS12YXItZXhjaGFuZ2U6IFxcZjBlYztcbiRmYS12YXItZXhjaGFuZ2UtYWx0OiBcXGYzNjI7XG4kZmEtdmFyLWV4Y2xhbWF0aW9uOiBcXGYxMmE7XG4kZmEtdmFyLWV4Y2xhbWF0aW9uLWNpcmNsZTogXFxmMDZhO1xuJGZhLXZhci1leGNsYW1hdGlvbi1zcXVhcmU6IFxcZjMyMTtcbiRmYS12YXItZXhjbGFtYXRpb24tdHJpYW5nbGU6IFxcZjA3MTtcbiRmYS12YXItZXhwYW5kOiBcXGYwNjU7XG4kZmEtdmFyLWV4cGFuZC1hbHQ6IFxcZjQyNDtcbiRmYS12YXItZXhwYW5kLWFycm93czogXFxmMzFkO1xuJGZhLXZhci1leHBhbmQtYXJyb3dzLWFsdDogXFxmMzFlO1xuJGZhLXZhci1leHBhbmQtd2lkZTogXFxmMzIwO1xuJGZhLXZhci1leHBlZGl0ZWRzc2w6IFxcZjIzZTtcbiRmYS12YXItZXh0ZXJuYWwtbGluazogXFxmMDhlO1xuJGZhLXZhci1leHRlcm5hbC1saW5rLWFsdDogXFxmMzVkO1xuJGZhLXZhci1leHRlcm5hbC1saW5rLXNxdWFyZTogXFxmMTRjO1xuJGZhLXZhci1leHRlcm5hbC1saW5rLXNxdWFyZS1hbHQ6IFxcZjM2MDtcbiRmYS12YXItZXllOiBcXGYwNmU7XG4kZmEtdmFyLWV5ZS1kcm9wcGVyOiBcXGYxZmI7XG4kZmEtdmFyLWV5ZS1zbGFzaDogXFxmMDcwO1xuJGZhLXZhci1mYWNlYm9vazogXFxmMDlhO1xuJGZhLXZhci1mYWNlYm9vay1mOiBcXGYzOWU7XG4kZmEtdmFyLWZhY2Vib29rLW1lc3NlbmdlcjogXFxmMzlmO1xuJGZhLXZhci1mYWNlYm9vay1zcXVhcmU6IFxcZjA4MjtcbiRmYS12YXItZmFzdC1iYWNrd2FyZDogXFxmMDQ5O1xuJGZhLXZhci1mYXN0LWZvcndhcmQ6IFxcZjA1MDtcbiRmYS12YXItZmF4OiBcXGYxYWM7XG4kZmEtdmFyLWZlbWFsZTogXFxmMTgyO1xuJGZhLXZhci1maWVsZC1ob2NrZXk6IFxcZjQ0YztcbiRmYS12YXItZmlnaHRlci1qZXQ6IFxcZjBmYjtcbiRmYS12YXItZmlsZTogXFxmMTViO1xuJGZhLXZhci1maWxlLWFsdDogXFxmMTVjO1xuJGZhLXZhci1maWxlLWFyY2hpdmU6IFxcZjFjNjtcbiRmYS12YXItZmlsZS1hdWRpbzogXFxmMWM3O1xuJGZhLXZhci1maWxlLWNoZWNrOiBcXGYzMTY7XG4kZmEtdmFyLWZpbGUtY29kZTogXFxmMWM5O1xuJGZhLXZhci1maWxlLWVkaXQ6IFxcZjMxYztcbiRmYS12YXItZmlsZS1leGNlbDogXFxmMWMzO1xuJGZhLXZhci1maWxlLWV4Y2xhbWF0aW9uOiBcXGYzMWE7XG4kZmEtdmFyLWZpbGUtaW1hZ2U6IFxcZjFjNTtcbiRmYS12YXItZmlsZS1tZWRpY2FsOiBcXGY0Nzc7XG4kZmEtdmFyLWZpbGUtbWVkaWNhbC1hbHQ6IFxcZjQ3ODtcbiRmYS12YXItZmlsZS1taW51czogXFxmMzE4O1xuJGZhLXZhci1maWxlLXBkZjogXFxmMWMxO1xuJGZhLXZhci1maWxlLXBsdXM6IFxcZjMxOTtcbiRmYS12YXItZmlsZS1wb3dlcnBvaW50OiBcXGYxYzQ7XG4kZmEtdmFyLWZpbGUtdGltZXM6IFxcZjMxNztcbiRmYS12YXItZmlsZS12aWRlbzogXFxmMWM4O1xuJGZhLXZhci1maWxlLXdvcmQ6IFxcZjFjMjtcbiRmYS12YXItZmlsbTogXFxmMDA4O1xuJGZhLXZhci1maWxtLWFsdDogXFxmM2EwO1xuJGZhLXZhci1maWx0ZXI6IFxcZjBiMDtcbiRmYS12YXItZmlyZTogXFxmMDZkO1xuJGZhLXZhci1maXJlLWV4dGluZ3Vpc2hlcjogXFxmMTM0O1xuJGZhLXZhci1maXJlZm94OiBcXGYyNjk7XG4kZmEtdmFyLWZpcnN0LWFpZDogXFxmNDc5O1xuJGZhLXZhci1maXJzdC1vcmRlcjogXFxmMmIwO1xuJGZhLXZhci1maXJzdGRyYWZ0OiBcXGYzYTE7XG4kZmEtdmFyLWZsYWc6IFxcZjAyNDtcbiRmYS12YXItZmxhZy1jaGVja2VyZWQ6IFxcZjExZTtcbiRmYS12YXItZmxhc2s6IFxcZjBjMztcbiRmYS12YXItZmxpY2tyOiBcXGYxNmU7XG4kZmEtdmFyLWZsaXBib2FyZDogXFxmNDRkO1xuJGZhLXZhci1mbHk6IFxcZjQxNztcbiRmYS12YXItZm9sZGVyOiBcXGYwN2I7XG4kZmEtdmFyLWZvbGRlci1vcGVuOiBcXGYwN2M7XG4kZmEtdmFyLWZvbnQ6IFxcZjAzMTtcbiRmYS12YXItZm9udC1hd2Vzb21lOiBcXGYyYjQ7XG4kZmEtdmFyLWZvbnQtYXdlc29tZS1hbHQ6IFxcZjM1YztcbiRmYS12YXItZm9udC1hd2Vzb21lLWZsYWc6IFxcZjQyNTtcbiRmYS12YXItZm9udGljb25zOiBcXGYyODA7XG4kZmEtdmFyLWZvbnRpY29ucy1maTogXFxmM2EyO1xuJGZhLXZhci1mb290YmFsbC1iYWxsOiBcXGY0NGU7XG4kZmEtdmFyLWZvb3RiYWxsLWhlbG1ldDogXFxmNDRmO1xuJGZhLXZhci1mb3JrbGlmdDogXFxmNDdhO1xuJGZhLXZhci1mb3J0LWF3ZXNvbWU6IFxcZjI4NjtcbiRmYS12YXItZm9ydC1hd2Vzb21lLWFsdDogXFxmM2EzO1xuJGZhLXZhci1mb3J1bWJlZTogXFxmMjExO1xuJGZhLXZhci1mb3J3YXJkOiBcXGYwNGU7XG4kZmEtdmFyLWZvdXJzcXVhcmU6IFxcZjE4MDtcbiRmYS12YXItZnJlZS1jb2RlLWNhbXA6IFxcZjJjNTtcbiRmYS12YXItZnJlZWJzZDogXFxmM2E0O1xuJGZhLXZhci1mcm93bjogXFxmMTE5O1xuJGZhLXZhci1mdXRib2w6IFxcZjFlMztcbiRmYS12YXItZ2FtZXBhZDogXFxmMTFiO1xuJGZhLXZhci1nYXZlbDogXFxmMGUzO1xuJGZhLXZhci1nZW06IFxcZjNhNTtcbiRmYS12YXItZ2VuZGVybGVzczogXFxmMjJkO1xuJGZhLXZhci1nZXQtcG9ja2V0OiBcXGYyNjU7XG4kZmEtdmFyLWdnOiBcXGYyNjA7XG4kZmEtdmFyLWdnLWNpcmNsZTogXFxmMjYxO1xuJGZhLXZhci1naWZ0OiBcXGYwNmI7XG4kZmEtdmFyLWdpdDogXFxmMWQzO1xuJGZhLXZhci1naXQtc3F1YXJlOiBcXGYxZDI7XG4kZmEtdmFyLWdpdGh1YjogXFxmMDliO1xuJGZhLXZhci1naXRodWItYWx0OiBcXGYxMTM7XG4kZmEtdmFyLWdpdGh1Yi1zcXVhcmU6IFxcZjA5MjtcbiRmYS12YXItZ2l0a3Jha2VuOiBcXGYzYTY7XG4kZmEtdmFyLWdpdGxhYjogXFxmMjk2O1xuJGZhLXZhci1naXR0ZXI6IFxcZjQyNjtcbiRmYS12YXItZ2xhc3MtbWFydGluaTogXFxmMDAwO1xuJGZhLXZhci1nbGlkZTogXFxmMmE1O1xuJGZhLXZhci1nbGlkZS1nOiBcXGYyYTY7XG4kZmEtdmFyLWdsb2JlOiBcXGYwYWM7XG4kZmEtdmFyLWdvZm9yZTogXFxmM2E3O1xuJGZhLXZhci1nb2xmLWJhbGw6IFxcZjQ1MDtcbiRmYS12YXItZ29sZi1jbHViOiBcXGY0NTE7XG4kZmEtdmFyLWdvb2RyZWFkczogXFxmM2E4O1xuJGZhLXZhci1nb29kcmVhZHMtZzogXFxmM2E5O1xuJGZhLXZhci1nb29nbGU6IFxcZjFhMDtcbiRmYS12YXItZ29vZ2xlLWRyaXZlOiBcXGYzYWE7XG4kZmEtdmFyLWdvb2dsZS1wbGF5OiBcXGYzYWI7XG4kZmEtdmFyLWdvb2dsZS1wbHVzOiBcXGYyYjM7XG4kZmEtdmFyLWdvb2dsZS1wbHVzLWc6IFxcZjBkNTtcbiRmYS12YXItZ29vZ2xlLXBsdXMtc3F1YXJlOiBcXGYwZDQ7XG4kZmEtdmFyLWdvb2dsZS13YWxsZXQ6IFxcZjFlZTtcbiRmYS12YXItZ3JhZHVhdGlvbi1jYXA6IFxcZjE5ZDtcbiRmYS12YXItZ3JhdGlwYXk6IFxcZjE4NDtcbiRmYS12YXItZ3JhdjogXFxmMmQ2O1xuJGZhLXZhci1ncmlwZmlyZTogXFxmM2FjO1xuJGZhLXZhci1ncnVudDogXFxmM2FkO1xuJGZhLXZhci1ndWxwOiBcXGYzYWU7XG4kZmEtdmFyLWgtc3F1YXJlOiBcXGYwZmQ7XG4kZmEtdmFyLWgxOiBcXGYzMTM7XG4kZmEtdmFyLWgyOiBcXGYzMTQ7XG4kZmEtdmFyLWgzOiBcXGYzMTU7XG4kZmEtdmFyLWhhY2tlci1uZXdzOiBcXGYxZDQ7XG4kZmEtdmFyLWhhY2tlci1uZXdzLXNxdWFyZTogXFxmM2FmO1xuJGZhLXZhci1oYW5kLWhvbGRpbmctYm94OiBcXGY0N2I7XG4kZmEtdmFyLWhhbmQtbGl6YXJkOiBcXGYyNTg7XG4kZmEtdmFyLWhhbmQtcGFwZXI6IFxcZjI1NjtcbiRmYS12YXItaGFuZC1wZWFjZTogXFxmMjViO1xuJGZhLXZhci1oYW5kLXBvaW50LWRvd246IFxcZjBhNztcbiRmYS12YXItaGFuZC1wb2ludC1sZWZ0OiBcXGYwYTU7XG4kZmEtdmFyLWhhbmQtcG9pbnQtcmlnaHQ6IFxcZjBhNDtcbiRmYS12YXItaGFuZC1wb2ludC11cDogXFxmMGE2O1xuJGZhLXZhci1oYW5kLXBvaW50ZXI6IFxcZjI1YTtcbiRmYS12YXItaGFuZC1yZWNlaXZpbmc6IFxcZjQ3YztcbiRmYS12YXItaGFuZC1yb2NrOiBcXGYyNTU7XG4kZmEtdmFyLWhhbmQtc2Npc3NvcnM6IFxcZjI1NztcbiRmYS12YXItaGFuZC1zcG9jazogXFxmMjU5O1xuJGZhLXZhci1oYW5kc2hha2U6IFxcZjJiNTtcbiRmYS12YXItaGFzaHRhZzogXFxmMjkyO1xuJGZhLXZhci1oZGQ6IFxcZjBhMDtcbiRmYS12YXItaGVhZGluZzogXFxmMWRjO1xuJGZhLXZhci1oZWFkcGhvbmVzOiBcXGYwMjU7XG4kZmEtdmFyLWhlYXJ0OiBcXGYwMDQ7XG4kZmEtdmFyLWhlYXJ0YmVhdDogXFxmMjFlO1xuJGZhLXZhci1oZXhhZ29uOiBcXGYzMTI7XG4kZmEtdmFyLWhpcHM6IFxcZjQ1MjtcbiRmYS12YXItaGlyZS1hLWhlbHBlcjogXFxmM2IwO1xuJGZhLXZhci1oaXN0b3J5OiBcXGYxZGE7XG4kZmEtdmFyLWhvY2tleS1wdWNrOiBcXGY0NTM7XG4kZmEtdmFyLWhvY2tleS1zdGlja3M6IFxcZjQ1NDtcbiRmYS12YXItaG9tZTogXFxmMDE1O1xuJGZhLXZhci1ob29saTogXFxmNDI3O1xuJGZhLXZhci1ob3NwaXRhbDogXFxmMGY4O1xuJGZhLXZhci1ob3NwaXRhbC1hbHQ6IFxcZjQ3ZDtcbiRmYS12YXItaG9zcGl0YWwtc3ltYm9sOiBcXGY0N2U7XG4kZmEtdmFyLWhvdGphcjogXFxmM2IxO1xuJGZhLXZhci1ob3VyZ2xhc3M6IFxcZjI1NDtcbiRmYS12YXItaG91cmdsYXNzLWVuZDogXFxmMjUzO1xuJGZhLXZhci1ob3VyZ2xhc3MtaGFsZjogXFxmMjUyO1xuJGZhLXZhci1ob3VyZ2xhc3Mtc3RhcnQ6IFxcZjI1MTtcbiRmYS12YXItaG91eno6IFxcZjI3YztcbiRmYS12YXItaHRtbDU6IFxcZjEzYjtcbiRmYS12YXItaHVic3BvdDogXFxmM2IyO1xuJGZhLXZhci1pLWN1cnNvcjogXFxmMjQ2O1xuJGZhLXZhci1pZC1iYWRnZTogXFxmMmMxO1xuJGZhLXZhci1pZC1jYXJkOiBcXGYyYzI7XG4kZmEtdmFyLWlkLWNhcmQtYWx0OiBcXGY0N2Y7XG4kZmEtdmFyLWltYWdlOiBcXGYwM2U7XG4kZmEtdmFyLWltYWdlczogXFxmMzAyO1xuJGZhLXZhci1pbWRiOiBcXGYyZDg7XG4kZmEtdmFyLWluYm94OiBcXGYwMWM7XG4kZmEtdmFyLWluYm94LWluOiBcXGYzMTA7XG4kZmEtdmFyLWluYm94LW91dDogXFxmMzExO1xuJGZhLXZhci1pbmRlbnQ6IFxcZjAzYztcbiRmYS12YXItaW5kdXN0cnk6IFxcZjI3NTtcbiRmYS12YXItaW5kdXN0cnktYWx0OiBcXGYzYjM7XG4kZmEtdmFyLWluZm86IFxcZjEyOTtcbiRmYS12YXItaW5mby1jaXJjbGU6IFxcZjA1YTtcbiRmYS12YXItaW5mby1zcXVhcmU6IFxcZjMwZjtcbiRmYS12YXItaW5zdGFncmFtOiBcXGYxNmQ7XG4kZmEtdmFyLWludGVybmV0LWV4cGxvcmVyOiBcXGYyNmI7XG4kZmEtdmFyLWludmVudG9yeTogXFxmNDgwO1xuJGZhLXZhci1pb3hob3N0OiBcXGYyMDg7XG4kZmEtdmFyLWl0YWxpYzogXFxmMDMzO1xuJGZhLXZhci1pdHVuZXM6IFxcZjNiNDtcbiRmYS12YXItaXR1bmVzLW5vdGU6IFxcZjNiNTtcbiRmYS12YXItamFjay1vLWxhbnRlcm46IFxcZjMwZTtcbiRmYS12YXItamVua2luczogXFxmM2I2O1xuJGZhLXZhci1qb2dldDogXFxmM2I3O1xuJGZhLXZhci1qb29tbGE6IFxcZjFhYTtcbiRmYS12YXItanM6IFxcZjNiODtcbiRmYS12YXItanMtc3F1YXJlOiBcXGYzYjk7XG4kZmEtdmFyLWpzZmlkZGxlOiBcXGYxY2M7XG4kZmEtdmFyLWtleTogXFxmMDg0O1xuJGZhLXZhci1rZXlib2FyZDogXFxmMTFjO1xuJGZhLXZhci1rZXljZG46IFxcZjNiYTtcbiRmYS12YXIta2lja3N0YXJ0ZXI6IFxcZjNiYjtcbiRmYS12YXIta2lja3N0YXJ0ZXItazogXFxmM2JjO1xuJGZhLXZhci1rb3J2dWU6IFxcZjQyZjtcbiRmYS12YXItbGFuZ3VhZ2U6IFxcZjFhYjtcbiRmYS12YXItbGFwdG9wOiBcXGYxMDk7XG4kZmEtdmFyLWxhcmF2ZWw6IFxcZjNiZDtcbiRmYS12YXItbGFzdGZtOiBcXGYyMDI7XG4kZmEtdmFyLWxhc3RmbS1zcXVhcmU6IFxcZjIwMztcbiRmYS12YXItbGVhZjogXFxmMDZjO1xuJGZhLXZhci1sZWFucHViOiBcXGYyMTI7XG4kZmEtdmFyLWxlbW9uOiBcXGYwOTQ7XG4kZmEtdmFyLWxlc3M6IFxcZjQxZDtcbiRmYS12YXItbGV2ZWwtZG93bjogXFxmMTQ5O1xuJGZhLXZhci1sZXZlbC1kb3duLWFsdDogXFxmM2JlO1xuJGZhLXZhci1sZXZlbC11cDogXFxmMTQ4O1xuJGZhLXZhci1sZXZlbC11cC1hbHQ6IFxcZjNiZjtcbiRmYS12YXItbGlmZS1yaW5nOiBcXGYxY2Q7XG4kZmEtdmFyLWxpZ2h0YnVsYjogXFxmMGViO1xuJGZhLXZhci1saW5lOiBcXGYzYzA7XG4kZmEtdmFyLWxpbms6IFxcZjBjMTtcbiRmYS12YXItbGlua2VkaW46IFxcZjA4YztcbiRmYS12YXItbGlua2VkaW4taW46IFxcZjBlMTtcbiRmYS12YXItbGlub2RlOiBcXGYyYjg7XG4kZmEtdmFyLWxpbnV4OiBcXGYxN2M7XG4kZmEtdmFyLWxpcmEtc2lnbjogXFxmMTk1O1xuJGZhLXZhci1saXN0OiBcXGYwM2E7XG4kZmEtdmFyLWxpc3QtYWx0OiBcXGYwMjI7XG4kZmEtdmFyLWxpc3Qtb2w6IFxcZjBjYjtcbiRmYS12YXItbGlzdC11bDogXFxmMGNhO1xuJGZhLXZhci1sb2NhdGlvbi1hcnJvdzogXFxmMTI0O1xuJGZhLXZhci1sb2NrOiBcXGYwMjM7XG4kZmEtdmFyLWxvY2stYWx0OiBcXGYzMGQ7XG4kZmEtdmFyLWxvY2stb3BlbjogXFxmM2MxO1xuJGZhLXZhci1sb2NrLW9wZW4tYWx0OiBcXGYzYzI7XG4kZmEtdmFyLWxvbmctYXJyb3ctYWx0LWRvd246IFxcZjMwOTtcbiRmYS12YXItbG9uZy1hcnJvdy1hbHQtbGVmdDogXFxmMzBhO1xuJGZhLXZhci1sb25nLWFycm93LWFsdC1yaWdodDogXFxmMzBiO1xuJGZhLXZhci1sb25nLWFycm93LWFsdC11cDogXFxmMzBjO1xuJGZhLXZhci1sb25nLWFycm93LWRvd246IFxcZjE3NTtcbiRmYS12YXItbG9uZy1hcnJvdy1sZWZ0OiBcXGYxNzc7XG4kZmEtdmFyLWxvbmctYXJyb3ctcmlnaHQ6IFxcZjE3ODtcbiRmYS12YXItbG9uZy1hcnJvdy11cDogXFxmMTc2O1xuJGZhLXZhci1sb3ctdmlzaW9uOiBcXGYyYTg7XG4kZmEtdmFyLWx1Y2hhZG9yOiBcXGY0NTU7XG4kZmEtdmFyLWx5ZnQ6IFxcZjNjMztcbiRmYS12YXItbWFnZW50bzogXFxmM2M0O1xuJGZhLXZhci1tYWdpYzogXFxmMGQwO1xuJGZhLXZhci1tYWduZXQ6IFxcZjA3NjtcbiRmYS12YXItbWFsZTogXFxmMTgzO1xuJGZhLXZhci1tYXA6IFxcZjI3OTtcbiRmYS12YXItbWFwLW1hcmtlcjogXFxmMDQxO1xuJGZhLXZhci1tYXAtbWFya2VyLWFsdDogXFxmM2M1O1xuJGZhLXZhci1tYXAtcGluOiBcXGYyNzY7XG4kZmEtdmFyLW1hcC1zaWduczogXFxmMjc3O1xuJGZhLXZhci1tYXJzOiBcXGYyMjI7XG4kZmEtdmFyLW1hcnMtZG91YmxlOiBcXGYyMjc7XG4kZmEtdmFyLW1hcnMtc3Ryb2tlOiBcXGYyMjk7XG4kZmEtdmFyLW1hcnMtc3Ryb2tlLWg6IFxcZjIyYjtcbiRmYS12YXItbWFycy1zdHJva2UtdjogXFxmMjJhO1xuJGZhLXZhci1tYXhjZG46IFxcZjEzNjtcbiRmYS12YXItbWVkYXBwczogXFxmM2M2O1xuJGZhLXZhci1tZWRpdW06IFxcZjIzYTtcbiRmYS12YXItbWVkaXVtLW06IFxcZjNjNztcbiRmYS12YXItbWVka2l0OiBcXGYwZmE7XG4kZmEtdmFyLW1lZHJ0OiBcXGYzYzg7XG4kZmEtdmFyLW1lZXR1cDogXFxmMmUwO1xuJGZhLXZhci1tZWg6IFxcZjExYTtcbiRmYS12YXItbWVyY3VyeTogXFxmMjIzO1xuJGZhLXZhci1taWNyb2NoaXA6IFxcZjJkYjtcbiRmYS12YXItbWljcm9waG9uZTogXFxmMTMwO1xuJGZhLXZhci1taWNyb3Bob25lLWFsdDogXFxmM2M5O1xuJGZhLXZhci1taWNyb3Bob25lLXNsYXNoOiBcXGYxMzE7XG4kZmEtdmFyLW1pY3Jvc29mdDogXFxmM2NhO1xuJGZhLXZhci1taW51czogXFxmMDY4O1xuJGZhLXZhci1taW51cy1jaXJjbGU6IFxcZjA1NjtcbiRmYS12YXItbWludXMtaGV4YWdvbjogXFxmMzA3O1xuJGZhLXZhci1taW51cy1vY3RhZ29uOiBcXGYzMDg7XG4kZmEtdmFyLW1pbnVzLXNxdWFyZTogXFxmMTQ2O1xuJGZhLXZhci1taXg6IFxcZjNjYjtcbiRmYS12YXItbWl4Y2xvdWQ6IFxcZjI4OTtcbiRmYS12YXItbWl6dW5pOiBcXGYzY2M7XG4kZmEtdmFyLW1vYmlsZTogXFxmMTBiO1xuJGZhLXZhci1tb2JpbGUtYWx0OiBcXGYzY2Q7XG4kZmEtdmFyLW1vYmlsZS1hbmRyb2lkOiBcXGYzY2U7XG4kZmEtdmFyLW1vYmlsZS1hbmRyb2lkLWFsdDogXFxmM2NmO1xuJGZhLXZhci1tb2R4OiBcXGYyODU7XG4kZmEtdmFyLW1vbmVybzogXFxmM2QwO1xuJGZhLXZhci1tb25leS1iaWxsOiBcXGYwZDY7XG4kZmEtdmFyLW1vbmV5LWJpbGwtYWx0OiBcXGYzZDE7XG4kZmEtdmFyLW1vb246IFxcZjE4NjtcbiRmYS12YXItbW90b3JjeWNsZTogXFxmMjFjO1xuJGZhLXZhci1tb3VzZS1wb2ludGVyOiBcXGYyNDU7XG4kZmEtdmFyLW11c2ljOiBcXGYwMDE7XG4kZmEtdmFyLW5hcHN0ZXI6IFxcZjNkMjtcbiRmYS12YXItbmV1dGVyOiBcXGYyMmM7XG4kZmEtdmFyLW5ld3NwYXBlcjogXFxmMWVhO1xuJGZhLXZhci1uaW50ZW5kby1zd2l0Y2g6IFxcZjQxODtcbiRmYS12YXItbm9kZTogXFxmNDE5O1xuJGZhLXZhci1ub2RlLWpzOiBcXGYzZDM7XG4kZmEtdmFyLW5vdGVzLW1lZGljYWw6IFxcZjQ4MTtcbiRmYS12YXItbnBtOiBcXGYzZDQ7XG4kZmEtdmFyLW5zODogXFxmM2Q1O1xuJGZhLXZhci1udXRyaXRpb25peDogXFxmM2Q2O1xuJGZhLXZhci1vYmplY3QtZ3JvdXA6IFxcZjI0NztcbiRmYS12YXItb2JqZWN0LXVuZ3JvdXA6IFxcZjI0ODtcbiRmYS12YXItb2N0YWdvbjogXFxmMzA2O1xuJGZhLXZhci1vZG5va2xhc3NuaWtpOiBcXGYyNjM7XG4kZmEtdmFyLW9kbm9rbGFzc25pa2ktc3F1YXJlOiBcXGYyNjQ7XG4kZmEtdmFyLW9wZW5jYXJ0OiBcXGYyM2Q7XG4kZmEtdmFyLW9wZW5pZDogXFxmMTliO1xuJGZhLXZhci1vcGVyYTogXFxmMjZhO1xuJGZhLXZhci1vcHRpbi1tb25zdGVyOiBcXGYyM2M7XG4kZmEtdmFyLW9zaTogXFxmNDFhO1xuJGZhLXZhci1vdXRkZW50OiBcXGYwM2I7XG4kZmEtdmFyLXBhZ2U0OiBcXGYzZDc7XG4kZmEtdmFyLXBhZ2VsaW5lczogXFxmMThjO1xuJGZhLXZhci1wYWludC1icnVzaDogXFxmMWZjO1xuJGZhLXZhci1wYWxmZWQ6IFxcZjNkODtcbiRmYS12YXItcGFsbGV0OiBcXGY0ODI7XG4kZmEtdmFyLXBhbGxldC1hbHQ6IFxcZjQ4MztcbiRmYS12YXItcGFwZXItcGxhbmU6IFxcZjFkODtcbiRmYS12YXItcGFwZXJjbGlwOiBcXGYwYzY7XG4kZmEtdmFyLXBhcmFncmFwaDogXFxmMWRkO1xuJGZhLXZhci1wYXN0ZTogXFxmMGVhO1xuJGZhLXZhci1wYXRyZW9uOiBcXGYzZDk7XG4kZmEtdmFyLXBhdXNlOiBcXGYwNGM7XG4kZmEtdmFyLXBhdXNlLWNpcmNsZTogXFxmMjhiO1xuJGZhLXZhci1wYXc6IFxcZjFiMDtcbiRmYS12YXItcGF5cGFsOiBcXGYxZWQ7XG4kZmEtdmFyLXBlbjogXFxmMzA0O1xuJGZhLXZhci1wZW4tYWx0OiBcXGYzMDU7XG4kZmEtdmFyLXBlbi1zcXVhcmU6IFxcZjE0YjtcbiRmYS12YXItcGVuY2lsOiBcXGYwNDA7XG4kZmEtdmFyLXBlbmNpbC1hbHQ6IFxcZjMwMztcbiRmYS12YXItcGVubmFudDogXFxmNDU2O1xuJGZhLXZhci1wZXJjZW50OiBcXGYyOTU7XG4kZmEtdmFyLXBlcmlzY29wZTogXFxmM2RhO1xuJGZhLXZhci1waGFicmljYXRvcjogXFxmM2RiO1xuJGZhLXZhci1waG9lbml4LWZyYW1ld29yazogXFxmM2RjO1xuJGZhLXZhci1waG9uZTogXFxmMDk1O1xuJGZhLXZhci1waG9uZS1zbGFzaDogXFxmM2RkO1xuJGZhLXZhci1waG9uZS1zcXVhcmU6IFxcZjA5ODtcbiRmYS12YXItcGhvbmUtdm9sdW1lOiBcXGYyYTA7XG4kZmEtdmFyLXBocDogXFxmNDU3O1xuJGZhLXZhci1waWVkLXBpcGVyOiBcXGYyYWU7XG4kZmEtdmFyLXBpZWQtcGlwZXItYWx0OiBcXGYxYTg7XG4kZmEtdmFyLXBpZWQtcGlwZXItcHA6IFxcZjFhNztcbiRmYS12YXItcGlsbHM6IFxcZjQ4NDtcbiRmYS12YXItcGludGVyZXN0OiBcXGYwZDI7XG4kZmEtdmFyLXBpbnRlcmVzdC1wOiBcXGYyMzE7XG4kZmEtdmFyLXBpbnRlcmVzdC1zcXVhcmU6IFxcZjBkMztcbiRmYS12YXItcGxhbmU6IFxcZjA3MjtcbiRmYS12YXItcGxhbmUtYWx0OiBcXGYzZGU7XG4kZmEtdmFyLXBsYXk6IFxcZjA0YjtcbiRmYS12YXItcGxheS1jaXJjbGU6IFxcZjE0NDtcbiRmYS12YXItcGxheXN0YXRpb246IFxcZjNkZjtcbiRmYS12YXItcGx1ZzogXFxmMWU2O1xuJGZhLXZhci1wbHVzOiBcXGYwNjc7XG4kZmEtdmFyLXBsdXMtY2lyY2xlOiBcXGYwNTU7XG4kZmEtdmFyLXBsdXMtaGV4YWdvbjogXFxmMzAwO1xuJGZhLXZhci1wbHVzLW9jdGFnb246IFxcZjMwMTtcbiRmYS12YXItcGx1cy1zcXVhcmU6IFxcZjBmZTtcbiRmYS12YXItcG9kY2FzdDogXFxmMmNlO1xuJGZhLXZhci1wb286IFxcZjJmZTtcbiRmYS12YXItcG9ydHJhaXQ6IFxcZjNlMDtcbiRmYS12YXItcG91bmQtc2lnbjogXFxmMTU0O1xuJGZhLXZhci1wb3dlci1vZmY6IFxcZjAxMTtcbiRmYS12YXItcHJlc2NyaXB0aW9uLWJvdHRsZTogXFxmNDg1O1xuJGZhLXZhci1wcmVzY3JpcHRpb24tYm90dGxlLWFsdDogXFxmNDg2O1xuJGZhLXZhci1wcmludDogXFxmMDJmO1xuJGZhLXZhci1wcm9jZWR1cmVzOiBcXGY0ODc7XG4kZmEtdmFyLXByb2R1Y3QtaHVudDogXFxmMjg4O1xuJGZhLXZhci1wdXNoZWQ6IFxcZjNlMTtcbiRmYS12YXItcHV6emxlLXBpZWNlOiBcXGYxMmU7XG4kZmEtdmFyLXB5dGhvbjogXFxmM2UyO1xuJGZhLXZhci1xcTogXFxmMWQ2O1xuJGZhLXZhci1xcmNvZGU6IFxcZjAyOTtcbiRmYS12YXItcXVlc3Rpb246IFxcZjEyODtcbiRmYS12YXItcXVlc3Rpb24tY2lyY2xlOiBcXGYwNTk7XG4kZmEtdmFyLXF1ZXN0aW9uLXNxdWFyZTogXFxmMmZkO1xuJGZhLXZhci1xdWlkZGl0Y2g6IFxcZjQ1ODtcbiRmYS12YXItcXVpbnNjYXBlOiBcXGY0NTk7XG4kZmEtdmFyLXF1b3JhOiBcXGYyYzQ7XG4kZmEtdmFyLXF1b3RlLWxlZnQ6IFxcZjEwZDtcbiRmYS12YXItcXVvdGUtcmlnaHQ6IFxcZjEwZTtcbiRmYS12YXItcmFjcXVldDogXFxmNDVhO1xuJGZhLXZhci1yYW5kb206IFxcZjA3NDtcbiRmYS12YXItcmF2ZWxyeTogXFxmMmQ5O1xuJGZhLXZhci1yZWFjdDogXFxmNDFiO1xuJGZhLXZhci1yZWJlbDogXFxmMWQwO1xuJGZhLXZhci1yZWN0YW5nbGUtbGFuZHNjYXBlOiBcXGYyZmE7XG4kZmEtdmFyLXJlY3RhbmdsZS1wb3J0cmFpdDogXFxmMmZiO1xuJGZhLXZhci1yZWN0YW5nbGUtd2lkZTogXFxmMmZjO1xuJGZhLXZhci1yZWN5Y2xlOiBcXGYxYjg7XG4kZmEtdmFyLXJlZC1yaXZlcjogXFxmM2UzO1xuJGZhLXZhci1yZWRkaXQ6IFxcZjFhMTtcbiRmYS12YXItcmVkZGl0LWFsaWVuOiBcXGYyODE7XG4kZmEtdmFyLXJlZGRpdC1zcXVhcmU6IFxcZjFhMjtcbiRmYS12YXItcmVkbzogXFxmMDFlO1xuJGZhLXZhci1yZWRvLWFsdDogXFxmMmY5O1xuJGZhLXZhci1yZWdpc3RlcmVkOiBcXGYyNWQ7XG4kZmEtdmFyLXJlbmRhY3Q6IFxcZjNlNDtcbiRmYS12YXItcmVucmVuOiBcXGYxOGI7XG4kZmEtdmFyLXJlcGVhdDogXFxmMzYzO1xuJGZhLXZhci1yZXBlYXQtMTogXFxmMzY1O1xuJGZhLXZhci1yZXBlYXQtMS1hbHQ6IFxcZjM2NjtcbiRmYS12YXItcmVwZWF0LWFsdDogXFxmMzY0O1xuJGZhLXZhci1yZXBseTogXFxmM2U1O1xuJGZhLXZhci1yZXBseS1hbGw6IFxcZjEyMjtcbiRmYS12YXItcmVwbHlkOiBcXGYzZTY7XG4kZmEtdmFyLXJlc29sdmluZzogXFxmM2U3O1xuJGZhLXZhci1yZXR3ZWV0OiBcXGYwNzk7XG4kZmEtdmFyLXJldHdlZXQtYWx0OiBcXGYzNjE7XG4kZmEtdmFyLXJvYWQ6IFxcZjAxODtcbiRmYS12YXItcm9ja2V0OiBcXGYxMzU7XG4kZmEtdmFyLXJvY2tldGNoYXQ6IFxcZjNlODtcbiRmYS12YXItcm9ja3JtczogXFxmM2U5O1xuJGZhLXZhci1yc3M6IFxcZjA5ZTtcbiRmYS12YXItcnNzLXNxdWFyZTogXFxmMTQzO1xuJGZhLXZhci1ydWJsZS1zaWduOiBcXGYxNTg7XG4kZmEtdmFyLXJ1cGVlLXNpZ246IFxcZjE1NjtcbiRmYS12YXItc2FmYXJpOiBcXGYyNjc7XG4kZmEtdmFyLXNhc3M6IFxcZjQxZTtcbiRmYS12YXItc2F2ZTogXFxmMGM3O1xuJGZhLXZhci1zY2FubmVyOiBcXGY0ODg7XG4kZmEtdmFyLXNjYW5uZXIta2V5Ym9hcmQ6IFxcZjQ4OTtcbiRmYS12YXItc2Nhbm5lci10b3VjaHNjcmVlbjogXFxmNDhhO1xuJGZhLXZhci1zY2hsaXg6IFxcZjNlYTtcbiRmYS12YXItc2NyaWJkOiBcXGYyOGE7XG4kZmEtdmFyLXNjcnViYmVyOiBcXGYyZjg7XG4kZmEtdmFyLXNlYXJjaDogXFxmMDAyO1xuJGZhLXZhci1zZWFyY2gtbWludXM6IFxcZjAxMDtcbiRmYS12YXItc2VhcmNoLXBsdXM6IFxcZjAwZTtcbiRmYS12YXItc2VhcmNoZW5naW46IFxcZjNlYjtcbiRmYS12YXItc2VsbGNhc3Q6IFxcZjJkYTtcbiRmYS12YXItc2VsbHN5OiBcXGYyMTM7XG4kZmEtdmFyLXNlcnZlcjogXFxmMjMzO1xuJGZhLXZhci1zZXJ2aWNlc3RhY2s6IFxcZjNlYztcbiRmYS12YXItc2hhcmU6IFxcZjA2NDtcbiRmYS12YXItc2hhcmUtYWxsOiBcXGYzNjc7XG4kZmEtdmFyLXNoYXJlLWFsdDogXFxmMWUwO1xuJGZhLXZhci1zaGFyZS1hbHQtc3F1YXJlOiBcXGYxZTE7XG4kZmEtdmFyLXNoYXJlLXNxdWFyZTogXFxmMTRkO1xuJGZhLXZhci1zaGVrZWwtc2lnbjogXFxmMjBiO1xuJGZhLXZhci1zaGllbGQ6IFxcZjEzMjtcbiRmYS12YXItc2hpZWxkLWFsdDogXFxmM2VkO1xuJGZhLXZhci1zaGllbGQtY2hlY2s6IFxcZjJmNztcbiRmYS12YXItc2hpcDogXFxmMjFhO1xuJGZhLXZhci1zaGlwcGluZy1mYXN0OiBcXGY0OGI7XG4kZmEtdmFyLXNoaXBwaW5nLXRpbWVkOiBcXGY0OGM7XG4kZmEtdmFyLXNoaXJ0c2luYnVsazogXFxmMjE0O1xuJGZhLXZhci1zaG9wcGluZy1iYWc6IFxcZjI5MDtcbiRmYS12YXItc2hvcHBpbmctYmFza2V0OiBcXGYyOTE7XG4kZmEtdmFyLXNob3BwaW5nLWNhcnQ6IFxcZjA3YTtcbiRmYS12YXItc2hvd2VyOiBcXGYyY2M7XG4kZmEtdmFyLXNodXR0bGVjb2NrOiBcXGY0NWI7XG4kZmEtdmFyLXNpZ24taW46IFxcZjA5MDtcbiRmYS12YXItc2lnbi1pbi1hbHQ6IFxcZjJmNjtcbiRmYS12YXItc2lnbi1sYW5ndWFnZTogXFxmMmE3O1xuJGZhLXZhci1zaWduLW91dDogXFxmMDhiO1xuJGZhLXZhci1zaWduLW91dC1hbHQ6IFxcZjJmNTtcbiRmYS12YXItc2lnbmFsOiBcXGYwMTI7XG4kZmEtdmFyLXNpbXBseWJ1aWx0OiBcXGYyMTU7XG4kZmEtdmFyLXNpc3RyaXg6IFxcZjNlZTtcbiRmYS12YXItc2l0ZW1hcDogXFxmMGU4O1xuJGZhLXZhci1za3lhdGxhczogXFxmMjE2O1xuJGZhLXZhci1za3lwZTogXFxmMTdlO1xuJGZhLXZhci1zbGFjazogXFxmMTk4O1xuJGZhLXZhci1zbGFjay1oYXNoOiBcXGYzZWY7XG4kZmEtdmFyLXNsaWRlcnMtaDogXFxmMWRlO1xuJGZhLXZhci1zbGlkZXJzLWgtc3F1YXJlOiBcXGYzZjA7XG4kZmEtdmFyLXNsaWRlcnMtdjogXFxmM2YxO1xuJGZhLXZhci1zbGlkZXJzLXYtc3F1YXJlOiBcXGYzZjI7XG4kZmEtdmFyLXNsaWRlc2hhcmU6IFxcZjFlNztcbiRmYS12YXItc21pbGU6IFxcZjExODtcbiRmYS12YXItc21va2luZzogXFxmNDhkO1xuJGZhLXZhci1zbmFwY2hhdDogXFxmMmFiO1xuJGZhLXZhci1zbmFwY2hhdC1naG9zdDogXFxmMmFjO1xuJGZhLXZhci1zbmFwY2hhdC1zcXVhcmU6IFxcZjJhZDtcbiRmYS12YXItc25vd2ZsYWtlOiBcXGYyZGM7XG4kZmEtdmFyLXNvcnQ6IFxcZjBkYztcbiRmYS12YXItc29ydC1hbHBoYS1kb3duOiBcXGYxNWQ7XG4kZmEtdmFyLXNvcnQtYWxwaGEtdXA6IFxcZjE1ZTtcbiRmYS12YXItc29ydC1hbW91bnQtZG93bjogXFxmMTYwO1xuJGZhLXZhci1zb3J0LWFtb3VudC11cDogXFxmMTYxO1xuJGZhLXZhci1zb3J0LWRvd246IFxcZjBkZDtcbiRmYS12YXItc29ydC1udW1lcmljLWRvd246IFxcZjE2MjtcbiRmYS12YXItc29ydC1udW1lcmljLXVwOiBcXGYxNjM7XG4kZmEtdmFyLXNvcnQtdXA6IFxcZjBkZTtcbiRmYS12YXItc291bmRjbG91ZDogXFxmMWJlO1xuJGZhLXZhci1zcGFjZS1zaHV0dGxlOiBcXGYxOTc7XG4kZmEtdmFyLXNwYWRlOiBcXGYyZjQ7XG4kZmEtdmFyLXNwZWFrYXA6IFxcZjNmMztcbiRmYS12YXItc3Bpbm5lcjogXFxmMTEwO1xuJGZhLXZhci1zcGlubmVyLXRoaXJkOiBcXGYzZjQ7XG4kZmEtdmFyLXNwb3RpZnk6IFxcZjFiYztcbiRmYS12YXItc3F1YXJlOiBcXGYwYzg7XG4kZmEtdmFyLXNxdWFyZS1mdWxsOiBcXGY0NWM7XG4kZmEtdmFyLXN0YWNrLWV4Y2hhbmdlOiBcXGYxOGQ7XG4kZmEtdmFyLXN0YWNrLW92ZXJmbG93OiBcXGYxNmM7XG4kZmEtdmFyLXN0YXI6IFxcZjAwNTtcbiRmYS12YXItc3Rhci1leGNsYW1hdGlvbjogXFxmMmYzO1xuJGZhLXZhci1zdGFyLWhhbGY6IFxcZjA4OTtcbiRmYS12YXItc3RheWxpbmtlZDogXFxmM2Y1O1xuJGZhLXZhci1zdGVhbTogXFxmMWI2O1xuJGZhLXZhci1zdGVhbS1zcXVhcmU6IFxcZjFiNztcbiRmYS12YXItc3RlYW0tc3ltYm9sOiBcXGYzZjY7XG4kZmEtdmFyLXN0ZXAtYmFja3dhcmQ6IFxcZjA0ODtcbiRmYS12YXItc3RlcC1mb3J3YXJkOiBcXGYwNTE7XG4kZmEtdmFyLXN0ZXRob3Njb3BlOiBcXGYwZjE7XG4kZmEtdmFyLXN0aWNrZXItbXVsZTogXFxmM2Y3O1xuJGZhLXZhci1zdGlja3ktbm90ZTogXFxmMjQ5O1xuJGZhLXZhci1zdG9wOiBcXGYwNGQ7XG4kZmEtdmFyLXN0b3AtY2lyY2xlOiBcXGYyOGQ7XG4kZmEtdmFyLXN0b3B3YXRjaDogXFxmMmYyO1xuJGZhLXZhci1zdHJhdmE6IFxcZjQyODtcbiRmYS12YXItc3RyZWV0LXZpZXc6IFxcZjIxZDtcbiRmYS12YXItc3RyaWtldGhyb3VnaDogXFxmMGNjO1xuJGZhLXZhci1zdHJpcGU6IFxcZjQyOTtcbiRmYS12YXItc3RyaXBlLXM6IFxcZjQyYTtcbiRmYS12YXItc3R1ZGlvdmluYXJpOiBcXGYzZjg7XG4kZmEtdmFyLXN0dW1ibGV1cG9uOiBcXGYxYTQ7XG4kZmEtdmFyLXN0dW1ibGV1cG9uLWNpcmNsZTogXFxmMWEzO1xuJGZhLXZhci1zdWJzY3JpcHQ6IFxcZjEyYztcbiRmYS12YXItc3Vid2F5OiBcXGYyMzk7XG4kZmEtdmFyLXN1aXRjYXNlOiBcXGYwZjI7XG4kZmEtdmFyLXN1bjogXFxmMTg1O1xuJGZhLXZhci1zdXBlcnBvd2VyczogXFxmMmRkO1xuJGZhLXZhci1zdXBlcnNjcmlwdDogXFxmMTJiO1xuJGZhLXZhci1zdXBwbGU6IFxcZjNmOTtcbiRmYS12YXItc3luYzogXFxmMDIxO1xuJGZhLXZhci1zeW5jLWFsdDogXFxmMmYxO1xuJGZhLXZhci1zeXJpbmdlOiBcXGY0OGU7XG4kZmEtdmFyLXRhYmxlOiBcXGYwY2U7XG4kZmEtdmFyLXRhYmxlLXRlbm5pczogXFxmNDVkO1xuJGZhLXZhci10YWJsZXQ6IFxcZjEwYTtcbiRmYS12YXItdGFibGV0LWFsdDogXFxmM2ZhO1xuJGZhLXZhci10YWJsZXQtYW5kcm9pZDogXFxmM2ZiO1xuJGZhLXZhci10YWJsZXQtYW5kcm9pZC1hbHQ6IFxcZjNmYztcbiRmYS12YXItdGFibGV0LXJ1Z2dlZDogXFxmNDhmO1xuJGZhLXZhci10YWJsZXRzOiBcXGY0OTA7XG4kZmEtdmFyLXRhY2hvbWV0ZXI6IFxcZjBlNDtcbiRmYS12YXItdGFjaG9tZXRlci1hbHQ6IFxcZjNmZDtcbiRmYS12YXItdGFnOiBcXGYwMmI7XG4kZmEtdmFyLXRhZ3M6IFxcZjAyYztcbiRmYS12YXItdGFza3M6IFxcZjBhZTtcbiRmYS12YXItdGF4aTogXFxmMWJhO1xuJGZhLXZhci10ZWxlZ3JhbTogXFxmMmM2O1xuJGZhLXZhci10ZWxlZ3JhbS1wbGFuZTogXFxmM2ZlO1xuJGZhLXZhci10ZW5jZW50LXdlaWJvOiBcXGYxZDU7XG4kZmEtdmFyLXRlbm5pcy1iYWxsOiBcXGY0NWU7XG4kZmEtdmFyLXRlcm1pbmFsOiBcXGYxMjA7XG4kZmEtdmFyLXRleHQtaGVpZ2h0OiBcXGYwMzQ7XG4kZmEtdmFyLXRleHQtd2lkdGg6IFxcZjAzNTtcbiRmYS12YXItdGg6IFxcZjAwYTtcbiRmYS12YXItdGgtbGFyZ2U6IFxcZjAwOTtcbiRmYS12YXItdGgtbGlzdDogXFxmMDBiO1xuJGZhLXZhci10aGVtZWlzbGU6IFxcZjJiMjtcbiRmYS12YXItdGhlcm1vbWV0ZXI6IFxcZjQ5MTtcbiRmYS12YXItdGhlcm1vbWV0ZXItZW1wdHk6IFxcZjJjYjtcbiRmYS12YXItdGhlcm1vbWV0ZXItZnVsbDogXFxmMmM3O1xuJGZhLXZhci10aGVybW9tZXRlci1oYWxmOiBcXGYyYzk7XG4kZmEtdmFyLXRoZXJtb21ldGVyLXF1YXJ0ZXI6IFxcZjJjYTtcbiRmYS12YXItdGhlcm1vbWV0ZXItdGhyZWUtcXVhcnRlcnM6IFxcZjJjODtcbiRmYS12YXItdGh1bWJzLWRvd246IFxcZjE2NTtcbiRmYS12YXItdGh1bWJzLXVwOiBcXGYxNjQ7XG4kZmEtdmFyLXRodW1idGFjazogXFxmMDhkO1xuJGZhLXZhci10aWNrZXQ6IFxcZjE0NTtcbiRmYS12YXItdGlja2V0LWFsdDogXFxmM2ZmO1xuJGZhLXZhci10aW1lczogXFxmMDBkO1xuJGZhLXZhci10aW1lcy1jaXJjbGU6IFxcZjA1NztcbiRmYS12YXItdGltZXMtaGV4YWdvbjogXFxmMmVlO1xuJGZhLXZhci10aW1lcy1vY3RhZ29uOiBcXGYyZjA7XG4kZmEtdmFyLXRpbWVzLXNxdWFyZTogXFxmMmQzO1xuJGZhLXZhci10aW50OiBcXGYwNDM7XG4kZmEtdmFyLXRvZ2dsZS1vZmY6IFxcZjIwNDtcbiRmYS12YXItdG9nZ2xlLW9uOiBcXGYyMDU7XG4kZmEtdmFyLXRyYWRlbWFyazogXFxmMjVjO1xuJGZhLXZhci10cmFpbjogXFxmMjM4O1xuJGZhLXZhci10cmFuc2dlbmRlcjogXFxmMjI0O1xuJGZhLXZhci10cmFuc2dlbmRlci1hbHQ6IFxcZjIyNTtcbiRmYS12YXItdHJhc2g6IFxcZjFmODtcbiRmYS12YXItdHJhc2gtYWx0OiBcXGYyZWQ7XG4kZmEtdmFyLXRyZWU6IFxcZjFiYjtcbiRmYS12YXItdHJlZS1hbHQ6IFxcZjQwMDtcbiRmYS12YXItdHJlbGxvOiBcXGYxODE7XG4kZmEtdmFyLXRyaWFuZ2xlOiBcXGYyZWM7XG4kZmEtdmFyLXRyaXBhZHZpc29yOiBcXGYyNjI7XG4kZmEtdmFyLXRyb3BoeTogXFxmMDkxO1xuJGZhLXZhci10cm9waHktYWx0OiBcXGYyZWI7XG4kZmEtdmFyLXRydWNrOiBcXGYwZDE7XG4kZmEtdmFyLXR0eTogXFxmMWU0O1xuJGZhLXZhci10dW1ibHI6IFxcZjE3MztcbiRmYS12YXItdHVtYmxyLXNxdWFyZTogXFxmMTc0O1xuJGZhLXZhci10djogXFxmMjZjO1xuJGZhLXZhci10di1yZXRybzogXFxmNDAxO1xuJGZhLXZhci10d2l0Y2g6IFxcZjFlODtcbiRmYS12YXItdHdpdHRlcjogXFxmMDk5O1xuJGZhLXZhci10d2l0dGVyLXNxdWFyZTogXFxmMDgxO1xuJGZhLXZhci10eXBvMzogXFxmNDJiO1xuJGZhLXZhci11YmVyOiBcXGY0MDI7XG4kZmEtdmFyLXVpa2l0OiBcXGY0MDM7XG4kZmEtdmFyLXVtYnJlbGxhOiBcXGYwZTk7XG4kZmEtdmFyLXVuZGVybGluZTogXFxmMGNkO1xuJGZhLXZhci11bmRvOiBcXGYwZTI7XG4kZmEtdmFyLXVuZG8tYWx0OiBcXGYyZWE7XG4kZmEtdmFyLXVuaXJlZ2lzdHJ5OiBcXGY0MDQ7XG4kZmEtdmFyLXVuaXZlcnNhbC1hY2Nlc3M6IFxcZjI5YTtcbiRmYS12YXItdW5pdmVyc2l0eTogXFxmMTljO1xuJGZhLXZhci11bmxpbms6IFxcZjEyNztcbiRmYS12YXItdW5sb2NrOiBcXGYwOWM7XG4kZmEtdmFyLXVubG9jay1hbHQ6IFxcZjEzZTtcbiRmYS12YXItdW50YXBwZDogXFxmNDA1O1xuJGZhLXZhci11cGxvYWQ6IFxcZjA5MztcbiRmYS12YXItdXNiOiBcXGYyODc7XG4kZmEtdmFyLXVzZC1jaXJjbGU6IFxcZjJlODtcbiRmYS12YXItdXNkLXNxdWFyZTogXFxmMmU5O1xuJGZhLXZhci11c2VyOiBcXGYwMDc7XG4kZmEtdmFyLXVzZXItYWx0OiBcXGY0MDY7XG4kZmEtdmFyLXVzZXItY2lyY2xlOiBcXGYyYmQ7XG4kZmEtdmFyLXVzZXItbWQ6IFxcZjBmMDtcbiRmYS12YXItdXNlci1wbHVzOiBcXGYyMzQ7XG4kZmEtdmFyLXVzZXItc2VjcmV0OiBcXGYyMWI7XG4kZmEtdmFyLXVzZXItdGltZXM6IFxcZjIzNTtcbiRmYS12YXItdXNlcnM6IFxcZjBjMDtcbiRmYS12YXItdXNzdW5uYWg6IFxcZjQwNztcbiRmYS12YXItdXRlbnNpbC1mb3JrOiBcXGYyZTM7XG4kZmEtdmFyLXV0ZW5zaWwta25pZmU6IFxcZjJlNDtcbiRmYS12YXItdXRlbnNpbC1zcG9vbjogXFxmMmU1O1xuJGZhLXZhci11dGVuc2lsczogXFxmMmU3O1xuJGZhLXZhci11dGVuc2lscy1hbHQ6IFxcZjJlNjtcbiRmYS12YXItdmFhZGluOiBcXGY0MDg7XG4kZmEtdmFyLXZlbnVzOiBcXGYyMjE7XG4kZmEtdmFyLXZlbnVzLWRvdWJsZTogXFxmMjI2O1xuJGZhLXZhci12ZW51cy1tYXJzOiBcXGYyMjg7XG4kZmEtdmFyLXZpYWNvaW46IFxcZjIzNztcbiRmYS12YXItdmlhZGVvOiBcXGYyYTk7XG4kZmEtdmFyLXZpYWRlby1zcXVhcmU6IFxcZjJhYTtcbiRmYS12YXItdmlhbDogXFxmNDkyO1xuJGZhLXZhci12aWFsczogXFxmNDkzO1xuJGZhLXZhci12aWJlcjogXFxmNDA5O1xuJGZhLXZhci12aWRlbzogXFxmMDNkO1xuJGZhLXZhci12aW1lbzogXFxmNDBhO1xuJGZhLXZhci12aW1lby1zcXVhcmU6IFxcZjE5NDtcbiRmYS12YXItdmltZW8tdjogXFxmMjdkO1xuJGZhLXZhci12aW5lOiBcXGYxY2E7XG4kZmEtdmFyLXZrOiBcXGYxODk7XG4kZmEtdmFyLXZudjogXFxmNDBiO1xuJGZhLXZhci12b2xsZXliYWxsLWJhbGw6IFxcZjQ1ZjtcbiRmYS12YXItdm9sdW1lLWRvd246IFxcZjAyNztcbiRmYS12YXItdm9sdW1lLW11dGU6IFxcZjJlMjtcbiRmYS12YXItdm9sdW1lLW9mZjogXFxmMDI2O1xuJGZhLXZhci12b2x1bWUtdXA6IFxcZjAyODtcbiRmYS12YXItdnVlanM6IFxcZjQxZjtcbiRmYS12YXItd2FyZWhvdXNlOiBcXGY0OTQ7XG4kZmEtdmFyLXdhcmVob3VzZS1hbHQ6IFxcZjQ5NTtcbiRmYS12YXItd2F0Y2g6IFxcZjJlMTtcbiRmYS12YXItd2VpYm86IFxcZjE4YTtcbiRmYS12YXItd2VpZ2h0OiBcXGY0OTY7XG4kZmEtdmFyLXdlaXhpbjogXFxmMWQ3O1xuJGZhLXZhci13aGF0c2FwcDogXFxmMjMyO1xuJGZhLXZhci13aGF0c2FwcC1zcXVhcmU6IFxcZjQwYztcbiRmYS12YXItd2hlZWxjaGFpcjogXFxmMTkzO1xuJGZhLXZhci13aGlzdGxlOiBcXGY0NjA7XG4kZmEtdmFyLXdobWNzOiBcXGY0MGQ7XG4kZmEtdmFyLXdpZmk6IFxcZjFlYjtcbiRmYS12YXItd2lraXBlZGlhLXc6IFxcZjI2NjtcbiRmYS12YXItd2luZG93OiBcXGY0MGU7XG4kZmEtdmFyLXdpbmRvdy1hbHQ6IFxcZjQwZjtcbiRmYS12YXItd2luZG93LWNsb3NlOiBcXGY0MTA7XG4kZmEtdmFyLXdpbmRvdy1tYXhpbWl6ZTogXFxmMmQwO1xuJGZhLXZhci13aW5kb3ctbWluaW1pemU6IFxcZjJkMTtcbiRmYS12YXItd2luZG93LXJlc3RvcmU6IFxcZjJkMjtcbiRmYS12YXItd2luZG93czogXFxmMTdhO1xuJGZhLXZhci13b24tc2lnbjogXFxmMTU5O1xuJGZhLXZhci13b3JkcHJlc3M6IFxcZjE5YTtcbiRmYS12YXItd29yZHByZXNzLXNpbXBsZTogXFxmNDExO1xuJGZhLXZhci13cGJlZ2lubmVyOiBcXGYyOTc7XG4kZmEtdmFyLXdwZXhwbG9yZXI6IFxcZjJkZTtcbiRmYS12YXItd3Bmb3JtczogXFxmMjk4O1xuJGZhLXZhci13cmVuY2g6IFxcZjBhZDtcbiRmYS12YXIteC1yYXk6IFxcZjQ5NztcbiRmYS12YXIteGJveDogXFxmNDEyO1xuJGZhLXZhci14aW5nOiBcXGYxNjg7XG4kZmEtdmFyLXhpbmctc3F1YXJlOiBcXGYxNjk7XG4kZmEtdmFyLXktY29tYmluYXRvcjogXFxmMjNiO1xuJGZhLXZhci15YWhvbzogXFxmMTllO1xuJGZhLXZhci15YW5kZXg6IFxcZjQxMztcbiRmYS12YXIteWFuZGV4LWludGVybmF0aW9uYWw6IFxcZjQxNDtcbiRmYS12YXIteWVscDogXFxmMWU5O1xuJGZhLXZhci15ZW4tc2lnbjogXFxmMTU3O1xuJGZhLXZhci15b2FzdDogXFxmMmIxO1xuJGZhLXZhci15b3V0dWJlOiBcXGYxNjc7XG4kZmEtdmFyLXlvdXR1YmUtc3F1YXJlOiBcXGY0MzE7XG4iLCIvLyBCb3JkZXJlZCAmIFB1bGxlZFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4uI3skZmEtY3NzLXByZWZpeH0tYm9yZGVyIHtcbiAgYm9yZGVyOiBzb2xpZCAuMDhlbSAkZmEtYm9yZGVyLWNvbG9yO1xuICBib3JkZXItcmFkaXVzOiAuMWVtO1xuICBwYWRkaW5nOiAuMmVtIC4yNWVtIC4xNWVtO1xufVxuXG4uI3skZmEtY3NzLXByZWZpeH0tcHVsbC1sZWZ0IHsgZmxvYXQ6IGxlZnQ7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wdWxsLXJpZ2h0IHsgZmxvYXQ6IHJpZ2h0OyB9XG5cbi4jeyRmYS1jc3MtcHJlZml4fSxcbi5mYXMsXG4uZmFyLFxuLmZhbCxcbi5mYWIge1xuICAmLiN7JGZhLWNzcy1wcmVmaXh9LXB1bGwtbGVmdCB7IG1hcmdpbi1yaWdodDogLjNlbTsgfVxuICAmLiN7JGZhLWNzcy1wcmVmaXh9LXB1bGwtcmlnaHQgeyBtYXJnaW4tbGVmdDogLjNlbTsgfVxufVxuIiwiLy8gQW5pbWF0ZWQgSWNvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi4jeyRmYS1jc3MtcHJlZml4fS1zcGluIHtcbiAgYW5pbWF0aW9uOiBmYS1zcGluIDJzIGluZmluaXRlIGxpbmVhcjtcbn1cblxuLiN7JGZhLWNzcy1wcmVmaXh9LXB1bHNlIHtcbiAgYW5pbWF0aW9uOiBmYS1zcGluIDFzIGluZmluaXRlIHN0ZXBzKDgpO1xufVxuXG5Aa2V5ZnJhbWVzIGZhLXNwaW4ge1xuICAwJSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG4gIH1cblxuICAxMDAlIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xuICB9XG59XG4iLCIvLyBSb3RhdGVkICYgRmxpcHBlZCBJY29uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4uI3skZmEtY3NzLXByZWZpeH0tcm90YXRlLTkwICB7IEBpbmNsdWRlIGZhLWljb24tcm90YXRlKDkwZGVnLCAxKTsgIH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yb3RhdGUtMTgwIHsgQGluY2x1ZGUgZmEtaWNvbi1yb3RhdGUoMTgwZGVnLCAyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJvdGF0ZS0yNzAgeyBAaW5jbHVkZSBmYS1pY29uLXJvdGF0ZSgyNzBkZWcsIDMpOyB9XG5cbi4jeyRmYS1jc3MtcHJlZml4fS1mbGlwLWhvcml6b250YWwgeyBAaW5jbHVkZSBmYS1pY29uLWZsaXAoLTEsIDEsIDApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmxpcC12ZXJ0aWNhbCAgIHsgQGluY2x1ZGUgZmEtaWNvbi1mbGlwKDEsIC0xLCAyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZsaXAtaG9yaXpvbnRhbC4jeyRmYS1jc3MtcHJlZml4fS1mbGlwLXZlcnRpY2FsIHsgQGluY2x1ZGUgZmEtaWNvbi1mbGlwKC0xLCAtMSwgMik7IH1cblxuLy8gSG9vayBmb3IgSUU4LTlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuOnJvb3Qge1xuICAuI3skZmEtY3NzLXByZWZpeH0tcm90YXRlLTkwLFxuICAuI3skZmEtY3NzLXByZWZpeH0tcm90YXRlLTE4MCxcbiAgLiN7JGZhLWNzcy1wcmVmaXh9LXJvdGF0ZS0yNzAsXG4gIC4jeyRmYS1jc3MtcHJlZml4fS1mbGlwLWhvcml6b250YWwsXG4gIC4jeyRmYS1jc3MtcHJlZml4fS1mbGlwLXZlcnRpY2FsIHtcbiAgICBmaWx0ZXI6IG5vbmU7XG4gIH1cbn1cbiIsIi8vIE1peGluc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuQG1peGluIGZhLWljb24ge1xuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcbiAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICBmb250LXN0eWxlOiBub3JtYWw7XG4gIGZvbnQtdmFyaWFudDogbm9ybWFsO1xuICBmb250LXdlaWdodDogbm9ybWFsO1xuICBsaW5lLWhlaWdodDogMTtcbiAgdmVydGljYWwtYWxpZ246IC0uMTI1ZW07XG59XG5cbkBtaXhpbiBmYS1pY29uLXJvdGF0ZSgkZGVncmVlcywgJHJvdGF0aW9uKSB7XG4gIC1tcy1maWx0ZXI6IFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJhc2ljSW1hZ2Uocm90YXRpb249I3skcm90YXRpb259KVwiO1xuICB0cmFuc2Zvcm06IHJvdGF0ZSgkZGVncmVlcyk7XG59XG5cbkBtaXhpbiBmYS1pY29uLWZsaXAoJGhvcml6LCAkdmVydCwgJHJvdGF0aW9uKSB7XG4gIC1tcy1maWx0ZXI6IFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJhc2ljSW1hZ2Uocm90YXRpb249I3skcm90YXRpb259LCBtaXJyb3I9MSlcIjtcbiAgdHJhbnNmb3JtOiBzY2FsZSgkaG9yaXosICR2ZXJ0KTtcbn1cblxuXG4vLyBPbmx5IGRpc3BsYXkgY29udGVudCB0byBzY3JlZW4gcmVhZGVycy4gQSBsYSBCb290c3RyYXAgNC5cbi8vXG4vLyBTZWU6IGh0dHA6Ly9hMTF5cHJvamVjdC5jb20vcG9zdHMvaG93LXRvLWhpZGUtY29udGVudC9cblxuQG1peGluIHNyLW9ubHkge1xuICBib3JkZXI6IDA7XG4gIGNsaXA6IHJlY3QoMCwgMCwgMCwgMCk7XG4gIGhlaWdodDogMXB4O1xuICBtYXJnaW46IC0xcHg7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHBhZGRpbmc6IDA7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgd2lkdGg6IDFweDtcbn1cblxuLy8gVXNlIGluIGNvbmp1bmN0aW9uIHdpdGggLnNyLW9ubHkgdG8gb25seSBkaXNwbGF5IGNvbnRlbnQgd2hlbiBpdCdzIGZvY3VzZWQuXG4vL1xuLy8gVXNlZnVsIGZvciBcIlNraXAgdG8gbWFpbiBjb250ZW50XCIgbGlua3M7IHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL05PVEUtV0NBRzIwLVRFQ0hTLTIwMTMwOTA1L0cxXG4vL1xuLy8gQ3JlZGl0OiBIVE1MNSBCb2lsZXJwbGF0ZVxuXG5AbWl4aW4gc3Itb25seS1mb2N1c2FibGUge1xuICAmOmFjdGl2ZSxcbiAgJjpmb2N1cyB7XG4gICAgY2xpcDogYXV0bztcbiAgICBoZWlnaHQ6IGF1dG87XG4gICAgbWFyZ2luOiAwO1xuICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICAgIHBvc2l0aW9uOiBzdGF0aWM7XG4gICAgd2lkdGg6IGF1dG87XG4gIH1cbn1cbiIsIi8vIFN0YWNrZWQgSWNvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0YWNrIHtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICBoZWlnaHQ6IDJlbTtcbiAgbGluZS1oZWlnaHQ6IDJlbTtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICB3aWR0aDogMmVtO1xufVxuXG4uI3skZmEtY3NzLXByZWZpeH0tc3RhY2stMXgsXG4uI3skZmEtY3NzLXByZWZpeH0tc3RhY2stMngge1xuICBsZWZ0OiAwO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgd2lkdGg6IDEwMCU7XG59XG5cbi4jeyRmYS1jc3MtcHJlZml4fS1zdGFjay0xeCB7XG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xufVxuXG4uI3skZmEtY3NzLXByZWZpeH0tc3RhY2stMngge1xuICBmb250LXNpemU6IDJlbTtcbn1cblxuLiN7JGZhLWNzcy1wcmVmaXh9LWludmVyc2Uge1xuICBjb2xvcjogJGZhLWludmVyc2U7XG59XG4iLCIvKiBGb250IEF3ZXNvbWUgdXNlcyB0aGUgVW5pY29kZSBQcml2YXRlIFVzZSBBcmVhIChQVUEpIHRvIGVuc3VyZSBzY3JlZW5cbnJlYWRlcnMgZG8gbm90IHJlYWQgb2ZmIHJhbmRvbSBjaGFyYWN0ZXJzIHRoYXQgcmVwcmVzZW50IGljb25zICovXG5cbi4jeyRmYS1jc3MtcHJlZml4fS01MDBweDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItNTAwcHgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYWNjZXNzaWJsZS1pY29uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hY2Nlc3NpYmxlLWljb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYWNjdXNvZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFjY3Vzb2Z0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFkZHJlc3MtYm9vazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYWRkcmVzcy1ib29rKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFkZHJlc3MtY2FyZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYWRkcmVzcy1jYXJkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFkanVzdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYWRqdXN0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFkbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYWRuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFkdmVyc2FsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hZHZlcnNhbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hZmZpbGlhdGV0aGVtZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYWZmaWxpYXRldGhlbWUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYWxhcm0tY2xvY2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFsYXJtLWNsb2NrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFsZ29saWE6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFsZ29saWEpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYWxpZ24tY2VudGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbGlnbi1jZW50ZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYWxpZ24tanVzdGlmeTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYWxpZ24tanVzdGlmeSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbGlnbi1sZWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbGlnbi1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFsaWduLXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbGlnbi1yaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbGxlcmdpZXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFsbGVyZ2llcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbWF6b246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFtYXpvbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbWF6b24tcGF5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbWF6b24tcGF5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFtYnVsYW5jZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW1idWxhbmNlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFtZXJpY2FuLXNpZ24tbGFuZ3VhZ2UtaW50ZXJwcmV0aW5nOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbWVyaWNhbi1zaWduLWxhbmd1YWdlLWludGVycHJldGluZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbWlsaWE6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFtaWxpYSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbmNob3I6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFuY2hvcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbmRyb2lkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbmRyb2lkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFuZ2VsbGlzdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW5nZWxsaXN0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFuZ2xlLWRvdWJsZS1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbmdsZS1kb3VibGUtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbmdsZS1kb3VibGUtbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW5nbGUtZG91YmxlLWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYW5nbGUtZG91YmxlLXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbmdsZS1kb3VibGUtcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYW5nbGUtZG91YmxlLXVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbmdsZS1kb3VibGUtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYW5nbGUtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW5nbGUtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbmdsZS1sZWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbmdsZS1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFuZ2xlLXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbmdsZS1yaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbmdsZS11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW5nbGUtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYW5ncnljcmVhdGl2ZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW5ncnljcmVhdGl2ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbmd1bGFyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbmd1bGFyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFwcC1zdG9yZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXBwLXN0b3JlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFwcC1zdG9yZS1pb3M6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFwcC1zdG9yZS1pb3MpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXBwZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFwcGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFwcGxlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcHBsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcHBsZS1wYXk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFwcGxlLXBheSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcmNoaXZlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcmNoaXZlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC1jaXJjbGUtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LWNpcmNsZS1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC1jaXJjbGUtbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LWNpcmNsZS1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC1jaXJjbGUtcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC1jaXJjbGUtcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctYWx0LWNpcmNsZS11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LWNpcmNsZS11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1hbHQtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctYWx0LWZyb20tYm90dG9tOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1hbHQtZnJvbS1ib3R0b20pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctYWx0LWZyb20tbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LWZyb20tbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1hbHQtZnJvbS1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LWZyb20tcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctYWx0LWZyb20tdG9wOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1hbHQtZnJvbS10b3ApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctYWx0LWxlZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LXJpZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC1zcXVhcmUtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LXNxdWFyZS1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC1zcXVhcmUtbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LXNxdWFyZS1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC1zcXVhcmUtcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC1zcXVhcmUtcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctYWx0LXNxdWFyZS11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LXNxdWFyZS11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1hbHQtdG8tYm90dG9tOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1hbHQtdG8tYm90dG9tKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC10by1sZWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1hbHQtdG8tbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1hbHQtdG8tcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC10by1yaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1hbHQtdG8tdG9wOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1hbHQtdG8tdG9wKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWNpcmNsZS1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1jaXJjbGUtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1jaXJjbGUtbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctY2lyY2xlLWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctY2lyY2xlLXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1jaXJjbGUtcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctY2lyY2xlLXVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1jaXJjbGUtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1mcm9tLWJvdHRvbTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctZnJvbS1ib3R0b20pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctZnJvbS1sZWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1mcm9tLWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctZnJvbS1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctZnJvbS1yaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1mcm9tLXRvcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctZnJvbS10b3ApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctc3F1YXJlLWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LXNxdWFyZS1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LXNxdWFyZS1sZWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1zcXVhcmUtbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1zcXVhcmUtcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LXNxdWFyZS1yaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1zcXVhcmUtdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LXNxdWFyZS11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy10by1ib3R0b206YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LXRvLWJvdHRvbSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy10by1sZWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy10by1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LXRvLXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy10by1yaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy10by10b3A6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LXRvLXRvcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3dzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvd3MpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3dzLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3dzLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvd3MtYWx0LWg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93cy1hbHQtaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvd3MtYWx0LXY6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93cy1hbHQtdik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvd3MtaDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3dzLWgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3dzLXY6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93cy12KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFzc2lzdGl2ZS1saXN0ZW5pbmctc3lzdGVtczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXNzaXN0aXZlLWxpc3RlbmluZy1zeXN0ZW1zKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFzdGVyaXNrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hc3Rlcmlzayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hc3ltbWV0cmlrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hc3ltbWV0cmlrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWF0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hdWRpYmxlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hdWRpYmxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWF1ZGlvLWRlc2NyaXB0aW9uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hdWRpby1kZXNjcmlwdGlvbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hdXRvcHJlZml4ZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWF1dG9wcmVmaXhlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hdmlhbmV4OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hdmlhbmV4KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWF2aWF0bzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXZpYXRvKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWF3czpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXdzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJhY2t3YXJkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYWNrd2FyZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYWRnZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmFkZ2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmFkZ2UtY2hlY2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJhZGdlLWNoZWNrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJhbGFuY2Utc2NhbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJhbGFuY2Utc2NhbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmFuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmFuZC1haWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJhbmQtYWlkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJhbmRjYW1wOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYW5kY2FtcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXJjb2RlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYXJjb2RlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJhcmNvZGUtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYXJjb2RlLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXJjb2RlLXJlYWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJhcmNvZGUtcmVhZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXJjb2RlLXNjYW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJhcmNvZGUtc2Nhbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXJzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYXJzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJhc2ViYWxsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYXNlYmFsbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXNlYmFsbC1iYWxsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYXNlYmFsbC1iYWxsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJhc2tldGJhbGwtYmFsbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmFza2V0YmFsbC1iYWxsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJhc2tldGJhbGwtaG9vcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmFza2V0YmFsbC1ob29wKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJhdGg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJhdGgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmF0dGVyeS1ib2x0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYXR0ZXJ5LWJvbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmF0dGVyeS1lbXB0eTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmF0dGVyeS1lbXB0eSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXR0ZXJ5LWZ1bGw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJhdHRlcnktZnVsbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXR0ZXJ5LWhhbGY6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJhdHRlcnktaGFsZik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXR0ZXJ5LXF1YXJ0ZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJhdHRlcnktcXVhcnRlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXR0ZXJ5LXNsYXNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYXR0ZXJ5LXNsYXNoKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJhdHRlcnktdGhyZWUtcXVhcnRlcnM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJhdHRlcnktdGhyZWUtcXVhcnRlcnMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmVkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iZWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmVlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmVlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iZWhhbmNlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iZWhhbmNlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJlaGFuY2Utc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iZWhhbmNlLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iZWxsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iZWxsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJlbGwtc2xhc2g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJlbGwtc2xhc2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmljeWNsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmljeWNsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iaW1vYmplY3Q6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJpbW9iamVjdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iaW5vY3VsYXJzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iaW5vY3VsYXJzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJpcnRoZGF5LWNha2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJpcnRoZGF5LWNha2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYml0YnVja2V0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iaXRidWNrZXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYml0Y29pbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYml0Y29pbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iaXR5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iaXR5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJsYWNrLXRpZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmxhY2stdGllKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJsYWNrYmVycnk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJsYWNrYmVycnkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmxpbmQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJsaW5kKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJsb2dnZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJsb2dnZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmxvZ2dlci1iOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ibG9nZ2VyLWIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmx1ZXRvb3RoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ibHVldG9vdGgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmx1ZXRvb3RoLWI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJsdWV0b290aC1iKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJvbGQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJvbGQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYm9sdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYm9sdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ib21iOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ib21iKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJvb2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJvb2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYm9va21hcms6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJvb2ttYXJrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJvd2xpbmctYmFsbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYm93bGluZy1iYWxsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJvd2xpbmctcGluczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYm93bGluZy1waW5zKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJveDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYm94KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJveC1jaGVjazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYm94LWNoZWNrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJveGVzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ib3hlcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ib3hpbmctZ2xvdmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJveGluZy1nbG92ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1icmFpbGxlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1icmFpbGxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJyaWVmY2FzZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYnJpZWZjYXNlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJyaWVmY2FzZS1tZWRpY2FsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1icmllZmNhc2UtbWVkaWNhbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1icm93c2VyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1icm93c2VyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJ0YzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYnRjKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJ1ZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYnVnKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJ1aWxkaW5nOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1idWlsZGluZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1idWxsaG9ybjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYnVsbGhvcm4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYnVsbHNleWU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJ1bGxzZXllKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJ1cm46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJ1cm4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYnVyb21vYmVsZXhwZXJ0ZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYnVyb21vYmVsZXhwZXJ0ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1idXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJ1cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1idXlzZWxsYWRzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1idXlzZWxsYWRzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhbGN1bGF0b3I6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhbGN1bGF0b3IpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FsZW5kYXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhbGVuZGFyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhbGVuZGFyLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FsZW5kYXItYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhbGVuZGFyLWNoZWNrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYWxlbmRhci1jaGVjayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYWxlbmRhci1lZGl0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYWxlbmRhci1lZGl0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhbGVuZGFyLWV4Y2xhbWF0aW9uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYWxlbmRhci1leGNsYW1hdGlvbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYWxlbmRhci1taW51czpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FsZW5kYXItbWludXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FsZW5kYXItcGx1czpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FsZW5kYXItcGx1cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYWxlbmRhci10aW1lczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FsZW5kYXItdGltZXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FtZXJhOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYW1lcmEpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FtZXJhLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FtZXJhLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYW1lcmEtcmV0cm86YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhbWVyYS1yZXRybyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYXBzdWxlczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2Fwc3VsZXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FyZXQtY2lyY2xlLWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhcmV0LWNpcmNsZS1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhcmV0LWNpcmNsZS1sZWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYXJldC1jaXJjbGUtbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYXJldC1jaXJjbGUtcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhcmV0LWNpcmNsZS1yaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYXJldC1jaXJjbGUtdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhcmV0LWNpcmNsZS11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYXJldC1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYXJldC1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhcmV0LWxlZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhcmV0LWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FyZXQtcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhcmV0LXJpZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhcmV0LXNxdWFyZS1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYXJldC1zcXVhcmUtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYXJldC1zcXVhcmUtbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FyZXQtc3F1YXJlLWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FyZXQtc3F1YXJlLXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYXJldC1zcXVhcmUtcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FyZXQtc3F1YXJlLXVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYXJldC1zcXVhcmUtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FyZXQtdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhcmV0LXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhcnQtYXJyb3ctZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FydC1hcnJvdy1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhcnQtcGx1czpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FydC1wbHVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNjLWFtYXpvbi1wYXk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNjLWFtYXpvbi1wYXkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2MtYW1leDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2MtYW1leCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYy1hcHBsZS1wYXk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNjLWFwcGxlLXBheSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYy1kaW5lcnMtY2x1YjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2MtZGluZXJzLWNsdWIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2MtZGlzY292ZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNjLWRpc2NvdmVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNjLWpjYjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2MtamNiKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNjLW1hc3RlcmNhcmQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNjLW1hc3RlcmNhcmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2MtcGF5cGFsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYy1wYXlwYWwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2Mtc3RyaXBlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYy1zdHJpcGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2MtdmlzYTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2MtdmlzYSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jZW50ZXJjb2RlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jZW50ZXJjb2RlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNlcnRpZmljYXRlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jZXJ0aWZpY2F0ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGFydC1hcmVhOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGFydC1hcmVhKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoYXJ0LWJhcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hhcnQtYmFyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoYXJ0LWxpbmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoYXJ0LWxpbmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hhcnQtcGllOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGFydC1waWUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hlY2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZWNrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZWNrLWNpcmNsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlY2stY2lyY2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZWNrLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlY2stc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXNzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGVzcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGVzcy1iaXNob3A6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXNzLWJpc2hvcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGVzcy1iaXNob3AtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGVzcy1iaXNob3AtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXNzLWJvYXJkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGVzcy1ib2FyZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGVzcy1jbG9jazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3MtY2xvY2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hlc3MtY2xvY2stYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGVzcy1jbG9jay1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hlc3Mta2luZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3Mta2luZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGVzcy1raW5nLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3Mta2luZy1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hlc3Mta25pZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGVzcy1rbmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hlc3Mta25pZ2h0LWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3Mta25pZ2h0LWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGVzcy1wYXduOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGVzcy1wYXduKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXNzLXBhd24tYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGVzcy1wYXduLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGVzcy1xdWVlbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3MtcXVlZW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hlc3MtcXVlZW4tYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGVzcy1xdWVlbi1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hlc3Mtcm9vazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3Mtcm9vayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGVzcy1yb29rLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3Mtcm9vay1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hldnJvbi1jaXJjbGUtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hldnJvbi1jaXJjbGUtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGV2cm9uLWNpcmNsZS1sZWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGV2cm9uLWNpcmNsZS1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXZyb24tY2lyY2xlLXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGV2cm9uLWNpcmNsZS1yaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGV2cm9uLWNpcmNsZS11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hldnJvbi1jaXJjbGUtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hldnJvbi1kb3VibGUtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hldnJvbi1kb3VibGUtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGV2cm9uLWRvdWJsZS1sZWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGV2cm9uLWRvdWJsZS1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXZyb24tZG91YmxlLXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGV2cm9uLWRvdWJsZS1yaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGV2cm9uLWRvdWJsZS11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hldnJvbi1kb3VibGUtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hldnJvbi1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGV2cm9uLWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hldnJvbi1sZWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGV2cm9uLWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hldnJvbi1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hldnJvbi1yaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGV2cm9uLXNxdWFyZS1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGV2cm9uLXNxdWFyZS1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXZyb24tc3F1YXJlLWxlZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXZyb24tc3F1YXJlLWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hldnJvbi1zcXVhcmUtcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXZyb24tc3F1YXJlLXJpZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXZyb24tc3F1YXJlLXVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGV2cm9uLXNxdWFyZS11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGV2cm9uLXVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGV2cm9uLXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoaWxkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGlsZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaHJvbWU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNocm9tZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaXJjbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNpcmNsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaXJjbGUtbm90Y2g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNpcmNsZS1ub3RjaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jbGlwYm9hcmQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNsaXBib2FyZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jbGlwYm9hcmQtY2hlY2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNsaXBib2FyZC1jaGVjayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jbGlwYm9hcmQtbGlzdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2xpcGJvYXJkLWxpc3QpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2xvY2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNsb2NrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNsb25lOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jbG9uZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jbG9zZWQtY2FwdGlvbmluZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2xvc2VkLWNhcHRpb25pbmcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2xvdWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNsb3VkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNsb3VkLWRvd25sb2FkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jbG91ZC1kb3dubG9hZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jbG91ZC1kb3dubG9hZC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNsb3VkLWRvd25sb2FkLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jbG91ZC11cGxvYWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNsb3VkLXVwbG9hZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jbG91ZC11cGxvYWQtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jbG91ZC11cGxvYWQtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNsb3Vkc2NhbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNsb3Vkc2NhbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2xvdWRzbWl0aDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2xvdWRzbWl0aCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jbG91ZHZlcnNpZnk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNsb3VkdmVyc2lmeSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jbHViOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jbHViKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvZGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvZGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29kZS1icmFuY2g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvZGUtYnJhbmNoKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvZGUtY29tbWl0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jb2RlLWNvbW1pdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jb2RlLW1lcmdlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jb2RlLW1lcmdlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvZGVwZW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvZGVwZW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29kaWVwaWU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvZGllcGllKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvZmZlZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29mZmVlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29nKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvZ3M6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvZ3MpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29sdW1uczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29sdW1ucyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jb21tZW50OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jb21tZW50KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvbW1lbnQtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jb21tZW50LWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jb21tZW50czpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29tbWVudHMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29tcGFzczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29tcGFzcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jb21wcmVzczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29tcHJlc3MpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29tcHJlc3MtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jb21wcmVzcy1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29tcHJlc3Mtd2lkZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29tcHJlc3Mtd2lkZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jb25uZWN0ZGV2ZWxvcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29ubmVjdGRldmVsb3ApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29udGFvOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jb250YW8pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29udmV5b3ItYmVsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29udmV5b3ItYmVsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jb252ZXlvci1iZWx0LWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29udmV5b3ItYmVsdC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29weTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29weSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jb3B5cmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvcHlyaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jcGFuZWw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNwYW5lbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jcmVhdGl2ZS1jb21tb25zOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jcmVhdGl2ZS1jb21tb25zKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNyZWRpdC1jYXJkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jcmVkaXQtY2FyZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jcmVkaXQtY2FyZC1ibGFuazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY3JlZGl0LWNhcmQtYmxhbmspOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY3JlZGl0LWNhcmQtZnJvbnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNyZWRpdC1jYXJkLWZyb250KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNyaWNrZXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNyaWNrZXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY3JvcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY3JvcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jcm9zc2hhaXJzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jcm9zc2hhaXJzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNzczM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNzczMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY3NzMy1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNzczMtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWN1YmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWN1YmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY3ViZXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWN1YmVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWN1cmxpbmc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWN1cmxpbmcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY3V0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jdXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY3V0dGxlZmlzaDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY3V0dGxlZmlzaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kLWFuZC1kOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kLWFuZC1kKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRhc2hjdWJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kYXNoY3ViZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kYXRhYmFzZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZGF0YWJhc2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZGVhZjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZGVhZik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kZWxpY2lvdXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRlbGljaW91cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kZXBsb3lkb2c6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRlcGxveWRvZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kZXNrcHJvOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kZXNrcHJvKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRlc2t0b3A6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRlc2t0b3ApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZGVza3RvcC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRlc2t0b3AtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRldmlhbnRhcnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRldmlhbnRhcnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZGlhZ25vc2VzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kaWFnbm9zZXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZGlhbW9uZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZGlhbW9uZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kaWdnOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kaWdnKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRpZ2l0YWwtb2NlYW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRpZ2l0YWwtb2NlYW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZGlzY29yZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZGlzY29yZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kaXNjb3Vyc2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRpc2NvdXJzZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kbmE6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRuYSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kb2NodWI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRvY2h1Yik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kb2NrZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRvY2tlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kb2xsYXItc2lnbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZG9sbGFyLXNpZ24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZG9sbHk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRvbGx5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRvbGx5LWVtcHR5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kb2xseS1lbXB0eSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kb2xseS1mbGF0YmVkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kb2xseS1mbGF0YmVkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRvbGx5LWZsYXRiZWQtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kb2xseS1mbGF0YmVkLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kb2xseS1mbGF0YmVkLWVtcHR5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kb2xseS1mbGF0YmVkLWVtcHR5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRvdC1jaXJjbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRvdC1jaXJjbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZG93bmxvYWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRvd25sb2FkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRyYWZ0MmRpZ2l0YWw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRyYWZ0MmRpZ2l0YWwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZHJpYmJibGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRyaWJiYmxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRyaWJiYmxlLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZHJpYmJibGUtc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRyb3Bib3g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRyb3Bib3gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZHJ1cGFsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kcnVwYWwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZHVtYmJlbGw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWR1bWJiZWxsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWR5YWxvZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZHlhbG9nKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWVhcmx5YmlyZHM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWVhcmx5YmlyZHMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZWRnZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZWRnZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1lZGl0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lZGl0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWVqZWN0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lamVjdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1lbGVtZW50b3I6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWVsZW1lbnRvcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1lbGxpcHNpcy1oOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lbGxpcHNpcy1oKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWVsbGlwc2lzLWgtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lbGxpcHNpcy1oLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1lbGxpcHNpcy12OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lbGxpcHNpcy12KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWVsbGlwc2lzLXYtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lbGxpcHNpcy12LWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1lbWJlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZW1iZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZW1waXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lbXBpcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZW52ZWxvcGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWVudmVsb3BlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWVudmVsb3BlLW9wZW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWVudmVsb3BlLW9wZW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZW52ZWxvcGUtc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lbnZlbG9wZS1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZW52aXJhOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lbnZpcmEpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXJhc2VyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lcmFzZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXJsYW5nOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lcmxhbmcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXRoZXJldW06YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV0aGVyZXVtKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV0c3k6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV0c3kpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXVyby1zaWduOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ldXJvLXNpZ24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXhjaGFuZ2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV4Y2hhbmdlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV4Y2hhbmdlLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXhjaGFuZ2UtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV4Y2xhbWF0aW9uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1leGNsYW1hdGlvbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1leGNsYW1hdGlvbi1jaXJjbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV4Y2xhbWF0aW9uLWNpcmNsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1leGNsYW1hdGlvbi1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV4Y2xhbWF0aW9uLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1leGNsYW1hdGlvbi10cmlhbmdsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXhjbGFtYXRpb24tdHJpYW5nbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXhwYW5kOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1leHBhbmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXhwYW5kLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXhwYW5kLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1leHBhbmQtYXJyb3dzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1leHBhbmQtYXJyb3dzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV4cGFuZC1hcnJvd3MtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1leHBhbmQtYXJyb3dzLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1leHBhbmQtd2lkZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXhwYW5kLXdpZGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXhwZWRpdGVkc3NsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1leHBlZGl0ZWRzc2wpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXh0ZXJuYWwtbGluazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXh0ZXJuYWwtbGluayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1leHRlcm5hbC1saW5rLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXh0ZXJuYWwtbGluay1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXh0ZXJuYWwtbGluay1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV4dGVybmFsLWxpbmstc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV4dGVybmFsLWxpbmstc3F1YXJlLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXh0ZXJuYWwtbGluay1zcXVhcmUtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV5ZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXllKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV5ZS1kcm9wcGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1leWUtZHJvcHBlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1leWUtc2xhc2g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV5ZS1zbGFzaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mYWNlYm9vazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmFjZWJvb2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmFjZWJvb2stZjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmFjZWJvb2stZik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mYWNlYm9vay1tZXNzZW5nZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZhY2Vib29rLW1lc3Nlbmdlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mYWNlYm9vay1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZhY2Vib29rLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mYXN0LWJhY2t3YXJkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mYXN0LWJhY2t3YXJkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZhc3QtZm9yd2FyZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmFzdC1mb3J3YXJkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZheDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmF4KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZlbWFsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmVtYWxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpZWxkLWhvY2tleTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmllbGQtaG9ja2V5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpZ2h0ZXItamV0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWdodGVyLWpldCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWxlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpbGUtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWxlLWFyY2hpdmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpbGUtYXJjaGl2ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWxlLWF1ZGlvOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLWF1ZGlvKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpbGUtY2hlY2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpbGUtY2hlY2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsZS1jb2RlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLWNvZGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsZS1lZGl0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLWVkaXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsZS1leGNlbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsZS1leGNlbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWxlLWV4Y2xhbWF0aW9uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLWV4Y2xhbWF0aW9uKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpbGUtaW1hZ2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpbGUtaW1hZ2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsZS1tZWRpY2FsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLW1lZGljYWwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsZS1tZWRpY2FsLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsZS1tZWRpY2FsLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWxlLW1pbnVzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLW1pbnVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpbGUtcGRmOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLXBkZik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWxlLXBsdXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpbGUtcGx1cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWxlLXBvd2VycG9pbnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpbGUtcG93ZXJwb2ludCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWxlLXRpbWVzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLXRpbWVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpbGUtdmlkZW86YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpbGUtdmlkZW8pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsZS13b3JkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLXdvcmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsbTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsbSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWxtLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsbS1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsdGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWx0ZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maXJlLWV4dGluZ3Vpc2hlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlyZS1leHRpbmd1aXNoZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlyZWZveDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlyZWZveCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maXJzdC1haWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpcnN0LWFpZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maXJzdC1vcmRlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlyc3Qtb3JkZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlyc3RkcmFmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlyc3RkcmFmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mbGFnOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mbGFnKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZsYWctY2hlY2tlcmVkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mbGFnLWNoZWNrZXJlZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mbGFzazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmxhc2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmxpY2tyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mbGlja3IpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmxpcGJvYXJkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mbGlwYm9hcmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmx5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mbHkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm9sZGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mb2xkZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm9sZGVyLW9wZW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZvbGRlci1vcGVuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZvbnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZvbnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm9udC1hd2Vzb21lOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mb250LWF3ZXNvbWUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm9udC1hd2Vzb21lLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZm9udC1hd2Vzb21lLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mb250LWF3ZXNvbWUtZmxhZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZm9udC1hd2Vzb21lLWZsYWcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm9udGljb25zOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mb250aWNvbnMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm9udGljb25zLWZpOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mb250aWNvbnMtZmkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm9vdGJhbGwtYmFsbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZm9vdGJhbGwtYmFsbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mb290YmFsbC1oZWxtZXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZvb3RiYWxsLWhlbG1ldCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mb3JrbGlmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZm9ya2xpZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm9ydC1hd2Vzb21lOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mb3J0LWF3ZXNvbWUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm9ydC1hd2Vzb21lLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZm9ydC1hd2Vzb21lLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mb3J1bWJlZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZm9ydW1iZWUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm9yd2FyZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZm9yd2FyZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mb3Vyc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mb3Vyc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZyZWUtY29kZS1jYW1wOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mcmVlLWNvZGUtY2FtcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mcmVlYnNkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mcmVlYnNkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZyb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mcm93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mdXRib2w6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZ1dGJvbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1nYW1lcGFkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1nYW1lcGFkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdhdmVsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1nYXZlbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1nZW06YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdlbSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1nZW5kZXJsZXNzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1nZW5kZXJsZXNzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdldC1wb2NrZXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdldC1wb2NrZXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2c6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdnKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdnLWNpcmNsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ2ctY2lyY2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdpZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdpZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2l0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1naXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2l0LXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ2l0LXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1naXRodWI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdpdGh1Yik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1naXRodWItYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1naXRodWItYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdpdGh1Yi1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdpdGh1Yi1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2l0a3Jha2VuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1naXRrcmFrZW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2l0bGFiOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1naXRsYWIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2l0dGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1naXR0ZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2xhc3MtbWFydGluaTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ2xhc3MtbWFydGluaSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1nbGlkZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ2xpZGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2xpZGUtZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ2xpZGUtZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1nbG9iZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ2xvYmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ29mb3JlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1nb2ZvcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ29sZi1iYWxsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1nb2xmLWJhbGwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ29sZi1jbHViOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1nb2xmLWNsdWIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ29vZHJlYWRzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1nb29kcmVhZHMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ29vZHJlYWRzLWc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdvb2RyZWFkcy1nKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdvb2dsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ29vZ2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdvb2dsZS1kcml2ZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ29vZ2xlLWRyaXZlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdvb2dsZS1wbGF5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1nb29nbGUtcGxheSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1nb29nbGUtcGx1czpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ29vZ2xlLXBsdXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ29vZ2xlLXBsdXMtZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ29vZ2xlLXBsdXMtZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1nb29nbGUtcGx1cy1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdvb2dsZS1wbHVzLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1nb29nbGUtd2FsbGV0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1nb29nbGUtd2FsbGV0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdyYWR1YXRpb24tY2FwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ncmFkdWF0aW9uLWNhcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ncmF0aXBheTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ3JhdGlwYXkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ3JhdjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ3Jhdik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ncmlwZmlyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ3JpcGZpcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ3J1bnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdydW50KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWd1bHA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWd1bHApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taC1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWgtc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWgxOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oMSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oMjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaDIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taDM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWgzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhhY2tlci1uZXdzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oYWNrZXItbmV3cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oYWNrZXItbmV3cy1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhhY2tlci1uZXdzLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oYW5kLWhvbGRpbmctYm94OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oYW5kLWhvbGRpbmctYm94KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhhbmQtbGl6YXJkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oYW5kLWxpemFyZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oYW5kLXBhcGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oYW5kLXBhcGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhhbmQtcGVhY2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhhbmQtcGVhY2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGFuZC1wb2ludC1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oYW5kLXBvaW50LWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGFuZC1wb2ludC1sZWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oYW5kLXBvaW50LWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGFuZC1wb2ludC1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGFuZC1wb2ludC1yaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oYW5kLXBvaW50LXVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oYW5kLXBvaW50LXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhhbmQtcG9pbnRlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGFuZC1wb2ludGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhhbmQtcmVjZWl2aW5nOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oYW5kLXJlY2VpdmluZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oYW5kLXJvY2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhhbmQtcm9jayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oYW5kLXNjaXNzb3JzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oYW5kLXNjaXNzb3JzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhhbmQtc3BvY2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhhbmQtc3BvY2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGFuZHNoYWtlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oYW5kc2hha2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGFzaHRhZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGFzaHRhZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oZGQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhkZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oZWFkaW5nOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oZWFkaW5nKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhlYWRwaG9uZXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhlYWRwaG9uZXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGVhcnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhlYXJ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhlYXJ0YmVhdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGVhcnRiZWF0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhleGFnb246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhleGFnb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGlwczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGlwcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oaXJlLWEtaGVscGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oaXJlLWEtaGVscGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhpc3Rvcnk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhpc3RvcnkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taG9ja2V5LXB1Y2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhvY2tleS1wdWNrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhvY2tleS1zdGlja3M6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhvY2tleS1zdGlja3MpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taG9tZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaG9tZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ob29saTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaG9vbGkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taG9zcGl0YWw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhvc3BpdGFsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhvc3BpdGFsLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaG9zcGl0YWwtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhvc3BpdGFsLXN5bWJvbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaG9zcGl0YWwtc3ltYm9sKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhvdGphcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaG90amFyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhvdXJnbGFzczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaG91cmdsYXNzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhvdXJnbGFzcy1lbmQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhvdXJnbGFzcy1lbmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taG91cmdsYXNzLWhhbGY6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhvdXJnbGFzcy1oYWxmKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhvdXJnbGFzcy1zdGFydDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaG91cmdsYXNzLXN0YXJ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhvdXp6OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ob3V6eik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1odG1sNTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaHRtbDUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taHVic3BvdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaHVic3BvdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pLWN1cnNvcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaS1jdXJzb3IpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taWQtYmFkZ2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWlkLWJhZGdlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWlkLWNhcmQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWlkLWNhcmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taWQtY2FyZC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWlkLWNhcmQtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWltYWdlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pbWFnZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pbWFnZXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWltYWdlcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pbWRiOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pbWRiKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWluYm94OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pbmJveCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pbmJveC1pbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaW5ib3gtaW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taW5ib3gtb3V0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pbmJveC1vdXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taW5kZW50OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pbmRlbnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taW5kdXN0cnk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWluZHVzdHJ5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWluZHVzdHJ5LWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaW5kdXN0cnktYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWluZm86YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWluZm8pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taW5mby1jaXJjbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWluZm8tY2lyY2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWluZm8tc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pbmZvLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pbnN0YWdyYW06YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWluc3RhZ3JhbSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pbnRlcm5ldC1leHBsb3JlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaW50ZXJuZXQtZXhwbG9yZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taW52ZW50b3J5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pbnZlbnRvcnkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taW94aG9zdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaW94aG9zdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pdGFsaWM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWl0YWxpYyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pdHVuZXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWl0dW5lcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pdHVuZXMtbm90ZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaXR1bmVzLW5vdGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tamFjay1vLWxhbnRlcm46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWphY2stby1sYW50ZXJuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWplbmtpbnM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWplbmtpbnMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tam9nZXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWpvZ2V0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWpvb21sYTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItam9vbWxhKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWpzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1qcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1qcy1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWpzLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1qc2ZpZGRsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItanNmaWRkbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0ta2V5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1rZXkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0ta2V5Ym9hcmQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWtleWJvYXJkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWtleWNkbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXIta2V5Y2RuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWtpY2tzdGFydGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1raWNrc3RhcnRlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1raWNrc3RhcnRlci1rOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1raWNrc3RhcnRlci1rKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWtvcnZ1ZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXIta29ydnVlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxhbmd1YWdlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sYW5ndWFnZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sYXB0b3A6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxhcHRvcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sYXJhdmVsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sYXJhdmVsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxhc3RmbTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGFzdGZtKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxhc3RmbS1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxhc3RmbS1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGVhZjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGVhZik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sZWFucHViOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sZWFucHViKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxlbW9uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sZW1vbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sZXNzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sZXNzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxldmVsLWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxldmVsLWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGV2ZWwtZG93bi1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxldmVsLWRvd24tYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxldmVsLXVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sZXZlbC11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sZXZlbC11cC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxldmVsLXVwLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1saWZlLXJpbmc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxpZmUtcmluZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1saWdodGJ1bGI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxpZ2h0YnVsYik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1saW5lOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1saW5lKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxpbms6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxpbmspOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGlua2VkaW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxpbmtlZGluKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxpbmtlZGluLWluOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1saW5rZWRpbi1pbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1saW5vZGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxpbm9kZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1saW51eDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGludXgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGlyYS1zaWduOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1saXJhLXNpZ24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGlzdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGlzdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1saXN0LWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGlzdC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGlzdC1vbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGlzdC1vbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1saXN0LXVsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1saXN0LXVsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxvY2F0aW9uLWFycm93OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sb2NhdGlvbi1hcnJvdyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sb2NrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sb2NrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxvY2stYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sb2NrLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sb2NrLW9wZW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxvY2stb3Blbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sb2NrLW9wZW4tYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sb2NrLW9wZW4tYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxvbmctYXJyb3ctYWx0LWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxvbmctYXJyb3ctYWx0LWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbG9uZy1hcnJvdy1hbHQtbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbG9uZy1hcnJvdy1hbHQtbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sb25nLWFycm93LWFsdC1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbG9uZy1hcnJvdy1hbHQtcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbG9uZy1hcnJvdy1hbHQtdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxvbmctYXJyb3ctYWx0LXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxvbmctYXJyb3ctZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbG9uZy1hcnJvdy1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxvbmctYXJyb3ctbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbG9uZy1hcnJvdy1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxvbmctYXJyb3ctcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxvbmctYXJyb3ctcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbG9uZy1hcnJvdy11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbG9uZy1hcnJvdy11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sb3ctdmlzaW9uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sb3ctdmlzaW9uKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWx1Y2hhZG9yOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sdWNoYWRvcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1seWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1seWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1hZ2VudG86YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1hZ2VudG8pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWFnaWM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1hZ2ljKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1hZ25ldDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWFnbmV0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1hbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1hbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWFwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tYXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWFwLW1hcmtlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWFwLW1hcmtlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tYXAtbWFya2VyLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWFwLW1hcmtlci1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWFwLXBpbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWFwLXBpbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tYXAtc2lnbnM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1hcC1zaWducyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tYXJzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tYXJzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1hcnMtZG91YmxlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tYXJzLWRvdWJsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tYXJzLXN0cm9rZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWFycy1zdHJva2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWFycy1zdHJva2UtaDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWFycy1zdHJva2UtaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tYXJzLXN0cm9rZS12OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tYXJzLXN0cm9rZS12KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1heGNkbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWF4Y2RuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1lZGFwcHM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1lZGFwcHMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWVkaXVtOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tZWRpdW0pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWVkaXVtLW06YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1lZGl1bS1tKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1lZGtpdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWVka2l0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1lZHJ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tZWRydCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tZWV0dXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1lZXR1cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tZWg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1laCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tZXJjdXJ5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tZXJjdXJ5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1pY3JvY2hpcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWljcm9jaGlwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1pY3JvcGhvbmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1pY3JvcGhvbmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWljcm9waG9uZS1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1pY3JvcGhvbmUtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1pY3JvcGhvbmUtc2xhc2g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1pY3JvcGhvbmUtc2xhc2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWljcm9zb2Z0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1taWNyb3NvZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWludXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1pbnVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1pbnVzLWNpcmNsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWludXMtY2lyY2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1pbnVzLWhleGFnb246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1pbnVzLWhleGFnb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWludXMtb2N0YWdvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWludXMtb2N0YWdvbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1taW51cy1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1pbnVzLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1taXg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1peCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1taXhjbG91ZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWl4Y2xvdWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWl6dW5pOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1taXp1bmkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbW9iaWxlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tb2JpbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbW9iaWxlLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbW9iaWxlLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tb2JpbGUtYW5kcm9pZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbW9iaWxlLWFuZHJvaWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbW9iaWxlLWFuZHJvaWQtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tb2JpbGUtYW5kcm9pZC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbW9keDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbW9keCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tb25lcm86YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1vbmVybyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tb25leS1iaWxsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tb25leS1iaWxsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1vbmV5LWJpbGwtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tb25leS1iaWxsLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tb29uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tb29uKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1vdG9yY3ljbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1vdG9yY3ljbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbW91c2UtcG9pbnRlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbW91c2UtcG9pbnRlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tdXNpYzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbXVzaWMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbmFwc3RlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbmFwc3Rlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1uZXV0ZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW5ldXRlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1uZXdzcGFwZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW5ld3NwYXBlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1uaW50ZW5kby1zd2l0Y2g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW5pbnRlbmRvLXN3aXRjaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ub2RlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ub2RlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW5vZGUtanM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW5vZGUtanMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbm90ZXMtbWVkaWNhbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbm90ZXMtbWVkaWNhbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ucG06YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW5wbSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1uczg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW5zOCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1udXRyaXRpb25peDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbnV0cml0aW9uaXgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tb2JqZWN0LWdyb3VwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1vYmplY3QtZ3JvdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tb2JqZWN0LXVuZ3JvdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW9iamVjdC11bmdyb3VwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW9jdGFnb246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW9jdGFnb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tb2Rub2tsYXNzbmlraTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItb2Rub2tsYXNzbmlraSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1vZG5va2xhc3NuaWtpLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItb2Rub2tsYXNzbmlraS1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tb3BlbmNhcnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW9wZW5jYXJ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW9wZW5pZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItb3BlbmlkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW9wZXJhOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1vcGVyYSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1vcHRpbi1tb25zdGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1vcHRpbi1tb25zdGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW9zaTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItb3NpKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW91dGRlbnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW91dGRlbnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGFnZTQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBhZ2U0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBhZ2VsaW5lczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGFnZWxpbmVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBhaW50LWJydXNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wYWludC1icnVzaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wYWxmZWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBhbGZlZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wYWxsZXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBhbGxldCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wYWxsZXQtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wYWxsZXQtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBhcGVyLXBsYW5lOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wYXBlci1wbGFuZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wYXBlcmNsaXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBhcGVyY2xpcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wYXJhZ3JhcGg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBhcmFncmFwaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wYXN0ZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGFzdGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGF0cmVvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGF0cmVvbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wYXVzZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGF1c2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGF1c2UtY2lyY2xlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wYXVzZS1jaXJjbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGF3OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wYXcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGF5cGFsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wYXlwYWwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGVuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wZW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGVuLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGVuLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wZW4tc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wZW4tc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBlbmNpbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGVuY2lsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBlbmNpbC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBlbmNpbC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGVubmFudDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGVubmFudCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wZXJjZW50OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wZXJjZW50KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBlcmlzY29wZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGVyaXNjb3BlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBoYWJyaWNhdG9yOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1waGFicmljYXRvcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1waG9lbml4LWZyYW1ld29yazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGhvZW5peC1mcmFtZXdvcmspOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGhvbmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBob25lKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBob25lLXNsYXNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1waG9uZS1zbGFzaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1waG9uZS1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBob25lLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1waG9uZS12b2x1bWU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBob25lLXZvbHVtZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1waHA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBocCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1waWVkLXBpcGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1waWVkLXBpcGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBpZWQtcGlwZXItYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1waWVkLXBpcGVyLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1waWVkLXBpcGVyLXBwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1waWVkLXBpcGVyLXBwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBpbGxzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1waWxscyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1waW50ZXJlc3Q6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBpbnRlcmVzdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1waW50ZXJlc3QtcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGludGVyZXN0LXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGludGVyZXN0LXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGludGVyZXN0LXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wbGFuZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGxhbmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGxhbmUtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wbGFuZS1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGxheTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGxheSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wbGF5LWNpcmNsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGxheS1jaXJjbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGxheXN0YXRpb246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBsYXlzdGF0aW9uKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBsdWc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBsdWcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGx1czpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGx1cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wbHVzLWNpcmNsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGx1cy1jaXJjbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGx1cy1oZXhhZ29uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wbHVzLWhleGFnb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGx1cy1vY3RhZ29uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wbHVzLW9jdGFnb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGx1cy1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBsdXMtc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBvZGNhc3Q6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBvZGNhc3QpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcG9vOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wb28pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcG9ydHJhaXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBvcnRyYWl0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBvdW5kLXNpZ246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBvdW5kLXNpZ24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcG93ZXItb2ZmOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wb3dlci1vZmYpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcHJlc2NyaXB0aW9uLWJvdHRsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcHJlc2NyaXB0aW9uLWJvdHRsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wcmVzY3JpcHRpb24tYm90dGxlLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcHJlc2NyaXB0aW9uLWJvdHRsZS1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcHJpbnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXByaW50KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXByb2NlZHVyZXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXByb2NlZHVyZXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcHJvZHVjdC1odW50OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wcm9kdWN0LWh1bnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcHVzaGVkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wdXNoZWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcHV6emxlLXBpZWNlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wdXp6bGUtcGllY2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcHl0aG9uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1weXRob24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcXE6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXFxKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXFyY29kZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcXJjb2RlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXF1ZXN0aW9uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1xdWVzdGlvbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1xdWVzdGlvbi1jaXJjbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXF1ZXN0aW9uLWNpcmNsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1xdWVzdGlvbi1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXF1ZXN0aW9uLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1xdWlkZGl0Y2g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXF1aWRkaXRjaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1xdWluc2NhcGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXF1aW5zY2FwZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1xdW9yYTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcXVvcmEpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcXVvdGUtbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcXVvdGUtbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1xdW90ZS1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcXVvdGUtcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmFjcXVldDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmFjcXVldCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yYW5kb206YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJhbmRvbSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yYXZlbHJ5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yYXZlbHJ5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJlYWN0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZWFjdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZWJlbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmViZWwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVjdGFuZ2xlLWxhbmRzY2FwZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmVjdGFuZ2xlLWxhbmRzY2FwZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZWN0YW5nbGUtcG9ydHJhaXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlY3RhbmdsZS1wb3J0cmFpdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZWN0YW5nbGUtd2lkZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmVjdGFuZ2xlLXdpZGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVjeWNsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmVjeWNsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZWQtcml2ZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlZC1yaXZlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZWRkaXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlZGRpdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZWRkaXQtYWxpZW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlZGRpdC1hbGllbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZWRkaXQtc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZWRkaXQtc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJlZG86YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlZG8pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVkby1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlZG8tYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJlZ2lzdGVyZWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlZ2lzdGVyZWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVuZGFjdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmVuZGFjdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZW5yZW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlbnJlbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZXBlYXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlcGVhdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZXBlYXQtMTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmVwZWF0LTEpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVwZWF0LTEtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZXBlYXQtMS1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVwZWF0LWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmVwZWF0LWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZXBseTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmVwbHkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVwbHktYWxsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZXBseS1hbGwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVwbHlkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZXBseWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVzb2x2aW5nOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZXNvbHZpbmcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmV0d2VldDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmV0d2VldCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZXR3ZWV0LWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmV0d2VldC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcm9hZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcm9hZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yb2NrZXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJvY2tldCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yb2NrZXRjaGF0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yb2NrZXRjaGF0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJvY2tybXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJvY2tybXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcnNzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yc3MpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcnNzLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcnNzLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ydWJsZS1zaWduOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ydWJsZS1zaWduKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJ1cGVlLXNpZ246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJ1cGVlLXNpZ24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2FmYXJpOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zYWZhcmkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2FzczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2Fzcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zYXZlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zYXZlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNjYW5uZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNjYW5uZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2Nhbm5lci1rZXlib2FyZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2Nhbm5lci1rZXlib2FyZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zY2FubmVyLXRvdWNoc2NyZWVuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zY2FubmVyLXRvdWNoc2NyZWVuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNjaGxpeDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2NobGl4KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNjcmliZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2NyaWJkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNjcnViYmVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zY3J1YmJlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zZWFyY2g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNlYXJjaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zZWFyY2gtbWludXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNlYXJjaC1taW51cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zZWFyY2gtcGx1czpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2VhcmNoLXBsdXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2VhcmNoZW5naW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNlYXJjaGVuZ2luKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNlbGxjYXN0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zZWxsY2FzdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zZWxsc3k6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNlbGxzeSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zZXJ2ZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNlcnZlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zZXJ2aWNlc3RhY2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNlcnZpY2VzdGFjayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaGFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2hhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2hhcmUtYWxsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaGFyZS1hbGwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2hhcmUtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaGFyZS1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2hhcmUtYWx0LXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2hhcmUtYWx0LXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaGFyZS1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNoYXJlLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaGVrZWwtc2lnbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2hla2VsLXNpZ24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2hpZWxkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaGllbGQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2hpZWxkLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2hpZWxkLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaGllbGQtY2hlY2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNoaWVsZC1jaGVjayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaGlwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaGlwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNoaXBwaW5nLWZhc3Q6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNoaXBwaW5nLWZhc3QpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2hpcHBpbmctdGltZWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNoaXBwaW5nLXRpbWVkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNoaXJ0c2luYnVsazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2hpcnRzaW5idWxrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNob3BwaW5nLWJhZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2hvcHBpbmctYmFnKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNob3BwaW5nLWJhc2tldDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2hvcHBpbmctYmFza2V0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNob3BwaW5nLWNhcnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNob3BwaW5nLWNhcnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2hvd2VyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaG93ZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2h1dHRsZWNvY2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNodXR0bGVjb2NrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNpZ24taW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNpZ24taW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2lnbi1pbi1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNpZ24taW4tYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNpZ24tbGFuZ3VhZ2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNpZ24tbGFuZ3VhZ2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2lnbi1vdXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNpZ24tb3V0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNpZ24tb3V0LWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2lnbi1vdXQtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNpZ25hbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2lnbmFsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNpbXBseWJ1aWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaW1wbHlidWlsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaXN0cml4OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaXN0cml4KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNpdGVtYXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNpdGVtYXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2t5YXRsYXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNreWF0bGFzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNreXBlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1za3lwZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zbGFjazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2xhY2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2xhY2staGFzaDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2xhY2staGFzaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zbGlkZXJzLWg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNsaWRlcnMtaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zbGlkZXJzLWgtc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zbGlkZXJzLWgtc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNsaWRlcnMtdjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2xpZGVycy12KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNsaWRlcnMtdi1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNsaWRlcnMtdi1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2xpZGVzaGFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2xpZGVzaGFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zbWlsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc21pbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc21va2luZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc21va2luZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zbmFwY2hhdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc25hcGNoYXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc25hcGNoYXQtZ2hvc3Q6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNuYXBjaGF0LWdob3N0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNuYXBjaGF0LXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc25hcGNoYXQtc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNub3dmbGFrZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc25vd2ZsYWtlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNvcnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNvcnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc29ydC1hbHBoYS1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zb3J0LWFscGhhLWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc29ydC1hbHBoYS11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc29ydC1hbHBoYS11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zb3J0LWFtb3VudC1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zb3J0LWFtb3VudC1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNvcnQtYW1vdW50LXVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zb3J0LWFtb3VudC11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zb3J0LWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNvcnQtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zb3J0LW51bWVyaWMtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc29ydC1udW1lcmljLWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc29ydC1udW1lcmljLXVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zb3J0LW51bWVyaWMtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc29ydC11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc29ydC11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zb3VuZGNsb3VkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zb3VuZGNsb3VkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNwYWNlLXNodXR0bGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNwYWNlLXNodXR0bGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3BhZGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNwYWRlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNwZWFrYXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNwZWFrYXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3Bpbm5lcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3Bpbm5lcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zcGlubmVyLXRoaXJkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zcGlubmVyLXRoaXJkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNwb3RpZnk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNwb3RpZnkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3F1YXJlLWZ1bGw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNxdWFyZS1mdWxsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0YWNrLWV4Y2hhbmdlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdGFjay1leGNoYW5nZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdGFjay1vdmVyZmxvdzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3RhY2stb3ZlcmZsb3cpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3RhcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3Rhcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdGFyLWV4Y2xhbWF0aW9uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdGFyLWV4Y2xhbWF0aW9uKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0YXItaGFsZjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3Rhci1oYWxmKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0YXlsaW5rZWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0YXlsaW5rZWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3RlYW06YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0ZWFtKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0ZWFtLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3RlYW0tc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0ZWFtLXN5bWJvbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3RlYW0tc3ltYm9sKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0ZXAtYmFja3dhcmQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0ZXAtYmFja3dhcmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3RlcC1mb3J3YXJkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdGVwLWZvcndhcmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3RldGhvc2NvcGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0ZXRob3Njb3BlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0aWNrZXItbXVsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3RpY2tlci1tdWxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0aWNreS1ub3RlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdGlja3ktbm90ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdG9wOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdG9wKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0b3AtY2lyY2xlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdG9wLWNpcmNsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdG9wd2F0Y2g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0b3B3YXRjaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdHJhdmE6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0cmF2YSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdHJlZXQtdmlldzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3RyZWV0LXZpZXcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3RyaWtldGhyb3VnaDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3RyaWtldGhyb3VnaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdHJpcGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0cmlwZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdHJpcGUtczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3RyaXBlLXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3R1ZGlvdmluYXJpOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdHVkaW92aW5hcmkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3R1bWJsZXVwb246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0dW1ibGV1cG9uKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0dW1ibGV1cG9uLWNpcmNsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3R1bWJsZXVwb24tY2lyY2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN1YnNjcmlwdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3Vic2NyaXB0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN1YndheTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3Vid2F5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN1aXRjYXNlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdWl0Y2FzZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN1bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdXBlcnBvd2VyczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3VwZXJwb3dlcnMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3VwZXJzY3JpcHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN1cGVyc2NyaXB0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN1cHBsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3VwcGxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN5bmM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN5bmMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3luYy1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN5bmMtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN5cmluZ2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN5cmluZ2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGFibGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRhYmxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRhYmxlLXRlbm5pczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGFibGUtdGVubmlzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRhYmxldDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGFibGV0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRhYmxldC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRhYmxldC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGFibGV0LWFuZHJvaWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRhYmxldC1hbmRyb2lkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRhYmxldC1hbmRyb2lkLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGFibGV0LWFuZHJvaWQtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRhYmxldC1ydWdnZWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRhYmxldC1ydWdnZWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGFibGV0czpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGFibGV0cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10YWNob21ldGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10YWNob21ldGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRhY2hvbWV0ZXItYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10YWNob21ldGVyLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10YWc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRhZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10YWdzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10YWdzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRhc2tzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10YXNrcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10YXhpOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10YXhpKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRlbGVncmFtOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10ZWxlZ3JhbSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10ZWxlZ3JhbS1wbGFuZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGVsZWdyYW0tcGxhbmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGVuY2VudC13ZWlibzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGVuY2VudC13ZWlibyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10ZW5uaXMtYmFsbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGVubmlzLWJhbGwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGVybWluYWw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRlcm1pbmFsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRleHQtaGVpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10ZXh0LWhlaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10ZXh0LXdpZHRoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10ZXh0LXdpZHRoKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10aCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10aC1sYXJnZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGgtbGFyZ2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGgtbGlzdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGgtbGlzdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10aGVtZWlzbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRoZW1laXNsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10aGVybW9tZXRlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGhlcm1vbWV0ZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGhlcm1vbWV0ZXItZW1wdHk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRoZXJtb21ldGVyLWVtcHR5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRoZXJtb21ldGVyLWZ1bGw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRoZXJtb21ldGVyLWZ1bGwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGhlcm1vbWV0ZXItaGFsZjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGhlcm1vbWV0ZXItaGFsZik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10aGVybW9tZXRlci1xdWFydGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10aGVybW9tZXRlci1xdWFydGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRoZXJtb21ldGVyLXRocmVlLXF1YXJ0ZXJzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10aGVybW9tZXRlci10aHJlZS1xdWFydGVycyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10aHVtYnMtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGh1bWJzLWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGh1bWJzLXVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10aHVtYnMtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGh1bWJ0YWNrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10aHVtYnRhY2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGlja2V0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10aWNrZXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGlja2V0LWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGlja2V0LWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10aW1lczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGltZXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGltZXMtY2lyY2xlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10aW1lcy1jaXJjbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGltZXMtaGV4YWdvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGltZXMtaGV4YWdvbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10aW1lcy1vY3RhZ29uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10aW1lcy1vY3RhZ29uKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRpbWVzLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGltZXMtc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRpbnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRpbnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdG9nZ2xlLW9mZjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdG9nZ2xlLW9mZik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10b2dnbGUtb246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRvZ2dsZS1vbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10cmFkZW1hcms6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRyYWRlbWFyayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10cmFpbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdHJhaW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdHJhbnNnZW5kZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRyYW5zZ2VuZGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRyYW5zZ2VuZGVyLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdHJhbnNnZW5kZXItYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRyYXNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10cmFzaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10cmFzaC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRyYXNoLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10cmVlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10cmVlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRyZWUtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10cmVlLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10cmVsbG86YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRyZWxsbyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10cmlhbmdsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdHJpYW5nbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdHJpcGFkdmlzb3I6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRyaXBhZHZpc29yKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRyb3BoeTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdHJvcGh5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRyb3BoeS1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRyb3BoeS1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdHJ1Y2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRydWNrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXR0eTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdHR5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXR1bWJscjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdHVtYmxyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXR1bWJsci1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXR1bWJsci1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdHY6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXR2KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXR2LXJldHJvOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10di1yZXRybyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10d2l0Y2g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXR3aXRjaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10d2l0dGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10d2l0dGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXR3aXR0ZXItc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10d2l0dGVyLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10eXBvMzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdHlwbzMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdWJlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdWJlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11aWtpdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdWlraXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdW1icmVsbGE6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVtYnJlbGxhKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVuZGVybGluZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdW5kZXJsaW5lKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVuZG86YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVuZG8pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdW5kby1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVuZG8tYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVuaXJlZ2lzdHJ5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11bmlyZWdpc3RyeSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11bml2ZXJzYWwtYWNjZXNzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11bml2ZXJzYWwtYWNjZXNzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVuaXZlcnNpdHk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVuaXZlcnNpdHkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdW5saW5rOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11bmxpbmspOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdW5sb2NrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11bmxvY2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdW5sb2NrLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdW5sb2NrLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11bnRhcHBkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11bnRhcHBkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVwbG9hZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdXBsb2FkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVzYjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdXNiKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVzZC1jaXJjbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVzZC1jaXJjbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdXNkLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdXNkLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11c2VyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11c2VyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVzZXItYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11c2VyLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11c2VyLWNpcmNsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdXNlci1jaXJjbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdXNlci1tZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdXNlci1tZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11c2VyLXBsdXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVzZXItcGx1cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11c2VyLXNlY3JldDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdXNlci1zZWNyZXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdXNlci10aW1lczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdXNlci10aW1lcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11c2VyczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdXNlcnMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdXNzdW5uYWg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVzc3VubmFoKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXV0ZW5zaWwtZm9yazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdXRlbnNpbC1mb3JrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXV0ZW5zaWwta25pZmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXV0ZW5zaWwta25pZmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdXRlbnNpbC1zcG9vbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdXRlbnNpbC1zcG9vbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11dGVuc2lsczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdXRlbnNpbHMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdXRlbnNpbHMtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11dGVuc2lscy1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdmFhZGluOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12YWFkaW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdmVudXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZlbnVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZlbnVzLWRvdWJsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdmVudXMtZG91YmxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZlbnVzLW1hcnM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZlbnVzLW1hcnMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdmlhY29pbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdmlhY29pbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS12aWFkZW86YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZpYWRlbyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS12aWFkZW8tc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12aWFkZW8tc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZpYWw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZpYWwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdmlhbHM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZpYWxzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZpYmVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12aWJlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS12aWRlbzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdmlkZW8pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdmltZW86YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZpbWVvKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZpbWVvLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdmltZW8tc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZpbWVvLXY6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZpbWVvLXYpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdmluZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdmluZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS12azpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdmspOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdm52OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12bnYpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdm9sbGV5YmFsbC1iYWxsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12b2xsZXliYWxsLWJhbGwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdm9sdW1lLWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZvbHVtZS1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZvbHVtZS1tdXRlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12b2x1bWUtbXV0ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS12b2x1bWUtb2ZmOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12b2x1bWUtb2ZmKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZvbHVtZS11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdm9sdW1lLXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZ1ZWpzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12dWVqcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13YXJlaG91c2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdhcmVob3VzZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13YXJlaG91c2UtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13YXJlaG91c2UtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdhdGNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13YXRjaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13ZWlibzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd2VpYm8pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2VpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13ZWlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2VpeGluOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13ZWl4aW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2hhdHNhcHA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdoYXRzYXBwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdoYXRzYXBwLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd2hhdHNhcHAtc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdoZWVsY2hhaXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdoZWVsY2hhaXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2hpc3RsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd2hpc3RsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13aG1jczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd2htY3MpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2lmaTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd2lmaSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13aWtpcGVkaWEtdzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd2lraXBlZGlhLXcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2luZG93OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13aW5kb3cpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2luZG93LWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd2luZG93LWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13aW5kb3ctY2xvc2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdpbmRvdy1jbG9zZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13aW5kb3ctbWF4aW1pemU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdpbmRvdy1tYXhpbWl6ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13aW5kb3ctbWluaW1pemU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdpbmRvdy1taW5pbWl6ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13aW5kb3ctcmVzdG9yZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd2luZG93LXJlc3RvcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2luZG93czpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd2luZG93cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13b24tc2lnbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd29uLXNpZ24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td29yZHByZXNzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13b3JkcHJlc3MpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td29yZHByZXNzLXNpbXBsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd29yZHByZXNzLXNpbXBsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13cGJlZ2lubmVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13cGJlZ2lubmVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdwZXhwbG9yZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdwZXhwbG9yZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td3Bmb3JtczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd3Bmb3Jtcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13cmVuY2g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdyZW5jaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS14LXJheTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXIteC1yYXkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0teGJveDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXIteGJveCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS14aW5nOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci14aW5nKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXhpbmctc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci14aW5nLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS15LWNvbWJpbmF0b3I6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXktY29tYmluYXRvcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS15YWhvbzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXIteWFob28pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0teWFuZGV4OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci15YW5kZXgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0teWFuZGV4LWludGVybmF0aW9uYWw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXlhbmRleC1pbnRlcm5hdGlvbmFsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXllbHA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXllbHApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0teWVuLXNpZ246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXllbi1zaWduKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXlvYXN0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci15b2FzdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS15b3V0dWJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci15b3V0dWJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXlvdXR1YmUtc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci15b3V0dWJlLXNxdWFyZSk7IH1cbiIsIi8vIFNjcmVlbiBSZWFkZXJzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi5zci1vbmx5IHsgQGluY2x1ZGUgc3Itb25seTsgfVxuLnNyLW9ubHktZm9jdXNhYmxlIHsgQGluY2x1ZGUgc3Itb25seS1mb2N1c2FibGU7IH1cbiIsImJsb2NrcXVvdGUge1xuICBtYXJnaW46IDA7XG4gIHBhZGRpbmc6IDA7XG5cbiAgcCB7XG4gICAgYm9yZGVyOiAxcHggc29saWQgJGxpZ2h0Z3JheTtcbiAgICBib3JkZXItbGVmdDogLjVyZW0gc29saWQgJGxpZ2h0Z3JheTtcbiAgICBtYXJnaW46IC41cmVtIDA7XG4gICAgcGFkZGluZzogLjVyZW0gMXJlbSAuNXJlbSAxLjVyZW07XG4gIH1cbn1cblxucHJlLCBjb2RlIHtcbiAgYm9yZGVyLXJhZGl1czogLjI1ZW07XG4gIGJhY2tncm91bmQtY29sb3I6ICRjb2RlLWJnO1xufVxuXG5wcmUge1xuICBvdmVyZmxvdy14OiBhdXRvO1xuICBmb250LXNpemU6IC45cmVtO1xuICBwYWRkaW5nOiAxcmVtO1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG5cbiAgY29kZSB7XG4gICAgcGFkZGluZzogMDtcbiAgfVxufVxuXG5jb2RlIHtcbiAgcGFkZGluZzogLjJlbSAuNWVtO1xufVxuIiwiXG4kYmx1ZTogICAgIzMwQTFDMTtcbiRpbmRpZ286ICAjNjYxMGYyO1xuJHB1cnBsZTogICM2ZjQyYzE7XG4kcGluazogICAgI0QwNjU2NjtcbiRyZWQ6ICAgICAjREQ2MTYzO1xuJG9yYW5nZTogICNENTZENTk7XG4keWVsbG93OiAgI0ZFQ0QzRDtcbiRncmVlbjogICAjMzRDMzcxO1xuJHRlYWw6ICAgICMyMGM5OTc7XG4kY3lhbjogICAgIzVEOTlCRDtcblxuJGRhcmstY3lhbjogIzZkOTBhMztcblxuJHdoaXRlOiAgI2ZmZjtcbiRsaWdodGdyYXk6ICNlOGU4ZTg7XG4kYmc6ICNmMmYyZjI7XG4kY29kZS1iZzogI2Y4ZjhmODtcbiRncmF5OiAjNjY2O1xuJGNoYXJjb2FsOiAjMkIyRDMzO1xuJGJsYWNrOiAgIzAwMDtcbiRzaGFkb3c6IHRyYW5zcGFyZW50aXplKCRibGFjaywgLjk1KTtcbiRkYXJrLXNoYWRvdzogdHJhbnNwYXJlbnRpemUoJGJsYWNrLCAuNyk7XG5cbiRyZWQtbGlnaHQ6IGxpZ2h0ZW4oJHJlZCwgMzUlKTtcbiRjeWFuLWxpZ2h0OiBsaWdodGVuKCRjeWFuLCAzOCUpO1xuJHllbGxvdy1saWdodDogbGlnaHRlbigkeWVsbG93LCAzNSUpO1xuJGJsdWUtbGlnaHQ6IGxpZ2h0ZW4oJGJsdWUsIDQ1JSk7XG4kZ3JlZW4tbGlnaHQ6IGxpZ2h0ZW4oJGdyZWVuLCA0NSUpO1xuIiwiQGltcG9ydCBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZVwiO1xuXG5AaW1wb3J0IFwiaW5saW5lLWZpbGVzXCI7XG5AaW1wb3J0IFwiZmEtZm9udFwiO1xuQGltcG9ydCBcIi4uLy4uLy4uL2ZhNS9zY3NzL2ZvbnRhd2Vzb21lXCI7XG5cbkBpbXBvcnQgXCJjb2xvcnNcIjtcbkBpbXBvcnQgXCJtYXJrLWRvd25cIjtcblxuaHRtbCB7XG4gIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIEhlbHZldGljYSwgQXJpYWw7XG4gIGZvbnQtc2l6ZTogMTZweDtcbiAgbGluZS1oZWlnaHQ6IDEuNTtcbiAgY29sb3I6ICRjaGFyY29hbDtcbn1cblxuYm9keSB7XG4gIGhlaWdodDogMTAwJTtcbn1cblxuKiB7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG59XG5cbiRuYXYtd2lkdGg6IDMwMHB4O1xuJGNvbGxwYXNlLXdpZHRoOiA3MjBweDtcblxuLmJjeC1kb2MtbmF2IHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICBib3R0b206IDA7XG4gIHdpZHRoOiAkbmF2LXdpZHRoO1xuICBvdmVyZmxvdy14OiBoaWRkZW47XG4gIG92ZXJmbG93LXk6IGF1dG87XG4gIGJhY2tncm91bmQtY29sb3I6ICRiZztcbiAgcGFkZGluZzogLjVyZW07XG4gIHRyYW5zaXRpb246IGxlZnQgZWFzZSAyMDBtcztcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgJGxpZ2h0Z3JheTtcblxuICBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2IHtcbiAgICBtYXJnaW46IC44ZW0gMCAuNGVtO1xuICB9XG5cbiAgLmNsb3NlLW1lbnUge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cbn1cblxuLmJjeC1kb2MtbmF2LWJhY2tkcm9wIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cblxuYS5uYXYtbGluayB7XG4gICYsICY6dmlzaXRlZCB7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIHBhZGRpbmc6IC4zcmVtIC41cmVtO1xuICAgIGNvbG9yOiAkd2hpdGU7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAmOmhvdmVyIHtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICR3aGl0ZTtcbiAgICAgIGNvbG9yOiAkY3lhbjtcbiAgICB9XG4gIH1cbn1cblxuLm5hdi1kaXNhYmxlZCB7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgcGFkZGluZzogLjNyZW0gLjVyZW07XG4gIGNvbG9yOiB0cmFuc3BhcmVudGl6ZSgkd2hpdGUsIC42KTtcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDtcbn1cblxuYS5saW5rIHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgZm9udC1zaXplOiAuODVyZW07XG5cbiAgJi5yZW1vdGUtbGluayB7XG4gICAgZm9udC1zaXplOiAuNzVyZW07XG4gICAgbWFyZ2luOiA0cHggMDtcbiAgfVxuXG4gICYuZGVwcmVjYXRlZCwge1xuICAgICYsICY6dmlzaXRlZCB7XG4gICAgICB0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaDtcbiAgICAgIGNvbG9yOiAkZ3JheTtcbiAgICB9XG4gIH1cblxuICAmLCAmOnZpc2l0ZWQge1xuICAgIGNvbG9yOiAkY2hhcmNvYWw7XG4gICAgcGFkZGluZzogNHB4IDVweCA0cHggMTBweDtcbiAgICBtYXJnaW46IDJweCAwO1xuICB9XG5cbiAgJi5hY3RpdmUge1xuICAgICYsICY6dmlzaXRlZCB7XG4gICAgICAmLCAmLmRlcHJlY2F0ZWQge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkY3lhbjtcbiAgICAgICAgY29sb3I6ICR3aGl0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAmOmhvdmVyIHtcbiAgICAmLCAmOnZpc2l0ZWQge1xuICAgICAgJiwgJi5kZXByZWNhdGVkIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGdyYXk7XG4gICAgICAgIGNvbG9yOiAkd2hpdGU7XG5cbiAgICAgICAgJi5hY3RpdmUge1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRjeWFuO1xuICAgICAgICAgIGNvbG9yOiAkd2hpdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLmJjeC1kb2MtbWFpbiB7XG4gIHotaW5kZXg6IDE7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgbGVmdDogJG5hdi13aWR0aDtcbiAgYm90dG9tOiAwO1xuICByaWdodDogMDtcbiAgcGFkZGluZzogMXJlbTtcbiAgdHJhbnNpdGlvbjogbGVmdCBlYXNlIDIwMG1zO1xuICBvdmVyZmxvdy14OiBoaWRkZW47XG4gIG92ZXJmbG93LXk6IGF1dG87XG59XG5cbi5iY3gtb3ZlcmxheS1zcGlubmVyIHtcbiAgY29sb3I6ICRibHVlO1xuXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgcmlnaHQ6IDA7XG4gIGJvdHRvbTogMDtcbiAgY29sb3I6ICRjeWFuO1xufVxuXG4uYmN4LWRvYy1kZW1vIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC13cmFwOiBub3dyYXA7XG4gIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuXG4gIC5iY3gtZG9jLW1haW4gPiAmIHtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDIuNHJlbTtcbiAgICBsZWZ0OiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIGJvdHRvbTogMDtcbiAgfVxuXG4gIGNvbXBvc2UgPiAmIHtcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgIGJveC1zaGFkb3c6IDAgMCAxcmVtICRsaWdodGdyYXk7XG4gICAgbWFyZ2luOiAxcmVtIC0xcmVtO1xuICB9XG5cbiAgLmRlbW8tYXBwIHtcbiAgICBtYXJnaW46IDFyZW07XG4gICAgZmxleC1ncm93OiAwO1xuICB9XG5cbiAgLmRlbW8tY29kZSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGZsZXgtZ3JvdzogMTtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblxuICAgIC5iY3gtc2VsZWN0IHtcbiAgICAgIGZsZXgtZ3JvdzogMDtcbiAgICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIH1cblxuICAgIGRpc3BsYXktc291cmNlIHtcbiAgICAgIGZsZXg6IDEgMSAwO1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cbiAgfVxufVxuXG4uZGlzcGxheS1zb3VyY2Uge1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG5zZWxlY3QuYmN4LXNlbGVjdCB7XG4gIGFwcGVhcmFuY2U6IG5vbmU7XG4gIGJvcmRlci1yYWRpdXM6IDA7XG4gIGJvcmRlcjogMDtcbiAgY29sb3I6ICR3aGl0ZTtcbiAgcGFkZGluZzogLjI1cmVtIC41cmVtIC4yNXJlbSAxLjVyZW07XG4gIGZvbnQtc2l6ZTogLjg1cmVtO1xuICBiYWNrZ3JvdW5kOiAkZGFyay1jeWFuIHVybChcImRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0ZjgsJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgdmlld0JveD0nMCAwIDQgNSclM0UlM0NwYXRoIGZpbGw9J3doaXRlJyBkPSdNMiAwTDAgMmg0em0wIDVMMCAzaDR6Jy8lM0UlM0Mvc3ZnJTNFXCIpIG5vLXJlcGVhdCBsZWZ0IC41cmVtIGNlbnRlcjtcbiAgYmFja2dyb3VuZC1zaXplOiA4cHggMTBweDtcbn1cblxuLmJjeC1vcGVuLW1lbnUge1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB6LWluZGV4OiAyO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDA7XG4gIG1heC13aWR0aDogMTAwJTtcbiAgcGFkZGluZzogLjRyZW0gLjZyZW0gLjRyZW0gLjVyZW07XG4gIGNvbG9yOiAkd2hpdGU7XG4gIGJhY2tncm91bmQtY29sb3I6ICRjeWFuO1xuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogLjZyZW07XG5cbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cbiAgY3Vyc29yOiBkZWZhdWx0O1xuXG4gIC5mYS1iYXJzIHtcbiAgICBtYXJnaW4tcmlnaHQ6IC4yNXJlbTtcbiAgfVxufVxuXG4udGV4dC1tdXRlZCB7XG4gIGNvbG9yOiAkZ3JheTtcbn1cblxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogJGNvbGxwYXNlLXdpZHRoKSB7XG4gIC5iY3gtZG9jLW1haW4gPiAuYmN4LWRvYy1kZW1vIHtcbiAgICAuZGVtby1hcHAge1xuICAgICAgbWluLWhlaWdodDogMTAwcHg7XG4gICAgfVxuICB9XG5cbiAgY29tcG9zZSA+IC5iY3gtZG9jLWRlbW8ge1xuICAgIC5kZW1vLWFwcCB7XG4gICAgICBtaW4td2lkdGg6IDMwMHB4O1xuICAgIH1cblxuICAgIC5kZW1vLWNvZGUge1xuICAgICAgbWluLWhlaWdodDogMzAwcHg7XG4gICAgfVxuICB9XG5cbiAgLkNvZGVNaXJyb3ItZnVsbHNjcmVlbiB7XG4gICAgbGVmdDogJG5hdi13aWR0aDtcbiAgfVxuXG4gIC5iY3gtb3Blbi1tZW51IHtcbiAgICBsZWZ0OiAkbmF2LXdpZHRoO1xuICAgIG1heC13aWR0aDogY2FsYygxMDAlIC0gI3skbmF2LXdpZHRofSk7XG5cbiAgICAuZmEtYmFycyB7XG4gICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgfVxufVxuXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAkY29sbHBhc2Utd2lkdGggKyAkbmF2LXdpZHRoKSB7XG4gIGNvbXBvc2UgPiAuYmN4LWRvYy1kZW1vIHtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICB9XG59XG5cbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6ICRjb2xscGFzZS13aWR0aCkge1xuICBjb21wb3NlID4gLmJjeC1kb2MtZGVtbyB7XG4gICAgLmRlbW8tY29kZSB7XG4gICAgICBtaW4taGVpZ2h0OiAyMDBweDtcbiAgICB9XG4gIH1cblxuICAuYmN4LWRvYy1uYXYge1xuICAgIHotaW5kZXg6IDQ7XG4gICAgbGVmdDogLSRuYXYtd2lkdGg7XG5cbiAgICAmLm1lbnUtb3BlbiB7XG4gICAgICBsZWZ0OiAwO1xuICAgICAgYm94LXNoYWRvdzogMCAwIDJyZW0gJGRhcmstc2hhZG93O1xuXG4gICAgICAub3Blbi1tZW51IHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAuY2xvc2UtbWVudSB7XG4gICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHotaW5kZXg6IDI7XG4gICAgICB0b3A6IDA7XG4gICAgICByaWdodDogMDtcbiAgICAgIGZvbnQtc2l6ZTogMS4xcmVtO1xuICAgICAgcGFkZGluZzogLjRyZW0gLjVyZW0gLjRyZW0gLjZyZW07XG4gICAgICBjb2xvcjogJGdyYXk7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkbGlnaHRncmF5O1xuICAgICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogLjZyZW07XG4gICAgfVxuICB9XG5cbiAgLmJjeC1kb2MtbmF2LWJhY2tkcm9wIHtcbiAgICB6LWluZGV4OiAzO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICByaWdodDogMDtcbiAgICBib3R0b206IDA7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnRpemUoJGdyYXksIC40KTtcbiAgfVxuXG4gIC5iY3gtZG9jLW1haW4ge1xuICAgIGxlZnQ6IDA7XG4gIH1cbn1cblxuIl19 */\n"; });
define('bcx-doc-base/dist/elements/bcx-doc-nav',['require','exports','module','aurelia-framework','aurelia-event-aggregator','aurelia-pal','lodash'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.BcxDocNav = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _dec2, _dec3, _dec4, _dec5, _class, _desc, _value, _class2, _descriptor;

var _aureliaFramework = require('aurelia-framework');

var _aureliaEventAggregator = require('aurelia-event-aggregator');

var _aureliaPal = require('aurelia-pal');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var BcxDocNav = exports.BcxDocNav = (_dec = (0, _aureliaFramework.inject)(_aureliaEventAggregator.EventAggregator), _dec2 = (0, _aureliaFramework.computedFrom)('router.currentInstruction'), _dec3 = (0, _aureliaFramework.computedFrom)('router.currentInstruction', 'allNavs'), _dec4 = (0, _aureliaFramework.computedFrom)('currentIndex'), _dec5 = (0, _aureliaFramework.computedFrom)('currentIndex'), _dec(_class = (_class2 = function () {
  function BcxDocNav(ea) {
    _classCallCheck(this, BcxDocNav);

    _initDefineProp(this, 'router', _descriptor, this);

    this.menuOpen = false;
    this.allNavs = [];

    this.ea = ea;
  }

  BcxDocNav.prototype.attached = function attached() {
    var _this = this;

    var sections = (0, _lodash2.default)(this.router.navigation).map('settings.section').compact().uniq().value();

    var sectionedNavigation = [];
    _lodash2.default.each(sections, function (section) {
      sectionedNavigation.push({
        name: section,
        navs: _lodash2.default.filter(_this.router.navigation, function (n) {
          return _lodash2.default.get(n, 'settings.section') === section;
        })
      });
    });

    this.sectionedNavigation = sectionedNavigation;
    this.allNavs = (0, _lodash2.default)(this.sectionedNavigation).map('navs').flatten().value();

    this.afterNavigation = this.ea.subscribe('router:navigation:complete', function () {
      _this.menuOpen = false;
      var main = _aureliaPal.DOM.querySelector('.bcx-doc-main');
      if (main) main.scrollTop = 0;
    });
  };

  BcxDocNav.prototype.detached = function detached() {
    if (this.afterNavigation) {
      this.afterNavigation.dispose();
      this.afterNavigation = null;
    }
  };

  _createClass(BcxDocNav, [{
    key: 'currentTitle',
    get: function get() {
      var currentInstruction = this.router.currentInstruction;

      if (currentInstruction) {
        var section = _lodash2.default.get(currentInstruction, 'config.settings.section');
        var title = currentInstruction.config.title;
        if (section) title = section + ': ' + title;
        return title;
      }
    }
  }, {
    key: 'currentIndex',
    get: function get() {
      var currentInstruction = this.router.currentInstruction;

      if (currentInstruction) {
        return _lodash2.default.findIndex(this.allNavs, function (a) {
          return a.config === currentInstruction.config;
        });
      }
      return -1;
    }
  }, {
    key: 'previousPageLink',
    get: function get() {
      var currentIndex = this.currentIndex,
          allNavs = this.allNavs;

      if (currentIndex > 0) {
        return allNavs[currentIndex - 1].href;
      }
    }
  }, {
    key: 'nextPageLink',
    get: function get() {
      var currentIndex = this.currentIndex,
          allNavs = this.allNavs;

      if (currentIndex >= 0 && currentIndex < allNavs.length - 1) {
        return allNavs[currentIndex + 1].href;
      }
    }
  }]);

  return BcxDocNav;
}(), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'router', [_aureliaFramework.bindable], {
  enumerable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class2.prototype, 'currentTitle', [_dec2], Object.getOwnPropertyDescriptor(_class2.prototype, 'currentTitle'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'currentIndex', [_dec3], Object.getOwnPropertyDescriptor(_class2.prototype, 'currentIndex'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'previousPageLink', [_dec4], Object.getOwnPropertyDescriptor(_class2.prototype, 'previousPageLink'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'nextPageLink', [_dec5], Object.getOwnPropertyDescriptor(_class2.prototype, 'nextPageLink'), _class2.prototype)), _class2)) || _class);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVsZW1lbnRzL2JjeC1kb2MtbmF2LmpzIl0sIm5hbWVzIjpbIkJjeERvY05hdiIsImVhIiwibWVudU9wZW4iLCJhbGxOYXZzIiwiYXR0YWNoZWQiLCJzZWN0aW9ucyIsInJvdXRlciIsIm5hdmlnYXRpb24iLCJtYXAiLCJjb21wYWN0IiwidW5pcSIsInZhbHVlIiwic2VjdGlvbmVkTmF2aWdhdGlvbiIsImVhY2giLCJwdXNoIiwibmFtZSIsInNlY3Rpb24iLCJuYXZzIiwiZmlsdGVyIiwiZ2V0IiwibiIsImZsYXR0ZW4iLCJhZnRlck5hdmlnYXRpb24iLCJzdWJzY3JpYmUiLCJtYWluIiwicXVlcnlTZWxlY3RvciIsInNjcm9sbFRvcCIsImRldGFjaGVkIiwiZGlzcG9zZSIsImN1cnJlbnRJbnN0cnVjdGlvbiIsInRpdGxlIiwiY29uZmlnIiwiZmluZEluZGV4IiwiYSIsImN1cnJlbnRJbmRleCIsImhyZWYiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFHYUEsUyxXQUFBQSxTLFdBRFosc0UsVUFzQ0Usb0NBQWEsMkJBQWIsQyxVQVdBLG9DQUFhLDJCQUFiLEVBQTBDLFNBQTFDLEMsVUFTQSxvQ0FBYSxjQUFiLEMsVUFRQSxvQ0FBYSxjQUFiLEM7QUE1REQscUJBQVlDLEVBQVosRUFBZ0I7QUFBQTs7QUFBQTs7QUFBQSxTQUhoQkMsUUFHZ0IsR0FITCxLQUdLO0FBQUEsU0FGaEJDLE9BRWdCLEdBRk4sRUFFTTs7QUFDZCxTQUFLRixFQUFMLEdBQVVBLEVBQVY7QUFDRDs7c0JBRURHLFEsdUJBQVc7QUFBQTs7QUFDVCxRQUFNQyxXQUFXLHNCQUFFLEtBQUtDLE1BQUwsQ0FBWUMsVUFBZCxFQUEwQkMsR0FBMUIsQ0FBOEIsa0JBQTlCLEVBQWtEQyxPQUFsRCxHQUE0REMsSUFBNUQsR0FBbUVDLEtBQW5FLEVBQWpCOztBQUVBLFFBQU1DLHNCQUFzQixFQUE1QjtBQUNBLHFCQUFFQyxJQUFGLENBQU9SLFFBQVAsRUFBaUIsbUJBQVc7QUFDMUJPLDBCQUFvQkUsSUFBcEIsQ0FBeUI7QUFDdkJDLGNBQU1DLE9BRGlCO0FBRXZCQyxjQUFNLGlCQUFFQyxNQUFGLENBQVMsTUFBS1osTUFBTCxDQUFZQyxVQUFyQixFQUFpQztBQUFBLGlCQUFLLGlCQUFFWSxHQUFGLENBQU1DLENBQU4sRUFBUyxrQkFBVCxNQUFpQ0osT0FBdEM7QUFBQSxTQUFqQztBQUZpQixPQUF6QjtBQUlELEtBTEQ7O0FBT0EsU0FBS0osbUJBQUwsR0FBMkJBLG1CQUEzQjtBQUNBLFNBQUtULE9BQUwsR0FBZSxzQkFBRSxLQUFLUyxtQkFBUCxFQUE0QkosR0FBNUIsQ0FBZ0MsTUFBaEMsRUFBd0NhLE9BQXhDLEdBQWtEVixLQUFsRCxFQUFmOztBQUVBLFNBQUtXLGVBQUwsR0FBdUIsS0FBS3JCLEVBQUwsQ0FBUXNCLFNBQVIsQ0FBa0IsNEJBQWxCLEVBQWdELFlBQU07QUFDM0UsWUFBS3JCLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSxVQUFJc0IsT0FBTyxnQkFBSUMsYUFBSixDQUFrQixlQUFsQixDQUFYO0FBQ0EsVUFBSUQsSUFBSixFQUFVQSxLQUFLRSxTQUFMLEdBQWlCLENBQWpCO0FBQ1gsS0FKc0IsQ0FBdkI7QUFLRCxHOztzQkFFREMsUSx1QkFBVztBQUNULFFBQUksS0FBS0wsZUFBVCxFQUEwQjtBQUN4QixXQUFLQSxlQUFMLENBQXFCTSxPQUFyQjtBQUNBLFdBQUtOLGVBQUwsR0FBdUIsSUFBdkI7QUFDRDtBQUNGLEc7Ozs7d0JBR21CO0FBQUEsVUFDWE8sa0JBRFcsR0FDVyxLQUFLdkIsTUFEaEIsQ0FDWHVCLGtCQURXOztBQUVsQixVQUFJQSxrQkFBSixFQUF3QjtBQUN0QixZQUFNYixVQUFVLGlCQUFFRyxHQUFGLENBQU1VLGtCQUFOLEVBQTBCLHlCQUExQixDQUFoQjtBQUNBLFlBQUlDLFFBQVFELG1CQUFtQkUsTUFBbkIsQ0FBMEJELEtBQXRDO0FBQ0EsWUFBSWQsT0FBSixFQUFhYyxRQUFRZCxVQUFVLElBQVYsR0FBaUJjLEtBQXpCO0FBQ2IsZUFBT0EsS0FBUDtBQUNEO0FBQ0Y7Ozt3QkFHa0I7QUFBQSxVQUNWRCxrQkFEVSxHQUNZLEtBQUt2QixNQURqQixDQUNWdUIsa0JBRFU7O0FBRWpCLFVBQUlBLGtCQUFKLEVBQXdCO0FBQ3RCLGVBQU8saUJBQUVHLFNBQUYsQ0FBWSxLQUFLN0IsT0FBakIsRUFBMEI7QUFBQSxpQkFBSzhCLEVBQUVGLE1BQUYsS0FBYUYsbUJBQW1CRSxNQUFyQztBQUFBLFNBQTFCLENBQVA7QUFDRDtBQUNELGFBQU8sQ0FBQyxDQUFSO0FBQ0Q7Ozt3QkFHc0I7QUFBQSxVQUNkRyxZQURjLEdBQ1csSUFEWCxDQUNkQSxZQURjO0FBQUEsVUFDQS9CLE9BREEsR0FDVyxJQURYLENBQ0FBLE9BREE7O0FBRXJCLFVBQUkrQixlQUFlLENBQW5CLEVBQXNCO0FBQ3BCLGVBQU8vQixRQUFRK0IsZUFBZSxDQUF2QixFQUEwQkMsSUFBakM7QUFDRDtBQUNGOzs7d0JBR2tCO0FBQUEsVUFDVkQsWUFEVSxHQUNlLElBRGYsQ0FDVkEsWUFEVTtBQUFBLFVBQ0kvQixPQURKLEdBQ2UsSUFEZixDQUNJQSxPQURKOztBQUVqQixVQUFJK0IsZ0JBQWdCLENBQWhCLElBQXFCQSxlQUFlL0IsUUFBUWlDLE1BQVIsR0FBaUIsQ0FBekQsRUFBNEQ7QUFDMUQsZUFBT2pDLFFBQVErQixlQUFlLENBQXZCLEVBQTBCQyxJQUFqQztBQUNEO0FBQ0YiLCJmaWxlIjoiZWxlbWVudHMvYmN4LWRvYy1uYXYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2luamVjdCwgYmluZGFibGUsIGNvbXB1dGVkRnJvbX0gZnJvbSAnYXVyZWxpYS1mcmFtZXdvcmsnO1xuaW1wb3J0IHtFdmVudEFnZ3JlZ2F0b3J9IGZyb20gJ2F1cmVsaWEtZXZlbnQtYWdncmVnYXRvcic7XG5pbXBvcnQge0RPTX0gZnJvbSAnYXVyZWxpYS1wYWwnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcblxuQGluamVjdChFdmVudEFnZ3JlZ2F0b3IpXG5leHBvcnQgY2xhc3MgQmN4RG9jTmF2IHtcbiAgQGJpbmRhYmxlIHJvdXRlcjtcbiAgbWVudU9wZW4gPSBmYWxzZTtcbiAgYWxsTmF2cyA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGVhKSB7XG4gICAgdGhpcy5lYSA9IGVhO1xuICB9XG5cbiAgYXR0YWNoZWQoKSB7XG4gICAgY29uc3Qgc2VjdGlvbnMgPSBfKHRoaXMucm91dGVyLm5hdmlnYXRpb24pLm1hcCgnc2V0dGluZ3Muc2VjdGlvbicpLmNvbXBhY3QoKS51bmlxKCkudmFsdWUoKTtcblxuICAgIGNvbnN0IHNlY3Rpb25lZE5hdmlnYXRpb24gPSBbXTtcbiAgICBfLmVhY2goc2VjdGlvbnMsIHNlY3Rpb24gPT4ge1xuICAgICAgc2VjdGlvbmVkTmF2aWdhdGlvbi5wdXNoKHtcbiAgICAgICAgbmFtZTogc2VjdGlvbixcbiAgICAgICAgbmF2czogXy5maWx0ZXIodGhpcy5yb3V0ZXIubmF2aWdhdGlvbiwgbiA9PiBfLmdldChuLCAnc2V0dGluZ3Muc2VjdGlvbicpID09PSBzZWN0aW9uKVxuICAgICAgfSlcbiAgICB9KTtcblxuICAgIHRoaXMuc2VjdGlvbmVkTmF2aWdhdGlvbiA9IHNlY3Rpb25lZE5hdmlnYXRpb247XG4gICAgdGhpcy5hbGxOYXZzID0gXyh0aGlzLnNlY3Rpb25lZE5hdmlnYXRpb24pLm1hcCgnbmF2cycpLmZsYXR0ZW4oKS52YWx1ZSgpO1xuXG4gICAgdGhpcy5hZnRlck5hdmlnYXRpb24gPSB0aGlzLmVhLnN1YnNjcmliZSgncm91dGVyOm5hdmlnYXRpb246Y29tcGxldGUnLCAoKSA9PiB7XG4gICAgICB0aGlzLm1lbnVPcGVuID0gZmFsc2U7XG4gICAgICBsZXQgbWFpbiA9IERPTS5xdWVyeVNlbGVjdG9yKCcuYmN4LWRvYy1tYWluJyk7XG4gICAgICBpZiAobWFpbikgbWFpbi5zY3JvbGxUb3AgPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgZGV0YWNoZWQoKSB7XG4gICAgaWYgKHRoaXMuYWZ0ZXJOYXZpZ2F0aW9uKSB7XG4gICAgICB0aGlzLmFmdGVyTmF2aWdhdGlvbi5kaXNwb3NlKCk7XG4gICAgICB0aGlzLmFmdGVyTmF2aWdhdGlvbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgQGNvbXB1dGVkRnJvbSgncm91dGVyLmN1cnJlbnRJbnN0cnVjdGlvbicpXG4gIGdldCBjdXJyZW50VGl0bGUgKCkge1xuICAgIGNvbnN0IHtjdXJyZW50SW5zdHJ1Y3Rpb259ID0gdGhpcy5yb3V0ZXI7XG4gICAgaWYgKGN1cnJlbnRJbnN0cnVjdGlvbikge1xuICAgICAgY29uc3Qgc2VjdGlvbiA9IF8uZ2V0KGN1cnJlbnRJbnN0cnVjdGlvbiwgJ2NvbmZpZy5zZXR0aW5ncy5zZWN0aW9uJyk7XG4gICAgICBsZXQgdGl0bGUgPSBjdXJyZW50SW5zdHJ1Y3Rpb24uY29uZmlnLnRpdGxlO1xuICAgICAgaWYgKHNlY3Rpb24pIHRpdGxlID0gc2VjdGlvbiArICc6ICcgKyB0aXRsZTtcbiAgICAgIHJldHVybiB0aXRsZTtcbiAgICB9XG4gIH1cblxuICBAY29tcHV0ZWRGcm9tKCdyb3V0ZXIuY3VycmVudEluc3RydWN0aW9uJywgJ2FsbE5hdnMnKVxuICBnZXQgY3VycmVudEluZGV4KCkge1xuICAgIGNvbnN0IHtjdXJyZW50SW5zdHJ1Y3Rpb259ID0gdGhpcy5yb3V0ZXI7XG4gICAgaWYgKGN1cnJlbnRJbnN0cnVjdGlvbikge1xuICAgICAgcmV0dXJuIF8uZmluZEluZGV4KHRoaXMuYWxsTmF2cywgYSA9PiBhLmNvbmZpZyA9PT0gY3VycmVudEluc3RydWN0aW9uLmNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIEBjb21wdXRlZEZyb20oJ2N1cnJlbnRJbmRleCcpXG4gIGdldCBwcmV2aW91c1BhZ2VMaW5rKCkge1xuICAgIGNvbnN0IHtjdXJyZW50SW5kZXgsIGFsbE5hdnN9ID0gdGhpcztcbiAgICBpZiAoY3VycmVudEluZGV4ID4gMCkge1xuICAgICAgcmV0dXJuIGFsbE5hdnNbY3VycmVudEluZGV4IC0gMV0uaHJlZjtcbiAgICB9XG4gIH1cblxuICBAY29tcHV0ZWRGcm9tKCdjdXJyZW50SW5kZXgnKVxuICBnZXQgbmV4dFBhZ2VMaW5rKCkge1xuICAgIGNvbnN0IHtjdXJyZW50SW5kZXgsIGFsbE5hdnN9ID0gdGhpcztcbiAgICBpZiAoY3VycmVudEluZGV4ID49IDAgJiYgY3VycmVudEluZGV4IDwgYWxsTmF2cy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gYWxsTmF2c1tjdXJyZW50SW5kZXggKyAxXS5ocmVmO1xuICAgIH1cbiAgfVxufVxuXG4iXX0=

});

define('text!bcx-doc-base/dist/elements/bcx-doc-nav.html', ['module'], function(module) { module.exports = "<template>\n  <div\n    if.bind=\"menuOpen\"\n    class=\"bcx-doc-nav-backdrop\"\n    click.trigger=\"menuOpen = false & leftClick\"></div>\n\n  <div class=\"bcx-doc-nav ${menuOpen ? 'menu-open' : ''}\">\n    <i class=\"far fa-times close-menu\" click.trigger=\"menuOpen = false & leftClick\"></i>\n\n    <slot name=\"top\"></slot>\n\n    <template repeat.for=\"section of sectionedNavigation\">\n      <h4><em>${section.name}</em></h4>\n      <a\n        repeat.for=\"row of section.navs\"\n        class=\"link ${row.isActive ? 'active' : ''} ${row.settings.deprecated ? 'deprecated' : ''}\"\n        href.bind=\"row.href\"\n      >${row.title}</a>\n    </template>\n\n    <slot></slot>\n  </div>\n\n\n  <div class=\"bcx-open-menu\">\n    <i class=\"fas fa-bars\" click.trigger=\"menuOpen = true & leftClick\"></i>\n\n    <a if.bind=\"previousPageLink\" class=\"fas fa-chevron-left nav-link\" href.bind=\"previousPageLink\"></a>\n    <i else class=\"fas fa-chevron-left nav-disabled\"></i>\n    <a if.bind=\"nextPageLink\" class=\"fas fa-chevron-right nav-link\" href.bind=\"nextPageLink\"></a>\n    <i else class=\"fas fa-chevron-right nav-disabled\"></i>\n    ${currentTitle}\n  </div>\n</template>\n"; });
define('bcx-doc-base/dist/elements/code-viewer',['require','exports','module','aurelia-framework','codemirror','codemirror/addon/display/fullscreen','codemirror/mode/markdown/markdown','codemirror/mode/javascript/javascript','codemirror/mode/css/css','codemirror/mode/xml/xml','codemirror/mode/htmlmixed/htmlmixed'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.CodeViewer = undefined;

var _desc, _value, _class, _descriptor, _descriptor2;

var _aureliaFramework = require('aurelia-framework');

var _codemirror = require('codemirror');

var _codemirror2 = _interopRequireDefault(_codemirror);

require('codemirror/addon/display/fullscreen');

require('codemirror/mode/markdown/markdown');

require('codemirror/mode/javascript/javascript');

require('codemirror/mode/css/css');

require('codemirror/mode/xml/xml');

require('codemirror/mode/htmlmixed/htmlmixed');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

function cleanMode(mode) {
  mode = (mode || '').toLowerCase();
  if (mode === 'md' || mode === 'markdown') return 'text/x-markdown';
  if (mode === 'html' || mode === 'htm') return 'text/html';

  if (mode === 'js' || mode === 'javascript') return 'text/javascript';
  if (mode === 'ts' || mode === 'typescript') return 'application/typescript';
  if (mode === 'json') return 'application/json';

  if (mode === 'css') return 'text/css';
  if (mode === 'scss') return 'text/x-scss';

  return null;
}

var CodeViewer = exports.CodeViewer = (_class = function () {
  function CodeViewer() {
    _classCallCheck(this, CodeViewer);

    _initDefineProp(this, 'value', _descriptor, this);

    _initDefineProp(this, 'mode', _descriptor2, this);

    this.fullScreen = false;
  }

  CodeViewer.prototype.valueChanged = function valueChanged(newValue) {
    var cm = this.cm;

    if (!cm) return;
    cm.setValue(newValue);
  };

  CodeViewer.prototype.modeChanged = function modeChanged(newMode) {
    var cm = this.cm;

    if (!cm) return;
    cm.setOption('mode', cleanMode(newMode));
  };

  CodeViewer.prototype.toggleFullScreen = function toggleFullScreen() {
    var cm = this.cm;

    if (!cm) return;
    this.fullScreen = !this.fullScreen;
    cm.setOption('fullScreen', this.fullScreen);
  };

  CodeViewer.prototype.attached = function attached() {
    this.cm = (0, _codemirror2.default)(this.viewer, {
      value: this.value,
      mode: cleanMode(this.mode),

      lineNumbers: true,
      readOnly: 'nocursor',
      lineWrapping: true
    });
  };

  CodeViewer.prototype.detached = function detached() {
    if (!this.cm) return;
    this.cm.off(this.onChange);
    delete this.cm;

    var cmDom = this.viewer.querySelector('.CodeMirror');
    if (cmDom) {
      this.viewer.removeChild(cmDom);
    }
  };

  return CodeViewer;
}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'value', [_aureliaFramework.bindable], {
  enumerable: true,
  initializer: function initializer() {
    return '';
  }
}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'mode', [_aureliaFramework.bindable], {
  enumerable: true,
  initializer: null
})), _class);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVsZW1lbnRzL2NvZGUtdmlld2VyLmpzIl0sIm5hbWVzIjpbImNsZWFuTW9kZSIsIm1vZGUiLCJ0b0xvd2VyQ2FzZSIsIkNvZGVWaWV3ZXIiLCJmdWxsU2NyZWVuIiwidmFsdWVDaGFuZ2VkIiwibmV3VmFsdWUiLCJjbSIsInNldFZhbHVlIiwibW9kZUNoYW5nZWQiLCJuZXdNb2RlIiwic2V0T3B0aW9uIiwidG9nZ2xlRnVsbFNjcmVlbiIsImF0dGFjaGVkIiwidmlld2VyIiwidmFsdWUiLCJsaW5lTnVtYmVycyIsInJlYWRPbmx5IiwibGluZVdyYXBwaW5nIiwiZGV0YWNoZWQiLCJvZmYiLCJvbkNoYW5nZSIsImNtRG9tIiwicXVlcnlTZWxlY3RvciIsInJlbW92ZUNoaWxkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLFNBQVNBLFNBQVQsQ0FBb0JDLElBQXBCLEVBQTBCO0FBQ3hCQSxTQUFPLENBQUNBLFFBQVEsRUFBVCxFQUFhQyxXQUFiLEVBQVA7QUFDQSxNQUFJRCxTQUFTLElBQVQsSUFBaUJBLFNBQVMsVUFBOUIsRUFBMEMsT0FBTyxpQkFBUDtBQUMxQyxNQUFJQSxTQUFTLE1BQVQsSUFBbUJBLFNBQVMsS0FBaEMsRUFBdUMsT0FBTyxXQUFQOztBQUV2QyxNQUFJQSxTQUFTLElBQVQsSUFBaUJBLFNBQVMsWUFBOUIsRUFBNEMsT0FBTyxpQkFBUDtBQUM1QyxNQUFJQSxTQUFTLElBQVQsSUFBaUJBLFNBQVMsWUFBOUIsRUFBNEMsT0FBTyx3QkFBUDtBQUM1QyxNQUFJQSxTQUFTLE1BQWIsRUFBcUIsT0FBTyxrQkFBUDs7QUFFckIsTUFBSUEsU0FBUyxLQUFiLEVBQW9CLE9BQU8sVUFBUDtBQUNwQixNQUFJQSxTQUFTLE1BQWIsRUFBcUIsT0FBTyxhQUFQOztBQUVyQixTQUFPLElBQVA7QUFDRDs7SUFFWUUsVSxXQUFBQSxVOzs7Ozs7OztTQUdYQyxVLEdBQWEsSzs7O3VCQUViQyxZLHlCQUFhQyxRLEVBQVU7QUFBQSxRQUNkQyxFQURjLEdBQ1IsSUFEUSxDQUNkQSxFQURjOztBQUVyQixRQUFJLENBQUNBLEVBQUwsRUFBUztBQUNUQSxPQUFHQyxRQUFILENBQVlGLFFBQVo7QUFDRCxHOzt1QkFFREcsVyx3QkFBWUMsTyxFQUFTO0FBQUEsUUFDWkgsRUFEWSxHQUNOLElBRE0sQ0FDWkEsRUFEWTs7QUFFbkIsUUFBSSxDQUFDQSxFQUFMLEVBQVM7QUFDVEEsT0FBR0ksU0FBSCxDQUFhLE1BQWIsRUFBcUJYLFVBQVVVLE9BQVYsQ0FBckI7QUFDRCxHOzt1QkFFREUsZ0IsK0JBQW1CO0FBQUEsUUFDVkwsRUFEVSxHQUNKLElBREksQ0FDVkEsRUFEVTs7QUFFakIsUUFBSSxDQUFDQSxFQUFMLEVBQVM7QUFDVCxTQUFLSCxVQUFMLEdBQWtCLENBQUMsS0FBS0EsVUFBeEI7QUFDQUcsT0FBR0ksU0FBSCxDQUFhLFlBQWIsRUFBMkIsS0FBS1AsVUFBaEM7QUFDRCxHOzt1QkFFRFMsUSx1QkFBVztBQUNULFNBQUtOLEVBQUwsR0FBVSwwQkFBVyxLQUFLTyxNQUFoQixFQUF3QjtBQUNoQ0MsYUFBTyxLQUFLQSxLQURvQjtBQUVoQ2QsWUFBTUQsVUFBVSxLQUFLQyxJQUFmLENBRjBCOztBQUloQ2UsbUJBQWEsSUFKbUI7QUFLaENDLGdCQUFVLFVBTHNCO0FBTWhDQyxvQkFBYztBQU5rQixLQUF4QixDQUFWO0FBUUQsRzs7dUJBRURDLFEsdUJBQVc7QUFDVCxRQUFJLENBQUMsS0FBS1osRUFBVixFQUFjO0FBQ2QsU0FBS0EsRUFBTCxDQUFRYSxHQUFSLENBQVksS0FBS0MsUUFBakI7QUFDQSxXQUFPLEtBQUtkLEVBQVo7O0FBSUEsUUFBTWUsUUFBUSxLQUFLUixNQUFMLENBQVlTLGFBQVosQ0FBMEIsYUFBMUIsQ0FBZDtBQUNBLFFBQUlELEtBQUosRUFBVztBQUNULFdBQUtSLE1BQUwsQ0FBWVUsV0FBWixDQUF3QkYsS0FBeEI7QUFDRDtBQUNGLEc7Ozs7OztXQTdDaUIsRSIsImZpbGUiOiJlbGVtZW50cy9jb2RlLXZpZXdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YmluZGFibGV9IGZyb20gJ2F1cmVsaWEtZnJhbWV3b3JrJztcbmltcG9ydCBDb2RlTWlycm9yIGZyb20gJ2NvZGVtaXJyb3InO1xuaW1wb3J0IFwiY29kZW1pcnJvci9hZGRvbi9kaXNwbGF5L2Z1bGxzY3JlZW5cIjtcbmltcG9ydCBcImNvZGVtaXJyb3IvbW9kZS9tYXJrZG93bi9tYXJrZG93blwiO1xuaW1wb3J0IFwiY29kZW1pcnJvci9tb2RlL2phdmFzY3JpcHQvamF2YXNjcmlwdFwiO1xuaW1wb3J0IFwiY29kZW1pcnJvci9tb2RlL2Nzcy9jc3NcIjtcbmltcG9ydCBcImNvZGVtaXJyb3IvbW9kZS94bWwveG1sXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL21vZGUvaHRtbG1peGVkL2h0bWxtaXhlZFwiO1xuXG5mdW5jdGlvbiBjbGVhbk1vZGUgKG1vZGUpIHtcbiAgbW9kZSA9IChtb2RlIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobW9kZSA9PT0gJ21kJyB8fCBtb2RlID09PSAnbWFya2Rvd24nKSByZXR1cm4gJ3RleHQveC1tYXJrZG93bic7XG4gIGlmIChtb2RlID09PSAnaHRtbCcgfHwgbW9kZSA9PT0gJ2h0bScpIHJldHVybiAndGV4dC9odG1sJztcbiAgLy8gbW9kZS9qYXZhc2NyaXB0L2phdmFzY3JpcHRcbiAgaWYgKG1vZGUgPT09ICdqcycgfHwgbW9kZSA9PT0gJ2phdmFzY3JpcHQnKSByZXR1cm4gJ3RleHQvamF2YXNjcmlwdCc7XG4gIGlmIChtb2RlID09PSAndHMnIHx8IG1vZGUgPT09ICd0eXBlc2NyaXB0JykgcmV0dXJuICdhcHBsaWNhdGlvbi90eXBlc2NyaXB0JztcbiAgaWYgKG1vZGUgPT09ICdqc29uJykgcmV0dXJuICdhcHBsaWNhdGlvbi9qc29uJztcbiAgLy8gc3VwcG9ydGVkIGJ5IG1vZGUvY3NzL2Nzc1xuICBpZiAobW9kZSA9PT0gJ2NzcycpIHJldHVybiAndGV4dC9jc3MnO1xuICBpZiAobW9kZSA9PT0gJ3Njc3MnKSByZXR1cm4gJ3RleHQveC1zY3NzJztcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGNsYXNzIENvZGVWaWV3ZXIge1xuICBAYmluZGFibGUgdmFsdWUgPSAnJztcbiAgQGJpbmRhYmxlIG1vZGU7XG4gIGZ1bGxTY3JlZW4gPSBmYWxzZTtcblxuICB2YWx1ZUNoYW5nZWQobmV3VmFsdWUpIHtcbiAgICBjb25zdCB7Y219ID0gdGhpcztcbiAgICBpZiAoIWNtKSByZXR1cm47XG4gICAgY20uc2V0VmFsdWUobmV3VmFsdWUpO1xuICB9XG5cbiAgbW9kZUNoYW5nZWQobmV3TW9kZSkge1xuICAgIGNvbnN0IHtjbX0gPSB0aGlzO1xuICAgIGlmICghY20pIHJldHVybjtcbiAgICBjbS5zZXRPcHRpb24oJ21vZGUnLCBjbGVhbk1vZGUobmV3TW9kZSkpO1xuICB9XG5cbiAgdG9nZ2xlRnVsbFNjcmVlbigpIHtcbiAgICBjb25zdCB7Y219ID0gdGhpcztcbiAgICBpZiAoIWNtKSByZXR1cm47XG4gICAgdGhpcy5mdWxsU2NyZWVuID0gIXRoaXMuZnVsbFNjcmVlbjtcbiAgICBjbS5zZXRPcHRpb24oJ2Z1bGxTY3JlZW4nLCB0aGlzLmZ1bGxTY3JlZW4pO1xuICB9XG5cbiAgYXR0YWNoZWQoKSB7XG4gICAgdGhpcy5jbSA9IENvZGVNaXJyb3IodGhpcy52aWV3ZXIsIHtcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgbW9kZTogY2xlYW5Nb2RlKHRoaXMubW9kZSksXG4gICAgICAvLyB0aGVtZTogJ3NvbGFyaXplZCBkYXJrJyxcbiAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxuICAgICAgcmVhZE9ubHk6ICdub2N1cnNvcicsXG4gICAgICBsaW5lV3JhcHBpbmc6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGRldGFjaGVkKCkge1xuICAgIGlmICghdGhpcy5jbSkgcmV0dXJuO1xuICAgIHRoaXMuY20ub2ZmKHRoaXMub25DaGFuZ2UpO1xuICAgIGRlbGV0ZSB0aGlzLmNtO1xuXG4gICAgLy8gYXVyZWxpYSBrZWVwcyB2aWV3IGluIGNhY2hlIChyZXR1cm5Ub0NhY2hlKS5cbiAgICAvLyB0aGlzIG1ha2VzIHN1cmUgdG8gY2xlYW4gdXAgY29kZW1pcnJvciBpbnN0YW5jZS5cbiAgICBjb25zdCBjbURvbSA9IHRoaXMudmlld2VyLnF1ZXJ5U2VsZWN0b3IoJy5Db2RlTWlycm9yJyk7XG4gICAgaWYgKGNtRG9tKSB7XG4gICAgICB0aGlzLnZpZXdlci5yZW1vdmVDaGlsZChjbURvbSk7XG4gICAgfVxuICB9XG5cbn1cblxuIl19

});

define('text!bcx-doc-base/dist/elements/code-viewer.css', ['module'], function(module) { module.exports = ".code-viewer {\n  box-sizing: border-box;\n  display: block;\n  position: relative;\n  font-size: 14px;\n  border: 1px solid #e8e8e8; }\n  .code-viewer .full-screen-button {\n    display: none; }\n\n.CodeMirror {\n  width: 100%;\n  height: auto; }\n\n.demo-code .code-viewer {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  border: 0; }\n  .demo-code .code-viewer .full-screen-button {\n    display: block; }\n  .demo-code .code-viewer .CodeMirror {\n    height: 100%; }\n\n.full-screen-button {\n  z-index: 9999;\n  position: absolute;\n  cursor: default;\n  top: 0;\n  right: 0;\n  font-size: 1.1rem;\n  padding: .4rem .5rem .4rem .6rem;\n  color: #666;\n  background-color: rgba(255, 255, 255, 0.8);\n  border-bottom-left-radius: .6rem;\n  border: 1px solid #e8e8e8;\n  box-shadow: 0 0 1rem rgba(0, 0, 0, 0.05); }\n  .full-screen-button.full-screen {\n    position: fixed; }\n\n.full-screen-button.full-screen, .CodeMirror-fullscreen {\n  top: 1.9rem; }\n\n.CodeMirror-fullscreen {\n  border-top: 1px solid #e8e8e8; }\n\n/*# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVsZW1lbnRzL2NvZGUtdmlld2VyLnNjc3MiLCJjc3MvX2NvbG9ycy5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBO0VBQ0UsdUJBQXNCO0VBQ3RCLGVBQWM7RUFDZCxtQkFBa0I7RUFDbEIsZ0JBQWU7RUFDZiwwQkNRaUIsRURIbEI7RUFWRDtJQVFJLGNBQWEsRUFDZDs7QUFHSDtFQUNFLFlBQVc7RUFDWCxhQUFZLEVBQ2I7O0FBRUQ7RUFFSSxtQkFBa0I7RUFDbEIsT0FBTTtFQUNOLFFBQU87RUFDUCxTQUFRO0VBQ1IsVUFBUztFQUNULFVBQVMsRUFTVjtFQWhCSDtJQVVNLGVBQWMsRUFDZjtFQVhMO0lBY00sYUFBWSxFQUNiOztBQUlMO0VBQ0UsY0FBYTtFQUNiLG1CQUFrQjtFQUNsQixnQkFBZTtFQUNmLE9BQU07RUFDTixTQUFRO0VBQ1Isa0JBQWlCO0VBQ2pCLGlDQUFnQztFQUNoQyxZQzVCUztFRDZCVCwyQ0FBNEM7RUFDNUMsaUNBQWdDO0VBQ2hDLDBCQ2xDaUI7RURtQ2pCLHlDQzdCa0MsRURrQ25DO0VBakJEO0lBZUksZ0JBQWUsRUFDaEI7O0FBR0g7RUFDRSxZQUFXLEVBQ1o7O0FBRUQ7RUFDRSw4QkMvQ2lCLEVEZ0RsQiIsImZpbGUiOiJlbGVtZW50cy9jb2RlLXZpZXdlci5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyJAaW1wb3J0IFwiLi4vY3NzL2NvbG9yc1wiO1xuXG4uY29kZS12aWV3ZXIge1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBmb250LXNpemU6IDE0cHg7XG4gIGJvcmRlcjogMXB4IHNvbGlkICRsaWdodGdyYXk7XG5cbiAgLmZ1bGwtc2NyZWVuLWJ1dHRvbiB7XG4gICAgZGlzcGxheTogbm9uZTtcbiAgfVxufVxuXG4uQ29kZU1pcnJvciB7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IGF1dG87XG59XG5cbi5kZW1vLWNvZGUge1xuICAuY29kZS12aWV3ZXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICByaWdodDogMDtcbiAgICBib3R0b206IDA7XG4gICAgYm9yZGVyOiAwO1xuXG4gICAgLmZ1bGwtc2NyZWVuLWJ1dHRvbiB7XG4gICAgICBkaXNwbGF5OiBibG9jaztcbiAgICB9XG5cbiAgICAuQ29kZU1pcnJvciB7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuICB9XG59XG5cbi5mdWxsLXNjcmVlbi1idXR0b24ge1xuICB6LWluZGV4OiA5OTk5O1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGN1cnNvcjogZGVmYXVsdDtcbiAgdG9wOiAwO1xuICByaWdodDogMDtcbiAgZm9udC1zaXplOiAxLjFyZW07XG4gIHBhZGRpbmc6IC40cmVtIC41cmVtIC40cmVtIC42cmVtO1xuICBjb2xvcjogJGdyYXk7XG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50aXplKCR3aGl0ZSwgLjIpO1xuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAuNnJlbTtcbiAgYm9yZGVyOiAxcHggc29saWQgJGxpZ2h0Z3JheTtcbiAgYm94LXNoYWRvdzogMCAwIDFyZW0gJHNoYWRvdztcblxuICAmLmZ1bGwtc2NyZWVuIHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gIH1cbn1cblxuLmZ1bGwtc2NyZWVuLWJ1dHRvbi5mdWxsLXNjcmVlbiwgLkNvZGVNaXJyb3ItZnVsbHNjcmVlbiB7XG4gIHRvcDogMS45cmVtO1xufVxuXG4uQ29kZU1pcnJvci1mdWxsc2NyZWVuIHtcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICRsaWdodGdyYXk7XG59XG4iLCJcbiRibHVlOiAgICAjMzBBMUMxO1xuJGluZGlnbzogICM2NjEwZjI7XG4kcHVycGxlOiAgIzZmNDJjMTtcbiRwaW5rOiAgICAjRDA2NTY2O1xuJHJlZDogICAgICNERDYxNjM7XG4kb3JhbmdlOiAgI0Q1NkQ1OTtcbiR5ZWxsb3c6ICAjRkVDRDNEO1xuJGdyZWVuOiAgICMzNEMzNzE7XG4kdGVhbDogICAgIzIwYzk5NztcbiRjeWFuOiAgICAjNUQ5OUJEO1xuXG4kZGFyay1jeWFuOiAjNmQ5MGEzO1xuXG4kd2hpdGU6ICAjZmZmO1xuJGxpZ2h0Z3JheTogI2U4ZThlODtcbiRiZzogI2YyZjJmMjtcbiRjb2RlLWJnOiAjZjhmOGY4O1xuJGdyYXk6ICM2NjY7XG4kY2hhcmNvYWw6ICMyQjJEMzM7XG4kYmxhY2s6ICAjMDAwO1xuJHNoYWRvdzogdHJhbnNwYXJlbnRpemUoJGJsYWNrLCAuOTUpO1xuJGRhcmstc2hhZG93OiB0cmFuc3BhcmVudGl6ZSgkYmxhY2ssIC43KTtcblxuJHJlZC1saWdodDogbGlnaHRlbigkcmVkLCAzNSUpO1xuJGN5YW4tbGlnaHQ6IGxpZ2h0ZW4oJGN5YW4sIDM4JSk7XG4keWVsbG93LWxpZ2h0OiBsaWdodGVuKCR5ZWxsb3csIDM1JSk7XG4kYmx1ZS1saWdodDogbGlnaHRlbigkYmx1ZSwgNDUlKTtcbiRncmVlbi1saWdodDogbGlnaHRlbigkZ3JlZW4sIDQ1JSk7XG4iXX0= */\n"; });
define('text!bcx-doc-base/dist/elements/code-viewer.html', ['module'], function(module) { module.exports = "<template ref=\"viewer\" class=\"code-viewer\">\n  <require from=\"codemirror/lib/codemirror.css\"></require>\n  <require from=\"codemirror/addon/display/fullscreen.css\"></require>\n  <require from=\"./code-viewer.css\"></require>\n\n  <div\n    class=\"full-screen-button ${fullScreen ? 'full-screen' : ''}\"\n    click.trigger=\"toggleFullScreen() & leftClick\"\n  >\n    <i class=\"far fa-${fullScreen ? 'compress' : 'expand'}\" aria-hidden=\"true\"></i>\n  </div>\n</template>\n"; });
define('bcx-doc-base/dist/elements/display-source',['require','exports','module','aurelia-framework','aurelia-pal'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.DisplaySource = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _desc, _value, _class, _descriptor;

var _aureliaFramework = require('aurelia-framework');

var _aureliaPal = require('aurelia-pal');

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var DisplaySource = exports.DisplaySource = (_dec = (0, _aureliaFramework.computedFrom)('source'), (_class = function () {
  function DisplaySource() {
    _classCallCheck(this, DisplaySource);

    _initDefineProp(this, 'source', _descriptor, this);

    this.fileContent = '';
    this.loading = false;
  }

  DisplaySource.prototype.bind = function bind() {
    this.reloadContent();
  };

  DisplaySource.prototype.sourceChanged = function sourceChanged() {
    this.reloadContent();
  };

  DisplaySource.prototype.reloadContent = function reloadContent() {
    var _this = this;

    this.fileContent = '';
    this.loading = true;

    _aureliaPal.PLATFORM.global.require(['text!../' + this.source], function (content) {
      _this.fileContent = content;
      _this.loading = false;
    }, function () {
      _this.fileContent = 'Failed to load ' + _this.source;
      _this.loading = false;
    });
  };

  _createClass(DisplaySource, [{
    key: 'ext',
    get: function get() {
      var idx = this.source.lastIndexOf('.');
      if (idx !== -1) return this.source.substr(idx + 1);
      return null;
    }
  }]);

  return DisplaySource;
}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'source', [_aureliaFramework.bindable], {
  enumerable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class.prototype, 'ext', [_dec], Object.getOwnPropertyDescriptor(_class.prototype, 'ext'), _class.prototype)), _class));
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVsZW1lbnRzL2Rpc3BsYXktc291cmNlLmpzIl0sIm5hbWVzIjpbIkRpc3BsYXlTb3VyY2UiLCJmaWxlQ29udGVudCIsImxvYWRpbmciLCJiaW5kIiwicmVsb2FkQ29udGVudCIsInNvdXJjZUNoYW5nZWQiLCJnbG9iYWwiLCJyZXF1aXJlIiwic291cmNlIiwiY29udGVudCIsImlkeCIsImxhc3RJbmRleE9mIiwic3Vic3RyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFYUEsYSxXQUFBQSxhLFdBNkJWLG9DQUFhLFFBQWIsQzs7Ozs7O1NBM0JEQyxXLEdBQWMsRTtTQUNkQyxPLEdBQVUsSzs7OzBCQUVWQyxJLG1CQUFPO0FBQ0wsU0FBS0MsYUFBTDtBQUNELEc7OzBCQUVEQyxhLDRCQUFnQjtBQUNkLFNBQUtELGFBQUw7QUFDRCxHOzswQkFFREEsYSw0QkFBZ0I7QUFBQTs7QUFDZCxTQUFLSCxXQUFMLEdBQW1CLEVBQW5CO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLElBQWY7O0FBRUEseUJBQVNJLE1BQVQsQ0FBZ0JDLE9BQWhCLENBQXdCLGNBQVksS0FBS0MsTUFBakIsQ0FBeEIsRUFDRSxtQkFBVztBQUNULFlBQUtQLFdBQUwsR0FBbUJRLE9BQW5CO0FBQ0EsWUFBS1AsT0FBTCxHQUFlLEtBQWY7QUFDRCxLQUpILEVBS0UsWUFBTTtBQUNKLFlBQUtELFdBQUwsR0FBbUIsb0JBQW9CLE1BQUtPLE1BQTVDO0FBQ0EsWUFBS04sT0FBTCxHQUFlLEtBQWY7QUFDRCxLQVJIO0FBVUQsRzs7Ozt3QkFHUztBQUNSLFVBQU1RLE1BQU0sS0FBS0YsTUFBTCxDQUFZRyxXQUFaLENBQXdCLEdBQXhCLENBQVo7QUFDQSxVQUFJRCxRQUFRLENBQUMsQ0FBYixFQUFnQixPQUFPLEtBQUtGLE1BQUwsQ0FBWUksTUFBWixDQUFtQkYsTUFBTSxDQUF6QixDQUFQO0FBQ2hCLGFBQU8sSUFBUDtBQUNEIiwiZmlsZSI6ImVsZW1lbnRzL2Rpc3BsYXktc291cmNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtiaW5kYWJsZSwgY29tcHV0ZWRGcm9tfSBmcm9tICdhdXJlbGlhLWZyYW1ld29yayc7XG5pbXBvcnQge1BMQVRGT1JNfSBmcm9tICdhdXJlbGlhLXBhbCc7XG5cbmV4cG9ydCBjbGFzcyBEaXNwbGF5U291cmNlIHtcbiAgQGJpbmRhYmxlIHNvdXJjZTtcbiAgZmlsZUNvbnRlbnQgPSAnJztcbiAgbG9hZGluZyA9IGZhbHNlO1xuXG4gIGJpbmQoKSB7XG4gICAgdGhpcy5yZWxvYWRDb250ZW50KCk7XG4gIH1cblxuICBzb3VyY2VDaGFuZ2VkKCkge1xuICAgIHRoaXMucmVsb2FkQ29udGVudCgpO1xuICB9XG5cbiAgcmVsb2FkQ29udGVudCgpIHtcbiAgICB0aGlzLmZpbGVDb250ZW50ID0gJyc7XG4gICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcblxuICAgIFBMQVRGT1JNLmdsb2JhbC5yZXF1aXJlKFtgdGV4dCEuLi8ke3RoaXMuc291cmNlfWBdLFxuICAgICAgY29udGVudCA9PiB7XG4gICAgICAgIHRoaXMuZmlsZUNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuZmlsZUNvbnRlbnQgPSAnRmFpbGVkIHRvIGxvYWQgJyArIHRoaXMuc291cmNlO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgQGNvbXB1dGVkRnJvbSgnc291cmNlJylcbiAgZ2V0IGV4dCgpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnNvdXJjZS5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChpZHggIT09IC0xKSByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic3RyKGlkeCArIDEpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4iXX0=

});

define('text!bcx-doc-base/dist/elements/display-source.html', ['module'], function(module) { module.exports = "<template>\n  <code-viewer value.bind=\"fileContent\" mode.bind=\"ext\"></code-viewer>\n  <div if.bind=\"loading\" class=\"bcx-overlay-spinner\">\n    <i class=\"far fa-circle-notch fa-spin fa-2x fa-fw\"></i>\n  </div>\n</template>\n"; });
define('bcx-doc-base/dist/elements/display-sources',['require','exports','module','aurelia-framework'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.DisplaySources = undefined;

var _desc, _value, _class, _descriptor;

var _aureliaFramework = require('aurelia-framework');

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var DisplaySources = exports.DisplaySources = (_class = function () {
  function DisplaySources() {
    _classCallCheck(this, DisplaySources);

    _initDefineProp(this, 'sources', _descriptor, this);

    this.fullScreen = false;
  }

  DisplaySources.prototype.bind = function bind() {
    if (this.sources && this.sources.length) {
      this.selected = this.sources[0];
    }
  };

  return DisplaySources;
}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'sources', [_aureliaFramework.bindable], {
  enumerable: true,
  initializer: null
})), _class);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVsZW1lbnRzL2Rpc3BsYXktc291cmNlcy5qcyJdLCJuYW1lcyI6WyJEaXNwbGF5U291cmNlcyIsImZ1bGxTY3JlZW4iLCJiaW5kIiwic291cmNlcyIsImxlbmd0aCIsInNlbGVjdGVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRWFBLGMsV0FBQUEsYzs7Ozs7O1NBR1hDLFUsR0FBYSxLOzs7MkJBRWJDLEksbUJBQU87QUFDTCxRQUFJLEtBQUtDLE9BQUwsSUFBZ0IsS0FBS0EsT0FBTCxDQUFhQyxNQUFqQyxFQUF5QztBQUN2QyxXQUFLQyxRQUFMLEdBQWdCLEtBQUtGLE9BQUwsQ0FBYSxDQUFiLENBQWhCO0FBQ0Q7QUFDRixHIiwiZmlsZSI6ImVsZW1lbnRzL2Rpc3BsYXktc291cmNlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YmluZGFibGV9IGZyb20gJ2F1cmVsaWEtZnJhbWV3b3JrJztcblxuZXhwb3J0IGNsYXNzIERpc3BsYXlTb3VyY2VzIHtcbiAgQGJpbmRhYmxlIHNvdXJjZXM7XG4gIHNlbGVjdGVkO1xuICBmdWxsU2NyZWVuID0gZmFsc2U7XG5cbiAgYmluZCgpIHtcbiAgICBpZiAodGhpcy5zb3VyY2VzICYmIHRoaXMuc291cmNlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNvdXJjZXNbMF07XG4gICAgfVxuICB9XG59XG4iXX0=

});

define('text!bcx-doc-base/dist/elements/display-sources.html', ['module'], function(module) { module.exports = "<template>\n  <select class=\"bcx-select\" value.bind=\"selected\">\n    <option repeat.for=\"source of sources\" model.bind=\"source\">${source}</option>\n  </select>\n\n  <display-source class=\"display-source\" if.bind=\"selected\" source.bind=\"selected\"></display-source>\n</template>\n"; });
define('bcx-doc-base/dist/index',['require','exports','module','aurelia-pal'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.configure = configure;

var _aureliaPal = require('aurelia-pal');

function configure(config) {
  config.globalResources([_aureliaPal.PLATFORM.moduleName('./binding-behaviors/left-click'), _aureliaPal.PLATFORM.moduleName('./elements/bcx-doc-nav'), _aureliaPal.PLATFORM.moduleName('./elements/code-viewer'), _aureliaPal.PLATFORM.moduleName('./elements/display-source'), _aureliaPal.PLATFORM.moduleName('./elements/display-sources')]);
}
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbImNvbmZpZ3VyZSIsImNvbmZpZyIsImdsb2JhbFJlc291cmNlcyIsIm1vZHVsZU5hbWUiXSwibWFwcGluZ3MiOiI7OztRQUVnQkEsUyxHQUFBQSxTOztBQUZoQjs7QUFFTyxTQUFTQSxTQUFULENBQW1CQyxNQUFuQixFQUEyQjtBQUNoQ0EsU0FBT0MsZUFBUCxDQUF1QixDQUNyQixxQkFBU0MsVUFBVCxDQUFvQixnQ0FBcEIsQ0FEcUIsRUFFckIscUJBQVNBLFVBQVQsQ0FBb0Isd0JBQXBCLENBRnFCLEVBR3JCLHFCQUFTQSxVQUFULENBQW9CLHdCQUFwQixDQUhxQixFQUlyQixxQkFBU0EsVUFBVCxDQUFvQiwyQkFBcEIsQ0FKcUIsRUFLckIscUJBQVNBLFVBQVQsQ0FBb0IsNEJBQXBCLENBTHFCLENBQXZCO0FBT0QiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1BMQVRGT1JNfSBmcm9tICdhdXJlbGlhLXBhbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25maWd1cmUoY29uZmlnKSB7XG4gIGNvbmZpZy5nbG9iYWxSZXNvdXJjZXMoW1xuICAgIFBMQVRGT1JNLm1vZHVsZU5hbWUoJy4vYmluZGluZy1iZWhhdmlvcnMvbGVmdC1jbGljaycpLFxuICAgIFBMQVRGT1JNLm1vZHVsZU5hbWUoJy4vZWxlbWVudHMvYmN4LWRvYy1uYXYnKSxcbiAgICBQTEFURk9STS5tb2R1bGVOYW1lKCcuL2VsZW1lbnRzL2NvZGUtdmlld2VyJyksXG4gICAgUExBVEZPUk0ubW9kdWxlTmFtZSgnLi9lbGVtZW50cy9kaXNwbGF5LXNvdXJjZScpLFxuICAgIFBMQVRGT1JNLm1vZHVsZU5hbWUoJy4vZWxlbWVudHMvZGlzcGxheS1zb3VyY2VzJyksXG4gIF0pO1xufVxuIl19

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/addon/display/fullscreen',["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineOption("fullScreen", false, function(cm, val, old) {
    if (old == CodeMirror.Init) old = false;
    if (!old == !val) return;
    if (val) setFullscreen(cm);
    else setNormal(cm);
  });

  function setFullscreen(cm) {
    var wrap = cm.getWrapperElement();
    cm.state.fullScreenRestore = {scrollTop: window.pageYOffset, scrollLeft: window.pageXOffset,
                                  width: wrap.style.width, height: wrap.style.height};
    wrap.style.width = "";
    wrap.style.height = "auto";
    wrap.className += " CodeMirror-fullscreen";
    document.documentElement.style.overflow = "hidden";
    cm.refresh();
  }

  function setNormal(cm) {
    var wrap = cm.getWrapperElement();
    wrap.className = wrap.className.replace(/\s*CodeMirror-fullscreen\b/, "");
    document.documentElement.style.overflow = "";
    var info = cm.state.fullScreenRestore;
    wrap.style.width = info.width; wrap.style.height = info.height;
    window.scrollTo(info.scrollLeft, info.scrollTop);
    cm.refresh();
  }
});

define('text!codemirror/addon/display/fullscreen.css', ['module'], function(module) { module.exports = ".CodeMirror-fullscreen {\n  position: fixed;\n  top: 0; left: 0; right: 0; bottom: 0;\n  height: auto;\n  z-index: 9;\n}\n"; });
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define('codemirror/lib/codemirror',factory) :
	(global.CodeMirror = factory());
}(this, (function () { 'use strict';

// Kludges for bugs and behavior differences that can't be feature
// detected are enabled based on userAgent etc sniffing.
var userAgent = navigator.userAgent;
var platform = navigator.platform;

var gecko = /gecko\/\d/i.test(userAgent);
var ie_upto10 = /MSIE \d/.test(userAgent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
var edge = /Edge\/(\d+)/.exec(userAgent);
var ie = ie_upto10 || ie_11up || edge;
var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
var webkit = !edge && /WebKit\//.test(userAgent);
var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
var chrome = !edge && /Chrome\//.test(userAgent);
var presto = /Opera\//.test(userAgent);
var safari = /Apple Computer/.test(navigator.vendor);
var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
var phantom = /PhantomJS/.test(userAgent);

var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
var android = /Android/.test(userAgent);
// This is woefully incomplete. Suggestions for alternative methods welcome.
var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
var mac = ios || /Mac/.test(platform);
var chromeOS = /\bCrOS\b/.test(userAgent);
var windows = /win/i.test(platform);

var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
if (presto_version) { presto_version = Number(presto_version[1]); }
if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
// Some browsers use the wrong event properties to signal cmd/ctrl on OS X
var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
var captureRightClick = gecko || (ie && ie_version >= 9);

function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

var rmClass = function(node, cls) {
  var current = node.className;
  var match = classTest(cls).exec(current);
  if (match) {
    var after = current.slice(match.index + match[0].length);
    node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
  }
};

function removeChildren(e) {
  for (var count = e.childNodes.length; count > 0; --count)
    { e.removeChild(e.firstChild); }
  return e
}

function removeChildrenAndAdd(parent, e) {
  return removeChildren(parent).appendChild(e)
}

function elt(tag, content, className, style) {
  var e = document.createElement(tag);
  if (className) { e.className = className; }
  if (style) { e.style.cssText = style; }
  if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
  return e
}
// wrapper for elt, which removes the elt from the accessibility tree
function eltP(tag, content, className, style) {
  var e = elt(tag, content, className, style);
  e.setAttribute("role", "presentation");
  return e
}

var range;
if (document.createRange) { range = function(node, start, end, endNode) {
  var r = document.createRange();
  r.setEnd(endNode || node, end);
  r.setStart(node, start);
  return r
}; }
else { range = function(node, start, end) {
  var r = document.body.createTextRange();
  try { r.moveToElementText(node.parentNode); }
  catch(e) { return r }
  r.collapse(true);
  r.moveEnd("character", end);
  r.moveStart("character", start);
  return r
}; }

function contains(parent, child) {
  if (child.nodeType == 3) // Android browser always returns false when child is a textnode
    { child = child.parentNode; }
  if (parent.contains)
    { return parent.contains(child) }
  do {
    if (child.nodeType == 11) { child = child.host; }
    if (child == parent) { return true }
  } while (child = child.parentNode)
}

function activeElt() {
  // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
  // IE < 10 will throw when accessed while the page is loading or in an iframe.
  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
  var activeElement;
  try {
    activeElement = document.activeElement;
  } catch(e) {
    activeElement = document.body || null;
  }
  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
    { activeElement = activeElement.shadowRoot.activeElement; }
  return activeElement
}

function addClass(node, cls) {
  var current = node.className;
  if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
}
function joinClasses(a, b) {
  var as = a.split(" ");
  for (var i = 0; i < as.length; i++)
    { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
  return b
}

var selectInput = function(node) { node.select(); };
if (ios) // Mobile Safari apparently has a bug where select() is broken.
  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
else if (ie) // Suppress mysterious IE10 errors
  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

function bind(f) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function(){return f.apply(null, args)}
}

function copyObj(obj, target, overwrite) {
  if (!target) { target = {}; }
  for (var prop in obj)
    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
      { target[prop] = obj[prop]; } }
  return target
}

// Counts the column offset in a string, taking tabs into account.
// Used mostly to find indentation.
function countColumn(string, end, tabSize, startIndex, startValue) {
  if (end == null) {
    end = string.search(/[^\s\u00a0]/);
    if (end == -1) { end = string.length; }
  }
  for (var i = startIndex || 0, n = startValue || 0;;) {
    var nextTab = string.indexOf("\t", i);
    if (nextTab < 0 || nextTab >= end)
      { return n + (end - i) }
    n += nextTab - i;
    n += tabSize - (n % tabSize);
    i = nextTab + 1;
  }
}

var Delayed = function() {this.id = null;};
Delayed.prototype.set = function (ms, f) {
  clearTimeout(this.id);
  this.id = setTimeout(f, ms);
};

function indexOf(array, elt) {
  for (var i = 0; i < array.length; ++i)
    { if (array[i] == elt) { return i } }
  return -1
}

// Number of pixels added to scroller and sizer to hide scrollbar
var scrollerGap = 30;

// Returned or thrown by various protocols to signal 'I'm not
// handling this'.
var Pass = {toString: function(){return "CodeMirror.Pass"}};

// Reused option objects for setSelection & friends
var sel_dontScroll = {scroll: false};
var sel_mouse = {origin: "*mouse"};
var sel_move = {origin: "+move"};

// The inverse of countColumn -- find the offset that corresponds to
// a particular column.
function findColumn(string, goal, tabSize) {
  for (var pos = 0, col = 0;;) {
    var nextTab = string.indexOf("\t", pos);
    if (nextTab == -1) { nextTab = string.length; }
    var skipped = nextTab - pos;
    if (nextTab == string.length || col + skipped >= goal)
      { return pos + Math.min(skipped, goal - col) }
    col += nextTab - pos;
    col += tabSize - (col % tabSize);
    pos = nextTab + 1;
    if (col >= goal) { return pos }
  }
}

var spaceStrs = [""];
function spaceStr(n) {
  while (spaceStrs.length <= n)
    { spaceStrs.push(lst(spaceStrs) + " "); }
  return spaceStrs[n]
}

function lst(arr) { return arr[arr.length-1] }

function map(array, f) {
  var out = [];
  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
  return out
}

function insertSorted(array, value, score) {
  var pos = 0, priority = score(value);
  while (pos < array.length && score(array[pos]) <= priority) { pos++; }
  array.splice(pos, 0, value);
}

function nothing() {}

function createObj(base, props) {
  var inst;
  if (Object.create) {
    inst = Object.create(base);
  } else {
    nothing.prototype = base;
    inst = new nothing();
  }
  if (props) { copyObj(props, inst); }
  return inst
}

var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
function isWordCharBasic(ch) {
  return /\w/.test(ch) || ch > "\x80" &&
    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
}
function isWordChar(ch, helper) {
  if (!helper) { return isWordCharBasic(ch) }
  if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
  return helper.test(ch)
}

function isEmpty(obj) {
  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
  return true
}

// Extending unicode characters. A series of a non-extending char +
// any number of extending chars is treated as a single unit as far
// as editing and measuring is concerned. This is not fully correct,
// since some scripts/fonts/browsers also treat other configurations
// of code points as a group.
var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
function skipExtendingChars(str, pos, dir) {
  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
  return pos
}

// Returns the value from the range [`from`; `to`] that satisfies
// `pred` and is closest to `from`. Assumes that at least `to`
// satisfies `pred`. Supports `from` being greater than `to`.
function findFirst(pred, from, to) {
  // At any point we are certain `to` satisfies `pred`, don't know
  // whether `from` does.
  var dir = from > to ? -1 : 1;
  for (;;) {
    if (from == to) { return from }
    var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
    if (mid == from) { return pred(mid) ? from : to }
    if (pred(mid)) { to = mid; }
    else { from = mid + dir; }
  }
}

// The display handles the DOM integration, both for input reading
// and content drawing. It holds references to DOM nodes and
// display-related state.

function Display(place, doc, input) {
  var d = this;
  this.input = input;

  // Covers bottom-right square when both scrollbars are present.
  d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
  d.scrollbarFiller.setAttribute("cm-not-content", "true");
  // Covers bottom of gutter when coverGutterNextToScrollbar is on
  // and h scrollbar is present.
  d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
  d.gutterFiller.setAttribute("cm-not-content", "true");
  // Will contain the actual code, positioned to cover the viewport.
  d.lineDiv = eltP("div", null, "CodeMirror-code");
  // Elements are added to these to represent selection and cursors.
  d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
  d.cursorDiv = elt("div", null, "CodeMirror-cursors");
  // A visibility: hidden element used to find the size of things.
  d.measure = elt("div", null, "CodeMirror-measure");
  // When lines outside of the viewport are measured, they are drawn in this.
  d.lineMeasure = elt("div", null, "CodeMirror-measure");
  // Wraps everything that needs to exist inside the vertically-padded coordinate system
  d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                    null, "position: relative; outline: none");
  var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
  // Moved around its parent to cover visible view.
  d.mover = elt("div", [lines], null, "position: relative");
  // Set to the height of the document, allowing scrolling.
  d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
  d.sizerWidth = null;
  // Behavior of elts with overflow: auto and padding is
  // inconsistent across browsers. This is used to ensure the
  // scrollable area is big enough.
  d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
  // Will contain the gutters, if any.
  d.gutters = elt("div", null, "CodeMirror-gutters");
  d.lineGutter = null;
  // Actual scrollable element.
  d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
  d.scroller.setAttribute("tabIndex", "-1");
  // The element in which the editor lives.
  d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

  if (place) {
    if (place.appendChild) { place.appendChild(d.wrapper); }
    else { place(d.wrapper); }
  }

  // Current rendered range (may be bigger than the view window).
  d.viewFrom = d.viewTo = doc.first;
  d.reportedViewFrom = d.reportedViewTo = doc.first;
  // Information about the rendered lines.
  d.view = [];
  d.renderedView = null;
  // Holds info about a single rendered line when it was rendered
  // for measurement, while not in view.
  d.externalMeasured = null;
  // Empty space (in pixels) above the view
  d.viewOffset = 0;
  d.lastWrapHeight = d.lastWrapWidth = 0;
  d.updateLineNumbers = null;

  d.nativeBarWidth = d.barHeight = d.barWidth = 0;
  d.scrollbarsClipped = false;

  // Used to only resize the line number gutter when necessary (when
  // the amount of lines crosses a boundary that makes its width change)
  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
  // Set to true when a non-horizontal-scrolling line widget is
  // added. As an optimization, line widget aligning is skipped when
  // this is false.
  d.alignWidgets = false;

  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

  // Tracks the maximum line length so that the horizontal scrollbar
  // can be kept static when scrolling.
  d.maxLine = null;
  d.maxLineLength = 0;
  d.maxLineChanged = false;

  // Used for measuring wheel scrolling granularity
  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

  // True when shift is held down.
  d.shift = false;

  // Used to track whether anything happened since the context menu
  // was opened.
  d.selForContextMenu = null;

  d.activeTouch = null;

  input.init(d);
}

// Find the line object corresponding to the given line number.
function getLine(doc, n) {
  n -= doc.first;
  if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
  var chunk = doc;
  while (!chunk.lines) {
    for (var i = 0;; ++i) {
      var child = chunk.children[i], sz = child.chunkSize();
      if (n < sz) { chunk = child; break }
      n -= sz;
    }
  }
  return chunk.lines[n]
}

// Get the part of a document between two positions, as an array of
// strings.
function getBetween(doc, start, end) {
  var out = [], n = start.line;
  doc.iter(start.line, end.line + 1, function (line) {
    var text = line.text;
    if (n == end.line) { text = text.slice(0, end.ch); }
    if (n == start.line) { text = text.slice(start.ch); }
    out.push(text);
    ++n;
  });
  return out
}
// Get the lines between from and to, as array of strings.
function getLines(doc, from, to) {
  var out = [];
  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
  return out
}

// Update the height of a line, propagating the height change
// upwards to parent nodes.
function updateLineHeight(line, height) {
  var diff = height - line.height;
  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
}

// Given a line object, find its line number by walking up through
// its parent links.
function lineNo(line) {
  if (line.parent == null) { return null }
  var cur = line.parent, no = indexOf(cur.lines, line);
  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
    for (var i = 0;; ++i) {
      if (chunk.children[i] == cur) { break }
      no += chunk.children[i].chunkSize();
    }
  }
  return no + cur.first
}

// Find the line at the given vertical position, using the height
// information in the document tree.
function lineAtHeight(chunk, h) {
  var n = chunk.first;
  outer: do {
    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
      var child = chunk.children[i$1], ch = child.height;
      if (h < ch) { chunk = child; continue outer }
      h -= ch;
      n += child.chunkSize();
    }
    return n
  } while (!chunk.lines)
  var i = 0;
  for (; i < chunk.lines.length; ++i) {
    var line = chunk.lines[i], lh = line.height;
    if (h < lh) { break }
    h -= lh;
  }
  return n + i
}

function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

function lineNumberFor(options, i) {
  return String(options.lineNumberFormatter(i + options.firstLineNumber))
}

// A Pos instance represents a position within the text.
function Pos(line, ch, sticky) {
  if ( sticky === void 0 ) sticky = null;

  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
  this.line = line;
  this.ch = ch;
  this.sticky = sticky;
}

// Compare two positions, return 0 if they are the same, a negative
// number when a is less, and a positive number otherwise.
function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

function copyPos(x) {return Pos(x.line, x.ch)}
function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

// Most of the external API clips given positions to make sure they
// actually exist within the document.
function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
function clipPos(doc, pos) {
  if (pos.line < doc.first) { return Pos(doc.first, 0) }
  var last = doc.first + doc.size - 1;
  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
  return clipToLen(pos, getLine(doc, pos.line).text.length)
}
function clipToLen(pos, linelen) {
  var ch = pos.ch;
  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
  else if (ch < 0) { return Pos(pos.line, 0) }
  else { return pos }
}
function clipPosArray(doc, array) {
  var out = [];
  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
  return out
}

// Optimize some code when these features are not used.
var sawReadOnlySpans = false;
var sawCollapsedSpans = false;

function seeReadOnlySpans() {
  sawReadOnlySpans = true;
}

function seeCollapsedSpans() {
  sawCollapsedSpans = true;
}

// TEXTMARKER SPANS

function MarkedSpan(marker, from, to) {
  this.marker = marker;
  this.from = from; this.to = to;
}

// Search an array of spans for a span matching the given marker.
function getMarkedSpanFor(spans, marker) {
  if (spans) { for (var i = 0; i < spans.length; ++i) {
    var span = spans[i];
    if (span.marker == marker) { return span }
  } }
}
// Remove a span from an array, returning undefined if no spans are
// left (we don't store arrays for lines without spans).
function removeMarkedSpan(spans, span) {
  var r;
  for (var i = 0; i < spans.length; ++i)
    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
  return r
}
// Add a span to a line.
function addMarkedSpan(line, span) {
  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
  span.marker.attachLine(line);
}

// Used for the algorithm that adjusts markers for a change in the
// document. These functions cut an array of spans at a given
// character position, returning an array of remaining chunks (or
// undefined if nothing remains).
function markedSpansBefore(old, startCh, isInsert) {
  var nw;
  if (old) { for (var i = 0; i < old.length; ++i) {
    var span = old[i], marker = span.marker;
    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
    if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
    }
  } }
  return nw
}
function markedSpansAfter(old, endCh, isInsert) {
  var nw;
  if (old) { for (var i = 0; i < old.length; ++i) {
    var span = old[i], marker = span.marker;
    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
    if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                            span.to == null ? null : span.to - endCh));
    }
  } }
  return nw
}

// Given a change object, compute the new set of marker spans that
// cover the line in which the change took place. Removes spans
// entirely within the change, reconnects spans belonging to the
// same marker that appear on both sides of the change, and cuts off
// spans partially within the change. Returns an array of span
// arrays with one element for each line in (after) the change.
function stretchSpansOverChange(doc, change) {
  if (change.full) { return null }
  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
  if (!oldFirst && !oldLast) { return null }

  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
  // Get the spans that 'stick out' on both sides
  var first = markedSpansBefore(oldFirst, startCh, isInsert);
  var last = markedSpansAfter(oldLast, endCh, isInsert);

  // Next, merge those two ends
  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
  if (first) {
    // Fix up .to properties of first
    for (var i = 0; i < first.length; ++i) {
      var span = first[i];
      if (span.to == null) {
        var found = getMarkedSpanFor(last, span.marker);
        if (!found) { span.to = startCh; }
        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
      }
    }
  }
  if (last) {
    // Fix up .from in last (or move them into first in case of sameLine)
    for (var i$1 = 0; i$1 < last.length; ++i$1) {
      var span$1 = last[i$1];
      if (span$1.to != null) { span$1.to += offset; }
      if (span$1.from == null) {
        var found$1 = getMarkedSpanFor(first, span$1.marker);
        if (!found$1) {
          span$1.from = offset;
          if (sameLine) { (first || (first = [])).push(span$1); }
        }
      } else {
        span$1.from += offset;
        if (sameLine) { (first || (first = [])).push(span$1); }
      }
    }
  }
  // Make sure we didn't create any zero-length spans
  if (first) { first = clearEmptySpans(first); }
  if (last && last != first) { last = clearEmptySpans(last); }

  var newMarkers = [first];
  if (!sameLine) {
    // Fill gap with whole-line-spans
    var gap = change.text.length - 2, gapMarkers;
    if (gap > 0 && first)
      { for (var i$2 = 0; i$2 < first.length; ++i$2)
        { if (first[i$2].to == null)
          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
    for (var i$3 = 0; i$3 < gap; ++i$3)
      { newMarkers.push(gapMarkers); }
    newMarkers.push(last);
  }
  return newMarkers
}

// Remove spans that are empty and don't have a clearWhenEmpty
// option of false.
function clearEmptySpans(spans) {
  for (var i = 0; i < spans.length; ++i) {
    var span = spans[i];
    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
      { spans.splice(i--, 1); }
  }
  if (!spans.length) { return null }
  return spans
}

// Used to 'clip' out readOnly ranges when making a change.
function removeReadOnlyRanges(doc, from, to) {
  var markers = null;
  doc.iter(from.line, to.line + 1, function (line) {
    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
      var mark = line.markedSpans[i].marker;
      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
        { (markers || (markers = [])).push(mark); }
    } }
  });
  if (!markers) { return null }
  var parts = [{from: from, to: to}];
  for (var i = 0; i < markers.length; ++i) {
    var mk = markers[i], m = mk.find(0);
    for (var j = 0; j < parts.length; ++j) {
      var p = parts[j];
      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
        { newParts.push({from: p.from, to: m.from}); }
      if (dto > 0 || !mk.inclusiveRight && !dto)
        { newParts.push({from: m.to, to: p.to}); }
      parts.splice.apply(parts, newParts);
      j += newParts.length - 3;
    }
  }
  return parts
}

// Connect or disconnect spans from a line.
function detachMarkedSpans(line) {
  var spans = line.markedSpans;
  if (!spans) { return }
  for (var i = 0; i < spans.length; ++i)
    { spans[i].marker.detachLine(line); }
  line.markedSpans = null;
}
function attachMarkedSpans(line, spans) {
  if (!spans) { return }
  for (var i = 0; i < spans.length; ++i)
    { spans[i].marker.attachLine(line); }
  line.markedSpans = spans;
}

// Helpers used when computing which overlapping collapsed span
// counts as the larger one.
function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

// Returns a number indicating which of two overlapping collapsed
// spans is larger (and thus includes the other). Falls back to
// comparing ids when the spans cover exactly the same range.
function compareCollapsedMarkers(a, b) {
  var lenDiff = a.lines.length - b.lines.length;
  if (lenDiff != 0) { return lenDiff }
  var aPos = a.find(), bPos = b.find();
  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
  if (fromCmp) { return -fromCmp }
  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
  if (toCmp) { return toCmp }
  return b.id - a.id
}

// Find out whether a line ends or starts in a collapsed span. If
// so, return the marker for that span.
function collapsedSpanAtSide(line, start) {
  var sps = sawCollapsedSpans && line.markedSpans, found;
  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
    sp = sps[i];
    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
        (!found || compareCollapsedMarkers(found, sp.marker) < 0))
      { found = sp.marker; }
  } }
  return found
}
function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

// Test whether there exists a collapsed span that partially
// overlaps (covers the start or end, but not both) of a new span.
// Such overlap is not allowed.
function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
  var line = getLine(doc, lineNo$$1);
  var sps = sawCollapsedSpans && line.markedSpans;
  if (sps) { for (var i = 0; i < sps.length; ++i) {
    var sp = sps[i];
    if (!sp.marker.collapsed) { continue }
    var found = sp.marker.find(0);
    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
      { return true }
  } }
}

// A visual line is a line as drawn on the screen. Folding, for
// example, can cause multiple logical lines to appear on the same
// visual line. This finds the start of the visual line that the
// given line is part of (usually that is the line itself).
function visualLine(line) {
  var merged;
  while (merged = collapsedSpanAtStart(line))
    { line = merged.find(-1, true).line; }
  return line
}

function visualLineEnd(line) {
  var merged;
  while (merged = collapsedSpanAtEnd(line))
    { line = merged.find(1, true).line; }
  return line
}

// Returns an array of logical lines that continue the visual line
// started by the argument, or undefined if there are no such lines.
function visualLineContinued(line) {
  var merged, lines;
  while (merged = collapsedSpanAtEnd(line)) {
    line = merged.find(1, true).line
    ;(lines || (lines = [])).push(line);
  }
  return lines
}

// Get the line number of the start of the visual line that the
// given line number is part of.
function visualLineNo(doc, lineN) {
  var line = getLine(doc, lineN), vis = visualLine(line);
  if (line == vis) { return lineN }
  return lineNo(vis)
}

// Get the line number of the start of the next visual line after
// the given line.
function visualLineEndNo(doc, lineN) {
  if (lineN > doc.lastLine()) { return lineN }
  var line = getLine(doc, lineN), merged;
  if (!lineIsHidden(doc, line)) { return lineN }
  while (merged = collapsedSpanAtEnd(line))
    { line = merged.find(1, true).line; }
  return lineNo(line) + 1
}

// Compute whether a line is hidden. Lines count as hidden when they
// are part of a visual line that starts with another line, or when
// they are entirely covered by collapsed, non-widget span.
function lineIsHidden(doc, line) {
  var sps = sawCollapsedSpans && line.markedSpans;
  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
    sp = sps[i];
    if (!sp.marker.collapsed) { continue }
    if (sp.from == null) { return true }
    if (sp.marker.widgetNode) { continue }
    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
      { return true }
  } }
}
function lineIsHiddenInner(doc, line, span) {
  if (span.to == null) {
    var end = span.marker.find(1, true);
    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
  }
  if (span.marker.inclusiveRight && span.to == line.text.length)
    { return true }
  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
    sp = line.markedSpans[i];
    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
        (sp.to == null || sp.to != span.from) &&
        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
        lineIsHiddenInner(doc, line, sp)) { return true }
  }
}

// Find the height above the given line.
function heightAtLine(lineObj) {
  lineObj = visualLine(lineObj);

  var h = 0, chunk = lineObj.parent;
  for (var i = 0; i < chunk.lines.length; ++i) {
    var line = chunk.lines[i];
    if (line == lineObj) { break }
    else { h += line.height; }
  }
  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
      var cur = p.children[i$1];
      if (cur == chunk) { break }
      else { h += cur.height; }
    }
  }
  return h
}

// Compute the character length of a line, taking into account
// collapsed ranges (see markText) that might hide parts, and join
// other lines onto it.
function lineLength(line) {
  if (line.height == 0) { return 0 }
  var len = line.text.length, merged, cur = line;
  while (merged = collapsedSpanAtStart(cur)) {
    var found = merged.find(0, true);
    cur = found.from.line;
    len += found.from.ch - found.to.ch;
  }
  cur = line;
  while (merged = collapsedSpanAtEnd(cur)) {
    var found$1 = merged.find(0, true);
    len -= cur.text.length - found$1.from.ch;
    cur = found$1.to.line;
    len += cur.text.length - found$1.to.ch;
  }
  return len
}

// Find the longest line in the document.
function findMaxLine(cm) {
  var d = cm.display, doc = cm.doc;
  d.maxLine = getLine(doc, doc.first);
  d.maxLineLength = lineLength(d.maxLine);
  d.maxLineChanged = true;
  doc.iter(function (line) {
    var len = lineLength(line);
    if (len > d.maxLineLength) {
      d.maxLineLength = len;
      d.maxLine = line;
    }
  });
}

// BIDI HELPERS

function iterateBidiSections(order, from, to, f) {
  if (!order) { return f(from, to, "ltr", 0) }
  var found = false;
  for (var i = 0; i < order.length; ++i) {
    var part = order[i];
    if (part.from < to && part.to > from || from == to && part.to == from) {
      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
      found = true;
    }
  }
  if (!found) { f(from, to, "ltr"); }
}

var bidiOther = null;
function getBidiPartAt(order, ch, sticky) {
  var found;
  bidiOther = null;
  for (var i = 0; i < order.length; ++i) {
    var cur = order[i];
    if (cur.from < ch && cur.to > ch) { return i }
    if (cur.to == ch) {
      if (cur.from != cur.to && sticky == "before") { found = i; }
      else { bidiOther = i; }
    }
    if (cur.from == ch) {
      if (cur.from != cur.to && sticky != "before") { found = i; }
      else { bidiOther = i; }
    }
  }
  return found != null ? found : bidiOther
}

// Bidirectional ordering algorithm
// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
// that this (partially) implements.

// One-char codes used for character types:
// L (L):   Left-to-Right
// R (R):   Right-to-Left
// r (AL):  Right-to-Left Arabic
// 1 (EN):  European Number
// + (ES):  European Number Separator
// % (ET):  European Number Terminator
// n (AN):  Arabic Number
// , (CS):  Common Number Separator
// m (NSM): Non-Spacing Mark
// b (BN):  Boundary Neutral
// s (B):   Paragraph Separator
// t (S):   Segment Separator
// w (WS):  Whitespace
// N (ON):  Other Neutrals

// Returns null if characters are ordered as they appear
// (left-to-right), or an array of sections ({from, to, level}
// objects) in the order in which they occur visually.
var bidiOrdering = (function() {
  // Character types for codepoints 0 to 0xff
  var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
  // Character types for codepoints 0x600 to 0x6f9
  var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
  function charType(code) {
    if (code <= 0xf7) { return lowTypes.charAt(code) }
    else if (0x590 <= code && code <= 0x5f4) { return "R" }
    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
    else if (0x6ee <= code && code <= 0x8ac) { return "r" }
    else if (0x2000 <= code && code <= 0x200b) { return "w" }
    else if (code == 0x200c) { return "b" }
    else { return "L" }
  }

  var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

  function BidiSpan(level, from, to) {
    this.level = level;
    this.from = from; this.to = to;
  }

  return function(str, direction) {
    var outerType = direction == "ltr" ? "L" : "R";

    if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
    var len = str.length, types = [];
    for (var i = 0; i < len; ++i)
      { types.push(charType(str.charCodeAt(i))); }

    // W1. Examine each non-spacing mark (NSM) in the level run, and
    // change the type of the NSM to the type of the previous
    // character. If the NSM is at the start of the level run, it will
    // get the type of sor.
    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
      var type = types[i$1];
      if (type == "m") { types[i$1] = prev; }
      else { prev = type; }
    }

    // W2. Search backwards from each instance of a European number
    // until the first strong type (R, L, AL, or sor) is found. If an
    // AL is found, change the type of the European number to Arabic
    // number.
    // W3. Change all ALs to R.
    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
      var type$1 = types[i$2];
      if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
    }

    // W4. A single European separator between two European numbers
    // changes to a European number. A single common separator between
    // two numbers of the same type changes to that type.
    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
      var type$2 = types[i$3];
      if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
      else if (type$2 == "," && prev$1 == types[i$3+1] &&
               (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
      prev$1 = type$2;
    }

    // W5. A sequence of European terminators adjacent to European
    // numbers changes to all European numbers.
    // W6. Otherwise, separators and terminators change to Other
    // Neutral.
    for (var i$4 = 0; i$4 < len; ++i$4) {
      var type$3 = types[i$4];
      if (type$3 == ",") { types[i$4] = "N"; }
      else if (type$3 == "%") {
        var end = (void 0);
        for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
        var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
        for (var j = i$4; j < end; ++j) { types[j] = replace; }
        i$4 = end - 1;
      }
    }

    // W7. Search backwards from each instance of a European number
    // until the first strong type (R, L, or sor) is found. If an L is
    // found, then change the type of the European number to L.
    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
      var type$4 = types[i$5];
      if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
      else if (isStrong.test(type$4)) { cur$1 = type$4; }
    }

    // N1. A sequence of neutrals takes the direction of the
    // surrounding strong text if the text on both sides has the same
    // direction. European and Arabic numbers act as if they were R in
    // terms of their influence on neutrals. Start-of-level-run (sor)
    // and end-of-level-run (eor) are used at level run boundaries.
    // N2. Any remaining neutrals take the embedding direction.
    for (var i$6 = 0; i$6 < len; ++i$6) {
      if (isNeutral.test(types[i$6])) {
        var end$1 = (void 0);
        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
        var before = (i$6 ? types[i$6-1] : outerType) == "L";
        var after = (end$1 < len ? types[end$1] : outerType) == "L";
        var replace$1 = before == after ? (before ? "L" : "R") : outerType;
        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
        i$6 = end$1 - 1;
      }
    }

    // Here we depart from the documented algorithm, in order to avoid
    // building up an actual levels array. Since there are only three
    // levels (0, 1, 2) in an implementation that doesn't take
    // explicit embedding into account, we can build up the order on
    // the fly, without following the level-based algorithm.
    var order = [], m;
    for (var i$7 = 0; i$7 < len;) {
      if (countsAsLeft.test(types[i$7])) {
        var start = i$7;
        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
        order.push(new BidiSpan(0, start, i$7));
      } else {
        var pos = i$7, at = order.length;
        for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
        for (var j$2 = pos; j$2 < i$7;) {
          if (countsAsNum.test(types[j$2])) {
            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }
            var nstart = j$2;
            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
            order.splice(at, 0, new BidiSpan(2, nstart, j$2));
            pos = j$2;
          } else { ++j$2; }
        }
        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
      }
    }
    if (direction == "ltr") {
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
    }

    return direction == "rtl" ? order.reverse() : order
  }
})();

// Get the bidi ordering for the given line (and cache it). Returns
// false for lines that are fully left-to-right, and an array of
// BidiSpan objects otherwise.
function getOrder(line, direction) {
  var order = line.order;
  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
  return order
}

// EVENT HANDLING

// Lightweight event framework. on/off also work on DOM nodes,
// registering native DOM handlers.

var noHandlers = [];

var on = function(emitter, type, f) {
  if (emitter.addEventListener) {
    emitter.addEventListener(type, f, false);
  } else if (emitter.attachEvent) {
    emitter.attachEvent("on" + type, f);
  } else {
    var map$$1 = emitter._handlers || (emitter._handlers = {});
    map$$1[type] = (map$$1[type] || noHandlers).concat(f);
  }
};

function getHandlers(emitter, type) {
  return emitter._handlers && emitter._handlers[type] || noHandlers
}

function off(emitter, type, f) {
  if (emitter.removeEventListener) {
    emitter.removeEventListener(type, f, false);
  } else if (emitter.detachEvent) {
    emitter.detachEvent("on" + type, f);
  } else {
    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
    if (arr) {
      var index = indexOf(arr, f);
      if (index > -1)
        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
    }
  }
}

function signal(emitter, type /*, values...*/) {
  var handlers = getHandlers(emitter, type);
  if (!handlers.length) { return }
  var args = Array.prototype.slice.call(arguments, 2);
  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
}

// The DOM events that CodeMirror handles can be overridden by
// registering a (non-DOM) handler on the editor for the event name,
// and preventDefault-ing the event in that handler.
function signalDOMEvent(cm, e, override) {
  if (typeof e == "string")
    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
  signal(cm, override || e.type, cm, e);
  return e_defaultPrevented(e) || e.codemirrorIgnore
}

function signalCursorActivity(cm) {
  var arr = cm._handlers && cm._handlers.cursorActivity;
  if (!arr) { return }
  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
    { set.push(arr[i]); } }
}

function hasHandler(emitter, type) {
  return getHandlers(emitter, type).length > 0
}

// Add on and off methods to a constructor's prototype, to make
// registering events on such objects more convenient.
function eventMixin(ctor) {
  ctor.prototype.on = function(type, f) {on(this, type, f);};
  ctor.prototype.off = function(type, f) {off(this, type, f);};
}

// Due to the fact that we still support jurassic IE versions, some
// compatibility wrappers are needed.

function e_preventDefault(e) {
  if (e.preventDefault) { e.preventDefault(); }
  else { e.returnValue = false; }
}
function e_stopPropagation(e) {
  if (e.stopPropagation) { e.stopPropagation(); }
  else { e.cancelBubble = true; }
}
function e_defaultPrevented(e) {
  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
}
function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

function e_target(e) {return e.target || e.srcElement}
function e_button(e) {
  var b = e.which;
  if (b == null) {
    if (e.button & 1) { b = 1; }
    else if (e.button & 2) { b = 3; }
    else if (e.button & 4) { b = 2; }
  }
  if (mac && e.ctrlKey && b == 1) { b = 3; }
  return b
}

// Detect drag-and-drop
var dragAndDrop = function() {
  // There is *some* kind of drag-and-drop support in IE6-8, but I
  // couldn't get it to work yet.
  if (ie && ie_version < 9) { return false }
  var div = elt('div');
  return "draggable" in div || "dragDrop" in div
}();

var zwspSupported;
function zeroWidthElement(measure) {
  if (zwspSupported == null) {
    var test = elt("span", "\u200b");
    removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
    if (measure.firstChild.offsetHeight != 0)
      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
  }
  var node = zwspSupported ? elt("span", "\u200b") :
    elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
  node.setAttribute("cm-text", "");
  return node
}

// Feature-detect IE's crummy client rect reporting for bidi text
var badBidiRects;
function hasBadBidiRects(measure) {
  if (badBidiRects != null) { return badBidiRects }
  var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
  var r0 = range(txt, 0, 1).getBoundingClientRect();
  var r1 = range(txt, 1, 2).getBoundingClientRect();
  removeChildren(measure);
  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
  return badBidiRects = (r1.right - r0.right < 3)
}

// See if "".split is the broken IE version, if so, provide an
// alternative way to split lines.
var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
  var pos = 0, result = [], l = string.length;
  while (pos <= l) {
    var nl = string.indexOf("\n", pos);
    if (nl == -1) { nl = string.length; }
    var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
    var rt = line.indexOf("\r");
    if (rt != -1) {
      result.push(line.slice(0, rt));
      pos += rt + 1;
    } else {
      result.push(line);
      pos = nl + 1;
    }
  }
  return result
} : function (string) { return string.split(/\r\n?|\n/); };

var hasSelection = window.getSelection ? function (te) {
  try { return te.selectionStart != te.selectionEnd }
  catch(e) { return false }
} : function (te) {
  var range$$1;
  try {range$$1 = te.ownerDocument.selection.createRange();}
  catch(e) {}
  if (!range$$1 || range$$1.parentElement() != te) { return false }
  return range$$1.compareEndPoints("StartToEnd", range$$1) != 0
};

var hasCopyEvent = (function () {
  var e = elt("div");
  if ("oncopy" in e) { return true }
  e.setAttribute("oncopy", "return;");
  return typeof e.oncopy == "function"
})();

var badZoomedRects = null;
function hasBadZoomedRects(measure) {
  if (badZoomedRects != null) { return badZoomedRects }
  var node = removeChildrenAndAdd(measure, elt("span", "x"));
  var normal = node.getBoundingClientRect();
  var fromRange = range(node, 0, 1).getBoundingClientRect();
  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
}

// Known modes, by name and by MIME
var modes = {};
var mimeModes = {};

// Extra arguments are stored as the mode's dependencies, which is
// used by (legacy) mechanisms like loadmode.js to automatically
// load a mode. (Preferred mechanism is the require/define calls.)
function defineMode(name, mode) {
  if (arguments.length > 2)
    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
  modes[name] = mode;
}

function defineMIME(mime, spec) {
  mimeModes[mime] = spec;
}

// Given a MIME type, a {name, ...options} config object, or a name
// string, return a mode config object.
function resolveMode(spec) {
  if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
    spec = mimeModes[spec];
  } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
    var found = mimeModes[spec.name];
    if (typeof found == "string") { found = {name: found}; }
    spec = createObj(found, spec);
    spec.name = found.name;
  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
    return resolveMode("application/xml")
  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
    return resolveMode("application/json")
  }
  if (typeof spec == "string") { return {name: spec} }
  else { return spec || {name: "null"} }
}

// Given a mode spec (anything that resolveMode accepts), find and
// initialize an actual mode object.
function getMode(options, spec) {
  spec = resolveMode(spec);
  var mfactory = modes[spec.name];
  if (!mfactory) { return getMode(options, "text/plain") }
  var modeObj = mfactory(options, spec);
  if (modeExtensions.hasOwnProperty(spec.name)) {
    var exts = modeExtensions[spec.name];
    for (var prop in exts) {
      if (!exts.hasOwnProperty(prop)) { continue }
      if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
      modeObj[prop] = exts[prop];
    }
  }
  modeObj.name = spec.name;
  if (spec.helperType) { modeObj.helperType = spec.helperType; }
  if (spec.modeProps) { for (var prop$1 in spec.modeProps)
    { modeObj[prop$1] = spec.modeProps[prop$1]; } }

  return modeObj
}

// This can be used to attach properties to mode objects from
// outside the actual mode definition.
var modeExtensions = {};
function extendMode(mode, properties) {
  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
  copyObj(properties, exts);
}

function copyState(mode, state) {
  if (state === true) { return state }
  if (mode.copyState) { return mode.copyState(state) }
  var nstate = {};
  for (var n in state) {
    var val = state[n];
    if (val instanceof Array) { val = val.concat([]); }
    nstate[n] = val;
  }
  return nstate
}

// Given a mode and a state (for that mode), find the inner mode and
// state at the position that the state refers to.
function innerMode(mode, state) {
  var info;
  while (mode.innerMode) {
    info = mode.innerMode(state);
    if (!info || info.mode == mode) { break }
    state = info.state;
    mode = info.mode;
  }
  return info || {mode: mode, state: state}
}

function startState(mode, a1, a2) {
  return mode.startState ? mode.startState(a1, a2) : true
}

// STRING STREAM

// Fed to the mode parsers, provides helper functions to make
// parsers more succinct.

var StringStream = function(string, tabSize, lineOracle) {
  this.pos = this.start = 0;
  this.string = string;
  this.tabSize = tabSize || 8;
  this.lastColumnPos = this.lastColumnValue = 0;
  this.lineStart = 0;
  this.lineOracle = lineOracle;
};

StringStream.prototype.eol = function () {return this.pos >= this.string.length};
StringStream.prototype.sol = function () {return this.pos == this.lineStart};
StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
StringStream.prototype.next = function () {
  if (this.pos < this.string.length)
    { return this.string.charAt(this.pos++) }
};
StringStream.prototype.eat = function (match) {
  var ch = this.string.charAt(this.pos);
  var ok;
  if (typeof match == "string") { ok = ch == match; }
  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
  if (ok) {++this.pos; return ch}
};
StringStream.prototype.eatWhile = function (match) {
  var start = this.pos;
  while (this.eat(match)){}
  return this.pos > start
};
StringStream.prototype.eatSpace = function () {
    var this$1 = this;

  var start = this.pos;
  while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }
  return this.pos > start
};
StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
StringStream.prototype.skipTo = function (ch) {
  var found = this.string.indexOf(ch, this.pos);
  if (found > -1) {this.pos = found; return true}
};
StringStream.prototype.backUp = function (n) {this.pos -= n;};
StringStream.prototype.column = function () {
  if (this.lastColumnPos < this.start) {
    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
    this.lastColumnPos = this.start;
  }
  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
};
StringStream.prototype.indentation = function () {
  return countColumn(this.string, null, this.tabSize) -
    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
};
StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
  if (typeof pattern == "string") {
    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
    var substr = this.string.substr(this.pos, pattern.length);
    if (cased(substr) == cased(pattern)) {
      if (consume !== false) { this.pos += pattern.length; }
      return true
    }
  } else {
    var match = this.string.slice(this.pos).match(pattern);
    if (match && match.index > 0) { return null }
    if (match && consume !== false) { this.pos += match[0].length; }
    return match
  }
};
StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
StringStream.prototype.hideFirstChars = function (n, inner) {
  this.lineStart += n;
  try { return inner() }
  finally { this.lineStart -= n; }
};
StringStream.prototype.lookAhead = function (n) {
  var oracle = this.lineOracle;
  return oracle && oracle.lookAhead(n)
};
StringStream.prototype.baseToken = function () {
  var oracle = this.lineOracle;
  return oracle && oracle.baseToken(this.pos)
};

var SavedContext = function(state, lookAhead) {
  this.state = state;
  this.lookAhead = lookAhead;
};

var Context = function(doc, state, line, lookAhead) {
  this.state = state;
  this.doc = doc;
  this.line = line;
  this.maxLookAhead = lookAhead || 0;
  this.baseTokens = null;
  this.baseTokenPos = 1;
};

Context.prototype.lookAhead = function (n) {
  var line = this.doc.getLine(this.line + n);
  if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
  return line
};

Context.prototype.baseToken = function (n) {
    var this$1 = this;

  if (!this.baseTokens) { return null }
  while (this.baseTokens[this.baseTokenPos] <= n)
    { this$1.baseTokenPos += 2; }
  var type = this.baseTokens[this.baseTokenPos + 1];
  return {type: type && type.replace(/( |^)overlay .*/, ""),
          size: this.baseTokens[this.baseTokenPos] - n}
};

Context.prototype.nextLine = function () {
  this.line++;
  if (this.maxLookAhead > 0) { this.maxLookAhead--; }
};

Context.fromSaved = function (doc, saved, line) {
  if (saved instanceof SavedContext)
    { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
  else
    { return new Context(doc, copyState(doc.mode, saved), line) }
};

Context.prototype.save = function (copy) {
  var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
  return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
};


// Compute a style array (an array starting with a mode generation
// -- for invalidation -- followed by pairs of end positions and
// style strings), which is used to highlight the tokens on the
// line.
function highlightLine(cm, line, context, forceToEnd) {
  // A styles array always starts with a number identifying the
  // mode/overlays that it is based on (for easy invalidation).
  var st = [cm.state.modeGen], lineClasses = {};
  // Compute the base array of styles
  runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
          lineClasses, forceToEnd);
  var state = context.state;

  // Run overlays, adjust style array.
  var loop = function ( o ) {
    context.baseTokens = st;
    var overlay = cm.state.overlays[o], i = 1, at = 0;
    context.state = true;
    runMode(cm, line.text, overlay.mode, context, function (end, style) {
      var start = i;
      // Ensure there's a token end at the current position, and that i points at it
      while (at < end) {
        var i_end = st[i];
        if (i_end > end)
          { st.splice(i, 1, end, st[i+1], i_end); }
        i += 2;
        at = Math.min(end, i_end);
      }
      if (!style) { return }
      if (overlay.opaque) {
        st.splice(start, i - start, end, "overlay " + style);
        i = start + 2;
      } else {
        for (; start < i; start += 2) {
          var cur = st[start+1];
          st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
        }
      }
    }, lineClasses);
    context.state = state;
    context.baseTokens = null;
    context.baseTokenPos = 1;
  };

  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
}

function getLineStyles(cm, line, updateFrontier) {
  if (!line.styles || line.styles[0] != cm.state.modeGen) {
    var context = getContextBefore(cm, lineNo(line));
    var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
    var result = highlightLine(cm, line, context);
    if (resetState) { context.state = resetState; }
    line.stateAfter = context.save(!resetState);
    line.styles = result.styles;
    if (result.classes) { line.styleClasses = result.classes; }
    else if (line.styleClasses) { line.styleClasses = null; }
    if (updateFrontier === cm.doc.highlightFrontier)
      { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
  }
  return line.styles
}

function getContextBefore(cm, n, precise) {
  var doc = cm.doc, display = cm.display;
  if (!doc.mode.startState) { return new Context(doc, true, n) }
  var start = findStartLine(cm, n, precise);
  var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
  var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

  doc.iter(start, n, function (line) {
    processLine(cm, line.text, context);
    var pos = context.line;
    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
    context.nextLine();
  });
  if (precise) { doc.modeFrontier = context.line; }
  return context
}

// Lightweight form of highlight -- proceed over this line and
// update state, but don't save a style array. Used for lines that
// aren't currently visible.
function processLine(cm, text, context, startAt) {
  var mode = cm.doc.mode;
  var stream = new StringStream(text, cm.options.tabSize, context);
  stream.start = stream.pos = startAt || 0;
  if (text == "") { callBlankLine(mode, context.state); }
  while (!stream.eol()) {
    readToken(mode, stream, context.state);
    stream.start = stream.pos;
  }
}

function callBlankLine(mode, state) {
  if (mode.blankLine) { return mode.blankLine(state) }
  if (!mode.innerMode) { return }
  var inner = innerMode(mode, state);
  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
}

function readToken(mode, stream, state, inner) {
  for (var i = 0; i < 10; i++) {
    if (inner) { inner[0] = innerMode(mode, state).mode; }
    var style = mode.token(stream, state);
    if (stream.pos > stream.start) { return style }
  }
  throw new Error("Mode " + mode.name + " failed to advance stream.")
}

var Token = function(stream, type, state) {
  this.start = stream.start; this.end = stream.pos;
  this.string = stream.current();
  this.type = type || null;
  this.state = state;
};

// Utility for getTokenAt and getLineTokens
function takeToken(cm, pos, precise, asArray) {
  var doc = cm.doc, mode = doc.mode, style;
  pos = clipPos(doc, pos);
  var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
  var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
  if (asArray) { tokens = []; }
  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
    stream.start = stream.pos;
    style = readToken(mode, stream, context.state);
    if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
  }
  return asArray ? tokens : new Token(stream, style, context.state)
}

function extractLineClasses(type, output) {
  if (type) { for (;;) {
    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
    if (!lineClass) { break }
    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
    var prop = lineClass[1] ? "bgClass" : "textClass";
    if (output[prop] == null)
      { output[prop] = lineClass[2]; }
    else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
      { output[prop] += " " + lineClass[2]; }
  } }
  return type
}

// Run the given mode's parser over a line, calling f for each token.
function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
  var flattenSpans = mode.flattenSpans;
  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
  var curStart = 0, curStyle = null;
  var stream = new StringStream(text, cm.options.tabSize, context), style;
  var inner = cm.options.addModeClass && [null];
  if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
  while (!stream.eol()) {
    if (stream.pos > cm.options.maxHighlightLength) {
      flattenSpans = false;
      if (forceToEnd) { processLine(cm, text, context, stream.pos); }
      stream.pos = text.length;
      style = null;
    } else {
      style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
    }
    if (inner) {
      var mName = inner[0].name;
      if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
    }
    if (!flattenSpans || curStyle != style) {
      while (curStart < stream.start) {
        curStart = Math.min(stream.start, curStart + 5000);
        f(curStart, curStyle);
      }
      curStyle = style;
    }
    stream.start = stream.pos;
  }
  while (curStart < stream.pos) {
    // Webkit seems to refuse to render text nodes longer than 57444
    // characters, and returns inaccurate measurements in nodes
    // starting around 5000 chars.
    var pos = Math.min(stream.pos, curStart + 5000);
    f(pos, curStyle);
    curStart = pos;
  }
}

// Finds the line to start with when starting a parse. Tries to
// find a line with a stateAfter, so that it can start with a
// valid state. If that fails, it returns the line with the
// smallest indentation, which tends to need the least context to
// parse correctly.
function findStartLine(cm, n, precise) {
  var minindent, minline, doc = cm.doc;
  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
  for (var search = n; search > lim; --search) {
    if (search <= doc.first) { return doc.first }
    var line = getLine(doc, search - 1), after = line.stateAfter;
    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
      { return search }
    var indented = countColumn(line.text, null, cm.options.tabSize);
    if (minline == null || minindent > indented) {
      minline = search - 1;
      minindent = indented;
    }
  }
  return minline
}

function retreatFrontier(doc, n) {
  doc.modeFrontier = Math.min(doc.modeFrontier, n);
  if (doc.highlightFrontier < n - 10) { return }
  var start = doc.first;
  for (var line = n - 1; line > start; line--) {
    var saved = getLine(doc, line).stateAfter;
    // change is on 3
    // state on line 1 looked ahead 2 -- so saw 3
    // test 1 + 2 < 3 should cover this
    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
      start = line + 1;
      break
    }
  }
  doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
}

// LINE DATA STRUCTURE

// Line objects. These hold state related to a line, including
// highlighting info (the styles array).
var Line = function(text, markedSpans, estimateHeight) {
  this.text = text;
  attachMarkedSpans(this, markedSpans);
  this.height = estimateHeight ? estimateHeight(this) : 1;
};

Line.prototype.lineNo = function () { return lineNo(this) };
eventMixin(Line);

// Change the content (text, markers) of a line. Automatically
// invalidates cached information and tries to re-estimate the
// line's height.
function updateLine(line, text, markedSpans, estimateHeight) {
  line.text = text;
  if (line.stateAfter) { line.stateAfter = null; }
  if (line.styles) { line.styles = null; }
  if (line.order != null) { line.order = null; }
  detachMarkedSpans(line);
  attachMarkedSpans(line, markedSpans);
  var estHeight = estimateHeight ? estimateHeight(line) : 1;
  if (estHeight != line.height) { updateLineHeight(line, estHeight); }
}

// Detach a line from the document tree and its markers.
function cleanUpLine(line) {
  line.parent = null;
  detachMarkedSpans(line);
}

// Convert a style as returned by a mode (either null, or a string
// containing one or more styles) to a CSS style. This is cached,
// and also looks for line-wide styles.
var styleToClassCache = {};
var styleToClassCacheWithMode = {};
function interpretTokenStyle(style, options) {
  if (!style || /^\s*$/.test(style)) { return null }
  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
  return cache[style] ||
    (cache[style] = style.replace(/\S+/g, "cm-$&"))
}

// Render the DOM representation of the text of a line. Also builds
// up a 'line map', which points at the DOM nodes that represent
// specific stretches of text, and is used by the measuring code.
// The returned object contains the DOM node, this map, and
// information about line-wide styles that were set by the mode.
function buildLineContent(cm, lineView) {
  // The padding-right forces the element to have a 'border', which
  // is needed on Webkit to be able to get line-level bounding
  // rectangles for it (in measureChar).
  var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
  var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                 col: 0, pos: 0, cm: cm,
                 trailingSpace: false,
                 splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
  lineView.measure = {};

  // Iterate over the logical lines that make up this visual line.
  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
    builder.pos = 0;
    builder.addToken = buildToken;
    // Optionally wire in some hacks into the token-rendering
    // algorithm, to deal with browser quirks.
    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
    builder.map = [];
    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
    if (line.styleClasses) {
      if (line.styleClasses.bgClass)
        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
      if (line.styleClasses.textClass)
        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
    }

    // Ensure at least a single node is present, for measuring.
    if (builder.map.length == 0)
      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

    // Store the map and a cache object for the current logical line
    if (i == 0) {
      lineView.measure.map = builder.map;
      lineView.measure.cache = {};
    } else {
      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
    }
  }

  // See issue #2901
  if (webkit) {
    var last = builder.content.lastChild;
    if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
      { builder.content.className = "cm-tab-wrap-hack"; }
  }

  signal(cm, "renderLine", cm, lineView.line, builder.pre);
  if (builder.pre.className)
    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

  return builder
}

function defaultSpecialCharPlaceholder(ch) {
  var token = elt("span", "\u2022", "cm-invalidchar");
  token.title = "\\u" + ch.charCodeAt(0).toString(16);
  token.setAttribute("aria-label", token.title);
  return token
}

// Build up the DOM representation for a single token, and add it to
// the line map. Takes care to render special characters separately.
function buildToken(builder, text, style, startStyle, endStyle, title, css) {
  if (!text) { return }
  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
  var special = builder.cm.state.specialChars, mustWrap = false;
  var content;
  if (!special.test(text)) {
    builder.col += text.length;
    content = document.createTextNode(displayText);
    builder.map.push(builder.pos, builder.pos + text.length, content);
    if (ie && ie_version < 9) { mustWrap = true; }
    builder.pos += text.length;
  } else {
    content = document.createDocumentFragment();
    var pos = 0;
    while (true) {
      special.lastIndex = pos;
      var m = special.exec(text);
      var skipped = m ? m.index - pos : text.length - pos;
      if (skipped) {
        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
        else { content.appendChild(txt); }
        builder.map.push(builder.pos, builder.pos + skipped, txt);
        builder.col += skipped;
        builder.pos += skipped;
      }
      if (!m) { break }
      pos += skipped + 1;
      var txt$1 = (void 0);
      if (m[0] == "\t") {
        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
        txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
        txt$1.setAttribute("role", "presentation");
        txt$1.setAttribute("cm-text", "\t");
        builder.col += tabWidth;
      } else if (m[0] == "\r" || m[0] == "\n") {
        txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
        txt$1.setAttribute("cm-text", m[0]);
        builder.col += 1;
      } else {
        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
        txt$1.setAttribute("cm-text", m[0]);
        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
        else { content.appendChild(txt$1); }
        builder.col += 1;
      }
      builder.map.push(builder.pos, builder.pos + 1, txt$1);
      builder.pos++;
    }
  }
  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
  if (style || startStyle || endStyle || mustWrap || css) {
    var fullStyle = style || "";
    if (startStyle) { fullStyle += startStyle; }
    if (endStyle) { fullStyle += endStyle; }
    var token = elt("span", [content], fullStyle, css);
    if (title) { token.title = title; }
    return builder.content.appendChild(token)
  }
  builder.content.appendChild(content);
}

function splitSpaces(text, trailingBefore) {
  if (text.length > 1 && !/  /.test(text)) { return text }
  var spaceBefore = trailingBefore, result = "";
  for (var i = 0; i < text.length; i++) {
    var ch = text.charAt(i);
    if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
      { ch = "\u00a0"; }
    result += ch;
    spaceBefore = ch == " ";
  }
  return result
}

// Work around nonsense dimensions being reported for stretches of
// right-to-left text.
function buildTokenBadBidi(inner, order) {
  return function (builder, text, style, startStyle, endStyle, title, css) {
    style = style ? style + " cm-force-border" : "cm-force-border";
    var start = builder.pos, end = start + text.length;
    for (;;) {
      // Find the part that overlaps with the start of this text
      var part = (void 0);
      for (var i = 0; i < order.length; i++) {
        part = order[i];
        if (part.to > start && part.from <= start) { break }
      }
      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }
      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
      startStyle = null;
      text = text.slice(part.to - start);
      start = part.to;
    }
  }
}

function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
  var widget = !ignoreWidget && marker.widgetNode;
  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
    if (!widget)
      { widget = builder.content.appendChild(document.createElement("span")); }
    widget.setAttribute("cm-marker", marker.id);
  }
  if (widget) {
    builder.cm.display.input.setUneditable(widget);
    builder.content.appendChild(widget);
  }
  builder.pos += size;
  builder.trailingSpace = false;
}

// Outputs a number of spans to make up a line, taking highlighting
// and marked text into account.
function insertLineContent(line, builder, styles) {
  var spans = line.markedSpans, allText = line.text, at = 0;
  if (!spans) {
    for (var i$1 = 1; i$1 < styles.length; i$1+=2)
      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
    return
  }

  var len = allText.length, pos = 0, i = 1, text = "", style, css;
  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
  for (;;) {
    if (nextChange == pos) { // Update current marker set
      spanStyle = spanEndStyle = spanStartStyle = title = css = "";
      collapsed = null; nextChange = Infinity;
      var foundBookmarks = [], endStyles = (void 0);
      for (var j = 0; j < spans.length; ++j) {
        var sp = spans[j], m = sp.marker;
        if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
          foundBookmarks.push(m);
        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
          if (sp.to != null && sp.to != pos && nextChange > sp.to) {
            nextChange = sp.to;
            spanEndStyle = "";
          }
          if (m.className) { spanStyle += " " + m.className; }
          if (m.css) { css = (css ? css + ";" : "") + m.css; }
          if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
          if (m.title && !title) { title = m.title; }
          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
            { collapsed = sp; }
        } else if (sp.from > pos && nextChange > sp.from) {
          nextChange = sp.from;
        }
      }
      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
      if (collapsed && (collapsed.from || 0) == pos) {
        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                           collapsed.marker, collapsed.from == null);
        if (collapsed.to == null) { return }
        if (collapsed.to == pos) { collapsed = false; }
      }
    }
    if (pos >= len) { break }

    var upto = Math.min(len, nextChange);
    while (true) {
      if (text) {
        var end = pos + text.length;
        if (!collapsed) {
          var tokenText = end > upto ? text.slice(0, upto - pos) : text;
          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
        }
        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
        pos = end;
        spanStartStyle = "";
      }
      text = allText.slice(at, at = styles[i++]);
      style = interpretTokenStyle(styles[i++], builder.cm.options);
    }
  }
}


// These objects are used to represent the visible (currently drawn)
// part of the document. A LineView may correspond to multiple
// logical lines, if those are connected by collapsed ranges.
function LineView(doc, line, lineN) {
  // The starting line
  this.line = line;
  // Continuing lines, if any
  this.rest = visualLineContinued(line);
  // Number of logical lines in this visual line
  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
  this.node = this.text = null;
  this.hidden = lineIsHidden(doc, line);
}

// Create a range of LineView objects for the given lines.
function buildViewArray(cm, from, to) {
  var array = [], nextPos;
  for (var pos = from; pos < to; pos = nextPos) {
    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
    nextPos = pos + view.size;
    array.push(view);
  }
  return array
}

var operationGroup = null;

function pushOperation(op) {
  if (operationGroup) {
    operationGroup.ops.push(op);
  } else {
    op.ownsGroup = operationGroup = {
      ops: [op],
      delayedCallbacks: []
    };
  }
}

function fireCallbacksForOps(group) {
  // Calls delayed callbacks and cursorActivity handlers until no
  // new ones appear
  var callbacks = group.delayedCallbacks, i = 0;
  do {
    for (; i < callbacks.length; i++)
      { callbacks[i].call(null); }
    for (var j = 0; j < group.ops.length; j++) {
      var op = group.ops[j];
      if (op.cursorActivityHandlers)
        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
    }
  } while (i < callbacks.length)
}

function finishOperation(op, endCb) {
  var group = op.ownsGroup;
  if (!group) { return }

  try { fireCallbacksForOps(group); }
  finally {
    operationGroup = null;
    endCb(group);
  }
}

var orphanDelayedCallbacks = null;

// Often, we want to signal events at a point where we are in the
// middle of some work, but don't want the handler to start calling
// other methods on the editor, which might be in an inconsistent
// state or simply not expect any other events to happen.
// signalLater looks whether there are any handlers, and schedules
// them to be executed when the last operation ends, or, if no
// operation is active, when a timeout fires.
function signalLater(emitter, type /*, values...*/) {
  var arr = getHandlers(emitter, type);
  if (!arr.length) { return }
  var args = Array.prototype.slice.call(arguments, 2), list;
  if (operationGroup) {
    list = operationGroup.delayedCallbacks;
  } else if (orphanDelayedCallbacks) {
    list = orphanDelayedCallbacks;
  } else {
    list = orphanDelayedCallbacks = [];
    setTimeout(fireOrphanDelayed, 0);
  }
  var loop = function ( i ) {
    list.push(function () { return arr[i].apply(null, args); });
  };

  for (var i = 0; i < arr.length; ++i)
    loop( i );
}

function fireOrphanDelayed() {
  var delayed = orphanDelayedCallbacks;
  orphanDelayedCallbacks = null;
  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
}

// When an aspect of a line changes, a string is added to
// lineView.changes. This updates the relevant part of the line's
// DOM structure.
function updateLineForChanges(cm, lineView, lineN, dims) {
  for (var j = 0; j < lineView.changes.length; j++) {
    var type = lineView.changes[j];
    if (type == "text") { updateLineText(cm, lineView); }
    else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
    else if (type == "class") { updateLineClasses(cm, lineView); }
    else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
  }
  lineView.changes = null;
}

// Lines with gutter elements, widgets or a background class need to
// be wrapped, and have the extra elements added to the wrapper div
function ensureLineWrapped(lineView) {
  if (lineView.node == lineView.text) {
    lineView.node = elt("div", null, null, "position: relative");
    if (lineView.text.parentNode)
      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
    lineView.node.appendChild(lineView.text);
    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
  }
  return lineView.node
}

function updateLineBackground(cm, lineView) {
  var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
  if (cls) { cls += " CodeMirror-linebackground"; }
  if (lineView.background) {
    if (cls) { lineView.background.className = cls; }
    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
  } else if (cls) {
    var wrap = ensureLineWrapped(lineView);
    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    cm.display.input.setUneditable(lineView.background);
  }
}

// Wrapper around buildLineContent which will reuse the structure
// in display.externalMeasured when possible.
function getLineContent(cm, lineView) {
  var ext = cm.display.externalMeasured;
  if (ext && ext.line == lineView.line) {
    cm.display.externalMeasured = null;
    lineView.measure = ext.measure;
    return ext.built
  }
  return buildLineContent(cm, lineView)
}

// Redraw the line's text. Interacts with the background and text
// classes because the mode may output tokens that influence these
// classes.
function updateLineText(cm, lineView) {
  var cls = lineView.text.className;
  var built = getLineContent(cm, lineView);
  if (lineView.text == lineView.node) { lineView.node = built.pre; }
  lineView.text.parentNode.replaceChild(built.pre, lineView.text);
  lineView.text = built.pre;
  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
    lineView.bgClass = built.bgClass;
    lineView.textClass = built.textClass;
    updateLineClasses(cm, lineView);
  } else if (cls) {
    lineView.text.className = cls;
  }
}

function updateLineClasses(cm, lineView) {
  updateLineBackground(cm, lineView);
  if (lineView.line.wrapClass)
    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
  else if (lineView.node != lineView.text)
    { lineView.node.className = ""; }
  var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
  lineView.text.className = textClass || "";
}

function updateLineGutter(cm, lineView, lineN, dims) {
  if (lineView.gutter) {
    lineView.node.removeChild(lineView.gutter);
    lineView.gutter = null;
  }
  if (lineView.gutterBackground) {
    lineView.node.removeChild(lineView.gutterBackground);
    lineView.gutterBackground = null;
  }
  if (lineView.line.gutterClass) {
    var wrap = ensureLineWrapped(lineView);
    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                    ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
    cm.display.input.setUneditable(lineView.gutterBackground);
    wrap.insertBefore(lineView.gutterBackground, lineView.text);
  }
  var markers = lineView.line.gutterMarkers;
  if (cm.options.lineNumbers || markers) {
    var wrap$1 = ensureLineWrapped(lineView);
    var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
    cm.display.input.setUneditable(gutterWrap);
    wrap$1.insertBefore(gutterWrap, lineView.text);
    if (lineView.line.gutterClass)
      { gutterWrap.className += " " + lineView.line.gutterClass; }
    if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
      { lineView.lineNumber = gutterWrap.appendChild(
        elt("div", lineNumberFor(cm.options, lineN),
            "CodeMirror-linenumber CodeMirror-gutter-elt",
            ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {
      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
      if (found)
        { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                   ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
    } }
  }
}

function updateLineWidgets(cm, lineView, dims) {
  if (lineView.alignable) { lineView.alignable = null; }
  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
    next = node.nextSibling;
    if (node.className == "CodeMirror-linewidget")
      { lineView.node.removeChild(node); }
  }
  insertLineWidgets(cm, lineView, dims);
}

// Build a line's DOM representation from scratch
function buildLineElement(cm, lineView, lineN, dims) {
  var built = getLineContent(cm, lineView);
  lineView.text = lineView.node = built.pre;
  if (built.bgClass) { lineView.bgClass = built.bgClass; }
  if (built.textClass) { lineView.textClass = built.textClass; }

  updateLineClasses(cm, lineView);
  updateLineGutter(cm, lineView, lineN, dims);
  insertLineWidgets(cm, lineView, dims);
  return lineView.node
}

// A lineView may contain multiple logical lines (when merged by
// collapsed spans). The widgets for all of them need to be drawn.
function insertLineWidgets(cm, lineView, dims) {
  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
}

function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
  if (!line.widgets) { return }
  var wrap = ensureLineWrapped(lineView);
  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
    var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
    if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
    positionLineWidget(widget, node, lineView, dims);
    cm.display.input.setUneditable(node);
    if (allowAbove && widget.above)
      { wrap.insertBefore(node, lineView.gutter || lineView.text); }
    else
      { wrap.appendChild(node); }
    signalLater(widget, "redraw");
  }
}

function positionLineWidget(widget, node, lineView, dims) {
  if (widget.noHScroll) {
    (lineView.alignable || (lineView.alignable = [])).push(node);
    var width = dims.wrapperWidth;
    node.style.left = dims.fixedPos + "px";
    if (!widget.coverGutter) {
      width -= dims.gutterTotalWidth;
      node.style.paddingLeft = dims.gutterTotalWidth + "px";
    }
    node.style.width = width + "px";
  }
  if (widget.coverGutter) {
    node.style.zIndex = 5;
    node.style.position = "relative";
    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
  }
}

function widgetHeight(widget) {
  if (widget.height != null) { return widget.height }
  var cm = widget.doc.cm;
  if (!cm) { return 0 }
  if (!contains(document.body, widget.node)) {
    var parentStyle = "position: relative;";
    if (widget.coverGutter)
      { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
    if (widget.noHScroll)
      { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
    removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
  }
  return widget.height = widget.node.parentNode.offsetHeight
}

// Return true when the given mouse event happened in a widget
function eventInWidget(display, e) {
  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
    if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
        (n.parentNode == display.sizer && n != display.mover))
      { return true }
  }
}

// POSITION MEASUREMENT

function paddingTop(display) {return display.lineSpace.offsetTop}
function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
function paddingH(display) {
  if (display.cachedPaddingH) { return display.cachedPaddingH }
  var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
  return data
}

function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
function displayWidth(cm) {
  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
}
function displayHeight(cm) {
  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
}

// Ensure the lineView.wrapping.heights array is populated. This is
// an array of bottom offsets for the lines that make up a drawn
// line. When lineWrapping is on, there might be more than one
// height.
function ensureLineHeights(cm, lineView, rect) {
  var wrapping = cm.options.lineWrapping;
  var curWidth = wrapping && displayWidth(cm);
  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
    var heights = lineView.measure.heights = [];
    if (wrapping) {
      lineView.measure.width = curWidth;
      var rects = lineView.text.firstChild.getClientRects();
      for (var i = 0; i < rects.length - 1; i++) {
        var cur = rects[i], next = rects[i + 1];
        if (Math.abs(cur.bottom - next.bottom) > 2)
          { heights.push((cur.bottom + next.top) / 2 - rect.top); }
      }
    }
    heights.push(rect.bottom - rect.top);
  }
}

// Find a line map (mapping character offsets to text nodes) and a
// measurement cache for the given line number. (A line view might
// contain multiple lines when collapsed ranges are present.)
function mapFromLineView(lineView, line, lineN) {
  if (lineView.line == line)
    { return {map: lineView.measure.map, cache: lineView.measure.cache} }
  for (var i = 0; i < lineView.rest.length; i++)
    { if (lineView.rest[i] == line)
      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
    { if (lineNo(lineView.rest[i$1]) > lineN)
      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
}

// Render a line into the hidden node display.externalMeasured. Used
// when measurement is needed for a line that's not in the viewport.
function updateExternalMeasurement(cm, line) {
  line = visualLine(line);
  var lineN = lineNo(line);
  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
  view.lineN = lineN;
  var built = view.built = buildLineContent(cm, view);
  view.text = built.pre;
  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
  return view
}

// Get a {top, bottom, left, right} box (in line-local coordinates)
// for a given character.
function measureChar(cm, line, ch, bias) {
  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
}

// Find a line view that corresponds to the given line number.
function findViewForLine(cm, lineN) {
  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
    { return cm.display.view[findViewIndex(cm, lineN)] }
  var ext = cm.display.externalMeasured;
  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
    { return ext }
}

// Measurement can be split in two steps, the set-up work that
// applies to the whole line, and the measurement of the actual
// character. Functions like coordsChar, that need to do a lot of
// measurements in a row, can thus ensure that the set-up work is
// only done once.
function prepareMeasureForLine(cm, line) {
  var lineN = lineNo(line);
  var view = findViewForLine(cm, lineN);
  if (view && !view.text) {
    view = null;
  } else if (view && view.changes) {
    updateLineForChanges(cm, view, lineN, getDimensions(cm));
    cm.curOp.forceUpdate = true;
  }
  if (!view)
    { view = updateExternalMeasurement(cm, line); }

  var info = mapFromLineView(view, line, lineN);
  return {
    line: line, view: view, rect: null,
    map: info.map, cache: info.cache, before: info.before,
    hasHeights: false
  }
}

// Given a prepared measurement object, measures the position of an
// actual character (or fetches it from the cache).
function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
  if (prepared.before) { ch = -1; }
  var key = ch + (bias || ""), found;
  if (prepared.cache.hasOwnProperty(key)) {
    found = prepared.cache[key];
  } else {
    if (!prepared.rect)
      { prepared.rect = prepared.view.text.getBoundingClientRect(); }
    if (!prepared.hasHeights) {
      ensureLineHeights(cm, prepared.view, prepared.rect);
      prepared.hasHeights = true;
    }
    found = measureCharInner(cm, prepared, ch, bias);
    if (!found.bogus) { prepared.cache[key] = found; }
  }
  return {left: found.left, right: found.right,
          top: varHeight ? found.rtop : found.top,
          bottom: varHeight ? found.rbottom : found.bottom}
}

var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

function nodeAndOffsetInLineMap(map$$1, ch, bias) {
  var node, start, end, collapse, mStart, mEnd;
  // First, search the line map for the text node corresponding to,
  // or closest to, the target character.
  for (var i = 0; i < map$$1.length; i += 3) {
    mStart = map$$1[i];
    mEnd = map$$1[i + 1];
    if (ch < mStart) {
      start = 0; end = 1;
      collapse = "left";
    } else if (ch < mEnd) {
      start = ch - mStart;
      end = start + 1;
    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
      end = mEnd - mStart;
      start = end - 1;
      if (ch >= mEnd) { collapse = "right"; }
    }
    if (start != null) {
      node = map$$1[i + 2];
      if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
        { collapse = bias; }
      if (bias == "left" && start == 0)
        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
          node = map$$1[(i -= 3) + 2];
          collapse = "left";
        } }
      if (bias == "right" && start == mEnd - mStart)
        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
          node = map$$1[(i += 3) + 2];
          collapse = "right";
        } }
      break
    }
  }
  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
}

function getUsefulRect(rects, bias) {
  var rect = nullRect;
  if (bias == "left") { for (var i = 0; i < rects.length; i++) {
    if ((rect = rects[i]).left != rect.right) { break }
  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
    if ((rect = rects[i$1]).left != rect.right) { break }
  } }
  return rect
}

function measureCharInner(cm, prepared, ch, bias) {
  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

  var rect;
  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
        { rect = node.parentNode.getBoundingClientRect(); }
      else
        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
      if (rect.left || rect.right || start == 0) { break }
      end = start;
      start = start - 1;
      collapse = "right";
    }
    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
  } else { // If it is a widget, simply get the box for the whole widget.
    if (start > 0) { collapse = bias = "right"; }
    var rects;
    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
      { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
    else
      { rect = node.getBoundingClientRect(); }
  }
  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
    var rSpan = node.parentNode.getClientRects()[0];
    if (rSpan)
      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
    else
      { rect = nullRect; }
  }

  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
  var mid = (rtop + rbot) / 2;
  var heights = prepared.view.measure.heights;
  var i = 0;
  for (; i < heights.length - 1; i++)
    { if (mid < heights[i]) { break } }
  var top = i ? heights[i - 1] : 0, bot = heights[i];
  var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                top: top, bottom: bot};
  if (!rect.left && !rect.right) { result.bogus = true; }
  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

  return result
}

// Work around problem with bounding client rects on ranges being
// returned incorrectly when zoomed on IE10 and below.
function maybeUpdateRectForZooming(measure, rect) {
  if (!window.screen || screen.logicalXDPI == null ||
      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
    { return rect }
  var scaleX = screen.logicalXDPI / screen.deviceXDPI;
  var scaleY = screen.logicalYDPI / screen.deviceYDPI;
  return {left: rect.left * scaleX, right: rect.right * scaleX,
          top: rect.top * scaleY, bottom: rect.bottom * scaleY}
}

function clearLineMeasurementCacheFor(lineView) {
  if (lineView.measure) {
    lineView.measure.cache = {};
    lineView.measure.heights = null;
    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
      { lineView.measure.caches[i] = {}; } }
  }
}

function clearLineMeasurementCache(cm) {
  cm.display.externalMeasure = null;
  removeChildren(cm.display.lineMeasure);
  for (var i = 0; i < cm.display.view.length; i++)
    { clearLineMeasurementCacheFor(cm.display.view[i]); }
}

function clearCaches(cm) {
  clearLineMeasurementCache(cm);
  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
  cm.display.lineNumChars = null;
}

function pageScrollX() {
  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
  // which causes page_Offset and bounding client rects to use
  // different reference viewports and invalidate our calculations.
  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
  return window.pageXOffset || (document.documentElement || document.body).scrollLeft
}
function pageScrollY() {
  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
  return window.pageYOffset || (document.documentElement || document.body).scrollTop
}

function widgetTopHeight(lineObj) {
  var height = 0;
  if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
    { height += widgetHeight(lineObj.widgets[i]); } } }
  return height
}

// Converts a {top, bottom, left, right} box from line-local
// coordinates into another coordinate system. Context may be one of
// "line", "div" (display.lineDiv), "local"./null (editor), "window",
// or "page".
function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
  if (!includeWidgets) {
    var height = widgetTopHeight(lineObj);
    rect.top += height; rect.bottom += height;
  }
  if (context == "line") { return rect }
  if (!context) { context = "local"; }
  var yOff = heightAtLine(lineObj);
  if (context == "local") { yOff += paddingTop(cm.display); }
  else { yOff -= cm.display.viewOffset; }
  if (context == "page" || context == "window") {
    var lOff = cm.display.lineSpace.getBoundingClientRect();
    yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
    var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
    rect.left += xOff; rect.right += xOff;
  }
  rect.top += yOff; rect.bottom += yOff;
  return rect
}

// Coverts a box from "div" coords to another coordinate system.
// Context may be "window", "page", "div", or "local"./null.
function fromCoordSystem(cm, coords, context) {
  if (context == "div") { return coords }
  var left = coords.left, top = coords.top;
  // First move into "page" coordinate system
  if (context == "page") {
    left -= pageScrollX();
    top -= pageScrollY();
  } else if (context == "local" || !context) {
    var localBox = cm.display.sizer.getBoundingClientRect();
    left += localBox.left;
    top += localBox.top;
  }

  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
}

function charCoords(cm, pos, context, lineObj, bias) {
  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
}

// Returns a box for a given cursor position, which may have an
// 'other' property containing the position of the secondary cursor
// on a bidi boundary.
// A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
// and after `char - 1` in writing order of `char - 1`
// A cursor Pos(line, char, "after") is on the same visual line as `char`
// and before `char` in writing order of `char`
// Examples (upper-case letters are RTL, lower-case are LTR):
//     Pos(0, 1, ...)
//     before   after
// ab     a|b     a|b
// aB     a|B     aB|
// Ab     |Ab     A|b
// AB     B|A     B|A
// Every position after the last character on a line is considered to stick
// to the last character on the line.
function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
  lineObj = lineObj || getLine(cm.doc, pos.line);
  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
  function get(ch, right) {
    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
    if (right) { m.left = m.right; } else { m.right = m.left; }
    return intoCoordSystem(cm, lineObj, m, context)
  }
  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
  if (ch >= lineObj.text.length) {
    ch = lineObj.text.length;
    sticky = "before";
  } else if (ch <= 0) {
    ch = 0;
    sticky = "after";
  }
  if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

  function getBidi(ch, partPos, invert) {
    var part = order[partPos], right = part.level == 1;
    return get(invert ? ch - 1 : ch, right != invert)
  }
  var partPos = getBidiPartAt(order, ch, sticky);
  var other = bidiOther;
  var val = getBidi(ch, partPos, sticky == "before");
  if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
  return val
}

// Used to cheaply estimate the coordinates for a position. Used for
// intermediate scroll updates.
function estimateCoords(cm, pos) {
  var left = 0;
  pos = clipPos(cm.doc, pos);
  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
  var lineObj = getLine(cm.doc, pos.line);
  var top = heightAtLine(lineObj) + paddingTop(cm.display);
  return {left: left, right: left, top: top, bottom: top + lineObj.height}
}

// Positions returned by coordsChar contain some extra information.
// xRel is the relative x position of the input coordinates compared
// to the found position (so xRel > 0 means the coordinates are to
// the right of the character position, for example). When outside
// is true, that means the coordinates lie outside the line's
// vertical range.
function PosWithInfo(line, ch, sticky, outside, xRel) {
  var pos = Pos(line, ch, sticky);
  pos.xRel = xRel;
  if (outside) { pos.outside = true; }
  return pos
}

// Compute the character position closest to the given coordinates.
// Input must be lineSpace-local ("div" coordinate system).
function coordsChar(cm, x, y) {
  var doc = cm.doc;
  y += cm.display.viewOffset;
  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }
  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
  if (lineN > last)
    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }
  if (x < 0) { x = 0; }

  var lineObj = getLine(doc, lineN);
  for (;;) {
    var found = coordsCharInner(cm, lineObj, lineN, x, y);
    var merged = collapsedSpanAtEnd(lineObj);
    var mergedPos = merged && merged.find(0, true);
    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
      { lineN = lineNo(lineObj = mergedPos.to.line); }
    else
      { return found }
  }
}

function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
  y -= widgetTopHeight(lineObj);
  var end = lineObj.text.length;
  var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
  end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
  return {begin: begin, end: end}
}

function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
}

// Returns true if the given side of a box is after the given
// coordinates, in top-to-bottom, left-to-right order.
function boxIsAfter(box, x, y, left) {
  return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
}

function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
  // Move y into line-local coordinate space
  y -= heightAtLine(lineObj);
  var preparedMeasure = prepareMeasureForLine(cm, lineObj);
  // When directly calling `measureCharPrepared`, we have to adjust
  // for the widgets at this line.
  var widgetHeight$$1 = widgetTopHeight(lineObj);
  var begin = 0, end = lineObj.text.length, ltr = true;

  var order = getOrder(lineObj, cm.doc.direction);
  // If the line isn't plain left-to-right text, first figure out
  // which bidi section the coordinates fall into.
  if (order) {
    var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                 (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
    ltr = part.level != 1;
    // The awkward -1 offsets are needed because findFirst (called
    // on these below) will treat its first bound as inclusive,
    // second as exclusive, but we want to actually address the
    // characters in the part's range
    begin = ltr ? part.from : part.to - 1;
    end = ltr ? part.to : part.from - 1;
  }

  // A binary search to find the first character whose bounding box
  // starts after the coordinates. If we run across any whose box wrap
  // the coordinates, store that.
  var chAround = null, boxAround = null;
  var ch = findFirst(function (ch) {
    var box = measureCharPrepared(cm, preparedMeasure, ch);
    box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;
    if (!boxIsAfter(box, x, y, false)) { return false }
    if (box.top <= y && box.left <= x) {
      chAround = ch;
      boxAround = box;
    }
    return true
  }, begin, end);

  var baseX, sticky, outside = false;
  // If a box around the coordinates was found, use that
  if (boxAround) {
    // Distinguish coordinates nearer to the left or right side of the box
    var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
    ch = chAround + (atStart ? 0 : 1);
    sticky = atStart ? "after" : "before";
    baseX = atLeft ? boxAround.left : boxAround.right;
  } else {
    // (Adjust for extended bound, if necessary.)
    if (!ltr && (ch == end || ch == begin)) { ch++; }
    // To determine which side to associate with, get the box to the
    // left of the character and compare it's vertical position to the
    // coordinates
    sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
      (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?
      "after" : "before";
    // Now get accurate coordinates for this place, in order to get a
    // base X position
    var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
    baseX = coords.left;
    outside = y < coords.top || y >= coords.bottom;
  }

  ch = skipExtendingChars(lineObj.text, ch, 1);
  return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)
}

function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
  // Bidi parts are sorted left-to-right, and in a non-line-wrapping
  // situation, we can take this ordering to correspond to the visual
  // ordering. This finds the first part whose end is after the given
  // coordinates.
  var index = findFirst(function (i) {
    var part = order[i], ltr = part.level != 1;
    return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                   "line", lineObj, preparedMeasure), x, y, true)
  }, 0, order.length - 1);
  var part = order[index];
  // If this isn't the first part, the part's start is also after
  // the coordinates, and the coordinates aren't on the same line as
  // that start, move one part back.
  if (index > 0) {
    var ltr = part.level != 1;
    var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"),
                             "line", lineObj, preparedMeasure);
    if (boxIsAfter(start, x, y, true) && start.top > y)
      { part = order[index - 1]; }
  }
  return part
}

function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
  // In a wrapped line, rtl text on wrapping boundaries can do things
  // that don't correspond to the ordering in our `order` array at
  // all, so a binary search doesn't work, and we want to return a
  // part that only spans one line so that the binary search in
  // coordsCharInner is safe. As such, we first find the extent of the
  // wrapped line, and then do a flat search in which we discard any
  // spans that aren't on the line.
  var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
  var begin = ref.begin;
  var end = ref.end;
  if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
  var part = null, closestDist = null;
  for (var i = 0; i < order.length; i++) {
    var p = order[i];
    if (p.from >= end || p.to <= begin) { continue }
    var ltr = p.level != 1;
    var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
    // Weigh against spans ending before this, so that they are only
    // picked if nothing ends after
    var dist = endX < x ? x - endX + 1e9 : endX - x;
    if (!part || closestDist > dist) {
      part = p;
      closestDist = dist;
    }
  }
  if (!part) { part = order[order.length - 1]; }
  // Clip the part to the wrapped line.
  if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
  if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
  return part
}

var measureText;
// Compute the default text height.
function textHeight(display) {
  if (display.cachedTextHeight != null) { return display.cachedTextHeight }
  if (measureText == null) {
    measureText = elt("pre");
    // Measure a bunch of lines, for browsers that compute
    // fractional heights.
    for (var i = 0; i < 49; ++i) {
      measureText.appendChild(document.createTextNode("x"));
      measureText.appendChild(elt("br"));
    }
    measureText.appendChild(document.createTextNode("x"));
  }
  removeChildrenAndAdd(display.measure, measureText);
  var height = measureText.offsetHeight / 50;
  if (height > 3) { display.cachedTextHeight = height; }
  removeChildren(display.measure);
  return height || 1
}

// Compute the default character width.
function charWidth(display) {
  if (display.cachedCharWidth != null) { return display.cachedCharWidth }
  var anchor = elt("span", "xxxxxxxxxx");
  var pre = elt("pre", [anchor]);
  removeChildrenAndAdd(display.measure, pre);
  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
  if (width > 2) { display.cachedCharWidth = width; }
  return width || 10
}

// Do a bulk-read of the DOM positions and sizes needed to draw the
// view, so that we don't interleave reading and writing to the DOM.
function getDimensions(cm) {
  var d = cm.display, left = {}, width = {};
  var gutterLeft = d.gutters.clientLeft;
  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
    width[cm.options.gutters[i]] = n.clientWidth;
  }
  return {fixedPos: compensateForHScroll(d),
          gutterTotalWidth: d.gutters.offsetWidth,
          gutterLeft: left,
          gutterWidth: width,
          wrapperWidth: d.wrapper.clientWidth}
}

// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
// but using getBoundingClientRect to get a sub-pixel-accurate
// result.
function compensateForHScroll(display) {
  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
}

// Returns a function that estimates the height of a line, to use as
// first approximation until the line becomes visible (and is thus
// properly measurable).
function estimateHeight(cm) {
  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
  return function (line) {
    if (lineIsHidden(cm.doc, line)) { return 0 }

    var widgetsHeight = 0;
    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
    } }

    if (wrapping)
      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
    else
      { return widgetsHeight + th }
  }
}

function estimateLineHeights(cm) {
  var doc = cm.doc, est = estimateHeight(cm);
  doc.iter(function (line) {
    var estHeight = est(line);
    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
  });
}

// Given a mouse event, find the corresponding position. If liberal
// is false, it checks whether a gutter or scrollbar was clicked,
// and returns null if it was. forRect is used by rectangular
// selections, and tries to estimate a character position even for
// coordinates beyond the right of the text.
function posFromMouse(cm, e, liberal, forRect) {
  var display = cm.display;
  if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

  var x, y, space = display.lineSpace.getBoundingClientRect();
  // Fails unpredictably on IE[67] when mouse is dragged around quickly.
  try { x = e.clientX - space.left; y = e.clientY - space.top; }
  catch (e) { return null }
  var coords = coordsChar(cm, x, y), line;
  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
  }
  return coords
}

// Find the view element corresponding to a given line. Return null
// when the line isn't visible.
function findViewIndex(cm, n) {
  if (n >= cm.display.viewTo) { return null }
  n -= cm.display.viewFrom;
  if (n < 0) { return null }
  var view = cm.display.view;
  for (var i = 0; i < view.length; i++) {
    n -= view[i].size;
    if (n < 0) { return i }
  }
}

function updateSelection(cm) {
  cm.display.input.showSelection(cm.display.input.prepareSelection());
}

function prepareSelection(cm, primary) {
  if ( primary === void 0 ) primary = true;

  var doc = cm.doc, result = {};
  var curFragment = result.cursors = document.createDocumentFragment();
  var selFragment = result.selection = document.createDocumentFragment();

  for (var i = 0; i < doc.sel.ranges.length; i++) {
    if (!primary && i == doc.sel.primIndex) { continue }
    var range$$1 = doc.sel.ranges[i];
    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }
    var collapsed = range$$1.empty();
    if (collapsed || cm.options.showCursorWhenSelecting)
      { drawSelectionCursor(cm, range$$1.head, curFragment); }
    if (!collapsed)
      { drawSelectionRange(cm, range$$1, selFragment); }
  }
  return result
}

// Draws a cursor for the given range
function drawSelectionCursor(cm, head, output) {
  var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

  var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
  cursor.style.left = pos.left + "px";
  cursor.style.top = pos.top + "px";
  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

  if (pos.other) {
    // Secondary cursor, shown when on a 'jump' in bi-directional text
    var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
    otherCursor.style.display = "";
    otherCursor.style.left = pos.other.left + "px";
    otherCursor.style.top = pos.other.top + "px";
    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
  }
}

function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

// Draws the given range as a highlighted selection
function drawSelectionRange(cm, range$$1, output) {
  var display = cm.display, doc = cm.doc;
  var fragment = document.createDocumentFragment();
  var padding = paddingH(cm.display), leftSide = padding.left;
  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
  var docLTR = doc.direction == "ltr";

  function add(left, top, width, bottom) {
    if (top < 0) { top = 0; }
    top = Math.round(top);
    bottom = Math.round(bottom);
    fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
  }

  function drawForLine(line, fromArg, toArg) {
    var lineObj = getLine(doc, line);
    var lineLen = lineObj.text.length;
    var start, end;
    function coords(ch, bias) {
      return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
    }

    function wrapX(pos, dir, side) {
      var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
      var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
      var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
      return coords(ch, prop)[prop]
    }

    var order = getOrder(lineObj, doc.direction);
    iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
      var ltr = dir == "ltr";
      var fromPos = coords(from, ltr ? "left" : "right");
      var toPos = coords(to - 1, ltr ? "right" : "left");

      var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
      var first = i == 0, last = !order || i == order.length - 1;
      if (toPos.top - fromPos.top <= 3) { // Single line
        var openLeft = (docLTR ? openStart : openEnd) && first;
        var openRight = (docLTR ? openEnd : openStart) && last;
        var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
        var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
        add(left, fromPos.top, right - left, fromPos.bottom);
      } else { // Multiple lines
        var topLeft, topRight, botLeft, botRight;
        if (ltr) {
          topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
          topRight = docLTR ? rightSide : wrapX(from, dir, "before");
          botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
          botRight = docLTR && openEnd && last ? rightSide : toPos.right;
        } else {
          topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
          topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
          botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
          botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
        }
        add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
        if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
        add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
      }

      if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
      if (cmpCoords(toPos, start) < 0) { start = toPos; }
      if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
      if (cmpCoords(toPos, end) < 0) { end = toPos; }
    });
    return {start: start, end: end}
  }

  var sFrom = range$$1.from(), sTo = range$$1.to();
  if (sFrom.line == sTo.line) {
    drawForLine(sFrom.line, sFrom.ch, sTo.ch);
  } else {
    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
    var singleVLine = visualLine(fromLine) == visualLine(toLine);
    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
    if (singleVLine) {
      if (leftEnd.top < rightStart.top - 2) {
        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
      } else {
        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
      }
    }
    if (leftEnd.bottom < rightStart.top)
      { add(leftSide, leftEnd.bottom, null, rightStart.top); }
  }

  output.appendChild(fragment);
}

// Cursor-blinking
function restartBlink(cm) {
  if (!cm.state.focused) { return }
  var display = cm.display;
  clearInterval(display.blinker);
  var on = true;
  display.cursorDiv.style.visibility = "";
  if (cm.options.cursorBlinkRate > 0)
    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
      cm.options.cursorBlinkRate); }
  else if (cm.options.cursorBlinkRate < 0)
    { display.cursorDiv.style.visibility = "hidden"; }
}

function ensureFocus(cm) {
  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
}

function delayBlurEvent(cm) {
  cm.state.delayingBlurEvent = true;
  setTimeout(function () { if (cm.state.delayingBlurEvent) {
    cm.state.delayingBlurEvent = false;
    onBlur(cm);
  } }, 100);
}

function onFocus(cm, e) {
  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }

  if (cm.options.readOnly == "nocursor") { return }
  if (!cm.state.focused) {
    signal(cm, "focus", cm, e);
    cm.state.focused = true;
    addClass(cm.display.wrapper, "CodeMirror-focused");
    // This test prevents this from firing when a context
    // menu is closed (since the input reset would kill the
    // select-all detection hack)
    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
      cm.display.input.reset();
      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
    }
    cm.display.input.receivedFocus();
  }
  restartBlink(cm);
}
function onBlur(cm, e) {
  if (cm.state.delayingBlurEvent) { return }

  if (cm.state.focused) {
    signal(cm, "blur", cm, e);
    cm.state.focused = false;
    rmClass(cm.display.wrapper, "CodeMirror-focused");
  }
  clearInterval(cm.display.blinker);
  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
}

// Read the actual heights of the rendered lines, and update their
// stored heights to match.
function updateHeightsInViewport(cm) {
  var display = cm.display;
  var prevBottom = display.lineDiv.offsetTop;
  for (var i = 0; i < display.view.length; i++) {
    var cur = display.view[i], height = (void 0);
    if (cur.hidden) { continue }
    if (ie && ie_version < 8) {
      var bot = cur.node.offsetTop + cur.node.offsetHeight;
      height = bot - prevBottom;
      prevBottom = bot;
    } else {
      var box = cur.node.getBoundingClientRect();
      height = box.bottom - box.top;
    }
    var diff = cur.line.height - height;
    if (height < 2) { height = textHeight(display); }
    if (diff > .005 || diff < -.005) {
      updateLineHeight(cur.line, height);
      updateWidgetHeight(cur.line);
      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
        { updateWidgetHeight(cur.rest[j]); } }
    }
  }
}

// Read and store the height of line widgets associated with the
// given line.
function updateWidgetHeight(line) {
  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
    var w = line.widgets[i], parent = w.node.parentNode;
    if (parent) { w.height = parent.offsetHeight; }
  } }
}

// Compute the lines that are visible in a given viewport (defaults
// the the current scroll position). viewport may contain top,
// height, and ensure (see op.scrollToPos) properties.
function visibleLines(display, doc, viewport) {
  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
  top = Math.floor(top - paddingTop(display));
  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
  // forces those lines into the viewport (if possible).
  if (viewport && viewport.ensure) {
    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
    if (ensureFrom < from) {
      from = ensureFrom;
      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
      to = ensureTo;
    }
  }
  return {from: from, to: Math.max(to, from + 1)}
}

// Re-align line numbers and gutter marks to compensate for
// horizontal scrolling.
function alignHorizontally(cm) {
  var display = cm.display, view = display.view;
  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
  var gutterW = display.gutters.offsetWidth, left = comp + "px";
  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
    if (cm.options.fixedGutter) {
      if (view[i].gutter)
        { view[i].gutter.style.left = left; }
      if (view[i].gutterBackground)
        { view[i].gutterBackground.style.left = left; }
    }
    var align = view[i].alignable;
    if (align) { for (var j = 0; j < align.length; j++)
      { align[j].style.left = left; } }
  } }
  if (cm.options.fixedGutter)
    { display.gutters.style.left = (comp + gutterW) + "px"; }
}

// Used to ensure that the line number gutter is still the right
// size for the current document size. Returns true when an update
// is needed.
function maybeUpdateLineNumberWidth(cm) {
  if (!cm.options.lineNumbers) { return false }
  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
  if (last.length != display.lineNumChars) {
    var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                               "CodeMirror-linenumber CodeMirror-gutter-elt"));
    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
    display.lineGutter.style.width = "";
    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
    display.lineNumWidth = display.lineNumInnerWidth + padding;
    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
    display.lineGutter.style.width = display.lineNumWidth + "px";
    updateGutterSpace(cm);
    return true
  }
  return false
}

// SCROLLING THINGS INTO VIEW

// If an editor sits on the top or bottom of the window, partially
// scrolled out of view, this ensures that the cursor is visible.
function maybeScrollWindow(cm, rect) {
  if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
  if (rect.top + box.top < 0) { doScroll = true; }
  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
  if (doScroll != null && !phantom) {
    var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
    cm.display.lineSpace.appendChild(scrollNode);
    scrollNode.scrollIntoView(doScroll);
    cm.display.lineSpace.removeChild(scrollNode);
  }
}

// Scroll a given position into view (immediately), verifying that
// it actually became visible (as line heights are accurately
// measured, the position of something may 'drift' during drawing).
function scrollPosIntoView(cm, pos, end, margin) {
  if (margin == null) { margin = 0; }
  var rect;
  if (!cm.options.lineWrapping && pos == end) {
    // Set pos and end to the cursor positions around the character pos sticks to
    // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
    // If pos == Pos(_, 0, "before"), pos and end are unchanged
    pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
    end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
  }
  for (var limit = 0; limit < 5; limit++) {
    var changed = false;
    var coords = cursorCoords(cm, pos);
    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
    rect = {left: Math.min(coords.left, endCoords.left),
            top: Math.min(coords.top, endCoords.top) - margin,
            right: Math.max(coords.left, endCoords.left),
            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
    var scrollPos = calculateScrollPos(cm, rect);
    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
    if (scrollPos.scrollTop != null) {
      updateScrollTop(cm, scrollPos.scrollTop);
      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
    }
    if (scrollPos.scrollLeft != null) {
      setScrollLeft(cm, scrollPos.scrollLeft);
      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
    }
    if (!changed) { break }
  }
  return rect
}

// Scroll a given set of coordinates into view (immediately).
function scrollIntoView(cm, rect) {
  var scrollPos = calculateScrollPos(cm, rect);
  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
}

// Calculate a new scroll position needed to scroll the given
// rectangle into view. Returns an object with scrollTop and
// scrollLeft properties. When these are undefined, the
// vertical/horizontal position does not need to be adjusted.
function calculateScrollPos(cm, rect) {
  var display = cm.display, snapMargin = textHeight(cm.display);
  if (rect.top < 0) { rect.top = 0; }
  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
  var screen = displayHeight(cm), result = {};
  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
  var docBottom = cm.doc.height + paddingVert(display);
  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
  if (rect.top < screentop) {
    result.scrollTop = atTop ? 0 : rect.top;
  } else if (rect.bottom > screentop + screen) {
    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
    if (newTop != screentop) { result.scrollTop = newTop; }
  }

  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
  var tooWide = rect.right - rect.left > screenw;
  if (tooWide) { rect.right = rect.left + screenw; }
  if (rect.left < 10)
    { result.scrollLeft = 0; }
  else if (rect.left < screenleft)
    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
  else if (rect.right > screenw + screenleft - 3)
    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
  return result
}

// Store a relative adjustment to the scroll position in the current
// operation (to be applied when the operation finishes).
function addToScrollTop(cm, top) {
  if (top == null) { return }
  resolveScrollToPos(cm);
  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
}

// Make sure that at the end of the operation the current cursor is
// shown.
function ensureCursorVisible(cm) {
  resolveScrollToPos(cm);
  var cur = cm.getCursor();
  cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
}

function scrollToCoords(cm, x, y) {
  if (x != null || y != null) { resolveScrollToPos(cm); }
  if (x != null) { cm.curOp.scrollLeft = x; }
  if (y != null) { cm.curOp.scrollTop = y; }
}

function scrollToRange(cm, range$$1) {
  resolveScrollToPos(cm);
  cm.curOp.scrollToPos = range$$1;
}

// When an operation has its scrollToPos property set, and another
// scroll action is applied before the end of the operation, this
// 'simulates' scrolling that position into view in a cheap way, so
// that the effect of intermediate scroll commands is not ignored.
function resolveScrollToPos(cm) {
  var range$$1 = cm.curOp.scrollToPos;
  if (range$$1) {
    cm.curOp.scrollToPos = null;
    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
    scrollToCoordsRange(cm, from, to, range$$1.margin);
  }
}

function scrollToCoordsRange(cm, from, to, margin) {
  var sPos = calculateScrollPos(cm, {
    left: Math.min(from.left, to.left),
    top: Math.min(from.top, to.top) - margin,
    right: Math.max(from.right, to.right),
    bottom: Math.max(from.bottom, to.bottom) + margin
  });
  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
}

// Sync the scrollable area and scrollbars, ensure the viewport
// covers the visible area.
function updateScrollTop(cm, val) {
  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
  if (!gecko) { updateDisplaySimple(cm, {top: val}); }
  setScrollTop(cm, val, true);
  if (gecko) { updateDisplaySimple(cm); }
  startWorker(cm, 100);
}

function setScrollTop(cm, val, forceScroll) {
  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
  cm.doc.scrollTop = val;
  cm.display.scrollbars.setScrollTop(val);
  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
}

// Sync scroller and scrollbar, ensure the gutter elements are
// aligned.
function setScrollLeft(cm, val, isScroller, forceScroll) {
  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
  cm.doc.scrollLeft = val;
  alignHorizontally(cm);
  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
  cm.display.scrollbars.setScrollLeft(val);
}

// SCROLLBARS

// Prepare DOM reads needed to update the scrollbars. Done in one
// shot to minimize update/measure roundtrips.
function measureForScrollbars(cm) {
  var d = cm.display, gutterW = d.gutters.offsetWidth;
  var docH = Math.round(cm.doc.height + paddingVert(cm.display));
  return {
    clientHeight: d.scroller.clientHeight,
    viewHeight: d.wrapper.clientHeight,
    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
    viewWidth: d.wrapper.clientWidth,
    barLeft: cm.options.fixedGutter ? gutterW : 0,
    docHeight: docH,
    scrollHeight: docH + scrollGap(cm) + d.barHeight,
    nativeBarWidth: d.nativeBarWidth,
    gutterWidth: gutterW
  }
}

var NativeScrollbars = function(place, scroll, cm) {
  this.cm = cm;
  var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
  var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
  place(vert); place(horiz);

  on(vert, "scroll", function () {
    if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
  });
  on(horiz, "scroll", function () {
    if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
  });

  this.checkedZeroWidth = false;
  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
};

NativeScrollbars.prototype.update = function (measure) {
  var needsH = measure.scrollWidth > measure.clientWidth + 1;
  var needsV = measure.scrollHeight > measure.clientHeight + 1;
  var sWidth = measure.nativeBarWidth;

  if (needsV) {
    this.vert.style.display = "block";
    this.vert.style.bottom = needsH ? sWidth + "px" : "0";
    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
    // A bug in IE8 can cause this value to be negative, so guard it.
    this.vert.firstChild.style.height =
      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
  } else {
    this.vert.style.display = "";
    this.vert.firstChild.style.height = "0";
  }

  if (needsH) {
    this.horiz.style.display = "block";
    this.horiz.style.right = needsV ? sWidth + "px" : "0";
    this.horiz.style.left = measure.barLeft + "px";
    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
    this.horiz.firstChild.style.width =
      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
  } else {
    this.horiz.style.display = "";
    this.horiz.firstChild.style.width = "0";
  }

  if (!this.checkedZeroWidth && measure.clientHeight > 0) {
    if (sWidth == 0) { this.zeroWidthHack(); }
    this.checkedZeroWidth = true;
  }

  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
};

NativeScrollbars.prototype.setScrollLeft = function (pos) {
  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
};

NativeScrollbars.prototype.setScrollTop = function (pos) {
  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
};

NativeScrollbars.prototype.zeroWidthHack = function () {
  var w = mac && !mac_geMountainLion ? "12px" : "18px";
  this.horiz.style.height = this.vert.style.width = w;
  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
  this.disableHoriz = new Delayed;
  this.disableVert = new Delayed;
};

NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
  bar.style.pointerEvents = "auto";
  function maybeDisable() {
    // To find out whether the scrollbar is still visible, we
    // check whether the element under the pixel in the bottom
    // right corner of the scrollbar box is the scrollbar box
    // itself (when the bar is still visible) or its filler child
    // (when the bar is hidden). If it is still visible, we keep
    // it enabled, if it's hidden, we disable pointer events.
    var box = bar.getBoundingClientRect();
    var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
    if (elt$$1 != bar) { bar.style.pointerEvents = "none"; }
    else { delay.set(1000, maybeDisable); }
  }
  delay.set(1000, maybeDisable);
};

NativeScrollbars.prototype.clear = function () {
  var parent = this.horiz.parentNode;
  parent.removeChild(this.horiz);
  parent.removeChild(this.vert);
};

var NullScrollbars = function () {};

NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
NullScrollbars.prototype.setScrollLeft = function () {};
NullScrollbars.prototype.setScrollTop = function () {};
NullScrollbars.prototype.clear = function () {};

function updateScrollbars(cm, measure) {
  if (!measure) { measure = measureForScrollbars(cm); }
  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
  updateScrollbarsInner(cm, measure);
  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
      { updateHeightsInViewport(cm); }
    updateScrollbarsInner(cm, measureForScrollbars(cm));
    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
  }
}

// Re-synchronize the fake scrollbars with the actual size of the
// content.
function updateScrollbarsInner(cm, measure) {
  var d = cm.display;
  var sizes = d.scrollbars.update(measure);

  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
  d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

  if (sizes.right && sizes.bottom) {
    d.scrollbarFiller.style.display = "block";
    d.scrollbarFiller.style.height = sizes.bottom + "px";
    d.scrollbarFiller.style.width = sizes.right + "px";
  } else { d.scrollbarFiller.style.display = ""; }
  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
    d.gutterFiller.style.display = "block";
    d.gutterFiller.style.height = sizes.bottom + "px";
    d.gutterFiller.style.width = measure.gutterWidth + "px";
  } else { d.gutterFiller.style.display = ""; }
}

var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

function initScrollbars(cm) {
  if (cm.display.scrollbars) {
    cm.display.scrollbars.clear();
    if (cm.display.scrollbars.addClass)
      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
  }

  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
    // Prevent clicks in the scrollbars from killing focus
    on(node, "mousedown", function () {
      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
    });
    node.setAttribute("cm-not-content", "true");
  }, function (pos, axis) {
    if (axis == "horizontal") { setScrollLeft(cm, pos); }
    else { updateScrollTop(cm, pos); }
  }, cm);
  if (cm.display.scrollbars.addClass)
    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
}

// Operations are used to wrap a series of changes to the editor
// state in such a way that each change won't have to update the
// cursor and display (which would be awkward, slow, and
// error-prone). Instead, display updates are batched and then all
// combined and executed at once.

var nextOpId = 0;
// Start a new operation.
function startOperation(cm) {
  cm.curOp = {
    cm: cm,
    viewChanged: false,      // Flag that indicates that lines might need to be redrawn
    startHeight: cm.doc.height, // Used to detect need to update scrollbar
    forceUpdate: false,      // Used to force a redraw
    updateInput: null,       // Whether to reset the input textarea
    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
    changeObjs: null,        // Accumulated changes, for firing change events
    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
    selectionChanged: false, // Whether the selection needs to be redrawn
    updateMaxLine: false,    // Set when the widest line needs to be determined anew
    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
    scrollToPos: null,       // Used to scroll to a specific position
    focus: false,
    id: ++nextOpId           // Unique ID
  };
  pushOperation(cm.curOp);
}

// Finish an operation, updating the display and signalling delayed events
function endOperation(cm) {
  var op = cm.curOp;
  finishOperation(op, function (group) {
    for (var i = 0; i < group.ops.length; i++)
      { group.ops[i].cm.curOp = null; }
    endOperations(group);
  });
}

// The DOM updates done when an operation finishes are batched so
// that the minimum number of relayouts are required.
function endOperations(group) {
  var ops = group.ops;
  for (var i = 0; i < ops.length; i++) // Read DOM
    { endOperation_R1(ops[i]); }
  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
    { endOperation_W1(ops[i$1]); }
  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
    { endOperation_R2(ops[i$2]); }
  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
    { endOperation_W2(ops[i$3]); }
  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
    { endOperation_finish(ops[i$4]); }
}

function endOperation_R1(op) {
  var cm = op.cm, display = cm.display;
  maybeClipScrollbars(cm);
  if (op.updateMaxLine) { findMaxLine(cm); }

  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                       op.scrollToPos.to.line >= display.viewTo) ||
    display.maxLineChanged && cm.options.lineWrapping;
  op.update = op.mustUpdate &&
    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
}

function endOperation_W1(op) {
  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
}

function endOperation_R2(op) {
  var cm = op.cm, display = cm.display;
  if (op.updatedDisplay) { updateHeightsInViewport(cm); }

  op.barMeasure = measureForScrollbars(cm);

  // If the max line changed since it was last measured, measure it,
  // and ensure the document's width matches it.
  // updateDisplay_W2 will use these properties to do the actual resizing
  if (display.maxLineChanged && !cm.options.lineWrapping) {
    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
    cm.display.sizerWidth = op.adjustWidthTo;
    op.barMeasure.scrollWidth =
      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
  }

  if (op.updatedDisplay || op.selectionChanged)
    { op.preparedSelection = display.input.prepareSelection(); }
}

function endOperation_W2(op) {
  var cm = op.cm;

  if (op.adjustWidthTo != null) {
    cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
    if (op.maxScrollLeft < cm.doc.scrollLeft)
      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
    cm.display.maxLineChanged = false;
  }

  var takeFocus = op.focus && op.focus == activeElt();
  if (op.preparedSelection)
    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
  if (op.updatedDisplay || op.startHeight != cm.doc.height)
    { updateScrollbars(cm, op.barMeasure); }
  if (op.updatedDisplay)
    { setDocumentHeight(cm, op.barMeasure); }

  if (op.selectionChanged) { restartBlink(cm); }

  if (cm.state.focused && op.updateInput)
    { cm.display.input.reset(op.typing); }
  if (takeFocus) { ensureFocus(op.cm); }
}

function endOperation_finish(op) {
  var cm = op.cm, display = cm.display, doc = cm.doc;

  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

  // Abort mouse wheel delta measurement, when scrolling explicitly
  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
    { display.wheelStartX = display.wheelStartY = null; }

  // Propagate the scroll position to the actual DOM scroller
  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
  // If we need to scroll a specific position into view, do so.
  if (op.scrollToPos) {
    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
    maybeScrollWindow(cm, rect);
  }

  // Fire events for markers that are hidden/unidden by editing or
  // undoing
  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
  if (hidden) { for (var i = 0; i < hidden.length; ++i)
    { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

  if (display.wrapper.offsetHeight)
    { doc.scrollTop = cm.display.scroller.scrollTop; }

  // Fire change events, and delayed event handlers
  if (op.changeObjs)
    { signal(cm, "changes", cm, op.changeObjs); }
  if (op.update)
    { op.update.finish(); }
}

// Run the given function in an operation
function runInOp(cm, f) {
  if (cm.curOp) { return f() }
  startOperation(cm);
  try { return f() }
  finally { endOperation(cm); }
}
// Wraps a function in an operation. Returns the wrapped function.
function operation(cm, f) {
  return function() {
    if (cm.curOp) { return f.apply(cm, arguments) }
    startOperation(cm);
    try { return f.apply(cm, arguments) }
    finally { endOperation(cm); }
  }
}
// Used to add methods to editor and doc instances, wrapping them in
// operations.
function methodOp(f) {
  return function() {
    if (this.curOp) { return f.apply(this, arguments) }
    startOperation(this);
    try { return f.apply(this, arguments) }
    finally { endOperation(this); }
  }
}
function docMethodOp(f) {
  return function() {
    var cm = this.cm;
    if (!cm || cm.curOp) { return f.apply(this, arguments) }
    startOperation(cm);
    try { return f.apply(this, arguments) }
    finally { endOperation(cm); }
  }
}

// Updates the display.view data structure for a given change to the
// document. From and to are in pre-change coordinates. Lendiff is
// the amount of lines added or subtracted by the change. This is
// used for changes that span multiple lines, or change the way
// lines are divided into visual lines. regLineChange (below)
// registers single-line changes.
function regChange(cm, from, to, lendiff) {
  if (from == null) { from = cm.doc.first; }
  if (to == null) { to = cm.doc.first + cm.doc.size; }
  if (!lendiff) { lendiff = 0; }

  var display = cm.display;
  if (lendiff && to < display.viewTo &&
      (display.updateLineNumbers == null || display.updateLineNumbers > from))
    { display.updateLineNumbers = from; }

  cm.curOp.viewChanged = true;

  if (from >= display.viewTo) { // Change after
    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
      { resetView(cm); }
  } else if (to <= display.viewFrom) { // Change before
    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
      resetView(cm);
    } else {
      display.viewFrom += lendiff;
      display.viewTo += lendiff;
    }
  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
    resetView(cm);
  } else if (from <= display.viewFrom) { // Top overlap
    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
    if (cut) {
      display.view = display.view.slice(cut.index);
      display.viewFrom = cut.lineN;
      display.viewTo += lendiff;
    } else {
      resetView(cm);
    }
  } else if (to >= display.viewTo) { // Bottom overlap
    var cut$1 = viewCuttingPoint(cm, from, from, -1);
    if (cut$1) {
      display.view = display.view.slice(0, cut$1.index);
      display.viewTo = cut$1.lineN;
    } else {
      resetView(cm);
    }
  } else { // Gap in the middle
    var cutTop = viewCuttingPoint(cm, from, from, -1);
    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
    if (cutTop && cutBot) {
      display.view = display.view.slice(0, cutTop.index)
        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
        .concat(display.view.slice(cutBot.index));
      display.viewTo += lendiff;
    } else {
      resetView(cm);
    }
  }

  var ext = display.externalMeasured;
  if (ext) {
    if (to < ext.lineN)
      { ext.lineN += lendiff; }
    else if (from < ext.lineN + ext.size)
      { display.externalMeasured = null; }
  }
}

// Register a change to a single line. Type must be one of "text",
// "gutter", "class", "widget"
function regLineChange(cm, line, type) {
  cm.curOp.viewChanged = true;
  var display = cm.display, ext = cm.display.externalMeasured;
  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
    { display.externalMeasured = null; }

  if (line < display.viewFrom || line >= display.viewTo) { return }
  var lineView = display.view[findViewIndex(cm, line)];
  if (lineView.node == null) { return }
  var arr = lineView.changes || (lineView.changes = []);
  if (indexOf(arr, type) == -1) { arr.push(type); }
}

// Clear the view.
function resetView(cm) {
  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
  cm.display.view = [];
  cm.display.viewOffset = 0;
}

function viewCuttingPoint(cm, oldN, newN, dir) {
  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
    { return {index: index, lineN: newN} }
  var n = cm.display.viewFrom;
  for (var i = 0; i < index; i++)
    { n += view[i].size; }
  if (n != oldN) {
    if (dir > 0) {
      if (index == view.length - 1) { return null }
      diff = (n + view[index].size) - oldN;
      index++;
    } else {
      diff = n - oldN;
    }
    oldN += diff; newN += diff;
  }
  while (visualLineNo(cm.doc, newN) != newN) {
    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
    index += dir;
  }
  return {index: index, lineN: newN}
}

// Force the view to cover a given range, adding empty view element
// or clipping off existing ones as needed.
function adjustView(cm, from, to) {
  var display = cm.display, view = display.view;
  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
    display.view = buildViewArray(cm, from, to);
    display.viewFrom = from;
  } else {
    if (display.viewFrom > from)
      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
    else if (display.viewFrom < from)
      { display.view = display.view.slice(findViewIndex(cm, from)); }
    display.viewFrom = from;
    if (display.viewTo < to)
      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
    else if (display.viewTo > to)
      { display.view = display.view.slice(0, findViewIndex(cm, to)); }
  }
  display.viewTo = to;
}

// Count the number of lines in the view whose DOM representation is
// out of date (or nonexistent).
function countDirtyView(cm) {
  var view = cm.display.view, dirty = 0;
  for (var i = 0; i < view.length; i++) {
    var lineView = view[i];
    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
  }
  return dirty
}

// HIGHLIGHT WORKER

function startWorker(cm, time) {
  if (cm.doc.highlightFrontier < cm.display.viewTo)
    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
}

function highlightWorker(cm) {
  var doc = cm.doc;
  if (doc.highlightFrontier >= cm.display.viewTo) { return }
  var end = +new Date + cm.options.workTime;
  var context = getContextBefore(cm, doc.highlightFrontier);
  var changedLines = [];

  doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
    if (context.line >= cm.display.viewFrom) { // Visible
      var oldStyles = line.styles;
      var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
      var highlighted = highlightLine(cm, line, context, true);
      if (resetState) { context.state = resetState; }
      line.styles = highlighted.styles;
      var oldCls = line.styleClasses, newCls = highlighted.classes;
      if (newCls) { line.styleClasses = newCls; }
      else if (oldCls) { line.styleClasses = null; }
      var ischange = !oldStyles || oldStyles.length != line.styles.length ||
        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
      if (ischange) { changedLines.push(context.line); }
      line.stateAfter = context.save();
      context.nextLine();
    } else {
      if (line.text.length <= cm.options.maxHighlightLength)
        { processLine(cm, line.text, context); }
      line.stateAfter = context.line % 5 == 0 ? context.save() : null;
      context.nextLine();
    }
    if (+new Date > end) {
      startWorker(cm, cm.options.workDelay);
      return true
    }
  });
  doc.highlightFrontier = context.line;
  doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
  if (changedLines.length) { runInOp(cm, function () {
    for (var i = 0; i < changedLines.length; i++)
      { regLineChange(cm, changedLines[i], "text"); }
  }); }
}

// DISPLAY DRAWING

var DisplayUpdate = function(cm, viewport, force) {
  var display = cm.display;

  this.viewport = viewport;
  // Store some values that we'll need later (but don't want to force a relayout for)
  this.visible = visibleLines(display, cm.doc, viewport);
  this.editorIsHidden = !display.wrapper.offsetWidth;
  this.wrapperHeight = display.wrapper.clientHeight;
  this.wrapperWidth = display.wrapper.clientWidth;
  this.oldDisplayWidth = displayWidth(cm);
  this.force = force;
  this.dims = getDimensions(cm);
  this.events = [];
};

DisplayUpdate.prototype.signal = function (emitter, type) {
  if (hasHandler(emitter, type))
    { this.events.push(arguments); }
};
DisplayUpdate.prototype.finish = function () {
    var this$1 = this;

  for (var i = 0; i < this.events.length; i++)
    { signal.apply(null, this$1.events[i]); }
};

function maybeClipScrollbars(cm) {
  var display = cm.display;
  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
    display.heightForcer.style.height = scrollGap(cm) + "px";
    display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
    display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
    display.scrollbarsClipped = true;
  }
}

function selectionSnapshot(cm) {
  if (cm.hasFocus()) { return null }
  var active = activeElt();
  if (!active || !contains(cm.display.lineDiv, active)) { return null }
  var result = {activeElt: active};
  if (window.getSelection) {
    var sel = window.getSelection();
    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
      result.anchorNode = sel.anchorNode;
      result.anchorOffset = sel.anchorOffset;
      result.focusNode = sel.focusNode;
      result.focusOffset = sel.focusOffset;
    }
  }
  return result
}

function restoreSelection(snapshot) {
  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
  snapshot.activeElt.focus();
  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
    var sel = window.getSelection(), range$$1 = document.createRange();
    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
    range$$1.collapse(false);
    sel.removeAllRanges();
    sel.addRange(range$$1);
    sel.extend(snapshot.focusNode, snapshot.focusOffset);
  }
}

// Does the actual updating of the line display. Bails out
// (returning false) when there is nothing to be done and forced is
// false.
function updateDisplayIfNeeded(cm, update) {
  var display = cm.display, doc = cm.doc;

  if (update.editorIsHidden) {
    resetView(cm);
    return false
  }

  // Bail out if the visible area is already rendered and nothing changed.
  if (!update.force &&
      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
      display.renderedView == display.view && countDirtyView(cm) == 0)
    { return false }

  if (maybeUpdateLineNumberWidth(cm)) {
    resetView(cm);
    update.dims = getDimensions(cm);
  }

  // Compute a suitable new viewport (from & to)
  var end = doc.first + doc.size;
  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
  if (sawCollapsedSpans) {
    from = visualLineNo(cm.doc, from);
    to = visualLineEndNo(cm.doc, to);
  }

  var different = from != display.viewFrom || to != display.viewTo ||
    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
  adjustView(cm, from, to);

  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
  // Position the mover div to align with the current scroll position
  cm.display.mover.style.top = display.viewOffset + "px";

  var toUpdate = countDirtyView(cm);
  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
    { return false }

  // For big changes, we hide the enclosing element during the
  // update, since that speeds up the operations on most browsers.
  var selSnapshot = selectionSnapshot(cm);
  if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
  patchDisplay(cm, display.updateLineNumbers, update.dims);
  if (toUpdate > 4) { display.lineDiv.style.display = ""; }
  display.renderedView = display.view;
  // There might have been a widget with a focused element that got
  // hidden or updated, if so re-focus it.
  restoreSelection(selSnapshot);

  // Prevent selection and cursors from interfering with the scroll
  // width and height.
  removeChildren(display.cursorDiv);
  removeChildren(display.selectionDiv);
  display.gutters.style.height = display.sizer.style.minHeight = 0;

  if (different) {
    display.lastWrapHeight = update.wrapperHeight;
    display.lastWrapWidth = update.wrapperWidth;
    startWorker(cm, 400);
  }

  display.updateLineNumbers = null;

  return true
}

function postUpdateDisplay(cm, update) {
  var viewport = update.viewport;

  for (var first = true;; first = false) {
    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
      // Clip forced viewport to actual scrollable area.
      if (viewport && viewport.top != null)
        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
      // Updated line heights might result in the drawn area not
      // actually covering the viewport. Keep looping until it does.
      update.visible = visibleLines(cm.display, cm.doc, viewport);
      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
        { break }
    }
    if (!updateDisplayIfNeeded(cm, update)) { break }
    updateHeightsInViewport(cm);
    var barMeasure = measureForScrollbars(cm);
    updateSelection(cm);
    updateScrollbars(cm, barMeasure);
    setDocumentHeight(cm, barMeasure);
    update.force = false;
  }

  update.signal(cm, "update", cm);
  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
    update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
  }
}

function updateDisplaySimple(cm, viewport) {
  var update = new DisplayUpdate(cm, viewport);
  if (updateDisplayIfNeeded(cm, update)) {
    updateHeightsInViewport(cm);
    postUpdateDisplay(cm, update);
    var barMeasure = measureForScrollbars(cm);
    updateSelection(cm);
    updateScrollbars(cm, barMeasure);
    setDocumentHeight(cm, barMeasure);
    update.finish();
  }
}

// Sync the actual display DOM structure with display.view, removing
// nodes for lines that are no longer in view, and creating the ones
// that are not there yet, and updating the ones that are out of
// date.
function patchDisplay(cm, updateNumbersFrom, dims) {
  var display = cm.display, lineNumbers = cm.options.lineNumbers;
  var container = display.lineDiv, cur = container.firstChild;

  function rm(node) {
    var next = node.nextSibling;
    // Works around a throw-scroll bug in OS X Webkit
    if (webkit && mac && cm.display.currentWheelTarget == node)
      { node.style.display = "none"; }
    else
      { node.parentNode.removeChild(node); }
    return next
  }

  var view = display.view, lineN = display.viewFrom;
  // Loop over the elements in the view, syncing cur (the DOM nodes
  // in display.lineDiv) with the view as we go.
  for (var i = 0; i < view.length; i++) {
    var lineView = view[i];
    if (lineView.hidden) {
    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
      var node = buildLineElement(cm, lineView, lineN, dims);
      container.insertBefore(node, cur);
    } else { // Already drawn
      while (cur != lineView.node) { cur = rm(cur); }
      var updateNumber = lineNumbers && updateNumbersFrom != null &&
        updateNumbersFrom <= lineN && lineView.lineNumber;
      if (lineView.changes) {
        if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
        updateLineForChanges(cm, lineView, lineN, dims);
      }
      if (updateNumber) {
        removeChildren(lineView.lineNumber);
        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
      }
      cur = lineView.node.nextSibling;
    }
    lineN += lineView.size;
  }
  while (cur) { cur = rm(cur); }
}

function updateGutterSpace(cm) {
  var width = cm.display.gutters.offsetWidth;
  cm.display.sizer.style.marginLeft = width + "px";
}

function setDocumentHeight(cm, measure) {
  cm.display.sizer.style.minHeight = measure.docHeight + "px";
  cm.display.heightForcer.style.top = measure.docHeight + "px";
  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
}

// Rebuild the gutter elements, ensure the margin to the left of the
// code matches their width.
function updateGutters(cm) {
  var gutters = cm.display.gutters, specs = cm.options.gutters;
  removeChildren(gutters);
  var i = 0;
  for (; i < specs.length; ++i) {
    var gutterClass = specs[i];
    var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
    if (gutterClass == "CodeMirror-linenumbers") {
      cm.display.lineGutter = gElt;
      gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
    }
  }
  gutters.style.display = i ? "" : "none";
  updateGutterSpace(cm);
}

// Make sure the gutters options contains the element
// "CodeMirror-linenumbers" when the lineNumbers option is true.
function setGuttersForLineNumbers(options) {
  var found = indexOf(options.gutters, "CodeMirror-linenumbers");
  if (found == -1 && options.lineNumbers) {
    options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
  } else if (found > -1 && !options.lineNumbers) {
    options.gutters = options.gutters.slice(0);
    options.gutters.splice(found, 1);
  }
}

// Since the delta values reported on mouse wheel events are
// unstandardized between browsers and even browser versions, and
// generally horribly unpredictable, this code starts by measuring
// the scroll effect that the first few mouse wheel events have,
// and, from that, detects the way it can convert deltas to pixel
// offsets afterwards.
//
// The reason we want to know the amount a wheel event will scroll
// is that it gives us a chance to update the display before the
// actual scrolling happens, reducing flickering.

var wheelSamples = 0;
var wheelPixelsPerUnit = null;
// Fill in a browser-detected starting value on browsers where we
// know one. These don't have to be accurate -- the result of them
// being wrong would just be a slight flicker on the first wheel
// scroll (if it is large enough).
if (ie) { wheelPixelsPerUnit = -.53; }
else if (gecko) { wheelPixelsPerUnit = 15; }
else if (chrome) { wheelPixelsPerUnit = -.7; }
else if (safari) { wheelPixelsPerUnit = -1/3; }

function wheelEventDelta(e) {
  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
  else if (dy == null) { dy = e.wheelDelta; }
  return {x: dx, y: dy}
}
function wheelEventPixels(e) {
  var delta = wheelEventDelta(e);
  delta.x *= wheelPixelsPerUnit;
  delta.y *= wheelPixelsPerUnit;
  return delta
}

function onScrollWheel(cm, e) {
  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

  var display = cm.display, scroll = display.scroller;
  // Quit if there's nothing to scroll here
  var canScrollX = scroll.scrollWidth > scroll.clientWidth;
  var canScrollY = scroll.scrollHeight > scroll.clientHeight;
  if (!(dx && canScrollX || dy && canScrollY)) { return }

  // Webkit browsers on OS X abort momentum scrolls when the target
  // of the scroll event is removed from the scrollable element.
  // This hack (see related code in patchDisplay) makes sure the
  // element is kept around.
  if (dy && mac && webkit) {
    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
      for (var i = 0; i < view.length; i++) {
        if (view[i].node == cur) {
          cm.display.currentWheelTarget = cur;
          break outer
        }
      }
    }
  }

  // On some browsers, horizontal scrolling will cause redraws to
  // happen before the gutter has been realigned, causing it to
  // wriggle around in a most unseemly way. When we have an
  // estimated pixels/delta value, we just handle horizontal
  // scrolling entirely here. It'll be slightly off from native, but
  // better than glitching out.
  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
    if (dy && canScrollY)
      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
    // Only prevent default scrolling if vertical scrolling is
    // actually possible. Otherwise, it causes vertical scroll
    // jitter on OSX trackpads when deltaX is small and deltaY
    // is large (issue #3579)
    if (!dy || (dy && canScrollY))
      { e_preventDefault(e); }
    display.wheelStartX = null; // Abort measurement, if in progress
    return
  }

  // 'Project' the visible viewport to cover the area that is being
  // scrolled into view (if we know enough to estimate it).
  if (dy && wheelPixelsPerUnit != null) {
    var pixels = dy * wheelPixelsPerUnit;
    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
    updateDisplaySimple(cm, {top: top, bottom: bot});
  }

  if (wheelSamples < 20) {
    if (display.wheelStartX == null) {
      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
      display.wheelDX = dx; display.wheelDY = dy;
      setTimeout(function () {
        if (display.wheelStartX == null) { return }
        var movedX = scroll.scrollLeft - display.wheelStartX;
        var movedY = scroll.scrollTop - display.wheelStartY;
        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
          (movedX && display.wheelDX && movedX / display.wheelDX);
        display.wheelStartX = display.wheelStartY = null;
        if (!sample) { return }
        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
        ++wheelSamples;
      }, 200);
    } else {
      display.wheelDX += dx; display.wheelDY += dy;
    }
  }
}

// Selection objects are immutable. A new one is created every time
// the selection changes. A selection is one or more non-overlapping
// (and non-touching) ranges, sorted, and an integer that indicates
// which one is the primary selection (the one that's scrolled into
// view, that getCursor returns, etc).
var Selection = function(ranges, primIndex) {
  this.ranges = ranges;
  this.primIndex = primIndex;
};

Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

Selection.prototype.equals = function (other) {
    var this$1 = this;

  if (other == this) { return true }
  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
  for (var i = 0; i < this.ranges.length; i++) {
    var here = this$1.ranges[i], there = other.ranges[i];
    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
  }
  return true
};

Selection.prototype.deepCopy = function () {
    var this$1 = this;

  var out = [];
  for (var i = 0; i < this.ranges.length; i++)
    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }
  return new Selection(out, this.primIndex)
};

Selection.prototype.somethingSelected = function () {
    var this$1 = this;

  for (var i = 0; i < this.ranges.length; i++)
    { if (!this$1.ranges[i].empty()) { return true } }
  return false
};

Selection.prototype.contains = function (pos, end) {
    var this$1 = this;

  if (!end) { end = pos; }
  for (var i = 0; i < this.ranges.length; i++) {
    var range = this$1.ranges[i];
    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
      { return i }
  }
  return -1
};

var Range = function(anchor, head) {
  this.anchor = anchor; this.head = head;
};

Range.prototype.from = function () { return minPos(this.anchor, this.head) };
Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

// Take an unsorted, potentially overlapping set of ranges, and
// build a selection out of it. 'Consumes' ranges array (modifying
// it).
function normalizeSelection(ranges, primIndex) {
  var prim = ranges[primIndex];
  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
  primIndex = indexOf(ranges, prim);
  for (var i = 1; i < ranges.length; i++) {
    var cur = ranges[i], prev = ranges[i - 1];
    if (cmp(prev.to(), cur.from()) >= 0) {
      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
      if (i <= primIndex) { --primIndex; }
      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
    }
  }
  return new Selection(ranges, primIndex)
}

function simpleSelection(anchor, head) {
  return new Selection([new Range(anchor, head || anchor)], 0)
}

// Compute the position of the end of a change (its 'to' property
// refers to the pre-change end).
function changeEnd(change) {
  if (!change.text) { return change.to }
  return Pos(change.from.line + change.text.length - 1,
             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
}

// Adjust a position to refer to the post-change position of the
// same text, or the end of the change if the change covers it.
function adjustForChange(pos, change) {
  if (cmp(pos, change.from) < 0) { return pos }
  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
  return Pos(line, ch)
}

function computeSelAfterChange(doc, change) {
  var out = [];
  for (var i = 0; i < doc.sel.ranges.length; i++) {
    var range = doc.sel.ranges[i];
    out.push(new Range(adjustForChange(range.anchor, change),
                       adjustForChange(range.head, change)));
  }
  return normalizeSelection(out, doc.sel.primIndex)
}

function offsetPos(pos, old, nw) {
  if (pos.line == old.line)
    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
  else
    { return Pos(nw.line + (pos.line - old.line), pos.ch) }
}

// Used by replaceSelections to allow moving the selection to the
// start or around the replaced test. Hint may be "start" or "around".
function computeReplacedSel(doc, changes, hint) {
  var out = [];
  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];
    var from = offsetPos(change.from, oldPrev, newPrev);
    var to = offsetPos(changeEnd(change), oldPrev, newPrev);
    oldPrev = change.to;
    newPrev = to;
    if (hint == "around") {
      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
      out[i] = new Range(inv ? to : from, inv ? from : to);
    } else {
      out[i] = new Range(from, from);
    }
  }
  return new Selection(out, doc.sel.primIndex)
}

// Used to get the editor into a consistent state again when options change.

function loadMode(cm) {
  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
  resetModeState(cm);
}

function resetModeState(cm) {
  cm.doc.iter(function (line) {
    if (line.stateAfter) { line.stateAfter = null; }
    if (line.styles) { line.styles = null; }
  });
  cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
  startWorker(cm, 100);
  cm.state.modeGen++;
  if (cm.curOp) { regChange(cm); }
}

// DOCUMENT DATA STRUCTURE

// By default, updates that start and end at the beginning of a line
// are treated specially, in order to make the association of line
// widgets and marker elements with the text behave more intuitive.
function isWholeLineUpdate(doc, change) {
  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
}

// Perform a change on the document data structure.
function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
  function spansFor(n) {return markedSpans ? markedSpans[n] : null}
  function update(line, text, spans) {
    updateLine(line, text, spans, estimateHeight$$1);
    signalLater(line, "change", line, change);
  }
  function linesFor(start, end) {
    var result = [];
    for (var i = start; i < end; ++i)
      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }
    return result
  }

  var from = change.from, to = change.to, text = change.text;
  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

  // Adjust the line structure
  if (change.full) {
    doc.insert(0, linesFor(0, text.length));
    doc.remove(text.length, doc.size - text.length);
  } else if (isWholeLineUpdate(doc, change)) {
    // This is a whole-line replace. Treated specially to make
    // sure line objects move the way they are supposed to.
    var added = linesFor(0, text.length - 1);
    update(lastLine, lastLine.text, lastSpans);
    if (nlines) { doc.remove(from.line, nlines); }
    if (added.length) { doc.insert(from.line, added); }
  } else if (firstLine == lastLine) {
    if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
    } else {
      var added$1 = linesFor(1, text.length - 1);
      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      doc.insert(from.line + 1, added$1);
    }
  } else if (text.length == 1) {
    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
    doc.remove(from.line + 1, nlines);
  } else {
    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
    var added$2 = linesFor(1, text.length - 1);
    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
    doc.insert(from.line + 1, added$2);
  }

  signalLater(doc, "change", doc, change);
}

// Call f for all linked documents.
function linkedDocs(doc, f, sharedHistOnly) {
  function propagate(doc, skip, sharedHist) {
    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
      var rel = doc.linked[i];
      if (rel.doc == skip) { continue }
      var shared = sharedHist && rel.sharedHist;
      if (sharedHistOnly && !shared) { continue }
      f(rel.doc, shared);
      propagate(rel.doc, doc, shared);
    } }
  }
  propagate(doc, null, true);
}

// Attach a document to an editor.
function attachDoc(cm, doc) {
  if (doc.cm) { throw new Error("This document is already in use.") }
  cm.doc = doc;
  doc.cm = cm;
  estimateLineHeights(cm);
  loadMode(cm);
  setDirectionClass(cm);
  if (!cm.options.lineWrapping) { findMaxLine(cm); }
  cm.options.mode = doc.modeOption;
  regChange(cm);
}

function setDirectionClass(cm) {
  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
}

function directionChanged(cm) {
  runInOp(cm, function () {
    setDirectionClass(cm);
    regChange(cm);
  });
}

function History(startGen) {
  // Arrays of change events and selections. Doing something adds an
  // event to done and clears undo. Undoing moves events from done
  // to undone, redoing moves them in the other direction.
  this.done = []; this.undone = [];
  this.undoDepth = Infinity;
  // Used to track when changes can be merged into a single undo
  // event
  this.lastModTime = this.lastSelTime = 0;
  this.lastOp = this.lastSelOp = null;
  this.lastOrigin = this.lastSelOrigin = null;
  // Used by the isClean() method
  this.generation = this.maxGeneration = startGen || 1;
}

// Create a history change event from an updateDoc-style change
// object.
function historyChangeFromChange(doc, change) {
  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
  return histChange
}

// Pop all selection events off the end of a history array. Stop at
// a change event.
function clearSelectionEvents(array) {
  while (array.length) {
    var last = lst(array);
    if (last.ranges) { array.pop(); }
    else { break }
  }
}

// Find the top change event in the history. Pop off selection
// events that are in the way.
function lastChangeEvent(hist, force) {
  if (force) {
    clearSelectionEvents(hist.done);
    return lst(hist.done)
  } else if (hist.done.length && !lst(hist.done).ranges) {
    return lst(hist.done)
  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
    hist.done.pop();
    return lst(hist.done)
  }
}

// Register a change in the history. Merges changes that are within
// a single operation, or are close together with an origin that
// allows merging (starting with "+") into a single event.
function addChangeToHistory(doc, change, selAfter, opId) {
  var hist = doc.history;
  hist.undone.length = 0;
  var time = +new Date, cur;
  var last;

  if ((hist.lastOp == opId ||
       hist.lastOrigin == change.origin && change.origin &&
       ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
        change.origin.charAt(0) == "*")) &&
      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
    // Merge this change into the last event
    last = lst(cur.changes);
    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
      // Optimized case for simple insertion -- don't want to add
      // new changesets for every character typed
      last.to = changeEnd(change);
    } else {
      // Add new sub-event
      cur.changes.push(historyChangeFromChange(doc, change));
    }
  } else {
    // Can not be merged, start a new event.
    var before = lst(hist.done);
    if (!before || !before.ranges)
      { pushSelectionToHistory(doc.sel, hist.done); }
    cur = {changes: [historyChangeFromChange(doc, change)],
           generation: hist.generation};
    hist.done.push(cur);
    while (hist.done.length > hist.undoDepth) {
      hist.done.shift();
      if (!hist.done[0].ranges) { hist.done.shift(); }
    }
  }
  hist.done.push(selAfter);
  hist.generation = ++hist.maxGeneration;
  hist.lastModTime = hist.lastSelTime = time;
  hist.lastOp = hist.lastSelOp = opId;
  hist.lastOrigin = hist.lastSelOrigin = change.origin;

  if (!last) { signal(doc, "historyAdded"); }
}

function selectionEventCanBeMerged(doc, origin, prev, sel) {
  var ch = origin.charAt(0);
  return ch == "*" ||
    ch == "+" &&
    prev.ranges.length == sel.ranges.length &&
    prev.somethingSelected() == sel.somethingSelected() &&
    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
}

// Called whenever the selection changes, sets the new selection as
// the pending selection in the history, and pushes the old pending
// selection into the 'done' array when it was significantly
// different (in number of selected ranges, emptiness, or time).
function addSelectionToHistory(doc, sel, opId, options) {
  var hist = doc.history, origin = options && options.origin;

  // A new event is started when the previous origin does not match
  // the current, or the origins don't allow matching. Origins
  // starting with * are always merged, those starting with + are
  // merged when similar and close together in time.
  if (opId == hist.lastSelOp ||
      (origin && hist.lastSelOrigin == origin &&
       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
    { hist.done[hist.done.length - 1] = sel; }
  else
    { pushSelectionToHistory(sel, hist.done); }

  hist.lastSelTime = +new Date;
  hist.lastSelOrigin = origin;
  hist.lastSelOp = opId;
  if (options && options.clearRedo !== false)
    { clearSelectionEvents(hist.undone); }
}

function pushSelectionToHistory(sel, dest) {
  var top = lst(dest);
  if (!(top && top.ranges && top.equals(sel)))
    { dest.push(sel); }
}

// Used to store marked span information in the history.
function attachLocalSpans(doc, change, from, to) {
  var existing = change["spans_" + doc.id], n = 0;
  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
    if (line.markedSpans)
      { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
    ++n;
  });
}

// When un/re-doing restores text containing marked spans, those
// that have been explicitly cleared should not be restored.
function removeClearedSpans(spans) {
  if (!spans) { return null }
  var out;
  for (var i = 0; i < spans.length; ++i) {
    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
    else if (out) { out.push(spans[i]); }
  }
  return !out ? spans : out.length ? out : null
}

// Retrieve and filter the old marked spans stored in a change event.
function getOldSpans(doc, change) {
  var found = change["spans_" + doc.id];
  if (!found) { return null }
  var nw = [];
  for (var i = 0; i < change.text.length; ++i)
    { nw.push(removeClearedSpans(found[i])); }
  return nw
}

// Used for un/re-doing changes from the history. Combines the
// result of computing the existing spans with the set of spans that
// existed in the history (so that deleting around a span and then
// undoing brings back the span).
function mergeOldSpans(doc, change) {
  var old = getOldSpans(doc, change);
  var stretched = stretchSpansOverChange(doc, change);
  if (!old) { return stretched }
  if (!stretched) { return old }

  for (var i = 0; i < old.length; ++i) {
    var oldCur = old[i], stretchCur = stretched[i];
    if (oldCur && stretchCur) {
      spans: for (var j = 0; j < stretchCur.length; ++j) {
        var span = stretchCur[j];
        for (var k = 0; k < oldCur.length; ++k)
          { if (oldCur[k].marker == span.marker) { continue spans } }
        oldCur.push(span);
      }
    } else if (stretchCur) {
      old[i] = stretchCur;
    }
  }
  return old
}

// Used both to provide a JSON-safe object in .getHistory, and, when
// detaching a document, to split the history in two
function copyHistoryArray(events, newGroup, instantiateSel) {
  var copy = [];
  for (var i = 0; i < events.length; ++i) {
    var event = events[i];
    if (event.ranges) {
      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
      continue
    }
    var changes = event.changes, newChanges = [];
    copy.push({changes: newChanges});
    for (var j = 0; j < changes.length; ++j) {
      var change = changes[j], m = (void 0);
      newChanges.push({from: change.from, to: change.to, text: change.text});
      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
        if (indexOf(newGroup, Number(m[1])) > -1) {
          lst(newChanges)[prop] = change[prop];
          delete change[prop];
        }
      } } }
    }
  }
  return copy
}

// The 'scroll' parameter given to many of these indicated whether
// the new cursor position should be scrolled into view after
// modifying the selection.

// If shift is held or the extend flag is set, extends a range to
// include a given position (and optionally a second position).
// Otherwise, simply returns the range between the given positions.
// Used for cursor motion and such.
function extendRange(range, head, other, extend) {
  if (extend) {
    var anchor = range.anchor;
    if (other) {
      var posBefore = cmp(head, anchor) < 0;
      if (posBefore != (cmp(other, anchor) < 0)) {
        anchor = head;
        head = other;
      } else if (posBefore != (cmp(head, other) < 0)) {
        head = other;
      }
    }
    return new Range(anchor, head)
  } else {
    return new Range(other || head, head)
  }
}

// Extend the primary selection range, discard the rest.
function extendSelection(doc, head, other, options, extend) {
  if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
  setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
}

// Extend all selections (pos is an array of selections with length
// equal the number of selections)
function extendSelections(doc, heads, options) {
  var out = [];
  var extend = doc.cm && (doc.cm.display.shift || doc.extend);
  for (var i = 0; i < doc.sel.ranges.length; i++)
    { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
  var newSel = normalizeSelection(out, doc.sel.primIndex);
  setSelection(doc, newSel, options);
}

// Updates a single range in the selection.
function replaceOneSelection(doc, i, range, options) {
  var ranges = doc.sel.ranges.slice(0);
  ranges[i] = range;
  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
}

// Reset the selection to a single range.
function setSimpleSelection(doc, anchor, head, options) {
  setSelection(doc, simpleSelection(anchor, head), options);
}

// Give beforeSelectionChange handlers a change to influence a
// selection update.
function filterSelectionChange(doc, sel, options) {
  var obj = {
    ranges: sel.ranges,
    update: function(ranges) {
      var this$1 = this;

      this.ranges = [];
      for (var i = 0; i < ranges.length; i++)
        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                   clipPos(doc, ranges[i].head)); }
    },
    origin: options && options.origin
  };
  signal(doc, "beforeSelectionChange", doc, obj);
  if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }
  else { return sel }
}

function setSelectionReplaceHistory(doc, sel, options) {
  var done = doc.history.done, last = lst(done);
  if (last && last.ranges) {
    done[done.length - 1] = sel;
    setSelectionNoUndo(doc, sel, options);
  } else {
    setSelection(doc, sel, options);
  }
}

// Set a new selection.
function setSelection(doc, sel, options) {
  setSelectionNoUndo(doc, sel, options);
  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
}

function setSelectionNoUndo(doc, sel, options) {
  if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
    { sel = filterSelectionChange(doc, sel, options); }

  var bias = options && options.bias ||
    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

  if (!(options && options.scroll === false) && doc.cm)
    { ensureCursorVisible(doc.cm); }
}

function setSelectionInner(doc, sel) {
  if (sel.equals(doc.sel)) { return }

  doc.sel = sel;

  if (doc.cm) {
    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
    signalCursorActivity(doc.cm);
  }
  signalLater(doc, "cursorActivity", doc);
}

// Verify that the selection does not partially select any atomic
// marked ranges.
function reCheckSelection(doc) {
  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
}

// Return a selection that does not partially select any atomic
// ranges.
function skipAtomicInSelection(doc, sel, bias, mayClear) {
  var out;
  for (var i = 0; i < sel.ranges.length; i++) {
    var range = sel.ranges[i];
    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
    if (out || newAnchor != range.anchor || newHead != range.head) {
      if (!out) { out = sel.ranges.slice(0, i); }
      out[i] = new Range(newAnchor, newHead);
    }
  }
  return out ? normalizeSelection(out, sel.primIndex) : sel
}

function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
  var line = getLine(doc, pos.line);
  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
    var sp = line.markedSpans[i], m = sp.marker;
    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
      if (mayClear) {
        signal(m, "beforeCursorEnter");
        if (m.explicitlyCleared) {
          if (!line.markedSpans) { break }
          else {--i; continue}
        }
      }
      if (!m.atomic) { continue }

      if (oldPos) {
        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
          { return skipAtomicInner(doc, near, pos, dir, mayClear) }
      }

      var far = m.find(dir < 0 ? -1 : 1);
      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
    }
  } }
  return pos
}

// Ensure a given position is not inside an atomic range.
function skipAtomic(doc, pos, oldPos, bias, mayClear) {
  var dir = bias || 1;
  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
  if (!found) {
    doc.cantEdit = true;
    return Pos(doc.first, 0)
  }
  return found
}

function movePos(doc, pos, dir, line) {
  if (dir < 0 && pos.ch == 0) {
    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
    else { return null }
  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
    else { return null }
  } else {
    return new Pos(pos.line, pos.ch + dir)
  }
}

function selectAll(cm) {
  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
}

// UPDATING

// Allow "beforeChange" event handlers to influence a change
function filterChange(doc, change, update) {
  var obj = {
    canceled: false,
    from: change.from,
    to: change.to,
    text: change.text,
    origin: change.origin,
    cancel: function () { return obj.canceled = true; }
  };
  if (update) { obj.update = function (from, to, text, origin) {
    if (from) { obj.from = clipPos(doc, from); }
    if (to) { obj.to = clipPos(doc, to); }
    if (text) { obj.text = text; }
    if (origin !== undefined) { obj.origin = origin; }
  }; }
  signal(doc, "beforeChange", doc, obj);
  if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

  if (obj.canceled) { return null }
  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
}

// Apply a change to a document, and add it to the document's
// history, and propagating it to all linked documents.
function makeChange(doc, change, ignoreReadOnly) {
  if (doc.cm) {
    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
    if (doc.cm.state.suppressEdits) { return }
  }

  if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
    change = filterChange(doc, change, true);
    if (!change) { return }
  }

  // Possibly split or suppress the update based on the presence
  // of read-only spans in its range.
  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
  if (split) {
    for (var i = split.length - 1; i >= 0; --i)
      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
  } else {
    makeChangeInner(doc, change);
  }
}

function makeChangeInner(doc, change) {
  if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
  var selAfter = computeSelAfterChange(doc, change);
  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
  var rebased = [];

  linkedDocs(doc, function (doc, sharedHist) {
    if (!sharedHist && indexOf(rebased, doc.history) == -1) {
      rebaseHist(doc.history, change);
      rebased.push(doc.history);
    }
    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
  });
}

// Revert a change stored in a document's history.
function makeChangeFromHistory(doc, type, allowSelectionOnly) {
  var suppress = doc.cm && doc.cm.state.suppressEdits;
  if (suppress && !allowSelectionOnly) { return }

  var hist = doc.history, event, selAfter = doc.sel;
  var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

  // Verify that there is a useable event (so that ctrl-z won't
  // needlessly clear selection events)
  var i = 0;
  for (; i < source.length; i++) {
    event = source[i];
    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
      { break }
  }
  if (i == source.length) { return }
  hist.lastOrigin = hist.lastSelOrigin = null;

  for (;;) {
    event = source.pop();
    if (event.ranges) {
      pushSelectionToHistory(event, dest);
      if (allowSelectionOnly && !event.equals(doc.sel)) {
        setSelection(doc, event, {clearRedo: false});
        return
      }
      selAfter = event;
    } else if (suppress) {
      source.push(event);
      return
    } else { break }
  }

  // Build up a reverse change object to add to the opposite history
  // stack (redo when undoing, and vice versa).
  var antiChanges = [];
  pushSelectionToHistory(selAfter, dest);
  dest.push({changes: antiChanges, generation: hist.generation});
  hist.generation = event.generation || ++hist.maxGeneration;

  var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

  var loop = function ( i ) {
    var change = event.changes[i];
    change.origin = type;
    if (filter && !filterChange(doc, change, false)) {
      source.length = 0;
      return {}
    }

    antiChanges.push(historyChangeFromChange(doc, change));

    var after = i ? computeSelAfterChange(doc, change) : lst(source);
    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
    var rebased = [];

    // Propagate to the linked documents
    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
    });
  };

  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
    var returned = loop( i$1 );

    if ( returned ) return returned.v;
  }
}

// Sub-views need their line numbers shifted when text is added
// above or below them in the parent document.
function shiftDoc(doc, distance) {
  if (distance == 0) { return }
  doc.first += distance;
  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
    Pos(range.anchor.line + distance, range.anchor.ch),
    Pos(range.head.line + distance, range.head.ch)
  ); }), doc.sel.primIndex);
  if (doc.cm) {
    regChange(doc.cm, doc.first, doc.first - distance, distance);
    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
      { regLineChange(doc.cm, l, "gutter"); }
  }
}

// More lower-level change function, handling only a single document
// (not linked ones).
function makeChangeSingleDoc(doc, change, selAfter, spans) {
  if (doc.cm && !doc.cm.curOp)
    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

  if (change.to.line < doc.first) {
    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
    return
  }
  if (change.from.line > doc.lastLine()) { return }

  // Clip the change to the size of this doc
  if (change.from.line < doc.first) {
    var shift = change.text.length - 1 - (doc.first - change.from.line);
    shiftDoc(doc, shift);
    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
              text: [lst(change.text)], origin: change.origin};
  }
  var last = doc.lastLine();
  if (change.to.line > last) {
    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
              text: [change.text[0]], origin: change.origin};
  }

  change.removed = getBetween(doc, change.from, change.to);

  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
  else { updateDoc(doc, change, spans); }
  setSelectionNoUndo(doc, selAfter, sel_dontScroll);
}

// Handle the interaction of a change to a document with the editor
// that this document is part of.
function makeChangeSingleDocInEditor(cm, change, spans) {
  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

  var recomputeMaxLength = false, checkWidthStart = from.line;
  if (!cm.options.lineWrapping) {
    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
    doc.iter(checkWidthStart, to.line + 1, function (line) {
      if (line == display.maxLine) {
        recomputeMaxLength = true;
        return true
      }
    });
  }

  if (doc.sel.contains(change.from, change.to) > -1)
    { signalCursorActivity(cm); }

  updateDoc(doc, change, spans, estimateHeight(cm));

  if (!cm.options.lineWrapping) {
    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
      var len = lineLength(line);
      if (len > display.maxLineLength) {
        display.maxLine = line;
        display.maxLineLength = len;
        display.maxLineChanged = true;
        recomputeMaxLength = false;
      }
    });
    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
  }

  retreatFrontier(doc, from.line);
  startWorker(cm, 400);

  var lendiff = change.text.length - (to.line - from.line) - 1;
  // Remember that these lines changed, for updating the display
  if (change.full)
    { regChange(cm); }
  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
    { regLineChange(cm, from.line, "text"); }
  else
    { regChange(cm, from.line, to.line + 1, lendiff); }

  var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
  if (changeHandler || changesHandler) {
    var obj = {
      from: from, to: to,
      text: change.text,
      removed: change.removed,
      origin: change.origin
    };
    if (changeHandler) { signalLater(cm, "change", cm, obj); }
    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
  }
  cm.display.selForContextMenu = null;
}

function replaceRange(doc, code, from, to, origin) {
  if (!to) { to = from; }
  if (cmp(to, from) < 0) { var assign;
    (assign = [to, from], from = assign[0], to = assign[1]); }
  if (typeof code == "string") { code = doc.splitLines(code); }
  makeChange(doc, {from: from, to: to, text: code, origin: origin});
}

// Rebasing/resetting history to deal with externally-sourced changes

function rebaseHistSelSingle(pos, from, to, diff) {
  if (to < pos.line) {
    pos.line += diff;
  } else if (from < pos.line) {
    pos.line = from;
    pos.ch = 0;
  }
}

// Tries to rebase an array of history events given a change in the
// document. If the change touches the same lines as the event, the
// event, and everything 'behind' it, is discarded. If the change is
// before the event, the event's positions are updated. Uses a
// copy-on-write scheme for the positions, to avoid having to
// reallocate them all on every rebase, but also avoid problems with
// shared position objects being unsafely updated.
function rebaseHistArray(array, from, to, diff) {
  for (var i = 0; i < array.length; ++i) {
    var sub = array[i], ok = true;
    if (sub.ranges) {
      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
      for (var j = 0; j < sub.ranges.length; j++) {
        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
      }
      continue
    }
    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
      var cur = sub.changes[j$1];
      if (to < cur.from.line) {
        cur.from = Pos(cur.from.line + diff, cur.from.ch);
        cur.to = Pos(cur.to.line + diff, cur.to.ch);
      } else if (from <= cur.to.line) {
        ok = false;
        break
      }
    }
    if (!ok) {
      array.splice(0, i + 1);
      i = 0;
    }
  }
}

function rebaseHist(hist, change) {
  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
  rebaseHistArray(hist.done, from, to, diff);
  rebaseHistArray(hist.undone, from, to, diff);
}

// Utility for applying a change to a line by handle or number,
// returning the number and optionally registering the line as
// changed.
function changeLine(doc, handle, changeType, op) {
  var no = handle, line = handle;
  if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
  else { no = lineNo(handle); }
  if (no == null) { return null }
  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
  return line
}

// The document is represented as a BTree consisting of leaves, with
// chunk of lines in them, and branches, with up to ten leaves or
// other branch nodes below them. The top node is always a branch
// node, and is the document object itself (meaning it has
// additional methods and properties).
//
// All nodes have parent links. The tree is used both to go from
// line numbers to line objects, and to go from objects to numbers.
// It also indexes by height, and is used to convert between height
// and line object, and to find the total height of the document.
//
// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

function LeafChunk(lines) {
  var this$1 = this;

  this.lines = lines;
  this.parent = null;
  var height = 0;
  for (var i = 0; i < lines.length; ++i) {
    lines[i].parent = this$1;
    height += lines[i].height;
  }
  this.height = height;
}

LeafChunk.prototype = {
  chunkSize: function() { return this.lines.length },

  // Remove the n lines at offset 'at'.
  removeInner: function(at, n) {
    var this$1 = this;

    for (var i = at, e = at + n; i < e; ++i) {
      var line = this$1.lines[i];
      this$1.height -= line.height;
      cleanUpLine(line);
      signalLater(line, "delete");
    }
    this.lines.splice(at, n);
  },

  // Helper used to collapse a small branch into a single leaf.
  collapse: function(lines) {
    lines.push.apply(lines, this.lines);
  },

  // Insert the given array of lines at offset 'at', count them as
  // having the given height.
  insertInner: function(at, lines, height) {
    var this$1 = this;

    this.height += height;
    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }
  },

  // Used to iterate over a part of the tree.
  iterN: function(at, n, op) {
    var this$1 = this;

    for (var e = at + n; at < e; ++at)
      { if (op(this$1.lines[at])) { return true } }
  }
};

function BranchChunk(children) {
  var this$1 = this;

  this.children = children;
  var size = 0, height = 0;
  for (var i = 0; i < children.length; ++i) {
    var ch = children[i];
    size += ch.chunkSize(); height += ch.height;
    ch.parent = this$1;
  }
  this.size = size;
  this.height = height;
  this.parent = null;
}

BranchChunk.prototype = {
  chunkSize: function() { return this.size },

  removeInner: function(at, n) {
    var this$1 = this;

    this.size -= n;
    for (var i = 0; i < this.children.length; ++i) {
      var child = this$1.children[i], sz = child.chunkSize();
      if (at < sz) {
        var rm = Math.min(n, sz - at), oldHeight = child.height;
        child.removeInner(at, rm);
        this$1.height -= oldHeight - child.height;
        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }
        if ((n -= rm) == 0) { break }
        at = 0;
      } else { at -= sz; }
    }
    // If the result is smaller than 25 lines, ensure that it is a
    // single leaf node.
    if (this.size - n < 25 &&
        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
      var lines = [];
      this.collapse(lines);
      this.children = [new LeafChunk(lines)];
      this.children[0].parent = this;
    }
  },

  collapse: function(lines) {
    var this$1 = this;

    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }
  },

  insertInner: function(at, lines, height) {
    var this$1 = this;

    this.size += lines.length;
    this.height += height;
    for (var i = 0; i < this.children.length; ++i) {
      var child = this$1.children[i], sz = child.chunkSize();
      if (at <= sz) {
        child.insertInner(at, lines, height);
        if (child.lines && child.lines.length > 50) {
          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
          var remaining = child.lines.length % 25 + 25;
          for (var pos = remaining; pos < child.lines.length;) {
            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
            child.height -= leaf.height;
            this$1.children.splice(++i, 0, leaf);
            leaf.parent = this$1;
          }
          child.lines = child.lines.slice(0, remaining);
          this$1.maybeSpill();
        }
        break
      }
      at -= sz;
    }
  },

  // When a node has grown, check whether it should be split.
  maybeSpill: function() {
    if (this.children.length <= 10) { return }
    var me = this;
    do {
      var spilled = me.children.splice(me.children.length - 5, 5);
      var sibling = new BranchChunk(spilled);
      if (!me.parent) { // Become the parent node
        var copy = new BranchChunk(me.children);
        copy.parent = me;
        me.children = [copy, sibling];
        me = copy;
     } else {
        me.size -= sibling.size;
        me.height -= sibling.height;
        var myIndex = indexOf(me.parent.children, me);
        me.parent.children.splice(myIndex + 1, 0, sibling);
      }
      sibling.parent = me.parent;
    } while (me.children.length > 10)
    me.parent.maybeSpill();
  },

  iterN: function(at, n, op) {
    var this$1 = this;

    for (var i = 0; i < this.children.length; ++i) {
      var child = this$1.children[i], sz = child.chunkSize();
      if (at < sz) {
        var used = Math.min(n, sz - at);
        if (child.iterN(at, used, op)) { return true }
        if ((n -= used) == 0) { break }
        at = 0;
      } else { at -= sz; }
    }
  }
};

// Line widgets are block elements displayed above or below a line.

var LineWidget = function(doc, node, options) {
  var this$1 = this;

  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
    { this$1[opt] = options[opt]; } } }
  this.doc = doc;
  this.node = node;
};

LineWidget.prototype.clear = function () {
    var this$1 = this;

  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
  if (no == null || !ws) { return }
  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }
  if (!ws.length) { line.widgets = null; }
  var height = widgetHeight(this);
  updateLineHeight(line, Math.max(0, line.height - height));
  if (cm) {
    runInOp(cm, function () {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, "widget");
    });
    signalLater(cm, "lineWidgetCleared", cm, this, no);
  }
};

LineWidget.prototype.changed = function () {
    var this$1 = this;

  var oldH = this.height, cm = this.doc.cm, line = this.line;
  this.height = null;
  var diff = widgetHeight(this) - oldH;
  if (!diff) { return }
  updateLineHeight(line, line.height + diff);
  if (cm) {
    runInOp(cm, function () {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
      signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
    });
  }
};
eventMixin(LineWidget);

function adjustScrollWhenAboveVisible(cm, line, diff) {
  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
    { addToScrollTop(cm, diff); }
}

function addLineWidget(doc, handle, node, options) {
  var widget = new LineWidget(doc, node, options);
  var cm = doc.cm;
  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
  changeLine(doc, handle, "widget", function (line) {
    var widgets = line.widgets || (line.widgets = []);
    if (widget.insertAt == null) { widgets.push(widget); }
    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
    widget.line = line;
    if (cm && !lineIsHidden(doc, line)) {
      var aboveVisible = heightAtLine(line) < doc.scrollTop;
      updateLineHeight(line, line.height + widgetHeight(widget));
      if (aboveVisible) { addToScrollTop(cm, widget.height); }
      cm.curOp.forceUpdate = true;
    }
    return true
  });
  if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
  return widget
}

// TEXTMARKERS

// Created with markText and setBookmark methods. A TextMarker is a
// handle that can be used to clear or find a marked position in the
// document. Line objects hold arrays (markedSpans) containing
// {from, to, marker} object pointing to such marker objects, and
// indicating that such a marker is present on that line. Multiple
// lines may point to the same marker when it spans across lines.
// The spans will have null for their from/to properties when the
// marker continues beyond the start/end of the line. Markers have
// links back to the lines they currently touch.

// Collapsed markers have unique ids, in order to be able to order
// them, which is needed for uniquely determining an outer marker
// when they overlap (they may nest, but not partially overlap).
var nextMarkerId = 0;

var TextMarker = function(doc, type) {
  this.lines = [];
  this.type = type;
  this.doc = doc;
  this.id = ++nextMarkerId;
};

// Clear the marker.
TextMarker.prototype.clear = function () {
    var this$1 = this;

  if (this.explicitlyCleared) { return }
  var cm = this.doc.cm, withOp = cm && !cm.curOp;
  if (withOp) { startOperation(cm); }
  if (hasHandler(this, "clear")) {
    var found = this.find();
    if (found) { signalLater(this, "clear", found.from, found.to); }
  }
  var min = null, max = null;
  for (var i = 0; i < this.lines.length; ++i) {
    var line = this$1.lines[i];
    var span = getMarkedSpanFor(line.markedSpans, this$1);
    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text"); }
    else if (cm) {
      if (span.to != null) { max = lineNo(line); }
      if (span.from != null) { min = lineNo(line); }
    }
    line.markedSpans = removeMarkedSpan(line.markedSpans, span);
    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
      { updateLineHeight(line, textHeight(cm.display)); }
  }
  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
    if (len > cm.display.maxLineLength) {
      cm.display.maxLine = visual;
      cm.display.maxLineLength = len;
      cm.display.maxLineChanged = true;
    }
  } }

  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
  this.lines.length = 0;
  this.explicitlyCleared = true;
  if (this.atomic && this.doc.cantEdit) {
    this.doc.cantEdit = false;
    if (cm) { reCheckSelection(cm.doc); }
  }
  if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
  if (withOp) { endOperation(cm); }
  if (this.parent) { this.parent.clear(); }
};

// Find the position of the marker in the document. Returns a {from,
// to} object by default. Side can be passed to get a specific side
// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
// Pos objects returned contain a line object, rather than a line
// number (used to prevent looking up the same line twice).
TextMarker.prototype.find = function (side, lineObj) {
    var this$1 = this;

  if (side == null && this.type == "bookmark") { side = 1; }
  var from, to;
  for (var i = 0; i < this.lines.length; ++i) {
    var line = this$1.lines[i];
    var span = getMarkedSpanFor(line.markedSpans, this$1);
    if (span.from != null) {
      from = Pos(lineObj ? line : lineNo(line), span.from);
      if (side == -1) { return from }
    }
    if (span.to != null) {
      to = Pos(lineObj ? line : lineNo(line), span.to);
      if (side == 1) { return to }
    }
  }
  return from && {from: from, to: to}
};

// Signals that the marker's widget changed, and surrounding layout
// should be recomputed.
TextMarker.prototype.changed = function () {
    var this$1 = this;

  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
  if (!pos || !cm) { return }
  runInOp(cm, function () {
    var line = pos.line, lineN = lineNo(pos.line);
    var view = findViewForLine(cm, lineN);
    if (view) {
      clearLineMeasurementCacheFor(view);
      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
    }
    cm.curOp.updateMaxLine = true;
    if (!lineIsHidden(widget.doc, line) && widget.height != null) {
      var oldHeight = widget.height;
      widget.height = null;
      var dHeight = widgetHeight(widget) - oldHeight;
      if (dHeight)
        { updateLineHeight(line, line.height + dHeight); }
    }
    signalLater(cm, "markerChanged", cm, this$1);
  });
};

TextMarker.prototype.attachLine = function (line) {
  if (!this.lines.length && this.doc.cm) {
    var op = this.doc.cm.curOp;
    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
  }
  this.lines.push(line);
};

TextMarker.prototype.detachLine = function (line) {
  this.lines.splice(indexOf(this.lines, line), 1);
  if (!this.lines.length && this.doc.cm) {
    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
  }
};
eventMixin(TextMarker);

// Create a marker, wire it up to the right lines, and
function markText(doc, from, to, options, type) {
  // Shared markers (across linked documents) are handled separately
  // (markTextShared will call out to this again, once per
  // document).
  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
  // Ensure we are in an operation.
  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

  var marker = new TextMarker(doc, type), diff = cmp(from, to);
  if (options) { copyObj(options, marker, false); }
  // Don't connect empty markers unless clearWhenEmpty is false
  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
    { return marker }
  if (marker.replacedWith) {
    // Showing up as a widget implies collapsed (widget replaces text)
    marker.collapsed = true;
    marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
  }
  if (marker.collapsed) {
    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
      { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
    seeCollapsedSpans();
  }

  if (marker.addToHistory)
    { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

  var curLine = from.line, cm = doc.cm, updateMaxLine;
  doc.iter(curLine, to.line + 1, function (line) {
    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
      { updateMaxLine = true; }
    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
    addMarkedSpan(line, new MarkedSpan(marker,
                                       curLine == from.line ? from.ch : null,
                                       curLine == to.line ? to.ch : null));
    ++curLine;
  });
  // lineIsHidden depends on the presence of the spans, so needs a second pass
  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
  }); }

  if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

  if (marker.readOnly) {
    seeReadOnlySpans();
    if (doc.history.done.length || doc.history.undone.length)
      { doc.clearHistory(); }
  }
  if (marker.collapsed) {
    marker.id = ++nextMarkerId;
    marker.atomic = true;
  }
  if (cm) {
    // Sync editor state
    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
    if (marker.collapsed)
      { regChange(cm, from.line, to.line + 1); }
    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
    if (marker.atomic) { reCheckSelection(cm.doc); }
    signalLater(cm, "markerAdded", cm, marker);
  }
  return marker
}

// SHARED TEXTMARKERS

// A shared marker spans multiple linked documents. It is
// implemented as a meta-marker-object controlling multiple normal
// markers.
var SharedTextMarker = function(markers, primary) {
  var this$1 = this;

  this.markers = markers;
  this.primary = primary;
  for (var i = 0; i < markers.length; ++i)
    { markers[i].parent = this$1; }
};

SharedTextMarker.prototype.clear = function () {
    var this$1 = this;

  if (this.explicitlyCleared) { return }
  this.explicitlyCleared = true;
  for (var i = 0; i < this.markers.length; ++i)
    { this$1.markers[i].clear(); }
  signalLater(this, "clear");
};

SharedTextMarker.prototype.find = function (side, lineObj) {
  return this.primary.find(side, lineObj)
};
eventMixin(SharedTextMarker);

function markTextShared(doc, from, to, options, type) {
  options = copyObj(options);
  options.shared = false;
  var markers = [markText(doc, from, to, options, type)], primary = markers[0];
  var widget = options.widgetNode;
  linkedDocs(doc, function (doc) {
    if (widget) { options.widgetNode = widget.cloneNode(true); }
    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
    for (var i = 0; i < doc.linked.length; ++i)
      { if (doc.linked[i].isParent) { return } }
    primary = lst(markers);
  });
  return new SharedTextMarker(markers, primary)
}

function findSharedMarkers(doc) {
  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
}

function copySharedMarkers(doc, markers) {
  for (var i = 0; i < markers.length; i++) {
    var marker = markers[i], pos = marker.find();
    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
    if (cmp(mFrom, mTo)) {
      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
      marker.markers.push(subMark);
      subMark.parent = marker;
    }
  }
}

function detachSharedMarkers(markers) {
  var loop = function ( i ) {
    var marker = markers[i], linked = [marker.primary.doc];
    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
    for (var j = 0; j < marker.markers.length; j++) {
      var subMarker = marker.markers[j];
      if (indexOf(linked, subMarker.doc) == -1) {
        subMarker.parent = null;
        marker.markers.splice(j--, 1);
      }
    }
  };

  for (var i = 0; i < markers.length; i++) loop( i );
}

var nextDocId = 0;
var Doc = function(text, mode, firstLine, lineSep, direction) {
  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
  if (firstLine == null) { firstLine = 0; }

  BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
  this.first = firstLine;
  this.scrollTop = this.scrollLeft = 0;
  this.cantEdit = false;
  this.cleanGeneration = 1;
  this.modeFrontier = this.highlightFrontier = firstLine;
  var start = Pos(firstLine, 0);
  this.sel = simpleSelection(start);
  this.history = new History(null);
  this.id = ++nextDocId;
  this.modeOption = mode;
  this.lineSep = lineSep;
  this.direction = (direction == "rtl") ? "rtl" : "ltr";
  this.extend = false;

  if (typeof text == "string") { text = this.splitLines(text); }
  updateDoc(this, {from: start, to: start, text: text});
  setSelection(this, simpleSelection(start), sel_dontScroll);
};

Doc.prototype = createObj(BranchChunk.prototype, {
  constructor: Doc,
  // Iterate over the document. Supports two forms -- with only one
  // argument, it calls that for each line in the document. With
  // three, it iterates over the range given by the first two (with
  // the second being non-inclusive).
  iter: function(from, to, op) {
    if (op) { this.iterN(from - this.first, to - from, op); }
    else { this.iterN(this.first, this.first + this.size, from); }
  },

  // Non-public interface for adding and removing lines.
  insert: function(at, lines) {
    var height = 0;
    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
    this.insertInner(at - this.first, lines, height);
  },
  remove: function(at, n) { this.removeInner(at - this.first, n); },

  // From here, the methods are part of the public interface. Most
  // are also available from CodeMirror (editor) instances.

  getValue: function(lineSep) {
    var lines = getLines(this, this.first, this.first + this.size);
    if (lineSep === false) { return lines }
    return lines.join(lineSep || this.lineSeparator())
  },
  setValue: docMethodOp(function(code) {
    var top = Pos(this.first, 0), last = this.first + this.size - 1;
    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                      text: this.splitLines(code), origin: "setValue", full: true}, true);
    if (this.cm) { scrollToCoords(this.cm, 0, 0); }
    setSelection(this, simpleSelection(top), sel_dontScroll);
  }),
  replaceRange: function(code, from, to, origin) {
    from = clipPos(this, from);
    to = to ? clipPos(this, to) : from;
    replaceRange(this, code, from, to, origin);
  },
  getRange: function(from, to, lineSep) {
    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
    if (lineSep === false) { return lines }
    return lines.join(lineSep || this.lineSeparator())
  },

  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
  getLineNumber: function(line) {return lineNo(line)},

  getLineHandleVisualStart: function(line) {
    if (typeof line == "number") { line = getLine(this, line); }
    return visualLine(line)
  },

  lineCount: function() {return this.size},
  firstLine: function() {return this.first},
  lastLine: function() {return this.first + this.size - 1},

  clipPos: function(pos) {return clipPos(this, pos)},

  getCursor: function(start) {
    var range$$1 = this.sel.primary(), pos;
    if (start == null || start == "head") { pos = range$$1.head; }
    else if (start == "anchor") { pos = range$$1.anchor; }
    else if (start == "end" || start == "to" || start === false) { pos = range$$1.to(); }
    else { pos = range$$1.from(); }
    return pos
  },
  listSelections: function() { return this.sel.ranges },
  somethingSelected: function() {return this.sel.somethingSelected()},

  setCursor: docMethodOp(function(line, ch, options) {
    setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
  }),
  setSelection: docMethodOp(function(anchor, head, options) {
    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
  }),
  extendSelection: docMethodOp(function(head, other, options) {
    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
  }),
  extendSelections: docMethodOp(function(heads, options) {
    extendSelections(this, clipPosArray(this, heads), options);
  }),
  extendSelectionsBy: docMethodOp(function(f, options) {
    var heads = map(this.sel.ranges, f);
    extendSelections(this, clipPosArray(this, heads), options);
  }),
  setSelections: docMethodOp(function(ranges, primary, options) {
    var this$1 = this;

    if (!ranges.length) { return }
    var out = [];
    for (var i = 0; i < ranges.length; i++)
      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
                         clipPos(this$1, ranges[i].head)); }
    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
    setSelection(this, normalizeSelection(out, primary), options);
  }),
  addSelection: docMethodOp(function(anchor, head, options) {
    var ranges = this.sel.ranges.slice(0);
    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
  }),

  getSelection: function(lineSep) {
    var this$1 = this;

    var ranges = this.sel.ranges, lines;
    for (var i = 0; i < ranges.length; i++) {
      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
      lines = lines ? lines.concat(sel) : sel;
    }
    if (lineSep === false) { return lines }
    else { return lines.join(lineSep || this.lineSeparator()) }
  },
  getSelections: function(lineSep) {
    var this$1 = this;

    var parts = [], ranges = this.sel.ranges;
    for (var i = 0; i < ranges.length; i++) {
      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }
      parts[i] = sel;
    }
    return parts
  },
  replaceSelection: function(code, collapse, origin) {
    var dup = [];
    for (var i = 0; i < this.sel.ranges.length; i++)
      { dup[i] = code; }
    this.replaceSelections(dup, collapse, origin || "+input");
  },
  replaceSelections: docMethodOp(function(code, collapse, origin) {
    var this$1 = this;

    var changes = [], sel = this.sel;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range$$1 = sel.ranges[i];
      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};
    }
    var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
      { makeChange(this$1, changes[i$1]); }
    if (newSel) { setSelectionReplaceHistory(this, newSel); }
    else if (this.cm) { ensureCursorVisible(this.cm); }
  }),
  undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
  redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

  setExtending: function(val) {this.extend = val;},
  getExtending: function() {return this.extend},

  historySize: function() {
    var hist = this.history, done = 0, undone = 0;
    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
    return {undo: done, redo: undone}
  },
  clearHistory: function() {this.history = new History(this.history.maxGeneration);},

  markClean: function() {
    this.cleanGeneration = this.changeGeneration(true);
  },
  changeGeneration: function(forceSplit) {
    if (forceSplit)
      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
    return this.history.generation
  },
  isClean: function (gen) {
    return this.history.generation == (gen || this.cleanGeneration)
  },

  getHistory: function() {
    return {done: copyHistoryArray(this.history.done),
            undone: copyHistoryArray(this.history.undone)}
  },
  setHistory: function(histData) {
    var hist = this.history = new History(this.history.maxGeneration);
    hist.done = copyHistoryArray(histData.done.slice(0), null, true);
    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
  },

  setGutterMarker: docMethodOp(function(line, gutterID, value) {
    return changeLine(this, line, "gutter", function (line) {
      var markers = line.gutterMarkers || (line.gutterMarkers = {});
      markers[gutterID] = value;
      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
      return true
    })
  }),

  clearGutter: docMethodOp(function(gutterID) {
    var this$1 = this;

    this.iter(function (line) {
      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
        changeLine(this$1, line, "gutter", function () {
          line.gutterMarkers[gutterID] = null;
          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
          return true
        });
      }
    });
  }),

  lineInfo: function(line) {
    var n;
    if (typeof line == "number") {
      if (!isLine(this, line)) { return null }
      n = line;
      line = getLine(this, line);
      if (!line) { return null }
    } else {
      n = lineNo(line);
      if (n == null) { return null }
    }
    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
            widgets: line.widgets}
  },

  addLineClass: docMethodOp(function(handle, where, cls) {
    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
      var prop = where == "text" ? "textClass"
               : where == "background" ? "bgClass"
               : where == "gutter" ? "gutterClass" : "wrapClass";
      if (!line[prop]) { line[prop] = cls; }
      else if (classTest(cls).test(line[prop])) { return false }
      else { line[prop] += " " + cls; }
      return true
    })
  }),
  removeLineClass: docMethodOp(function(handle, where, cls) {
    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
      var prop = where == "text" ? "textClass"
               : where == "background" ? "bgClass"
               : where == "gutter" ? "gutterClass" : "wrapClass";
      var cur = line[prop];
      if (!cur) { return false }
      else if (cls == null) { line[prop] = null; }
      else {
        var found = cur.match(classTest(cls));
        if (!found) { return false }
        var end = found.index + found[0].length;
        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
      }
      return true
    })
  }),

  addLineWidget: docMethodOp(function(handle, node, options) {
    return addLineWidget(this, handle, node, options)
  }),
  removeLineWidget: function(widget) { widget.clear(); },

  markText: function(from, to, options) {
    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
  },
  setBookmark: function(pos, options) {
    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                    insertLeft: options && options.insertLeft,
                    clearWhenEmpty: false, shared: options && options.shared,
                    handleMouseEvents: options && options.handleMouseEvents};
    pos = clipPos(this, pos);
    return markText(this, pos, pos, realOpts, "bookmark")
  },
  findMarksAt: function(pos) {
    pos = clipPos(this, pos);
    var markers = [], spans = getLine(this, pos.line).markedSpans;
    if (spans) { for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if ((span.from == null || span.from <= pos.ch) &&
          (span.to == null || span.to >= pos.ch))
        { markers.push(span.marker.parent || span.marker); }
    } }
    return markers
  },
  findMarks: function(from, to, filter) {
    from = clipPos(this, from); to = clipPos(this, to);
    var found = [], lineNo$$1 = from.line;
    this.iter(from.line, to.line + 1, function (line) {
      var spans = line.markedSpans;
      if (spans) { for (var i = 0; i < spans.length; i++) {
        var span = spans[i];
        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||
              span.from == null && lineNo$$1 != from.line ||
              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&
            (!filter || filter(span.marker)))
          { found.push(span.marker.parent || span.marker); }
      } }
      ++lineNo$$1;
    });
    return found
  },
  getAllMarks: function() {
    var markers = [];
    this.iter(function (line) {
      var sps = line.markedSpans;
      if (sps) { for (var i = 0; i < sps.length; ++i)
        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
    });
    return markers
  },

  posFromIndex: function(off) {
    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
    this.iter(function (line) {
      var sz = line.text.length + sepSize;
      if (sz > off) { ch = off; return true }
      off -= sz;
      ++lineNo$$1;
    });
    return clipPos(this, Pos(lineNo$$1, ch))
  },
  indexFromPos: function (coords) {
    coords = clipPos(this, coords);
    var index = coords.ch;
    if (coords.line < this.first || coords.ch < 0) { return 0 }
    var sepSize = this.lineSeparator().length;
    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
      index += line.text.length + sepSize;
    });
    return index
  },

  copy: function(copyHistory) {
    var doc = new Doc(getLines(this, this.first, this.first + this.size),
                      this.modeOption, this.first, this.lineSep, this.direction);
    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
    doc.sel = this.sel;
    doc.extend = false;
    if (copyHistory) {
      doc.history.undoDepth = this.history.undoDepth;
      doc.setHistory(this.getHistory());
    }
    return doc
  },

  linkedDoc: function(options) {
    if (!options) { options = {}; }
    var from = this.first, to = this.first + this.size;
    if (options.from != null && options.from > from) { from = options.from; }
    if (options.to != null && options.to < to) { to = options.to; }
    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
    if (options.sharedHist) { copy.history = this.history
    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
    copySharedMarkers(copy, findSharedMarkers(this));
    return copy
  },
  unlinkDoc: function(other) {
    var this$1 = this;

    if (other instanceof CodeMirror$1) { other = other.doc; }
    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
      var link = this$1.linked[i];
      if (link.doc != other) { continue }
      this$1.linked.splice(i, 1);
      other.unlinkDoc(this$1);
      detachSharedMarkers(findSharedMarkers(this$1));
      break
    } }
    // If the histories were shared, split them again
    if (other.history == this.history) {
      var splitIds = [other.id];
      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
      other.history = new History(null);
      other.history.done = copyHistoryArray(this.history.done, splitIds);
      other.history.undone = copyHistoryArray(this.history.undone, splitIds);
    }
  },
  iterLinkedDocs: function(f) {linkedDocs(this, f);},

  getMode: function() {return this.mode},
  getEditor: function() {return this.cm},

  splitLines: function(str) {
    if (this.lineSep) { return str.split(this.lineSep) }
    return splitLinesAuto(str)
  },
  lineSeparator: function() { return this.lineSep || "\n" },

  setDirection: docMethodOp(function (dir) {
    if (dir != "rtl") { dir = "ltr"; }
    if (dir == this.direction) { return }
    this.direction = dir;
    this.iter(function (line) { return line.order = null; });
    if (this.cm) { directionChanged(this.cm); }
  })
});

// Public alias.
Doc.prototype.eachLine = Doc.prototype.iter;

// Kludge to work around strange IE behavior where it'll sometimes
// re-fire a series of drag-related events right after the drop (#1551)
var lastDrop = 0;

function onDrop(e) {
  var cm = this;
  clearDragCursor(cm);
  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
    { return }
  e_preventDefault(e);
  if (ie) { lastDrop = +new Date; }
  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
  if (!pos || cm.isReadOnly()) { return }
  // Might be a file drop, in which case we simply extract the text
  // and insert it.
  if (files && files.length && window.FileReader && window.File) {
    var n = files.length, text = Array(n), read = 0;
    var loadFile = function (file, i) {
      if (cm.options.allowDropFileTypes &&
          indexOf(cm.options.allowDropFileTypes, file.type) == -1)
        { return }

      var reader = new FileReader;
      reader.onload = operation(cm, function () {
        var content = reader.result;
        if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = ""; }
        text[i] = content;
        if (++read == n) {
          pos = clipPos(cm.doc, pos);
          var change = {from: pos, to: pos,
                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                        origin: "paste"};
          makeChange(cm.doc, change);
          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
        }
      });
      reader.readAsText(file);
    };
    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }
  } else { // Normal drop
    // Don't do a replace if the drop happened inside of the selected text.
    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
      cm.state.draggingText(e);
      // Ensure the editor is re-focused
      setTimeout(function () { return cm.display.input.focus(); }, 20);
      return
    }
    try {
      var text$1 = e.dataTransfer.getData("Text");
      if (text$1) {
        var selected;
        if (cm.state.draggingText && !cm.state.draggingText.copy)
          { selected = cm.listSelections(); }
        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
          { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
        cm.replaceSelection(text$1, "around", "paste");
        cm.display.input.focus();
      }
    }
    catch(e){}
  }
}

function onDragStart(cm, e) {
  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

  e.dataTransfer.setData("Text", cm.getSelection());
  e.dataTransfer.effectAllowed = "copyMove";

  // Use dummy image instead of default browsers image.
  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
  if (e.dataTransfer.setDragImage && !safari) {
    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    if (presto) {
      img.width = img.height = 1;
      cm.display.wrapper.appendChild(img);
      // Force a relayout, or Opera won't use our image for some obscure reason
      img._top = img.offsetTop;
    }
    e.dataTransfer.setDragImage(img, 0, 0);
    if (presto) { img.parentNode.removeChild(img); }
  }
}

function onDragOver(cm, e) {
  var pos = posFromMouse(cm, e);
  if (!pos) { return }
  var frag = document.createDocumentFragment();
  drawSelectionCursor(cm, pos, frag);
  if (!cm.display.dragCursor) {
    cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
  }
  removeChildrenAndAdd(cm.display.dragCursor, frag);
}

function clearDragCursor(cm) {
  if (cm.display.dragCursor) {
    cm.display.lineSpace.removeChild(cm.display.dragCursor);
    cm.display.dragCursor = null;
  }
}

// These must be handled carefully, because naively registering a
// handler for each editor will cause the editors to never be
// garbage collected.

function forEachCodeMirror(f) {
  if (!document.getElementsByClassName) { return }
  var byClass = document.getElementsByClassName("CodeMirror");
  for (var i = 0; i < byClass.length; i++) {
    var cm = byClass[i].CodeMirror;
    if (cm) { f(cm); }
  }
}

var globalsRegistered = false;
function ensureGlobalHandlers() {
  if (globalsRegistered) { return }
  registerGlobalHandlers();
  globalsRegistered = true;
}
function registerGlobalHandlers() {
  // When the window resizes, we need to refresh active editors.
  var resizeTimer;
  on(window, "resize", function () {
    if (resizeTimer == null) { resizeTimer = setTimeout(function () {
      resizeTimer = null;
      forEachCodeMirror(onResize);
    }, 100); }
  });
  // When the window loses focus, we want to show the editor as blurred
  on(window, "blur", function () { return forEachCodeMirror(onBlur); });
}
// Called when the window resizes
function onResize(cm) {
  var d = cm.display;
  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
    { return }
  // Might be a text scaling operation, clear size caches.
  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
  d.scrollbarsClipped = false;
  cm.setSize();
}

var keyNames = {
  3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
  106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete", 145: "ScrollLock",
  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
};

// Number keys
for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
// Alphabetic keys
for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
// Function keys
for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

var keyMap = {};

keyMap.basic = {
  "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
  "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
  "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
  "Tab": "defaultTab", "Shift-Tab": "indentAuto",
  "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
  "Esc": "singleSelection"
};
// Note that the save and find-related commands aren't defined by
// default. User code or addons can define them. Unknown commands
// are simply ignored.
keyMap.pcDefault = {
  "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
  "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
  "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
  "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
  "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
  "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
  "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
  fallthrough: "basic"
};
// Very basic readline/emacs-style bindings, which are standard on Mac.
keyMap.emacsy = {
  "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
  "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
  "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
  "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
  "Ctrl-O": "openLine"
};
keyMap.macDefault = {
  "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
  "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
  "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
  "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
  "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
  "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
  "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
  fallthrough: ["basic", "emacsy"]
};
keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

// KEYMAP DISPATCH

function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/);
  name = parts[parts.length - 1];
  var alt, ctrl, shift, cmd;
  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
    else if (/^a(lt)?$/i.test(mod)) { alt = true; }
    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
    else if (/^s(hift)?$/i.test(mod)) { shift = true; }
    else { throw new Error("Unrecognized modifier name: " + mod) }
  }
  if (alt) { name = "Alt-" + name; }
  if (ctrl) { name = "Ctrl-" + name; }
  if (cmd) { name = "Cmd-" + name; }
  if (shift) { name = "Shift-" + name; }
  return name
}

// This is a kludge to keep keymaps mostly working as raw objects
// (backwards compatibility) while at the same time support features
// like normalization and multi-stroke key bindings. It compiles a
// new normalized keymap, and then updates the old object to reflect
// this.
function normalizeKeyMap(keymap) {
  var copy = {};
  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
    var value = keymap[keyname];
    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
    if (value == "...") { delete keymap[keyname]; continue }

    var keys = map(keyname.split(" "), normalizeKeyName);
    for (var i = 0; i < keys.length; i++) {
      var val = (void 0), name = (void 0);
      if (i == keys.length - 1) {
        name = keys.join(" ");
        val = value;
      } else {
        name = keys.slice(0, i + 1).join(" ");
        val = "...";
      }
      var prev = copy[name];
      if (!prev) { copy[name] = val; }
      else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
    }
    delete keymap[keyname];
  } }
  for (var prop in copy) { keymap[prop] = copy[prop]; }
  return keymap
}

function lookupKey(key, map$$1, handle, context) {
  map$$1 = getKeyMap(map$$1);
  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
  if (found === false) { return "nothing" }
  if (found === "...") { return "multi" }
  if (found != null && handle(found)) { return "handled" }

  if (map$$1.fallthrough) {
    if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]")
      { return lookupKey(key, map$$1.fallthrough, handle, context) }
    for (var i = 0; i < map$$1.fallthrough.length; i++) {
      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
      if (result) { return result }
    }
  }
}

// Modifier key presses don't count as 'real' key presses for the
// purpose of keymap fallthrough.
function isModifierKey(value) {
  var name = typeof value == "string" ? value : keyNames[value.keyCode];
  return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
}

function addModifierNames(name, event, noShift) {
  var base = name;
  if (event.altKey && base != "Alt") { name = "Alt-" + name; }
  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
  if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
  return name
}

// Look up the name of a key as indicated by an event object.
function keyName(event, noShift) {
  if (presto && event.keyCode == 34 && event["char"]) { return false }
  var name = keyNames[event.keyCode];
  if (name == null || event.altGraphKey) { return false }
  // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
  // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
  if (event.keyCode == 3 && event.code) { name = event.code; }
  return addModifierNames(name, event, noShift)
}

function getKeyMap(val) {
  return typeof val == "string" ? keyMap[val] : val
}

// Helper for deleting text near the selection(s), used to implement
// backspace, delete, and similar functionality.
function deleteNearSelection(cm, compute) {
  var ranges = cm.doc.sel.ranges, kill = [];
  // Build up a set of ranges to kill first, merging overlapping
  // ranges.
  for (var i = 0; i < ranges.length; i++) {
    var toKill = compute(ranges[i]);
    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
      var replaced = kill.pop();
      if (cmp(replaced.from, toKill.from) < 0) {
        toKill.from = replaced.from;
        break
      }
    }
    kill.push(toKill);
  }
  // Next, remove those actual ranges.
  runInOp(cm, function () {
    for (var i = kill.length - 1; i >= 0; i--)
      { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
    ensureCursorVisible(cm);
  });
}

function moveCharLogically(line, ch, dir) {
  var target = skipExtendingChars(line.text, ch + dir, dir);
  return target < 0 || target > line.text.length ? null : target
}

function moveLogically(line, start, dir) {
  var ch = moveCharLogically(line, start.ch, dir);
  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
}

function endOfLine(visually, cm, lineObj, lineNo, dir) {
  if (visually) {
    var order = getOrder(lineObj, cm.doc.direction);
    if (order) {
      var part = dir < 0 ? lst(order) : order[0];
      var moveInStorageOrder = (dir < 0) == (part.level == 1);
      var sticky = moveInStorageOrder ? "after" : "before";
      var ch;
      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
      // it could be that the last bidi part is not on the last visual line,
      // since visual lines contain content order-consecutive chunks.
      // Thus, in rtl, we are looking for the first (content-order) character
      // in the rtl chunk that is on the last line (that is, the same line
      // as the last (content-order) character).
      if (part.level > 0 || cm.doc.direction == "rtl") {
        var prep = prepareMeasureForLine(cm, lineObj);
        ch = dir < 0 ? lineObj.text.length - 1 : 0;
        var targetTop = measureCharPrepared(cm, prep, ch).top;
        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
        if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
      } else { ch = dir < 0 ? part.to : part.from; }
      return new Pos(lineNo, ch, sticky)
    }
  }
  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
}

function moveVisually(cm, line, start, dir) {
  var bidi = getOrder(line, cm.doc.direction);
  if (!bidi) { return moveLogically(line, start, dir) }
  if (start.ch >= line.text.length) {
    start.ch = line.text.length;
    start.sticky = "before";
  } else if (start.ch <= 0) {
    start.ch = 0;
    start.sticky = "after";
  }
  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
  if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
    // nothing interesting happens.
    return moveLogically(line, start, dir)
  }

  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
  var prep;
  var getWrappedLineExtent = function (ch) {
    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
    prep = prep || prepareMeasureForLine(cm, line);
    return wrappedLineExtentChar(cm, line, prep, ch)
  };
  var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

  if (cm.doc.direction == "rtl" || part.level == 1) {
    var moveInStorageOrder = (part.level == 1) == (dir < 0);
    var ch = mv(start, moveInStorageOrder ? 1 : -1);
    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
      // Case 2: We move within an rtl part or in an rtl editor on the same visual line
      var sticky = moveInStorageOrder ? "before" : "after";
      return new Pos(start.line, ch, sticky)
    }
  }

  // Case 3: Could not move within this bidi part in this visual line, so leave
  // the current bidi part

  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
      ? new Pos(start.line, mv(ch, 1), "before")
      : new Pos(start.line, ch, "after"); };

    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
      var part = bidi[partPos];
      var moveInStorageOrder = (dir > 0) == (part.level != 1);
      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
      ch = moveInStorageOrder ? part.from : mv(part.to, -1);
      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
    }
  };

  // Case 3a: Look for other bidi parts on the same visual line
  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
  if (res) { return res }

  // Case 3b: Look for other bidi parts on the next visual line
  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
    if (res) { return res }
  }

  // Case 4: Nowhere to move
  return null
}

// Commands are parameter-less actions that can be performed on an
// editor, mostly used for keybindings.
var commands = {
  selectAll: selectAll,
  singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
  killLine: function (cm) { return deleteNearSelection(cm, function (range) {
    if (range.empty()) {
      var len = getLine(cm.doc, range.head.line).text.length;
      if (range.head.ch == len && range.head.line < cm.lastLine())
        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
      else
        { return {from: range.head, to: Pos(range.head.line, len)} }
    } else {
      return {from: range.from(), to: range.to()}
    }
  }); },
  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
    from: Pos(range.from().line, 0),
    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
  }); }); },
  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
    from: Pos(range.from().line, 0), to: range.from()
  }); }); },
  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
    var top = cm.charCoords(range.head, "div").top + 5;
    var leftPos = cm.coordsChar({left: 0, top: top}, "div");
    return {from: leftPos, to: range.from()}
  }); },
  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
    var top = cm.charCoords(range.head, "div").top + 5;
    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
    return {from: range.from(), to: rightPos }
  }); },
  undo: function (cm) { return cm.undo(); },
  redo: function (cm) { return cm.redo(); },
  undoSelection: function (cm) { return cm.undoSelection(); },
  redoSelection: function (cm) { return cm.redoSelection(); },
  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
    {origin: "+move", bias: 1}
  ); },
  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
    {origin: "+move", bias: 1}
  ); },
  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
    {origin: "+move", bias: -1}
  ); },
  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
    var top = cm.cursorCoords(range.head, "div").top + 5;
    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
  }, sel_move); },
  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
    var top = cm.cursorCoords(range.head, "div").top + 5;
    return cm.coordsChar({left: 0, top: top}, "div")
  }, sel_move); },
  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
    var top = cm.cursorCoords(range.head, "div").top + 5;
    var pos = cm.coordsChar({left: 0, top: top}, "div");
    if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
    return pos
  }, sel_move); },
  goLineUp: function (cm) { return cm.moveV(-1, "line"); },
  goLineDown: function (cm) { return cm.moveV(1, "line"); },
  goPageUp: function (cm) { return cm.moveV(-1, "page"); },
  goPageDown: function (cm) { return cm.moveV(1, "page"); },
  goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
  goCharRight: function (cm) { return cm.moveH(1, "char"); },
  goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
  goColumnRight: function (cm) { return cm.moveH(1, "column"); },
  goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
  goGroupRight: function (cm) { return cm.moveH(1, "group"); },
  goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
  goWordRight: function (cm) { return cm.moveH(1, "word"); },
  delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
  delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
  delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
  delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
  delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
  delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
  indentAuto: function (cm) { return cm.indentSelection("smart"); },
  indentMore: function (cm) { return cm.indentSelection("add"); },
  indentLess: function (cm) { return cm.indentSelection("subtract"); },
  insertTab: function (cm) { return cm.replaceSelection("\t"); },
  insertSoftTab: function (cm) {
    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
    for (var i = 0; i < ranges.length; i++) {
      var pos = ranges[i].from();
      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
      spaces.push(spaceStr(tabSize - col % tabSize));
    }
    cm.replaceSelections(spaces);
  },
  defaultTab: function (cm) {
    if (cm.somethingSelected()) { cm.indentSelection("add"); }
    else { cm.execCommand("insertTab"); }
  },
  // Swap the two chars left and right of each selection's head.
  // Move cursor behind the two swapped characters afterwards.
  //
  // Doesn't consider line feeds a character.
  // Doesn't scan more than one line above to find a character.
  // Doesn't do anything on an empty line.
  // Doesn't do anything with non-empty selections.
  transposeChars: function (cm) { return runInOp(cm, function () {
    var ranges = cm.listSelections(), newSel = [];
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) { continue }
      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
      if (line) {
        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
        if (cur.ch > 0) {
          cur = new Pos(cur.line, cur.ch + 1);
          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                          Pos(cur.line, cur.ch - 2), cur, "+transpose");
        } else if (cur.line > cm.doc.first) {
          var prev = getLine(cm.doc, cur.line - 1).text;
          if (prev) {
            cur = new Pos(cur.line, 1);
            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                            prev.charAt(prev.length - 1),
                            Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
          }
        }
      }
      newSel.push(new Range(cur, cur));
    }
    cm.setSelections(newSel);
  }); },
  newlineAndIndent: function (cm) { return runInOp(cm, function () {
    var sels = cm.listSelections();
    for (var i = sels.length - 1; i >= 0; i--)
      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
    sels = cm.listSelections();
    for (var i$1 = 0; i$1 < sels.length; i$1++)
      { cm.indentLine(sels[i$1].from().line, null, true); }
    ensureCursorVisible(cm);
  }); },
  openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
};


function lineStart(cm, lineN) {
  var line = getLine(cm.doc, lineN);
  var visual = visualLine(line);
  if (visual != line) { lineN = lineNo(visual); }
  return endOfLine(true, cm, visual, lineN, 1)
}
function lineEnd(cm, lineN) {
  var line = getLine(cm.doc, lineN);
  var visual = visualLineEnd(line);
  if (visual != line) { lineN = lineNo(visual); }
  return endOfLine(true, cm, line, lineN, -1)
}
function lineStartSmart(cm, pos) {
  var start = lineStart(cm, pos.line);
  var line = getLine(cm.doc, start.line);
  var order = getOrder(line, cm.doc.direction);
  if (!order || order[0].level == 0) {
    var firstNonWS = Math.max(0, line.text.search(/\S/));
    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
  }
  return start
}

// Run a handler that was bound to a key.
function doHandleBinding(cm, bound, dropShift) {
  if (typeof bound == "string") {
    bound = commands[bound];
    if (!bound) { return false }
  }
  // Ensure previous input has been read, so that the handler sees a
  // consistent view of the document
  cm.display.input.ensurePolled();
  var prevShift = cm.display.shift, done = false;
  try {
    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
    if (dropShift) { cm.display.shift = false; }
    done = bound(cm) != Pass;
  } finally {
    cm.display.shift = prevShift;
    cm.state.suppressEdits = false;
  }
  return done
}

function lookupKeyForEditor(cm, name, handle) {
  for (var i = 0; i < cm.state.keyMaps.length; i++) {
    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
    if (result) { return result }
  }
  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
    || lookupKey(name, cm.options.keyMap, handle, cm)
}

// Note that, despite the name, this function is also used to check
// for bound mouse clicks.

var stopSeq = new Delayed;

function dispatchKey(cm, name, e, handle) {
  var seq = cm.state.keySeq;
  if (seq) {
    if (isModifierKey(name)) { return "handled" }
    if (/\'$/.test(name))
      { cm.state.keySeq = null; }
    else
      { stopSeq.set(50, function () {
        if (cm.state.keySeq == seq) {
          cm.state.keySeq = null;
          cm.display.input.reset();
        }
      }); }
    if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
  }
  return dispatchKeyInner(cm, name, e, handle)
}

function dispatchKeyInner(cm, name, e, handle) {
  var result = lookupKeyForEditor(cm, name, handle);

  if (result == "multi")
    { cm.state.keySeq = name; }
  if (result == "handled")
    { signalLater(cm, "keyHandled", cm, name, e); }

  if (result == "handled" || result == "multi") {
    e_preventDefault(e);
    restartBlink(cm);
  }

  return !!result
}

// Handle a key from the keydown event.
function handleKeyBinding(cm, e) {
  var name = keyName(e, true);
  if (!name) { return false }

  if (e.shiftKey && !cm.state.keySeq) {
    // First try to resolve full name (including 'Shift-'). Failing
    // that, see if there is a cursor-motion command (starting with
    // 'go') bound to the keyname without 'Shift-'.
    return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
        || dispatchKey(cm, name, e, function (b) {
             if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
               { return doHandleBinding(cm, b) }
           })
  } else {
    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
  }
}

// Handle a key from the keypress event
function handleCharBinding(cm, e, ch) {
  return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
}

var lastStoppedKey = null;
function onKeyDown(e) {
  var cm = this;
  cm.curOp.focus = activeElt();
  if (signalDOMEvent(cm, e)) { return }
  // IE does strange things with escape.
  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
  var code = e.keyCode;
  cm.display.shift = code == 16 || e.shiftKey;
  var handled = handleKeyBinding(cm, e);
  if (presto) {
    lastStoppedKey = handled ? code : null;
    // Opera has no cut event... we try to at least catch the key combo
    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
      { cm.replaceSelection("", null, "cut"); }
  }

  // Turn mouse into crosshair when Alt is held on Mac.
  if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
    { showCrossHair(cm); }
}

function showCrossHair(cm) {
  var lineDiv = cm.display.lineDiv;
  addClass(lineDiv, "CodeMirror-crosshair");

  function up(e) {
    if (e.keyCode == 18 || !e.altKey) {
      rmClass(lineDiv, "CodeMirror-crosshair");
      off(document, "keyup", up);
      off(document, "mouseover", up);
    }
  }
  on(document, "keyup", up);
  on(document, "mouseover", up);
}

function onKeyUp(e) {
  if (e.keyCode == 16) { this.doc.sel.shift = false; }
  signalDOMEvent(this, e);
}

function onKeyPress(e) {
  var cm = this;
  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
  var keyCode = e.keyCode, charCode = e.charCode;
  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
  // Some browsers fire keypress events for backspace
  if (ch == "\x08") { return }
  if (handleCharBinding(cm, e, ch)) { return }
  cm.display.input.onKeyPress(e);
}

var DOUBLECLICK_DELAY = 400;

var PastClick = function(time, pos, button) {
  this.time = time;
  this.pos = pos;
  this.button = button;
};

PastClick.prototype.compare = function (time, pos, button) {
  return this.time + DOUBLECLICK_DELAY > time &&
    cmp(pos, this.pos) == 0 && button == this.button
};

var lastClick;
var lastDoubleClick;
function clickRepeat(pos, button) {
  var now = +new Date;
  if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
    lastClick = lastDoubleClick = null;
    return "triple"
  } else if (lastClick && lastClick.compare(now, pos, button)) {
    lastDoubleClick = new PastClick(now, pos, button);
    lastClick = null;
    return "double"
  } else {
    lastClick = new PastClick(now, pos, button);
    lastDoubleClick = null;
    return "single"
  }
}

// A mouse down can be a single click, double click, triple click,
// start of selection drag, start of text drag, new cursor
// (ctrl-click), rectangle drag (alt-drag), or xwin
// middle-click-paste. Or it might be a click on something we should
// not interfere with, such as a scrollbar or widget.
function onMouseDown(e) {
  var cm = this, display = cm.display;
  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
  display.input.ensurePolled();
  display.shift = e.shiftKey;

  if (eventInWidget(display, e)) {
    if (!webkit) {
      // Briefly turn off draggability, to allow widgets to do
      // normal dragging things.
      display.scroller.draggable = false;
      setTimeout(function () { return display.scroller.draggable = true; }, 100);
    }
    return
  }
  if (clickInGutter(cm, e)) { return }
  var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
  window.focus();

  // #3261: make sure, that we're not starting a second selection
  if (button == 1 && cm.state.selectingText)
    { cm.state.selectingText(e); }

  if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

  if (button == 1) {
    if (pos) { leftButtonDown(cm, pos, repeat, e); }
    else if (e_target(e) == display.scroller) { e_preventDefault(e); }
  } else if (button == 2) {
    if (pos) { extendSelection(cm.doc, pos); }
    setTimeout(function () { return display.input.focus(); }, 20);
  } else if (button == 3) {
    if (captureRightClick) { onContextMenu(cm, e); }
    else { delayBlurEvent(cm); }
  }
}

function handleMappedButton(cm, button, pos, repeat, event) {
  var name = "Click";
  if (repeat == "double") { name = "Double" + name; }
  else if (repeat == "triple") { name = "Triple" + name; }
  name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

  return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
    if (typeof bound == "string") { bound = commands[bound]; }
    if (!bound) { return false }
    var done = false;
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
      done = bound(cm, pos) != Pass;
    } finally {
      cm.state.suppressEdits = false;
    }
    return done
  })
}

function configureMouse(cm, repeat, event) {
  var option = cm.getOption("configureMouse");
  var value = option ? option(cm, repeat, event) : {};
  if (value.unit == null) {
    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
    value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
  }
  if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
  if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
  if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
  return value
}

function leftButtonDown(cm, pos, repeat, event) {
  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
  else { cm.curOp.focus = activeElt(); }

  var behavior = configureMouse(cm, repeat, event);

  var sel = cm.doc.sel, contained;
  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
      repeat == "single" && (contained = sel.contains(pos)) > -1 &&
      (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
      (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
    { leftButtonStartDrag(cm, event, pos, behavior); }
  else
    { leftButtonSelect(cm, event, pos, behavior); }
}

// Start a text drag. When it ends, see if any dragging actually
// happen, and treat as a click if it didn't.
function leftButtonStartDrag(cm, event, pos, behavior) {
  var display = cm.display, moved = false;
  var dragEnd = operation(cm, function (e) {
    if (webkit) { display.scroller.draggable = false; }
    cm.state.draggingText = false;
    off(display.wrapper.ownerDocument, "mouseup", dragEnd);
    off(display.wrapper.ownerDocument, "mousemove", mouseMove);
    off(display.scroller, "dragstart", dragStart);
    off(display.scroller, "drop", dragEnd);
    if (!moved) {
      e_preventDefault(e);
      if (!behavior.addNew)
        { extendSelection(cm.doc, pos, null, null, behavior.extend); }
      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
      if (webkit || ie && ie_version == 9)
        { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }
      else
        { display.input.focus(); }
    }
  });
  var mouseMove = function(e2) {
    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
  };
  var dragStart = function () { return moved = true; };
  // Let the drag handler handle this.
  if (webkit) { display.scroller.draggable = true; }
  cm.state.draggingText = dragEnd;
  dragEnd.copy = !behavior.moveOnDrag;
  // IE's approach to draggable
  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
  on(display.wrapper.ownerDocument, "mouseup", dragEnd);
  on(display.wrapper.ownerDocument, "mousemove", mouseMove);
  on(display.scroller, "dragstart", dragStart);
  on(display.scroller, "drop", dragEnd);

  delayBlurEvent(cm);
  setTimeout(function () { return display.input.focus(); }, 20);
}

function rangeForUnit(cm, pos, unit) {
  if (unit == "char") { return new Range(pos, pos) }
  if (unit == "word") { return cm.findWordAt(pos) }
  if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
  var result = unit(cm, pos);
  return new Range(result.from, result.to)
}

// Normal selection, as opposed to text dragging.
function leftButtonSelect(cm, event, start, behavior) {
  var display = cm.display, doc = cm.doc;
  e_preventDefault(event);

  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
  if (behavior.addNew && !behavior.extend) {
    ourIndex = doc.sel.contains(start);
    if (ourIndex > -1)
      { ourRange = ranges[ourIndex]; }
    else
      { ourRange = new Range(start, start); }
  } else {
    ourRange = doc.sel.primary();
    ourIndex = doc.sel.primIndex;
  }

  if (behavior.unit == "rectangle") {
    if (!behavior.addNew) { ourRange = new Range(start, start); }
    start = posFromMouse(cm, event, true, true);
    ourIndex = -1;
  } else {
    var range$$1 = rangeForUnit(cm, start, behavior.unit);
    if (behavior.extend)
      { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }
    else
      { ourRange = range$$1; }
  }

  if (!behavior.addNew) {
    ourIndex = 0;
    setSelection(doc, new Selection([ourRange], 0), sel_mouse);
    startSel = doc.sel;
  } else if (ourIndex == -1) {
    ourIndex = ranges.length;
    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
                 {scroll: false, origin: "*mouse"});
  } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                 {scroll: false, origin: "*mouse"});
    startSel = doc.sel;
  } else {
    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
  }

  var lastPos = start;
  function extendTo(pos) {
    if (cmp(lastPos, pos) == 0) { return }
    lastPos = pos;

    if (behavior.unit == "rectangle") {
      var ranges = [], tabSize = cm.options.tabSize;
      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
           line <= end; line++) {
        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
        if (left == right)
          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
        else if (text.length > leftPos)
          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
      }
      if (!ranges.length) { ranges.push(new Range(start, start)); }
      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                   {origin: "*mouse", scroll: false});
      cm.scrollIntoView(pos);
    } else {
      var oldRange = ourRange;
      var range$$1 = rangeForUnit(cm, pos, behavior.unit);
      var anchor = oldRange.anchor, head;
      if (cmp(range$$1.anchor, anchor) > 0) {
        head = range$$1.head;
        anchor = minPos(oldRange.from(), range$$1.anchor);
      } else {
        head = range$$1.anchor;
        anchor = maxPos(oldRange.to(), range$$1.head);
      }
      var ranges$1 = startSel.ranges.slice(0);
      ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
    }
  }

  var editorSize = display.wrapper.getBoundingClientRect();
  // Used to ensure timeout re-tries don't fire when another extend
  // happened in the meantime (clearTimeout isn't reliable -- at
  // least on Chrome, the timeouts still happen even when cleared,
  // if the clear happens after their scheduled firing time).
  var counter = 0;

  function extend(e) {
    var curCount = ++counter;
    var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
    if (!cur) { return }
    if (cmp(cur, lastPos) != 0) {
      cm.curOp.focus = activeElt();
      extendTo(cur);
      var visible = visibleLines(display, doc);
      if (cur.line >= visible.to || cur.line < visible.from)
        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
    } else {
      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
      if (outside) { setTimeout(operation(cm, function () {
        if (counter != curCount) { return }
        display.scroller.scrollTop += outside;
        extend(e);
      }), 50); }
    }
  }

  function done(e) {
    cm.state.selectingText = false;
    counter = Infinity;
    e_preventDefault(e);
    display.input.focus();
    off(display.wrapper.ownerDocument, "mousemove", move);
    off(display.wrapper.ownerDocument, "mouseup", up);
    doc.history.lastSelOrigin = null;
  }

  var move = operation(cm, function (e) {
    if (!e_button(e)) { done(e); }
    else { extend(e); }
  });
  var up = operation(cm, done);
  cm.state.selectingText = up;
  on(display.wrapper.ownerDocument, "mousemove", move);
  on(display.wrapper.ownerDocument, "mouseup", up);
}

// Used when mouse-selecting to adjust the anchor to the proper side
// of a bidi jump depending on the visual position of the head.
function bidiSimplify(cm, range$$1) {
  var anchor = range$$1.anchor;
  var head = range$$1.head;
  var anchorLine = getLine(cm.doc, anchor.line);
  if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }
  var order = getOrder(anchorLine);
  if (!order) { return range$$1 }
  var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
  if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }
  var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
  if (boundary == 0 || boundary == order.length) { return range$$1 }

  // Compute the relative visual position of the head compared to the
  // anchor (<0 is to the left, >0 to the right)
  var leftSide;
  if (head.line != anchor.line) {
    leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
  } else {
    var headIndex = getBidiPartAt(order, head.ch, head.sticky);
    var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
    if (headIndex == boundary - 1 || headIndex == boundary)
      { leftSide = dir < 0; }
    else
      { leftSide = dir > 0; }
  }

  var usePart = order[boundary + (leftSide ? -1 : 0)];
  var from = leftSide == (usePart.level == 1);
  var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
  return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)
}


// Determines whether an event happened in the gutter, and fires the
// handlers for the corresponding event.
function gutterEvent(cm, e, type, prevent) {
  var mX, mY;
  if (e.touches) {
    mX = e.touches[0].clientX;
    mY = e.touches[0].clientY;
  } else {
    try { mX = e.clientX; mY = e.clientY; }
    catch(e) { return false }
  }
  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
  if (prevent) { e_preventDefault(e); }

  var display = cm.display;
  var lineBox = display.lineDiv.getBoundingClientRect();

  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
  mY -= lineBox.top - display.viewOffset;

  for (var i = 0; i < cm.options.gutters.length; ++i) {
    var g = display.gutters.childNodes[i];
    if (g && g.getBoundingClientRect().right >= mX) {
      var line = lineAtHeight(cm.doc, mY);
      var gutter = cm.options.gutters[i];
      signal(cm, type, cm, line, gutter, e);
      return e_defaultPrevented(e)
    }
  }
}

function clickInGutter(cm, e) {
  return gutterEvent(cm, e, "gutterClick", true)
}

// CONTEXT MENU HANDLING

// To make the context menu work, we need to briefly unhide the
// textarea (making it as unobtrusive as possible) to let the
// right-click take effect on it.
function onContextMenu(cm, e) {
  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
  if (signalDOMEvent(cm, e, "contextmenu")) { return }
  cm.display.input.onContextMenu(e);
}

function contextMenuInGutter(cm, e) {
  if (!hasHandler(cm, "gutterContextMenu")) { return false }
  return gutterEvent(cm, e, "gutterContextMenu", false)
}

function themeChanged(cm) {
  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
    cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
  clearCaches(cm);
}

var Init = {toString: function(){return "CodeMirror.Init"}};

var defaults = {};
var optionHandlers = {};

function defineOptions(CodeMirror) {
  var optionHandlers = CodeMirror.optionHandlers;

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) { optionHandlers[name] =
      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
  }

  CodeMirror.defineOption = option;

  // Passed to option handlers when there is no old value.
  CodeMirror.Init = Init;

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function (cm, val) { return cm.setValue(val); }, true);
  option("mode", null, function (cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function (cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);

  option("lineSeparator", null, function (cm, val) {
    cm.doc.lineSep = val;
    if (!val) { return }
    var newBreaks = [], lineNo = cm.doc.first;
    cm.doc.iter(function (line) {
      for (var pos = 0;;) {
        var found = line.text.indexOf(val, pos);
        if (found == -1) { break }
        pos = found + val.length;
        newBreaks.push(Pos(lineNo, found));
      }
      lineNo++;
    });
    for (var i = newBreaks.length - 1; i >= 0; i--)
      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
  });
  option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
    if (old != Init) { cm.refresh(); }
  });
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
  option("electricChars", true);
  option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
    throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
  }, true);
  option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
  option("rtlMoveVisually", !windows);
  option("wholeLineUpdateBefore", true);

  option("theme", "default", function (cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", function (cm, val, old) {
    var next = getKeyMap(val);
    var prev = old != Init && getKeyMap(old);
    if (prev && prev.detach) { prev.detach(cm, next); }
    if (next.attach) { next.attach(cm, prev || null); }
  });
  option("extraKeys", null);
  option("configureMouse", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function (cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
  option("scrollbarStyle", "native", function (cm) {
    initScrollbars(cm);
    updateScrollbars(cm);
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
  }, true);
  option("lineNumbers", false, function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function (integer) { return integer; }, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("resetSelectionOnContextMenu", true);
  option("lineWiseCopyCut", true);
  option("pasteLinesPerSelection", true);

  option("readOnly", false, function (cm, val) {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
    }
    cm.display.input.readOnlyChanged(val);
  });
  option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
  option("dragDrop", true, dragDropChanged);
  option("allowDropFileTypes", null);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1, updateSelection, true);
  option("singleCursorHeightPerLine", true, updateSelection, true);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true, resetModeState, true);
  option("addModeClass", false, resetModeState, true);
  option("pollInterval", 100);
  option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
  option("historyEventDelay", 1250);
  option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
  option("maxHighlightLength", 10000, resetModeState, true);
  option("moveInputWithCursor", true, function (cm, val) {
    if (!val) { cm.display.input.resetPosition(); }
  });

  option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
  option("autofocus", null);
  option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
}

function guttersChanged(cm) {
  updateGutters(cm);
  regChange(cm);
  alignHorizontally(cm);
}

function dragDropChanged(cm, value, old) {
  var wasOn = old && old != Init;
  if (!value != !wasOn) {
    var funcs = cm.display.dragFunctions;
    var toggle = value ? on : off;
    toggle(cm.display.scroller, "dragstart", funcs.start);
    toggle(cm.display.scroller, "dragenter", funcs.enter);
    toggle(cm.display.scroller, "dragover", funcs.over);
    toggle(cm.display.scroller, "dragleave", funcs.leave);
    toggle(cm.display.scroller, "drop", funcs.drop);
  }
}

function wrappingChanged(cm) {
  if (cm.options.lineWrapping) {
    addClass(cm.display.wrapper, "CodeMirror-wrap");
    cm.display.sizer.style.minWidth = "";
    cm.display.sizerWidth = null;
  } else {
    rmClass(cm.display.wrapper, "CodeMirror-wrap");
    findMaxLine(cm);
  }
  estimateLineHeights(cm);
  regChange(cm);
  clearCaches(cm);
  setTimeout(function () { return updateScrollbars(cm); }, 100);
}

// A CodeMirror instance represents an editor. This is the object
// that user code is usually dealing with.

function CodeMirror$1(place, options) {
  var this$1 = this;

  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }

  this.options = options = options ? copyObj(options) : {};
  // Determine effective options based on given values and defaults.
  copyObj(defaults, options, false);
  setGuttersForLineNumbers(options);

  var doc = options.value;
  if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
  this.doc = doc;

  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);
  var display = this.display = new Display(place, doc, input);
  display.wrapper.CodeMirror = this;
  updateGutters(this);
  themeChanged(this);
  if (options.lineWrapping)
    { this.display.wrapper.className += " CodeMirror-wrap"; }
  initScrollbars(this);

  this.state = {
    keyMaps: [],  // stores maps added by addKeyMap
    overlays: [], // highlighting overlays, as added by addOverlay
    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
    overwrite: false,
    delayingBlurEvent: false,
    focused: false,
    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
    selectingText: false,
    draggingText: false,
    highlight: new Delayed(), // stores highlight worker timeout
    keySeq: null,  // Unfinished key sequence
    specialChars: null
  };

  if (options.autofocus && !mobile) { display.input.focus(); }

  // Override magic textarea content restore that IE sometimes does
  // on our hidden textarea on reload
  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

  registerEventHandlers(this);
  ensureGlobalHandlers();

  startOperation(this);
  this.curOp.forceUpdate = true;
  attachDoc(this, doc);

  if ((options.autofocus && !mobile) || this.hasFocus())
    { setTimeout(bind(onFocus, this), 20); }
  else
    { onBlur(this); }

  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
    { optionHandlers[opt](this$1, options[opt], Init); } }
  maybeUpdateLineNumberWidth(this);
  if (options.finishInit) { options.finishInit(this); }
  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }
  endOperation(this);
  // Suppress optimizelegibility in Webkit, since it breaks text
  // measuring on line wrapping boundaries.
  if (webkit && options.lineWrapping &&
      getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
    { display.lineDiv.style.textRendering = "auto"; }
}

// The default configuration options.
CodeMirror$1.defaults = defaults;
// Functions to run when options are changed.
CodeMirror$1.optionHandlers = optionHandlers;

// Attach the necessary event handlers when initializing the editor
function registerEventHandlers(cm) {
  var d = cm.display;
  on(d.scroller, "mousedown", operation(cm, onMouseDown));
  // Older IE's will not fire a second mousedown for a double click
  if (ie && ie_version < 11)
    { on(d.scroller, "dblclick", operation(cm, function (e) {
      if (signalDOMEvent(cm, e)) { return }
      var pos = posFromMouse(cm, e);
      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
      e_preventDefault(e);
      var word = cm.findWordAt(pos);
      extendSelection(cm.doc, word.anchor, word.head);
    })); }
  else
    { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
  // Some browsers fire contextmenu *after* opening the menu, at
  // which point we can't mess with it anymore. Context menu is
  // handled in onMouseDown for these browsers.
  if (!captureRightClick) { on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); }); }

  // Used to suppress mouse event handling when a touch happens
  var touchFinished, prevTouch = {end: 0};
  function finishTouch() {
    if (d.activeTouch) {
      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
      prevTouch = d.activeTouch;
      prevTouch.end = +new Date;
    }
  }
  function isMouseLikeTouchEvent(e) {
    if (e.touches.length != 1) { return false }
    var touch = e.touches[0];
    return touch.radiusX <= 1 && touch.radiusY <= 1
  }
  function farAway(touch, other) {
    if (other.left == null) { return true }
    var dx = other.left - touch.left, dy = other.top - touch.top;
    return dx * dx + dy * dy > 20 * 20
  }
  on(d.scroller, "touchstart", function (e) {
    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
      d.input.ensurePolled();
      clearTimeout(touchFinished);
      var now = +new Date;
      d.activeTouch = {start: now, moved: false,
                       prev: now - prevTouch.end <= 300 ? prevTouch : null};
      if (e.touches.length == 1) {
        d.activeTouch.left = e.touches[0].pageX;
        d.activeTouch.top = e.touches[0].pageY;
      }
    }
  });
  on(d.scroller, "touchmove", function () {
    if (d.activeTouch) { d.activeTouch.moved = true; }
  });
  on(d.scroller, "touchend", function (e) {
    var touch = d.activeTouch;
    if (touch && !eventInWidget(d, e) && touch.left != null &&
        !touch.moved && new Date - touch.start < 300) {
      var pos = cm.coordsChar(d.activeTouch, "page"), range;
      if (!touch.prev || farAway(touch, touch.prev)) // Single tap
        { range = new Range(pos, pos); }
      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
        { range = cm.findWordAt(pos); }
      else // Triple tap
        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
      cm.setSelection(range.anchor, range.head);
      cm.focus();
      e_preventDefault(e);
    }
    finishTouch();
  });
  on(d.scroller, "touchcancel", finishTouch);

  // Sync scrolling between fake scrollbars and real scrollable
  // area, ensure viewport is updated when scrolling.
  on(d.scroller, "scroll", function () {
    if (d.scroller.clientHeight) {
      updateScrollTop(cm, d.scroller.scrollTop);
      setScrollLeft(cm, d.scroller.scrollLeft, true);
      signal(cm, "scroll", cm);
    }
  });

  // Listen to wheel events in order to try and update the viewport on time.
  on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
  on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

  // Prevent wrapper from ever scrolling
  on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

  d.dragFunctions = {
    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
    start: function (e) { return onDragStart(cm, e); },
    drop: operation(cm, onDrop),
    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
  };

  var inp = d.input.getField();
  on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
  on(inp, "keydown", operation(cm, onKeyDown));
  on(inp, "keypress", operation(cm, onKeyPress));
  on(inp, "focus", function (e) { return onFocus(cm, e); });
  on(inp, "blur", function (e) { return onBlur(cm, e); });
}

var initHooks = [];
CodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };

// Indent the given line. The how parameter can be "smart",
// "add"/null, "subtract", or "prev". When aggressive is false
// (typically set to true for forced single-line indents), empty
// lines are not indented, and places where the mode returns Pass
// are left alone.
function indentLine(cm, n, how, aggressive) {
  var doc = cm.doc, state;
  if (how == null) { how = "add"; }
  if (how == "smart") {
    // Fall back to "prev" when the mode doesn't have an indentation
    // method.
    if (!doc.mode.indent) { how = "prev"; }
    else { state = getContextBefore(cm, n).state; }
  }

  var tabSize = cm.options.tabSize;
  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
  if (line.stateAfter) { line.stateAfter = null; }
  var curSpaceString = line.text.match(/^\s*/)[0], indentation;
  if (!aggressive && !/\S/.test(line.text)) {
    indentation = 0;
    how = "not";
  } else if (how == "smart") {
    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
    if (indentation == Pass || indentation > 150) {
      if (!aggressive) { return }
      how = "prev";
    }
  }
  if (how == "prev") {
    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
    else { indentation = 0; }
  } else if (how == "add") {
    indentation = curSpace + cm.options.indentUnit;
  } else if (how == "subtract") {
    indentation = curSpace - cm.options.indentUnit;
  } else if (typeof how == "number") {
    indentation = curSpace + how;
  }
  indentation = Math.max(0, indentation);

  var indentString = "", pos = 0;
  if (cm.options.indentWithTabs)
    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
  if (pos < indentation) { indentString += spaceStr(indentation - pos); }

  if (indentString != curSpaceString) {
    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
    line.stateAfter = null;
    return true
  } else {
    // Ensure that, if the cursor was in the whitespace at the start
    // of the line, it is moved to the end of that space.
    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
      var range = doc.sel.ranges[i$1];
      if (range.head.line == n && range.head.ch < curSpaceString.length) {
        var pos$1 = Pos(n, curSpaceString.length);
        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
        break
      }
    }
  }
}

// This will be set to a {lineWise: bool, text: [string]} object, so
// that, when pasting, we know what kind of selections the copied
// text was made out of.
var lastCopied = null;

function setLastCopied(newLastCopied) {
  lastCopied = newLastCopied;
}

function applyTextInput(cm, inserted, deleted, sel, origin) {
  var doc = cm.doc;
  cm.display.shift = false;
  if (!sel) { sel = doc.sel; }

  var paste = cm.state.pasteIncoming || origin == "paste";
  var textLines = splitLinesAuto(inserted), multiPaste = null;
  // When pasting N lines into N selections, insert one line per selection
  if (paste && sel.ranges.length > 1) {
    if (lastCopied && lastCopied.text.join("\n") == inserted) {
      if (sel.ranges.length % lastCopied.text.length == 0) {
        multiPaste = [];
        for (var i = 0; i < lastCopied.text.length; i++)
          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
      }
    } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
      multiPaste = map(textLines, function (l) { return [l]; });
    }
  }

  var updateInput;
  // Normal behavior is to insert the new text into every selection
  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
    var range$$1 = sel.ranges[i$1];
    var from = range$$1.from(), to = range$$1.to();
    if (range$$1.empty()) {
      if (deleted && deleted > 0) // Handle deletion
        { from = Pos(from.line, from.ch - deleted); }
      else if (cm.state.overwrite && !paste) // Handle overwrite
        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
        { from = to = Pos(from.line, 0); }
    }
    updateInput = cm.curOp.updateInput;
    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                       origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
    makeChange(cm.doc, changeEvent);
    signalLater(cm, "inputRead", cm, changeEvent);
  }
  if (inserted && !paste)
    { triggerElectric(cm, inserted); }

  ensureCursorVisible(cm);
  cm.curOp.updateInput = updateInput;
  cm.curOp.typing = true;
  cm.state.pasteIncoming = cm.state.cutIncoming = false;
}

function handlePaste(e, cm) {
  var pasted = e.clipboardData && e.clipboardData.getData("Text");
  if (pasted) {
    e.preventDefault();
    if (!cm.isReadOnly() && !cm.options.disableInput)
      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
    return true
  }
}

function triggerElectric(cm, inserted) {
  // When an 'electric' character is inserted, immediately trigger a reindent
  if (!cm.options.electricChars || !cm.options.smartIndent) { return }
  var sel = cm.doc.sel;

  for (var i = sel.ranges.length - 1; i >= 0; i--) {
    var range$$1 = sel.ranges[i];
    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }
    var mode = cm.getModeAt(range$$1.head);
    var indented = false;
    if (mode.electricChars) {
      for (var j = 0; j < mode.electricChars.length; j++)
        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
          indented = indentLine(cm, range$$1.head.line, "smart");
          break
        } }
    } else if (mode.electricInput) {
      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))
        { indented = indentLine(cm, range$$1.head.line, "smart"); }
    }
    if (indented) { signalLater(cm, "electricInput", cm, range$$1.head.line); }
  }
}

function copyableRanges(cm) {
  var text = [], ranges = [];
  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
    var line = cm.doc.sel.ranges[i].head.line;
    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
    ranges.push(lineRange);
    text.push(cm.getRange(lineRange.anchor, lineRange.head));
  }
  return {text: text, ranges: ranges}
}

function disableBrowserMagic(field, spellcheck) {
  field.setAttribute("autocorrect", "off");
  field.setAttribute("autocapitalize", "off");
  field.setAttribute("spellcheck", !!spellcheck);
}

function hiddenTextarea() {
  var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
  var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
  // The textarea is kept positioned near the cursor to prevent the
  // fact that it'll be scrolled into view on input from scrolling
  // our fake cursor out of view. On webkit, when wrap=off, paste is
  // very slow. So make the area wide instead.
  if (webkit) { te.style.width = "1000px"; }
  else { te.setAttribute("wrap", "off"); }
  // If border: 0; -- iOS fails to open keyboard (issue #1287)
  if (ios) { te.style.border = "1px solid black"; }
  disableBrowserMagic(te);
  return div
}

// The publicly visible API. Note that methodOp(f) means
// 'wrap f in an operation, performed on its `this` parameter'.

// This is not the complete set of editor methods. Most of the
// methods defined on the Doc type are also injected into
// CodeMirror.prototype, for backwards compatibility and
// convenience.

var addEditorMethods = function(CodeMirror) {
  var optionHandlers = CodeMirror.optionHandlers;

  var helpers = CodeMirror.helpers = {};

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); this.display.input.focus();},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") { return }
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        { operation(this, optionHandlers[option])(this, value, old); }
      signal(this, "optionChange", this, option);
    },

    getOption: function(option) {return this.options[option]},
    getDoc: function() {return this.doc},

    addKeyMap: function(map$$1, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
    },
    removeKeyMap: function(map$$1) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        { if (maps[i] == map$$1 || maps[i].name == map$$1) {
          maps.splice(i, 1);
          return true
        } }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) { throw new Error("Overlays may not be stateful.") }
      insertSorted(this.state.overlays,
                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                    priority: (options && options.priority) || 0},
                   function (overlay) { return overlay.priority; });
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      var this$1 = this;

      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this$1.state.modeGen++;
          regChange(this$1);
          return
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
        else { dir = dir ? "add" : "subtract"; }
      }
      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
    }),
    indentSelection: methodOp(function(how) {
      var this$1 = this;

      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range$$1 = ranges[i];
        if (!range$$1.empty()) {
          var from = range$$1.from(), to = range$$1.to();
          var start = Math.max(end, from.line);
          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            { indentLine(this$1, j, how); }
          var newRanges = this$1.doc.sel.ranges;
          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
        } else if (range$$1.head.line > end) {
          indentLine(this$1, range$$1.head.line, how, true);
          end = range$$1.head.line;
          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      return takeToken(this, pos, precise)
    },

    getLineTokens: function(line, precise) {
      return takeToken(this, Pos(line), precise, true)
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0) { type = styles[2]; }
      else { for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
        else { type = styles[mid * 2 + 2]; break }
      } }
      var cut = type ? type.indexOf("overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) { return mode }
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0]
    },

    getHelpers: function(pos, type) {
      var this$1 = this;

      var found = [];
      if (!helpers.hasOwnProperty(type)) { return found }
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) { found.push(help[mode[type]]); }
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) { found.push(val); }
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i$1 = 0; i$1 < help._global.length; i$1++) {
        var cur = help._global[i$1];
        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
          { found.push(cur.val); }
      }
      return found
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getContextBefore(this, line + 1, precise).state
    },

    cursorCoords: function(start, mode) {
      var pos, range$$1 = this.doc.sel.primary();
      if (start == null) { pos = range$$1.head; }
      else if (typeof start == "object") { pos = clipPos(this.doc, start); }
      else { pos = start ? range$$1.from() : range$$1.to(); }
      return cursorCoords(this, pos, mode || "page")
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page")
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top)
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset)
    },
    heightAtLine: function(line, mode, includeWidgets) {
      var end = false, lineObj;
      if (typeof line == "number") {
        var last = this.doc.first + this.doc.size - 1;
        if (line < this.doc.first) { line = this.doc.first; }
        else if (line > last) { line = last; end = true; }
        lineObj = getLine(this.doc, line);
      } else {
        lineObj = line;
      }
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0)
    },

    defaultTextHeight: function() { return textHeight(this.display) },
    defaultCharWidth: function() { return charWidth(this.display) },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      node.setAttribute("cm-ignore-events", "true");
      this.display.input.setUneditable(node);
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          { top = pos.top - node.offsetHeight; }
        else if (pos.bottom + node.offsetHeight <= vspace)
          { top = pos.bottom; }
        if (left + node.offsetWidth > hspace)
          { left = hspace - node.offsetWidth; }
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") { left = 0; }
        else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
        node.style.left = left + "px";
      }
      if (scroll)
        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: onKeyUp,
    triggerOnMouseDown: methodOp(onMouseDown),

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        { return commands[cmd].call(null, this) }
    },

    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

    findPosH: function(from, amount, unit, visually) {
      var this$1 = this;

      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      var cur = clipPos(this.doc, from);
      for (var i = 0; i < amount; ++i) {
        cur = findPosH(this$1.doc, cur, dir, unit, visually);
        if (cur.hitSide) { break }
      }
      return cur
    },

    moveH: methodOp(function(dir, unit) {
      var this$1 = this;

      this.extendSelectionsBy(function (range$$1) {
        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())
          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }
        else
          { return dir < 0 ? range$$1.from() : range$$1.to() }
      }, sel_move);
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        { doc.replaceSelection("", null, "+delete"); }
      else
        { deleteNearSelection(this, function (range$$1) {
          var other = findPosH(doc, range$$1.head, dir, unit, false);
          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}
        }); }
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var this$1 = this;

      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      var cur = clipPos(this.doc, from);
      for (var i = 0; i < amount; ++i) {
        var coords = cursorCoords(this$1, cur, "div");
        if (x == null) { x = coords.left; }
        else { coords.left = x; }
        cur = findPosV(this$1, coords, dir, unit);
        if (cur.hitSide) { break }
      }
      return cur
    },

    moveV: methodOp(function(dir, unit) {
      var this$1 = this;

      var doc = this.doc, goals = [];
      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function (range$$1) {
        if (collapse)
          { return dir < 0 ? range$$1.from() : range$$1.to() }
        var headPos = cursorCoords(this$1, range$$1.head, "div");
        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }
        goals.push(headPos.left);
        var pos = findPosV(this$1, headPos, dir, unit);
        if (unit == "page" && range$$1 == doc.sel.primary())
          { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
        return pos
      }, sel_move);
      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
        { doc.sel.ranges[i].goalColumn = goals[i]; } }
    }),

    // Find the word at the given position (as returned by coordsChar).
    findWordAt: function(pos) {
      var doc = this.doc, line = getLine(doc, pos.line).text;
      var start = pos.ch, end = pos.ch;
      if (line) {
        var helper = this.getHelper(pos, "wordChars");
        if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
        var startChar = line.charAt(start);
        var check = isWordChar(startChar, helper)
          ? function (ch) { return isWordChar(ch, helper); }
          : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
          : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
        while (start > 0 && check(line.charAt(start - 1))) { --start; }
        while (end < line.length && check(line.charAt(end))) { ++end; }
      }
      return new Range(Pos(pos.line, start), Pos(pos.line, end))
    },

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) { return }
      if (this.state.overwrite = !this.state.overwrite)
        { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
      else
        { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() { return this.display.input.getField() == activeElt() },
    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
    getScrollInfo: function() {
      var scroller = this.display.scroller;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
    },

    scrollIntoView: methodOp(function(range$$1, margin) {
      if (range$$1 == null) {
        range$$1 = {from: this.doc.sel.primary().head, to: null};
        if (margin == null) { margin = this.options.cursorScrollMargin; }
      } else if (typeof range$$1 == "number") {
        range$$1 = {from: Pos(range$$1, 0), to: null};
      } else if (range$$1.from == null) {
        range$$1 = {from: range$$1, to: null};
      }
      if (!range$$1.to) { range$$1.to = range$$1.from; }
      range$$1.margin = margin || 0;

      if (range$$1.from.line != null) {
        scrollToRange(this, range$$1);
      } else {
        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
      }
    }),

    setSize: methodOp(function(width, height) {
      var this$1 = this;

      var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
      if (width != null) { this.display.wrapper.style.width = interpret(width); }
      if (height != null) { this.display.wrapper.style.height = interpret(height); }
      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
      var lineNo$$1 = this.display.viewFrom;
      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, "widget"); break } } }
        ++lineNo$$1;
      });
      this.curOp.forceUpdate = true;
      signal(this, "refresh", this);
    }),

    operation: function(f){return runInOp(this, f)},
    startOperation: function(){return startOperation(this)},
    endOperation: function(){return endOperation(this)},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        { estimateLineHeights(this); }
      signal(this, "refresh", this);
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      this.display.input.reset();
      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
      this.curOp.forceScroll = true;
      signalLater(this, "swapDoc", this, old);
      return old
    }),

    getInputField: function(){return this.display.input.getField()},
    getWrapperElement: function(){return this.display.wrapper},
    getScrollerElement: function(){return this.display.scroller},
    getGutterElement: function(){return this.display.gutters}
  };
  eventMixin(CodeMirror);

  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };
};

// Used for horizontal relative motion. Dir is -1 or 1 (left or
// right), unit can be "char", "column" (like char, but doesn't
// cross line boundaries), "word" (across next word), or "group" (to
// the start of next group of word or non-word-non-whitespace
// chars). The visually param controls whether, in right-to-left
// text, direction 1 means to move towards the next index in the
// string, or towards the character to the right of the current
// position. The resulting position will have a hitSide=true
// property if it reached the end of the document.
function findPosH(doc, pos, dir, unit, visually) {
  var oldPos = pos;
  var origDir = dir;
  var lineObj = getLine(doc, pos.line);
  function findNextLine() {
    var l = pos.line + dir;
    if (l < doc.first || l >= doc.first + doc.size) { return false }
    pos = new Pos(l, pos.ch, pos.sticky);
    return lineObj = getLine(doc, l)
  }
  function moveOnce(boundToLine) {
    var next;
    if (visually) {
      next = moveVisually(doc.cm, lineObj, pos, dir);
    } else {
      next = moveLogically(lineObj, pos, dir);
    }
    if (next == null) {
      if (!boundToLine && findNextLine())
        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }
      else
        { return false }
    } else {
      pos = next;
    }
    return true
  }

  if (unit == "char") {
    moveOnce();
  } else if (unit == "column") {
    moveOnce(true);
  } else if (unit == "word" || unit == "group") {
    var sawType = null, group = unit == "group";
    var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
    for (var first = true;; first = false) {
      if (dir < 0 && !moveOnce(!first)) { break }
      var cur = lineObj.text.charAt(pos.ch) || "\n";
      var type = isWordChar(cur, helper) ? "w"
        : group && cur == "\n" ? "n"
        : !group || /\s/.test(cur) ? null
        : "p";
      if (group && !first && !type) { type = "s"; }
      if (sawType && sawType != type) {
        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
        break
      }

      if (type) { sawType = type; }
      if (dir > 0 && !moveOnce(!first)) { break }
    }
  }
  var result = skipAtomic(doc, pos, oldPos, origDir, true);
  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
  return result
}

// For relative vertical movement. Dir may be -1 or 1. Unit can be
// "page" or "line". The resulting position will have a hitSide=true
// property if it reached the end of the document.
function findPosV(cm, pos, dir, unit) {
  var doc = cm.doc, x = pos.left, y;
  if (unit == "page") {
    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

  } else if (unit == "line") {
    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
  }
  var target;
  for (;;) {
    target = coordsChar(cm, x, y);
    if (!target.outside) { break }
    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
    y += dir * 5;
  }
  return target
}

// CONTENTEDITABLE INPUT STYLE

var ContentEditableInput = function(cm) {
  this.cm = cm;
  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
  this.polling = new Delayed();
  this.composing = null;
  this.gracePeriod = false;
  this.readDOMTimeout = null;
};

ContentEditableInput.prototype.init = function (display) {
    var this$1 = this;

  var input = this, cm = input.cm;
  var div = input.div = display.lineDiv;
  disableBrowserMagic(div, cm.options.spellcheck);

  on(div, "paste", function (e) {
    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
    // IE doesn't fire input events, so we schedule a read for the pasted content in this way
    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
  });

  on(div, "compositionstart", function (e) {
    this$1.composing = {data: e.data, done: false};
  });
  on(div, "compositionupdate", function (e) {
    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
  });
  on(div, "compositionend", function (e) {
    if (this$1.composing) {
      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
      this$1.composing.done = true;
    }
  });

  on(div, "touchstart", function () { return input.forceCompositionEnd(); });

  on(div, "input", function () {
    if (!this$1.composing) { this$1.readFromDOMSoon(); }
  });

  function onCopyCut(e) {
    if (signalDOMEvent(cm, e)) { return }
    if (cm.somethingSelected()) {
      setLastCopied({lineWise: false, text: cm.getSelections()});
      if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
    } else if (!cm.options.lineWiseCopyCut) {
      return
    } else {
      var ranges = copyableRanges(cm);
      setLastCopied({lineWise: true, text: ranges.text});
      if (e.type == "cut") {
        cm.operation(function () {
          cm.setSelections(ranges.ranges, 0, sel_dontScroll);
          cm.replaceSelection("", null, "cut");
        });
      }
    }
    if (e.clipboardData) {
      e.clipboardData.clearData();
      var content = lastCopied.text.join("\n");
      // iOS exposes the clipboard API, but seems to discard content inserted into it
      e.clipboardData.setData("Text", content);
      if (e.clipboardData.getData("Text") == content) {
        e.preventDefault();
        return
      }
    }
    // Old-fashioned briefly-focus-a-textarea hack
    var kludge = hiddenTextarea(), te = kludge.firstChild;
    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
    te.value = lastCopied.text.join("\n");
    var hadFocus = document.activeElement;
    selectInput(te);
    setTimeout(function () {
      cm.display.lineSpace.removeChild(kludge);
      hadFocus.focus();
      if (hadFocus == div) { input.showPrimarySelection(); }
    }, 50);
  }
  on(div, "copy", onCopyCut);
  on(div, "cut", onCopyCut);
};

ContentEditableInput.prototype.prepareSelection = function () {
  var result = prepareSelection(this.cm, false);
  result.focus = this.cm.state.focused;
  return result
};

ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
  if (!info || !this.cm.display.view.length) { return }
  if (info.focus || takeFocus) { this.showPrimarySelection(); }
  this.showMultipleSelections(info);
};

ContentEditableInput.prototype.showPrimarySelection = function () {
  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
  var from = prim.from(), to = prim.to();

  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
    sel.removeAllRanges();
    return
  }

  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
      cmp(minPos(curAnchor, curFocus), from) == 0 &&
      cmp(maxPos(curAnchor, curFocus), to) == 0)
    { return }

  var view = cm.display.view;
  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
      {node: view[0].measure.map[2], offset: 0};
  var end = to.line < cm.display.viewTo && posToDOM(cm, to);
  if (!end) {
    var measure = view[view.length - 1].measure;
    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};
  }

  if (!start || !end) {
    sel.removeAllRanges();
    return
  }

  var old = sel.rangeCount && sel.getRangeAt(0), rng;
  try { rng = range(start.node, start.offset, end.offset, end.node); }
  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
  if (rng) {
    if (!gecko && cm.state.focused) {
      sel.collapse(start.node, start.offset);
      if (!rng.collapsed) {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
    } else {
      sel.removeAllRanges();
      sel.addRange(rng);
    }
    if (old && sel.anchorNode == null) { sel.addRange(old); }
    else if (gecko) { this.startGracePeriod(); }
  }
  this.rememberSelection();
};

ContentEditableInput.prototype.startGracePeriod = function () {
    var this$1 = this;

  clearTimeout(this.gracePeriod);
  this.gracePeriod = setTimeout(function () {
    this$1.gracePeriod = false;
    if (this$1.selectionChanged())
      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
  }, 20);
};

ContentEditableInput.prototype.showMultipleSelections = function (info) {
  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
};

ContentEditableInput.prototype.rememberSelection = function () {
  var sel = window.getSelection();
  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
};

ContentEditableInput.prototype.selectionInEditor = function () {
  var sel = window.getSelection();
  if (!sel.rangeCount) { return false }
  var node = sel.getRangeAt(0).commonAncestorContainer;
  return contains(this.div, node)
};

ContentEditableInput.prototype.focus = function () {
  if (this.cm.options.readOnly != "nocursor") {
    if (!this.selectionInEditor())
      { this.showSelection(this.prepareSelection(), true); }
    this.div.focus();
  }
};
ContentEditableInput.prototype.blur = function () { this.div.blur(); };
ContentEditableInput.prototype.getField = function () { return this.div };

ContentEditableInput.prototype.supportsTouch = function () { return true };

ContentEditableInput.prototype.receivedFocus = function () {
  var input = this;
  if (this.selectionInEditor())
    { this.pollSelection(); }
  else
    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

  function poll() {
    if (input.cm.state.focused) {
      input.pollSelection();
      input.polling.set(input.cm.options.pollInterval, poll);
    }
  }
  this.polling.set(this.cm.options.pollInterval, poll);
};

ContentEditableInput.prototype.selectionChanged = function () {
  var sel = window.getSelection();
  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
};

ContentEditableInput.prototype.pollSelection = function () {
  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
  var sel = window.getSelection(), cm = this.cm;
  // On Android Chrome (version 56, at least), backspacing into an
  // uneditable block element will put the cursor in that element,
  // and then, because it's not editable, hide the virtual keyboard.
  // Because Android doesn't allow us to actually detect backspace
  // presses in a sane way, this code checks for when that happens
  // and simulates a backspace press in this case.
  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {
    this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
    this.blur();
    this.focus();
    return
  }
  if (this.composing) { return }
  this.rememberSelection();
  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
  var head = domToPos(cm, sel.focusNode, sel.focusOffset);
  if (anchor && head) { runInOp(cm, function () {
    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
  }); }
};

ContentEditableInput.prototype.pollContent = function () {
  if (this.readDOMTimeout != null) {
    clearTimeout(this.readDOMTimeout);
    this.readDOMTimeout = null;
  }

  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
  var from = sel.from(), to = sel.to();
  if (from.ch == 0 && from.line > cm.firstLine())
    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
    { to = Pos(to.line + 1, 0); }
  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

  var fromIndex, fromLine, fromNode;
  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
    fromLine = lineNo(display.view[0].line);
    fromNode = display.view[0].node;
  } else {
    fromLine = lineNo(display.view[fromIndex].line);
    fromNode = display.view[fromIndex - 1].node.nextSibling;
  }
  var toIndex = findViewIndex(cm, to.line);
  var toLine, toNode;
  if (toIndex == display.view.length - 1) {
    toLine = display.viewTo - 1;
    toNode = display.lineDiv.lastChild;
  } else {
    toLine = lineNo(display.view[toIndex + 1].line) - 1;
    toNode = display.view[toIndex + 1].node.previousSibling;
  }

  if (!fromNode) { return false }
  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
  while (newText.length > 1 && oldText.length > 1) {
    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
    else { break }
  }

  var cutFront = 0, cutEnd = 0;
  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
    { ++cutFront; }
  var newBot = lst(newText), oldBot = lst(oldText);
  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                           oldBot.length - (oldText.length == 1 ? cutFront : 0));
  while (cutEnd < maxCutEnd &&
         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
    { ++cutEnd; }
  // Try to move start of change to start of selection if ambiguous
  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
    while (cutFront && cutFront > from.ch &&
           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
      cutFront--;
      cutEnd++;
    }
  }

  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
  newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

  var chFrom = Pos(fromLine, cutFront);
  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
    replaceRange(cm.doc, newText, chFrom, chTo, "+input");
    return true
  }
};

ContentEditableInput.prototype.ensurePolled = function () {
  this.forceCompositionEnd();
};
ContentEditableInput.prototype.reset = function () {
  this.forceCompositionEnd();
};
ContentEditableInput.prototype.forceCompositionEnd = function () {
  if (!this.composing) { return }
  clearTimeout(this.readDOMTimeout);
  this.composing = null;
  this.updateFromDOM();
  this.div.blur();
  this.div.focus();
};
ContentEditableInput.prototype.readFromDOMSoon = function () {
    var this$1 = this;

  if (this.readDOMTimeout != null) { return }
  this.readDOMTimeout = setTimeout(function () {
    this$1.readDOMTimeout = null;
    if (this$1.composing) {
      if (this$1.composing.done) { this$1.composing = null; }
      else { return }
    }
    this$1.updateFromDOM();
  }, 80);
};

ContentEditableInput.prototype.updateFromDOM = function () {
    var this$1 = this;

  if (this.cm.isReadOnly() || !this.pollContent())
    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
};

ContentEditableInput.prototype.setUneditable = function (node) {
  node.contentEditable = "false";
};

ContentEditableInput.prototype.onKeyPress = function (e) {
  if (e.charCode == 0 || this.composing) { return }
  e.preventDefault();
  if (!this.cm.isReadOnly())
    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
};

ContentEditableInput.prototype.readOnlyChanged = function (val) {
  this.div.contentEditable = String(val != "nocursor");
};

ContentEditableInput.prototype.onContextMenu = function () {};
ContentEditableInput.prototype.resetPosition = function () {};

ContentEditableInput.prototype.needsContentAttribute = true;

function posToDOM(cm, pos) {
  var view = findViewForLine(cm, pos.line);
  if (!view || view.hidden) { return null }
  var line = getLine(cm.doc, pos.line);
  var info = mapFromLineView(view, line, pos.line);

  var order = getOrder(line, cm.doc.direction), side = "left";
  if (order) {
    var partPos = getBidiPartAt(order, pos.ch);
    side = partPos % 2 ? "right" : "left";
  }
  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
  result.offset = result.collapse == "right" ? result.end : result.start;
  return result
}

function isInGutter(node) {
  for (var scan = node; scan; scan = scan.parentNode)
    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
  return false
}

function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

function domTextBetween(cm, from, to, fromLine, toLine) {
  var text = "", closing = false, lineSep = cm.doc.lineSeparator();
  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
  function close() {
    if (closing) {
      text += lineSep;
      closing = false;
    }
  }
  function addText(str) {
    if (str) {
      close();
      text += str;
    }
  }
  function walk(node) {
    if (node.nodeType == 1) {
      var cmText = node.getAttribute("cm-text");
      if (cmText != null) {
        addText(cmText || node.textContent.replace(/\u200b/g, ""));
        return
      }
      var markerID = node.getAttribute("cm-marker"), range$$1;
      if (markerID) {
        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
        if (found.length && (range$$1 = found[0].find(0)))
          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }
        return
      }
      if (node.getAttribute("contenteditable") == "false") { return }
      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);
      if (isBlock) { close(); }
      for (var i = 0; i < node.childNodes.length; i++)
        { walk(node.childNodes[i]); }
      if (isBlock) { closing = true; }
    } else if (node.nodeType == 3) {
      addText(node.nodeValue);
    }
  }
  for (;;) {
    walk(from);
    if (from == to) { break }
    from = from.nextSibling;
  }
  return text
}

function domToPos(cm, node, offset) {
  var lineNode;
  if (node == cm.display.lineDiv) {
    lineNode = cm.display.lineDiv.childNodes[offset];
    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
    node = null; offset = 0;
  } else {
    for (lineNode = node;; lineNode = lineNode.parentNode) {
      if (!lineNode || lineNode == cm.display.lineDiv) { return null }
      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
    }
  }
  for (var i = 0; i < cm.display.view.length; i++) {
    var lineView = cm.display.view[i];
    if (lineView.node == lineNode)
      { return locateNodeInLineView(lineView, node, offset) }
  }
}

function locateNodeInLineView(lineView, node, offset) {
  var wrapper = lineView.text.firstChild, bad = false;
  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
  if (node == wrapper) {
    bad = true;
    node = wrapper.childNodes[offset];
    offset = 0;
    if (!node) {
      var line = lineView.rest ? lst(lineView.rest) : lineView.line;
      return badPos(Pos(lineNo(line), line.text.length), bad)
    }
  }

  var textNode = node.nodeType == 3 ? node : null, topNode = node;
  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
    textNode = node.firstChild;
    if (offset) { offset = textNode.nodeValue.length; }
  }
  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
  var measure = lineView.measure, maps = measure.maps;

  function find(textNode, topNode, offset) {
    for (var i = -1; i < (maps ? maps.length : 0); i++) {
      var map$$1 = i < 0 ? measure.map : maps[i];
      for (var j = 0; j < map$$1.length; j += 3) {
        var curNode = map$$1[j + 2];
        if (curNode == textNode || curNode == topNode) {
          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
          var ch = map$$1[j] + offset;
          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }
          return Pos(line, ch)
        }
      }
    }
  }
  var found = find(textNode, topNode, offset);
  if (found) { return badPos(found, bad) }

  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
    found = find(after, after.firstChild, 0);
    if (found)
      { return badPos(Pos(found.line, found.ch - dist), bad) }
    else
      { dist += after.textContent.length; }
  }
  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
    found = find(before, before.firstChild, -1);
    if (found)
      { return badPos(Pos(found.line, found.ch + dist$1), bad) }
    else
      { dist$1 += before.textContent.length; }
  }
}

// TEXTAREA INPUT STYLE

var TextareaInput = function(cm) {
  this.cm = cm;
  // See input.poll and input.reset
  this.prevInput = "";

  // Flag that indicates whether we expect input to appear real soon
  // now (after some event like 'keypress' or 'input') and are
  // polling intensively.
  this.pollingFast = false;
  // Self-resetting timeout for the poller
  this.polling = new Delayed();
  // Used to work around IE issue with selection being forgotten when focus moves away from textarea
  this.hasSelection = false;
  this.composing = null;
};

TextareaInput.prototype.init = function (display) {
    var this$1 = this;

  var input = this, cm = this.cm;
  this.createField(display);
  var te = this.textarea;

  display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
  if (ios) { te.style.width = "0px"; }

  on(te, "input", function () {
    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
    input.poll();
  });

  on(te, "paste", function (e) {
    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

    cm.state.pasteIncoming = true;
    input.fastPoll();
  });

  function prepareCopyCut(e) {
    if (signalDOMEvent(cm, e)) { return }
    if (cm.somethingSelected()) {
      setLastCopied({lineWise: false, text: cm.getSelections()});
    } else if (!cm.options.lineWiseCopyCut) {
      return
    } else {
      var ranges = copyableRanges(cm);
      setLastCopied({lineWise: true, text: ranges.text});
      if (e.type == "cut") {
        cm.setSelections(ranges.ranges, null, sel_dontScroll);
      } else {
        input.prevInput = "";
        te.value = ranges.text.join("\n");
        selectInput(te);
      }
    }
    if (e.type == "cut") { cm.state.cutIncoming = true; }
  }
  on(te, "cut", prepareCopyCut);
  on(te, "copy", prepareCopyCut);

  on(display.scroller, "paste", function (e) {
    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
    cm.state.pasteIncoming = true;
    input.focus();
  });

  // Prevent normal selection in the editor (we handle our own)
  on(display.lineSpace, "selectstart", function (e) {
    if (!eventInWidget(display, e)) { e_preventDefault(e); }
  });

  on(te, "compositionstart", function () {
    var start = cm.getCursor("from");
    if (input.composing) { input.composing.range.clear(); }
    input.composing = {
      start: start,
      range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
    };
  });
  on(te, "compositionend", function () {
    if (input.composing) {
      input.poll();
      input.composing.range.clear();
      input.composing = null;
    }
  });
};

TextareaInput.prototype.createField = function (_display) {
  // Wraps and hides input textarea
  this.wrapper = hiddenTextarea();
  // The semihidden textarea that is focused when the editor is
  // focused, and receives input.
  this.textarea = this.wrapper.firstChild;
};

TextareaInput.prototype.prepareSelection = function () {
  // Redraw the selection and/or cursor
  var cm = this.cm, display = cm.display, doc = cm.doc;
  var result = prepareSelection(cm);

  // Move the hidden textarea near the cursor to prevent scrolling artifacts
  if (cm.options.moveInputWithCursor) {
    var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                        headPos.top + lineOff.top - wrapOff.top));
    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                         headPos.left + lineOff.left - wrapOff.left));
  }

  return result
};

TextareaInput.prototype.showSelection = function (drawn) {
  var cm = this.cm, display = cm.display;
  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
  removeChildrenAndAdd(display.selectionDiv, drawn.selection);
  if (drawn.teTop != null) {
    this.wrapper.style.top = drawn.teTop + "px";
    this.wrapper.style.left = drawn.teLeft + "px";
  }
};

// Reset the input to correspond to the selection (or to be empty,
// when not typing and nothing is selected)
TextareaInput.prototype.reset = function (typing) {
  if (this.contextMenuPending || this.composing) { return }
  var cm = this.cm;
  if (cm.somethingSelected()) {
    this.prevInput = "";
    var content = cm.getSelection();
    this.textarea.value = content;
    if (cm.state.focused) { selectInput(this.textarea); }
    if (ie && ie_version >= 9) { this.hasSelection = content; }
  } else if (!typing) {
    this.prevInput = this.textarea.value = "";
    if (ie && ie_version >= 9) { this.hasSelection = null; }
  }
};

TextareaInput.prototype.getField = function () { return this.textarea };

TextareaInput.prototype.supportsTouch = function () { return false };

TextareaInput.prototype.focus = function () {
  if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
    try { this.textarea.focus(); }
    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
  }
};

TextareaInput.prototype.blur = function () { this.textarea.blur(); };

TextareaInput.prototype.resetPosition = function () {
  this.wrapper.style.top = this.wrapper.style.left = 0;
};

TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

// Poll for input changes, using the normal rate of polling. This
// runs as long as the editor is focused.
TextareaInput.prototype.slowPoll = function () {
    var this$1 = this;

  if (this.pollingFast) { return }
  this.polling.set(this.cm.options.pollInterval, function () {
    this$1.poll();
    if (this$1.cm.state.focused) { this$1.slowPoll(); }
  });
};

// When an event has just come in that is likely to add or change
// something in the input textarea, we poll faster, to ensure that
// the change appears on the screen quickly.
TextareaInput.prototype.fastPoll = function () {
  var missed = false, input = this;
  input.pollingFast = true;
  function p() {
    var changed = input.poll();
    if (!changed && !missed) {missed = true; input.polling.set(60, p);}
    else {input.pollingFast = false; input.slowPoll();}
  }
  input.polling.set(20, p);
};

// Read input from the textarea, and update the document to match.
// When something is selected, it is present in the textarea, and
// selected (unless it is huge, in which case a placeholder is
// used). When nothing is selected, the cursor sits after previously
// seen text (can be empty), which is stored in prevInput (we must
// not reset the textarea when typing, because that breaks IME).
TextareaInput.prototype.poll = function () {
    var this$1 = this;

  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
  // Since this is called a *lot*, try to bail out as cheaply as
  // possible when it is clear that nothing happened. hasSelection
  // will be the case when there is a lot of text in the textarea,
  // in which case reading its value would be expensive.
  if (this.contextMenuPending || !cm.state.focused ||
      (hasSelection(input) && !prevInput && !this.composing) ||
      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
    { return false }

  var text = input.value;
  // If nothing changed, bail.
  if (text == prevInput && !cm.somethingSelected()) { return false }
  // Work around nonsensical selection resetting in IE9/10, and
  // inexplicable appearance of private area unicode characters on
  // some key combos in Mac (#2689).
  if (ie && ie_version >= 9 && this.hasSelection === text ||
      mac && /[\uf700-\uf7ff]/.test(text)) {
    cm.display.input.reset();
    return false
  }

  if (cm.doc.sel == cm.display.selForContextMenu) {
    var first = text.charCodeAt(0);
    if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
    if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
  }
  // Find the part of the input that is actually new
  var same = 0, l = Math.min(prevInput.length, text.length);
  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

  runInOp(cm, function () {
    applyTextInput(cm, text.slice(same), prevInput.length - same,
                   null, this$1.composing ? "*compose" : null);

    // Don't leave long text in the textarea, since it makes further polling slow
    if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
    else { this$1.prevInput = text; }

    if (this$1.composing) {
      this$1.composing.range.clear();
      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                         {className: "CodeMirror-composing"});
    }
  });
  return true
};

TextareaInput.prototype.ensurePolled = function () {
  if (this.pollingFast && this.poll()) { this.pollingFast = false; }
};

TextareaInput.prototype.onKeyPress = function () {
  if (ie && ie_version >= 9) { this.hasSelection = null; }
  this.fastPoll();
};

TextareaInput.prototype.onContextMenu = function (e) {
  var input = this, cm = input.cm, display = cm.display, te = input.textarea;
  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
  if (!pos || presto) { return } // Opera is difficult.

  // Reset the current text selection only if the click is done outside of the selection
  // and 'resetSelectionOnContextMenu' option is true.
  var reset = cm.options.resetSelectionOnContextMenu;
  if (reset && cm.doc.sel.contains(pos) == -1)
    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
  input.wrapper.style.cssText = "position: absolute";
  var wrapperBox = input.wrapper.getBoundingClientRect();
  te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
  var oldScrollY;
  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
  display.input.focus();
  if (webkit) { window.scrollTo(null, oldScrollY); }
  display.input.reset();
  // Adds "Select all" to context menu in FF
  if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
  input.contextMenuPending = true;
  display.selForContextMenu = cm.doc.sel;
  clearTimeout(display.detectingSelectAll);

  // Select-all will be greyed out if there's nothing to select, so
  // this adds a zero-width space so that we can later check whether
  // it got selected.
  function prepareSelectAllHack() {
    if (te.selectionStart != null) {
      var selected = cm.somethingSelected();
      var extval = "\u200b" + (selected ? te.value : "");
      te.value = "\u21da"; // Used to catch context-menu undo
      te.value = extval;
      input.prevInput = selected ? "" : "\u200b";
      te.selectionStart = 1; te.selectionEnd = extval.length;
      // Re-set this, in case some other handler touched the
      // selection in the meantime.
      display.selForContextMenu = cm.doc.sel;
    }
  }
  function rehide() {
    input.contextMenuPending = false;
    input.wrapper.style.cssText = oldWrapperCSS;
    te.style.cssText = oldCSS;
    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

    // Try to detect the user choosing select-all
    if (te.selectionStart != null) {
      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
      var i = 0, poll = function () {
        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
            te.selectionEnd > 0 && input.prevInput == "\u200b") {
          operation(cm, selectAll)(cm);
        } else if (i++ < 10) {
          display.detectingSelectAll = setTimeout(poll, 500);
        } else {
          display.selForContextMenu = null;
          display.input.reset();
        }
      };
      display.detectingSelectAll = setTimeout(poll, 200);
    }
  }

  if (ie && ie_version >= 9) { prepareSelectAllHack(); }
  if (captureRightClick) {
    e_stop(e);
    var mouseup = function () {
      off(window, "mouseup", mouseup);
      setTimeout(rehide, 20);
    };
    on(window, "mouseup", mouseup);
  } else {
    setTimeout(rehide, 50);
  }
};

TextareaInput.prototype.readOnlyChanged = function (val) {
  if (!val) { this.reset(); }
  this.textarea.disabled = val == "nocursor";
};

TextareaInput.prototype.setUneditable = function () {};

TextareaInput.prototype.needsContentAttribute = false;

function fromTextArea(textarea, options) {
  options = options ? copyObj(options) : {};
  options.value = textarea.value;
  if (!options.tabindex && textarea.tabIndex)
    { options.tabindex = textarea.tabIndex; }
  if (!options.placeholder && textarea.placeholder)
    { options.placeholder = textarea.placeholder; }
  // Set autofocus to true if this textarea is focused, or if it has
  // autofocus and no other element is focused.
  if (options.autofocus == null) {
    var hasFocus = activeElt();
    options.autofocus = hasFocus == textarea ||
      textarea.getAttribute("autofocus") != null && hasFocus == document.body;
  }

  function save() {textarea.value = cm.getValue();}

  var realSubmit;
  if (textarea.form) {
    on(textarea.form, "submit", save);
    // Deplorable hack to make the submit method do the right thing.
    if (!options.leaveSubmitMethodAlone) {
      var form = textarea.form;
      realSubmit = form.submit;
      try {
        var wrappedSubmit = form.submit = function () {
          save();
          form.submit = realSubmit;
          form.submit();
          form.submit = wrappedSubmit;
        };
      } catch(e) {}
    }
  }

  options.finishInit = function (cm) {
    cm.save = save;
    cm.getTextArea = function () { return textarea; };
    cm.toTextArea = function () {
      cm.toTextArea = isNaN; // Prevent this from being ran twice
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = "";
      if (textarea.form) {
        off(textarea.form, "submit", save);
        if (typeof textarea.form.submit == "function")
          { textarea.form.submit = realSubmit; }
      }
    };
  };

  textarea.style.display = "none";
  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
    options);
  return cm
}

function addLegacyProps(CodeMirror) {
  CodeMirror.off = off;
  CodeMirror.on = on;
  CodeMirror.wheelEventPixels = wheelEventPixels;
  CodeMirror.Doc = Doc;
  CodeMirror.splitLines = splitLinesAuto;
  CodeMirror.countColumn = countColumn;
  CodeMirror.findColumn = findColumn;
  CodeMirror.isWordChar = isWordCharBasic;
  CodeMirror.Pass = Pass;
  CodeMirror.signal = signal;
  CodeMirror.Line = Line;
  CodeMirror.changeEnd = changeEnd;
  CodeMirror.scrollbarModel = scrollbarModel;
  CodeMirror.Pos = Pos;
  CodeMirror.cmpPos = cmp;
  CodeMirror.modes = modes;
  CodeMirror.mimeModes = mimeModes;
  CodeMirror.resolveMode = resolveMode;
  CodeMirror.getMode = getMode;
  CodeMirror.modeExtensions = modeExtensions;
  CodeMirror.extendMode = extendMode;
  CodeMirror.copyState = copyState;
  CodeMirror.startState = startState;
  CodeMirror.innerMode = innerMode;
  CodeMirror.commands = commands;
  CodeMirror.keyMap = keyMap;
  CodeMirror.keyName = keyName;
  CodeMirror.isModifierKey = isModifierKey;
  CodeMirror.lookupKey = lookupKey;
  CodeMirror.normalizeKeyMap = normalizeKeyMap;
  CodeMirror.StringStream = StringStream;
  CodeMirror.SharedTextMarker = SharedTextMarker;
  CodeMirror.TextMarker = TextMarker;
  CodeMirror.LineWidget = LineWidget;
  CodeMirror.e_preventDefault = e_preventDefault;
  CodeMirror.e_stopPropagation = e_stopPropagation;
  CodeMirror.e_stop = e_stop;
  CodeMirror.addClass = addClass;
  CodeMirror.contains = contains;
  CodeMirror.rmClass = rmClass;
  CodeMirror.keyNames = keyNames;
}

// EDITOR CONSTRUCTOR

defineOptions(CodeMirror$1);

addEditorMethods(CodeMirror$1);

// Set up methods on CodeMirror's prototype to redirect to the editor's document.
var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
  { CodeMirror$1.prototype[prop] = (function(method) {
    return function() {return method.apply(this.doc, arguments)}
  })(Doc.prototype[prop]); } }

eventMixin(Doc);

// INPUT HANDLING

CodeMirror$1.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

// MODE DEFINITION AND QUERYING

// Extra arguments are stored as the mode's dependencies, which is
// used by (legacy) mechanisms like loadmode.js to automatically
// load a mode. (Preferred mechanism is the require/define calls.)
CodeMirror$1.defineMode = function(name/*, mode, …*/) {
  if (!CodeMirror$1.defaults.mode && name != "null") { CodeMirror$1.defaults.mode = name; }
  defineMode.apply(this, arguments);
};

CodeMirror$1.defineMIME = defineMIME;

// Minimal default mode.
CodeMirror$1.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
CodeMirror$1.defineMIME("text/plain", "null");

// EXTENSIONS

CodeMirror$1.defineExtension = function (name, func) {
  CodeMirror$1.prototype[name] = func;
};
CodeMirror$1.defineDocExtension = function (name, func) {
  Doc.prototype[name] = func;
};

CodeMirror$1.fromTextArea = fromTextArea;

addLegacyProps(CodeMirror$1);

CodeMirror$1.version = "5.37.0";

return CodeMirror$1;

})));

define('text!codemirror/lib/codemirror.css', ['module'], function(module) { module.exports = "/* BASICS */\n\n.CodeMirror {\n  /* Set height, width, borders, and global font properties here */\n  font-family: monospace;\n  height: 300px;\n  color: black;\n  direction: ltr;\n}\n\n/* PADDING */\n\n.CodeMirror-lines {\n  padding: 4px 0; /* Vertical padding around content */\n}\n.CodeMirror pre {\n  padding: 0 4px; /* Horizontal padding of content */\n}\n\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  background-color: white; /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n\n.CodeMirror-gutters {\n  border-right: 1px solid #ddd;\n  background-color: #f7f7f7;\n  white-space: nowrap;\n}\n.CodeMirror-linenumbers {}\n.CodeMirror-linenumber {\n  padding: 0 3px 0 5px;\n  min-width: 20px;\n  text-align: right;\n  color: #999;\n  white-space: nowrap;\n}\n\n.CodeMirror-guttermarker { color: black; }\n.CodeMirror-guttermarker-subtle { color: #999; }\n\n/* CURSOR */\n\n.CodeMirror-cursor {\n  border-left: 1px solid black;\n  border-right: none;\n  width: 0;\n}\n/* Shown when moving in bi-directional text */\n.CodeMirror div.CodeMirror-secondarycursor {\n  border-left: 1px solid silver;\n}\n.cm-fat-cursor .CodeMirror-cursor {\n  width: auto;\n  border: 0 !important;\n  background: #7e7;\n}\n.cm-fat-cursor div.CodeMirror-cursors {\n  z-index: 1;\n}\n.cm-fat-cursor-mark {\n  background-color: rgba(20, 255, 20, 0.5);\n  -webkit-animation: blink 1.06s steps(1) infinite;\n  -moz-animation: blink 1.06s steps(1) infinite;\n  animation: blink 1.06s steps(1) infinite;\n}\n.cm-animate-fat-cursor {\n  width: auto;\n  border: 0;\n  -webkit-animation: blink 1.06s steps(1) infinite;\n  -moz-animation: blink 1.06s steps(1) infinite;\n  animation: blink 1.06s steps(1) infinite;\n  background-color: #7e7;\n}\n@-moz-keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n@-webkit-keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n@keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n\n/* Can style cursor different in overwrite (non-insert) mode */\n.CodeMirror-overwrite .CodeMirror-cursor {}\n\n.cm-tab { display: inline-block; text-decoration: inherit; }\n\n.CodeMirror-rulers {\n  position: absolute;\n  left: 0; right: 0; top: -50px; bottom: -20px;\n  overflow: hidden;\n}\n.CodeMirror-ruler {\n  border-left: 1px solid #ccc;\n  top: 0; bottom: 0;\n  position: absolute;\n}\n\n/* DEFAULT THEME */\n\n.cm-s-default .cm-header {color: blue;}\n.cm-s-default .cm-quote {color: #090;}\n.cm-negative {color: #d44;}\n.cm-positive {color: #292;}\n.cm-header, .cm-strong {font-weight: bold;}\n.cm-em {font-style: italic;}\n.cm-link {text-decoration: underline;}\n.cm-strikethrough {text-decoration: line-through;}\n\n.cm-s-default .cm-keyword {color: #708;}\n.cm-s-default .cm-atom {color: #219;}\n.cm-s-default .cm-number {color: #164;}\n.cm-s-default .cm-def {color: #00f;}\n.cm-s-default .cm-variable,\n.cm-s-default .cm-punctuation,\n.cm-s-default .cm-property,\n.cm-s-default .cm-operator {}\n.cm-s-default .cm-variable-2 {color: #05a;}\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\n.cm-s-default .cm-comment {color: #a50;}\n.cm-s-default .cm-string {color: #a11;}\n.cm-s-default .cm-string-2 {color: #f50;}\n.cm-s-default .cm-meta {color: #555;}\n.cm-s-default .cm-qualifier {color: #555;}\n.cm-s-default .cm-builtin {color: #30a;}\n.cm-s-default .cm-bracket {color: #997;}\n.cm-s-default .cm-tag {color: #170;}\n.cm-s-default .cm-attribute {color: #00c;}\n.cm-s-default .cm-hr {color: #999;}\n.cm-s-default .cm-link {color: #00c;}\n\n.cm-s-default .cm-error {color: #f00;}\n.cm-invalidchar {color: #f00;}\n\n.CodeMirror-composing { border-bottom: 2px solid; }\n\n/* Default styles for common addons */\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\n.CodeMirror-activeline-background {background: #e8f2ff;}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\n   the editor. You probably shouldn't touch them. */\n\n.CodeMirror {\n  position: relative;\n  overflow: hidden;\n  background: white;\n}\n\n.CodeMirror-scroll {\n  overflow: scroll !important; /* Things will break if this is overridden */\n  /* 30px is the magic margin used to hide the element's real scrollbars */\n  /* See overflow: hidden in .CodeMirror */\n  margin-bottom: -30px; margin-right: -30px;\n  padding-bottom: 30px;\n  height: 100%;\n  outline: none; /* Prevent dragging from highlighting the element */\n  position: relative;\n}\n.CodeMirror-sizer {\n  position: relative;\n  border-right: 30px solid transparent;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\n   before actual scrolling happens, thus preventing shaking and\n   flickering artifacts. */\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  position: absolute;\n  z-index: 6;\n  display: none;\n}\n.CodeMirror-vscrollbar {\n  right: 0; top: 0;\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n  bottom: 0; left: 0;\n  overflow-y: hidden;\n  overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n  right: 0; bottom: 0;\n}\n.CodeMirror-gutter-filler {\n  left: 0; bottom: 0;\n}\n\n.CodeMirror-gutters {\n  position: absolute; left: 0; top: 0;\n  min-height: 100%;\n  z-index: 3;\n}\n.CodeMirror-gutter {\n  white-space: normal;\n  height: 100%;\n  display: inline-block;\n  vertical-align: top;\n  margin-bottom: -30px;\n}\n.CodeMirror-gutter-wrapper {\n  position: absolute;\n  z-index: 4;\n  background: none !important;\n  border: none !important;\n}\n.CodeMirror-gutter-background {\n  position: absolute;\n  top: 0; bottom: 0;\n  z-index: 4;\n}\n.CodeMirror-gutter-elt {\n  position: absolute;\n  cursor: default;\n  z-index: 4;\n}\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent }\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\n\n.CodeMirror-lines {\n  cursor: text;\n  min-height: 1px; /* prevents collapsing before first draw */\n}\n.CodeMirror pre {\n  /* Reset some styles that the rest of the page might have set */\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\n  border-width: 0;\n  background: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  margin: 0;\n  white-space: pre;\n  word-wrap: normal;\n  line-height: inherit;\n  color: inherit;\n  z-index: 2;\n  position: relative;\n  overflow: visible;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-font-variant-ligatures: contextual;\n  font-variant-ligatures: contextual;\n}\n.CodeMirror-wrap pre {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  word-break: normal;\n}\n\n.CodeMirror-linebackground {\n  position: absolute;\n  left: 0; right: 0; top: 0; bottom: 0;\n  z-index: 0;\n}\n\n.CodeMirror-linewidget {\n  position: relative;\n  z-index: 2;\n  padding: 0.1px; /* Force widget margins to stay inside of the container */\n}\n\n.CodeMirror-widget {}\n\n.CodeMirror-rtl pre { direction: rtl; }\n\n.CodeMirror-code {\n  outline: none;\n}\n\n/* Force content-box sizing for the elements where we expect it */\n.CodeMirror-scroll,\n.CodeMirror-sizer,\n.CodeMirror-gutter,\n.CodeMirror-gutters,\n.CodeMirror-linenumber {\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n\n.CodeMirror-measure {\n  position: absolute;\n  width: 100%;\n  height: 0;\n  overflow: hidden;\n  visibility: hidden;\n}\n\n.CodeMirror-cursor {\n  position: absolute;\n  pointer-events: none;\n}\n.CodeMirror-measure pre { position: static; }\n\ndiv.CodeMirror-cursors {\n  visibility: hidden;\n  position: relative;\n  z-index: 3;\n}\ndiv.CodeMirror-dragcursors {\n  visibility: visible;\n}\n\n.CodeMirror-focused div.CodeMirror-cursors {\n  visibility: visible;\n}\n\n.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\n.CodeMirror-crosshair { cursor: crosshair; }\n.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }\n.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }\n\n.cm-searching {\n  background-color: #ffa;\n  background-color: rgba(255, 255, 0, .4);\n}\n\n/* Used to force a border model for a node */\n.cm-force-border { padding-right: .1px; }\n\n@media print {\n  /* Hide the cursor when printing */\n  .CodeMirror div.CodeMirror-cursors {\n    visibility: hidden;\n  }\n}\n\n/* See issue #2901 */\n.cm-tab-wrap-hack:after { content: ''; }\n\n/* Help users use markselection to safely style text background */\nspan.CodeMirror-selectedtext { background: none; }\n"; });
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/mode/css/css',["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("css", function(config, parserConfig) {
  var inline = parserConfig.inline
  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

  var indentUnit = config.indentUnit,
      tokenHooks = parserConfig.tokenHooks,
      documentTypes = parserConfig.documentTypes || {},
      mediaTypes = parserConfig.mediaTypes || {},
      mediaFeatures = parserConfig.mediaFeatures || {},
      mediaValueKeywords = parserConfig.mediaValueKeywords || {},
      propertyKeywords = parserConfig.propertyKeywords || {},
      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
      fontProperties = parserConfig.fontProperties || {},
      counterDescriptors = parserConfig.counterDescriptors || {},
      colorKeywords = parserConfig.colorKeywords || {},
      valueKeywords = parserConfig.valueKeywords || {},
      allowNested = parserConfig.allowNested,
      lineComment = parserConfig.lineComment,
      supportsAtComponent = parserConfig.supportsAtComponent === true;

  var type, override;
  function ret(style, tp) { type = tp; return style; }

  // Tokenizers

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (tokenHooks[ch]) {
      var result = tokenHooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == "@") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("def", stream.current());
    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
      return ret(null, "compare");
    } else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "#") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("atom", "hash");
    } else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    } else if (ch === "-") {
      if (/[\d.]/.test(stream.peek())) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (stream.match(/^-[\w\\\-]+/)) {
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ret("variable-2", "variable-definition");
        return ret("variable-2", "variable");
      } else if (stream.match(/^\w+-/)) {
        return ret("meta", "meta");
      }
    } else if (/[,+>*\/]/.test(ch)) {
      return ret(null, "select-op");
    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
      return ret("qualifier", "qualifier");
    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
      return ret(null, ch);
    } else if (((ch == "u" || ch == "U") && stream.match(/rl(-prefix)?\(/i)) ||
               ((ch == "d" || ch == "D") && stream.match("omain(", true, true)) ||
               ((ch == "r" || ch == "R") && stream.match("egexp(", true, true))) {
      stream.backUp(1);
      state.tokenize = tokenParenthesized;
      return ret("property", "word");
    } else if (/[\w\\\-]/.test(ch)) {
      stream.eatWhile(/[\w\\\-]/);
      return ret("property", "word");
    } else {
      return ret(null, null);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped) {
          if (quote == ")") stream.backUp(1);
          break;
        }
        escaped = !escaped && ch == "\\";
      }
      if (ch == quote || !escaped && quote != ")") state.tokenize = null;
      return ret("string", "string");
    };
  }

  function tokenParenthesized(stream, state) {
    stream.next(); // Must be '('
    if (!stream.match(/\s*[\"\')]/, false))
      state.tokenize = tokenString(")");
    else
      state.tokenize = null;
    return ret(null, "(");
  }

  // Context management

  function Context(type, indent, prev) {
    this.type = type;
    this.indent = indent;
    this.prev = prev;
  }

  function pushContext(state, stream, type, indent) {
    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
    return type;
  }

  function popContext(state) {
    if (state.context.prev)
      state.context = state.context.prev;
    return state.context.type;
  }

  function pass(type, stream, state) {
    return states[state.context.type](type, stream, state);
  }
  function popAndPass(type, stream, state, n) {
    for (var i = n || 1; i > 0; i--)
      state.context = state.context.prev;
    return pass(type, stream, state);
  }

  // Parser

  function wordAsValue(stream) {
    var word = stream.current().toLowerCase();
    if (valueKeywords.hasOwnProperty(word))
      override = "atom";
    else if (colorKeywords.hasOwnProperty(word))
      override = "keyword";
    else
      override = "variable";
  }

  var states = {};

  states.top = function(type, stream, state) {
    if (type == "{") {
      return pushContext(state, stream, "block");
    } else if (type == "}" && state.context.prev) {
      return popContext(state);
    } else if (supportsAtComponent && /@component/i.test(type)) {
      return pushContext(state, stream, "atComponentBlock");
    } else if (/^@(-moz-)?document$/i.test(type)) {
      return pushContext(state, stream, "documentTypes");
    } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {
      return pushContext(state, stream, "atBlock");
    } else if (/^@(font-face|counter-style)/i.test(type)) {
      state.stateArg = type;
      return "restricted_atBlock_before";
    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {
      return "keyframes";
    } else if (type && type.charAt(0) == "@") {
      return pushContext(state, stream, "at");
    } else if (type == "hash") {
      override = "builtin";
    } else if (type == "word") {
      override = "tag";
    } else if (type == "variable-definition") {
      return "maybeprop";
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    } else if (type == ":") {
      return "pseudo";
    } else if (allowNested && type == "(") {
      return pushContext(state, stream, "parens");
    }
    return state.context.type;
  };

  states.block = function(type, stream, state) {
    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (propertyKeywords.hasOwnProperty(word)) {
        override = "property";
        return "maybeprop";
      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
        override = "string-2";
        return "maybeprop";
      } else if (allowNested) {
        override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
        return "block";
      } else {
        override += " error";
        return "maybeprop";
      }
    } else if (type == "meta") {
      return "block";
    } else if (!allowNested && (type == "hash" || type == "qualifier")) {
      override = "error";
      return "block";
    } else {
      return states.top(type, stream, state);
    }
  };

  states.maybeprop = function(type, stream, state) {
    if (type == ":") return pushContext(state, stream, "prop");
    return pass(type, stream, state);
  };

  states.prop = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
    if (type == "}" || type == "{") return popAndPass(type, stream, state);
    if (type == "(") return pushContext(state, stream, "parens");

    if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
      override += " error";
    } else if (type == "word") {
      wordAsValue(stream);
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    }
    return "prop";
  };

  states.propBlock = function(type, _stream, state) {
    if (type == "}") return popContext(state);
    if (type == "word") { override = "property"; return "maybeprop"; }
    return state.context.type;
  };

  states.parens = function(type, stream, state) {
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == ")") return popContext(state);
    if (type == "(") return pushContext(state, stream, "parens");
    if (type == "interpolation") return pushContext(state, stream, "interpolation");
    if (type == "word") wordAsValue(stream);
    return "parens";
  };

  states.pseudo = function(type, stream, state) {
    if (type == "meta") return "pseudo";

    if (type == "word") {
      override = "variable-3";
      return state.context.type;
    }
    return pass(type, stream, state);
  };

  states.documentTypes = function(type, stream, state) {
    if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
      override = "tag";
      return state.context.type;
    } else {
      return states.atBlock(type, stream, state);
    }
  };

  states.atBlock = function(type, stream, state) {
    if (type == "(") return pushContext(state, stream, "atBlock_parens");
    if (type == "}" || type == ";") return popAndPass(type, stream, state);
    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

    if (type == "interpolation") return pushContext(state, stream, "interpolation");

    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (word == "only" || word == "not" || word == "and" || word == "or")
        override = "keyword";
      else if (mediaTypes.hasOwnProperty(word))
        override = "attribute";
      else if (mediaFeatures.hasOwnProperty(word))
        override = "property";
      else if (mediaValueKeywords.hasOwnProperty(word))
        override = "keyword";
      else if (propertyKeywords.hasOwnProperty(word))
        override = "property";
      else if (nonStandardPropertyKeywords.hasOwnProperty(word))
        override = "string-2";
      else if (valueKeywords.hasOwnProperty(word))
        override = "atom";
      else if (colorKeywords.hasOwnProperty(word))
        override = "keyword";
      else
        override = "error";
    }
    return state.context.type;
  };

  states.atComponentBlock = function(type, stream, state) {
    if (type == "}")
      return popAndPass(type, stream, state);
    if (type == "{")
      return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
    if (type == "word")
      override = "error";
    return state.context.type;
  };

  states.atBlock_parens = function(type, stream, state) {
    if (type == ")") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
    return states.atBlock(type, stream, state);
  };

  states.restricted_atBlock_before = function(type, stream, state) {
    if (type == "{")
      return pushContext(state, stream, "restricted_atBlock");
    if (type == "word" && state.stateArg == "@counter-style") {
      override = "variable";
      return "restricted_atBlock_before";
    }
    return pass(type, stream, state);
  };

  states.restricted_atBlock = function(type, stream, state) {
    if (type == "}") {
      state.stateArg = null;
      return popContext(state);
    }
    if (type == "word") {
      if ((state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||
          (state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))
        override = "error";
      else
        override = "property";
      return "maybeprop";
    }
    return "restricted_atBlock";
  };

  states.keyframes = function(type, stream, state) {
    if (type == "word") { override = "variable"; return "keyframes"; }
    if (type == "{") return pushContext(state, stream, "top");
    return pass(type, stream, state);
  };

  states.at = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == "word") override = "tag";
    else if (type == "hash") override = "builtin";
    return "at";
  };

  states.interpolation = function(type, stream, state) {
    if (type == "}") return popContext(state);
    if (type == "{" || type == ";") return popAndPass(type, stream, state);
    if (type == "word") override = "variable";
    else if (type != "variable" && type != "(" && type != ")") override = "error";
    return "interpolation";
  };

  return {
    startState: function(base) {
      return {tokenize: null,
              state: inline ? "block" : "top",
              stateArg: null,
              context: new Context(inline ? "block" : "top", base || 0, null)};
    },

    token: function(stream, state) {
      if (!state.tokenize && stream.eatSpace()) return null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style && typeof style == "object") {
        type = style[1];
        style = style[0];
      }
      override = style;
      if (type != "comment")
        state.state = states[state.state](type, stream, state);
      return override;
    },

    indent: function(state, textAfter) {
      var cx = state.context, ch = textAfter && textAfter.charAt(0);
      var indent = cx.indent;
      if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
      if (cx.prev) {
        if (ch == "}" && (cx.type == "block" || cx.type == "top" ||
                          cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
          // Resume indentation from parent context.
          cx = cx.prev;
          indent = cx.indent;
        } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
            ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
          // Dedent relative to current context.
          indent = Math.max(0, cx.indent - indentUnit);
        }
      }
      return indent;
    },

    electricChars: "}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    blockCommentContinue: " * ",
    lineComment: lineComment,
    fold: "brace"
  };
});

  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i].toLowerCase()] = true;
    }
    return keys;
  }

  var documentTypes_ = [
    "domain", "regexp", "url", "url-prefix"
  ], documentTypes = keySet(documentTypes_);

  var mediaTypes_ = [
    "all", "aural", "braille", "handheld", "print", "projection", "screen",
    "tty", "tv", "embossed"
  ], mediaTypes = keySet(mediaTypes_);

  var mediaFeatures_ = [
    "width", "min-width", "max-width", "height", "min-height", "max-height",
    "device-width", "min-device-width", "max-device-width", "device-height",
    "min-device-height", "max-device-height", "aspect-ratio",
    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
    "max-color", "color-index", "min-color-index", "max-color-index",
    "monochrome", "min-monochrome", "max-monochrome", "resolution",
    "min-resolution", "max-resolution", "scan", "grid", "orientation",
    "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio",
    "pointer", "any-pointer", "hover", "any-hover"
  ], mediaFeatures = keySet(mediaFeatures_);

  var mediaValueKeywords_ = [
    "landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover",
    "interlace", "progressive"
  ], mediaValueKeywords = keySet(mediaValueKeywords_);

  var propertyKeywords_ = [
    "align-content", "align-items", "align-self", "alignment-adjust",
    "alignment-baseline", "anchor-point", "animation", "animation-delay",
    "animation-direction", "animation-duration", "animation-fill-mode",
    "animation-iteration-count", "animation-name", "animation-play-state",
    "animation-timing-function", "appearance", "azimuth", "backface-visibility",
    "background", "background-attachment", "background-blend-mode", "background-clip",
    "background-color", "background-image", "background-origin", "background-position",
    "background-repeat", "background-size", "baseline-shift", "binding",
    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
    "bookmark-target", "border", "border-bottom", "border-bottom-color",
    "border-bottom-left-radius", "border-bottom-right-radius",
    "border-bottom-style", "border-bottom-width", "border-collapse",
    "border-color", "border-image", "border-image-outset",
    "border-image-repeat", "border-image-slice", "border-image-source",
    "border-image-width", "border-left", "border-left-color",
    "border-left-style", "border-left-width", "border-radius", "border-right",
    "border-right-color", "border-right-style", "border-right-width",
    "border-spacing", "border-style", "border-top", "border-top-color",
    "border-top-left-radius", "border-top-right-radius", "border-top-style",
    "border-top-width", "border-width", "bottom", "box-decoration-break",
    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
    "caption-side", "caret-color", "clear", "clip", "color", "color-profile", "column-count",
    "column-fill", "column-gap", "column-rule", "column-rule-color",
    "column-rule-style", "column-rule-width", "column-span", "column-width",
    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
    "cue-after", "cue-before", "cursor", "direction", "display",
    "dominant-baseline", "drop-initial-after-adjust",
    "drop-initial-after-align", "drop-initial-before-adjust",
    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",
    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",
    "font-stretch", "font-style", "font-synthesis", "font-variant",
    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
    "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow",
    "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap",
    "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap",
    "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns",
    "grid-template-rows", "hanging-punctuation", "height", "hyphens",
    "icon", "image-orientation", "image-rendering", "image-resolution",
    "inline-box-align", "justify-content", "justify-items", "justify-self", "left", "letter-spacing",
    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
    "line-stacking-shift", "line-stacking-strategy", "list-style",
    "list-style-image", "list-style-position", "list-style-type", "margin",
    "margin-bottom", "margin-left", "margin-right", "margin-top",
    "marks", "marquee-direction", "marquee-loop",
    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",
    "nav-left", "nav-right", "nav-up", "object-fit", "object-position",
    "opacity", "order", "orphans", "outline",
    "outline-color", "outline-offset", "outline-style", "outline-width",
    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
    "page", "page-break-after", "page-break-before", "page-break-inside",
    "page-policy", "pause", "pause-after", "pause-before", "perspective",
    "perspective-origin", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "position",
    "presentation-level", "punctuation-trim", "quotes", "region-break-after",
    "region-break-before", "region-break-inside", "region-fragment",
    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",
    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",
    "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin",
    "shape-outside", "size", "speak", "speak-as", "speak-header",
    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
    "tab-size", "table-layout", "target", "target-name", "target-new",
    "target-position", "text-align", "text-align-last", "text-decoration",
    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
    "text-decoration-style", "text-emphasis", "text-emphasis-color",
    "text-emphasis-position", "text-emphasis-style", "text-height",
    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",
    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",
    "text-wrap", "top", "transform", "transform-origin", "transform-style",
    "transition", "transition-delay", "transition-duration",
    "transition-property", "transition-timing-function", "unicode-bidi",
    "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration",
    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
    "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break",
    "word-spacing", "word-wrap", "z-index",
    // SVG-specific
    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
    "color-interpolation", "color-interpolation-filters",
    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
    "glyph-orientation-vertical", "text-anchor", "writing-mode"
  ], propertyKeywords = keySet(propertyKeywords_);

  var nonStandardPropertyKeywords_ = [
    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
    "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside",
    "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button",
    "searchfield-results-decoration", "zoom"
  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);

  var fontProperties_ = [
    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",
    "font-stretch", "font-weight", "font-style"
  ], fontProperties = keySet(fontProperties_);

  var counterDescriptors_ = [
    "additive-symbols", "fallback", "negative", "pad", "prefix", "range",
    "speak-as", "suffix", "symbols", "system"
  ], counterDescriptors = keySet(counterDescriptors_);

  var colorKeywords_ = [
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
    "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
    "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
    "whitesmoke", "yellow", "yellowgreen"
  ], colorKeywords = keySet(colorKeywords_);

  var valueKeywords_ = [
    "above", "absolute", "activeborder", "additive", "activecaption", "afar",
    "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate",
    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
    "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page",
    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",
    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian",
    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
    "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch",
    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
    "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse",
    "compact", "condensed", "contain", "content", "contents",
    "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop",
    "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "dense", "destination-atop",
    "destination-in", "destination-out", "destination-over", "devanagari", "difference",
    "disc", "discard", "disclosure-closed", "disclosure-open", "document",
    "dot-dash", "dot-dot-dash",
    "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig",
    "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed",
    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes",
    "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove",
    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew",
    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
    "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert",
    "italic", "japanese-formal", "japanese-informal", "justify", "kannada",
    "katakana", "katakana-iroha", "keep-all", "khmer",
    "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal",
    "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten",
    "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem",
    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
    "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d",
    "media-controls-background", "media-current-time-display",
    "media-fullscreen-button", "media-mute-button", "media-play-button",
    "media-return-to-realtime-button", "media-rewind-button",
    "media-seek-back-button", "media-seek-forward-button", "media-slider",
    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
    "menu", "menulist", "menulist-button", "menulist-text",
    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize",
    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
    "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote",
    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
    "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter",
    "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d",
    "progress", "push-button", "radial-gradient", "radio", "read-only",
    "read-write", "read-write-plaintext-only", "rectangle", "region",
    "relative", "repeat", "repeating-linear-gradient",
    "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",
    "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY",
    "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running",
    "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen",
    "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield",
    "searchfield-cancel-button", "searchfield-decoration",
    "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end",
    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
    "simp-chinese-formal", "simp-chinese-informal", "single",
    "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
    "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali",
    "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square",
    "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub",
    "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table",
    "table-caption", "table-cell", "table-column", "table-column-group",
    "table-footer-group", "table-header-group", "table-row", "table-row-group",
    "tamil",
    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
    "trad-chinese-formal", "trad-chinese-informal", "transform",
    "translate", "translate3d", "translateX", "translateY", "translateZ",
    "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up",
    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
    "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
    "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor",
    "xx-large", "xx-small"
  ], valueKeywords = keySet(valueKeywords_);

  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)
    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)
    .concat(valueKeywords_);
  CodeMirror.registerHelper("hintWords", "css", allWords);

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ["comment", "comment"];
  }

  CodeMirror.defineMIME("text/css", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    tokenHooks: {
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css"
  });

  CodeMirror.defineMIME("text/x-scss", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      ":": function(stream) {
        if (stream.match(/\s*\{/, false))
          return [null, null]
        return false;
      },
      "$": function(stream) {
        stream.match(/^[\w-]+/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "#": function(stream) {
        if (!stream.eat("{")) return false;
        return [null, "interpolation"];
      }
    },
    name: "css",
    helperType: "scss"
  });

  CodeMirror.defineMIME("text/x-less", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "@": function(stream) {
        if (stream.eat("{")) return [null, "interpolation"];
        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "&": function() {
        return ["atom", "atom"];
      }
    },
    name: "css",
    helperType: "less"
  });

  CodeMirror.defineMIME("text/x-gss", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    supportsAtComponent: true,
    tokenHooks: {
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css",
    helperType: "gss"
  });

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("../xml/xml"), require("../javascript/javascript"), require("../css/css"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/mode/htmlmixed/htmlmixed',["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var defaultTags = {
    script: [
      ["lang", /(javascript|babel)/i, "javascript"],
      ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
      ["type", /./, "text/plain"],
      [null, null, "javascript"]
    ],
    style:  [
      ["lang", /^css$/i, "css"],
      ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
      ["type", /./, "text/plain"],
      [null, null, "css"]
    ]
  };

  function maybeBackup(stream, pat, style) {
    var cur = stream.current(), close = cur.search(pat);
    if (close > -1) {
      stream.backUp(cur.length - close);
    } else if (cur.match(/<\/?$/)) {
      stream.backUp(cur.length);
      if (!stream.match(pat, false)) stream.match(cur);
    }
    return style;
  }

  var attrRegexpCache = {};
  function getAttrRegexp(attr) {
    var regexp = attrRegexpCache[attr];
    if (regexp) return regexp;
    return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
  }

  function getAttrValue(text, attr) {
    var match = text.match(getAttrRegexp(attr))
    return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : ""
  }

  function getTagRegexp(tagName, anchored) {
    return new RegExp((anchored ? "^" : "") + "<\/\s*" + tagName + "\s*>", "i");
  }

  function addTags(from, to) {
    for (var tag in from) {
      var dest = to[tag] || (to[tag] = []);
      var source = from[tag];
      for (var i = source.length - 1; i >= 0; i--)
        dest.unshift(source[i])
    }
  }

  function findMatchingMode(tagInfo, tagText) {
    for (var i = 0; i < tagInfo.length; i++) {
      var spec = tagInfo[i];
      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
    }
  }

  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
    var htmlMode = CodeMirror.getMode(config, {
      name: "xml",
      htmlMode: true,
      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
    });

    var tags = {};
    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
    addTags(defaultTags, tags);
    if (configTags) addTags(configTags, tags);
    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)
      tags.script.unshift(["type", configScript[i].matches, configScript[i].mode])

    function html(stream, state) {
      var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName
      if (tag && !/[<>\s\/]/.test(stream.current()) &&
          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&
          tags.hasOwnProperty(tagName)) {
        state.inTag = tagName + " "
      } else if (state.inTag && tag && />$/.test(stream.current())) {
        var inTag = /^([\S]+) (.*)/.exec(state.inTag)
        state.inTag = null
        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2])
        var mode = CodeMirror.getMode(config, modeSpec)
        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
        state.token = function (stream, state) {
          if (stream.match(endTagA, false)) {
            state.token = html;
            state.localState = state.localMode = null;
            return null;
          }
          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
        };
        state.localMode = mode;
        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, ""));
      } else if (state.inTag) {
        state.inTag += stream.current()
        if (stream.eol()) state.inTag += " "
      }
      return style;
    };

    return {
      startState: function () {
        var state = CodeMirror.startState(htmlMode);
        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};
      },

      copyState: function (state) {
        var local;
        if (state.localState) {
          local = CodeMirror.copyState(state.localMode, state.localState);
        }
        return {token: state.token, inTag: state.inTag,
                localMode: state.localMode, localState: local,
                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
      },

      token: function (stream, state) {
        return state.token(stream, state);
      },

      indent: function (state, textAfter, line) {
        if (!state.localMode || /^\s*<\//.test(textAfter))
          return htmlMode.indent(state.htmlState, textAfter);
        else if (state.localMode.indent)
          return state.localMode.indent(state.localState, textAfter, line);
        else
          return CodeMirror.Pass;
      },

      innerMode: function (state) {
        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
      }
    };
  }, "xml", "javascript", "css");

  CodeMirror.defineMIME("text/html", "htmlmixed");
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/mode/javascript/javascript',["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;
  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    return {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,
      "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
      "await": C
    };
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    } else if (ch == "0" && stream.eat(/o/i)) {
      stream.eatWhile(/[0-7]/i);
      return ret("number", "number");
    } else if (ch == "0" && stream.eat(/b/i)) {
      stream.eatWhile(/[01]/i);
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (expressionAllowed(stream, state, 1)) {
        readRegexp(stream);
        stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
        return ret("regexp", "string-2");
      } else {
        stream.eat("=");
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    } else if (isOperatorChar.test(ch)) {
      if (ch != ">" || !state.lexical || state.lexical.type != ">") {
        if (stream.eat("=")) {
          if (ch == "!" || ch == "=") stream.eat("=")
        } else if (/[<>*+\-]/.test(ch)) {
          stream.eat(ch)
          if (ch == ">") stream.eat(ch)
        }
      }
      return ret("operator", "operator", stream.current());
    } else if (wordRE.test(ch)) {
      stream.eatWhile(wordRE);
      var word = stream.current()
      if (state.lastType != ".") {
        if (keywords.propertyIsEnumerable(word)) {
          var kw = keywords[word]
          return ret(kw.type, kw.style, word)
        }
        if (word == "async" && stream.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, false))
          return ret("async", "keyword", word)
      }
      return ret("variable", "variable", word)
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    if (isTS) { // Try to skip TypeScript return type declarations after the arguments
      var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow))
      if (m) arrow = m.index
    }

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (wordRE.test(ch)) {
        sawSomething = true;
      } else if (/["'\/]/.test(ch)) {
        return;
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    cx.marked = "def";
    if (state.context) {
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      if (parserConfig.globalVars)
        state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  function isModifier(name) {
    return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly"
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
        indent = outer.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
    if (type == "debugger") return cont(expect(";"));
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
    if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), className, poplex); }
    if (type == "variable") {
      if (isTS && value == "declare") {
        cx.marked = "keyword"
        return cont(statement)
      } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
        cx.marked = "keyword"
        if (value == "enum") return cont(enumdef);
        else if (value == "type") return cont(typeexpr, expect("operator"), typeexpr, expect(";"));
        else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
      } else if (isTS && value == "namespace") {
        cx.marked = "keyword"
        return cont(pushlex("form"), expression, block, poplex)
      } else if (isTS && value == "abstract") {
        cx.marked = "keyword"
        return cont(statement)
      } else {
        return cont(pushlex("stat"), maybelabel);
      }
    }
    if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"),
                                      block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                     statement, poplex, popcontext);
    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
    if (type == "async") return cont(statement)
    if (value == "@") return cont(expression, statement)
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type, value) {
    return expressionInner(type, value, false);
  }
  function expressionNoComma(type, value) {
    return expressionInner(type, value, true);
  }
  function parenExpr(type) {
    if (type != "(") return pass()
    return cont(pushlex(")"), expression, expect(")"), poplex)
  }
  function expressionInner(type, value, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), classExpression, poplex); }
    if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") return pass(quasi, maybeop);
    if (type == "new") return cont(maybeTarget(noComma));
    if (type == "import") return cont(expression);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
      if (isTS && value == "<" && cx.stream.match(/^([^>]|<.*?>)*>\s*\(/, false))
        return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
    if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }
    if (type == "regexp") {
      cx.state.lastType = cx.marked = "operator"
      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)
      return cont(expr)
    }
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expressionNoComma);
  }
  function maybeTarget(noComma) {
    return function(type) {
      if (type == ".") return cont(noComma ? targetNoComma : target);
      else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)
      else return pass(noComma ? expressionNoComma : expression);
    };
  }
  function target(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
  }
  function targetNoComma(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "async") {
      cx.marked = "property";
      return cont(objprop);
    } else if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params
      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
        cx.state.fatArrowAt = cx.stream.pos + m[0].length
      return cont(afterprop);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (cx.style + " property");
      return cont(afterprop);
    } else if (type == "jsonld-keyword") {
      return cont(afterprop);
    } else if (isTS && isModifier(value)) {
      cx.marked = "keyword"
      return cont(objprop)
    } else if (type == "[") {
      return cont(expression, maybetype, expect("]"), afterprop);
    } else if (type == "spread") {
      return cont(expressionNoComma, afterprop);
    } else if (value == "*") {
      cx.marked = "keyword";
      return cont(objprop);
    } else if (type == ":") {
      return pass(afterprop)
    }
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end, sep) {
    function proceed(type, value) {
      if (sep ? sep.indexOf(type) > -1 : type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(function(type, value) {
          if (type == end || value == end) return pass()
          return pass(what)
        }, proceed);
      }
      if (type == end || value == end) return cont();
      return cont(expect(end));
    }
    return function(type, value) {
      if (type == end || value == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type, value) {
    if (isTS) {
      if (type == ":") return cont(typeexpr);
      if (value == "?") return cont(maybetype);
    }
  }
  function mayberettype(type) {
    if (isTS && type == ":") {
      if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr)
      else return cont(typeexpr)
    }
  }
  function isKW(_, value) {
    if (value == "is") {
      cx.marked = "keyword"
      return cont()
    }
  }
  function typeexpr(type, value) {
    if (value == "keyof" || value == "typeof") {
      cx.marked = "keyword"
      return cont(value == "keyof" ? typeexpr : expressionNoComma)
    }
    if (type == "variable" || value == "void") {
      cx.marked = "type"
      return cont(afterType)
    }
    if (type == "string" || type == "number" || type == "atom") return cont(afterType);
    if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)
    if (type == "{") return cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType)
    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType)
    if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr)
  }
  function maybeReturnType(type) {
    if (type == "=>") return cont(typeexpr)
  }
  function typeprop(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property"
      return cont(typeprop)
    } else if (value == "?") {
      return cont(typeprop)
    } else if (type == ":") {
      return cont(typeexpr)
    } else if (type == "[") {
      return cont(expression, maybetype, expect("]"), typeprop)
    }
  }
  function typearg(type, value) {
    if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg)
    if (type == ":") return cont(typeexpr)
    return pass(typeexpr)
  }
  function afterType(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
    if (value == "|" || type == "." || value == "&") return cont(typeexpr)
    if (type == "[") return cont(expect("]"), afterType)
    if (value == "extends" || value == "implements") { cx.marked = "keyword"; return cont(typeexpr) }
  }
  function maybeTypeArgs(_, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
  }
  function typeparam() {
    return pass(typeexpr, maybeTypeDefault)
  }
  function maybeTypeDefault(_, value) {
    if (value == "=") return cont(typeexpr)
  }
  function vardef(_, value) {
    if (value == "enum") {cx.marked = "keyword"; return cont(enumdef)}
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(pattern) }
    if (type == "variable") { register(value); return cont(); }
    if (type == "spread") return cont(pattern);
    if (type == "[") return contCommasep(pattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    if (type == "spread") return cont(pattern);
    if (type == "}") return pass();
    return cont(expect(":"), pattern, maybeAssign);
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type, value) {
    if (value == "await") return cont(forspec);
    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, expect(";"), forspec2);
    if (type == ";") return cont(forspec2);
    if (type == "variable") return cont(formaybeinof);
    return pass(expression, expect(";"), forspec2);
  }
  function formaybeinof(_type, value) {
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return pass(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef)
  }
  function funarg(type, value) {
    if (value == "@") cont(expression, funarg)
    if (type == "spread") return cont(funarg);
    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(funarg); }
    return pass(pattern, maybetype, maybeAssign);
  }
  function classExpression(type, value) {
    // Class expressions may have an optional name.
    if (type == "variable") return className(type, value);
    return classNameAfter(type, value);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter)
    if (value == "extends" || value == "implements" || (isTS && type == ",")) {
      if (value == "implements") cx.marked = "keyword";
      return cont(isTS ? typeexpr : expression, classNameAfter);
    }
    if (type == "{") return cont(pushlex("}"), classBody, poplex);
  }
  function classBody(type, value) {
    if (type == "async" ||
        (type == "variable" &&
         (value == "static" || value == "get" || value == "set" || (isTS && isModifier(value))) &&
         cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))) {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      return cont(isTS ? classfield : functiondef, classBody);
    }
    if (type == "[")
      return cont(expression, maybetype, expect("]"), isTS ? classfield : functiondef, classBody)
    if (value == "*") {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == ";") return cont(classBody);
    if (type == "}") return cont();
    if (value == "@") return cont(expression, classBody)
  }
  function classfield(type, value) {
    if (value == "?") return cont(classfield)
    if (type == ":") return cont(typeexpr, maybeAssign)
    if (value == "=") return cont(expressionNoComma)
    return pass(functiondef)
  }
  function afterExport(type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
    return pass(statement);
  }
  function exportField(type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
    if (type == "variable") return pass(expressionNoComma, exportField);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    if (type == "(") return pass(expression);
    return pass(importSpec, maybeMoreImports, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    if (value == "*") cx.marked = "keyword";
    return cont(maybeAs);
  }
  function maybeMoreImports(type) {
    if (type == ",") return cont(importSpec, maybeMoreImports)
  }
  function maybeAs(_type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(commasep(expressionNoComma, "]"));
  }
  function enumdef() {
    return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
  }
  function enummember() {
    return pass(pattern, maybeAssign);
  }

  function isContinuedStatement(state, textAfter) {
    return state.lastType == "operator" || state.lastType == "," ||
      isOperatorChar.test(textAfter.charAt(0)) ||
      /[,.]/.test(textAfter.charAt(0));
  }

  function expressionAllowed(stream, state, backUp) {
    return state.tokenize == tokenBase &&
      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
      (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: basecolumn || 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      while ((lexical.type == "stat" || lexical.type == "form") &&
             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
                                   !/^[,\.=+\-*:?[\(]/.test(textAfter))))
        lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    blockCommentContinue: jsonMode ? null : " * ",
    lineComment: jsonMode ? null : "//",
    fold: "brace",
    closeBrackets: "()[]{}''\"\"``",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode,

    expressionAllowed: expressionAllowed,

    skipExpression: function(state) {
      var top = state.cc[state.cc.length - 1]
      if (top == expression || top == expressionNoComma) state.cc.pop()
    }
  };
});

CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/x-javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("../xml/xml"), require("../meta"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/mode/markdown/markdown',["../../lib/codemirror", "../xml/xml", "../meta"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("markdown", function(cmCfg, modeCfg) {

  var htmlMode = CodeMirror.getMode(cmCfg, "text/html");
  var htmlModeMissing = htmlMode.name == "null"

  function getMode(name) {
    if (CodeMirror.findModeByName) {
      var found = CodeMirror.findModeByName(name);
      if (found) name = found.mime || found.mimes[0];
    }
    var mode = CodeMirror.getMode(cmCfg, name);
    return mode.name == "null" ? null : mode;
  }

  // Should characters that affect highlighting be highlighted separate?
  // Does not include characters that will be output (such as `1.` and `-` for lists)
  if (modeCfg.highlightFormatting === undefined)
    modeCfg.highlightFormatting = false;

  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.
  // Excess `>` will emit `error` token.
  if (modeCfg.maxBlockquoteDepth === undefined)
    modeCfg.maxBlockquoteDepth = 0;

  // Turn on task lists? ("- [ ] " and "- [x] ")
  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;

  // Turn on strikethrough syntax
  if (modeCfg.strikethrough === undefined)
    modeCfg.strikethrough = false;

  if (modeCfg.emoji === undefined)
    modeCfg.emoji = false;

  if (modeCfg.fencedCodeBlockHighlighting === undefined)
    modeCfg.fencedCodeBlockHighlighting = true;

  if (modeCfg.xml === undefined)
    modeCfg.xml = true;

  // Allow token types to be overridden by user-provided token types.
  if (modeCfg.tokenTypeOverrides === undefined)
    modeCfg.tokenTypeOverrides = {};

  var tokenTypes = {
    header: "header",
    code: "comment",
    quote: "quote",
    list1: "variable-2",
    list2: "variable-3",
    list3: "keyword",
    hr: "hr",
    image: "image",
    imageAltText: "image-alt-text",
    imageMarker: "image-marker",
    formatting: "formatting",
    linkInline: "link",
    linkEmail: "link",
    linkText: "link",
    linkHref: "string",
    em: "em",
    strong: "strong",
    strikethrough: "strikethrough",
    emoji: "builtin"
  };

  for (var tokenType in tokenTypes) {
    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {
      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
    }
  }

  var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/
  ,   listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/
  ,   taskListRE = /^\[(x| )\](?=\s)/i // Must follow listRE
  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/
  ,   setextHeaderRE = /^ *(?:\={1,}|-{1,})\s*$/
  ,   textRE = /^[^#!\[\]*_\\<>` "'(~:]+/
  ,   fencedCodeRE = /^(~~~+|```+)[ \t]*([\w+#-]*)[^\n`]*$/
  ,   linkDefRE = /^\s*\[[^\]]+?\]:.*$/ // naive link-definition
  ,   punctuation = /[!\"#$%&\'()*+,\-\.\/:;<=>?@\[\\\]^_`{|}~—]/
  ,   expandedTab = "    " // CommonMark specifies tab as 4 spaces

  function switchInline(stream, state, f) {
    state.f = state.inline = f;
    return f(stream, state);
  }

  function switchBlock(stream, state, f) {
    state.f = state.block = f;
    return f(stream, state);
  }

  function lineIsEmpty(line) {
    return !line || !/\S/.test(line.string)
  }

  // Blocks

  function blankLine(state) {
    // Reset linkTitle state
    state.linkTitle = false;
    state.linkHref = false;
    state.linkText = false;
    // Reset EM state
    state.em = false;
    // Reset STRONG state
    state.strong = false;
    // Reset strikethrough state
    state.strikethrough = false;
    // Reset state.quote
    state.quote = 0;
    // Reset state.indentedCode
    state.indentedCode = false;
    if (state.f == htmlBlock) {
      state.f = inlineNormal;
      state.block = blockNormal;
    }
    // Reset state.trailingSpace
    state.trailingSpace = 0;
    state.trailingSpaceNewLine = false;
    // Mark this line as blank
    state.prevLine = state.thisLine
    state.thisLine = {stream: null}
    return null;
  }

  function blockNormal(stream, state) {
    var firstTokenOnLine = stream.column() === state.indentation;
    var prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream);
    var prevLineIsIndentedCode = state.indentedCode;
    var prevLineIsHr = state.prevLine.hr;
    var prevLineIsList = state.list !== false;
    var maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;

    state.indentedCode = false;

    var lineIndentation = state.indentation;
    // compute once per line (on first token)
    if (state.indentationDiff === null) {
      state.indentationDiff = state.indentation;
      if (prevLineIsList) {
        // Reset inline styles which shouldn't propagate aross list items
        state.em = false;
        state.strong = false;
        state.code = false;
        state.strikethrough = false;

        state.list = null;
        // While this list item's marker's indentation is less than the deepest
        //  list item's content's indentation,pop the deepest list item
        //  indentation off the stack, and update block indentation state
        while (lineIndentation < state.listStack[state.listStack.length - 1]) {
          state.listStack.pop();
          if (state.listStack.length) {
            state.indentation = state.listStack[state.listStack.length - 1];
          // less than the first list's indent -> the line is no longer a list
          } else {
            state.list = false;
          }
        }
        if (state.list !== false) {
          state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1]
        }
      }
    }

    // not comprehensive (currently only for setext detection purposes)
    var allowsInlineContinuation = (
        !prevLineLineIsEmpty && !prevLineIsHr && !state.prevLine.header &&
        (!prevLineIsList || !prevLineIsIndentedCode) &&
        !state.prevLine.fencedCodeEnd
    );

    var isHr = (state.list === false || prevLineIsHr || prevLineLineIsEmpty) &&
      state.indentation <= maxNonCodeIndentation && stream.match(hrRE);

    var match = null;
    if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd ||
         state.prevLine.header || prevLineLineIsEmpty)) {
      stream.skipToEnd();
      state.indentedCode = true;
      return tokenTypes.code;
    } else if (stream.eatSpace()) {
      return null;
    } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) {
      state.quote = 0;
      state.header = match[1].length;
      state.thisLine.header = true;
      if (modeCfg.highlightFormatting) state.formatting = "header";
      state.f = state.inline;
      return getType(state);
    } else if (state.indentation <= maxNonCodeIndentation && stream.eat('>')) {
      state.quote = firstTokenOnLine ? 1 : state.quote + 1;
      if (modeCfg.highlightFormatting) state.formatting = "quote";
      stream.eatSpace();
      return getType(state);
    } else if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {
      var listType = match[1] ? "ol" : "ul";

      state.indentation = lineIndentation + stream.current().length;
      state.list = true;
      state.quote = 0;

      // Add this list item's content's indentation to the stack
      state.listStack.push(state.indentation);

      if (modeCfg.taskLists && stream.match(taskListRE, false)) {
        state.taskList = true;
      }
      state.f = state.inline;
      if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];
      return getType(state);
    } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, true))) {
      state.quote = 0;
      state.fencedEndRE = new RegExp(match[1] + "+ *$");
      // try switching mode
      state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2]);
      if (state.localMode) state.localState = CodeMirror.startState(state.localMode);
      state.f = state.block = local;
      if (modeCfg.highlightFormatting) state.formatting = "code-block";
      state.code = -1
      return getType(state);
    // SETEXT has lowest block-scope precedence after HR, so check it after
    //  the others (code, blockquote, list...)
    } else if (
      // if setext set, indicates line after ---/===
      state.setext || (
        // line before ---/===
        (!allowsInlineContinuation || !prevLineIsList) && !state.quote && state.list === false &&
        !state.code && !isHr && !linkDefRE.test(stream.string) &&
        (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE))
      )
    ) {
      if ( !state.setext ) {
        state.header = match[0].charAt(0) == '=' ? 1 : 2;
        state.setext = state.header;
      } else {
        state.header = state.setext;
        // has no effect on type so we can reset it now
        state.setext = 0;
        stream.skipToEnd();
        if (modeCfg.highlightFormatting) state.formatting = "header";
      }
      state.thisLine.header = true;
      state.f = state.inline;
      return getType(state);
    } else if (isHr) {
      stream.skipToEnd();
      state.hr = true;
      state.thisLine.hr = true;
      return tokenTypes.hr;
    } else if (stream.peek() === '[') {
      return switchInline(stream, state, footnoteLink);
    }

    return switchInline(stream, state, state.inline);
  }

  function htmlBlock(stream, state) {
    var style = htmlMode.token(stream, state.htmlState);
    if (!htmlModeMissing) {
      var inner = CodeMirror.innerMode(htmlMode, state.htmlState)
      if ((inner.mode.name == "xml" && inner.state.tagStart === null &&
           (!inner.state.context && inner.state.tokenize.isInText)) ||
          (state.md_inside && stream.current().indexOf(">") > -1)) {
        state.f = inlineNormal;
        state.block = blockNormal;
        state.htmlState = null;
      }
    }
    return style;
  }

  function local(stream, state) {
    var currListInd = state.listStack[state.listStack.length - 1] || 0;
    var hasExitedList = state.indentation < currListInd;
    var maxFencedEndInd = currListInd + 3;
    if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {
      if (modeCfg.highlightFormatting) state.formatting = "code-block";
      var returnType;
      if (!hasExitedList) returnType = getType(state)
      state.localMode = state.localState = null;
      state.block = blockNormal;
      state.f = inlineNormal;
      state.fencedEndRE = null;
      state.code = 0
      state.thisLine.fencedCodeEnd = true;
      if (hasExitedList) return switchBlock(stream, state, state.block);
      return returnType;
    } else if (state.localMode) {
      return state.localMode.token(stream, state.localState);
    } else {
      stream.skipToEnd();
      return tokenTypes.code;
    }
  }

  // Inline
  function getType(state) {
    var styles = [];

    if (state.formatting) {
      styles.push(tokenTypes.formatting);

      if (typeof state.formatting === "string") state.formatting = [state.formatting];

      for (var i = 0; i < state.formatting.length; i++) {
        styles.push(tokenTypes.formatting + "-" + state.formatting[i]);

        if (state.formatting[i] === "header") {
          styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.header);
        }

        // Add `formatting-quote` and `formatting-quote-#` for blockquotes
        // Add `error` instead if the maximum blockquote nesting depth is passed
        if (state.formatting[i] === "quote") {
          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
            styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.quote);
          } else {
            styles.push("error");
          }
        }
      }
    }

    if (state.taskOpen) {
      styles.push("meta");
      return styles.length ? styles.join(' ') : null;
    }
    if (state.taskClosed) {
      styles.push("property");
      return styles.length ? styles.join(' ') : null;
    }

    if (state.linkHref) {
      styles.push(tokenTypes.linkHref, "url");
    } else { // Only apply inline styles to non-url text
      if (state.strong) { styles.push(tokenTypes.strong); }
      if (state.em) { styles.push(tokenTypes.em); }
      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }
      if (state.emoji) { styles.push(tokenTypes.emoji); }
      if (state.linkText) { styles.push(tokenTypes.linkText); }
      if (state.code) { styles.push(tokenTypes.code); }
      if (state.image) { styles.push(tokenTypes.image); }
      if (state.imageAltText) { styles.push(tokenTypes.imageAltText, "link"); }
      if (state.imageMarker) { styles.push(tokenTypes.imageMarker); }
    }

    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header); }

    if (state.quote) {
      styles.push(tokenTypes.quote);

      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth
      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
        styles.push(tokenTypes.quote + "-" + state.quote);
      } else {
        styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
      }
    }

    if (state.list !== false) {
      var listMod = (state.listStack.length - 1) % 3;
      if (!listMod) {
        styles.push(tokenTypes.list1);
      } else if (listMod === 1) {
        styles.push(tokenTypes.list2);
      } else {
        styles.push(tokenTypes.list3);
      }
    }

    if (state.trailingSpaceNewLine) {
      styles.push("trailing-space-new-line");
    } else if (state.trailingSpace) {
      styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
    }

    return styles.length ? styles.join(' ') : null;
  }

  function handleText(stream, state) {
    if (stream.match(textRE, true)) {
      return getType(state);
    }
    return undefined;
  }

  function inlineNormal(stream, state) {
    var style = state.text(stream, state);
    if (typeof style !== 'undefined')
      return style;

    if (state.list) { // List marker (*, +, -, 1., etc)
      state.list = null;
      return getType(state);
    }

    if (state.taskList) {
      var taskOpen = stream.match(taskListRE, true)[1] === " ";
      if (taskOpen) state.taskOpen = true;
      else state.taskClosed = true;
      if (modeCfg.highlightFormatting) state.formatting = "task";
      state.taskList = false;
      return getType(state);
    }

    state.taskOpen = false;
    state.taskClosed = false;

    if (state.header && stream.match(/^#+$/, true)) {
      if (modeCfg.highlightFormatting) state.formatting = "header";
      return getType(state);
    }

    var ch = stream.next();

    // Matches link titles present on next line
    if (state.linkTitle) {
      state.linkTitle = false;
      var matchCh = ch;
      if (ch === '(') {
        matchCh = ')';
      }
      matchCh = (matchCh+'').replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1");
      var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
      if (stream.match(new RegExp(regex), true)) {
        return tokenTypes.linkHref;
      }
    }

    // If this block is changed, it may need to be updated in GFM mode
    if (ch === '`') {
      var previousFormatting = state.formatting;
      if (modeCfg.highlightFormatting) state.formatting = "code";
      stream.eatWhile('`');
      var count = stream.current().length
      if (state.code == 0 && (!state.quote || count == 1)) {
        state.code = count
        return getType(state)
      } else if (count == state.code) { // Must be exact
        var t = getType(state)
        state.code = 0
        return t
      } else {
        state.formatting = previousFormatting
        return getType(state)
      }
    } else if (state.code) {
      return getType(state);
    }

    if (ch === '\\') {
      stream.next();
      if (modeCfg.highlightFormatting) {
        var type = getType(state);
        var formattingEscape = tokenTypes.formatting + "-escape";
        return type ? type + " " + formattingEscape : formattingEscape;
      }
    }

    if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
      state.imageMarker = true;
      state.image = true;
      if (modeCfg.highlightFormatting) state.formatting = "image";
      return getType(state);
    }

    if (ch === '[' && state.imageMarker && stream.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, false)) {
      state.imageMarker = false;
      state.imageAltText = true
      if (modeCfg.highlightFormatting) state.formatting = "image";
      return getType(state);
    }

    if (ch === ']' && state.imageAltText) {
      if (modeCfg.highlightFormatting) state.formatting = "image";
      var type = getType(state);
      state.imageAltText = false;
      state.image = false;
      state.inline = state.f = linkHref;
      return type;
    }

    if (ch === '[' && !state.image) {
      state.linkText = true;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      return getType(state);
    }

    if (ch === ']' && state.linkText) {
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      state.linkText = false;
      state.inline = state.f = stream.match(/\(.*?\)| ?\[.*?\]/, false) ? linkHref : inlineNormal
      return type;
    }

    if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
      state.f = state.inline = linkInline;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + tokenTypes.linkInline;
    }

    if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
      state.f = state.inline = linkInline;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + tokenTypes.linkEmail;
    }

    if (modeCfg.xml && ch === '<' && stream.match(/^(!--|[a-z][a-z0-9-]*(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*>)/i, false)) {
      var end = stream.string.indexOf(">", stream.pos);
      if (end != -1) {
        var atts = stream.string.substring(stream.start, end);
        if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) state.md_inside = true;
      }
      stream.backUp(1);
      state.htmlState = CodeMirror.startState(htmlMode);
      return switchBlock(stream, state, htmlBlock);
    }

    if (modeCfg.xml && ch === '<' && stream.match(/^\/\w*?>/)) {
      state.md_inside = false;
      return "tag";
    } else if (ch === "*" || ch === "_") {
      var len = 1, before = stream.pos == 1 ? " " : stream.string.charAt(stream.pos - 2)
      while (len < 3 && stream.eat(ch)) len++
      var after = stream.peek() || " "
      // See http://spec.commonmark.org/0.27/#emphasis-and-strong-emphasis
      var leftFlanking = !/\s/.test(after) && (!punctuation.test(after) || /\s/.test(before) || punctuation.test(before))
      var rightFlanking = !/\s/.test(before) && (!punctuation.test(before) || /\s/.test(after) || punctuation.test(after))
      var setEm = null, setStrong = null
      if (len % 2) { // Em
        if (!state.em && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
          setEm = true
        else if (state.em == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
          setEm = false
      }
      if (len > 1) { // Strong
        if (!state.strong && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
          setStrong = true
        else if (state.strong == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
          setStrong = false
      }
      if (setStrong != null || setEm != null) {
        if (modeCfg.highlightFormatting) state.formatting = setEm == null ? "strong" : setStrong == null ? "em" : "strong em"
        if (setEm === true) state.em = ch
        if (setStrong === true) state.strong = ch
        var t = getType(state)
        if (setEm === false) state.em = false
        if (setStrong === false) state.strong = false
        return t
      }
    } else if (ch === ' ') {
      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces
        if (stream.peek() === ' ') { // Surrounded by spaces, ignore
          return getType(state);
        } else { // Not surrounded by spaces, back up pointer
          stream.backUp(1);
        }
      }
    }

    if (modeCfg.strikethrough) {
      if (ch === '~' && stream.eatWhile(ch)) {
        if (state.strikethrough) {// Remove strikethrough
          if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
          var t = getType(state);
          state.strikethrough = false;
          return t;
        } else if (stream.match(/^[^\s]/, false)) {// Add strikethrough
          state.strikethrough = true;
          if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
          return getType(state);
        }
      } else if (ch === ' ') {
        if (stream.match(/^~~/, true)) { // Probably surrounded by space
          if (stream.peek() === ' ') { // Surrounded by spaces, ignore
            return getType(state);
          } else { // Not surrounded by spaces, back up pointer
            stream.backUp(2);
          }
        }
      }
    }

    if (modeCfg.emoji && ch === ":" && stream.match(/^[a-z_\d+-]+:/)) {
      state.emoji = true;
      if (modeCfg.highlightFormatting) state.formatting = "emoji";
      var retType = getType(state);
      state.emoji = false;
      return retType;
    }

    if (ch === ' ') {
      if (stream.match(/ +$/, false)) {
        state.trailingSpace++;
      } else if (state.trailingSpace) {
        state.trailingSpaceNewLine = true;
      }
    }

    return getType(state);
  }

  function linkInline(stream, state) {
    var ch = stream.next();

    if (ch === ">") {
      state.f = state.inline = inlineNormal;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + tokenTypes.linkInline;
    }

    stream.match(/^[^>]+/, true);

    return tokenTypes.linkInline;
  }

  function linkHref(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if(stream.eatSpace()){
      return null;
    }
    var ch = stream.next();
    if (ch === '(' || ch === '[') {
      state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
      if (modeCfg.highlightFormatting) state.formatting = "link-string";
      state.linkHref = true;
      return getType(state);
    }
    return 'error';
  }

  var linkRE = {
    ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
    "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/
  }

  function getLinkHrefInside(endChar) {
    return function(stream, state) {
      var ch = stream.next();

      if (ch === endChar) {
        state.f = state.inline = inlineNormal;
        if (modeCfg.highlightFormatting) state.formatting = "link-string";
        var returnState = getType(state);
        state.linkHref = false;
        return returnState;
      }

      stream.match(linkRE[endChar])
      state.linkHref = true;
      return getType(state);
    };
  }

  function footnoteLink(stream, state) {
    if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {
      state.f = footnoteLinkInside;
      stream.next(); // Consume [
      if (modeCfg.highlightFormatting) state.formatting = "link";
      state.linkText = true;
      return getType(state);
    }
    return switchInline(stream, state, inlineNormal);
  }

  function footnoteLinkInside(stream, state) {
    if (stream.match(/^\]:/, true)) {
      state.f = state.inline = footnoteUrl;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var returnType = getType(state);
      state.linkText = false;
      return returnType;
    }

    stream.match(/^([^\]\\]|\\.)+/, true);

    return tokenTypes.linkText;
  }

  function footnoteUrl(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if(stream.eatSpace()){
      return null;
    }
    // Match URL
    stream.match(/^[^\s]+/, true);
    // Check for link title
    if (stream.peek() === undefined) { // End of line, set flag to check next line
      state.linkTitle = true;
    } else { // More content on line, check if link title
      stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
    }
    state.f = state.inline = inlineNormal;
    return tokenTypes.linkHref + " url";
  }

  var mode = {
    startState: function() {
      return {
        f: blockNormal,

        prevLine: {stream: null},
        thisLine: {stream: null},

        block: blockNormal,
        htmlState: null,
        indentation: 0,

        inline: inlineNormal,
        text: handleText,

        formatting: false,
        linkText: false,
        linkHref: false,
        linkTitle: false,
        code: 0,
        em: false,
        strong: false,
        header: 0,
        setext: 0,
        hr: false,
        taskList: false,
        list: false,
        listStack: [],
        quote: 0,
        trailingSpace: 0,
        trailingSpaceNewLine: false,
        strikethrough: false,
        emoji: false,
        fencedEndRE: null
      };
    },

    copyState: function(s) {
      return {
        f: s.f,

        prevLine: s.prevLine,
        thisLine: s.thisLine,

        block: s.block,
        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),
        indentation: s.indentation,

        localMode: s.localMode,
        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,

        inline: s.inline,
        text: s.text,
        formatting: false,
        linkText: s.linkText,
        linkTitle: s.linkTitle,
        linkHref: s.linkHref,
        code: s.code,
        em: s.em,
        strong: s.strong,
        strikethrough: s.strikethrough,
        emoji: s.emoji,
        header: s.header,
        setext: s.setext,
        hr: s.hr,
        taskList: s.taskList,
        list: s.list,
        listStack: s.listStack.slice(0),
        quote: s.quote,
        indentedCode: s.indentedCode,
        trailingSpace: s.trailingSpace,
        trailingSpaceNewLine: s.trailingSpaceNewLine,
        md_inside: s.md_inside,
        fencedEndRE: s.fencedEndRE
      };
    },

    token: function(stream, state) {

      // Reset state.formatting
      state.formatting = false;

      if (stream != state.thisLine.stream) {
        state.header = 0;
        state.hr = false;

        if (stream.match(/^\s*$/, true)) {
          blankLine(state);
          return null;
        }

        state.prevLine = state.thisLine
        state.thisLine = {stream: stream}

        // Reset state.taskList
        state.taskList = false;

        // Reset state.trailingSpace
        state.trailingSpace = 0;
        state.trailingSpaceNewLine = false;

        if (!state.localState) {
          state.f = state.block;
          if (state.f != htmlBlock) {
            var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, expandedTab).length;
            state.indentation = indentation;
            state.indentationDiff = null;
            if (indentation > 0) return null;
          }
        }
      }
      return state.f(stream, state);
    },

    innerMode: function(state) {
      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};
      if (state.localState) return {state: state.localState, mode: state.localMode};
      return {state: state, mode: mode};
    },

    indent: function(state, textAfter, line) {
      if (state.block == htmlBlock && htmlMode.indent) return htmlMode.indent(state.htmlState, textAfter, line)
      if (state.localState && state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line)
      return CodeMirror.Pass
    },

    blankLine: blankLine,

    getType: getType,

    closeBrackets: "()[]{}''\"\"``",
    fold: "markdown"
  };
  return mode;
}, "xml");

CodeMirror.defineMIME("text/markdown", "markdown");

CodeMirror.defineMIME("text/x-markdown", "markdown");

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/mode/meta',["../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  CodeMirror.modeInfo = [
    {name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"]},
    {name: "PGP", mimes: ["application/pgp", "application/pgp-encrypted", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["asc", "pgp", "sig"]},
    {name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"]},
    {name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i},
    {name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"]},
    {name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h", "ino"]},
    {name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"]},
    {name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy"]},
    {name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp"]},
    {name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"]},
    {name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"]},
    {name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"]},
    {name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists.txt$/},
    {name: "CoffeeScript", mimes: ["application/vnd.coffeescript", "text/coffeescript", "text/x-coffeescript"], mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"]},
    {name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"]},
    {name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"]},
    {name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"]},
    {name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"]},
    {name: "CSS", mime: "text/css", mode: "css", ext: ["css"]},
    {name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"]},
    {name: "D", mime: "text/x-d", mode: "d", ext: ["d"]},
    {name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"]},
    {name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"]},
    {name: "Django", mime: "text/x-django", mode: "django"},
    {name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/},
    {name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"]},
    {name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"]},
    {name: "EBNF", mime: "text/x-ebnf", mode: "ebnf"},
    {name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"]},
    {name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"]},
    {name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"]},
    {name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"]},
    {name: "Embedded Javascript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"]},
    {name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"]},
    {name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"]},
    {name: "Esper", mime: "text/x-esper", mode: "sql"},
    {name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"]},
    {name: "FCL", mime: "text/x-fcl", mode: "fcl"},
    {name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"]},
    {name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90"]},
    {name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"]},
    {name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"]},
    {name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"]},
    {name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history).md$/i},
    {name: "Go", mime: "text/x-go", mode: "go", ext: ["go"]},
    {name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"], file: /^Jenkinsfile$/},
    {name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"]},
    {name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"]},
    {name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"]},
    {name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"]},
    {name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"]},
    {name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"]},
    {name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm", "handlebars", "hbs"], alias: ["xhtml"]},
    {name: "HTTP", mime: "message/http", mode: "http"},
    {name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"]},
    {name: "Pug", mime: "text/x-pug", mode: "pug", ext: ["jade", "pug"], alias: ["jade"]},
    {name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"]},
    {name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"]},
    {name: "JavaScript", mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
     mode: "javascript", ext: ["js"], alias: ["ecmascript", "js", "node"]},
    {name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"]},
    {name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"]},
    {name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"]},
    {name: "Jinja2", mime: "null", mode: "jinja2"},
    {name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"]},
    {name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"]},
    {name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"]},
    {name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"]},
    {name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"]},
    {name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"]},
    {name: "mIRC", mime: "text/mirc", mode: "mirc"},
    {name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql"},
    {name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb"]},
    {name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"]},
    {name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"]},
    {name: "MS SQL", mime: "text/x-mssql", mode: "sql"},
    {name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"]},
    {name: "MySQL", mime: "text/x-mysql", mode: "sql"},
    {name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i},
    {name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"]},
    {name: "NTriples", mimes: ["application/n-triples", "application/n-quads", "text/n-triples"],
     mode: "ntriples", ext: ["nt", "nq"]},
    {name: "Objective-C", mime: "text/x-objectivec", mode: "clike", ext: ["m", "mm"], alias: ["objective-c", "objc"]},
    {name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"]},
    {name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"]},
    {name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"]},
    {name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"]},
    {name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"]},
    {name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"]},
    {name: "PHP", mimes: ["text/x-php", "application/x-httpd-php", "application/x-httpd-php-open"], mode: "php", ext: ["php", "php3", "php4", "php5", "php7", "phtml"]},
    {name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"]},
    {name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"]},
    {name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"]},
    {name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"]},
    {name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"]},
    {name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"]},
    {name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/},
    {name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"]},
    {name: "Q", mime: "text/x-q", mode: "q", ext: ["q"]},
    {name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r", "R"], alias: ["rscript"]},
    {name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"]},
    {name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm"},
    {name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"]},
    {name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"]},
    {name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"]},
    {name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"]},
    {name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"]},
    {name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"]},
    {name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"]},
    {name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"]},
    {name: "Shell", mimes: ["text/x-sh", "application/x-sh"], mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/},
    {name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"]},
    {name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"]},
    {name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"]},
    {name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"]},
    {name: "Solr", mime: "text/x-solr", mode: "solr"},
    {name: "SML", mime: "text/x-sml", mode: "mllike", ext: ["sml", "sig", "fun", "smackspec"]},
    {name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"]},
    {name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"]},
    {name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"]},
    {name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"]},
    {name: "SQLite", mime: "text/x-sqlite", mode: "sql"},
    {name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"]},
    {name: "Stylus", mime: "text/x-styl", mode: "stylus", ext: ["styl"]},
    {name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"]},
    {name: "sTeX", mime: "text/x-stex", mode: "stex"},
    {name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx", "tex"], alias: ["tex"]},
    {name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v", "sv", "svh"]},
    {name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"]},
    {name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"]},
    {name: "TiddlyWiki ", mime: "text/x-tiddlywiki", mode: "tiddlywiki"},
    {name: "Tiki wiki", mime: "text/tiki", mode: "tiki"},
    {name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"]},
    {name: "Tornado", mime: "text/x-tornado", mode: "tornado"},
    {name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"]},
    {name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"]},
    {name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"]},
    {name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"]},
    {name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"]},
    {name: "TypeScript-JSX", mime: "text/typescript-jsx", mode: "jsx", ext: ["tsx"], alias: ["tsx"]},
    {name: "Twig", mime: "text/x-twig", mode: "twig"},
    {name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"]},
    {name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"]},
    {name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"]},
    {name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"]},
    {name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"]},
    {name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"]},
    {name: "Vue.js Component", mimes: ["script/x-vue", "text/x-vue"], mode: "vue", ext: ["vue"]},
    {name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd", "svg"], alias: ["rss", "wsdl", "xsd"]},
    {name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"]},
    {name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"]},
    {name: "YAML", mimes: ["text/x-yaml", "text/yaml"], mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"]},
    {name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"]},
    {name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"]},
    {name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"]},
    {name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"]}
  ];
  // Ensure all modes have a mime property for backwards compatibility
  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.mimes) info.mime = info.mimes[0];
  }

  CodeMirror.findModeByMIME = function(mime) {
    mime = mime.toLowerCase();
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.mime == mime) return info;
      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)
        if (info.mimes[j] == mime) return info;
    }
    if (/\+xml$/.test(mime)) return CodeMirror.findModeByMIME("application/xml")
    if (/\+json$/.test(mime)) return CodeMirror.findModeByMIME("application/json")
  };

  CodeMirror.findModeByExtension = function(ext) {
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.ext) for (var j = 0; j < info.ext.length; j++)
        if (info.ext[j] == ext) return info;
    }
  };

  CodeMirror.findModeByFileName = function(filename) {
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.file && info.file.test(filename)) return info;
    }
    var dot = filename.lastIndexOf(".");
    var ext = dot > -1 && filename.substring(dot + 1, filename.length);
    if (ext) return CodeMirror.findModeByExtension(ext);
  };

  CodeMirror.findModeByName = function(name) {
    name = name.toLowerCase();
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.name.toLowerCase() == name) return info;
      if (info.alias) for (var j = 0; j < info.alias.length; j++)
        if (info.alias[j].toLowerCase() == name) return info;
    }
  };
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/mode/xml/xml',["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

var htmlConfig = {
  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                    'track': true, 'wbr': true, 'menuitem': true},
  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                     'th': true, 'tr': true},
  contextGrabbers: {
    'dd': {'dd': true, 'dt': true},
    'dt': {'dd': true, 'dt': true},
    'li': {'li': true},
    'option': {'option': true, 'optgroup': true},
    'optgroup': {'optgroup': true},
    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
    'rp': {'rp': true, 'rt': true},
    'rt': {'rp': true, 'rt': true},
    'tbody': {'tbody': true, 'tfoot': true},
    'td': {'td': true, 'th': true},
    'tfoot': {'tbody': true},
    'th': {'td': true, 'th': true},
    'thead': {'tbody': true, 'tfoot': true},
    'tr': {'tr': true}
  },
  doNotIndent: {"pre": true},
  allowUnquoted: true,
  allowMissing: true,
  caseFold: true
}

var xmlConfig = {
  autoSelfClosers: {},
  implicitlyClosed: {},
  contextGrabbers: {},
  doNotIndent: {},
  allowUnquoted: false,
  allowMissing: false,
  allowMissingTagName: false,
  caseFold: false
}

CodeMirror.defineMode("xml", function(editorConf, config_) {
  var indentUnit = editorConf.indentUnit
  var config = {}
  var defaults = config_.htmlMode ? htmlConfig : xmlConfig
  for (var prop in defaults) config[prop] = defaults[prop]
  for (var prop in config_) config[prop] = config_[prop]

  // Return variables for tokenizers
  var type, setStyle;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "<") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
          else return null;
        } else if (stream.match("--")) {
          return chain(inBlock("comment", "-->"));
        } else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?>");
        return "meta";
      } else {
        type = stream.eat("/") ? "closeTag" : "openTag";
        state.tokenize = inTag;
        return "tag bracket";
      }
    } else if (ch == "&") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
      }
      return ok ? "atom" : "error";
    } else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }
  inText.isInText = true;

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
      state.tokenize = inText;
      type = ch == ">" ? "endTag" : "selfcloseTag";
      return "tag bracket";
    } else if (ch == "=") {
      type = "equals";
      return null;
    } else if (ch == "<") {
      state.tokenize = inText;
      state.state = baseState;
      state.tagName = state.tagStart = null;
      var next = state.tokenize(stream, state);
      return next ? next + " tag error" : "tag error";
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      state.stringStartCol = stream.column();
      return state.tokenize(stream, state);
    } else {
      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
      return "word";
    }
  }

  function inAttribute(quote) {
    var closure = function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
    closure.isInAttribute = true;
    return closure;
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    };
  }
  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "<") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == ">") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  function Context(state, tagName, startOfLine) {
    this.prev = state.context;
    this.tagName = tagName;
    this.indent = state.indented;
    this.startOfLine = startOfLine;
    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
      this.noIndent = true;
  }
  function popContext(state) {
    if (state.context) state.context = state.context.prev;
  }
  function maybePopContext(state, nextTagName) {
    var parentTagName;
    while (true) {
      if (!state.context) {
        return;
      }
      parentTagName = state.context.tagName;
      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext(state);
    }
  }

  function baseState(type, stream, state) {
    if (type == "openTag") {
      state.tagStart = stream.column();
      return tagNameState;
    } else if (type == "closeTag") {
      return closeTagNameState;
    } else {
      return baseState;
    }
  }
  function tagNameState(type, stream, state) {
    if (type == "word") {
      state.tagName = stream.current();
      setStyle = "tag";
      return attrState;
    } else if (config.allowMissingTagName && type == "endTag") {
      setStyle = "tag bracket";
      return attrState(type, stream, state);
    } else {
      setStyle = "error";
      return tagNameState;
    }
  }
  function closeTagNameState(type, stream, state) {
    if (type == "word") {
      var tagName = stream.current();
      if (state.context && state.context.tagName != tagName &&
          config.implicitlyClosed.hasOwnProperty(state.context.tagName))
        popContext(state);
      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
        setStyle = "tag";
        return closeState;
      } else {
        setStyle = "tag error";
        return closeStateErr;
      }
    } else if (config.allowMissingTagName && type == "endTag") {
      setStyle = "tag bracket";
      return closeState(type, stream, state);
    } else {
      setStyle = "error";
      return closeStateErr;
    }
  }

  function closeState(type, _stream, state) {
    if (type != "endTag") {
      setStyle = "error";
      return closeState;
    }
    popContext(state);
    return baseState;
  }
  function closeStateErr(type, stream, state) {
    setStyle = "error";
    return closeState(type, stream, state);
  }

  function attrState(type, _stream, state) {
    if (type == "word") {
      setStyle = "attribute";
      return attrEqState;
    } else if (type == "endTag" || type == "selfcloseTag") {
      var tagName = state.tagName, tagStart = state.tagStart;
      state.tagName = state.tagStart = null;
      if (type == "selfcloseTag" ||
          config.autoSelfClosers.hasOwnProperty(tagName)) {
        maybePopContext(state, tagName);
      } else {
        maybePopContext(state, tagName);
        state.context = new Context(state, tagName, tagStart == state.indented);
      }
      return baseState;
    }
    setStyle = "error";
    return attrState;
  }
  function attrEqState(type, stream, state) {
    if (type == "equals") return attrValueState;
    if (!config.allowMissing) setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrValueState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
    setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrContinuedState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    return attrState(type, stream, state);
  }

  return {
    startState: function(baseIndent) {
      var state = {tokenize: inText,
                   state: baseState,
                   indented: baseIndent || 0,
                   tagName: null, tagStart: null,
                   context: null}
      if (baseIndent != null) state.baseIndent = baseIndent
      return state
    },

    token: function(stream, state) {
      if (!state.tagName && stream.sol())
        state.indented = stream.indentation();

      if (stream.eatSpace()) return null;
      type = null;
      var style = state.tokenize(stream, state);
      if ((style || type) && style != "comment") {
        setStyle = null;
        state.state = state.state(type || style, stream, state);
        if (setStyle)
          style = setStyle == "error" ? style + " error" : setStyle;
      }
      return style;
    },

    indent: function(state, textAfter, fullLine) {
      var context = state.context;
      // Indent multi-line strings (e.g. css).
      if (state.tokenize.isInAttribute) {
        if (state.tagStart == state.indented)
          return state.stringStartCol + 1;
        else
          return state.indented + indentUnit;
      }
      if (context && context.noIndent) return CodeMirror.Pass;
      if (state.tokenize != inTag && state.tokenize != inText)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      // Indent the starts of attribute names.
      if (state.tagName) {
        if (config.multilineTagIndentPastTag !== false)
          return state.tagStart + state.tagName.length + 2;
        else
          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
      }
      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
      if (tagAfter && tagAfter[1]) { // Closing tag spotted
        while (context) {
          if (context.tagName == tagAfter[2]) {
            context = context.prev;
            break;
          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
            context = context.prev;
          } else {
            break;
          }
        }
      } else if (tagAfter) { // Opening tag spotted
        while (context) {
          var grabbers = config.contextGrabbers[context.tagName];
          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
            context = context.prev;
          else
            break;
        }
      }
      while (context && context.prev && !context.startOfLine)
        context = context.prev;
      if (context) return context.indent + indentUnit;
      else return state.baseIndent || 0;
    },

    electricInput: /<\/[\s\w:]+>$/,
    blockCommentStart: "<!--",
    blockCommentEnd: "-->",

    configuration: config.htmlMode ? "html" : "xml",
    helperType: config.htmlMode ? "html" : "xml",

    skipAttribute: function(state) {
      if (state.state == attrValueState)
        state.state = attrState
    }
  };
});

CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

});

/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.5';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Gets the value at `key`, unless `key` is "__proto__".
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function safeGet(object, key) {
    return key == '__proto__'
      ? undefined
      : object[key];
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });

        return result;
      }

      if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });

        return result;
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        if (isObject(srcValue)) {
          stack || (stack = new Stack);
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array == null ? 0 : array.length,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimEnd, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = (lodashFunc.name + ''),
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define('lodash/lodash',[],function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));

/**
 * @license text 2.0.15 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/text/LICENSE
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('text/text',['module'], function (module) {
    'use strict';

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    function useDefault(value, defaultValue) {
        return value === undefined || value === '' ? defaultValue : value;
    }

    //Allow for default ports for http and https.
    function isSamePort(protocol1, port1, protocol2, port2) {
        if (port1 === port2) {
            return true;
        } else if (protocol1 === protocol2) {
            if (protocol1 === 'http') {
                return useDefault(port1, '80') === useDefault(port2, '80');
            } else if (protocol1 === 'https') {
                return useDefault(port1, '443') === useDefault(port2, '443');
            }
        }
        return false;
    }

    text = {
        version: '2.0.15',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.lastIndexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || isSamePort(uProtocol, uPort, protocol, port));
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config && config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config && config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node &&
            !process.versions['node-webkit'] &&
            !process.versions['atom-shell'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file[0] === '\uFEFF') {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                if (errback) {
                    errback(e);
                }
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status || 0;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        if (errback) {
                            errback(err);
                        }
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes;
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});

define('aurelia-binding',['aurelia-binding/dist/commonjs/aurelia-binding'],function(m){return m;});
define('aurelia-binding.js',['aurelia-binding'],function(m){return m;});
define('aurelia-binding/dist/commonjs/aurelia-binding.js',['aurelia-binding/dist/commonjs/aurelia-binding'],function(m){return m;});
define('aurelia-bootstrapper',['aurelia-bootstrapper/dist/commonjs/aurelia-bootstrapper'],function(m){return m;});
define('aurelia-bootstrapper.js',['aurelia-bootstrapper'],function(m){return m;});
define('aurelia-bootstrapper/dist/commonjs/aurelia-bootstrapper.js',['aurelia-bootstrapper/dist/commonjs/aurelia-bootstrapper'],function(m){return m;});
define('aurelia-dependency-injection',['aurelia-dependency-injection/dist/commonjs/aurelia-dependency-injection'],function(m){return m;});
define('aurelia-dependency-injection.js',['aurelia-dependency-injection'],function(m){return m;});
define('aurelia-dependency-injection/dist/commonjs/aurelia-dependency-injection.js',['aurelia-dependency-injection/dist/commonjs/aurelia-dependency-injection'],function(m){return m;});
define('aurelia-event-aggregator',['aurelia-event-aggregator/dist/commonjs/aurelia-event-aggregator'],function(m){return m;});
define('aurelia-event-aggregator.js',['aurelia-event-aggregator'],function(m){return m;});
define('aurelia-event-aggregator/dist/commonjs/aurelia-event-aggregator.js',['aurelia-event-aggregator/dist/commonjs/aurelia-event-aggregator'],function(m){return m;});
define('aurelia-framework',['aurelia-framework/dist/commonjs/aurelia-framework'],function(m){return m;});
define('aurelia-framework.js',['aurelia-framework'],function(m){return m;});
define('aurelia-framework/dist/commonjs/aurelia-framework.js',['aurelia-framework/dist/commonjs/aurelia-framework'],function(m){return m;});
define('aurelia-history',['aurelia-history/dist/commonjs/aurelia-history'],function(m){return m;});
define('aurelia-history-browser',['aurelia-history-browser/dist/commonjs/aurelia-history-browser'],function(m){return m;});
define('aurelia-history-browser.js',['aurelia-history-browser'],function(m){return m;});
define('aurelia-history-browser/dist/commonjs/aurelia-history-browser.js',['aurelia-history-browser/dist/commonjs/aurelia-history-browser'],function(m){return m;});
define('aurelia-history.js',['aurelia-history'],function(m){return m;});
define('aurelia-history/dist/commonjs/aurelia-history.js',['aurelia-history/dist/commonjs/aurelia-history'],function(m){return m;});
define('aurelia-loader',['aurelia-loader/dist/commonjs/aurelia-loader'],function(m){return m;});
define('aurelia-loader-default',['aurelia-loader-default/dist/commonjs/aurelia-loader-default'],function(m){return m;});
define('aurelia-loader-default.js',['aurelia-loader-default'],function(m){return m;});
define('aurelia-loader-default/dist/commonjs/aurelia-loader-default.js',['aurelia-loader-default/dist/commonjs/aurelia-loader-default'],function(m){return m;});
define('aurelia-loader.js',['aurelia-loader'],function(m){return m;});
define('aurelia-loader/dist/commonjs/aurelia-loader.js',['aurelia-loader/dist/commonjs/aurelia-loader'],function(m){return m;});
define('aurelia-logging',['aurelia-logging/dist/commonjs/aurelia-logging'],function(m){return m;});
define('aurelia-logging-console',['aurelia-logging-console/dist/commonjs/aurelia-logging-console'],function(m){return m;});
define('aurelia-logging-console.js',['aurelia-logging-console'],function(m){return m;});
define('aurelia-logging-console/dist/commonjs/aurelia-logging-console.js',['aurelia-logging-console/dist/commonjs/aurelia-logging-console'],function(m){return m;});
define('aurelia-logging.js',['aurelia-logging'],function(m){return m;});
define('aurelia-logging/dist/commonjs/aurelia-logging.js',['aurelia-logging/dist/commonjs/aurelia-logging'],function(m){return m;});
define('aurelia-metadata',['aurelia-metadata/dist/commonjs/aurelia-metadata'],function(m){return m;});
define('aurelia-metadata.js',['aurelia-metadata'],function(m){return m;});
define('aurelia-metadata/dist/commonjs/aurelia-metadata.js',['aurelia-metadata/dist/commonjs/aurelia-metadata'],function(m){return m;});
define('aurelia-pal',['aurelia-pal/dist/commonjs/aurelia-pal'],function(m){return m;});
define('aurelia-pal-browser',['aurelia-pal-browser/dist/commonjs/aurelia-pal-browser'],function(m){return m;});
define('aurelia-pal-browser.js',['aurelia-pal-browser'],function(m){return m;});
define('aurelia-pal-browser/dist/commonjs/aurelia-pal-browser.js',['aurelia-pal-browser/dist/commonjs/aurelia-pal-browser'],function(m){return m;});
define('aurelia-pal.js',['aurelia-pal'],function(m){return m;});
define('aurelia-pal/dist/commonjs/aurelia-pal.js',['aurelia-pal/dist/commonjs/aurelia-pal'],function(m){return m;});
define('aurelia-path',['aurelia-path/dist/commonjs/aurelia-path'],function(m){return m;});
define('aurelia-path.js',['aurelia-path'],function(m){return m;});
define('aurelia-path/dist/commonjs/aurelia-path.js',['aurelia-path/dist/commonjs/aurelia-path'],function(m){return m;});
define('aurelia-polyfills',['aurelia-polyfills/dist/commonjs/aurelia-polyfills'],function(m){return m;});
define('aurelia-polyfills.js',['aurelia-polyfills'],function(m){return m;});
define('aurelia-polyfills/dist/commonjs/aurelia-polyfills.js',['aurelia-polyfills/dist/commonjs/aurelia-polyfills'],function(m){return m;});
define('aurelia-route-recognizer',['aurelia-route-recognizer/dist/commonjs/aurelia-route-recognizer'],function(m){return m;});
define('aurelia-route-recognizer.js',['aurelia-route-recognizer'],function(m){return m;});
define('aurelia-route-recognizer/dist/commonjs/aurelia-route-recognizer.js',['aurelia-route-recognizer/dist/commonjs/aurelia-route-recognizer'],function(m){return m;});
define('aurelia-router',['aurelia-router/dist/commonjs/aurelia-router'],function(m){return m;});
define('aurelia-router.js',['aurelia-router'],function(m){return m;});
define('aurelia-router/dist/commonjs/aurelia-router.js',['aurelia-router/dist/commonjs/aurelia-router'],function(m){return m;});
define('aurelia-task-queue',['aurelia-task-queue/dist/commonjs/aurelia-task-queue'],function(m){return m;});
define('aurelia-task-queue.js',['aurelia-task-queue'],function(m){return m;});
define('aurelia-task-queue/dist/commonjs/aurelia-task-queue.js',['aurelia-task-queue/dist/commonjs/aurelia-task-queue'],function(m){return m;});
define('aurelia-templating',['aurelia-templating/dist/commonjs/aurelia-templating'],function(m){return m;});
define('aurelia-templating-binding',['aurelia-templating-binding/dist/commonjs/aurelia-templating-binding'],function(m){return m;});
define('aurelia-templating-binding.js',['aurelia-templating-binding'],function(m){return m;});
define('aurelia-templating-binding/dist/commonjs/aurelia-templating-binding.js',['aurelia-templating-binding/dist/commonjs/aurelia-templating-binding'],function(m){return m;});
define('aurelia-templating-resources',['aurelia-templating-resources/dist/commonjs/aurelia-templating-resources'],function(m){return m;});
define('aurelia-templating-resources.js',['aurelia-templating-resources'],function(m){return m;});
define('aurelia-templating-resources/abstract-repeater',['aurelia-templating-resources/dist/commonjs/abstract-repeater'],function(m){return m;});
define('aurelia-templating-resources/abstract-repeater.js',['aurelia-templating-resources/abstract-repeater'],function(m){return m;});
define('aurelia-templating-resources/analyze-view-factory',['aurelia-templating-resources/dist/commonjs/analyze-view-factory'],function(m){return m;});
define('aurelia-templating-resources/analyze-view-factory.js',['aurelia-templating-resources/analyze-view-factory'],function(m){return m;});
define('aurelia-templating-resources/array-repeat-strategy',['aurelia-templating-resources/dist/commonjs/array-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/array-repeat-strategy.js',['aurelia-templating-resources/array-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/attr-binding-behavior',['aurelia-templating-resources/dist/commonjs/attr-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/attr-binding-behavior.js',['aurelia-templating-resources/attr-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/aurelia-hide-style',['aurelia-templating-resources/dist/commonjs/aurelia-hide-style'],function(m){return m;});
define('aurelia-templating-resources/aurelia-hide-style.js',['aurelia-templating-resources/aurelia-hide-style'],function(m){return m;});
define('aurelia-templating-resources/aurelia-templating-resources',['aurelia-templating-resources/dist/commonjs/aurelia-templating-resources'],function(m){return m;});
define('aurelia-templating-resources/aurelia-templating-resources.js',['aurelia-templating-resources/aurelia-templating-resources'],function(m){return m;});
define('aurelia-templating-resources/binding-mode-behaviors',['aurelia-templating-resources/dist/commonjs/binding-mode-behaviors'],function(m){return m;});
define('aurelia-templating-resources/binding-mode-behaviors.js',['aurelia-templating-resources/binding-mode-behaviors'],function(m){return m;});
define('aurelia-templating-resources/binding-signaler',['aurelia-templating-resources/dist/commonjs/binding-signaler'],function(m){return m;});
define('aurelia-templating-resources/binding-signaler.js',['aurelia-templating-resources/binding-signaler'],function(m){return m;});
define('aurelia-templating-resources/compose',['aurelia-templating-resources/dist/commonjs/compose'],function(m){return m;});
define('aurelia-templating-resources/compose.js',['aurelia-templating-resources/compose'],function(m){return m;});
define('aurelia-templating-resources/css-resource',['aurelia-templating-resources/dist/commonjs/css-resource'],function(m){return m;});
define('aurelia-templating-resources/css-resource.js',['aurelia-templating-resources/css-resource'],function(m){return m;});
define('aurelia-templating-resources/debounce-binding-behavior',['aurelia-templating-resources/dist/commonjs/debounce-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/debounce-binding-behavior.js',['aurelia-templating-resources/debounce-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/abstract-repeater.js',['aurelia-templating-resources/dist/commonjs/abstract-repeater'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/analyze-view-factory.js',['aurelia-templating-resources/dist/commonjs/analyze-view-factory'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/array-repeat-strategy.js',['aurelia-templating-resources/dist/commonjs/array-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/attr-binding-behavior.js',['aurelia-templating-resources/dist/commonjs/attr-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/aurelia-hide-style.js',['aurelia-templating-resources/dist/commonjs/aurelia-hide-style'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/aurelia-templating-resources.js',['aurelia-templating-resources/dist/commonjs/aurelia-templating-resources'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/binding-mode-behaviors.js',['aurelia-templating-resources/dist/commonjs/binding-mode-behaviors'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/binding-signaler.js',['aurelia-templating-resources/dist/commonjs/binding-signaler'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/compose.js',['aurelia-templating-resources/dist/commonjs/compose'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/css-resource.js',['aurelia-templating-resources/dist/commonjs/css-resource'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/debounce-binding-behavior.js',['aurelia-templating-resources/dist/commonjs/debounce-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/dynamic-element.js',['aurelia-templating-resources/dist/commonjs/dynamic-element'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/else.js',['aurelia-templating-resources/dist/commonjs/else'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/focus.js',['aurelia-templating-resources/dist/commonjs/focus'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/hide.js',['aurelia-templating-resources/dist/commonjs/hide'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/html-resource-plugin.js',['aurelia-templating-resources/dist/commonjs/html-resource-plugin'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/html-sanitizer.js',['aurelia-templating-resources/dist/commonjs/html-sanitizer'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/if-core.js',['aurelia-templating-resources/dist/commonjs/if-core'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/if.js',['aurelia-templating-resources/dist/commonjs/if'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/map-repeat-strategy.js',['aurelia-templating-resources/dist/commonjs/map-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/null-repeat-strategy.js',['aurelia-templating-resources/dist/commonjs/null-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/number-repeat-strategy.js',['aurelia-templating-resources/dist/commonjs/number-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/repeat-strategy-locator.js',['aurelia-templating-resources/dist/commonjs/repeat-strategy-locator'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/repeat-utilities.js',['aurelia-templating-resources/dist/commonjs/repeat-utilities'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/repeat.js',['aurelia-templating-resources/dist/commonjs/repeat'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/replaceable.js',['aurelia-templating-resources/dist/commonjs/replaceable'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/sanitize-html.js',['aurelia-templating-resources/dist/commonjs/sanitize-html'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/self-binding-behavior.js',['aurelia-templating-resources/dist/commonjs/self-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/set-repeat-strategy.js',['aurelia-templating-resources/dist/commonjs/set-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/show.js',['aurelia-templating-resources/dist/commonjs/show'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/signal-binding-behavior.js',['aurelia-templating-resources/dist/commonjs/signal-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/throttle-binding-behavior.js',['aurelia-templating-resources/dist/commonjs/throttle-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/update-trigger-binding-behavior.js',['aurelia-templating-resources/dist/commonjs/update-trigger-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/with.js',['aurelia-templating-resources/dist/commonjs/with'],function(m){return m;});
define('aurelia-templating-resources/dynamic-element',['aurelia-templating-resources/dist/commonjs/dynamic-element'],function(m){return m;});
define('aurelia-templating-resources/dynamic-element.js',['aurelia-templating-resources/dynamic-element'],function(m){return m;});
define('aurelia-templating-resources/else',['aurelia-templating-resources/dist/commonjs/else'],function(m){return m;});
define('aurelia-templating-resources/else.js',['aurelia-templating-resources/else'],function(m){return m;});
define('aurelia-templating-resources/focus',['aurelia-templating-resources/dist/commonjs/focus'],function(m){return m;});
define('aurelia-templating-resources/focus.js',['aurelia-templating-resources/focus'],function(m){return m;});
define('aurelia-templating-resources/hide',['aurelia-templating-resources/dist/commonjs/hide'],function(m){return m;});
define('aurelia-templating-resources/hide.js',['aurelia-templating-resources/hide'],function(m){return m;});
define('aurelia-templating-resources/html-resource-plugin',['aurelia-templating-resources/dist/commonjs/html-resource-plugin'],function(m){return m;});
define('aurelia-templating-resources/html-resource-plugin.js',['aurelia-templating-resources/html-resource-plugin'],function(m){return m;});
define('aurelia-templating-resources/html-sanitizer',['aurelia-templating-resources/dist/commonjs/html-sanitizer'],function(m){return m;});
define('aurelia-templating-resources/html-sanitizer.js',['aurelia-templating-resources/html-sanitizer'],function(m){return m;});
define('aurelia-templating-resources/if',['aurelia-templating-resources/dist/commonjs/if'],function(m){return m;});
define('aurelia-templating-resources/if-core',['aurelia-templating-resources/dist/commonjs/if-core'],function(m){return m;});
define('aurelia-templating-resources/if-core.js',['aurelia-templating-resources/if-core'],function(m){return m;});
define('aurelia-templating-resources/if.js',['aurelia-templating-resources/if'],function(m){return m;});
define('aurelia-templating-resources/map-repeat-strategy',['aurelia-templating-resources/dist/commonjs/map-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/map-repeat-strategy.js',['aurelia-templating-resources/map-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/null-repeat-strategy',['aurelia-templating-resources/dist/commonjs/null-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/null-repeat-strategy.js',['aurelia-templating-resources/null-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/number-repeat-strategy',['aurelia-templating-resources/dist/commonjs/number-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/number-repeat-strategy.js',['aurelia-templating-resources/number-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/repeat',['aurelia-templating-resources/dist/commonjs/repeat'],function(m){return m;});
define('aurelia-templating-resources/repeat-strategy-locator',['aurelia-templating-resources/dist/commonjs/repeat-strategy-locator'],function(m){return m;});
define('aurelia-templating-resources/repeat-strategy-locator.js',['aurelia-templating-resources/repeat-strategy-locator'],function(m){return m;});
define('aurelia-templating-resources/repeat-utilities',['aurelia-templating-resources/dist/commonjs/repeat-utilities'],function(m){return m;});
define('aurelia-templating-resources/repeat-utilities.js',['aurelia-templating-resources/repeat-utilities'],function(m){return m;});
define('aurelia-templating-resources/repeat.js',['aurelia-templating-resources/repeat'],function(m){return m;});
define('aurelia-templating-resources/replaceable',['aurelia-templating-resources/dist/commonjs/replaceable'],function(m){return m;});
define('aurelia-templating-resources/replaceable.js',['aurelia-templating-resources/replaceable'],function(m){return m;});
define('aurelia-templating-resources/sanitize-html',['aurelia-templating-resources/dist/commonjs/sanitize-html'],function(m){return m;});
define('aurelia-templating-resources/sanitize-html.js',['aurelia-templating-resources/sanitize-html'],function(m){return m;});
define('aurelia-templating-resources/self-binding-behavior',['aurelia-templating-resources/dist/commonjs/self-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/self-binding-behavior.js',['aurelia-templating-resources/self-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/set-repeat-strategy',['aurelia-templating-resources/dist/commonjs/set-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/set-repeat-strategy.js',['aurelia-templating-resources/set-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/show',['aurelia-templating-resources/dist/commonjs/show'],function(m){return m;});
define('aurelia-templating-resources/show.js',['aurelia-templating-resources/show'],function(m){return m;});
define('aurelia-templating-resources/signal-binding-behavior',['aurelia-templating-resources/dist/commonjs/signal-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/signal-binding-behavior.js',['aurelia-templating-resources/signal-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/throttle-binding-behavior',['aurelia-templating-resources/dist/commonjs/throttle-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/throttle-binding-behavior.js',['aurelia-templating-resources/throttle-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/update-trigger-binding-behavior',['aurelia-templating-resources/dist/commonjs/update-trigger-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/update-trigger-binding-behavior.js',['aurelia-templating-resources/update-trigger-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/with',['aurelia-templating-resources/dist/commonjs/with'],function(m){return m;});
define('aurelia-templating-resources/with.js',['aurelia-templating-resources/with'],function(m){return m;});
define('aurelia-templating-router',['aurelia-templating-router/dist/commonjs/aurelia-templating-router'],function(m){return m;});
define('aurelia-templating-router.js',['aurelia-templating-router'],function(m){return m;});
define('aurelia-templating-router/aurelia-templating-router',['aurelia-templating-router/dist/commonjs/aurelia-templating-router'],function(m){return m;});
define('aurelia-templating-router/aurelia-templating-router.js',['aurelia-templating-router/aurelia-templating-router'],function(m){return m;});
define('aurelia-templating-router/dist/commonjs/aurelia-templating-router.js',['aurelia-templating-router/dist/commonjs/aurelia-templating-router'],function(m){return m;});
define('aurelia-templating-router/dist/commonjs/route-href.js',['aurelia-templating-router/dist/commonjs/route-href'],function(m){return m;});
define('aurelia-templating-router/dist/commonjs/route-loader.js',['aurelia-templating-router/dist/commonjs/route-loader'],function(m){return m;});
define('aurelia-templating-router/dist/commonjs/router-view.js',['aurelia-templating-router/dist/commonjs/router-view'],function(m){return m;});
define('aurelia-templating-router/route-href',['aurelia-templating-router/dist/commonjs/route-href'],function(m){return m;});
define('aurelia-templating-router/route-href.js',['aurelia-templating-router/route-href'],function(m){return m;});
define('aurelia-templating-router/route-loader',['aurelia-templating-router/dist/commonjs/route-loader'],function(m){return m;});
define('aurelia-templating-router/route-loader.js',['aurelia-templating-router/route-loader'],function(m){return m;});
define('aurelia-templating-router/router-view',['aurelia-templating-router/dist/commonjs/router-view'],function(m){return m;});
define('aurelia-templating-router/router-view.js',['aurelia-templating-router/router-view'],function(m){return m;});
define('aurelia-templating.js',['aurelia-templating'],function(m){return m;});
define('aurelia-templating/dist/commonjs/aurelia-templating.js',['aurelia-templating/dist/commonjs/aurelia-templating'],function(m){return m;});
define('aurelia-testing',['aurelia-testing/dist/commonjs/aurelia-testing'],function(m){return m;});
define('aurelia-testing.js',['aurelia-testing'],function(m){return m;});
define('aurelia-testing/aurelia-testing',['aurelia-testing/dist/commonjs/aurelia-testing'],function(m){return m;});
define('aurelia-testing/aurelia-testing.js',['aurelia-testing/aurelia-testing'],function(m){return m;});
define('aurelia-testing/compile-spy',['aurelia-testing/dist/commonjs/compile-spy'],function(m){return m;});
define('aurelia-testing/compile-spy.js',['aurelia-testing/compile-spy'],function(m){return m;});
define('aurelia-testing/component-tester',['aurelia-testing/dist/commonjs/component-tester'],function(m){return m;});
define('aurelia-testing/component-tester.js',['aurelia-testing/component-tester'],function(m){return m;});
define('aurelia-testing/dist/commonjs/aurelia-testing.js',['aurelia-testing/dist/commonjs/aurelia-testing'],function(m){return m;});
define('aurelia-testing/dist/commonjs/compile-spy.js',['aurelia-testing/dist/commonjs/compile-spy'],function(m){return m;});
define('aurelia-testing/dist/commonjs/component-tester.js',['aurelia-testing/dist/commonjs/component-tester'],function(m){return m;});
define('aurelia-testing/dist/commonjs/view-spy.js',['aurelia-testing/dist/commonjs/view-spy'],function(m){return m;});
define('aurelia-testing/dist/commonjs/wait.js',['aurelia-testing/dist/commonjs/wait'],function(m){return m;});
define('aurelia-testing/view-spy',['aurelia-testing/dist/commonjs/view-spy'],function(m){return m;});
define('aurelia-testing/view-spy.js',['aurelia-testing/view-spy'],function(m){return m;});
define('aurelia-testing/wait',['aurelia-testing/dist/commonjs/wait'],function(m){return m;});
define('aurelia-testing/wait.js',['aurelia-testing/wait'],function(m){return m;});
define('bcx-aurelia-dnd',['bcx-aurelia-dnd/dist/index'],function(m){return m;});
define('bcx-aurelia-dnd.js',['bcx-aurelia-dnd'],function(m){return m;});
define('bcx-aurelia-dnd/dist/index.js',['bcx-aurelia-dnd/dist/index'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat',['bcx-aurelia-reorderable-repeat/dist/index'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat.js',['bcx-aurelia-reorderable-repeat'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/index.js',['bcx-aurelia-reorderable-repeat/dist/index'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/reorderable-after-reordering.js',['bcx-aurelia-reorderable-repeat/dist/reorderable-after-reordering'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/reorderable-direction.js',['bcx-aurelia-reorderable-repeat/dist/reorderable-direction'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-handler-selector.js',['bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-handler-selector'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-preview.js',['bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-preview'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/reorderable-repeat-strategy-locator.js',['bcx-aurelia-reorderable-repeat/dist/reorderable-repeat-strategy-locator'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/reorderable-repeat.js',['bcx-aurelia-reorderable-repeat/dist/reorderable-repeat'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/simple-array-repeat-strategy.js',['bcx-aurelia-reorderable-repeat/dist/simple-array-repeat-strategy'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/index',['bcx-aurelia-reorderable-repeat/dist/index'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/index.js',['bcx-aurelia-reorderable-repeat/index'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-after-reordering',['bcx-aurelia-reorderable-repeat/dist/reorderable-after-reordering'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-after-reordering.js',['bcx-aurelia-reorderable-repeat/reorderable-after-reordering'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-direction',['bcx-aurelia-reorderable-repeat/dist/reorderable-direction'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-direction.js',['bcx-aurelia-reorderable-repeat/reorderable-direction'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-dnd-handler-selector',['bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-handler-selector'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-dnd-handler-selector.js',['bcx-aurelia-reorderable-repeat/reorderable-dnd-handler-selector'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-dnd-preview',['bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-preview'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-dnd-preview.js',['bcx-aurelia-reorderable-repeat/reorderable-dnd-preview'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-repeat',['bcx-aurelia-reorderable-repeat/dist/reorderable-repeat'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-repeat-strategy-locator',['bcx-aurelia-reorderable-repeat/dist/reorderable-repeat-strategy-locator'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-repeat-strategy-locator.js',['bcx-aurelia-reorderable-repeat/reorderable-repeat-strategy-locator'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-repeat.js',['bcx-aurelia-reorderable-repeat/reorderable-repeat'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/simple-array-repeat-strategy',['bcx-aurelia-reorderable-repeat/dist/simple-array-repeat-strategy'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/simple-array-repeat-strategy.js',['bcx-aurelia-reorderable-repeat/simple-array-repeat-strategy'],function(m){return m;});
define('bcx-doc-base',['bcx-doc-base/dist/index'],function(m){return m;});
define('bcx-doc-base.js',['bcx-doc-base'],function(m){return m;});
define('bcx-doc-base/binding-behaviors/left-click',['bcx-doc-base/dist/binding-behaviors/left-click'],function(m){return m;});
define('bcx-doc-base/binding-behaviors/left-click.js',['bcx-doc-base/binding-behaviors/left-click'],function(m){return m;});
define('text!bcx-doc-base/css/doc.css',['text!bcx-doc-base/dist/css/doc.css'],function(m){return m;});
define('bcx-doc-base/dist/binding-behaviors/left-click.js',['bcx-doc-base/dist/binding-behaviors/left-click'],function(m){return m;});
define('bcx-doc-base/dist/elements/bcx-doc-nav.js',['bcx-doc-base/dist/elements/bcx-doc-nav'],function(m){return m;});
define('bcx-doc-base/dist/elements/code-viewer.js',['bcx-doc-base/dist/elements/code-viewer'],function(m){return m;});
define('bcx-doc-base/dist/elements/display-source.js',['bcx-doc-base/dist/elements/display-source'],function(m){return m;});
define('bcx-doc-base/dist/elements/display-sources.js',['bcx-doc-base/dist/elements/display-sources'],function(m){return m;});
define('bcx-doc-base/dist/index.js',['bcx-doc-base/dist/index'],function(m){return m;});
define('bcx-doc-base/elements/bcx-doc-nav',['bcx-doc-base/dist/elements/bcx-doc-nav'],function(m){return m;});
define('text!bcx-doc-base/elements/bcx-doc-nav.html',['text!bcx-doc-base/dist/elements/bcx-doc-nav.html'],function(m){return m;});
define('bcx-doc-base/elements/bcx-doc-nav.js',['bcx-doc-base/elements/bcx-doc-nav'],function(m){return m;});
define('bcx-doc-base/elements/code-viewer',['bcx-doc-base/dist/elements/code-viewer'],function(m){return m;});
define('text!bcx-doc-base/elements/code-viewer.css',['text!bcx-doc-base/dist/elements/code-viewer.css'],function(m){return m;});
define('text!bcx-doc-base/elements/code-viewer.html',['text!bcx-doc-base/dist/elements/code-viewer.html'],function(m){return m;});
define('bcx-doc-base/elements/code-viewer.js',['bcx-doc-base/elements/code-viewer'],function(m){return m;});
define('bcx-doc-base/elements/display-source',['bcx-doc-base/dist/elements/display-source'],function(m){return m;});
define('text!bcx-doc-base/elements/display-source.html',['text!bcx-doc-base/dist/elements/display-source.html'],function(m){return m;});
define('bcx-doc-base/elements/display-source.js',['bcx-doc-base/elements/display-source'],function(m){return m;});
define('bcx-doc-base/elements/display-sources',['bcx-doc-base/dist/elements/display-sources'],function(m){return m;});
define('text!bcx-doc-base/elements/display-sources.html',['text!bcx-doc-base/dist/elements/display-sources.html'],function(m){return m;});
define('bcx-doc-base/elements/display-sources.js',['bcx-doc-base/elements/display-sources'],function(m){return m;});
define('bcx-doc-base/index',['bcx-doc-base/dist/index'],function(m){return m;});
define('bcx-doc-base/index.js',['bcx-doc-base/index'],function(m){return m;});
define('codemirror',['codemirror/lib/codemirror'],function(m){return m;});
define('codemirror.js',['codemirror'],function(m){return m;});
define('codemirror/addon/display/fullscreen.js',['codemirror/addon/display/fullscreen'],function(m){return m;});
define('codemirror/lib/codemirror.js',['codemirror/lib/codemirror'],function(m){return m;});
define('codemirror/mode/css/css.js',['codemirror/mode/css/css'],function(m){return m;});
define('codemirror/mode/htmlmixed/htmlmixed.js',['codemirror/mode/htmlmixed/htmlmixed'],function(m){return m;});
define('codemirror/mode/javascript/javascript.js',['codemirror/mode/javascript/javascript'],function(m){return m;});
define('codemirror/mode/markdown/markdown.js',['codemirror/mode/markdown/markdown'],function(m){return m;});
define('codemirror/mode/meta.js',['codemirror/mode/meta'],function(m){return m;});
define('codemirror/mode/xml/xml.js',['codemirror/mode/xml/xml'],function(m){return m;});
define('jquery',['jquery/dist/jquery'],function(m){return m;});
define('jquery.js',['jquery'],function(m){return m;});
define('jquery/dist/jquery.js',['jquery/dist/jquery'],function(m){return m;});
define('lodash',['lodash/lodash'],function(m){return m;});
define('lodash.js',['lodash'],function(m){return m;});
define('lodash/lodash.js',['lodash/lodash'],function(m){return m;});
define('text',['text/text'],function(m){return m;});
define('text.js',['text'],function(m){return m;});
define('text/text.js',['text/text'],function(m){return m;});
function _aureliaConfigureModuleLoader(){requirejs.config({"baseUrl":"src","paths":{"root":"src","resources":"resources","elements":"resources/elements","attributes":"resources/attributes","valueConverters":"resources/value-converters","bindingBehaviors":"resources/binding-behaviors","app-bundle":"../scripts/app-bundle"},"packages":[],"stubModules":[],"shim":{},"bundles":{"app-bundle":["app","text!app.html","app.js","environment","environment.js","examples/e1-simple-move-step-1/box","text!examples/e1-simple-move-step-1/box.css","text!examples/e1-simple-move-step-1/box.html","examples/e1-simple-move-step-1/box.js","examples/e1-simple-move-step-1/container","text!examples/e1-simple-move-step-1/container.css","text!examples/e1-simple-move-step-1/container.html","examples/e1-simple-move-step-1/container.js","examples/e1-simple-move-step-1/index","text!examples/e1-simple-move-step-1/index.html","examples/e1-simple-move-step-1/index.js","examples/e1-simple-move-step-2/box","text!examples/e1-simple-move-step-2/box.css","text!examples/e1-simple-move-step-2/box.html","examples/e1-simple-move-step-2/box.js","examples/e1-simple-move-step-2/container","text!examples/e1-simple-move-step-2/container.css","text!examples/e1-simple-move-step-2/container.html","examples/e1-simple-move-step-2/container.js","examples/e1-simple-move-step-2/index","text!examples/e1-simple-move-step-2/index.html","examples/e1-simple-move-step-2/index.js","examples/e1-simple-move/box","text!examples/e1-simple-move/box.css","text!examples/e1-simple-move/box.html","examples/e1-simple-move/box.js","examples/e1-simple-move/container","text!examples/e1-simple-move/container.css","text!examples/e1-simple-move/container.html","examples/e1-simple-move/container.js","examples/e1-simple-move/index","text!examples/e1-simple-move/index.html","examples/e1-simple-move/index.js","examples/e2-simple-move-hover/box","text!examples/e2-simple-move-hover/box.css","text!examples/e2-simple-move-hover/box.html","examples/e2-simple-move-hover/box.js","examples/e2-simple-move-hover/container","text!examples/e2-simple-move-hover/container.css","text!examples/e2-simple-move-hover/container.html","examples/e2-simple-move-hover/container.js","examples/e2-simple-move-hover/index","text!examples/e2-simple-move-hover/index.html","examples/e2-simple-move-hover/index.js","examples/e2-simple-move-hover/test","examples/e2-simple-move-hover/test.js","examples/e3-customise-preview/add-box","text!examples/e3-customise-preview/add-box.html","examples/e3-customise-preview/add-box.js","examples/e3-customise-preview/add-money","text!examples/e3-customise-preview/add-money.css","text!examples/e3-customise-preview/add-money.html","examples/e3-customise-preview/add-money.js","examples/e3-customise-preview/box","text!examples/e3-customise-preview/box.css","text!examples/e3-customise-preview/box.html","examples/e3-customise-preview/box.js","examples/e3-customise-preview/container","text!examples/e3-customise-preview/container.css","text!examples/e3-customise-preview/container.html","examples/e3-customise-preview/container.js","examples/e3-customise-preview/index","text!examples/e3-customise-preview/index.html","examples/e3-customise-preview/index.js","text!examples/e3-customise-preview/target-effect.css","examples/e4-handler-move/box","text!examples/e4-handler-move/box.css","text!examples/e4-handler-move/box.html","examples/e4-handler-move/box.js","examples/e4-handler-move/container","text!examples/e4-handler-move/container.css","text!examples/e4-handler-move/container.html","examples/e4-handler-move/container.js","examples/e4-handler-move/index","text!examples/e4-handler-move/index.html","examples/e4-handler-move/index.js","examples/e5-draw/canvas-container","text!examples/e5-draw/canvas-container.html","examples/e5-draw/canvas-container.js","examples/e5-draw/index","text!examples/e5-draw/index.html","examples/e5-draw/index.js","examples/e6-reorder-list/index","text!examples/e6-reorder-list/index.html","examples/e6-reorder-list/index.js","examples/e6-reorder-list/item","text!examples/e6-reorder-list/item.css","text!examples/e6-reorder-list/item.html","examples/e6-reorder-list/item.js","examples/e6-reorder-list/list-container","text!examples/e6-reorder-list/list-container.css","text!examples/e6-reorder-list/list-container.html","examples/e6-reorder-list/list-container.js","examples/er1-reorderable-repeat/index","text!examples/er1-reorderable-repeat/index.html","examples/er1-reorderable-repeat/index.js","examples/er1-reorderable-repeat/list-container","text!examples/er1-reorderable-repeat/list-container.css","text!examples/er1-reorderable-repeat/list-container.html","examples/er1-reorderable-repeat/list-container.js","examples/er1-reorderable-repeat/list-container2","text!examples/er1-reorderable-repeat/list-container2.html","examples/er1-reorderable-repeat/list-container2.js","examples/er2-reorderable-repeat-customise-style/index","text!examples/er2-reorderable-repeat-customise-style/index.html","examples/er2-reorderable-repeat-customise-style/index.js","examples/er2-reorderable-repeat-customise-style/list-container","text!examples/er2-reorderable-repeat-customise-style/list-container.css","text!examples/er2-reorderable-repeat-customise-style/list-container.html","examples/er2-reorderable-repeat-customise-style/list-container.js","examples/er2-reorderable-repeat-customise-style/list-container2","text!examples/er2-reorderable-repeat-customise-style/list-container2.html","examples/er2-reorderable-repeat-customise-style/list-container2.js","examples/er3-reorderable-repeat-with-handler/index","text!examples/er3-reorderable-repeat-with-handler/index.html","examples/er3-reorderable-repeat-with-handler/index.js","examples/er3-reorderable-repeat-with-handler/table-container","text!examples/er3-reorderable-repeat-with-handler/table-container.css","text!examples/er3-reorderable-repeat-with-handler/table-container.html","examples/er3-reorderable-repeat-with-handler/table-container.js","examples/er4-reorderable-repeat-customise-preview/index","text!examples/er4-reorderable-repeat-customise-preview/index.html","examples/er4-reorderable-repeat-customise-preview/index.js","examples/er4-reorderable-repeat-customise-preview/table-container","text!examples/er4-reorderable-repeat-customise-preview/table-container.css","text!examples/er4-reorderable-repeat-customise-preview/table-container.html","examples/er4-reorderable-repeat-customise-preview/table-container.js","examples/er5-reorderable-repeat-direction/container","text!examples/er5-reorderable-repeat-direction/container.css","text!examples/er5-reorderable-repeat-direction/container.html","examples/er5-reorderable-repeat-direction/container.js","examples/er5-reorderable-repeat-direction/index","text!examples/er5-reorderable-repeat-direction/index.html","examples/er5-reorderable-repeat-direction/index.js","main","main.js","text!not-found.html","resources","resources.js","resources/index","resources/index.js","text!tutorial/api.html","text!tutorial/customise-preview-and-source-handler.html","text!tutorial/dnd-preview.html","text!tutorial/dnd-source.html","text!tutorial/dnd-target.html","text!tutorial/faq.html","text!tutorial/overview.html","text!tutorial/reorderable-repeat.html","text!tutorial/testing.html","text!tutorial/turn-off-preview-use-hover.html","text!tutorial/typescript-support.html"]}})}