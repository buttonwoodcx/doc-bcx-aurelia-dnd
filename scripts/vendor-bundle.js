/* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2013-2017 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
/**
 * bluebird build version 3.5.1
 * Features enabled: core
 * Features disabled: race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
*/
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";
var firstLineError;
try {throw new Error(); } catch (e) {firstLineError = e;}
var schedule = _dereq_("./schedule");
var Queue = _dereq_("./queue");
var util = _dereq_("./util");

function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule = schedule;
}

Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
};

Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
};

Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
};

Async.prototype.disableTrampolineIfNecessary = function() {
    if (util.hasDevTools) {
        this._trampolineEnabled = false;
    }
};

Async.prototype.haveItemsQueued = function () {
    return this._isTickUsed || this._haveDrainedQueues;
};


Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
            "\n");
        process.exit(2);
    } else {
        this.throwLater(e);
    }
};

Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () { throw arg; };
    }
    if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function() {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
};

function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
}

if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
} else {
    Async.prototype.invokeLater = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                setTimeout(function() {
                    fn.call(receiver, arg);
                }, 100);
            });
        }
    };

    Async.prototype.invoke = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                fn.call(receiver, arg);
            });
        }
    };

    Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
        } else {
            this._schedule(function() {
                promise._settlePromises();
            });
        }
    };
}

Async.prototype._drainQueue = function(queue) {
    while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};

Async.prototype._drainQueues = function () {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = Async;
module.exports.firstLineError = firstLineError;

},{"./queue":17,"./schedule":18,"./util":21}],2:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
var calledBind = false;
var rejectThis = function(_, e) {
    this._reject(e);
};

var targetRejected = function(e, context) {
    context.promiseRejectionQueued = true;
    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
};

var bindingResolved = function(thisArg, context) {
    if (((this._bitField & 50397184) === 0)) {
        this._resolveCallback(context.target);
    }
};

var bindingRejected = function(e, context) {
    if (!context.promiseRejectionQueued) this._reject(e);
};

Promise.prototype.bind = function (thisArg) {
    if (!calledBind) {
        calledBind = true;
        Promise.prototype._propagateFrom = debug.propagateFromFunction();
        Promise.prototype._boundValue = debug.boundValueFunction();
    }
    var maybePromise = tryConvertToPromise(thisArg);
    var ret = new Promise(INTERNAL);
    ret._propagateFrom(this, 1);
    var target = this._target();
    ret._setBoundTo(maybePromise);
    if (maybePromise instanceof Promise) {
        var context = {
            promiseRejectionQueued: false,
            promise: ret,
            target: target,
            bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, undefined, ret, context);
        maybePromise._then(
            bindingResolved, bindingRejected, undefined, ret, context);
        ret._setOnCancel(maybePromise);
    } else {
        ret._resolveCallback(target);
    }
    return ret;
};

Promise.prototype._setBoundTo = function (obj) {
    if (obj !== undefined) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
    } else {
        this._bitField = this._bitField & (~2097152);
    }
};

Promise.prototype._isBound = function () {
    return (this._bitField & 2097152) === 2097152;
};

Promise.bind = function (thisArg, value) {
    return Promise.resolve(value).bind(thisArg);
};
};

},{}],3:[function(_dereq_,module,exports){
"use strict";
var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict() {
    try { if (Promise === bluebird) Promise = old; }
    catch (e) {}
    return bluebird;
}
var bluebird = _dereq_("./promise")();
bluebird.noConflict = noConflict;
module.exports = bluebird;

},{"./promise":15}],4:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, PromiseArray, apiRejection, debug) {
var util = _dereq_("./util");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var async = Promise._async;

Promise.prototype["break"] = Promise.prototype.cancel = function() {
    if (!debug.cancellation()) return this._warn("cancellation is disabled");

    var promise = this;
    var child = promise;
    while (promise._isCancellable()) {
        if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
                child._followee().cancel();
            } else {
                child._cancelBranched();
            }
            break;
        }

        var parent = promise._cancellationParent;
        if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
                promise._followee().cancel();
            } else {
                promise._cancelBranched();
            }
            break;
        } else {
            if (promise._isFollowing()) promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
        }
    }
};

Promise.prototype._branchHasCancelled = function() {
    this._branchesRemainingToCancel--;
};

Promise.prototype._enoughBranchesHaveCancelled = function() {
    return this._branchesRemainingToCancel === undefined ||
           this._branchesRemainingToCancel <= 0;
};

Promise.prototype._cancelBy = function(canceller) {
    if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
    } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
        }
    }
    return false;
};

Promise.prototype._cancelBranched = function() {
    if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
    }
};

Promise.prototype._cancel = function() {
    if (!this._isCancellable()) return;
    this._setCancelled();
    async.invoke(this._cancelPromises, this, undefined);
};

Promise.prototype._cancelPromises = function() {
    if (this._length() > 0) this._settlePromises();
};

Promise.prototype._unsetOnCancel = function() {
    this._onCancelField = undefined;
};

Promise.prototype._isCancellable = function() {
    return this.isPending() && !this._isCancelled();
};

Promise.prototype.isCancellable = function() {
    return this.isPending() && !this.isCancelled();
};

Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
    if (util.isArray(onCancelCallback)) {
        for (var i = 0; i < onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
    } else if (onCancelCallback !== undefined) {
        if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
                var e = tryCatch(onCancelCallback).call(this._boundValue());
                if (e === errorObj) {
                    this._attachExtraTrace(e.e);
                    async.throwLater(e.e);
                }
            }
        } else {
            onCancelCallback._resultCancelled(this);
        }
    }
};

Promise.prototype._invokeOnCancel = function() {
    var onCancelCallback = this._onCancel();
    this._unsetOnCancel();
    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
};

Promise.prototype._invokeInternalOnCancel = function() {
    if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
    }
};

Promise.prototype._resultCancelled = function() {
    this.cancel();
};

};

},{"./util":21}],5:[function(_dereq_,module,exports){
"use strict";
module.exports = function(NEXT_FILTER) {
var util = _dereq_("./util");
var getKeys = _dereq_("./es5").keys;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function catchFilter(instances, cb, promise) {
    return function(e) {
        var boundTo = promise._boundValue();
        predicateLoop: for (var i = 0; i < instances.length; ++i) {
            var item = instances[i];

            if (item === Error ||
                (item != null && item.prototype instanceof Error)) {
                if (e instanceof item) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (typeof item === "function") {
                var matchesPredicate = tryCatch(item).call(boundTo, e);
                if (matchesPredicate === errorObj) {
                    return matchesPredicate;
                } else if (matchesPredicate) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (util.isObject(e)) {
                var keys = getKeys(item);
                for (var j = 0; j < keys.length; ++j) {
                    var key = keys[j];
                    if (item[key] != e[key]) {
                        continue predicateLoop;
                    }
                }
                return tryCatch(cb).call(boundTo, e);
            }
        }
        return NEXT_FILTER;
    };
}

return catchFilter;
};

},{"./es5":10,"./util":21}],6:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var longStackTraces = false;
var contextStack = [];

Promise.prototype._promiseCreated = function() {};
Promise.prototype._pushContext = function() {};
Promise.prototype._popContext = function() {return null;};
Promise._peekContext = Promise.prototype._peekContext = function() {};

function Context() {
    this._trace = new Context.CapturedTrace(peekContext());
}
Context.prototype._pushContext = function () {
    if (this._trace !== undefined) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
    }
};

Context.prototype._popContext = function () {
    if (this._trace !== undefined) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
    }
    return null;
};

function createContext() {
    if (longStackTraces) return new Context();
}

function peekContext() {
    var lastIndex = contextStack.length - 1;
    if (lastIndex >= 0) {
        return contextStack[lastIndex];
    }
    return undefined;
}
Context.CapturedTrace = null;
Context.create = createContext;
Context.deactivateLongStackTraces = function() {};
Context.activateLongStackTraces = function() {
    var Promise_pushContext = Promise.prototype._pushContext;
    var Promise_popContext = Promise.prototype._popContext;
    var Promise_PeekContext = Promise._peekContext;
    var Promise_peekContext = Promise.prototype._peekContext;
    var Promise_promiseCreated = Promise.prototype._promiseCreated;
    Context.deactivateLongStackTraces = function() {
        Promise.prototype._pushContext = Promise_pushContext;
        Promise.prototype._popContext = Promise_popContext;
        Promise._peekContext = Promise_PeekContext;
        Promise.prototype._peekContext = Promise_peekContext;
        Promise.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
    };
    longStackTraces = true;
    Promise.prototype._pushContext = Context.prototype._pushContext;
    Promise.prototype._popContext = Context.prototype._popContext;
    Promise._peekContext = Promise.prototype._peekContext = peekContext;
    Promise.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
    };
};
return Context;
};

},{}],7:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, Context) {
var getDomain = Promise._getDomain;
var async = Promise._async;
var Warning = _dereq_("./errors").Warning;
var util = _dereq_("./util");
var canAttachTrace = util.canAttachTrace;
var unhandledRejectionHandled;
var possiblyUnhandledRejection;
var bluebirdFramePattern =
    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
var stackFramePattern = null;
var formatStack = null;
var indentStackFrames = false;
var printWarning;
var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
                        (true ||
                         util.env("BLUEBIRD_DEBUG") ||
                         util.env("NODE_ENV") === "development"));

var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
    (debugging || util.env("BLUEBIRD_WARNINGS")));

var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 &&
    (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

Promise.prototype.suppressUnhandledRejections = function() {
    var target = this._target();
    target._bitField = ((target._bitField & (~1048576)) |
                      524288);
};

Promise.prototype._ensurePossibleRejectionHandled = function () {
    if ((this._bitField & 524288) !== 0) return;
    this._setRejectionIsUnhandled();
    var self = this;
    setTimeout(function() {
        self._notifyUnhandledRejection();
    }, 1);
};

Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
    fireRejectionEvent("rejectionHandled",
                                  unhandledRejectionHandled, undefined, this);
};

Promise.prototype._setReturnedNonUndefined = function() {
    this._bitField = this._bitField | 268435456;
};

Promise.prototype._returnedNonUndefined = function() {
    return (this._bitField & 268435456) !== 0;
};

Promise.prototype._notifyUnhandledRejection = function () {
    if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent("unhandledRejection",
                                      possiblyUnhandledRejection, reason, this);
    }
};

Promise.prototype._setUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField | 262144;
};

Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField & (~262144);
};

Promise.prototype._isUnhandledRejectionNotified = function () {
    return (this._bitField & 262144) > 0;
};

Promise.prototype._setRejectionIsUnhandled = function () {
    this._bitField = this._bitField | 1048576;
};

Promise.prototype._unsetRejectionIsUnhandled = function () {
    this._bitField = this._bitField & (~1048576);
    if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
    }
};

Promise.prototype._isRejectionUnhandled = function () {
    return (this._bitField & 1048576) > 0;
};

Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
    return warn(message, shouldUseOwnTrace, promise || this);
};

Promise.onPossiblyUnhandledRejection = function (fn) {
    var domain = getDomain();
    possiblyUnhandledRejection =
        typeof fn === "function" ? (domain === null ?
                                            fn : util.domainBind(domain, fn))
                                 : undefined;
};

Promise.onUnhandledRejectionHandled = function (fn) {
    var domain = getDomain();
    unhandledRejectionHandled =
        typeof fn === "function" ? (domain === null ?
                                            fn : util.domainBind(domain, fn))
                                 : undefined;
};

var disableLongStackTraces = function() {};
Promise.longStackTraces = function () {
    if (async.haveItemsQueued() && !config.longStackTraces) {
        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
            }
            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Context.deactivateLongStackTraces();
            async.enableTrampoline();
            config.longStackTraces = false;
        };
        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Context.activateLongStackTraces();
        async.disableTrampolineIfNecessary();
    }
};

Promise.hasLongStackTraces = function () {
    return config.longStackTraces && longStackTracesIsSupported();
};

var fireDomEvent = (function() {
    try {
        if (typeof CustomEvent === "function") {
            var event = new CustomEvent("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = new CustomEvent(name.toLowerCase(), {
                    detail: event,
                    cancelable: true
                });
                return !util.global.dispatchEvent(domEvent);
            };
        } else if (typeof Event === "function") {
            var event = new Event("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = new Event(name.toLowerCase(), {
                    cancelable: true
                });
                domEvent.detail = event;
                return !util.global.dispatchEvent(domEvent);
            };
        } else {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = document.createEvent("CustomEvent");
                domEvent.initCustomEvent(name.toLowerCase(), false, true,
                    event);
                return !util.global.dispatchEvent(domEvent);
            };
        }
    } catch (e) {}
    return function() {
        return false;
    };
})();

var fireGlobalEvent = (function() {
    if (util.isNode) {
        return function() {
            return process.emit.apply(process, arguments);
        };
    } else {
        if (!util.global) {
            return function() {
                return false;
            };
        }
        return function(name) {
            var methodName = "on" + name.toLowerCase();
            var method = util.global[methodName];
            if (!method) return false;
            method.apply(util.global, [].slice.call(arguments, 1));
            return true;
        };
    }
})();

function generatePromiseLifecycleEventObject(name, promise) {
    return {promise: promise};
}

var eventToObjectGenerator = {
    promiseCreated: generatePromiseLifecycleEventObject,
    promiseFulfilled: generatePromiseLifecycleEventObject,
    promiseRejected: generatePromiseLifecycleEventObject,
    promiseResolved: generatePromiseLifecycleEventObject,
    promiseCancelled: generatePromiseLifecycleEventObject,
    promiseChained: function(name, promise, child) {
        return {promise: promise, child: child};
    },
    warning: function(name, warning) {
        return {warning: warning};
    },
    unhandledRejection: function (name, reason, promise) {
        return {reason: reason, promise: promise};
    },
    rejectionHandled: generatePromiseLifecycleEventObject
};

var activeFireEvent = function (name) {
    var globalEventFired = false;
    try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
    } catch (e) {
        async.throwLater(e);
        globalEventFired = true;
    }

    var domEventFired = false;
    try {
        domEventFired = fireDomEvent(name,
                    eventToObjectGenerator[name].apply(null, arguments));
    } catch (e) {
        async.throwLater(e);
        domEventFired = true;
    }

    return domEventFired || globalEventFired;
};

Promise.config = function(opts) {
    opts = Object(opts);
    if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
            Promise.longStackTraces();
        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
            disableLongStackTraces();
        }
    }
    if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;

        if (util.isObject(warningsOption)) {
            if ("wForgottenReturn" in warningsOption) {
                wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
        }
    }
    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
        if (async.haveItemsQueued()) {
            throw new Error(
                "cannot enable cancellation after promises are in use");
        }
        Promise.prototype._clearCancellationData =
            cancellationClearCancellationData;
        Promise.prototype._propagateFrom = cancellationPropagateFrom;
        Promise.prototype._onCancel = cancellationOnCancel;
        Promise.prototype._setOnCancel = cancellationSetOnCancel;
        Promise.prototype._attachCancellationCallback =
            cancellationAttachCancellationCallback;
        Promise.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
    }
    if ("monitoring" in opts) {
        if (opts.monitoring && !config.monitoring) {
            config.monitoring = true;
            Promise.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config.monitoring) {
            config.monitoring = false;
            Promise.prototype._fireEvent = defaultFireEvent;
        }
    }
    return Promise;
};

function defaultFireEvent() { return false; }

Promise.prototype._fireEvent = defaultFireEvent;
Promise.prototype._execute = function(executor, resolve, reject) {
    try {
        executor(resolve, reject);
    } catch (e) {
        return e;
    }
};
Promise.prototype._onCancel = function () {};
Promise.prototype._setOnCancel = function (handler) { ; };
Promise.prototype._attachCancellationCallback = function(onCancel) {
    ;
};
Promise.prototype._captureStackTrace = function () {};
Promise.prototype._attachExtraTrace = function () {};
Promise.prototype._clearCancellationData = function() {};
Promise.prototype._propagateFrom = function (parent, flags) {
    ;
    ;
};

function cancellationExecute(executor, resolve, reject) {
    var promise = this;
    try {
        executor(resolve, reject, function(onCancel) {
            if (typeof onCancel !== "function") {
                throw new TypeError("onCancel must be a function, got: " +
                                    util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
        });
    } catch (e) {
        return e;
    }
}

function cancellationAttachCancellationCallback(onCancel) {
    if (!this._isCancellable()) return this;

    var previousOnCancel = this._onCancel();
    if (previousOnCancel !== undefined) {
        if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
        } else {
            this._setOnCancel([previousOnCancel, onCancel]);
        }
    } else {
        this._setOnCancel(onCancel);
    }
}

function cancellationOnCancel() {
    return this._onCancelField;
}

function cancellationSetOnCancel(onCancel) {
    this._onCancelField = onCancel;
}

function cancellationClearCancellationData() {
    this._cancellationParent = undefined;
    this._onCancelField = undefined;
}

function cancellationPropagateFrom(parent, flags) {
    if ((flags & 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === undefined) {
            branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
    }
    if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}

function bindingPropagateFrom(parent, flags) {
    if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}
var propagateFromFunction = bindingPropagateFrom;

function boundValueFunction() {
    var ret = this._boundTo;
    if (ret !== undefined) {
        if (ret instanceof Promise) {
            if (ret.isFulfilled()) {
                return ret.value();
            } else {
                return undefined;
            }
        }
    }
    return ret;
}

function longStackTracesCaptureStackTrace() {
    this._trace = new CapturedTrace(this._peekContext());
}

function longStackTracesAttachExtraTrace(error, ignoreSelf) {
    if (canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
            if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== undefined) {
            trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
            var parsed = parseStackAndMessage(error);
            util.notEnumerableProp(error, "stack",
                parsed.message + "\n" + parsed.stack.join("\n"));
            util.notEnumerableProp(error, "__stackCleaned__", true);
        }
    }
}

function checkForgottenReturns(returnValue, promiseCreated, name, promise,
                               parent) {
    if (returnValue === undefined && promiseCreated !== null &&
        wForgottenReturn) {
        if (parent !== undefined && parent._returnedNonUndefined()) return;
        if ((promise._bitField & 65535) === 0) return;

        if (name) name = name + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split("\n");
            var stack = cleanStack(traceLines);
            for (var i = stack.length - 1; i >= 0; --i) {
                var line = stack[i];
                if (!nodeFramePattern.test(line)) {
                    var lineMatches = line.match(parseLinePattern);
                    if (lineMatches) {
                        handlerLine  = "at " + lineMatches[1] +
                            ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                    }
                    break;
                }
            }

            if (stack.length > 0) {
                var firstUserLine = stack[0];
                for (var i = 0; i < traceLines.length; ++i) {

                    if (traceLines[i] === firstUserLine) {
                        if (i > 0) {
                            creatorLine = "\n" + traceLines[i - 1];
                        }
                        break;
                    }
                }

            }
        }
        var msg = "a promise was created in a " + name +
            "handler " + handlerLine + "but was not returned from it, " +
            "see http://goo.gl/rRqMUw" +
            creatorLine;
        promise._warn(msg, true, promiseCreated);
    }
}

function deprecated(name, replacement) {
    var message = name +
        " is deprecated and will be removed in a future version.";
    if (replacement) message += " Use " + replacement + " instead.";
    return warn(message);
}

function warn(message, shouldUseOwnTrace, promise) {
    if (!config.warnings) return;
    var warning = new Warning(message);
    var ctx;
    if (shouldUseOwnTrace) {
        promise._attachExtraTrace(warning);
    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
        ctx.attachExtraTrace(warning);
    } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
    }

    if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
    }
}

function reconstructStack(message, stacks) {
    for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
    }
    if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
    }
    return message + "\n" + stacks.join("\n");
}

function removeDuplicateOrEmptyJumps(stacks) {
    for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 ||
            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
            stacks.splice(i, 1);
            i--;
        }
    }
}

function removeCommonRoots(stacks) {
    var current = stacks[0];
    for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;

        for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
                commonRootMeetPoint = j;
                break;
            }
        }

        for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
                current.pop();
                currentLastIndex--;
            } else {
                break;
            }
        }
        current = prev;
    }
}

function cleanStack(stack) {
    var ret = [];
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = "    (No stack trace)" === line ||
            stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
                line = "    " + line;
            }
            ret.push(line);
        }
    }
    return ret;
}

function stackFramesAsArray(error) {
    var stack = error.stack.replace(/\s+$/g, "").split("\n");
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
        }
    }
    if (i > 0 && error.name != "SyntaxError") {
        stack = stack.slice(i);
    }
    return stack;
}

function parseStackAndMessage(error) {
    var stack = error.stack;
    var message = error.toString();
    stack = typeof stack === "string" && stack.length > 0
                ? stackFramesAsArray(error) : ["    (No stack trace)"];
    return {
        message: message,
        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
    };
}

function formatAndLogError(error, title, isSoft) {
    if (typeof console !== "undefined") {
        var message;
        if (util.isObject(error)) {
            var stack = error.stack;
            message = title + formatStack(stack, error);
        } else {
            message = title + String(error);
        }
        if (typeof printWarning === "function") {
            printWarning(message, isSoft);
        } else if (typeof console.log === "function" ||
            typeof console.log === "object") {
            console.log(message);
        }
    }
}

function fireRejectionEvent(name, localHandler, reason, promise) {
    var localEventFired = false;
    try {
        if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
                localHandler(promise);
            } else {
                localHandler(reason, promise);
            }
        }
    } catch (e) {
        async.throwLater(e);
    }

    if (name === "unhandledRejection") {
        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
            formatAndLogError(reason, "Unhandled rejection ");
        }
    } else {
        activeFireEvent(name, promise);
    }
}

function formatNonError(obj) {
    var str;
    if (typeof obj === "function") {
        str = "[function " +
            (obj.name || "anonymous") +
            "]";
    } else {
        str = obj && typeof obj.toString === "function"
            ? obj.toString() : util.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
            try {
                var newStr = JSON.stringify(obj);
                str = newStr;
            }
            catch(e) {

            }
        }
        if (str.length === 0) {
            str = "(empty array)";
        }
    }
    return ("(<" + snip(str) + ">, no stack trace)");
}

function snip(str) {
    var maxChars = 41;
    if (str.length < maxChars) {
        return str;
    }
    return str.substr(0, maxChars - 3) + "...";
}

function longStackTracesIsSupported() {
    return typeof captureStackTrace === "function";
}

var shouldIgnore = function() { return false; };
var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
function parseLineInfo(line) {
    var matches = line.match(parseLineInfoRegex);
    if (matches) {
        return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
        };
    }
}

function setBounds(firstLineError, lastLineError) {
    if (!longStackTracesIsSupported()) return;
    var firstStackLines = firstLineError.stack.split("\n");
    var lastStackLines = lastLineError.stack.split("\n");
    var firstIndex = -1;
    var lastIndex = -1;
    var firstFileName;
    var lastFileName;
    for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
        }
    }
    for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
        }
    }
    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
        firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
    }

    shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
            if (info.fileName === firstFileName &&
                (firstIndex <= info.line && info.line <= lastIndex)) {
                return true;
            }
        }
        return false;
    };
}

function CapturedTrace(parent) {
    this._parent = parent;
    this._promisesCreated = 0;
    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
    captureStackTrace(this, CapturedTrace);
    if (length > 32) this.uncycle();
}
util.inherits(CapturedTrace, Error);
Context.CapturedTrace = CapturedTrace;

CapturedTrace.prototype.uncycle = function() {
    var length = this._length;
    if (length < 2) return;
    var nodes = [];
    var stackToIndex = {};

    for (var i = 0, node = this; node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
    }
    length = this._length = i;
    for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
            stackToIndex[stack] = i;
        }
    }
    for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
            if (index > 0) {
                nodes[index - 1]._parent = undefined;
                nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = undefined;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

            if (index < length - 1) {
                cycleEdgeNode._parent = nodes[index + 1];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length =
                    cycleEdgeNode._parent._length + 1;
            } else {
                cycleEdgeNode._parent = undefined;
                cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
            }
            return;
        }
    }
};

CapturedTrace.prototype.attachExtraTrace = function(error) {
    if (error.__stackCleaned__) return;
    this.uncycle();
    var parsed = parseStackAndMessage(error);
    var message = parsed.message;
    var stacks = [parsed.stack];

    var trace = this;
    while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
    }
    removeCommonRoots(stacks);
    removeDuplicateOrEmptyJumps(stacks);
    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
    util.notEnumerableProp(error, "__stackCleaned__", true);
};

var captureStackTrace = (function stackDetection() {
    var v8stackFramePattern = /^\s*at\s*/;
    var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string") return stack;

        if (error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    if (typeof Error.stackTraceLimit === "number" &&
        typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace = Error.captureStackTrace;

        shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
        };
    }
    var err = new Error();

    if (typeof err.stack === "string" &&
        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
            o.stack = new Error().stack;
        };
    }

    var hasStackAfterThrow;
    try { throw new Error(); }
    catch(e) {
        hasStackAfterThrow = ("stack" in e);
    }
    if (!("stack" in err) && hasStackAfterThrow &&
        typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
            Error.stackTraceLimit += 6;
            try { throw new Error(); }
            catch(e) { o.stack = e.stack; }
            Error.stackTraceLimit -= 6;
        };
    }

    formatStack = function(stack, error) {
        if (typeof stack === "string") return stack;

        if ((typeof error === "object" ||
            typeof error === "function") &&
            error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    return null;

})([]);

if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
    printWarning = function (message) {
        console.warn(message);
    };
    if (util.isNode && process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
            console.warn(color + message + "\u001b[0m\n");
        };
    } else if (!util.isNode && typeof (new Error().stack) === "string") {
        printWarning = function(message, isSoft) {
            console.warn("%c" + message,
                        isSoft ? "color: darkorange" : "color: red");
        };
    }
}

var config = {
    warnings: warnings,
    longStackTraces: false,
    cancellation: false,
    monitoring: false
};

if (longStackTraces) Promise.longStackTraces();

return {
    longStackTraces: function() {
        return config.longStackTraces;
    },
    warnings: function() {
        return config.warnings;
    },
    cancellation: function() {
        return config.cancellation;
    },
    monitoring: function() {
        return config.monitoring;
    },
    propagateFromFunction: function() {
        return propagateFromFunction;
    },
    boundValueFunction: function() {
        return boundValueFunction;
    },
    checkForgottenReturns: checkForgottenReturns,
    setBounds: setBounds,
    warn: warn,
    deprecated: deprecated,
    CapturedTrace: CapturedTrace,
    fireDomEvent: fireDomEvent,
    fireGlobalEvent: fireGlobalEvent
};
};

},{"./errors":9,"./util":21}],8:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function returner() {
    return this.value;
}
function thrower() {
    throw this.reason;
}

Promise.prototype["return"] =
Promise.prototype.thenReturn = function (value) {
    if (value instanceof Promise) value.suppressUnhandledRejections();
    return this._then(
        returner, undefined, undefined, {value: value}, undefined);
};

Promise.prototype["throw"] =
Promise.prototype.thenThrow = function (reason) {
    return this._then(
        thrower, undefined, undefined, {reason: reason}, undefined);
};

Promise.prototype.catchThrow = function (reason) {
    if (arguments.length <= 1) {
        return this._then(
            undefined, thrower, undefined, {reason: reason}, undefined);
    } else {
        var _reason = arguments[1];
        var handler = function() {throw _reason;};
        return this.caught(reason, handler);
    }
};

Promise.prototype.catchReturn = function (value) {
    if (arguments.length <= 1) {
        if (value instanceof Promise) value.suppressUnhandledRejections();
        return this._then(
            undefined, returner, undefined, {value: value}, undefined);
    } else {
        var _value = arguments[1];
        if (_value instanceof Promise) _value.suppressUnhandledRejections();
        var handler = function() {return _value;};
        return this.caught(value, handler);
    }
};
};

},{}],9:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5");
var Objectfreeze = es5.freeze;
var util = _dereq_("./util");
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message",
            typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var Warning = subError("Warning", "warning");
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch(e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " +
    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    if (!(this instanceof OperationalError))
        return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }

}
inherits(OperationalError, Error);

var errorTypes = Error["__BluebirdErrorTypes__"];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
    });
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};

},{"./es5":10,"./util":21}],10:[function(_dereq_,module,exports){
var isES5 = (function(){
    "use strict";
    return this === undefined;
})();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectGetDescriptor = function(o, key) {
        return {value: o[key]};
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        }
        catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === "[object Array]";
        }
        catch(e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function() {
            return true;
        }
    };
}

},{}],11:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {
var util = _dereq_("./util");
var CancellationError = Promise.CancellationError;
var errorObj = util.errorObj;
var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);

function PassThroughHandlerContext(promise, type, handler) {
    this.promise = promise;
    this.type = type;
    this.handler = handler;
    this.called = false;
    this.cancelPromise = null;
}

PassThroughHandlerContext.prototype.isFinallyHandler = function() {
    return this.type === 0;
};

function FinallyHandlerCancelReaction(finallyHandler) {
    this.finallyHandler = finallyHandler;
}

FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
    checkCancel(this.finallyHandler);
};

function checkCancel(ctx, reason) {
    if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
        } else {
            ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
    }
    return false;
}

function succeed() {
    return finallyHandler.call(this, this.promise._target()._settledValue());
}
function fail(reason) {
    if (checkCancel(this, reason)) return;
    errorObj.e = reason;
    return errorObj;
}
function finallyHandler(reasonOrValue) {
    var promise = this.promise;
    var handler = this.handler;

    if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler()
            ? handler.call(promise._boundValue())
            : handler.call(promise._boundValue(), reasonOrValue);
        if (ret === NEXT_FILTER) {
            return ret;
        } else if (ret !== undefined) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                if (this.cancelPromise != null) {
                    if (maybePromise._isCancelled()) {
                        var reason =
                            new CancellationError("late cancellation observer");
                        promise._attachExtraTrace(reason);
                        errorObj.e = reason;
                        return errorObj;
                    } else if (maybePromise.isPending()) {
                        maybePromise._attachCancellationCallback(
                            new FinallyHandlerCancelReaction(this));
                    }
                }
                return maybePromise._then(
                    succeed, fail, undefined, this, undefined);
            }
        }
    }

    if (promise.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
    } else {
        checkCancel(this);
        return reasonOrValue;
    }
}

Promise.prototype._passThrough = function(handler, type, success, fail) {
    if (typeof handler !== "function") return this.then();
    return this._then(success,
                      fail,
                      undefined,
                      new PassThroughHandlerContext(this, type, handler),
                      undefined);
};

Promise.prototype.lastly =
Promise.prototype["finally"] = function (handler) {
    return this._passThrough(handler,
                             0,
                             finallyHandler,
                             finallyHandler);
};


Promise.prototype.tap = function (handler) {
    return this._passThrough(handler, 1, finallyHandler);
};

Promise.prototype.tapCatch = function (handlerOrPredicate) {
    var len = arguments.length;
    if(len === 1) {
        return this._passThrough(handlerOrPredicate,
                                 1,
                                 undefined,
                                 finallyHandler);
    } else {
         var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
                catchInstances[j++] = item;
            } else {
                return Promise.reject(new TypeError(
                    "tapCatch statement predicate: "
                    + "expecting an object but got " + util.classString(item)
                ));
            }
        }
        catchInstances.length = j;
        var handler = arguments[i];
        return this._passThrough(catchFilter(catchInstances, handler, this),
                                 1,
                                 undefined,
                                 finallyHandler);
    }

};

return PassThroughHandlerContext;
};

},{"./catch_filter":5,"./util":21}],12:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,
         getDomain) {
var util = _dereq_("./util");
var canEvaluate = util.canEvaluate;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var reject;

if (!true) {
if (canEvaluate) {
    var thenCallback = function(i) {
        return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
    };

    var promiseSetter = function(i) {
        return new Function("promise", "holder", "                           \n\
            'use strict';                                                    \n\
            holder.pIndex = promise;                                         \n\
            ".replace(/Index/g, i));
    };

    var generateHolderClass = function(total) {
        var props = new Array(total);
        for (var i = 0; i < props.length; ++i) {
            props[i] = "this.p" + (i+1);
        }
        var assignment = props.join(" = ") + " = null;";
        var cancellationCode= "var promise;\n" + props.map(function(prop) {
            return "                                                         \n\
                promise = " + prop + ";                                      \n\
                if (promise instanceof Promise) {                            \n\
                    promise.cancel();                                        \n\
                }                                                            \n\
            ";
        }).join("\n");
        var passedArguments = props.join(", ");
        var name = "Holder$" + total;


        var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
            'use strict';                                                    \n\
            function [TheName](fn) {                                         \n\
                [TheProperties]                                              \n\
                this.fn = fn;                                                \n\
                this.asyncNeeded = true;                                     \n\
                this.now = 0;                                                \n\
            }                                                                \n\
                                                                             \n\
            [TheName].prototype._callFunction = function(promise) {          \n\
                promise._pushContext();                                      \n\
                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
                promise._popContext();                                       \n\
                if (ret === errorObj) {                                      \n\
                    promise._rejectCallback(ret.e, false);                   \n\
                } else {                                                     \n\
                    promise._resolveCallback(ret);                           \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype.checkFulfillment = function(promise) {       \n\
                var now = ++this.now;                                        \n\
                if (now === [TheTotal]) {                                    \n\
                    if (this.asyncNeeded) {                                  \n\
                        async.invoke(this._callFunction, this, promise);     \n\
                    } else {                                                 \n\
                        this._callFunction(promise);                         \n\
                    }                                                        \n\
                                                                             \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype._resultCancelled = function() {              \n\
                [CancellationCode]                                           \n\
            };                                                               \n\
                                                                             \n\
            return [TheName];                                                \n\
        }(tryCatch, errorObj, Promise, async);                               \n\
        ";

        code = code.replace(/\[TheName\]/g, name)
            .replace(/\[TheTotal\]/g, total)
            .replace(/\[ThePassedArguments\]/g, passedArguments)
            .replace(/\[TheProperties\]/g, assignment)
            .replace(/\[CancellationCode\]/g, cancellationCode);

        return new Function("tryCatch", "errorObj", "Promise", "async", code)
                           (tryCatch, errorObj, Promise, async);
    };

    var holderClasses = [];
    var thenCallbacks = [];
    var promiseSetters = [];

    for (var i = 0; i < 8; ++i) {
        holderClasses.push(generateHolderClass(i + 1));
        thenCallbacks.push(thenCallback(i + 1));
        promiseSetters.push(promiseSetter(i + 1));
    }

    reject = function (reason) {
        this._reject(reason);
    };
}}

Promise.join = function () {
    var last = arguments.length - 1;
    var fn;
    if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (!true) {
            if (last <= 8 && canEvaluate) {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                var HolderClass = holderClasses[last - 1];
                var holder = new HolderClass(fn);
                var callbacks = thenCallbacks;

                for (var i = 0; i < last; ++i) {
                    var maybePromise = tryConvertToPromise(arguments[i], ret);
                    if (maybePromise instanceof Promise) {
                        maybePromise = maybePromise._target();
                        var bitField = maybePromise._bitField;
                        ;
                        if (((bitField & 50397184) === 0)) {
                            maybePromise._then(callbacks[i], reject,
                                               undefined, ret, holder);
                            promiseSetters[i](maybePromise, holder);
                            holder.asyncNeeded = false;
                        } else if (((bitField & 33554432) !== 0)) {
                            callbacks[i].call(ret,
                                              maybePromise._value(), holder);
                        } else if (((bitField & 16777216) !== 0)) {
                            ret._reject(maybePromise._reason());
                        } else {
                            ret._cancel();
                        }
                    } else {
                        callbacks[i].call(ret, maybePromise, holder);
                    }
                }

                if (!ret._isFateSealed()) {
                    if (holder.asyncNeeded) {
                        var domain = getDomain();
                        if (domain !== null) {
                            holder.fn = util.domainBind(domain, holder.fn);
                        }
                    }
                    ret._setAsyncGuaranteed();
                    ret._setOnCancel(holder);
                }
                return ret;
            }
        }
    }
    var args = [].slice.call(arguments);;
    if (fn) args.pop();
    var ret = new PromiseArray(args).promise();
    return fn !== undefined ? ret.spread(fn) : ret;
};

};

},{"./util":21}],13:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
var util = _dereq_("./util");
var tryCatch = util.tryCatch;

Promise.method = function (fn) {
    if (typeof fn !== "function") {
        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
    }
    return function () {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(
            value, promiseCreated, "Promise.method", ret);
        ret._resolveFromSyncValue(value);
        return ret;
    };
};

Promise.attempt = Promise["try"] = function (fn) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._pushContext();
    var value;
    if (arguments.length > 1) {
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
                                  : tryCatch(fn).call(ctx, arg);
    } else {
        value = tryCatch(fn)();
    }
    var promiseCreated = ret._popContext();
    debug.checkForgottenReturns(
        value, promiseCreated, "Promise.try", ret);
    ret._resolveFromSyncValue(value);
    return ret;
};

Promise.prototype._resolveFromSyncValue = function (value) {
    if (value === util.errorObj) {
        this._rejectCallback(value.e, false);
    } else {
        this._resolveCallback(value, true);
    }
};
};

},{"./util":21}],14:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util");
var maybeWrapAsError = util.maybeWrapAsError;
var errors = _dereq_("./errors");
var OperationalError = errors.OperationalError;
var es5 = _dereq_("./es5");

function isUntypedError(obj) {
    return obj instanceof Error &&
        es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise, multiArgs) {
    return function(err, value) {
        if (promise === null) return;
        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (!multiArgs) {
            promise._fulfill(value);
        } else {
            var args = [].slice.call(arguments, 1);;
            promise._fulfill(args);
        }
        promise = null;
    };
}

module.exports = nodebackForPromise;

},{"./errors":9,"./es5":10,"./util":21}],15:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
var makeSelfResolutionError = function () {
    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var reflectHandler = function() {
    return new Promise.PromiseInspection(this._target());
};
var apiRejection = function(msg) {
    return Promise.reject(new TypeError(msg));
};
function Proxyable() {}
var UNDEFINED_BINDING = {};
var util = _dereq_("./util");

var getDomain;
if (util.isNode) {
    getDomain = function() {
        var ret = process.domain;
        if (ret === undefined) ret = null;
        return ret;
    };
} else {
    getDomain = function() {
        return null;
    };
}
util.notEnumerableProp(Promise, "_getDomain", getDomain);

var es5 = _dereq_("./es5");
var Async = _dereq_("./async");
var async = new Async();
es5.defineProperty(Promise, "_async", {value: async});
var errors = _dereq_("./errors");
var TypeError = Promise.TypeError = errors.TypeError;
Promise.RangeError = errors.RangeError;
var CancellationError = Promise.CancellationError = errors.CancellationError;
Promise.TimeoutError = errors.TimeoutError;
Promise.OperationalError = errors.OperationalError;
Promise.RejectionError = errors.OperationalError;
Promise.AggregateError = errors.AggregateError;
var INTERNAL = function(){};
var APPLY = {};
var NEXT_FILTER = {};
var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);
var PromiseArray =
    _dereq_("./promise_array")(Promise, INTERNAL,
                               tryConvertToPromise, apiRejection, Proxyable);
var Context = _dereq_("./context")(Promise);
 /*jshint unused:false*/
var createContext = Context.create;
var debug = _dereq_("./debuggability")(Promise, Context);
var CapturedTrace = debug.CapturedTrace;
var PassThroughHandlerContext =
    _dereq_("./finally")(Promise, tryConvertToPromise, NEXT_FILTER);
var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);
var nodebackForPromise = _dereq_("./nodeback");
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
function check(self, executor) {
    if (self == null || self.constructor !== Promise) {
        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    if (typeof executor !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(executor));
    }

}

function Promise(executor) {
    if (executor !== INTERNAL) {
        check(this, executor);
    }
    this._bitField = 0;
    this._fulfillmentHandler0 = undefined;
    this._rejectionHandler0 = undefined;
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._resolveFromExecutor(executor);
    this._promiseCreated();
    this._fireEvent("promiseCreated", this);
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
    var len = arguments.length;
    if (len > 1) {
        var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
                catchInstances[j++] = item;
            } else {
                return apiRejection("Catch statement predicate: " +
                    "expecting an object but got " + util.classString(item));
            }
        }
        catchInstances.length = j;
        fn = arguments[i];
        return this.then(undefined, catchFilter(catchInstances, fn, this));
    }
    return this.then(undefined, fn);
};

Promise.prototype.reflect = function () {
    return this._then(reflectHandler,
        reflectHandler, undefined, this, undefined);
};

Promise.prototype.then = function (didFulfill, didReject) {
    if (debug.warnings() && arguments.length > 0 &&
        typeof didFulfill !== "function" &&
        typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " +
                util.classString(didFulfill);
        if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
        }
        this._warn(msg);
    }
    return this._then(didFulfill, didReject, undefined, undefined, undefined);
};

Promise.prototype.done = function (didFulfill, didReject) {
    var promise =
        this._then(didFulfill, didReject, undefined, undefined, undefined);
    promise._setIsFinal();
};

Promise.prototype.spread = function (fn) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
};

Promise.prototype.toJSON = function () {
    var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
    };
    if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
    } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
    }
    return ret;
};

Promise.prototype.all = function () {
    if (arguments.length > 0) {
        this._warn(".all() was passed arguments but it does not take any");
    }
    return new PromiseArray(this).promise();
};

Promise.prototype.error = function (fn) {
    return this.caught(util.originatesFromRejection, fn);
};

Promise.getNewLibraryCopy = module.exports;

Promise.is = function (val) {
    return val instanceof Promise;
};

Promise.fromNode = Promise.fromCallback = function(fn) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
                                         : false;
    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
    if (result === errorObj) {
        ret._rejectCallback(result.e, true);
    }
    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
    return ret;
};

Promise.all = function (promises) {
    return new PromiseArray(promises).promise();
};

Promise.cast = function (obj) {
    var ret = tryConvertToPromise(obj);
    if (!(ret instanceof Promise)) {
        ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._setFulfilled();
        ret._rejectionHandler0 = obj;
    }
    return ret;
};

Promise.resolve = Promise.fulfilled = Promise.cast;

Promise.reject = Promise.rejected = function (reason) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._rejectCallback(reason, true);
    return ret;
};

Promise.setScheduler = function(fn) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    return async.setScheduler(fn);
};

Promise.prototype._then = function (
    didFulfill,
    didReject,
    _,    receiver,
    internalData
) {
    var haveInternalData = internalData !== undefined;
    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
    var target = this._target();
    var bitField = target._bitField;

    if (!haveInternalData) {
        promise._propagateFrom(this, 3);
        promise._captureStackTrace();
        if (receiver === undefined &&
            ((this._bitField & 2097152) !== 0)) {
            if (!((bitField & 50397184) === 0)) {
                receiver = this._boundValue();
            } else {
                receiver = target === this ? undefined : this._boundTo;
            }
        }
        this._fireEvent("promiseChained", this, promise);
    }

    var domain = getDomain();
    if (!((bitField & 50397184) === 0)) {
        var handler, value, settler = target._settlePromiseCtx;
        if (((bitField & 33554432) !== 0)) {
            value = target._rejectionHandler0;
            handler = didFulfill;
        } else if (((bitField & 16777216) !== 0)) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
        } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
        }

        async.invoke(settler, target, {
            handler: domain === null ? handler
                : (typeof handler === "function" &&
                    util.domainBind(domain, handler)),
            promise: promise,
            receiver: receiver,
            value: value
        });
    } else {
        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
    }

    return promise;
};

Promise.prototype._length = function () {
    return this._bitField & 65535;
};

Promise.prototype._isFateSealed = function () {
    return (this._bitField & 117506048) !== 0;
};

Promise.prototype._isFollowing = function () {
    return (this._bitField & 67108864) === 67108864;
};

Promise.prototype._setLength = function (len) {
    this._bitField = (this._bitField & -65536) |
        (len & 65535);
};

Promise.prototype._setFulfilled = function () {
    this._bitField = this._bitField | 33554432;
    this._fireEvent("promiseFulfilled", this);
};

Promise.prototype._setRejected = function () {
    this._bitField = this._bitField | 16777216;
    this._fireEvent("promiseRejected", this);
};

Promise.prototype._setFollowing = function () {
    this._bitField = this._bitField | 67108864;
    this._fireEvent("promiseResolved", this);
};

Promise.prototype._setIsFinal = function () {
    this._bitField = this._bitField | 4194304;
};

Promise.prototype._isFinal = function () {
    return (this._bitField & 4194304) > 0;
};

Promise.prototype._unsetCancelled = function() {
    this._bitField = this._bitField & (~65536);
};

Promise.prototype._setCancelled = function() {
    this._bitField = this._bitField | 65536;
    this._fireEvent("promiseCancelled", this);
};

Promise.prototype._setWillBeCancelled = function() {
    this._bitField = this._bitField | 8388608;
};

Promise.prototype._setAsyncGuaranteed = function() {
    if (async.hasCustomScheduler()) return;
    this._bitField = this._bitField | 134217728;
};

Promise.prototype._receiverAt = function (index) {
    var ret = index === 0 ? this._receiver0 : this[
            index * 4 - 4 + 3];
    if (ret === UNDEFINED_BINDING) {
        return undefined;
    } else if (ret === undefined && this._isBound()) {
        return this._boundValue();
    }
    return ret;
};

Promise.prototype._promiseAt = function (index) {
    return this[
            index * 4 - 4 + 2];
};

Promise.prototype._fulfillmentHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 0];
};

Promise.prototype._rejectionHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 1];
};

Promise.prototype._boundValue = function() {};

Promise.prototype._migrateCallback0 = function (follower) {
    var bitField = follower._bitField;
    var fulfill = follower._fulfillmentHandler0;
    var reject = follower._rejectionHandler0;
    var promise = follower._promise0;
    var receiver = follower._receiverAt(0);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._migrateCallbackAt = function (follower, index) {
    var fulfill = follower._fulfillmentHandlerAt(index);
    var reject = follower._rejectionHandlerAt(index);
    var promise = follower._promiseAt(index);
    var receiver = follower._receiverAt(index);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._addCallbacks = function (
    fulfill,
    reject,
    promise,
    receiver,
    domain
) {
    var index = this._length();

    if (index >= 65535 - 4) {
        index = 0;
        this._setLength(0);
    }

    if (index === 0) {
        this._promise0 = promise;
        this._receiver0 = receiver;
        if (typeof fulfill === "function") {
            this._fulfillmentHandler0 =
                domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
            this._rejectionHandler0 =
                domain === null ? reject : util.domainBind(domain, reject);
        }
    } else {
        var base = index * 4 - 4;
        this[base + 2] = promise;
        this[base + 3] = receiver;
        if (typeof fulfill === "function") {
            this[base + 0] =
                domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
            this[base + 1] =
                domain === null ? reject : util.domainBind(domain, reject);
        }
    }
    this._setLength(index + 1);
    return index;
};

Promise.prototype._proxy = function (proxyable, arg) {
    this._addCallbacks(undefined, undefined, arg, proxyable, null);
};

Promise.prototype._resolveCallback = function(value, shouldBind) {
    if (((this._bitField & 117506048) !== 0)) return;
    if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false);
    var maybePromise = tryConvertToPromise(value, this);
    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

    if (shouldBind) this._propagateFrom(maybePromise, 2);

    var promise = maybePromise._target();

    if (promise === this) {
        this._reject(makeSelfResolutionError());
        return;
    }

    var bitField = promise._bitField;
    if (((bitField & 50397184) === 0)) {
        var len = this._length();
        if (len > 0) promise._migrateCallback0(this);
        for (var i = 1; i < len; ++i) {
            promise._migrateCallbackAt(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
    } else if (((bitField & 33554432) !== 0)) {
        this._fulfill(promise._value());
    } else if (((bitField & 16777216) !== 0)) {
        this._reject(promise._reason());
    } else {
        var reason = new CancellationError("late cancellation observer");
        promise._attachExtraTrace(reason);
        this._reject(reason);
    }
};

Promise.prototype._rejectCallback =
function(reason, synchronous, ignoreNonErrorWarnings) {
    var trace = util.ensureErrorObject(reason);
    var hasStack = trace === reason;
    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
        var message = "a promise was rejected with a non-error: " +
            util.classString(reason);
        this._warn(message, true);
    }
    this._attachExtraTrace(trace, synchronous ? hasStack : false);
    this._reject(reason);
};

Promise.prototype._resolveFromExecutor = function (executor) {
    if (executor === INTERNAL) return;
    var promise = this;
    this._captureStackTrace();
    this._pushContext();
    var synchronous = true;
    var r = this._execute(executor, function(value) {
        promise._resolveCallback(value);
    }, function (reason) {
        promise._rejectCallback(reason, synchronous);
    });
    synchronous = false;
    this._popContext();

    if (r !== undefined) {
        promise._rejectCallback(r, true);
    }
};

Promise.prototype._settlePromiseFromHandler = function (
    handler, receiver, value, promise
) {
    var bitField = promise._bitField;
    if (((bitField & 65536) !== 0)) return;
    promise._pushContext();
    var x;
    if (receiver === APPLY) {
        if (!value || typeof value.length !== "number") {
            x = errorObj;
            x.e = new TypeError("cannot .spread() a non-array: " +
                                    util.classString(value));
        } else {
            x = tryCatch(handler).apply(this._boundValue(), value);
        }
    } else {
        x = tryCatch(handler).call(receiver, value);
    }
    var promiseCreated = promise._popContext();
    bitField = promise._bitField;
    if (((bitField & 65536) !== 0)) return;

    if (x === NEXT_FILTER) {
        promise._reject(value);
    } else if (x === errorObj) {
        promise._rejectCallback(x.e, false);
    } else {
        debug.checkForgottenReturns(x, promiseCreated, "",  promise, this);
        promise._resolveCallback(x);
    }
};

Promise.prototype._target = function() {
    var ret = this;
    while (ret._isFollowing()) ret = ret._followee();
    return ret;
};

Promise.prototype._followee = function() {
    return this._rejectionHandler0;
};

Promise.prototype._setFollowee = function(promise) {
    this._rejectionHandler0 = promise;
};

Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
    var isPromise = promise instanceof Promise;
    var bitField = this._bitField;
    var asyncGuaranteed = ((bitField & 134217728) !== 0);
    if (((bitField & 65536) !== 0)) {
        if (isPromise) promise._invokeInternalOnCancel();

        if (receiver instanceof PassThroughHandlerContext &&
            receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise;
            if (tryCatch(handler).call(receiver, value) === errorObj) {
                promise._reject(errorObj.e);
            }
        } else if (handler === reflectHandler) {
            promise._fulfill(reflectHandler.call(receiver));
        } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
        } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
        } else {
            receiver.cancel();
        }
    } else if (typeof handler === "function") {
        if (!isPromise) {
            handler.call(receiver, value, promise);
        } else {
            if (asyncGuaranteed) promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (receiver instanceof Proxyable) {
        if (!receiver._isResolved()) {
            if (((bitField & 33554432) !== 0)) {
                receiver._promiseFulfilled(value, promise);
            } else {
                receiver._promiseRejected(value, promise);
            }
        }
    } else if (isPromise) {
        if (asyncGuaranteed) promise._setAsyncGuaranteed();
        if (((bitField & 33554432) !== 0)) {
            promise._fulfill(value);
        } else {
            promise._reject(value);
        }
    }
};

Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
    var handler = ctx.handler;
    var promise = ctx.promise;
    var receiver = ctx.receiver;
    var value = ctx.value;
    if (typeof handler === "function") {
        if (!(promise instanceof Promise)) {
            handler.call(receiver, value, promise);
        } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (promise instanceof Promise) {
        promise._reject(value);
    }
};

Promise.prototype._settlePromiseCtx = function(ctx) {
    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
};

Promise.prototype._settlePromise0 = function(handler, value, bitField) {
    var promise = this._promise0;
    var receiver = this._receiverAt(0);
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._settlePromise(promise, handler, receiver, value);
};

Promise.prototype._clearCallbackDataAtIndex = function(index) {
    var base = index * 4 - 4;
    this[base + 2] =
    this[base + 3] =
    this[base + 0] =
    this[base + 1] = undefined;
};

Promise.prototype._fulfill = function (value) {
    var bitField = this._bitField;
    if (((bitField & 117506048) >>> 16)) return;
    if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._reject(err);
    }
    this._setFulfilled();
    this._rejectionHandler0 = value;

    if ((bitField & 65535) > 0) {
        if (((bitField & 134217728) !== 0)) {
            this._settlePromises();
        } else {
            async.settlePromises(this);
        }
    }
};

Promise.prototype._reject = function (reason) {
    var bitField = this._bitField;
    if (((bitField & 117506048) >>> 16)) return;
    this._setRejected();
    this._fulfillmentHandler0 = reason;

    if (this._isFinal()) {
        return async.fatalError(reason, util.isNode);
    }

    if ((bitField & 65535) > 0) {
        async.settlePromises(this);
    } else {
        this._ensurePossibleRejectionHandled();
    }
};

Promise.prototype._fulfillPromises = function (len, value) {
    for (var i = 1; i < len; i++) {
        var handler = this._fulfillmentHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, value);
    }
};

Promise.prototype._rejectPromises = function (len, reason) {
    for (var i = 1; i < len; i++) {
        var handler = this._rejectionHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, reason);
    }
};

Promise.prototype._settlePromises = function () {
    var bitField = this._bitField;
    var len = (bitField & 65535);

    if (len > 0) {
        if (((bitField & 16842752) !== 0)) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
        } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
        }
        this._setLength(0);
    }
    this._clearCancellationData();
};

Promise.prototype._settledValue = function() {
    var bitField = this._bitField;
    if (((bitField & 33554432) !== 0)) {
        return this._rejectionHandler0;
    } else if (((bitField & 16777216) !== 0)) {
        return this._fulfillmentHandler0;
    }
};

function deferResolve(v) {this.promise._resolveCallback(v);}
function deferReject(v) {this.promise._rejectCallback(v, false);}

Promise.defer = Promise.pending = function() {
    debug.deprecated("Promise.defer", "new Promise");
    var promise = new Promise(INTERNAL);
    return {
        promise: promise,
        resolve: deferResolve,
        reject: deferReject
    };
};

util.notEnumerableProp(Promise,
                       "_makeSelfResolutionError",
                       makeSelfResolutionError);

_dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection,
    debug);
_dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);
_dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);
_dereq_("./direct_resolve")(Promise);
_dereq_("./synchronous_inspection")(Promise);
_dereq_("./join")(
    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
Promise.Promise = Promise;
Promise.version = "3.5.1";
                                                         
    util.toFastProperties(Promise);                                          
    util.toFastProperties(Promise.prototype);                                
    function fillTypes(value) {                                              
        var p = new Promise(INTERNAL);                                       
        p._fulfillmentHandler0 = value;                                      
        p._rejectionHandler0 = value;                                        
        p._promise0 = value;                                                 
        p._receiver0 = value;                                                
    }                                                                        
    // Complete slack tracking, opt out of field-type tracking and           
    // stabilize map                                                         
    fillTypes({a: 1});                                                       
    fillTypes({b: 2});                                                       
    fillTypes({c: 3});                                                       
    fillTypes(1);                                                            
    fillTypes(function(){});                                                 
    fillTypes(undefined);                                                    
    fillTypes(false);                                                        
    fillTypes(new Promise(INTERNAL));                                        
    debug.setBounds(Async.firstLineError, util.lastLineError);               
    return Promise;                                                          

};

},{"./async":1,"./bind":2,"./cancel":4,"./catch_filter":5,"./context":6,"./debuggability":7,"./direct_resolve":8,"./errors":9,"./es5":10,"./finally":11,"./join":12,"./method":13,"./nodeback":14,"./promise_array":16,"./synchronous_inspection":19,"./thenables":20,"./util":21}],16:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise,
    apiRejection, Proxyable) {
var util = _dereq_("./util");
var isArray = util.isArray;

function toResolutionValue(val) {
    switch(val) {
    case -2: return [];
    case -3: return {};
    case -6: return new Map();
    }
}

function PromiseArray(values) {
    var promise = this._promise = new Promise(INTERNAL);
    if (values instanceof Promise) {
        promise._propagateFrom(values, 3);
    }
    promise._setOnCancel(this);
    this._values = values;
    this._length = 0;
    this._totalResolved = 0;
    this._init(undefined, -2);
}
util.inherits(PromiseArray, Proxyable);

PromiseArray.prototype.length = function () {
    return this._length;
};

PromiseArray.prototype.promise = function () {
    return this._promise;
};

PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
    var values = tryConvertToPromise(this._values, this._promise);
    if (values instanceof Promise) {
        values = values._target();
        var bitField = values._bitField;
        ;
        this._values = values;

        if (((bitField & 50397184) === 0)) {
            this._promise._setAsyncGuaranteed();
            return values._then(
                init,
                this._reject,
                undefined,
                this,
                resolveValueIfEmpty
           );
        } else if (((bitField & 33554432) !== 0)) {
            values = values._value();
        } else if (((bitField & 16777216) !== 0)) {
            return this._reject(values._reason());
        } else {
            return this._cancel();
        }
    }
    values = util.asArray(values);
    if (values === null) {
        var err = apiRejection(
            "expecting an array or an iterable object but got " + util.classString(values)).reason();
        this._promise._rejectCallback(err, false);
        return;
    }

    if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
        }
        else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
    }
    this._iterate(values);
};

PromiseArray.prototype._iterate = function(values) {
    var len = this.getActualLength(values.length);
    this._length = len;
    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
    var result = this._promise;
    var isResolved = false;
    var bitField = null;
    for (var i = 0; i < len; ++i) {
        var maybePromise = tryConvertToPromise(values[i], result);

        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
        } else {
            bitField = null;
        }

        if (isResolved) {
            if (bitField !== null) {
                maybePromise.suppressUnhandledRejections();
            }
        } else if (bitField !== null) {
            if (((bitField & 50397184) === 0)) {
                maybePromise._proxy(this, i);
                this._values[i] = maybePromise;
            } else if (((bitField & 33554432) !== 0)) {
                isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if (((bitField & 16777216) !== 0)) {
                isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
                isResolved = this._promiseCancelled(i);
            }
        } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
        }
    }
    if (!isResolved) result._setAsyncGuaranteed();
};

PromiseArray.prototype._isResolved = function () {
    return this._values === null;
};

PromiseArray.prototype._resolve = function (value) {
    this._values = null;
    this._promise._fulfill(value);
};

PromiseArray.prototype._cancel = function() {
    if (this._isResolved() || !this._promise._isCancellable()) return;
    this._values = null;
    this._promise._cancel();
};

PromiseArray.prototype._reject = function (reason) {
    this._values = null;
    this._promise._rejectCallback(reason, false);
};

PromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
    }
    return false;
};

PromiseArray.prototype._promiseCancelled = function() {
    this._cancel();
    return true;
};

PromiseArray.prototype._promiseRejected = function (reason) {
    this._totalResolved++;
    this._reject(reason);
    return true;
};

PromiseArray.prototype._resultCancelled = function() {
    if (this._isResolved()) return;
    var values = this._values;
    this._cancel();
    if (values instanceof Promise) {
        values.cancel();
    } else {
        for (var i = 0; i < values.length; ++i) {
            if (values[i] instanceof Promise) {
                values[i].cancel();
            }
        }
    }
};

PromiseArray.prototype.shouldCopyValues = function () {
    return true;
};

PromiseArray.prototype.getActualLength = function (len) {
    return len;
};

return PromiseArray;
};

},{"./util":21}],17:[function(_dereq_,module,exports){
"use strict";
function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[(j + 0) & wrapMask] = fn;
    this[(j + 1) & wrapMask] = receiver;
    this[(j + 2) & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = (front + 1) & (this._capacity - 1);
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = (front + length) & (oldCapacity - 1);
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};

module.exports = Queue;

},{}],18:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util");
var schedule;
var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var NativePromise = util.getNativePromise();
if (util.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = global.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode
                ? function(fn) { GlobalSetImmediate.call(global, fn); }
                : function(fn) { ProcessNextTick.call(process, fn); };
} else if (typeof NativePromise === "function" &&
           typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
        nativePromise.then(fn);
    };
} else if ((typeof MutationObserver !== "undefined") &&
          !(typeof window !== "undefined" &&
            window.navigator &&
            (window.navigator.standalone || window.cordova))) {
    schedule = (function() {
        var div = document.createElement("div");
        var opts = {attributes: true};
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
            div.classList.toggle("foo");
            toggleScheduled = false;
        });
        o2.observe(div2, opts);

        var scheduleToggle = function() {
            if (toggleScheduled) return;
            toggleScheduled = true;
            div2.classList.toggle("foo");
        };

        return function schedule(fn) {
            var o = new MutationObserver(function() {
                o.disconnect();
                fn();
            });
            o.observe(div, opts);
            scheduleToggle();
        };
    })();
} else if (typeof setImmediate !== "undefined") {
    schedule = function (fn) {
        setImmediate(fn);
    };
} else if (typeof setTimeout !== "undefined") {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
} else {
    schedule = noAsyncScheduler;
}
module.exports = schedule;

},{"./util":21}],19:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function PromiseInspection(promise) {
    if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValueField = promise._isFateSealed()
            ? promise._settledValue() : undefined;
    }
    else {
        this._bitField = 0;
        this._settledValueField = undefined;
    }
}

PromiseInspection.prototype._settledValue = function() {
    return this._settledValueField;
};

var value = PromiseInspection.prototype.value = function () {
    if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    return this._settledValue();
};

var reason = PromiseInspection.prototype.error =
PromiseInspection.prototype.reason = function () {
    if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    return this._settledValue();
};

var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
    return (this._bitField & 33554432) !== 0;
};

var isRejected = PromiseInspection.prototype.isRejected = function () {
    return (this._bitField & 16777216) !== 0;
};

var isPending = PromiseInspection.prototype.isPending = function () {
    return (this._bitField & 50397184) === 0;
};

var isResolved = PromiseInspection.prototype.isResolved = function () {
    return (this._bitField & 50331648) !== 0;
};

PromiseInspection.prototype.isCancelled = function() {
    return (this._bitField & 8454144) !== 0;
};

Promise.prototype.__isCancelled = function() {
    return (this._bitField & 65536) === 65536;
};

Promise.prototype._isCancelled = function() {
    return this._target().__isCancelled();
};

Promise.prototype.isCancelled = function() {
    return (this._target()._bitField & 8454144) !== 0;
};

Promise.prototype.isPending = function() {
    return isPending.call(this._target());
};

Promise.prototype.isRejected = function() {
    return isRejected.call(this._target());
};

Promise.prototype.isFulfilled = function() {
    return isFulfilled.call(this._target());
};

Promise.prototype.isResolved = function() {
    return isResolved.call(this._target());
};

Promise.prototype.value = function() {
    return value.call(this._target());
};

Promise.prototype.reason = function() {
    var target = this._target();
    target._unsetRejectionIsUnhandled();
    return reason.call(target);
};

Promise.prototype._value = function() {
    return this._settledValue();
};

Promise.prototype._reason = function() {
    this._unsetRejectionIsUnhandled();
    return this._settledValue();
};

Promise.PromiseInspection = PromiseInspection;
};

},{}],20:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = _dereq_("./util");
var errorObj = util.errorObj;
var isObject = util.isObject;

function tryConvertToPromise(obj, context) {
    if (isObject(obj)) {
        if (obj instanceof Promise) return obj;
        var then = getThen(obj);
        if (then === errorObj) {
            if (context) context._pushContext();
            var ret = Promise.reject(then.e);
            if (context) context._popContext();
            return ret;
        } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj)) {
                var ret = new Promise(INTERNAL);
                obj._then(
                    ret._fulfill,
                    ret._reject,
                    undefined,
                    ret,
                    null
                );
                return ret;
            }
            return doThenable(obj, then, context);
        }
    }
    return obj;
}

function doGetThen(obj) {
    return obj.then;
}

function getThen(obj) {
    try {
        return doGetThen(obj);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

var hasProp = {}.hasOwnProperty;
function isAnyBluebirdPromise(obj) {
    try {
        return hasProp.call(obj, "_promise0");
    } catch (e) {
        return false;
    }
}

function doThenable(x, then, context) {
    var promise = new Promise(INTERNAL);
    var ret = promise;
    if (context) context._pushContext();
    promise._captureStackTrace();
    if (context) context._popContext();
    var synchronous = true;
    var result = util.tryCatch(then).call(x, resolve, reject);
    synchronous = false;

    if (promise && result === errorObj) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
    }

    function resolve(value) {
        if (!promise) return;
        promise._resolveCallback(value);
        promise = null;
    }

    function reject(reason) {
        if (!promise) return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
    }
    return ret;
}

return tryConvertToPromise;
};

},{"./util":21}],21:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5");
var canEvaluate = typeof navigator == "undefined";

var errorObj = {e: {}};
var tryCatchTarget;
var globalObject = typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    typeof global !== "undefined" ? global :
    this !== undefined ? this : null;

function tryCatcher() {
    try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) &&
                propertyName.charAt(propertyName.length-1) !== "$"
           ) {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};


function isPrimitive(val) {
    return val == null || val === true || val === false ||
        typeof val === "string" || typeof val === "number";

}

function isObject(value) {
    return typeof value === "function" ||
           typeof value === "object" && value !== null;
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);

        if (desc != null) {
            return desc.get == null && desc.set == null
                    ? desc.value
                    : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}

function thrower(r) {
    throw r;
}

var inheritedDataKeys = (function() {
    var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
    ];

    var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
                return true;
            }
        }
        return false;
    };

    if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) {
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null && !isExcludedProto(obj)) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj) {
            if (isExcludedProto(obj)) return [];
            var ret = [];

            /*jshint forin:false */
            enumeration: for (var key in obj) {
                if (hasProp.call(obj, key)) {
                    ret.push(key);
                } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                        if (hasProp.call(excludedPrototypes[i], key)) {
                            continue enumeration;
                        }
                    }
                    ret.push(key);
                }
            }
            return ret;
        };
    }

})();

var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.names(fn.prototype);

            var hasMethods = es5.isES5 && keys.length > 1;
            var hasMethodsOtherThanConstructor = keys.length > 0 &&
                !(keys.length === 1 && keys[0] === "constructor");
            var hasThisAssignmentAndStaticMethods =
                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

            if (hasMethods || hasMethodsOtherThanConstructor ||
                hasThisAssignmentAndStaticMethods) {
                return true;
            }
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027,-W055,-W031*/
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var l = 8;
    while (l--) new FakeConstructor();
    return obj;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for(var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + "";
    } catch (e) {
        return "[no string representation]";
    }
}

function isError(obj) {
    return obj instanceof Error ||
        (obj !== null &&
           typeof obj === "object" &&
           typeof obj.message === "string" &&
           typeof obj.name === "string");
}

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    }
    catch(ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
        e["isOperational"] === true);
}

function canAttachTrace(obj) {
    return isError(obj) && es5.propertyIsWritable(obj, "stack");
}

var ensureErrorObject = (function() {
    if (!("stack" in new Error())) {
        return function(value) {
            if (canAttachTrace(value)) return value;
            try {throw new Error(safeToString(value));}
            catch(err) {return err;}
        };
    } else {
        return function(value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
        };
    }
})();

function classString(obj) {
    return {}.toString.call(obj);
}

function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
            try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore) {}
        }
    }
}

var asArray = function(v) {
    if (es5.isArray(v)) {
        return v;
    }
    return null;
};

if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function(v) {
        return Array.from(v);
    } : function(v) {
        var ret = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!((itResult = it.next()).done)) {
            ret.push(itResult.value);
        }
        return ret;
    };

    asArray = function(v) {
        if (es5.isArray(v)) {
            return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
            return ArrayFrom(v);
        }
        return null;
    };
}

var isNode = typeof process !== "undefined" &&
        classString(process).toLowerCase() === "[object process]";

var hasEnvVariables = typeof process !== "undefined" &&
    typeof process.env !== "undefined";

function env(key) {
    return hasEnvVariables ? process.env[key] : undefined;
}

function getNativePromise() {
    if (typeof Promise === "function") {
        try {
            var promise = new Promise(function(){});
            if ({}.toString.call(promise) === "[object Promise]") {
                return Promise;
            }
        } catch (e) {}
    }
}

function domainBind(self, cb) {
    return self.bind(cb);
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    asArray: asArray,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    isError: isError,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome &&
                 typeof chrome.loadTimes === "function",
    isNode: isNode,
    hasEnvVariables: hasEnvVariables,
    env: env,
    global: globalObject,
    getNativePromise: getNativePromise,
    domainBind: domainBind
};
ret.isRecentNode = ret.isNode && (function() {
    var version = process.versions.node.split(".").map(Number);
    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
})();

if (ret.isNode) ret.toFastProperties(process);

try {throw new Error(); } catch (e) {ret.lastLineError = e;}
module.exports = ret;

},{"./es5":10}]},{},[3])(3)
});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
//Configure Bluebird Promises.
Promise.config({
  warnings: {
    wForgottenReturn: false
  }
});

/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.5 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.5',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));

_aureliaConfigureModuleLoader();
define('aurelia-binding/dist/commonjs/aurelia-binding',['require','exports','module','aurelia-logging','aurelia-pal','aurelia-task-queue','aurelia-metadata'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSetObserver = exports.BindingEngine = exports.NameExpression = exports.Listener = exports.ListenerExpression = exports.BindingBehaviorResource = exports.ValueConverterResource = exports.Call = exports.CallExpression = exports.Binding = exports.BindingExpression = exports.ObjectObservationAdapter = exports.ObserverLocator = exports.SVGAnalyzer = exports.presentationAttributes = exports.presentationElements = exports.elements = exports.ComputedExpression = exports.ClassObserver = exports.SelectValueObserver = exports.CheckedObserver = exports.ValueAttributeObserver = exports.StyleObserver = exports.DataAttributeObserver = exports.dataAttributeAccessor = exports.XLinkAttributeObserver = exports.SetterObserver = exports.PrimitiveObserver = exports.propertyAccessor = exports.DirtyCheckProperty = exports.DirtyChecker = exports.EventSubscriber = exports.EventManager = exports.delegationStrategy = exports.getMapObserver = exports.ParserImplementation = exports.Parser = exports.Scanner = exports.Lexer = exports.Token = exports.bindingMode = exports.ExpressionCloner = exports.Unparser = exports.LiteralObject = exports.LiteralArray = exports.LiteralString = exports.LiteralPrimitive = exports.PrefixNot = exports.Binary = exports.CallFunction = exports.CallMember = exports.CallScope = exports.AccessKeyed = exports.AccessMember = exports.AccessScope = exports.AccessThis = exports.Conditional = exports.Assign = exports.ValueConverter = exports.BindingBehavior = exports.Chain = exports.Expression = exports.getArrayObserver = exports.CollectionLengthObserver = exports.ModifyCollectionObserver = exports.ExpressionObserver = exports.sourceContext = exports.targetContext = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _dec2, _class, _dec3, _class2, _dec4, _class3, _dec5, _class5, _dec6, _class7, _dec7, _class8, _dec8, _class9, _dec9, _class10, _class12, _temp, _dec10, _class13, _class14, _temp2;

exports.camelCase = camelCase;
exports.createOverrideContext = createOverrideContext;
exports.getContextFor = getContextFor;
exports.createScopeForTest = createScopeForTest;
exports.connectable = connectable;
exports.enqueueBindingConnect = enqueueBindingConnect;
exports.subscriberCollection = subscriberCollection;
exports.calcSplices = calcSplices;
exports.mergeSplice = mergeSplice;
exports.projectArraySplices = projectArraySplices;
exports.getChangeRecords = getChangeRecords;
exports.cloneExpression = cloneExpression;
exports.hasDeclaredDependencies = hasDeclaredDependencies;
exports.declarePropertyDependencies = declarePropertyDependencies;
exports.computedFrom = computedFrom;
exports.createComputedObserver = createComputedObserver;
exports.valueConverter = valueConverter;
exports.bindingBehavior = bindingBehavior;
exports.observable = observable;
exports.connectBindingToSignal = connectBindingToSignal;
exports.signalBindings = signalBindings;

var _aureliaLogging = require('aurelia-logging');

var LogManager = _interopRequireWildcard(_aureliaLogging);

var _aureliaPal = require('aurelia-pal');

var _aureliaTaskQueue = require('aurelia-task-queue');

var _aureliaMetadata = require('aurelia-metadata');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var targetContext = exports.targetContext = 'Binding:target';
var sourceContext = exports.sourceContext = 'Binding:source';

var map = Object.create(null);

function camelCase(name) {
  if (name in map) {
    return map[name];
  }
  var result = name.charAt(0).toLowerCase() + name.slice(1).replace(/[_.-](\w|$)/g, function (_, x) {
    return x.toUpperCase();
  });
  map[name] = result;
  return result;
}

function createOverrideContext(bindingContext, parentOverrideContext) {
  return {
    bindingContext: bindingContext,
    parentOverrideContext: parentOverrideContext || null
  };
}

function getContextFor(name, scope, ancestor) {
  var oc = scope.overrideContext;

  if (ancestor) {
    while (ancestor && oc) {
      ancestor--;
      oc = oc.parentOverrideContext;
    }
    if (ancestor || !oc) {
      return undefined;
    }
    return name in oc ? oc : oc.bindingContext;
  }

  while (oc && !(name in oc) && !(oc.bindingContext && name in oc.bindingContext)) {
    oc = oc.parentOverrideContext;
  }
  if (oc) {
    return name in oc ? oc : oc.bindingContext;
  }

  return scope.bindingContext || scope.overrideContext;
}

function createScopeForTest(bindingContext, parentBindingContext) {
  if (parentBindingContext) {
    return {
      bindingContext: bindingContext,
      overrideContext: createOverrideContext(bindingContext, createOverrideContext(parentBindingContext))
    };
  }
  return {
    bindingContext: bindingContext,
    overrideContext: createOverrideContext(bindingContext)
  };
}

var slotNames = [];
var versionSlotNames = [];

for (var i = 0; i < 100; i++) {
  slotNames.push('_observer' + i);
  versionSlotNames.push('_observerVersion' + i);
}

function addObserver(observer) {
  var observerSlots = this._observerSlots === undefined ? 0 : this._observerSlots;
  var i = observerSlots;
  while (i-- && this[slotNames[i]] !== observer) {}

  if (i === -1) {
    i = 0;
    while (this[slotNames[i]]) {
      i++;
    }
    this[slotNames[i]] = observer;
    observer.subscribe(sourceContext, this);

    if (i === observerSlots) {
      this._observerSlots = i + 1;
    }
  }

  if (this._version === undefined) {
    this._version = 0;
  }
  this[versionSlotNames[i]] = this._version;
}

function observeProperty(obj, propertyName) {
  var observer = this.observerLocator.getObserver(obj, propertyName);
  addObserver.call(this, observer);
}

function observeArray(array) {
  var observer = this.observerLocator.getArrayObserver(array);
  addObserver.call(this, observer);
}

function unobserve(all) {
  var i = this._observerSlots;
  while (i--) {
    if (all || this[versionSlotNames[i]] !== this._version) {
      var observer = this[slotNames[i]];
      this[slotNames[i]] = null;
      if (observer) {
        observer.unsubscribe(sourceContext, this);
      }
    }
  }
}

function connectable() {
  return function (target) {
    target.prototype.observeProperty = observeProperty;
    target.prototype.observeArray = observeArray;
    target.prototype.unobserve = unobserve;
    target.prototype.addObserver = addObserver;
  };
}

var queue = [];
var queued = {};
var nextId = 0;
var minimumImmediate = 100;
var frameBudget = 15;

var isFlushRequested = false;
var immediate = 0;

function flush(animationFrameStart) {
  var length = queue.length;
  var i = 0;
  while (i < length) {
    var binding = queue[i];
    queued[binding.__connectQueueId] = false;
    binding.connect(true);
    i++;

    if (i % 100 === 0 && _aureliaPal.PLATFORM.performance.now() - animationFrameStart > frameBudget) {
      break;
    }
  }
  queue.splice(0, i);

  if (queue.length) {
    _aureliaPal.PLATFORM.requestAnimationFrame(flush);
  } else {
    isFlushRequested = false;
    immediate = 0;
  }
}

function enqueueBindingConnect(binding) {
  if (immediate < minimumImmediate) {
    immediate++;
    binding.connect(false);
  } else {
    var id = binding.__connectQueueId;
    if (id === undefined) {
      id = nextId;
      nextId++;
      binding.__connectQueueId = id;
    }

    if (!queued[id]) {
      queue.push(binding);
      queued[id] = true;
    }
  }
  if (!isFlushRequested) {
    isFlushRequested = true;
    _aureliaPal.PLATFORM.requestAnimationFrame(flush);
  }
}

function addSubscriber(context, callable) {
  if (this.hasSubscriber(context, callable)) {
    return false;
  }
  if (!this._context0) {
    this._context0 = context;
    this._callable0 = callable;
    return true;
  }
  if (!this._context1) {
    this._context1 = context;
    this._callable1 = callable;
    return true;
  }
  if (!this._context2) {
    this._context2 = context;
    this._callable2 = callable;
    return true;
  }
  if (!this._contextsRest) {
    this._contextsRest = [context];
    this._callablesRest = [callable];
    return true;
  }
  this._contextsRest.push(context);
  this._callablesRest.push(callable);
  return true;
}

function removeSubscriber(context, callable) {
  if (this._context0 === context && this._callable0 === callable) {
    this._context0 = null;
    this._callable0 = null;
    return true;
  }
  if (this._context1 === context && this._callable1 === callable) {
    this._context1 = null;
    this._callable1 = null;
    return true;
  }
  if (this._context2 === context && this._callable2 === callable) {
    this._context2 = null;
    this._callable2 = null;
    return true;
  }
  var callables = this._callablesRest;
  if (callables === undefined || callables.length === 0) {
    return false;
  }
  var contexts = this._contextsRest;
  var i = 0;
  while (!(callables[i] === callable && contexts[i] === context) && callables.length > i) {
    i++;
  }
  if (i >= callables.length) {
    return false;
  }
  contexts.splice(i, 1);
  callables.splice(i, 1);
  return true;
}

var arrayPool1 = [];
var arrayPool2 = [];
var poolUtilization = [];

function callSubscribers(newValue, oldValue) {
  var context0 = this._context0;
  var callable0 = this._callable0;
  var context1 = this._context1;
  var callable1 = this._callable1;
  var context2 = this._context2;
  var callable2 = this._callable2;
  var length = this._contextsRest ? this._contextsRest.length : 0;
  var contextsRest = void 0;
  var callablesRest = void 0;
  var poolIndex = void 0;
  var i = void 0;
  if (length) {
    poolIndex = poolUtilization.length;
    while (poolIndex-- && poolUtilization[poolIndex]) {}
    if (poolIndex < 0) {
      poolIndex = poolUtilization.length;
      contextsRest = [];
      callablesRest = [];
      poolUtilization.push(true);
      arrayPool1.push(contextsRest);
      arrayPool2.push(callablesRest);
    } else {
      poolUtilization[poolIndex] = true;
      contextsRest = arrayPool1[poolIndex];
      callablesRest = arrayPool2[poolIndex];
    }

    i = length;
    while (i--) {
      contextsRest[i] = this._contextsRest[i];
      callablesRest[i] = this._callablesRest[i];
    }
  }

  if (context0) {
    if (callable0) {
      callable0.call(context0, newValue, oldValue);
    } else {
      context0(newValue, oldValue);
    }
  }
  if (context1) {
    if (callable1) {
      callable1.call(context1, newValue, oldValue);
    } else {
      context1(newValue, oldValue);
    }
  }
  if (context2) {
    if (callable2) {
      callable2.call(context2, newValue, oldValue);
    } else {
      context2(newValue, oldValue);
    }
  }
  if (length) {
    for (i = 0; i < length; i++) {
      var callable = callablesRest[i];
      var context = contextsRest[i];
      if (callable) {
        callable.call(context, newValue, oldValue);
      } else {
        context(newValue, oldValue);
      }
      contextsRest[i] = null;
      callablesRest[i] = null;
    }
    poolUtilization[poolIndex] = false;
  }
}

function hasSubscribers() {
  return !!(this._context0 || this._context1 || this._context2 || this._contextsRest && this._contextsRest.length);
}

function hasSubscriber(context, callable) {
  var has = this._context0 === context && this._callable0 === callable || this._context1 === context && this._callable1 === callable || this._context2 === context && this._callable2 === callable;
  if (has) {
    return true;
  }
  var index = void 0;
  var contexts = this._contextsRest;
  if (!contexts || (index = contexts.length) === 0) {
    return false;
  }
  var callables = this._callablesRest;
  while (index--) {
    if (contexts[index] === context && callables[index] === callable) {
      return true;
    }
  }
  return false;
}

function subscriberCollection() {
  return function (target) {
    target.prototype.addSubscriber = addSubscriber;
    target.prototype.removeSubscriber = removeSubscriber;
    target.prototype.callSubscribers = callSubscribers;
    target.prototype.hasSubscribers = hasSubscribers;
    target.prototype.hasSubscriber = hasSubscriber;
  };
}

var ExpressionObserver = exports.ExpressionObserver = (_dec = connectable(), _dec2 = subscriberCollection(), _dec(_class = _dec2(_class = function () {
  function ExpressionObserver(scope, expression, observerLocator, lookupFunctions) {
    

    this.scope = scope;
    this.expression = expression;
    this.observerLocator = observerLocator;
    this.lookupFunctions = lookupFunctions;
  }

  ExpressionObserver.prototype.getValue = function getValue() {
    return this.expression.evaluate(this.scope, this.lookupFunctions);
  };

  ExpressionObserver.prototype.setValue = function setValue(newValue) {
    this.expression.assign(this.scope, newValue);
  };

  ExpressionObserver.prototype.subscribe = function subscribe(context, callable) {
    var _this = this;

    if (!this.hasSubscribers()) {
      this.oldValue = this.expression.evaluate(this.scope, this.lookupFunctions);
      this.expression.connect(this, this.scope);
    }
    this.addSubscriber(context, callable);
    if (arguments.length === 1 && context instanceof Function) {
      return {
        dispose: function dispose() {
          _this.unsubscribe(context, callable);
        }
      };
    }
  };

  ExpressionObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.unobserve(true);
      this.oldValue = undefined;
    }
  };

  ExpressionObserver.prototype.call = function call() {
    var newValue = this.expression.evaluate(this.scope, this.lookupFunctions);
    var oldValue = this.oldValue;
    if (newValue !== oldValue) {
      this.oldValue = newValue;
      this.callSubscribers(newValue, oldValue);
    }
    this._version++;
    this.expression.connect(this, this.scope);
    this.unobserve(false);
  };

  return ExpressionObserver;
}()) || _class) || _class);


function isIndex(s) {
  return +s === s >>> 0;
}

function toNumber(s) {
  return +s;
}

function newSplice(index, removed, addedCount) {
  return {
    index: index,
    removed: removed,
    addedCount: addedCount
  };
}

var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;

function ArraySplice() {}

ArraySplice.prototype = {
  calcEditDistances: function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    var rowCount = oldEnd - oldStart + 1;
    var columnCount = currentEnd - currentStart + 1;
    var distances = new Array(rowCount);
    var north = void 0;
    var west = void 0;

    for (var _i = 0; _i < rowCount; ++_i) {
      distances[_i] = new Array(columnCount);
      distances[_i][0] = _i;
    }

    for (var j = 0; j < columnCount; ++j) {
      distances[0][j] = j;
    }

    for (var _i2 = 1; _i2 < rowCount; ++_i2) {
      for (var _j = 1; _j < columnCount; ++_j) {
        if (this.equals(current[currentStart + _j - 1], old[oldStart + _i2 - 1])) {
          distances[_i2][_j] = distances[_i2 - 1][_j - 1];
        } else {
          north = distances[_i2 - 1][_j] + 1;
          west = distances[_i2][_j - 1] + 1;
          distances[_i2][_j] = north < west ? north : west;
        }
      }
    }

    return distances;
  },

  spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {
    var i = distances.length - 1;
    var j = distances[0].length - 1;
    var current = distances[i][j];
    var edits = [];
    while (i > 0 || j > 0) {
      if (i === 0) {
        edits.push(EDIT_ADD);
        j--;
        continue;
      }
      if (j === 0) {
        edits.push(EDIT_DELETE);
        i--;
        continue;
      }
      var northWest = distances[i - 1][j - 1];
      var west = distances[i - 1][j];
      var north = distances[i][j - 1];

      var min = void 0;
      if (west < north) {
        min = west < northWest ? west : northWest;
      } else {
        min = north < northWest ? north : northWest;
      }

      if (min === northWest) {
        if (northWest === current) {
          edits.push(EDIT_LEAVE);
        } else {
          edits.push(EDIT_UPDATE);
          current = northWest;
        }
        i--;
        j--;
      } else if (min === west) {
        edits.push(EDIT_DELETE);
        i--;
        current = west;
      } else {
        edits.push(EDIT_ADD);
        j--;
        current = north;
      }
    }

    edits.reverse();
    return edits;
  },

  calcSplices: function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    var prefixCount = 0;
    var suffixCount = 0;

    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
    if (currentStart === 0 && oldStart === 0) {
      prefixCount = this.sharedPrefix(current, old, minLength);
    }

    if (currentEnd === current.length && oldEnd === old.length) {
      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
    }

    currentStart += prefixCount;
    oldStart += prefixCount;
    currentEnd -= suffixCount;
    oldEnd -= suffixCount;

    if (currentEnd - currentStart === 0 && oldEnd - oldStart === 0) {
      return [];
    }

    if (currentStart === currentEnd) {
      var _splice = newSplice(currentStart, [], 0);
      while (oldStart < oldEnd) {
        _splice.removed.push(old[oldStart++]);
      }

      return [_splice];
    } else if (oldStart === oldEnd) {
      return [newSplice(currentStart, [], currentEnd - currentStart)];
    }

    var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

    var splice = undefined;
    var splices = [];
    var index = currentStart;
    var oldIndex = oldStart;
    for (var _i3 = 0; _i3 < ops.length; ++_i3) {
      switch (ops[_i3]) {
        case EDIT_LEAVE:
          if (splice) {
            splices.push(splice);
            splice = undefined;
          }

          index++;
          oldIndex++;
          break;
        case EDIT_UPDATE:
          if (!splice) {
            splice = newSplice(index, [], 0);
          }

          splice.addedCount++;
          index++;

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
        case EDIT_ADD:
          if (!splice) {
            splice = newSplice(index, [], 0);
          }

          splice.addedCount++;
          index++;
          break;
        case EDIT_DELETE:
          if (!splice) {
            splice = newSplice(index, [], 0);
          }

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
      }
    }

    if (splice) {
      splices.push(splice);
    }
    return splices;
  },

  sharedPrefix: function sharedPrefix(current, old, searchLength) {
    for (var _i4 = 0; _i4 < searchLength; ++_i4) {
      if (!this.equals(current[_i4], old[_i4])) {
        return _i4;
      }
    }

    return searchLength;
  },

  sharedSuffix: function sharedSuffix(current, old, searchLength) {
    var index1 = current.length;
    var index2 = old.length;
    var count = 0;
    while (count < searchLength && this.equals(current[--index1], old[--index2])) {
      count++;
    }

    return count;
  },

  calculateSplices: function calculateSplices(current, previous) {
    return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
  },

  equals: function equals(currentValue, previousValue) {
    return currentValue === previousValue;
  }
};

var arraySplice = new ArraySplice();

function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  return arraySplice.calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd);
}

function intersect(start1, end1, start2, end2) {
  if (end1 < start2 || end2 < start1) {
    return -1;
  }

  if (end1 === start2 || end2 === start1) {
    return 0;
  }

  if (start1 < start2) {
    if (end1 < end2) {
      return end1 - start2;
    }

    return end2 - start2;
  }

  if (end2 < end1) {
    return end2 - start1;
  }

  return end1 - start1;
}

function mergeSplice(splices, index, removed, addedCount) {
  var splice = newSplice(index, removed, addedCount);

  var inserted = false;
  var insertionOffset = 0;

  for (var _i5 = 0; _i5 < splices.length; _i5++) {
    var current = splices[_i5];
    current.index += insertionOffset;

    if (inserted) {
      continue;
    }

    var intersectCount = intersect(splice.index, splice.index + splice.removed.length, current.index, current.index + current.addedCount);

    if (intersectCount >= 0) {

      splices.splice(_i5, 1);
      _i5--;

      insertionOffset -= current.addedCount - current.removed.length;

      splice.addedCount += current.addedCount - intersectCount;
      var deleteCount = splice.removed.length + current.removed.length - intersectCount;

      if (!splice.addedCount && !deleteCount) {
        inserted = true;
      } else {
        var currentRemoved = current.removed;

        if (splice.index < current.index) {
          var prepend = splice.removed.slice(0, current.index - splice.index);
          Array.prototype.push.apply(prepend, currentRemoved);
          currentRemoved = prepend;
        }

        if (splice.index + splice.removed.length > current.index + current.addedCount) {
          var append = splice.removed.slice(current.index + current.addedCount - splice.index);
          Array.prototype.push.apply(currentRemoved, append);
        }

        splice.removed = currentRemoved;
        if (current.index < splice.index) {
          splice.index = current.index;
        }
      }
    } else if (splice.index < current.index) {

      inserted = true;

      splices.splice(_i5, 0, splice);
      _i5++;

      var offset = splice.addedCount - splice.removed.length;
      current.index += offset;
      insertionOffset += offset;
    }
  }

  if (!inserted) {
    splices.push(splice);
  }
}

function createInitialSplices(array, changeRecords) {
  var splices = [];

  for (var _i6 = 0; _i6 < changeRecords.length; _i6++) {
    var record = changeRecords[_i6];
    switch (record.type) {
      case 'splice':
        mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);
        break;
      case 'add':
      case 'update':
      case 'delete':
        if (!isIndex(record.name)) {
          continue;
        }

        var index = toNumber(record.name);
        if (index < 0) {
          continue;
        }

        mergeSplice(splices, index, [record.oldValue], record.type === 'delete' ? 0 : 1);
        break;
      default:
        console.error('Unexpected record type: ' + JSON.stringify(record));
        break;
    }
  }

  return splices;
}

function projectArraySplices(array, changeRecords) {
  var splices = [];

  createInitialSplices(array, changeRecords).forEach(function (splice) {
    if (splice.addedCount === 1 && splice.removed.length === 1) {
      if (splice.removed[0] !== array[splice.index]) {
        splices.push(splice);
      }

      return;
    }

    splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount, splice.removed, 0, splice.removed.length));
  });

  return splices;
}

function newRecord(type, object, key, oldValue) {
  return {
    type: type,
    object: object,
    key: key,
    oldValue: oldValue
  };
}

function getChangeRecords(map) {
  var entries = new Array(map.size);
  var keys = map.keys();
  var i = 0;
  var item = void 0;

  while (item = keys.next()) {
    if (item.done) {
      break;
    }

    entries[i] = newRecord('added', map, item.value);
    i++;
  }

  return entries;
}

var ModifyCollectionObserver = exports.ModifyCollectionObserver = (_dec3 = subscriberCollection(), _dec3(_class2 = function () {
  function ModifyCollectionObserver(taskQueue, collection) {
    

    this.taskQueue = taskQueue;
    this.queued = false;
    this.changeRecords = null;
    this.oldCollection = null;
    this.collection = collection;
    this.lengthPropertyName = collection instanceof Map || collection instanceof Set ? 'size' : 'length';
  }

  ModifyCollectionObserver.prototype.subscribe = function subscribe(context, callable) {
    this.addSubscriber(context, callable);
  };

  ModifyCollectionObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    this.removeSubscriber(context, callable);
  };

  ModifyCollectionObserver.prototype.addChangeRecord = function addChangeRecord(changeRecord) {
    if (!this.hasSubscribers() && !this.lengthObserver) {
      return;
    }

    if (changeRecord.type === 'splice') {
      var index = changeRecord.index;
      var arrayLength = changeRecord.object.length;
      if (index > arrayLength) {
        index = arrayLength - changeRecord.addedCount;
      } else if (index < 0) {
        index = arrayLength + changeRecord.removed.length + index - changeRecord.addedCount;
      }
      if (index < 0) {
        index = 0;
      }
      changeRecord.index = index;
    }

    if (this.changeRecords === null) {
      this.changeRecords = [changeRecord];
    } else {
      this.changeRecords.push(changeRecord);
    }

    if (!this.queued) {
      this.queued = true;
      this.taskQueue.queueMicroTask(this);
    }
  };

  ModifyCollectionObserver.prototype.flushChangeRecords = function flushChangeRecords() {
    if (this.changeRecords && this.changeRecords.length || this.oldCollection) {
      this.call();
    }
  };

  ModifyCollectionObserver.prototype.reset = function reset(oldCollection) {
    this.oldCollection = oldCollection;

    if (this.hasSubscribers() && !this.queued) {
      this.queued = true;
      this.taskQueue.queueMicroTask(this);
    }
  };

  ModifyCollectionObserver.prototype.getLengthObserver = function getLengthObserver() {
    return this.lengthObserver || (this.lengthObserver = new CollectionLengthObserver(this.collection));
  };

  ModifyCollectionObserver.prototype.call = function call() {
    var changeRecords = this.changeRecords;
    var oldCollection = this.oldCollection;
    var records = void 0;

    this.queued = false;
    this.changeRecords = [];
    this.oldCollection = null;

    if (this.hasSubscribers()) {
      if (oldCollection) {
        if (this.collection instanceof Map || this.collection instanceof Set) {
          records = getChangeRecords(oldCollection);
        } else {
          records = calcSplices(this.collection, 0, this.collection.length, oldCollection, 0, oldCollection.length);
        }
      } else {
        if (this.collection instanceof Map || this.collection instanceof Set) {
          records = changeRecords;
        } else {
          records = projectArraySplices(this.collection, changeRecords);
        }
      }

      this.callSubscribers(records);
    }

    if (this.lengthObserver) {
      this.lengthObserver.call(this.collection[this.lengthPropertyName]);
    }
  };

  return ModifyCollectionObserver;
}()) || _class2);
var CollectionLengthObserver = exports.CollectionLengthObserver = (_dec4 = subscriberCollection(), _dec4(_class3 = function () {
  function CollectionLengthObserver(collection) {
    

    this.collection = collection;
    this.lengthPropertyName = collection instanceof Map || collection instanceof Set ? 'size' : 'length';
    this.currentValue = collection[this.lengthPropertyName];
  }

  CollectionLengthObserver.prototype.getValue = function getValue() {
    return this.collection[this.lengthPropertyName];
  };

  CollectionLengthObserver.prototype.setValue = function setValue(newValue) {
    this.collection[this.lengthPropertyName] = newValue;
  };

  CollectionLengthObserver.prototype.subscribe = function subscribe(context, callable) {
    this.addSubscriber(context, callable);
  };

  CollectionLengthObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    this.removeSubscriber(context, callable);
  };

  CollectionLengthObserver.prototype.call = function call(newValue) {
    var oldValue = this.currentValue;
    this.callSubscribers(newValue, oldValue);
    this.currentValue = newValue;
  };

  return CollectionLengthObserver;
}()) || _class3);

var pop = Array.prototype.pop;
var push = Array.prototype.push;
var reverse = Array.prototype.reverse;
var shift = Array.prototype.shift;
var sort = Array.prototype.sort;
var splice = Array.prototype.splice;
var unshift = Array.prototype.unshift;

Array.prototype.pop = function () {
  var notEmpty = this.length > 0;
  var methodCallResult = pop.apply(this, arguments);
  if (notEmpty && this.__array_observer__ !== undefined) {
    this.__array_observer__.addChangeRecord({
      type: 'delete',
      object: this,
      name: this.length,
      oldValue: methodCallResult
    });
  }
  return methodCallResult;
};

Array.prototype.push = function () {
  var methodCallResult = push.apply(this, arguments);
  if (this.__array_observer__ !== undefined) {
    this.__array_observer__.addChangeRecord({
      type: 'splice',
      object: this,
      index: this.length - arguments.length,
      removed: [],
      addedCount: arguments.length
    });
  }
  return methodCallResult;
};

Array.prototype.reverse = function () {
  var oldArray = void 0;
  if (this.__array_observer__ !== undefined) {
    this.__array_observer__.flushChangeRecords();
    oldArray = this.slice();
  }
  var methodCallResult = reverse.apply(this, arguments);
  if (this.__array_observer__ !== undefined) {
    this.__array_observer__.reset(oldArray);
  }
  return methodCallResult;
};

Array.prototype.shift = function () {
  var notEmpty = this.length > 0;
  var methodCallResult = shift.apply(this, arguments);
  if (notEmpty && this.__array_observer__ !== undefined) {
    this.__array_observer__.addChangeRecord({
      type: 'delete',
      object: this,
      name: 0,
      oldValue: methodCallResult
    });
  }
  return methodCallResult;
};

Array.prototype.sort = function () {
  var oldArray = void 0;
  if (this.__array_observer__ !== undefined) {
    this.__array_observer__.flushChangeRecords();
    oldArray = this.slice();
  }
  var methodCallResult = sort.apply(this, arguments);
  if (this.__array_observer__ !== undefined) {
    this.__array_observer__.reset(oldArray);
  }
  return methodCallResult;
};

Array.prototype.splice = function () {
  var methodCallResult = splice.apply(this, arguments);
  if (this.__array_observer__ !== undefined) {
    this.__array_observer__.addChangeRecord({
      type: 'splice',
      object: this,
      index: +arguments[0],
      removed: methodCallResult,
      addedCount: arguments.length > 2 ? arguments.length - 2 : 0
    });
  }
  return methodCallResult;
};

Array.prototype.unshift = function () {
  var methodCallResult = unshift.apply(this, arguments);
  if (this.__array_observer__ !== undefined) {
    this.__array_observer__.addChangeRecord({
      type: 'splice',
      object: this,
      index: 0,
      removed: [],
      addedCount: arguments.length
    });
  }
  return methodCallResult;
};

function _getArrayObserver(taskQueue, array) {
  return ModifyArrayObserver.for(taskQueue, array);
}

exports.getArrayObserver = _getArrayObserver;

var ModifyArrayObserver = function (_ModifyCollectionObse) {
  _inherits(ModifyArrayObserver, _ModifyCollectionObse);

  function ModifyArrayObserver(taskQueue, array) {
    

    return _possibleConstructorReturn(this, _ModifyCollectionObse.call(this, taskQueue, array));
  }

  ModifyArrayObserver.for = function _for(taskQueue, array) {
    if (!('__array_observer__' in array)) {
      Reflect.defineProperty(array, '__array_observer__', {
        value: ModifyArrayObserver.create(taskQueue, array),
        enumerable: false, configurable: false
      });
    }
    return array.__array_observer__;
  };

  ModifyArrayObserver.create = function create(taskQueue, array) {
    return new ModifyArrayObserver(taskQueue, array);
  };

  return ModifyArrayObserver;
}(ModifyCollectionObserver);

var Expression = exports.Expression = function () {
  function Expression() {
    

    this.isChain = false;
    this.isAssignable = false;
  }

  Expression.prototype.evaluate = function evaluate(scope, lookupFunctions, args) {
    throw new Error('Binding expression "' + this + '" cannot be evaluated.');
  };

  Expression.prototype.assign = function assign(scope, value, lookupFunctions) {
    throw new Error('Binding expression "' + this + '" cannot be assigned to.');
  };

  Expression.prototype.toString = function toString() {
    return typeof FEATURE_NO_UNPARSER === 'undefined' ? _Unparser.unparse(this) : Function.prototype.toString.call(this);
  };

  return Expression;
}();

var Chain = exports.Chain = function (_Expression) {
  _inherits(Chain, _Expression);

  function Chain(expressions) {
    

    var _this3 = _possibleConstructorReturn(this, _Expression.call(this));

    _this3.expressions = expressions;
    _this3.isChain = true;
    return _this3;
  }

  Chain.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var result = void 0;
    var expressions = this.expressions;
    var last = void 0;

    for (var _i7 = 0, length = expressions.length; _i7 < length; ++_i7) {
      last = expressions[_i7].evaluate(scope, lookupFunctions);

      if (last !== null) {
        result = last;
      }
    }

    return result;
  };

  Chain.prototype.accept = function accept(visitor) {
    return visitor.visitChain(this);
  };

  return Chain;
}(Expression);

var BindingBehavior = exports.BindingBehavior = function (_Expression2) {
  _inherits(BindingBehavior, _Expression2);

  function BindingBehavior(expression, name, args) {
    

    var _this4 = _possibleConstructorReturn(this, _Expression2.call(this));

    _this4.expression = expression;
    _this4.name = name;
    _this4.args = args;
    return _this4;
  }

  BindingBehavior.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    return this.expression.evaluate(scope, lookupFunctions);
  };

  BindingBehavior.prototype.assign = function assign(scope, value, lookupFunctions) {
    return this.expression.assign(scope, value, lookupFunctions);
  };

  BindingBehavior.prototype.accept = function accept(visitor) {
    return visitor.visitBindingBehavior(this);
  };

  BindingBehavior.prototype.connect = function connect(binding, scope) {
    this.expression.connect(binding, scope);
  };

  BindingBehavior.prototype.bind = function bind(binding, scope, lookupFunctions) {
    if (this.expression.expression && this.expression.bind) {
      this.expression.bind(binding, scope, lookupFunctions);
    }
    var behavior = lookupFunctions.bindingBehaviors(this.name);
    if (!behavior) {
      throw new Error('No BindingBehavior named "' + this.name + '" was found!');
    }
    var behaviorKey = 'behavior-' + this.name;
    if (binding[behaviorKey]) {
      throw new Error('A binding behavior named "' + this.name + '" has already been applied to "' + this.expression + '"');
    }
    binding[behaviorKey] = behavior;
    behavior.bind.apply(behavior, [binding, scope].concat(evalList(scope, this.args, binding.lookupFunctions)));
  };

  BindingBehavior.prototype.unbind = function unbind(binding, scope) {
    var behaviorKey = 'behavior-' + this.name;
    binding[behaviorKey].unbind(binding, scope);
    binding[behaviorKey] = null;
    if (this.expression.expression && this.expression.unbind) {
      this.expression.unbind(binding, scope);
    }
  };

  return BindingBehavior;
}(Expression);

var ValueConverter = exports.ValueConverter = function (_Expression3) {
  _inherits(ValueConverter, _Expression3);

  function ValueConverter(expression, name, args, allArgs) {
    

    var _this5 = _possibleConstructorReturn(this, _Expression3.call(this));

    _this5.expression = expression;
    _this5.name = name;
    _this5.args = args;
    _this5.allArgs = allArgs;
    return _this5;
  }

  ValueConverter.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var converter = lookupFunctions.valueConverters(this.name);
    if (!converter) {
      throw new Error('No ValueConverter named "' + this.name + '" was found!');
    }

    if ('toView' in converter) {
      return converter.toView.apply(converter, evalList(scope, this.allArgs, lookupFunctions));
    }

    return this.allArgs[0].evaluate(scope, lookupFunctions);
  };

  ValueConverter.prototype.assign = function assign(scope, value, lookupFunctions) {
    var converter = lookupFunctions.valueConverters(this.name);
    if (!converter) {
      throw new Error('No ValueConverter named "' + this.name + '" was found!');
    }

    if ('fromView' in converter) {
      value = converter.fromView.apply(converter, [value].concat(evalList(scope, this.args, lookupFunctions)));
    }

    return this.allArgs[0].assign(scope, value, lookupFunctions);
  };

  ValueConverter.prototype.accept = function accept(visitor) {
    return visitor.visitValueConverter(this);
  };

  ValueConverter.prototype.connect = function connect(binding, scope) {
    var expressions = this.allArgs;
    var i = expressions.length;
    while (i--) {
      expressions[i].connect(binding, scope);
    }
    var converter = binding.lookupFunctions.valueConverters(this.name);
    if (!converter) {
      throw new Error('No ValueConverter named "' + this.name + '" was found!');
    }
    var signals = converter.signals;
    if (signals === undefined) {
      return;
    }
    i = signals.length;
    while (i--) {
      connectBindingToSignal(binding, signals[i]);
    }
  };

  return ValueConverter;
}(Expression);

var Assign = exports.Assign = function (_Expression4) {
  _inherits(Assign, _Expression4);

  function Assign(target, value) {
    

    var _this6 = _possibleConstructorReturn(this, _Expression4.call(this));

    _this6.target = target;
    _this6.value = value;
    _this6.isAssignable = true;
    return _this6;
  }

  Assign.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    return this.target.assign(scope, this.value.evaluate(scope, lookupFunctions));
  };

  Assign.prototype.accept = function accept(vistor) {
    vistor.visitAssign(this);
  };

  Assign.prototype.connect = function connect(binding, scope) {};

  Assign.prototype.assign = function assign(scope, value) {
    this.value.assign(scope, value);
    this.target.assign(scope, value);
  };

  return Assign;
}(Expression);

var Conditional = exports.Conditional = function (_Expression5) {
  _inherits(Conditional, _Expression5);

  function Conditional(condition, yes, no) {
    

    var _this7 = _possibleConstructorReturn(this, _Expression5.call(this));

    _this7.condition = condition;
    _this7.yes = yes;
    _this7.no = no;
    return _this7;
  }

  Conditional.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    return !!this.condition.evaluate(scope, lookupFunctions) ? this.yes.evaluate(scope, lookupFunctions) : this.no.evaluate(scope, lookupFunctions);
  };

  Conditional.prototype.accept = function accept(visitor) {
    return visitor.visitConditional(this);
  };

  Conditional.prototype.connect = function connect(binding, scope) {
    this.condition.connect(binding, scope);
    if (this.condition.evaluate(scope)) {
      this.yes.connect(binding, scope);
    } else {
      this.no.connect(binding, scope);
    }
  };

  return Conditional;
}(Expression);

var AccessThis = exports.AccessThis = function (_Expression6) {
  _inherits(AccessThis, _Expression6);

  function AccessThis(ancestor) {
    

    var _this8 = _possibleConstructorReturn(this, _Expression6.call(this));

    _this8.ancestor = ancestor;
    return _this8;
  }

  AccessThis.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var oc = scope.overrideContext;
    var i = this.ancestor;
    while (i-- && oc) {
      oc = oc.parentOverrideContext;
    }
    return i < 1 && oc ? oc.bindingContext : undefined;
  };

  AccessThis.prototype.accept = function accept(visitor) {
    return visitor.visitAccessThis(this);
  };

  AccessThis.prototype.connect = function connect(binding, scope) {};

  return AccessThis;
}(Expression);

var AccessScope = exports.AccessScope = function (_Expression7) {
  _inherits(AccessScope, _Expression7);

  function AccessScope(name, ancestor) {
    

    var _this9 = _possibleConstructorReturn(this, _Expression7.call(this));

    _this9.name = name;
    _this9.ancestor = ancestor;
    _this9.isAssignable = true;
    return _this9;
  }

  AccessScope.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var context = getContextFor(this.name, scope, this.ancestor);
    return context[this.name];
  };

  AccessScope.prototype.assign = function assign(scope, value) {
    var context = getContextFor(this.name, scope, this.ancestor);
    return context ? context[this.name] = value : undefined;
  };

  AccessScope.prototype.accept = function accept(visitor) {
    return visitor.visitAccessScope(this);
  };

  AccessScope.prototype.connect = function connect(binding, scope) {
    var context = getContextFor(this.name, scope, this.ancestor);
    binding.observeProperty(context, this.name);
  };

  return AccessScope;
}(Expression);

var AccessMember = exports.AccessMember = function (_Expression8) {
  _inherits(AccessMember, _Expression8);

  function AccessMember(object, name) {
    

    var _this10 = _possibleConstructorReturn(this, _Expression8.call(this));

    _this10.object = object;
    _this10.name = name;
    _this10.isAssignable = true;
    return _this10;
  }

  AccessMember.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var instance = this.object.evaluate(scope, lookupFunctions);
    return instance === null || instance === undefined ? instance : instance[this.name];
  };

  AccessMember.prototype.assign = function assign(scope, value) {
    var instance = this.object.evaluate(scope);

    if (instance === null || instance === undefined) {
      instance = {};
      this.object.assign(scope, instance);
    }

    instance[this.name] = value;
    return value;
  };

  AccessMember.prototype.accept = function accept(visitor) {
    return visitor.visitAccessMember(this);
  };

  AccessMember.prototype.connect = function connect(binding, scope) {
    this.object.connect(binding, scope);
    var obj = this.object.evaluate(scope);
    if (obj) {
      binding.observeProperty(obj, this.name);
    }
  };

  return AccessMember;
}(Expression);

var AccessKeyed = exports.AccessKeyed = function (_Expression9) {
  _inherits(AccessKeyed, _Expression9);

  function AccessKeyed(object, key) {
    

    var _this11 = _possibleConstructorReturn(this, _Expression9.call(this));

    _this11.object = object;
    _this11.key = key;
    _this11.isAssignable = true;
    return _this11;
  }

  AccessKeyed.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var instance = this.object.evaluate(scope, lookupFunctions);
    var lookup = this.key.evaluate(scope, lookupFunctions);
    return getKeyed(instance, lookup);
  };

  AccessKeyed.prototype.assign = function assign(scope, value) {
    var instance = this.object.evaluate(scope);
    var lookup = this.key.evaluate(scope);
    return setKeyed(instance, lookup, value);
  };

  AccessKeyed.prototype.accept = function accept(visitor) {
    return visitor.visitAccessKeyed(this);
  };

  AccessKeyed.prototype.connect = function connect(binding, scope) {
    this.object.connect(binding, scope);
    var obj = this.object.evaluate(scope);
    if (obj instanceof Object) {
      this.key.connect(binding, scope);
      var key = this.key.evaluate(scope);

      if (key !== null && key !== undefined && !(Array.isArray(obj) && typeof key === 'number')) {
        binding.observeProperty(obj, key);
      }
    }
  };

  return AccessKeyed;
}(Expression);

var CallScope = exports.CallScope = function (_Expression10) {
  _inherits(CallScope, _Expression10);

  function CallScope(name, args, ancestor) {
    

    var _this12 = _possibleConstructorReturn(this, _Expression10.call(this));

    _this12.name = name;
    _this12.args = args;
    _this12.ancestor = ancestor;
    return _this12;
  }

  CallScope.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
    var args = evalList(scope, this.args, lookupFunctions);
    var context = getContextFor(this.name, scope, this.ancestor);
    var func = getFunction(context, this.name, mustEvaluate);
    if (func) {
      return func.apply(context, args);
    }
    return undefined;
  };

  CallScope.prototype.accept = function accept(visitor) {
    return visitor.visitCallScope(this);
  };

  CallScope.prototype.connect = function connect(binding, scope) {
    var args = this.args;
    var i = args.length;
    while (i--) {
      args[i].connect(binding, scope);
    }
  };

  return CallScope;
}(Expression);

var CallMember = exports.CallMember = function (_Expression11) {
  _inherits(CallMember, _Expression11);

  function CallMember(object, name, args) {
    

    var _this13 = _possibleConstructorReturn(this, _Expression11.call(this));

    _this13.object = object;
    _this13.name = name;
    _this13.args = args;
    return _this13;
  }

  CallMember.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
    var instance = this.object.evaluate(scope, lookupFunctions);
    var args = evalList(scope, this.args, lookupFunctions);
    var func = getFunction(instance, this.name, mustEvaluate);
    if (func) {
      return func.apply(instance, args);
    }
    return undefined;
  };

  CallMember.prototype.accept = function accept(visitor) {
    return visitor.visitCallMember(this);
  };

  CallMember.prototype.connect = function connect(binding, scope) {
    this.object.connect(binding, scope);
    var obj = this.object.evaluate(scope);
    if (getFunction(obj, this.name, false)) {
      var args = this.args;
      var _i8 = args.length;
      while (_i8--) {
        args[_i8].connect(binding, scope);
      }
    }
  };

  return CallMember;
}(Expression);

var CallFunction = exports.CallFunction = function (_Expression12) {
  _inherits(CallFunction, _Expression12);

  function CallFunction(func, args) {
    

    var _this14 = _possibleConstructorReturn(this, _Expression12.call(this));

    _this14.func = func;
    _this14.args = args;
    return _this14;
  }

  CallFunction.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
    var func = this.func.evaluate(scope, lookupFunctions);
    if (typeof func === 'function') {
      return func.apply(null, evalList(scope, this.args, lookupFunctions));
    }
    if (!mustEvaluate && (func === null || func === undefined)) {
      return undefined;
    }
    throw new Error(this.func + ' is not a function');
  };

  CallFunction.prototype.accept = function accept(visitor) {
    return visitor.visitCallFunction(this);
  };

  CallFunction.prototype.connect = function connect(binding, scope) {
    this.func.connect(binding, scope);
    var func = this.func.evaluate(scope);
    if (typeof func === 'function') {
      var args = this.args;
      var _i9 = args.length;
      while (_i9--) {
        args[_i9].connect(binding, scope);
      }
    }
  };

  return CallFunction;
}(Expression);

var Binary = exports.Binary = function (_Expression13) {
  _inherits(Binary, _Expression13);

  function Binary(operation, left, right) {
    

    var _this15 = _possibleConstructorReturn(this, _Expression13.call(this));

    _this15.operation = operation;
    _this15.left = left;
    _this15.right = right;
    return _this15;
  }

  Binary.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var left = this.left.evaluate(scope, lookupFunctions);

    switch (this.operation) {
      case '&&':
        return left && this.right.evaluate(scope, lookupFunctions);
      case '||':
        return left || this.right.evaluate(scope, lookupFunctions);
    }

    var right = this.right.evaluate(scope, lookupFunctions);

    switch (this.operation) {
      case '==':
        return left == right;
      case '===':
        return left === right;
      case '!=':
        return left != right;
      case '!==':
        return left !== right;
    }

    if (left === null || right === null || left === undefined || right === undefined) {
      switch (this.operation) {
        case '+':
          if (left !== null && left !== undefined) return left;
          if (right !== null && right !== undefined) return right;
          return 0;
        case '-':
          if (left !== null && left !== undefined) return left;
          if (right !== null && right !== undefined) return 0 - right;
          return 0;
      }

      return null;
    }

    switch (this.operation) {
      case '+':
        return autoConvertAdd(left, right);
      case '-':
        return left - right;
      case '*':
        return left * right;
      case '/':
        return left / right;
      case '%':
        return left % right;
      case '<':
        return left < right;
      case '>':
        return left > right;
      case '<=':
        return left <= right;
      case '>=':
        return left >= right;
      case '^':
        return left ^ right;
    }

    throw new Error('Internal error [' + this.operation + '] not handled');
  };

  Binary.prototype.accept = function accept(visitor) {
    return visitor.visitBinary(this);
  };

  Binary.prototype.connect = function connect(binding, scope) {
    this.left.connect(binding, scope);
    var left = this.left.evaluate(scope);
    if (this.operation === '&&' && !left || this.operation === '||' && left) {
      return;
    }
    this.right.connect(binding, scope);
  };

  return Binary;
}(Expression);

var PrefixNot = exports.PrefixNot = function (_Expression14) {
  _inherits(PrefixNot, _Expression14);

  function PrefixNot(operation, expression) {
    

    var _this16 = _possibleConstructorReturn(this, _Expression14.call(this));

    _this16.operation = operation;
    _this16.expression = expression;
    return _this16;
  }

  PrefixNot.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    return !this.expression.evaluate(scope, lookupFunctions);
  };

  PrefixNot.prototype.accept = function accept(visitor) {
    return visitor.visitPrefix(this);
  };

  PrefixNot.prototype.connect = function connect(binding, scope) {
    this.expression.connect(binding, scope);
  };

  return PrefixNot;
}(Expression);

var LiteralPrimitive = exports.LiteralPrimitive = function (_Expression15) {
  _inherits(LiteralPrimitive, _Expression15);

  function LiteralPrimitive(value) {
    

    var _this17 = _possibleConstructorReturn(this, _Expression15.call(this));

    _this17.value = value;
    return _this17;
  }

  LiteralPrimitive.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    return this.value;
  };

  LiteralPrimitive.prototype.accept = function accept(visitor) {
    return visitor.visitLiteralPrimitive(this);
  };

  LiteralPrimitive.prototype.connect = function connect(binding, scope) {};

  return LiteralPrimitive;
}(Expression);

var LiteralString = exports.LiteralString = function (_Expression16) {
  _inherits(LiteralString, _Expression16);

  function LiteralString(value) {
    

    var _this18 = _possibleConstructorReturn(this, _Expression16.call(this));

    _this18.value = value;
    return _this18;
  }

  LiteralString.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    return this.value;
  };

  LiteralString.prototype.accept = function accept(visitor) {
    return visitor.visitLiteralString(this);
  };

  LiteralString.prototype.connect = function connect(binding, scope) {};

  return LiteralString;
}(Expression);

var LiteralArray = exports.LiteralArray = function (_Expression17) {
  _inherits(LiteralArray, _Expression17);

  function LiteralArray(elements) {
    

    var _this19 = _possibleConstructorReturn(this, _Expression17.call(this));

    _this19.elements = elements;
    return _this19;
  }

  LiteralArray.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var elements = this.elements;
    var result = [];

    for (var _i10 = 0, length = elements.length; _i10 < length; ++_i10) {
      result[_i10] = elements[_i10].evaluate(scope, lookupFunctions);
    }

    return result;
  };

  LiteralArray.prototype.accept = function accept(visitor) {
    return visitor.visitLiteralArray(this);
  };

  LiteralArray.prototype.connect = function connect(binding, scope) {
    var length = this.elements.length;
    for (var _i11 = 0; _i11 < length; _i11++) {
      this.elements[_i11].connect(binding, scope);
    }
  };

  return LiteralArray;
}(Expression);

var LiteralObject = exports.LiteralObject = function (_Expression18) {
  _inherits(LiteralObject, _Expression18);

  function LiteralObject(keys, values) {
    

    var _this20 = _possibleConstructorReturn(this, _Expression18.call(this));

    _this20.keys = keys;
    _this20.values = values;
    return _this20;
  }

  LiteralObject.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    var instance = {};
    var keys = this.keys;
    var values = this.values;

    for (var _i12 = 0, length = keys.length; _i12 < length; ++_i12) {
      instance[keys[_i12]] = values[_i12].evaluate(scope, lookupFunctions);
    }

    return instance;
  };

  LiteralObject.prototype.accept = function accept(visitor) {
    return visitor.visitLiteralObject(this);
  };

  LiteralObject.prototype.connect = function connect(binding, scope) {
    var length = this.keys.length;
    for (var _i13 = 0; _i13 < length; _i13++) {
      this.values[_i13].connect(binding, scope);
    }
  };

  return LiteralObject;
}(Expression);

function evalList(scope, list, lookupFunctions) {
  var length = list.length;
  var result = [];
  for (var _i14 = 0; _i14 < length; _i14++) {
    result[_i14] = list[_i14].evaluate(scope, lookupFunctions);
  }
  return result;
}

function autoConvertAdd(a, b) {
  if (a !== null && b !== null) {
    if (typeof a === 'string' && typeof b !== 'string') {
      return a + b.toString();
    }

    if (typeof a !== 'string' && typeof b === 'string') {
      return a.toString() + b;
    }

    return a + b;
  }

  if (a !== null) {
    return a;
  }

  if (b !== null) {
    return b;
  }

  return 0;
}

function getFunction(obj, name, mustExist) {
  var func = obj === null || obj === undefined ? null : obj[name];
  if (typeof func === 'function') {
    return func;
  }
  if (!mustExist && (func === null || func === undefined)) {
    return null;
  }
  throw new Error(name + ' is not a function');
}

function getKeyed(obj, key) {
  if (Array.isArray(obj)) {
    return obj[parseInt(key, 10)];
  } else if (obj) {
    return obj[key];
  } else if (obj === null || obj === undefined) {
    return undefined;
  }

  return obj[key];
}

function setKeyed(obj, key, value) {
  if (Array.isArray(obj)) {
    var index = parseInt(key, 10);

    if (obj.length <= index) {
      obj.length = index + 1;
    }

    obj[index] = value;
  } else {
    obj[key] = value;
  }

  return value;
}

var _Unparser = null;

exports.Unparser = _Unparser;
if (typeof FEATURE_NO_UNPARSER === 'undefined') {
  exports.Unparser = _Unparser = function () {
    function Unparser(buffer) {
      

      this.buffer = buffer;
    }

    Unparser.unparse = function unparse(expression) {
      var buffer = [];
      var visitor = new _Unparser(buffer);

      expression.accept(visitor);

      return buffer.join('');
    };

    Unparser.prototype.write = function write(text) {
      this.buffer.push(text);
    };

    Unparser.prototype.writeArgs = function writeArgs(args) {
      this.write('(');

      for (var _i15 = 0, length = args.length; _i15 < length; ++_i15) {
        if (_i15 !== 0) {
          this.write(',');
        }

        args[_i15].accept(this);
      }

      this.write(')');
    };

    Unparser.prototype.visitChain = function visitChain(chain) {
      var expressions = chain.expressions;

      for (var _i16 = 0, length = expressions.length; _i16 < length; ++_i16) {
        if (_i16 !== 0) {
          this.write(';');
        }

        expressions[_i16].accept(this);
      }
    };

    Unparser.prototype.visitBindingBehavior = function visitBindingBehavior(behavior) {
      var args = behavior.args;

      behavior.expression.accept(this);
      this.write('&' + behavior.name);

      for (var _i17 = 0, length = args.length; _i17 < length; ++_i17) {
        this.write(':');
        args[_i17].accept(this);
      }
    };

    Unparser.prototype.visitValueConverter = function visitValueConverter(converter) {
      var args = converter.args;

      converter.expression.accept(this);
      this.write('|' + converter.name);

      for (var _i18 = 0, length = args.length; _i18 < length; ++_i18) {
        this.write(':');
        args[_i18].accept(this);
      }
    };

    Unparser.prototype.visitAssign = function visitAssign(assign) {
      assign.target.accept(this);
      this.write('=');
      assign.value.accept(this);
    };

    Unparser.prototype.visitConditional = function visitConditional(conditional) {
      conditional.condition.accept(this);
      this.write('?');
      conditional.yes.accept(this);
      this.write(':');
      conditional.no.accept(this);
    };

    Unparser.prototype.visitAccessThis = function visitAccessThis(access) {
      if (access.ancestor === 0) {
        this.write('$this');
        return;
      }
      this.write('$parent');
      var i = access.ancestor - 1;
      while (i--) {
        this.write('.$parent');
      }
    };

    Unparser.prototype.visitAccessScope = function visitAccessScope(access) {
      var i = access.ancestor;
      while (i--) {
        this.write('$parent.');
      }
      this.write(access.name);
    };

    Unparser.prototype.visitAccessMember = function visitAccessMember(access) {
      access.object.accept(this);
      this.write('.' + access.name);
    };

    Unparser.prototype.visitAccessKeyed = function visitAccessKeyed(access) {
      access.object.accept(this);
      this.write('[');
      access.key.accept(this);
      this.write(']');
    };

    Unparser.prototype.visitCallScope = function visitCallScope(call) {
      var i = call.ancestor;
      while (i--) {
        this.write('$parent.');
      }
      this.write(call.name);
      this.writeArgs(call.args);
    };

    Unparser.prototype.visitCallFunction = function visitCallFunction(call) {
      call.func.accept(this);
      this.writeArgs(call.args);
    };

    Unparser.prototype.visitCallMember = function visitCallMember(call) {
      call.object.accept(this);
      this.write('.' + call.name);
      this.writeArgs(call.args);
    };

    Unparser.prototype.visitPrefix = function visitPrefix(prefix) {
      this.write('(' + prefix.operation);
      prefix.expression.accept(this);
      this.write(')');
    };

    Unparser.prototype.visitBinary = function visitBinary(binary) {
      binary.left.accept(this);
      this.write(binary.operation);
      binary.right.accept(this);
    };

    Unparser.prototype.visitLiteralPrimitive = function visitLiteralPrimitive(literal) {
      this.write('' + literal.value);
    };

    Unparser.prototype.visitLiteralArray = function visitLiteralArray(literal) {
      var elements = literal.elements;

      this.write('[');

      for (var _i19 = 0, length = elements.length; _i19 < length; ++_i19) {
        if (_i19 !== 0) {
          this.write(',');
        }

        elements[_i19].accept(this);
      }

      this.write(']');
    };

    Unparser.prototype.visitLiteralObject = function visitLiteralObject(literal) {
      var keys = literal.keys;
      var values = literal.values;

      this.write('{');

      for (var _i20 = 0, length = keys.length; _i20 < length; ++_i20) {
        if (_i20 !== 0) {
          this.write(',');
        }

        this.write('\'' + keys[_i20] + '\':');
        values[_i20].accept(this);
      }

      this.write('}');
    };

    Unparser.prototype.visitLiteralString = function visitLiteralString(literal) {
      var escaped = literal.value.replace(/'/g, "\'");
      this.write('\'' + escaped + '\'');
    };

    return Unparser;
  }();
}

var ExpressionCloner = exports.ExpressionCloner = function () {
  function ExpressionCloner() {
    
  }

  ExpressionCloner.prototype.cloneExpressionArray = function cloneExpressionArray(array) {
    var clonedArray = [];
    var i = array.length;
    while (i--) {
      clonedArray[i] = array[i].accept(this);
    }
    return clonedArray;
  };

  ExpressionCloner.prototype.visitChain = function visitChain(chain) {
    return new Chain(this.cloneExpressionArray(chain.expressions));
  };

  ExpressionCloner.prototype.visitBindingBehavior = function visitBindingBehavior(behavior) {
    return new BindingBehavior(behavior.expression.accept(this), behavior.name, this.cloneExpressionArray(behavior.args));
  };

  ExpressionCloner.prototype.visitValueConverter = function visitValueConverter(converter) {
    return new ValueConverter(converter.expression.accept(this), converter.name, this.cloneExpressionArray(converter.args));
  };

  ExpressionCloner.prototype.visitAssign = function visitAssign(assign) {
    return new Assign(assign.target.accept(this), assign.value.accept(this));
  };

  ExpressionCloner.prototype.visitConditional = function visitConditional(conditional) {
    return new Conditional(conditional.condition.accept(this), conditional.yes.accept(this), conditional.no.accept(this));
  };

  ExpressionCloner.prototype.visitAccessThis = function visitAccessThis(access) {
    return new AccessThis(access.ancestor);
  };

  ExpressionCloner.prototype.visitAccessScope = function visitAccessScope(access) {
    return new AccessScope(access.name, access.ancestor);
  };

  ExpressionCloner.prototype.visitAccessMember = function visitAccessMember(access) {
    return new AccessMember(access.object.accept(this), access.name);
  };

  ExpressionCloner.prototype.visitAccessKeyed = function visitAccessKeyed(access) {
    return new AccessKeyed(access.object.accept(this), access.key.accept(this));
  };

  ExpressionCloner.prototype.visitCallScope = function visitCallScope(call) {
    return new CallScope(call.name, this.cloneExpressionArray(call.args), call.ancestor);
  };

  ExpressionCloner.prototype.visitCallFunction = function visitCallFunction(call) {
    return new CallFunction(call.func.accept(this), this.cloneExpressionArray(call.args));
  };

  ExpressionCloner.prototype.visitCallMember = function visitCallMember(call) {
    return new CallMember(call.object.accept(this), call.name, this.cloneExpressionArray(call.args));
  };

  ExpressionCloner.prototype.visitPrefix = function visitPrefix(prefix) {
    return new PrefixNot(prefix.operation, prefix.expression.accept(this));
  };

  ExpressionCloner.prototype.visitBinary = function visitBinary(binary) {
    return new Binary(binary.operation, binary.left.accept(this), binary.right.accept(this));
  };

  ExpressionCloner.prototype.visitLiteralPrimitive = function visitLiteralPrimitive(literal) {
    return new LiteralPrimitive(literal);
  };

  ExpressionCloner.prototype.visitLiteralArray = function visitLiteralArray(literal) {
    return new LiteralArray(this.cloneExpressionArray(literal.elements));
  };

  ExpressionCloner.prototype.visitLiteralObject = function visitLiteralObject(literal) {
    return new LiteralObject(literal.keys, this.cloneExpressionArray(literal.values));
  };

  ExpressionCloner.prototype.visitLiteralString = function visitLiteralString(literal) {
    return new LiteralString(literal.value);
  };

  return ExpressionCloner;
}();

function cloneExpression(expression) {
  var visitor = new ExpressionCloner();
  return expression.accept(visitor);
}

var bindingMode = exports.bindingMode = {
  oneTime: 0,
  toView: 1,
  oneWay: 1,
  twoWay: 2,
  fromView: 3
};

var Token = exports.Token = function () {
  function Token(index, text) {
    

    this.index = index;
    this.text = text;
  }

  Token.prototype.withOp = function withOp(op) {
    this.opKey = op;
    return this;
  };

  Token.prototype.withGetterSetter = function withGetterSetter(key) {
    this.key = key;
    return this;
  };

  Token.prototype.withValue = function withValue(value) {
    this.value = value;
    return this;
  };

  Token.prototype.toString = function toString() {
    return 'Token(' + this.text + ')';
  };

  return Token;
}();

var Lexer = exports.Lexer = function () {
  function Lexer() {
    
  }

  Lexer.prototype.lex = function lex(text) {
    var scanner = new Scanner(text);
    var tokens = [];
    var token = scanner.scanToken();

    while (token) {
      tokens.push(token);
      token = scanner.scanToken();
    }

    return tokens;
  };

  return Lexer;
}();

var Scanner = exports.Scanner = function () {
  function Scanner(input) {
    

    this.input = input;
    this.length = input.length;
    this.peek = 0;
    this.index = -1;

    this.advance();
  }

  Scanner.prototype.scanToken = function scanToken() {
    while (this.peek <= $SPACE) {
      if (++this.index >= this.length) {
        this.peek = $EOF;
        return null;
      }

      this.peek = this.input.charCodeAt(this.index);
    }

    if (isIdentifierStart(this.peek)) {
      return this.scanIdentifier();
    }

    if (isDigit(this.peek)) {
      return this.scanNumber(this.index);
    }

    var start = this.index;

    switch (this.peek) {
      case $PERIOD:
        this.advance();
        return isDigit(this.peek) ? this.scanNumber(start) : new Token(start, '.');
      case $LPAREN:
      case $RPAREN:
      case $LBRACE:
      case $RBRACE:
      case $LBRACKET:
      case $RBRACKET:
      case $COMMA:
      case $COLON:
      case $SEMICOLON:
        return this.scanCharacter(start, String.fromCharCode(this.peek));
      case $SQ:
      case $DQ:
        return this.scanString();
      case $PLUS:
      case $MINUS:
      case $STAR:
      case $SLASH:
      case $PERCENT:
      case $CARET:
      case $QUESTION:
        return this.scanOperator(start, String.fromCharCode(this.peek));
      case $LT:
      case $GT:
      case $BANG:
      case $EQ:
        return this.scanComplexOperator(start, $EQ, String.fromCharCode(this.peek), '=');
      case $AMPERSAND:
        return this.scanComplexOperator(start, $AMPERSAND, '&', '&');
      case $BAR:
        return this.scanComplexOperator(start, $BAR, '|', '|');
      case $NBSP:
        while (isWhitespace(this.peek)) {
          this.advance();
        }

        return this.scanToken();
    }

    var character = String.fromCharCode(this.peek);
    this.error('Unexpected character [' + character + ']');
    return null;
  };

  Scanner.prototype.scanCharacter = function scanCharacter(start, text) {
    assert(this.peek === text.charCodeAt(0));
    this.advance();
    return new Token(start, text);
  };

  Scanner.prototype.scanOperator = function scanOperator(start, text) {
    assert(this.peek === text.charCodeAt(0));
    assert(OPERATORS[text] === 1);
    this.advance();
    return new Token(start, text).withOp(text);
  };

  Scanner.prototype.scanComplexOperator = function scanComplexOperator(start, code, one, two) {
    assert(this.peek === one.charCodeAt(0));
    this.advance();

    var text = one;

    if (this.peek === code) {
      this.advance();
      text += two;
    }

    if (this.peek === code) {
      this.advance();
      text += two;
    }

    assert(OPERATORS[text] === 1);

    return new Token(start, text).withOp(text);
  };

  Scanner.prototype.scanIdentifier = function scanIdentifier() {
    assert(isIdentifierStart(this.peek));
    var start = this.index;

    this.advance();

    while (isIdentifierPart(this.peek)) {
      this.advance();
    }

    var text = this.input.substring(start, this.index);
    var result = new Token(start, text);

    if (OPERATORS[text] === 1) {
      result.withOp(text);
    } else {
      result.withGetterSetter(text);
    }

    return result;
  };

  Scanner.prototype.scanNumber = function scanNumber(start) {
    assert(isDigit(this.peek));
    var simple = this.index === start;
    this.advance();

    while (true) {
      if (!isDigit(this.peek)) {
        if (this.peek === $PERIOD) {
          simple = false;
        } else if (isExponentStart(this.peek)) {
          this.advance();

          if (isExponentSign(this.peek)) {
            this.advance();
          }

          if (!isDigit(this.peek)) {
            this.error('Invalid exponent', -1);
          }

          simple = false;
        } else {
          break;
        }
      }

      this.advance();
    }

    var text = this.input.substring(start, this.index);
    var value = simple ? parseInt(text, 10) : parseFloat(text);
    return new Token(start, text).withValue(value);
  };

  Scanner.prototype.scanString = function scanString() {
    assert(this.peek === $SQ || this.peek === $DQ);

    var start = this.index;
    var quote = this.peek;

    this.advance();

    var buffer = void 0;
    var marker = this.index;

    while (this.peek !== quote) {
      if (this.peek === $BACKSLASH) {
        if (!buffer) {
          buffer = [];
        }

        buffer.push(this.input.substring(marker, this.index));
        this.advance();

        var _unescaped = void 0;

        if (this.peek === $u) {
          var hex = this.input.substring(this.index + 1, this.index + 5);

          if (!/[A-Z0-9]{4}/.test(hex)) {
            this.error('Invalid unicode escape [\\u' + hex + ']');
          }

          _unescaped = parseInt(hex, 16);

          for (var _i21 = 0; _i21 < 5; ++_i21) {
            this.advance();
          }
        } else {
          _unescaped = unescape(this.peek);
          this.advance();
        }

        buffer.push(String.fromCharCode(_unescaped));
        marker = this.index;
      } else if (this.peek === $EOF) {
        this.error('Unterminated quote');
      } else {
        this.advance();
      }
    }

    var last = this.input.substring(marker, this.index);
    this.advance();
    var text = this.input.substring(start, this.index);

    var unescaped = last;

    if (buffer !== null && buffer !== undefined) {
      buffer.push(last);
      unescaped = buffer.join('');
    }

    return new Token(start, text).withValue(unescaped);
  };

  Scanner.prototype.advance = function advance() {
    if (++this.index >= this.length) {
      this.peek = $EOF;
    } else {
      this.peek = this.input.charCodeAt(this.index);
    }
  };

  Scanner.prototype.error = function error(message) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var position = this.index + offset;
    throw new Error('Lexer Error: ' + message + ' at column ' + position + ' in expression [' + this.input + ']');
  };

  return Scanner;
}();

var OPERATORS = {
  'undefined': 1,
  'null': 1,
  'true': 1,
  'false': 1,
  '+': 1,
  '-': 1,
  '*': 1,
  '/': 1,
  '%': 1,
  '^': 1,
  '=': 1,
  '==': 1,
  '===': 1,
  '!=': 1,
  '!==': 1,
  '<': 1,
  '>': 1,
  '<=': 1,
  '>=': 1,
  '&&': 1,
  '||': 1,
  '&': 1,
  '|': 1,
  '!': 1,
  '?': 1
};

var $EOF = 0;
var $TAB = 9;
var $LF = 10;
var $VTAB = 11;
var $FF = 12;
var $CR = 13;
var $SPACE = 32;
var $BANG = 33;
var $DQ = 34;
var $$ = 36;
var $PERCENT = 37;
var $AMPERSAND = 38;
var $SQ = 39;
var $LPAREN = 40;
var $RPAREN = 41;
var $STAR = 42;
var $PLUS = 43;
var $COMMA = 44;
var $MINUS = 45;
var $PERIOD = 46;
var $SLASH = 47;
var $COLON = 58;
var $SEMICOLON = 59;
var $LT = 60;
var $EQ = 61;
var $GT = 62;
var $QUESTION = 63;

var $0 = 48;
var $9 = 57;

var $A = 65;
var $E = 69;
var $Z = 90;

var $LBRACKET = 91;
var $BACKSLASH = 92;
var $RBRACKET = 93;
var $CARET = 94;
var $_ = 95;

var $a = 97;
var $e = 101;
var $f = 102;
var $n = 110;
var $r = 114;
var $t = 116;
var $u = 117;
var $v = 118;
var $z = 122;

var $LBRACE = 123;
var $BAR = 124;
var $RBRACE = 125;
var $NBSP = 160;

function isWhitespace(code) {
  return code >= $TAB && code <= $SPACE || code === $NBSP;
}

function isIdentifierStart(code) {
  return $a <= code && code <= $z || $A <= code && code <= $Z || code === $_ || code === $$;
}

function isIdentifierPart(code) {
  return $a <= code && code <= $z || $A <= code && code <= $Z || $0 <= code && code <= $9 || code === $_ || code === $$;
}

function isDigit(code) {
  return $0 <= code && code <= $9;
}

function isExponentStart(code) {
  return code === $e || code === $E;
}

function isExponentSign(code) {
  return code === $MINUS || code === $PLUS;
}

function unescape(code) {
  switch (code) {
    case $n:
      return $LF;
    case $f:
      return $FF;
    case $r:
      return $CR;
    case $t:
      return $TAB;
    case $v:
      return $VTAB;
    default:
      return code;
  }
}

function assert(condition, message) {
  if (!condition) {
    throw message || 'Assertion failed';
  }
}

var EOF = new Token(-1, null);

var Parser = exports.Parser = function () {
  function Parser() {
    

    this.cache = {};
    this.lexer = new Lexer();
  }

  Parser.prototype.parse = function parse(input) {
    input = input || '';

    return this.cache[input] || (this.cache[input] = new ParserImplementation(this.lexer, input).parseChain());
  };

  return Parser;
}();

var ParserImplementation = exports.ParserImplementation = function () {
  function ParserImplementation(lexer, input) {
    

    this.index = 0;
    this.input = input;
    this.tokens = lexer.lex(input);
  }

  ParserImplementation.prototype.parseChain = function parseChain() {
    var isChain = false;
    var expressions = [];

    while (this.optional(';')) {
      isChain = true;
    }

    while (this.index < this.tokens.length) {
      if (this.peek.text === ')' || this.peek.text === '}' || this.peek.text === ']') {
        this.error('Unconsumed token ' + this.peek.text);
      }

      var expr = this.parseBindingBehavior();
      expressions.push(expr);

      while (this.optional(';')) {
        isChain = true;
      }

      if (isChain) {
        this.error('Multiple expressions are not allowed.');
      }
    }

    return expressions.length === 1 ? expressions[0] : new Chain(expressions);
  };

  ParserImplementation.prototype.parseBindingBehavior = function parseBindingBehavior() {
    var result = this.parseValueConverter();

    while (this.optional('&')) {
      var name = this.peek.text;
      var args = [];

      this.advance();

      while (this.optional(':')) {
        args.push(this.parseExpression());
      }

      result = new BindingBehavior(result, name, args);
    }

    return result;
  };

  ParserImplementation.prototype.parseValueConverter = function parseValueConverter() {
    var result = this.parseExpression();

    while (this.optional('|')) {
      var name = this.peek.text;
      var args = [];

      this.advance();

      while (this.optional(':')) {
        args.push(this.parseExpression());
      }

      result = new ValueConverter(result, name, args, [result].concat(args));
    }

    return result;
  };

  ParserImplementation.prototype.parseExpression = function parseExpression() {
    var start = this.peek.index;
    var result = this.parseConditional();

    while (this.peek.text === '=') {
      if (!result.isAssignable) {
        var end = this.index < this.tokens.length ? this.peek.index : this.input.length;
        var expression = this.input.substring(start, end);

        this.error('Expression ' + expression + ' is not assignable');
      }

      this.expect('=');
      result = new Assign(result, this.parseConditional());
    }

    return result;
  };

  ParserImplementation.prototype.parseConditional = function parseConditional() {
    var start = this.peek.index;
    var result = this.parseLogicalOr();

    if (this.optional('?')) {
      var yes = this.parseExpression();

      if (!this.optional(':')) {
        var end = this.index < this.tokens.length ? this.peek.index : this.input.length;
        var expression = this.input.substring(start, end);

        this.error('Conditional expression ' + expression + ' requires all 3 expressions');
      }

      var no = this.parseExpression();
      result = new Conditional(result, yes, no);
    }

    return result;
  };

  ParserImplementation.prototype.parseLogicalOr = function parseLogicalOr() {
    var result = this.parseLogicalAnd();

    while (this.optional('||')) {
      result = new Binary('||', result, this.parseLogicalAnd());
    }

    return result;
  };

  ParserImplementation.prototype.parseLogicalAnd = function parseLogicalAnd() {
    var result = this.parseEquality();

    while (this.optional('&&')) {
      result = new Binary('&&', result, this.parseEquality());
    }

    return result;
  };

  ParserImplementation.prototype.parseEquality = function parseEquality() {
    var result = this.parseRelational();

    while (true) {
      if (this.optional('==')) {
        result = new Binary('==', result, this.parseRelational());
      } else if (this.optional('!=')) {
        result = new Binary('!=', result, this.parseRelational());
      } else if (this.optional('===')) {
        result = new Binary('===', result, this.parseRelational());
      } else if (this.optional('!==')) {
        result = new Binary('!==', result, this.parseRelational());
      } else {
        return result;
      }
    }
  };

  ParserImplementation.prototype.parseRelational = function parseRelational() {
    var result = this.parseAdditive();

    while (true) {
      if (this.optional('<')) {
        result = new Binary('<', result, this.parseAdditive());
      } else if (this.optional('>')) {
        result = new Binary('>', result, this.parseAdditive());
      } else if (this.optional('<=')) {
        result = new Binary('<=', result, this.parseAdditive());
      } else if (this.optional('>=')) {
        result = new Binary('>=', result, this.parseAdditive());
      } else {
        return result;
      }
    }
  };

  ParserImplementation.prototype.parseAdditive = function parseAdditive() {
    var result = this.parseMultiplicative();

    while (true) {
      if (this.optional('+')) {
        result = new Binary('+', result, this.parseMultiplicative());
      } else if (this.optional('-')) {
        result = new Binary('-', result, this.parseMultiplicative());
      } else {
        return result;
      }
    }
  };

  ParserImplementation.prototype.parseMultiplicative = function parseMultiplicative() {
    var result = this.parsePrefix();

    while (true) {
      if (this.optional('*')) {
        result = new Binary('*', result, this.parsePrefix());
      } else if (this.optional('%')) {
        result = new Binary('%', result, this.parsePrefix());
      } else if (this.optional('/')) {
        result = new Binary('/', result, this.parsePrefix());
      } else {
        return result;
      }
    }
  };

  ParserImplementation.prototype.parsePrefix = function parsePrefix() {
    if (this.optional('+')) {
      return this.parsePrefix();
    } else if (this.optional('-')) {
      return new Binary('-', new LiteralPrimitive(0), this.parsePrefix());
    } else if (this.optional('!')) {
      return new PrefixNot('!', this.parsePrefix());
    }

    return this.parseAccessOrCallMember();
  };

  ParserImplementation.prototype.parseAccessOrCallMember = function parseAccessOrCallMember() {
    var result = this.parsePrimary();

    while (true) {
      if (this.optional('.')) {
        var name = this.peek.text;

        this.advance();

        if (this.optional('(')) {
          var args = this.parseExpressionList(')');
          this.expect(')');
          if (result instanceof AccessThis) {
            result = new CallScope(name, args, result.ancestor);
          } else {
            result = new CallMember(result, name, args);
          }
        } else {
          if (result instanceof AccessThis) {
            result = new AccessScope(name, result.ancestor);
          } else {
            result = new AccessMember(result, name);
          }
        }
      } else if (this.optional('[')) {
        var key = this.parseExpression();
        this.expect(']');
        result = new AccessKeyed(result, key);
      } else if (this.optional('(')) {
        var _args = this.parseExpressionList(')');
        this.expect(')');
        result = new CallFunction(result, _args);
      } else {
        return result;
      }
    }
  };

  ParserImplementation.prototype.parsePrimary = function parsePrimary() {
    if (this.optional('(')) {
      var result = this.parseExpression();
      this.expect(')');
      return result;
    } else if (this.optional('null')) {
      return new LiteralPrimitive(null);
    } else if (this.optional('undefined')) {
      return new LiteralPrimitive(undefined);
    } else if (this.optional('true')) {
      return new LiteralPrimitive(true);
    } else if (this.optional('false')) {
      return new LiteralPrimitive(false);
    } else if (this.optional('[')) {
      var _elements = this.parseExpressionList(']');
      this.expect(']');
      return new LiteralArray(_elements);
    } else if (this.peek.text === '{') {
      return this.parseObject();
    } else if (this.peek.key !== null && this.peek.key !== undefined) {
      return this.parseAccessOrCallScope();
    } else if (this.peek.value !== null && this.peek.value !== undefined) {
      var value = this.peek.value;
      this.advance();
      return value instanceof String || typeof value === 'string' ? new LiteralString(value) : new LiteralPrimitive(value);
    } else if (this.index >= this.tokens.length) {
      throw new Error('Unexpected end of expression: ' + this.input);
    } else {
      this.error('Unexpected token ' + this.peek.text);
    }
  };

  ParserImplementation.prototype.parseAccessOrCallScope = function parseAccessOrCallScope() {
    var name = this.peek.key;

    this.advance();

    if (name === '$this') {
      return new AccessThis(0);
    }

    var ancestor = 0;
    while (name === '$parent') {
      ancestor++;
      if (this.optional('.')) {
        name = this.peek.key;
        this.advance();
      } else if (this.peek === EOF || this.peek.text === '(' || this.peek.text === ')' || this.peek.text === '[' || this.peek.text === '}' || this.peek.text === ',' || this.peek.text === '|' || this.peek.text === '&') {
        return new AccessThis(ancestor);
      } else {
        this.error('Unexpected token ' + this.peek.text);
      }
    }

    if (this.optional('(')) {
      var args = this.parseExpressionList(')');
      this.expect(')');
      return new CallScope(name, args, ancestor);
    }

    return new AccessScope(name, ancestor);
  };

  ParserImplementation.prototype.parseObject = function parseObject() {
    var keys = [];
    var values = [];

    this.expect('{');

    if (this.peek.text !== '}') {
      do {
        var peek = this.peek;
        var value = peek.value;
        keys.push(typeof value === 'string' ? value : peek.text);

        this.advance();
        if (peek.key && (this.peek.text === ',' || this.peek.text === '}')) {
          --this.index;
          values.push(this.parseAccessOrCallScope());
        } else {
          this.expect(':');
          values.push(this.parseExpression());
        }
      } while (this.optional(','));
    }

    this.expect('}');

    return new LiteralObject(keys, values);
  };

  ParserImplementation.prototype.parseExpressionList = function parseExpressionList(terminator) {
    var result = [];

    if (this.peek.text !== terminator) {
      do {
        result.push(this.parseExpression());
      } while (this.optional(','));
    }

    return result;
  };

  ParserImplementation.prototype.optional = function optional(text) {
    if (this.peek.text === text) {
      this.advance();
      return true;
    }

    return false;
  };

  ParserImplementation.prototype.expect = function expect(text) {
    if (this.peek.text === text) {
      this.advance();
    } else {
      this.error('Missing expected ' + text);
    }
  };

  ParserImplementation.prototype.advance = function advance() {
    this.index++;
  };

  ParserImplementation.prototype.error = function error(message) {
    var location = this.index < this.tokens.length ? 'at column ' + (this.tokens[this.index].index + 1) + ' in' : 'at the end of the expression';

    throw new Error('Parser Error: ' + message + ' ' + location + ' [' + this.input + ']');
  };

  _createClass(ParserImplementation, [{
    key: 'peek',
    get: function get() {
      return this.index < this.tokens.length ? this.tokens[this.index] : EOF;
    }
  }]);

  return ParserImplementation;
}();

var mapProto = Map.prototype;

function _getMapObserver(taskQueue, map) {
  return ModifyMapObserver.for(taskQueue, map);
}

exports.getMapObserver = _getMapObserver;

var ModifyMapObserver = function (_ModifyCollectionObse2) {
  _inherits(ModifyMapObserver, _ModifyCollectionObse2);

  function ModifyMapObserver(taskQueue, map) {
    

    return _possibleConstructorReturn(this, _ModifyCollectionObse2.call(this, taskQueue, map));
  }

  ModifyMapObserver.for = function _for(taskQueue, map) {
    if (!('__map_observer__' in map)) {
      Reflect.defineProperty(map, '__map_observer__', {
        value: ModifyMapObserver.create(taskQueue, map),
        enumerable: false, configurable: false
      });
    }
    return map.__map_observer__;
  };

  ModifyMapObserver.create = function create(taskQueue, map) {
    var observer = new ModifyMapObserver(taskQueue, map);

    var proto = mapProto;
    if (proto.set !== map.set || proto.delete !== map.delete || proto.clear !== map.clear) {
      proto = {
        set: map.set,
        delete: map.delete,
        clear: map.clear
      };
    }

    map.set = function () {
      var hasValue = map.has(arguments[0]);
      var type = hasValue ? 'update' : 'add';
      var oldValue = map.get(arguments[0]);
      var methodCallResult = proto.set.apply(map, arguments);
      if (!hasValue || oldValue !== map.get(arguments[0])) {
        observer.addChangeRecord({
          type: type,
          object: map,
          key: arguments[0],
          oldValue: oldValue
        });
      }
      return methodCallResult;
    };

    map.delete = function () {
      var hasValue = map.has(arguments[0]);
      var oldValue = map.get(arguments[0]);
      var methodCallResult = proto.delete.apply(map, arguments);
      if (hasValue) {
        observer.addChangeRecord({
          type: 'delete',
          object: map,
          key: arguments[0],
          oldValue: oldValue
        });
      }
      return methodCallResult;
    };

    map.clear = function () {
      var methodCallResult = proto.clear.apply(map, arguments);
      observer.addChangeRecord({
        type: 'clear',
        object: map
      });
      return methodCallResult;
    };

    return observer;
  };

  return ModifyMapObserver;
}(ModifyCollectionObserver);

function findOriginalEventTarget(event) {
  return event.path && event.path[0] || event.deepPath && event.deepPath[0] || event.target;
}

function stopPropagation() {
  this.standardStopPropagation();
  this.propagationStopped = true;
}

function handleCapturedEvent(event) {
  event.propagationStopped = false;
  var target = findOriginalEventTarget(event);

  var orderedCallbacks = [];

  while (target) {
    if (target.capturedCallbacks) {
      var callback = target.capturedCallbacks[event.type];
      if (callback) {
        if (event.stopPropagation !== stopPropagation) {
          event.standardStopPropagation = event.stopPropagation;
          event.stopPropagation = stopPropagation;
        }
        orderedCallbacks.push(callback);
      }
    }
    target = target.parentNode;
  }
  for (var _i22 = orderedCallbacks.length - 1; _i22 >= 0 && !event.propagationStopped; _i22--) {
    var orderedCallback = orderedCallbacks[_i22];
    if ('handleEvent' in orderedCallback) {
      orderedCallback.handleEvent(event);
    } else {
      orderedCallback(event);
    }
  }
}

var CapturedHandlerEntry = function () {
  function CapturedHandlerEntry(eventName) {
    

    this.eventName = eventName;
    this.count = 0;
  }

  CapturedHandlerEntry.prototype.increment = function increment() {
    this.count++;

    if (this.count === 1) {
      _aureliaPal.DOM.addEventListener(this.eventName, handleCapturedEvent, true);
    }
  };

  CapturedHandlerEntry.prototype.decrement = function decrement() {
    this.count--;

    if (this.count === 0) {
      _aureliaPal.DOM.removeEventListener(this.eventName, handleCapturedEvent, true);
    }
  };

  return CapturedHandlerEntry;
}();

function handleDelegatedEvent(event) {
  event.propagationStopped = false;
  var target = findOriginalEventTarget(event);

  while (target && !event.propagationStopped) {
    if (target.delegatedCallbacks) {
      var callback = target.delegatedCallbacks[event.type];
      if (callback) {
        if (event.stopPropagation !== stopPropagation) {
          event.standardStopPropagation = event.stopPropagation;
          event.stopPropagation = stopPropagation;
        }
        if ('handleEvent' in callback) {
          callback.handleEvent(event);
        } else {
          callback(event);
        }
      }
    }

    target = target.parentNode;
  }
}

var DelegateHandlerEntry = function () {
  function DelegateHandlerEntry(eventName) {
    

    this.eventName = eventName;
    this.count = 0;
  }

  DelegateHandlerEntry.prototype.increment = function increment() {
    this.count++;

    if (this.count === 1) {
      _aureliaPal.DOM.addEventListener(this.eventName, handleDelegatedEvent, false);
    }
  };

  DelegateHandlerEntry.prototype.decrement = function decrement() {
    this.count--;

    if (this.count === 0) {
      _aureliaPal.DOM.removeEventListener(this.eventName, handleDelegatedEvent, false);
    }
  };

  return DelegateHandlerEntry;
}();

var DelegationEntryHandler = function () {
  function DelegationEntryHandler(entry, lookup, targetEvent) {
    

    this.entry = entry;
    this.lookup = lookup;
    this.targetEvent = targetEvent;
  }

  DelegationEntryHandler.prototype.dispose = function dispose() {
    this.entry.decrement();
    this.lookup[this.targetEvent] = null;
    this.entry = this.lookup = this.targetEvent = null;
  };

  return DelegationEntryHandler;
}();

var EventHandler = function () {
  function EventHandler(target, targetEvent, callback) {
    

    this.target = target;
    this.targetEvent = targetEvent;
    this.callback = callback;
  }

  EventHandler.prototype.dispose = function dispose() {
    this.target.removeEventListener(this.targetEvent, this.callback);
    this.target = this.targetEvent = this.callback = null;
  };

  return EventHandler;
}();

var DefaultEventStrategy = function () {
  function DefaultEventStrategy() {
    

    this.delegatedHandlers = {};
    this.capturedHandlers = {};
  }

  DefaultEventStrategy.prototype.subscribe = function subscribe(target, targetEvent, callback, strategy, disposable) {
    var delegatedHandlers = void 0;
    var capturedHandlers = void 0;
    var handlerEntry = void 0;

    if (strategy === delegationStrategy.bubbling) {
      delegatedHandlers = this.delegatedHandlers;
      handlerEntry = delegatedHandlers[targetEvent] || (delegatedHandlers[targetEvent] = new DelegateHandlerEntry(targetEvent));
      var delegatedCallbacks = target.delegatedCallbacks || (target.delegatedCallbacks = {});

      handlerEntry.increment();
      delegatedCallbacks[targetEvent] = callback;

      if (disposable === true) {
        return new DelegationEntryHandler(handlerEntry, delegatedCallbacks, targetEvent);
      }

      return function () {
        handlerEntry.decrement();
        delegatedCallbacks[targetEvent] = null;
      };
    }
    if (strategy === delegationStrategy.capturing) {
      capturedHandlers = this.capturedHandlers;
      handlerEntry = capturedHandlers[targetEvent] || (capturedHandlers[targetEvent] = new CapturedHandlerEntry(targetEvent));
      var capturedCallbacks = target.capturedCallbacks || (target.capturedCallbacks = {});

      handlerEntry.increment();
      capturedCallbacks[targetEvent] = callback;

      if (disposable === true) {
        return new DelegationEntryHandler(handlerEntry, capturedCallbacks, targetEvent);
      }

      return function () {
        handlerEntry.decrement();
        capturedCallbacks[targetEvent] = null;
      };
    }

    target.addEventListener(targetEvent, callback);

    if (disposable === true) {
      return new EventHandler(target, targetEvent, callback);
    }

    return function () {
      target.removeEventListener(targetEvent, callback);
    };
  };

  return DefaultEventStrategy;
}();

var delegationStrategy = exports.delegationStrategy = {
  none: 0,
  capturing: 1,
  bubbling: 2
};

var EventManager = exports.EventManager = function () {
  function EventManager() {
    

    this.elementHandlerLookup = {};
    this.eventStrategyLookup = {};

    this.registerElementConfig({
      tagName: 'input',
      properties: {
        value: ['change', 'input'],
        checked: ['change', 'input'],
        files: ['change', 'input']
      }
    });

    this.registerElementConfig({
      tagName: 'textarea',
      properties: {
        value: ['change', 'input']
      }
    });

    this.registerElementConfig({
      tagName: 'select',
      properties: {
        value: ['change']
      }
    });

    this.registerElementConfig({
      tagName: 'content editable',
      properties: {
        value: ['change', 'input', 'blur', 'keyup', 'paste']
      }
    });

    this.registerElementConfig({
      tagName: 'scrollable element',
      properties: {
        scrollTop: ['scroll'],
        scrollLeft: ['scroll']
      }
    });

    this.defaultEventStrategy = new DefaultEventStrategy();
  }

  EventManager.prototype.registerElementConfig = function registerElementConfig(config) {
    var tagName = config.tagName.toLowerCase();
    var properties = config.properties;
    var propertyName = void 0;

    var lookup = this.elementHandlerLookup[tagName] = {};

    for (propertyName in properties) {
      if (properties.hasOwnProperty(propertyName)) {
        lookup[propertyName] = properties[propertyName];
      }
    }
  };

  EventManager.prototype.registerEventStrategy = function registerEventStrategy(eventName, strategy) {
    this.eventStrategyLookup[eventName] = strategy;
  };

  EventManager.prototype.getElementHandler = function getElementHandler(target, propertyName) {
    var tagName = void 0;
    var lookup = this.elementHandlerLookup;

    if (target.tagName) {
      tagName = target.tagName.toLowerCase();

      if (lookup[tagName] && lookup[tagName][propertyName]) {
        return new EventSubscriber(lookup[tagName][propertyName]);
      }

      if (propertyName === 'textContent' || propertyName === 'innerHTML') {
        return new EventSubscriber(lookup['content editable'].value);
      }

      if (propertyName === 'scrollTop' || propertyName === 'scrollLeft') {
        return new EventSubscriber(lookup['scrollable element'][propertyName]);
      }
    }

    return null;
  };

  EventManager.prototype.addEventListener = function addEventListener(target, targetEvent, callbackOrListener, delegate, disposable) {
    return (this.eventStrategyLookup[targetEvent] || this.defaultEventStrategy).subscribe(target, targetEvent, callbackOrListener, delegate, disposable);
  };

  return EventManager;
}();

var EventSubscriber = exports.EventSubscriber = function () {
  function EventSubscriber(events) {
    

    this.events = events;
    this.element = null;
    this.handler = null;
  }

  EventSubscriber.prototype.subscribe = function subscribe(element, callbackOrListener) {
    this.element = element;
    this.handler = callbackOrListener;

    var events = this.events;
    for (var _i23 = 0, ii = events.length; ii > _i23; ++_i23) {
      element.addEventListener(events[_i23], callbackOrListener);
    }
  };

  EventSubscriber.prototype.dispose = function dispose() {
    if (this.element === null) {
      return;
    }
    var element = this.element;
    var callbackOrListener = this.handler;
    var events = this.events;
    for (var _i24 = 0, ii = events.length; ii > _i24; ++_i24) {
      element.removeEventListener(events[_i24], callbackOrListener);
    }
    this.element = this.handler = null;
  };

  return EventSubscriber;
}();

var DirtyChecker = exports.DirtyChecker = function () {
  function DirtyChecker() {
    

    this.tracked = [];
    this.checkDelay = 120;
  }

  DirtyChecker.prototype.addProperty = function addProperty(property) {
    var tracked = this.tracked;

    tracked.push(property);

    if (tracked.length === 1) {
      this.scheduleDirtyCheck();
    }
  };

  DirtyChecker.prototype.removeProperty = function removeProperty(property) {
    var tracked = this.tracked;
    tracked.splice(tracked.indexOf(property), 1);
  };

  DirtyChecker.prototype.scheduleDirtyCheck = function scheduleDirtyCheck() {
    var _this22 = this;

    setTimeout(function () {
      return _this22.check();
    }, this.checkDelay);
  };

  DirtyChecker.prototype.check = function check() {
    var tracked = this.tracked;
    var i = tracked.length;

    while (i--) {
      var current = tracked[i];

      if (current.isDirty()) {
        current.call();
      }
    }

    if (tracked.length) {
      this.scheduleDirtyCheck();
    }
  };

  return DirtyChecker;
}();

var DirtyCheckProperty = exports.DirtyCheckProperty = (_dec5 = subscriberCollection(), _dec5(_class5 = function () {
  function DirtyCheckProperty(dirtyChecker, obj, propertyName) {
    

    this.dirtyChecker = dirtyChecker;
    this.obj = obj;
    this.propertyName = propertyName;
  }

  DirtyCheckProperty.prototype.getValue = function getValue() {
    return this.obj[this.propertyName];
  };

  DirtyCheckProperty.prototype.setValue = function setValue(newValue) {
    this.obj[this.propertyName] = newValue;
  };

  DirtyCheckProperty.prototype.call = function call() {
    var oldValue = this.oldValue;
    var newValue = this.getValue();

    this.callSubscribers(newValue, oldValue);

    this.oldValue = newValue;
  };

  DirtyCheckProperty.prototype.isDirty = function isDirty() {
    return this.oldValue !== this.obj[this.propertyName];
  };

  DirtyCheckProperty.prototype.subscribe = function subscribe(context, callable) {
    if (!this.hasSubscribers()) {
      this.oldValue = this.getValue();
      this.dirtyChecker.addProperty(this);
    }
    this.addSubscriber(context, callable);
  };

  DirtyCheckProperty.prototype.unsubscribe = function unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.dirtyChecker.removeProperty(this);
    }
  };

  return DirtyCheckProperty;
}()) || _class5);


var logger = LogManager.getLogger('property-observation');

var propertyAccessor = exports.propertyAccessor = {
  getValue: function getValue(obj, propertyName) {
    return obj[propertyName];
  },
  setValue: function setValue(value, obj, propertyName) {
    obj[propertyName] = value;
  }
};

var PrimitiveObserver = exports.PrimitiveObserver = function () {
  function PrimitiveObserver(primitive, propertyName) {
    

    this.doNotCache = true;

    this.primitive = primitive;
    this.propertyName = propertyName;
  }

  PrimitiveObserver.prototype.getValue = function getValue() {
    return this.primitive[this.propertyName];
  };

  PrimitiveObserver.prototype.setValue = function setValue() {
    var type = _typeof(this.primitive);
    throw new Error('The ' + this.propertyName + ' property of a ' + type + ' (' + this.primitive + ') cannot be assigned.');
  };

  PrimitiveObserver.prototype.subscribe = function subscribe() {};

  PrimitiveObserver.prototype.unsubscribe = function unsubscribe() {};

  return PrimitiveObserver;
}();

var SetterObserver = exports.SetterObserver = (_dec6 = subscriberCollection(), _dec6(_class7 = function () {
  function SetterObserver(taskQueue, obj, propertyName) {
    

    this.taskQueue = taskQueue;
    this.obj = obj;
    this.propertyName = propertyName;
    this.queued = false;
    this.observing = false;
  }

  SetterObserver.prototype.getValue = function getValue() {
    return this.obj[this.propertyName];
  };

  SetterObserver.prototype.setValue = function setValue(newValue) {
    this.obj[this.propertyName] = newValue;
  };

  SetterObserver.prototype.getterValue = function getterValue() {
    return this.currentValue;
  };

  SetterObserver.prototype.setterValue = function setterValue(newValue) {
    var oldValue = this.currentValue;

    if (oldValue !== newValue) {
      if (!this.queued) {
        this.oldValue = oldValue;
        this.queued = true;
        this.taskQueue.queueMicroTask(this);
      }

      this.currentValue = newValue;
    }
  };

  SetterObserver.prototype.call = function call() {
    var oldValue = this.oldValue;
    var newValue = this.currentValue;

    this.queued = false;

    this.callSubscribers(newValue, oldValue);
  };

  SetterObserver.prototype.subscribe = function subscribe(context, callable) {
    if (!this.observing) {
      this.convertProperty();
    }
    this.addSubscriber(context, callable);
  };

  SetterObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    this.removeSubscriber(context, callable);
  };

  SetterObserver.prototype.convertProperty = function convertProperty() {
    this.observing = true;
    this.currentValue = this.obj[this.propertyName];
    this.setValue = this.setterValue;
    this.getValue = this.getterValue;

    if (!Reflect.defineProperty(this.obj, this.propertyName, {
      configurable: true,
      enumerable: this.propertyName in this.obj ? this.obj.propertyIsEnumerable(this.propertyName) : true,
      get: this.getValue.bind(this),
      set: this.setValue.bind(this)
    })) {
      logger.warn('Cannot observe property \'' + this.propertyName + '\' of object', this.obj);
    }
  };

  return SetterObserver;
}()) || _class7);

var XLinkAttributeObserver = exports.XLinkAttributeObserver = function () {
  function XLinkAttributeObserver(element, propertyName, attributeName) {
    

    this.element = element;
    this.propertyName = propertyName;
    this.attributeName = attributeName;
  }

  XLinkAttributeObserver.prototype.getValue = function getValue() {
    return this.element.getAttributeNS('http://www.w3.org/1999/xlink', this.attributeName);
  };

  XLinkAttributeObserver.prototype.setValue = function setValue(newValue) {
    return this.element.setAttributeNS('http://www.w3.org/1999/xlink', this.attributeName, newValue);
  };

  XLinkAttributeObserver.prototype.subscribe = function subscribe() {
    throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
  };

  return XLinkAttributeObserver;
}();

var dataAttributeAccessor = exports.dataAttributeAccessor = {
  getValue: function getValue(obj, propertyName) {
    return obj.getAttribute(propertyName);
  },
  setValue: function setValue(value, obj, propertyName) {
    if (value === null || value === undefined) {
      obj.removeAttribute(propertyName);
    } else {
      obj.setAttribute(propertyName, value);
    }
  }
};

var DataAttributeObserver = exports.DataAttributeObserver = function () {
  function DataAttributeObserver(element, propertyName) {
    

    this.element = element;
    this.propertyName = propertyName;
  }

  DataAttributeObserver.prototype.getValue = function getValue() {
    return this.element.getAttribute(this.propertyName);
  };

  DataAttributeObserver.prototype.setValue = function setValue(newValue) {
    if (newValue === null || newValue === undefined) {
      return this.element.removeAttribute(this.propertyName);
    }
    return this.element.setAttribute(this.propertyName, newValue);
  };

  DataAttributeObserver.prototype.subscribe = function subscribe() {
    throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
  };

  return DataAttributeObserver;
}();

var StyleObserver = exports.StyleObserver = function () {
  function StyleObserver(element, propertyName) {
    

    this.element = element;
    this.propertyName = propertyName;

    this.styles = null;
    this.version = 0;
  }

  StyleObserver.prototype.getValue = function getValue() {
    return this.element.style.cssText;
  };

  StyleObserver.prototype._setProperty = function _setProperty(style, value) {
    var priority = '';

    if (value !== null && value !== undefined && typeof value.indexOf === 'function' && value.indexOf('!important') !== -1) {
      priority = 'important';
      value = value.replace('!important', '');
    }
    this.element.style.setProperty(style, value, priority);
  };

  StyleObserver.prototype.setValue = function setValue(newValue) {
    var styles = this.styles || {};
    var style = void 0;
    var version = this.version;

    if (newValue !== null && newValue !== undefined) {
      if (newValue instanceof Object) {
        var value = void 0;
        for (style in newValue) {
          if (newValue.hasOwnProperty(style)) {
            value = newValue[style];
            style = style.replace(/([A-Z])/g, function (m) {
              return '-' + m.toLowerCase();
            });
            styles[style] = version;
            this._setProperty(style, value);
          }
        }
      } else if (newValue.length) {
        var rx = /\s*([\w\-]+)\s*:\s*((?:(?:[\w\-]+\(\s*(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[\w\-]+\(\s*(?:^"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^\)]*)\),?|[^\)]*)\),?|"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^;]*),?\s*)+);?/g;
        var pair = void 0;
        while ((pair = rx.exec(newValue)) !== null) {
          style = pair[1];
          if (!style) {
            continue;
          }

          styles[style] = version;
          this._setProperty(style, pair[2]);
        }
      }
    }

    this.styles = styles;
    this.version += 1;

    if (version === 0) {
      return;
    }

    version -= 1;
    for (style in styles) {
      if (!styles.hasOwnProperty(style) || styles[style] !== version) {
        continue;
      }

      this.element.style.removeProperty(style);
    }
  };

  StyleObserver.prototype.subscribe = function subscribe() {
    throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
  };

  return StyleObserver;
}();

var ValueAttributeObserver = exports.ValueAttributeObserver = (_dec7 = subscriberCollection(), _dec7(_class8 = function () {
  function ValueAttributeObserver(element, propertyName, handler) {
    

    this.element = element;
    this.propertyName = propertyName;
    this.handler = handler;
    if (propertyName === 'files') {
      this.setValue = function () {};
    }
  }

  ValueAttributeObserver.prototype.getValue = function getValue() {
    return this.element[this.propertyName];
  };

  ValueAttributeObserver.prototype.setValue = function setValue(newValue) {
    newValue = newValue === undefined || newValue === null ? '' : newValue;
    if (this.element[this.propertyName] !== newValue) {
      this.element[this.propertyName] = newValue;
      this.notify();
    }
  };

  ValueAttributeObserver.prototype.notify = function notify() {
    var oldValue = this.oldValue;
    var newValue = this.getValue();

    this.callSubscribers(newValue, oldValue);

    this.oldValue = newValue;
  };

  ValueAttributeObserver.prototype.handleEvent = function handleEvent() {
    this.notify();
  };

  ValueAttributeObserver.prototype.subscribe = function subscribe(context, callable) {
    if (!this.hasSubscribers()) {
      this.oldValue = this.getValue();
      this.handler.subscribe(this.element, this);
    }

    this.addSubscriber(context, callable);
  };

  ValueAttributeObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.handler.dispose();
    }
  };

  return ValueAttributeObserver;
}()) || _class8);


var checkedArrayContext = 'CheckedObserver:array';
var checkedValueContext = 'CheckedObserver:value';

var CheckedObserver = exports.CheckedObserver = (_dec8 = subscriberCollection(), _dec8(_class9 = function () {
  function CheckedObserver(element, handler, observerLocator) {
    

    this.element = element;
    this.handler = handler;
    this.observerLocator = observerLocator;
  }

  CheckedObserver.prototype.getValue = function getValue() {
    return this.value;
  };

  CheckedObserver.prototype.setValue = function setValue(newValue) {
    if (this.initialSync && this.value === newValue) {
      return;
    }

    if (this.arrayObserver) {
      this.arrayObserver.unsubscribe(checkedArrayContext, this);
      this.arrayObserver = null;
    }

    if (this.element.type === 'checkbox' && Array.isArray(newValue)) {
      this.arrayObserver = this.observerLocator.getArrayObserver(newValue);
      this.arrayObserver.subscribe(checkedArrayContext, this);
    }

    this.oldValue = this.value;
    this.value = newValue;
    this.synchronizeElement();
    this.notify();

    if (!this.initialSync) {
      this.initialSync = true;
      this.observerLocator.taskQueue.queueMicroTask(this);
    }
  };

  CheckedObserver.prototype.call = function call(context, splices) {
    this.synchronizeElement();

    if (!this.valueObserver) {
      this.valueObserver = this.element.__observers__.model || this.element.__observers__.value;
      if (this.valueObserver) {
        this.valueObserver.subscribe(checkedValueContext, this);
      }
    }
  };

  CheckedObserver.prototype.synchronizeElement = function synchronizeElement() {
    var value = this.value;
    var element = this.element;
    var elementValue = element.hasOwnProperty('model') ? element.model : element.value;
    var isRadio = element.type === 'radio';
    var matcher = element.matcher || function (a, b) {
      return a === b;
    };

    element.checked = isRadio && !!matcher(value, elementValue) || !isRadio && value === true || !isRadio && Array.isArray(value) && value.findIndex(function (item) {
      return !!matcher(item, elementValue);
    }) !== -1;
  };

  CheckedObserver.prototype.synchronizeValue = function synchronizeValue() {
    var value = this.value;
    var element = this.element;
    var elementValue = element.hasOwnProperty('model') ? element.model : element.value;
    var index = void 0;
    var matcher = element.matcher || function (a, b) {
      return a === b;
    };

    if (element.type === 'checkbox') {
      if (Array.isArray(value)) {
        index = value.findIndex(function (item) {
          return !!matcher(item, elementValue);
        });
        if (element.checked && index === -1) {
          value.push(elementValue);
        } else if (!element.checked && index !== -1) {
          value.splice(index, 1);
        }

        return;
      }

      value = element.checked;
    } else if (element.checked) {
      value = elementValue;
    } else {
      return;
    }

    this.oldValue = this.value;
    this.value = value;
    this.notify();
  };

  CheckedObserver.prototype.notify = function notify() {
    var oldValue = this.oldValue;
    var newValue = this.value;

    if (newValue === oldValue) {
      return;
    }

    this.callSubscribers(newValue, oldValue);
  };

  CheckedObserver.prototype.handleEvent = function handleEvent() {
    this.synchronizeValue();
  };

  CheckedObserver.prototype.subscribe = function subscribe(context, callable) {
    if (!this.hasSubscribers()) {
      this.handler.subscribe(this.element, this);
    }
    this.addSubscriber(context, callable);
  };

  CheckedObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.handler.dispose();
    }
  };

  CheckedObserver.prototype.unbind = function unbind() {
    if (this.arrayObserver) {
      this.arrayObserver.unsubscribe(checkedArrayContext, this);
      this.arrayObserver = null;
    }
    if (this.valueObserver) {
      this.valueObserver.unsubscribe(checkedValueContext, this);
    }
  };

  return CheckedObserver;
}()) || _class9);


var selectArrayContext = 'SelectValueObserver:array';

var SelectValueObserver = exports.SelectValueObserver = (_dec9 = subscriberCollection(), _dec9(_class10 = function () {
  function SelectValueObserver(element, handler, observerLocator) {
    

    this.element = element;
    this.handler = handler;
    this.observerLocator = observerLocator;
  }

  SelectValueObserver.prototype.getValue = function getValue() {
    return this.value;
  };

  SelectValueObserver.prototype.setValue = function setValue(newValue) {
    if (newValue !== null && newValue !== undefined && this.element.multiple && !Array.isArray(newValue)) {
      throw new Error('Only null or Array instances can be bound to a multi-select.');
    }
    if (this.value === newValue) {
      return;
    }

    if (this.arrayObserver) {
      this.arrayObserver.unsubscribe(selectArrayContext, this);
      this.arrayObserver = null;
    }

    if (Array.isArray(newValue)) {
      this.arrayObserver = this.observerLocator.getArrayObserver(newValue);
      this.arrayObserver.subscribe(selectArrayContext, this);
    }

    this.oldValue = this.value;
    this.value = newValue;
    this.synchronizeOptions();
    this.notify();

    if (!this.initialSync) {
      this.initialSync = true;
      this.observerLocator.taskQueue.queueMicroTask(this);
    }
  };

  SelectValueObserver.prototype.call = function call(context, splices) {
    this.synchronizeOptions();
  };

  SelectValueObserver.prototype.synchronizeOptions = function synchronizeOptions() {
    var value = this.value;
    var isArray = void 0;

    if (Array.isArray(value)) {
      isArray = true;
    }

    var options = this.element.options;
    var i = options.length;
    var matcher = this.element.matcher || function (a, b) {
      return a === b;
    };

    var _loop = function _loop() {
      var option = options.item(i);
      var optionValue = option.hasOwnProperty('model') ? option.model : option.value;
      if (isArray) {
        option.selected = value.findIndex(function (item) {
          return !!matcher(optionValue, item);
        }) !== -1;
        return 'continue';
      }
      option.selected = !!matcher(optionValue, value);
    };

    while (i--) {
      var _ret = _loop();

      if (_ret === 'continue') continue;
    }
  };

  SelectValueObserver.prototype.synchronizeValue = function synchronizeValue() {
    var _this23 = this;

    var options = this.element.options;
    var count = 0;
    var value = [];

    for (var _i25 = 0, ii = options.length; _i25 < ii; _i25++) {
      var _option = options.item(_i25);
      if (!_option.selected) {
        continue;
      }
      value.push(_option.hasOwnProperty('model') ? _option.model : _option.value);
      count++;
    }

    if (this.element.multiple) {
      if (Array.isArray(this.value)) {
        var _ret2 = function () {
          var matcher = _this23.element.matcher || function (a, b) {
            return a === b;
          };

          var i = 0;

          var _loop2 = function _loop2() {
            var a = _this23.value[i];
            if (value.findIndex(function (b) {
              return matcher(a, b);
            }) === -1) {
              _this23.value.splice(i, 1);
            } else {
              i++;
            }
          };

          while (i < _this23.value.length) {
            _loop2();
          }

          i = 0;

          var _loop3 = function _loop3() {
            var a = value[i];
            if (_this23.value.findIndex(function (b) {
              return matcher(a, b);
            }) === -1) {
              _this23.value.push(a);
            }
            i++;
          };

          while (i < value.length) {
            _loop3();
          }
          return {
            v: void 0
          };
        }();

        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
      }
    } else {
      if (count === 0) {
        value = null;
      } else {
        value = value[0];
      }
    }

    if (value !== this.value) {
      this.oldValue = this.value;
      this.value = value;
      this.notify();
    }
  };

  SelectValueObserver.prototype.notify = function notify() {
    var oldValue = this.oldValue;
    var newValue = this.value;

    this.callSubscribers(newValue, oldValue);
  };

  SelectValueObserver.prototype.handleEvent = function handleEvent() {
    this.synchronizeValue();
  };

  SelectValueObserver.prototype.subscribe = function subscribe(context, callable) {
    if (!this.hasSubscribers()) {
      this.handler.subscribe(this.element, this);
    }
    this.addSubscriber(context, callable);
  };

  SelectValueObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.handler.dispose();
    }
  };

  SelectValueObserver.prototype.bind = function bind() {
    var _this24 = this;

    this.domObserver = _aureliaPal.DOM.createMutationObserver(function () {
      _this24.synchronizeOptions();
      _this24.synchronizeValue();
    });
    this.domObserver.observe(this.element, { childList: true, subtree: true });
  };

  SelectValueObserver.prototype.unbind = function unbind() {
    this.domObserver.disconnect();
    this.domObserver = null;

    if (this.arrayObserver) {
      this.arrayObserver.unsubscribe(selectArrayContext, this);
      this.arrayObserver = null;
    }
  };

  return SelectValueObserver;
}()) || _class10);

var ClassObserver = exports.ClassObserver = function () {
  function ClassObserver(element) {
    

    this.element = element;
    this.doNotCache = true;
    this.value = '';
    this.version = 0;
  }

  ClassObserver.prototype.getValue = function getValue() {
    return this.value;
  };

  ClassObserver.prototype.setValue = function setValue(newValue) {
    var nameIndex = this.nameIndex || {};
    var version = this.version;
    var names = void 0;
    var name = void 0;

    if (newValue !== null && newValue !== undefined && newValue.length) {
      names = newValue.split(/\s+/);
      for (var _i26 = 0, length = names.length; _i26 < length; _i26++) {
        name = names[_i26];
        if (name === '') {
          continue;
        }
        nameIndex[name] = version;
        this.element.classList.add(name);
      }
    }

    this.value = newValue;
    this.nameIndex = nameIndex;
    this.version += 1;

    if (version === 0) {
      return;
    }

    version -= 1;
    for (name in nameIndex) {
      if (!nameIndex.hasOwnProperty(name) || nameIndex[name] !== version) {
        continue;
      }
      this.element.classList.remove(name);
    }
  };

  ClassObserver.prototype.subscribe = function subscribe() {
    throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "class" property is not supported.');
  };

  return ClassObserver;
}();

function hasDeclaredDependencies(descriptor) {
  return !!(descriptor && descriptor.get && descriptor.get.dependencies);
}

function declarePropertyDependencies(ctor, propertyName, dependencies) {
  var descriptor = Object.getOwnPropertyDescriptor(ctor.prototype, propertyName);
  descriptor.get.dependencies = dependencies;
}

function computedFrom() {
  for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
    rest[_key] = arguments[_key];
  }

  return function (target, key, descriptor) {
    descriptor.get.dependencies = rest;
    return descriptor;
  };
}

var ComputedExpression = exports.ComputedExpression = function (_Expression19) {
  _inherits(ComputedExpression, _Expression19);

  function ComputedExpression(name, dependencies) {
    

    var _this25 = _possibleConstructorReturn(this, _Expression19.call(this));

    _this25.name = name;
    _this25.dependencies = dependencies;
    _this25.isAssignable = true;
    return _this25;
  }

  ComputedExpression.prototype.evaluate = function evaluate(scope, lookupFunctions) {
    return scope.bindingContext[this.name];
  };

  ComputedExpression.prototype.assign = function assign(scope, value) {
    scope.bindingContext[this.name] = value;
  };

  ComputedExpression.prototype.accept = function accept(visitor) {
    throw new Error('not implemented');
  };

  ComputedExpression.prototype.connect = function connect(binding, scope) {
    var dependencies = this.dependencies;
    var i = dependencies.length;
    while (i--) {
      dependencies[i].connect(binding, scope);
    }
  };

  return ComputedExpression;
}(Expression);

function createComputedObserver(obj, propertyName, descriptor, observerLocator) {
  var dependencies = descriptor.get.dependencies;
  if (!(dependencies instanceof ComputedExpression)) {
    var _i27 = dependencies.length;
    while (_i27--) {
      dependencies[_i27] = observerLocator.parser.parse(dependencies[_i27]);
    }
    dependencies = descriptor.get.dependencies = new ComputedExpression(propertyName, dependencies);
  }

  var scope = { bindingContext: obj, overrideContext: createOverrideContext(obj) };
  return new ExpressionObserver(scope, dependencies, observerLocator);
}

var svgElements = void 0;
var svgPresentationElements = void 0;
var svgPresentationAttributes = void 0;
var svgAnalyzer = void 0;

if (typeof FEATURE_NO_SVG === 'undefined') {
  svgElements = {
    a: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'target', 'transform', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    altGlyph: ['class', 'dx', 'dy', 'externalResourcesRequired', 'format', 'glyphRef', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    altGlyphDef: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    altGlyphItem: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    animate: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    animateColor: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    animateMotion: ['accumulate', 'additive', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keyPoints', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'origin', 'path', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'rotate', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    animateTransform: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'type', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    circle: ['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'r', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    clipPath: ['class', 'clipPathUnits', 'externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    'color-profile': ['id', 'local', 'name', 'rendering-intent', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    cursor: ['externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    defs: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    desc: ['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space'],
    ellipse: ['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    feBlend: ['class', 'height', 'id', 'in', 'in2', 'mode', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feColorMatrix: ['class', 'height', 'id', 'in', 'result', 'style', 'type', 'values', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feComponentTransfer: ['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feComposite: ['class', 'height', 'id', 'in', 'in2', 'k1', 'k2', 'k3', 'k4', 'operator', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feConvolveMatrix: ['bias', 'class', 'divisor', 'edgeMode', 'height', 'id', 'in', 'kernelMatrix', 'kernelUnitLength', 'order', 'preserveAlpha', 'result', 'style', 'targetX', 'targetY', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feDiffuseLighting: ['class', 'diffuseConstant', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feDisplacementMap: ['class', 'height', 'id', 'in', 'in2', 'result', 'scale', 'style', 'width', 'x', 'xChannelSelector', 'xml:base', 'xml:lang', 'xml:space', 'y', 'yChannelSelector'],
    feDistantLight: ['azimuth', 'elevation', 'id', 'xml:base', 'xml:lang', 'xml:space'],
    feFlood: ['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feFuncA: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feFuncB: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feFuncG: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feFuncR: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feGaussianBlur: ['class', 'height', 'id', 'in', 'result', 'stdDeviation', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feImage: ['class', 'externalResourcesRequired', 'height', 'id', 'preserveAspectRatio', 'result', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feMerge: ['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feMergeNode: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    feMorphology: ['class', 'height', 'id', 'in', 'operator', 'radius', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feOffset: ['class', 'dx', 'dy', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    fePointLight: ['id', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z'],
    feSpecularLighting: ['class', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'specularConstant', 'specularExponent', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feSpotLight: ['id', 'limitingConeAngle', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'specularExponent', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z'],
    feTile: ['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feTurbulence: ['baseFrequency', 'class', 'height', 'id', 'numOctaves', 'result', 'seed', 'stitchTiles', 'style', 'type', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    filter: ['class', 'externalResourcesRequired', 'filterRes', 'filterUnits', 'height', 'id', 'primitiveUnits', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    font: ['class', 'externalResourcesRequired', 'horiz-adv-x', 'horiz-origin-x', 'horiz-origin-y', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face': ['accent-height', 'alphabetic', 'ascent', 'bbox', 'cap-height', 'descent', 'font-family', 'font-size', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'hanging', 'id', 'ideographic', 'mathematical', 'overline-position', 'overline-thickness', 'panose-1', 'slope', 'stemh', 'stemv', 'strikethrough-position', 'strikethrough-thickness', 'underline-position', 'underline-thickness', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'widths', 'x-height', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-format': ['id', 'string', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-name': ['id', 'name', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-src': ['id', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-uri': ['id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    foreignObject: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    g: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    glyph: ['arabic-form', 'class', 'd', 'glyph-name', 'horiz-adv-x', 'id', 'lang', 'orientation', 'style', 'unicode', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
    glyphRef: ['class', 'dx', 'dy', 'format', 'glyphRef', 'id', 'style', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    hkern: ['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space'],
    image: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    line: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'x1', 'x2', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2'],
    linearGradient: ['class', 'externalResourcesRequired', 'gradientTransform', 'gradientUnits', 'id', 'spreadMethod', 'style', 'x1', 'x2', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2'],
    marker: ['class', 'externalResourcesRequired', 'id', 'markerHeight', 'markerUnits', 'markerWidth', 'orient', 'preserveAspectRatio', 'refX', 'refY', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space'],
    mask: ['class', 'externalResourcesRequired', 'height', 'id', 'maskContentUnits', 'maskUnits', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    metadata: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    'missing-glyph': ['class', 'd', 'horiz-adv-x', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
    mpath: ['externalResourcesRequired', 'id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    path: ['class', 'd', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'pathLength', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    pattern: ['class', 'externalResourcesRequired', 'height', 'id', 'patternContentUnits', 'patternTransform', 'patternUnits', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'viewBox', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    polygon: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    polyline: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    radialGradient: ['class', 'cx', 'cy', 'externalResourcesRequired', 'fx', 'fy', 'gradientTransform', 'gradientUnits', 'id', 'r', 'spreadMethod', 'style', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    rect: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    script: ['externalResourcesRequired', 'id', 'type', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    set: ['attributeName', 'attributeType', 'begin', 'dur', 'end', 'externalResourcesRequired', 'fill', 'id', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    stop: ['class', 'id', 'offset', 'style', 'xml:base', 'xml:lang', 'xml:space'],
    style: ['id', 'media', 'title', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    svg: ['baseProfile', 'class', 'contentScriptType', 'contentStyleType', 'externalResourcesRequired', 'height', 'id', 'onabort', 'onactivate', 'onclick', 'onerror', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onresize', 'onscroll', 'onunload', 'onzoom', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'version', 'viewBox', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'zoomAndPan'],
    switch: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    symbol: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space'],
    text: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'transform', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    textPath: ['class', 'externalResourcesRequired', 'id', 'lengthAdjust', 'method', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'spacing', 'startOffset', 'style', 'systemLanguage', 'textLength', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    title: ['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space'],
    tref: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    tspan: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    use: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    view: ['externalResourcesRequired', 'id', 'preserveAspectRatio', 'viewBox', 'viewTarget', 'xml:base', 'xml:lang', 'xml:space', 'zoomAndPan'],
    vkern: ['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space']
  };


  svgPresentationElements = {
    'a': true,
    'altGlyph': true,
    'animate': true,
    'animateColor': true,
    'circle': true,
    'clipPath': true,
    'defs': true,
    'ellipse': true,
    'feBlend': true,
    'feColorMatrix': true,
    'feComponentTransfer': true,
    'feComposite': true,
    'feConvolveMatrix': true,
    'feDiffuseLighting': true,
    'feDisplacementMap': true,
    'feFlood': true,
    'feGaussianBlur': true,
    'feImage': true,
    'feMerge': true,
    'feMorphology': true,
    'feOffset': true,
    'feSpecularLighting': true,
    'feTile': true,
    'feTurbulence': true,
    'filter': true,
    'font': true,
    'foreignObject': true,
    'g': true,
    'glyph': true,
    'glyphRef': true,
    'image': true,
    'line': true,
    'linearGradient': true,
    'marker': true,
    'mask': true,
    'missing-glyph': true,
    'path': true,
    'pattern': true,
    'polygon': true,
    'polyline': true,
    'radialGradient': true,
    'rect': true,
    'stop': true,
    'svg': true,
    'switch': true,
    'symbol': true,
    'text': true,
    'textPath': true,
    'tref': true,
    'tspan': true,
    'use': true
  };

  svgPresentationAttributes = {
    'alignment-baseline': true,
    'baseline-shift': true,
    'clip-path': true,
    'clip-rule': true,
    'clip': true,
    'color-interpolation-filters': true,
    'color-interpolation': true,
    'color-profile': true,
    'color-rendering': true,
    'color': true,
    'cursor': true,
    'direction': true,
    'display': true,
    'dominant-baseline': true,
    'enable-background': true,
    'fill-opacity': true,
    'fill-rule': true,
    'fill': true,
    'filter': true,
    'flood-color': true,
    'flood-opacity': true,
    'font-family': true,
    'font-size-adjust': true,
    'font-size': true,
    'font-stretch': true,
    'font-style': true,
    'font-variant': true,
    'font-weight': true,
    'glyph-orientation-horizontal': true,
    'glyph-orientation-vertical': true,
    'image-rendering': true,
    'kerning': true,
    'letter-spacing': true,
    'lighting-color': true,
    'marker-end': true,
    'marker-mid': true,
    'marker-start': true,
    'mask': true,
    'opacity': true,
    'overflow': true,
    'pointer-events': true,
    'shape-rendering': true,
    'stop-color': true,
    'stop-opacity': true,
    'stroke-dasharray': true,
    'stroke-dashoffset': true,
    'stroke-linecap': true,
    'stroke-linejoin': true,
    'stroke-miterlimit': true,
    'stroke-opacity': true,
    'stroke-width': true,
    'stroke': true,
    'text-anchor': true,
    'text-decoration': true,
    'text-rendering': true,
    'unicode-bidi': true,
    'visibility': true,
    'word-spacing': true,
    'writing-mode': true
  };

  var createElement = function createElement(html) {
    var div = _aureliaPal.DOM.createElement('div');
    div.innerHTML = html;
    return div.firstChild;
  };

  svgAnalyzer = function () {
    function SVGAnalyzer() {
      

      if (createElement('<svg><altGlyph /></svg>').firstElementChild.nodeName === 'altglyph' && elements.altGlyph) {
        elements.altglyph = elements.altGlyph;
        delete elements.altGlyph;
        elements.altglyphdef = elements.altGlyphDef;
        delete elements.altGlyphDef;
        elements.altglyphitem = elements.altGlyphItem;
        delete elements.altGlyphItem;
        elements.glyphref = elements.glyphRef;
        delete elements.glyphRef;
      }
    }

    SVGAnalyzer.prototype.isStandardSvgAttribute = function isStandardSvgAttribute(nodeName, attributeName) {
      return presentationElements[nodeName] && presentationAttributes[attributeName] || elements[nodeName] && elements[nodeName].indexOf(attributeName) !== -1;
    };

    return SVGAnalyzer;
  }();
}

var elements = exports.elements = svgElements;
var presentationElements = exports.presentationElements = svgPresentationElements;
var presentationAttributes = exports.presentationAttributes = svgPresentationAttributes;
var SVGAnalyzer = exports.SVGAnalyzer = svgAnalyzer || function () {
  function _class11() {
    
  }

  _class11.prototype.isStandardSvgAttribute = function isStandardSvgAttribute() {
    return false;
  };

  return _class11;
}();

var ObserverLocator = exports.ObserverLocator = (_temp = _class12 = function () {
  function ObserverLocator(taskQueue, eventManager, dirtyChecker, svgAnalyzer, parser) {
    

    this.taskQueue = taskQueue;
    this.eventManager = eventManager;
    this.dirtyChecker = dirtyChecker;
    this.svgAnalyzer = svgAnalyzer;
    this.parser = parser;

    this.adapters = [];
    this.logger = LogManager.getLogger('observer-locator');
  }

  ObserverLocator.prototype.getObserver = function getObserver(obj, propertyName) {
    var observersLookup = obj.__observers__;
    var observer = void 0;

    if (observersLookup && propertyName in observersLookup) {
      return observersLookup[propertyName];
    }

    observer = this.createPropertyObserver(obj, propertyName);

    if (!observer.doNotCache) {
      if (observersLookup === undefined) {
        observersLookup = this.getOrCreateObserversLookup(obj);
      }

      observersLookup[propertyName] = observer;
    }

    return observer;
  };

  ObserverLocator.prototype.getOrCreateObserversLookup = function getOrCreateObserversLookup(obj) {
    return obj.__observers__ || this.createObserversLookup(obj);
  };

  ObserverLocator.prototype.createObserversLookup = function createObserversLookup(obj) {
    var value = {};

    if (!Reflect.defineProperty(obj, '__observers__', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: value
    })) {
      this.logger.warn('Cannot add observers to object', obj);
    }

    return value;
  };

  ObserverLocator.prototype.addAdapter = function addAdapter(adapter) {
    this.adapters.push(adapter);
  };

  ObserverLocator.prototype.getAdapterObserver = function getAdapterObserver(obj, propertyName, descriptor) {
    for (var _i28 = 0, ii = this.adapters.length; _i28 < ii; _i28++) {
      var adapter = this.adapters[_i28];
      var observer = adapter.getObserver(obj, propertyName, descriptor);
      if (observer) {
        return observer;
      }
    }
    return null;
  };

  ObserverLocator.prototype.createPropertyObserver = function createPropertyObserver(obj, propertyName) {
    var descriptor = void 0;
    var handler = void 0;
    var xlinkResult = void 0;

    if (!(obj instanceof Object)) {
      return new PrimitiveObserver(obj, propertyName);
    }

    if (obj instanceof _aureliaPal.DOM.Element) {
      if (propertyName === 'class') {
        return new ClassObserver(obj);
      }
      if (propertyName === 'style' || propertyName === 'css') {
        return new StyleObserver(obj, propertyName);
      }
      handler = this.eventManager.getElementHandler(obj, propertyName);
      if (propertyName === 'value' && obj.tagName.toLowerCase() === 'select') {
        return new SelectValueObserver(obj, handler, this);
      }
      if (propertyName === 'checked' && obj.tagName.toLowerCase() === 'input') {
        return new CheckedObserver(obj, handler, this);
      }
      if (handler) {
        return new ValueAttributeObserver(obj, propertyName, handler);
      }
      xlinkResult = /^xlink:(.+)$/.exec(propertyName);
      if (xlinkResult) {
        return new XLinkAttributeObserver(obj, propertyName, xlinkResult[1]);
      }
      if (propertyName === 'role' && (obj instanceof _aureliaPal.DOM.Element || obj instanceof _aureliaPal.DOM.SVGElement) || /^\w+:|^data-|^aria-/.test(propertyName) || obj instanceof _aureliaPal.DOM.SVGElement && this.svgAnalyzer.isStandardSvgAttribute(obj.nodeName, propertyName)) {
        return new DataAttributeObserver(obj, propertyName);
      }
    }

    descriptor = Object.getPropertyDescriptor(obj, propertyName);

    if (hasDeclaredDependencies(descriptor)) {
      return createComputedObserver(obj, propertyName, descriptor, this);
    }

    if (descriptor) {
      var existingGetterOrSetter = descriptor.get || descriptor.set;
      if (existingGetterOrSetter) {
        if (existingGetterOrSetter.getObserver) {
          return existingGetterOrSetter.getObserver(obj);
        }

        var adapterObserver = this.getAdapterObserver(obj, propertyName, descriptor);
        if (adapterObserver) {
          return adapterObserver;
        }
        return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
      }
    }

    if (obj instanceof Array) {
      if (propertyName === 'length') {
        return this.getArrayObserver(obj).getLengthObserver();
      }

      return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
    } else if (obj instanceof Map) {
      if (propertyName === 'size') {
        return this.getMapObserver(obj).getLengthObserver();
      }

      return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
    } else if (obj instanceof Set) {
      if (propertyName === 'size') {
        return this.getSetObserver(obj).getLengthObserver();
      }

      return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
    }

    return new SetterObserver(this.taskQueue, obj, propertyName);
  };

  ObserverLocator.prototype.getAccessor = function getAccessor(obj, propertyName) {
    if (obj instanceof _aureliaPal.DOM.Element) {
      if (propertyName === 'class' || propertyName === 'style' || propertyName === 'css' || propertyName === 'value' && (obj.tagName.toLowerCase() === 'input' || obj.tagName.toLowerCase() === 'select') || propertyName === 'checked' && obj.tagName.toLowerCase() === 'input' || propertyName === 'model' && obj.tagName.toLowerCase() === 'input' || /^xlink:.+$/.exec(propertyName)) {
        return this.getObserver(obj, propertyName);
      }
      if (/^\w+:|^data-|^aria-/.test(propertyName) || obj instanceof _aureliaPal.DOM.SVGElement && this.svgAnalyzer.isStandardSvgAttribute(obj.nodeName, propertyName) || obj.tagName.toLowerCase() === 'img' && propertyName === 'src' || obj.tagName.toLowerCase() === 'a' && propertyName === 'href') {
        return dataAttributeAccessor;
      }
    }
    return propertyAccessor;
  };

  ObserverLocator.prototype.getArrayObserver = function getArrayObserver(array) {
    return _getArrayObserver(this.taskQueue, array);
  };

  ObserverLocator.prototype.getMapObserver = function getMapObserver(map) {
    return _getMapObserver(this.taskQueue, map);
  };

  ObserverLocator.prototype.getSetObserver = function getSetObserver(set) {
    return _getSetObserver(this.taskQueue, set);
  };

  return ObserverLocator;
}(), _class12.inject = [_aureliaTaskQueue.TaskQueue, EventManager, DirtyChecker, SVGAnalyzer, Parser], _temp);

var ObjectObservationAdapter = exports.ObjectObservationAdapter = function () {
  function ObjectObservationAdapter() {
    
  }

  ObjectObservationAdapter.prototype.getObserver = function getObserver(object, propertyName, descriptor) {
    throw new Error('BindingAdapters must implement getObserver(object, propertyName).');
  };

  return ObjectObservationAdapter;
}();

var BindingExpression = exports.BindingExpression = function () {
  function BindingExpression(observerLocator, targetProperty, sourceExpression, mode, lookupFunctions, attribute) {
    

    this.observerLocator = observerLocator;
    this.targetProperty = targetProperty;
    this.sourceExpression = sourceExpression;
    this.mode = mode;
    this.lookupFunctions = lookupFunctions;
    this.attribute = attribute;
    this.discrete = false;
  }

  BindingExpression.prototype.createBinding = function createBinding(target) {
    return new Binding(this.observerLocator, this.sourceExpression, target, this.targetProperty, this.mode, this.lookupFunctions);
  };

  return BindingExpression;
}();

var Binding = exports.Binding = (_dec10 = connectable(), _dec10(_class13 = function () {
  function Binding(observerLocator, sourceExpression, target, targetProperty, mode, lookupFunctions) {
    

    this.observerLocator = observerLocator;
    this.sourceExpression = sourceExpression;
    this.target = target;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.lookupFunctions = lookupFunctions;
  }

  Binding.prototype.updateTarget = function updateTarget(value) {
    this.targetObserver.setValue(value, this.target, this.targetProperty);
  };

  Binding.prototype.updateSource = function updateSource(value) {
    this.sourceExpression.assign(this.source, value, this.lookupFunctions);
  };

  Binding.prototype.call = function call(context, newValue, oldValue) {
    if (!this.isBound) {
      return;
    }
    if (context === sourceContext) {
      oldValue = this.targetObserver.getValue(this.target, this.targetProperty);
      newValue = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
      if (newValue !== oldValue) {
        this.updateTarget(newValue);
      }
      if (this.mode !== bindingMode.oneTime) {
        this._version++;
        this.sourceExpression.connect(this, this.source);
        this.unobserve(false);
      }
      return;
    }
    if (context === targetContext) {
      if (newValue !== this.sourceExpression.evaluate(this.source, this.lookupFunctions)) {
        this.updateSource(newValue);
      }
      return;
    }
    throw new Error('Unexpected call context ' + context);
  };

  Binding.prototype.bind = function bind(source) {
    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this.source = source;

    if (this.sourceExpression.bind) {
      this.sourceExpression.bind(this, source, this.lookupFunctions);
    }

    var mode = this.mode;
    if (!this.targetObserver) {
      var method = mode === bindingMode.twoWay || mode === bindingMode.fromView ? 'getObserver' : 'getAccessor';
      this.targetObserver = this.observerLocator[method](this.target, this.targetProperty);
    }

    if ('bind' in this.targetObserver) {
      this.targetObserver.bind();
    }
    if (this.mode !== bindingMode.fromView) {
      var value = this.sourceExpression.evaluate(source, this.lookupFunctions);
      this.updateTarget(value);
    }

    if (mode === bindingMode.oneTime) {
      return;
    } else if (mode === bindingMode.toView) {
      enqueueBindingConnect(this);
    } else if (mode === bindingMode.twoWay) {
      this.sourceExpression.connect(this, source);
      this.targetObserver.subscribe(targetContext, this);
    } else if (mode === bindingMode.fromView) {
      this.targetObserver.subscribe(targetContext, this);
    }
  };

  Binding.prototype.unbind = function unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    if (this.sourceExpression.unbind) {
      this.sourceExpression.unbind(this, this.source);
    }
    this.source = null;
    if ('unbind' in this.targetObserver) {
      this.targetObserver.unbind();
    }
    if (this.targetObserver.unsubscribe) {
      this.targetObserver.unsubscribe(targetContext, this);
    }
    this.unobserve(true);
  };

  Binding.prototype.connect = function connect(evaluate) {
    if (!this.isBound) {
      return;
    }
    if (evaluate) {
      var value = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
      this.updateTarget(value);
    }
    this.sourceExpression.connect(this, this.source);
  };

  return Binding;
}()) || _class13);

var CallExpression = exports.CallExpression = function () {
  function CallExpression(observerLocator, targetProperty, sourceExpression, lookupFunctions) {
    

    this.observerLocator = observerLocator;
    this.targetProperty = targetProperty;
    this.sourceExpression = sourceExpression;
    this.lookupFunctions = lookupFunctions;
  }

  CallExpression.prototype.createBinding = function createBinding(target) {
    return new Call(this.observerLocator, this.sourceExpression, target, this.targetProperty, this.lookupFunctions);
  };

  return CallExpression;
}();

var Call = exports.Call = function () {
  function Call(observerLocator, sourceExpression, target, targetProperty, lookupFunctions) {
    

    this.sourceExpression = sourceExpression;
    this.target = target;
    this.targetProperty = observerLocator.getObserver(target, targetProperty);
    this.lookupFunctions = lookupFunctions;
  }

  Call.prototype.callSource = function callSource($event) {
    var overrideContext = this.source.overrideContext;
    Object.assign(overrideContext, $event);
    overrideContext.$event = $event;
    var mustEvaluate = true;
    var result = this.sourceExpression.evaluate(this.source, this.lookupFunctions, mustEvaluate);
    delete overrideContext.$event;
    for (var prop in $event) {
      delete overrideContext[prop];
    }
    return result;
  };

  Call.prototype.bind = function bind(source) {
    var _this26 = this;

    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this.source = source;

    if (this.sourceExpression.bind) {
      this.sourceExpression.bind(this, source, this.lookupFunctions);
    }
    this.targetProperty.setValue(function ($event) {
      return _this26.callSource($event);
    });
  };

  Call.prototype.unbind = function unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    if (this.sourceExpression.unbind) {
      this.sourceExpression.unbind(this, this.source);
    }
    this.source = null;
    this.targetProperty.setValue(null);
  };

  return Call;
}();

var ValueConverterResource = exports.ValueConverterResource = function () {
  function ValueConverterResource(name) {
    

    this.name = name;
  }

  ValueConverterResource.convention = function convention(name) {
    if (name.endsWith('ValueConverter')) {
      return new ValueConverterResource(camelCase(name.substring(0, name.length - 14)));
    }
  };

  ValueConverterResource.prototype.initialize = function initialize(container, target) {
    this.instance = container.get(target);
  };

  ValueConverterResource.prototype.register = function register(registry, name) {
    registry.registerValueConverter(name || this.name, this.instance);
  };

  ValueConverterResource.prototype.load = function load(container, target) {};

  return ValueConverterResource;
}();

function valueConverter(nameOrTarget) {
  if (nameOrTarget === undefined || typeof nameOrTarget === 'string') {
    return function (target) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ValueConverterResource(nameOrTarget), target);
    };
  }

  _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ValueConverterResource(), nameOrTarget);
}

var BindingBehaviorResource = exports.BindingBehaviorResource = function () {
  function BindingBehaviorResource(name) {
    

    this.name = name;
  }

  BindingBehaviorResource.convention = function convention(name) {
    if (name.endsWith('BindingBehavior')) {
      return new BindingBehaviorResource(camelCase(name.substring(0, name.length - 15)));
    }
  };

  BindingBehaviorResource.prototype.initialize = function initialize(container, target) {
    this.instance = container.get(target);
  };

  BindingBehaviorResource.prototype.register = function register(registry, name) {
    registry.registerBindingBehavior(name || this.name, this.instance);
  };

  BindingBehaviorResource.prototype.load = function load(container, target) {};

  return BindingBehaviorResource;
}();

function bindingBehavior(nameOrTarget) {
  if (nameOrTarget === undefined || typeof nameOrTarget === 'string') {
    return function (target) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new BindingBehaviorResource(nameOrTarget), target);
    };
  }

  _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new BindingBehaviorResource(), nameOrTarget);
}

var ListenerExpression = exports.ListenerExpression = function () {
  function ListenerExpression(eventManager, targetEvent, sourceExpression, delegationStrategy, preventDefault, lookupFunctions) {
    

    this.eventManager = eventManager;
    this.targetEvent = targetEvent;
    this.sourceExpression = sourceExpression;
    this.delegationStrategy = delegationStrategy;
    this.discrete = true;
    this.preventDefault = preventDefault;
    this.lookupFunctions = lookupFunctions;
  }

  ListenerExpression.prototype.createBinding = function createBinding(target) {
    return new Listener(this.eventManager, this.targetEvent, this.delegationStrategy, this.sourceExpression, target, this.preventDefault, this.lookupFunctions);
  };

  return ListenerExpression;
}();

var Listener = exports.Listener = function () {
  function Listener(eventManager, targetEvent, delegationStrategy, sourceExpression, target, preventDefault, lookupFunctions) {
    

    this.eventManager = eventManager;
    this.targetEvent = targetEvent;
    this.delegationStrategy = delegationStrategy;
    this.sourceExpression = sourceExpression;
    this.target = target;
    this.preventDefault = preventDefault;
    this.lookupFunctions = lookupFunctions;
  }

  Listener.prototype.callSource = function callSource(event) {
    var overrideContext = this.source.overrideContext;
    overrideContext.$event = event;
    var mustEvaluate = true;
    var result = this.sourceExpression.evaluate(this.source, this.lookupFunctions, mustEvaluate);
    delete overrideContext.$event;
    if (result !== true && this.preventDefault) {
      event.preventDefault();
    }
    return result;
  };

  Listener.prototype.handleEvent = function handleEvent(event) {
    this.callSource(event);
  };

  Listener.prototype.bind = function bind(source) {
    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this.source = source;

    if (this.sourceExpression.bind) {
      this.sourceExpression.bind(this, source, this.lookupFunctions);
    }
    this._handler = this.eventManager.addEventListener(this.target, this.targetEvent, this, this.delegationStrategy, true);
  };

  Listener.prototype.unbind = function unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    if (this.sourceExpression.unbind) {
      this.sourceExpression.unbind(this, this.source);
    }
    this.source = null;
    this._handler.dispose();
    this._handler = null;
  };

  return Listener;
}();

function getAU(element) {
  var au = element.au;

  if (au === undefined) {
    throw new Error('No Aurelia APIs are defined for the element: "' + element.tagName + '".');
  }

  return au;
}

var NameExpression = exports.NameExpression = function () {
  function NameExpression(sourceExpression, apiName, lookupFunctions) {
    

    this.sourceExpression = sourceExpression;
    this.apiName = apiName;
    this.lookupFunctions = lookupFunctions;
    this.discrete = true;
  }

  NameExpression.prototype.createBinding = function createBinding(target) {
    return new NameBinder(this.sourceExpression, NameExpression.locateAPI(target, this.apiName), this.lookupFunctions);
  };

  NameExpression.locateAPI = function locateAPI(element, apiName) {
    switch (apiName) {
      case 'element':
        return element;
      case 'controller':
        return getAU(element).controller;
      case 'view-model':
        return getAU(element).controller.viewModel;
      case 'view':
        return getAU(element).controller.view;
      default:
        var target = getAU(element)[apiName];

        if (target === undefined) {
          throw new Error('Attempted to reference "' + apiName + '", but it was not found amongst the target\'s API.');
        }

        return target.viewModel;
    }
  };

  return NameExpression;
}();

var NameBinder = function () {
  function NameBinder(sourceExpression, target, lookupFunctions) {
    

    this.sourceExpression = sourceExpression;
    this.target = target;
    this.lookupFunctions = lookupFunctions;
  }

  NameBinder.prototype.bind = function bind(source) {
    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this.source = source;
    if (this.sourceExpression.bind) {
      this.sourceExpression.bind(this, source, this.lookupFunctions);
    }
    this.sourceExpression.assign(this.source, this.target, this.lookupFunctions);
  };

  NameBinder.prototype.unbind = function unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    if (this.sourceExpression.evaluate(this.source, this.lookupFunctions) === this.target) {
      this.sourceExpression.assign(this.source, null, this.lookupFunctions);
    }
    if (this.sourceExpression.unbind) {
      this.sourceExpression.unbind(this, this.source);
    }
    this.source = null;
  };

  return NameBinder;
}();

var LookupFunctions = {
  bindingBehaviors: function bindingBehaviors(name) {
    return null;
  },
  valueConverters: function valueConverters(name) {
    return null;
  }
};

var BindingEngine = exports.BindingEngine = (_temp2 = _class14 = function () {
  function BindingEngine(observerLocator, parser) {
    

    this.observerLocator = observerLocator;
    this.parser = parser;
  }

  BindingEngine.prototype.createBindingExpression = function createBindingExpression(targetProperty, sourceExpression) {
    var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : bindingMode.toView;
    var lookupFunctions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : LookupFunctions;

    return new BindingExpression(this.observerLocator, targetProperty, this.parser.parse(sourceExpression), mode, lookupFunctions);
  };

  BindingEngine.prototype.propertyObserver = function propertyObserver(obj, propertyName) {
    var _this27 = this;

    return {
      subscribe: function subscribe(callback) {
        var observer = _this27.observerLocator.getObserver(obj, propertyName);
        observer.subscribe(callback);
        return {
          dispose: function dispose() {
            return observer.unsubscribe(callback);
          }
        };
      }
    };
  };

  BindingEngine.prototype.collectionObserver = function collectionObserver(collection) {
    var _this28 = this;

    return {
      subscribe: function subscribe(callback) {
        var observer = void 0;
        if (collection instanceof Array) {
          observer = _this28.observerLocator.getArrayObserver(collection);
        } else if (collection instanceof Map) {
          observer = _this28.observerLocator.getMapObserver(collection);
        } else if (collection instanceof Set) {
          observer = _this28.observerLocator.getSetObserver(collection);
        } else {
          throw new Error('collection must be an instance of Array, Map or Set.');
        }
        observer.subscribe(callback);
        return {
          dispose: function dispose() {
            return observer.unsubscribe(callback);
          }
        };
      }
    };
  };

  BindingEngine.prototype.expressionObserver = function expressionObserver(bindingContext, expression) {
    var scope = { bindingContext: bindingContext, overrideContext: createOverrideContext(bindingContext) };
    return new ExpressionObserver(scope, this.parser.parse(expression), this.observerLocator, LookupFunctions);
  };

  BindingEngine.prototype.parseExpression = function parseExpression(expression) {
    return this.parser.parse(expression);
  };

  BindingEngine.prototype.registerAdapter = function registerAdapter(adapter) {
    this.observerLocator.addAdapter(adapter);
  };

  return BindingEngine;
}(), _class14.inject = [ObserverLocator, Parser], _temp2);


var setProto = Set.prototype;

function _getSetObserver(taskQueue, set) {
  return ModifySetObserver.for(taskQueue, set);
}

exports.getSetObserver = _getSetObserver;

var ModifySetObserver = function (_ModifyCollectionObse3) {
  _inherits(ModifySetObserver, _ModifyCollectionObse3);

  function ModifySetObserver(taskQueue, set) {
    

    return _possibleConstructorReturn(this, _ModifyCollectionObse3.call(this, taskQueue, set));
  }

  ModifySetObserver.for = function _for(taskQueue, set) {
    if (!('__set_observer__' in set)) {
      Reflect.defineProperty(set, '__set_observer__', {
        value: ModifySetObserver.create(taskQueue, set),
        enumerable: false, configurable: false
      });
    }
    return set.__set_observer__;
  };

  ModifySetObserver.create = function create(taskQueue, set) {
    var observer = new ModifySetObserver(taskQueue, set);

    var proto = setProto;
    if (proto.add !== set.add || proto.delete !== set.delete || proto.clear !== set.clear) {
      proto = {
        add: set.add,
        delete: set.delete,
        clear: set.clear
      };
    }

    set.add = function () {
      var type = 'add';
      var oldSize = set.size;
      var methodCallResult = proto.add.apply(set, arguments);
      var hasValue = set.size === oldSize;
      if (!hasValue) {
        observer.addChangeRecord({
          type: type,
          object: set,
          value: Array.from(set).pop()
        });
      }
      return methodCallResult;
    };

    set.delete = function () {
      var hasValue = set.has(arguments[0]);
      var methodCallResult = proto.delete.apply(set, arguments);
      if (hasValue) {
        observer.addChangeRecord({
          type: 'delete',
          object: set,
          value: arguments[0]
        });
      }
      return methodCallResult;
    };

    set.clear = function () {
      var methodCallResult = proto.clear.apply(set, arguments);
      observer.addChangeRecord({
        type: 'clear',
        object: set
      });
      return methodCallResult;
    };

    return observer;
  };

  return ModifySetObserver;
}(ModifyCollectionObserver);

function observable(targetOrConfig, key, descriptor) {
  function deco(target, key, descriptor, config) {
    var isClassDecorator = key === undefined;
    if (isClassDecorator) {
      target = target.prototype;
      key = typeof config === 'string' ? config : config.name;
    }

    var innerPropertyName = '_' + key;
    var innerPropertyDescriptor = {
      configurable: true,
      enumerable: false,
      writable: true
    };

    var callbackName = config && config.changeHandler || key + 'Changed';

    if (descriptor) {
      if (typeof descriptor.initializer === 'function') {
        innerPropertyDescriptor.value = descriptor.initializer();
      }
    } else {
      descriptor = {};
    }

    if (!('enumerable' in descriptor)) {
      descriptor.enumerable = true;
    }

    delete descriptor.value;
    delete descriptor.writable;
    delete descriptor.initializer;

    Reflect.defineProperty(target, innerPropertyName, innerPropertyDescriptor);

    descriptor.get = function () {
      return this[innerPropertyName];
    };
    descriptor.set = function (newValue) {
      var oldValue = this[innerPropertyName];
      if (newValue === oldValue) {
        return;
      }

      this[innerPropertyName] = newValue;
      Reflect.defineProperty(this, innerPropertyName, { enumerable: false });

      if (this[callbackName]) {
        this[callbackName](newValue, oldValue, key);
      }
    };

    descriptor.get.dependencies = [innerPropertyName];

    if (isClassDecorator) {
      Reflect.defineProperty(target, key, descriptor);
    } else {
      return descriptor;
    }
  }

  if (key === undefined) {
    return function (t, k, d) {
      return deco(t, k, d, targetOrConfig);
    };
  }
  return deco(targetOrConfig, key, descriptor);
}

var signals = {};

function connectBindingToSignal(binding, name) {
  if (!signals.hasOwnProperty(name)) {
    signals[name] = 0;
  }
  binding.observeProperty(signals, name);
}

function signalBindings(name) {
  if (signals.hasOwnProperty(name)) {
    signals[name]++;
  }
}
});

define('aurelia-bootstrapper/dist/commonjs/aurelia-bootstrapper',['require','exports','module','aurelia-polyfills','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.starting = undefined;
exports.bootstrap = bootstrap;

require('aurelia-polyfills');

var _aureliaPal = require('aurelia-pal');

var bootstrapPromises = [];
var startResolve = void 0;

var startPromise = new Promise(function (resolve) {
  return startResolve = resolve;
});
var host = _aureliaPal.PLATFORM.global;
var isNodeLike = typeof process !== 'undefined' && !process.browser;

function ready() {
  if (!host.document || host.document.readyState === 'complete') {
    return Promise.resolve();
  }

  return new Promise(function (resolve) {
    host.document.addEventListener('DOMContentLoaded', completed);
    host.addEventListener('load', completed);

    function completed() {
      host.document.removeEventListener('DOMContentLoaded', completed);
      host.removeEventListener('load', completed);
      resolve();
    }
  });
}

function createLoader() {
  if (_aureliaPal.PLATFORM.Loader) {
    return Promise.resolve(new _aureliaPal.PLATFORM.Loader());
  }

  if (typeof AURELIA_WEBPACK_2_0 === 'undefined') {
    if (typeof __webpack_require__ !== 'undefined') {
      var m = __webpack_require__(require.resolve('aurelia-loader-webpack'));
      return Promise.resolve(new m.WebpackLoader());
    }

    if (host.System && typeof host.System.config === 'function') {
      return host.System.normalize('aurelia-bootstrapper').then(function (bsn) {
        return host.System.normalize('aurelia-loader-default', bsn);
      }).then(function (loaderName) {
        return host.System.import(loaderName).then(function (m) {
          return new m.DefaultLoader();
        });
      });
    }

    if (typeof host.require === 'function' && typeof host.require.version === 'string') {
      return new Promise(function (resolve, reject) {
        return host.require(['aurelia-loader-default'], function (m) {
          return resolve(new m.DefaultLoader());
        }, reject);
      });
    }

    if (isNodeLike && typeof module !== 'undefined' && typeof module.require !== 'undefined') {
      var _m = module.require('aurelia-loader-nodejs');
      return Promise.resolve(new _m.NodeJsLoader());
    }
  }

  return Promise.reject('No PLATFORM.Loader is defined and there is neither a System API (ES6) or a Require API (AMD) globally available to load your app.');
}

function initializePal(loader) {
  var type = void 0;

  var isRenderer = isNodeLike && (process.type === 'renderer' || process.versions['node-webkit']);

  if (isNodeLike && !isRenderer) {
    type = 'nodejs';
  } else if (typeof window !== 'undefined') {
    type = 'browser';
  } else if (typeof self !== 'undefined') {
    type = 'worker';
  } else {
    throw new Error('Could not determine platform implementation to load.');
  }

  return loader.loadModule('aurelia-pal-' + type).then(function (palModule) {
    return type === 'nodejs' && !_aureliaPal.isInitialized && palModule.globalize() || palModule.initialize();
  });
}

function preparePlatform(loader) {
  var map = function map(moduleId, relativeTo) {
    return loader.normalize(moduleId, relativeTo).then(function (normalized) {
      loader.map(moduleId, normalized);
      return normalized;
    });
  };

  return initializePal(loader).then(function () {
    return loader.normalize('aurelia-bootstrapper');
  }).then(function (bootstrapperName) {
    var frameworkPromise = map(_aureliaPal.PLATFORM.moduleName('aurelia-framework', { exports: ['Aurelia'] }), bootstrapperName);

    return Promise.all([frameworkPromise, frameworkPromise.then(function (frameworkName) {
      return map('aurelia-dependency-injection', frameworkName);
    }), map('aurelia-router', bootstrapperName), map('aurelia-logging-console', bootstrapperName)]);
  }).then(function (_ref) {
    var frameworkName = _ref[0];
    return loader.loadModule(frameworkName);
  }).then(function (fx) {
    return startResolve(function () {
      return new fx.Aurelia(loader);
    });
  });
}

function config(appHost, configModuleId, aurelia) {
  aurelia.host = appHost;
  aurelia.configModuleId = configModuleId || null;

  if (configModuleId) {
    return aurelia.loader.loadModule(configModuleId).then(function (customConfig) {
      if (!customConfig.configure) {
        throw new Error('Cannot initialize module \'' + configModuleId + '\' without a configure function.');
      }

      return customConfig.configure(aurelia);
    });
  }

  aurelia.use.standardConfiguration().developmentLogging();

  return aurelia.start().then(function () {
    return aurelia.setRoot();
  });
}

function run() {
  return ready().then(createLoader).then(preparePlatform).then(function () {
    var appHosts = host.document.querySelectorAll('[aurelia-app],[data-aurelia-app]');
    for (var i = 0, ii = appHosts.length; i < ii; ++i) {
      var appHost = appHosts[i];
      var moduleId = appHost.getAttribute('aurelia-app') || appHost.getAttribute('data-aurelia-app');
      bootstrap(config.bind(null, appHost, moduleId));
    }

    var toConsole = console.error.bind(console);
    var bootstraps = bootstrapPromises.map(function (p) {
      return p.catch(toConsole);
    });
    bootstrapPromises = null;
    return Promise.all(bootstraps);
  });
}

function bootstrap(configure) {
  var p = startPromise.then(function (factory) {
    return configure(factory());
  });
  if (bootstrapPromises) bootstrapPromises.push(p);
  return p;
}

var starting = exports.starting = run();
});

define('aurelia-dependency-injection/dist/commonjs/aurelia-dependency-injection',['require','exports','module','aurelia-metadata','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Container = exports.InvocationHandler = exports._emptyParameters = exports.SingletonRegistration = exports.TransientRegistration = exports.FactoryInvoker = exports.NewInstance = exports.Factory = exports.StrategyResolver = exports.Parent = exports.Optional = exports.All = exports.Lazy = exports.resolver = undefined;

var _dec, _class, _dec2, _class3, _dec3, _class5, _dec4, _class7, _dec5, _class9, _dec6, _class11, _dec7, _class13, _classInvokers;

exports.getDecoratorDependencies = getDecoratorDependencies;
exports.lazy = lazy;
exports.all = all;
exports.optional = optional;
exports.parent = parent;
exports.factory = factory;
exports.newInstance = newInstance;
exports.invoker = invoker;
exports.invokeAsFactory = invokeAsFactory;
exports.registration = registration;
exports.transient = transient;
exports.singleton = singleton;
exports.autoinject = autoinject;
exports.inject = inject;

var _aureliaMetadata = require('aurelia-metadata');

var _aureliaPal = require('aurelia-pal');



var resolver = exports.resolver = _aureliaMetadata.protocol.create('aurelia:resolver', function (target) {
  if (!(typeof target.get === 'function')) {
    return 'Resolvers must implement: get(container: Container, key: any): any';
  }

  return true;
});

var Lazy = exports.Lazy = (_dec = resolver(), _dec(_class = function () {
  function Lazy(key) {
    

    this._key = key;
  }

  Lazy.prototype.get = function get(container) {
    var _this = this;

    return function () {
      return container.get(_this._key);
    };
  };

  Lazy.of = function of(key) {
    return new Lazy(key);
  };

  return Lazy;
}()) || _class);
var All = exports.All = (_dec2 = resolver(), _dec2(_class3 = function () {
  function All(key) {
    

    this._key = key;
  }

  All.prototype.get = function get(container) {
    return container.getAll(this._key);
  };

  All.of = function of(key) {
    return new All(key);
  };

  return All;
}()) || _class3);
var Optional = exports.Optional = (_dec3 = resolver(), _dec3(_class5 = function () {
  function Optional(key) {
    var checkParent = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

    

    this._key = key;
    this._checkParent = checkParent;
  }

  Optional.prototype.get = function get(container) {
    if (container.hasResolver(this._key, this._checkParent)) {
      return container.get(this._key);
    }

    return null;
  };

  Optional.of = function of(key) {
    var checkParent = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

    return new Optional(key, checkParent);
  };

  return Optional;
}()) || _class5);
var Parent = exports.Parent = (_dec4 = resolver(), _dec4(_class7 = function () {
  function Parent(key) {
    

    this._key = key;
  }

  Parent.prototype.get = function get(container) {
    return container.parent ? container.parent.get(this._key) : null;
  };

  Parent.of = function of(key) {
    return new Parent(key);
  };

  return Parent;
}()) || _class7);
var StrategyResolver = exports.StrategyResolver = (_dec5 = resolver(), _dec5(_class9 = function () {
  function StrategyResolver(strategy, state) {
    

    this.strategy = strategy;
    this.state = state;
  }

  StrategyResolver.prototype.get = function get(container, key) {
    switch (this.strategy) {
      case 0:
        return this.state;
      case 1:
        var singleton = container.invoke(this.state);
        this.state = singleton;
        this.strategy = 0;
        return singleton;
      case 2:
        return container.invoke(this.state);
      case 3:
        return this.state(container, key, this);
      case 4:
        return this.state[0].get(container, key);
      case 5:
        return container.get(this.state);
      default:
        throw new Error('Invalid strategy: ' + this.strategy);
    }
  };

  return StrategyResolver;
}()) || _class9);
var Factory = exports.Factory = (_dec6 = resolver(), _dec6(_class11 = function () {
  function Factory(key) {
    

    this._key = key;
  }

  Factory.prototype.get = function get(container) {
    var _this2 = this;

    return function () {
      for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
        rest[_key] = arguments[_key];
      }

      return container.invoke(_this2._key, rest);
    };
  };

  Factory.of = function of(key) {
    return new Factory(key);
  };

  return Factory;
}()) || _class11);
var NewInstance = exports.NewInstance = (_dec7 = resolver(), _dec7(_class13 = function () {
  function NewInstance(key) {
    

    this.key = key;
    this.asKey = key;

    for (var _len2 = arguments.length, dynamicDependencies = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      dynamicDependencies[_key2 - 1] = arguments[_key2];
    }

    this.dynamicDependencies = dynamicDependencies;
  }

  NewInstance.prototype.get = function get(container) {
    var dynamicDependencies = this.dynamicDependencies.length > 0 ? this.dynamicDependencies.map(function (dependency) {
      return dependency['protocol:aurelia:resolver'] ? dependency.get(container) : container.get(dependency);
    }) : undefined;
    var instance = container.invoke(this.key, dynamicDependencies);
    container.registerInstance(this.asKey, instance);
    return instance;
  };

  NewInstance.prototype.as = function as(key) {
    this.asKey = key;
    return this;
  };

  NewInstance.of = function of(key) {
    for (var _len3 = arguments.length, dynamicDependencies = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      dynamicDependencies[_key3 - 1] = arguments[_key3];
    }

    return new (Function.prototype.bind.apply(NewInstance, [null].concat([key], dynamicDependencies)))();
  };

  return NewInstance;
}()) || _class13);
function getDecoratorDependencies(target, name) {
  var dependencies = target.inject;
  if (typeof dependencies === 'function') {
    throw new Error('Decorator ' + name + ' cannot be used with "inject()".  Please use an array instead.');
  }
  if (!dependencies) {
    dependencies = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target).slice();
    target.inject = dependencies;
  }

  return dependencies;
}

function lazy(keyValue) {
  return function (target, key, index) {
    var params = getDecoratorDependencies(target, 'lazy');
    params[index] = Lazy.of(keyValue);
  };
}

function all(keyValue) {
  return function (target, key, index) {
    var params = getDecoratorDependencies(target, 'all');
    params[index] = All.of(keyValue);
  };
}

function optional() {
  var checkParentOrTarget = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

  var deco = function deco(checkParent) {
    return function (target, key, index) {
      var params = getDecoratorDependencies(target, 'optional');
      params[index] = Optional.of(params[index], checkParent);
    };
  };
  if (typeof checkParentOrTarget === 'boolean') {
    return deco(checkParentOrTarget);
  }
  return deco(true);
}

function parent(target, key, index) {
  var params = getDecoratorDependencies(target, 'parent');
  params[index] = Parent.of(params[index]);
}

function factory(keyValue, asValue) {
  return function (target, key, index) {
    var params = getDecoratorDependencies(target, 'factory');
    var factory = Factory.of(keyValue);
    params[index] = asValue ? factory.as(asValue) : factory;
  };
}

function newInstance(asKeyOrTarget) {
  for (var _len4 = arguments.length, dynamicDependencies = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    dynamicDependencies[_key4 - 1] = arguments[_key4];
  }

  var deco = function deco(asKey) {
    return function (target, key, index) {
      var params = getDecoratorDependencies(target, 'newInstance');
      params[index] = NewInstance.of.apply(NewInstance, [params[index]].concat(dynamicDependencies));
      if (!!asKey) {
        params[index].as(asKey);
      }
    };
  };
  if (arguments.length >= 1) {
    return deco(asKeyOrTarget);
  }
  return deco();
}

function invoker(value) {
  return function (target) {
    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.invoker, value, target);
  };
}

function invokeAsFactory(potentialTarget) {
  var deco = function deco(target) {
    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.invoker, FactoryInvoker.instance, target);
  };

  return potentialTarget ? deco(potentialTarget) : deco;
}

var FactoryInvoker = exports.FactoryInvoker = function () {
  function FactoryInvoker() {
    
  }

  FactoryInvoker.prototype.invoke = function invoke(container, fn, dependencies) {
    var i = dependencies.length;
    var args = new Array(i);

    while (i--) {
      args[i] = container.get(dependencies[i]);
    }

    return fn.apply(undefined, args);
  };

  FactoryInvoker.prototype.invokeWithDynamicDependencies = function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
    var i = staticDependencies.length;
    var args = new Array(i);

    while (i--) {
      args[i] = container.get(staticDependencies[i]);
    }

    if (dynamicDependencies !== undefined) {
      args = args.concat(dynamicDependencies);
    }

    return fn.apply(undefined, args);
  };

  return FactoryInvoker;
}();

FactoryInvoker.instance = new FactoryInvoker();

function registration(value) {
  return function (target) {
    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.registration, value, target);
  };
}

function transient(key) {
  return registration(new TransientRegistration(key));
}

function singleton(keyOrRegisterInChild) {
  var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

  return registration(new SingletonRegistration(keyOrRegisterInChild, registerInChild));
}

var TransientRegistration = exports.TransientRegistration = function () {
  function TransientRegistration(key) {
    

    this._key = key;
  }

  TransientRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
    var existingResolver = container.getResolver(this._key || key);
    return existingResolver === undefined ? container.registerTransient(this._key || key, fn) : existingResolver;
  };

  return TransientRegistration;
}();

var SingletonRegistration = exports.SingletonRegistration = function () {
  function SingletonRegistration(keyOrRegisterInChild) {
    var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

    

    if (typeof keyOrRegisterInChild === 'boolean') {
      this._registerInChild = keyOrRegisterInChild;
    } else {
      this._key = keyOrRegisterInChild;
      this._registerInChild = registerInChild;
    }
  }

  SingletonRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
    var targetContainer = this._registerInChild ? container : container.root;
    var existingResolver = targetContainer.getResolver(this._key || key);
    return existingResolver === undefined ? targetContainer.registerSingleton(this._key || key, fn) : existingResolver;
  };

  return SingletonRegistration;
}();

function validateKey(key) {
  if (key === null || key === undefined) {
    throw new Error('key/value cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?');
  }
}
var _emptyParameters = exports._emptyParameters = Object.freeze([]);

_aureliaMetadata.metadata.registration = 'aurelia:registration';
_aureliaMetadata.metadata.invoker = 'aurelia:invoker';

var resolverDecorates = resolver.decorates;

var InvocationHandler = exports.InvocationHandler = function () {
  function InvocationHandler(fn, invoker, dependencies) {
    

    this.fn = fn;
    this.invoker = invoker;
    this.dependencies = dependencies;
  }

  InvocationHandler.prototype.invoke = function invoke(container, dynamicDependencies) {
    return dynamicDependencies !== undefined ? this.invoker.invokeWithDynamicDependencies(container, this.fn, this.dependencies, dynamicDependencies) : this.invoker.invoke(container, this.fn, this.dependencies);
  };

  return InvocationHandler;
}();

function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
  var i = staticDependencies.length;
  var args = new Array(i);
  var lookup = void 0;

  while (i--) {
    lookup = staticDependencies[i];

    if (lookup === null || lookup === undefined) {
      throw new Error('Constructor Parameter with index ' + i + ' cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?');
    } else {
      args[i] = container.get(lookup);
    }
  }

  if (dynamicDependencies !== undefined) {
    args = args.concat(dynamicDependencies);
  }

  return Reflect.construct(fn, args);
}

var classInvokers = (_classInvokers = {}, _classInvokers[0] = {
  invoke: function invoke(container, Type) {
    return new Type();
  },

  invokeWithDynamicDependencies: invokeWithDynamicDependencies
}, _classInvokers[1] = {
  invoke: function invoke(container, Type, deps) {
    return new Type(container.get(deps[0]));
  },

  invokeWithDynamicDependencies: invokeWithDynamicDependencies
}, _classInvokers[2] = {
  invoke: function invoke(container, Type, deps) {
    return new Type(container.get(deps[0]), container.get(deps[1]));
  },

  invokeWithDynamicDependencies: invokeWithDynamicDependencies
}, _classInvokers[3] = {
  invoke: function invoke(container, Type, deps) {
    return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]));
  },

  invokeWithDynamicDependencies: invokeWithDynamicDependencies
}, _classInvokers[4] = {
  invoke: function invoke(container, Type, deps) {
    return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]));
  },

  invokeWithDynamicDependencies: invokeWithDynamicDependencies
}, _classInvokers[5] = {
  invoke: function invoke(container, Type, deps) {
    return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]), container.get(deps[4]));
  },

  invokeWithDynamicDependencies: invokeWithDynamicDependencies
}, _classInvokers.fallback = {
  invoke: invokeWithDynamicDependencies,
  invokeWithDynamicDependencies: invokeWithDynamicDependencies
}, _classInvokers);

function getDependencies(f) {
  if (!f.hasOwnProperty('inject')) {
    return [];
  }

  if (typeof f.inject === 'function') {
    return f.inject();
  }

  return f.inject;
}

var Container = exports.Container = function () {
  function Container(configuration) {
    

    if (configuration === undefined) {
      configuration = {};
    }

    this._configuration = configuration;
    this._onHandlerCreated = configuration.onHandlerCreated;
    this._handlers = configuration.handlers || (configuration.handlers = new Map());
    this._resolvers = new Map();
    this.root = this;
    this.parent = null;
  }

  Container.prototype.makeGlobal = function makeGlobal() {
    Container.instance = this;
    return this;
  };

  Container.prototype.setHandlerCreatedCallback = function setHandlerCreatedCallback(onHandlerCreated) {
    this._onHandlerCreated = onHandlerCreated;
    this._configuration.onHandlerCreated = onHandlerCreated;
  };

  Container.prototype.registerInstance = function registerInstance(key, instance) {
    return this.registerResolver(key, new StrategyResolver(0, instance === undefined ? key : instance));
  };

  Container.prototype.registerSingleton = function registerSingleton(key, fn) {
    return this.registerResolver(key, new StrategyResolver(1, fn === undefined ? key : fn));
  };

  Container.prototype.registerTransient = function registerTransient(key, fn) {
    return this.registerResolver(key, new StrategyResolver(2, fn === undefined ? key : fn));
  };

  Container.prototype.registerHandler = function registerHandler(key, handler) {
    return this.registerResolver(key, new StrategyResolver(3, handler));
  };

  Container.prototype.registerAlias = function registerAlias(originalKey, aliasKey) {
    return this.registerResolver(aliasKey, new StrategyResolver(5, originalKey));
  };

  Container.prototype.registerResolver = function registerResolver(key, resolver) {
    validateKey(key);

    var allResolvers = this._resolvers;
    var result = allResolvers.get(key);

    if (result === undefined) {
      allResolvers.set(key, resolver);
    } else if (result.strategy === 4) {
      result.state.push(resolver);
    } else {
      allResolvers.set(key, new StrategyResolver(4, [result, resolver]));
    }

    return resolver;
  };

  Container.prototype.autoRegister = function autoRegister(key, fn) {
    fn = fn === undefined ? key : fn;

    if (typeof fn === 'function') {
      var _registration = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.registration, fn);

      if (_registration === undefined) {
        return this.registerResolver(key, new StrategyResolver(1, fn));
      }

      return _registration.registerResolver(this, key, fn);
    }

    return this.registerResolver(key, new StrategyResolver(0, fn));
  };

  Container.prototype.autoRegisterAll = function autoRegisterAll(fns) {
    var i = fns.length;
    while (i--) {
      this.autoRegister(fns[i]);
    }
  };

  Container.prototype.unregister = function unregister(key) {
    this._resolvers.delete(key);
  };

  Container.prototype.hasResolver = function hasResolver(key) {
    var checkParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

    validateKey(key);

    return this._resolvers.has(key) || checkParent && this.parent !== null && this.parent.hasResolver(key, checkParent);
  };

  Container.prototype.getResolver = function getResolver(key) {
    return this._resolvers.get(key);
  };

  Container.prototype.get = function get(key) {
    validateKey(key);

    if (key === Container) {
      return this;
    }

    if (resolverDecorates(key)) {
      return key.get(this, key);
    }

    var resolver = this._resolvers.get(key);

    if (resolver === undefined) {
      if (this.parent === null) {
        return this.autoRegister(key).get(this, key);
      }

      var _registration2 = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.registration, key);

      if (_registration2 === undefined) {
        return this.parent._get(key);
      }

      return _registration2.registerResolver(this, key, key).get(this, key);
    }

    return resolver.get(this, key);
  };

  Container.prototype._get = function _get(key) {
    var resolver = this._resolvers.get(key);

    if (resolver === undefined) {
      if (this.parent === null) {
        return this.autoRegister(key).get(this, key);
      }

      return this.parent._get(key);
    }

    return resolver.get(this, key);
  };

  Container.prototype.getAll = function getAll(key) {
    validateKey(key);

    var resolver = this._resolvers.get(key);

    if (resolver === undefined) {
      if (this.parent === null) {
        return _emptyParameters;
      }

      return this.parent.getAll(key);
    }

    if (resolver.strategy === 4) {
      var state = resolver.state;
      var i = state.length;
      var results = new Array(i);

      while (i--) {
        results[i] = state[i].get(this, key);
      }

      return results;
    }

    return [resolver.get(this, key)];
  };

  Container.prototype.createChild = function createChild() {
    var child = new Container(this._configuration);
    child.root = this.root;
    child.parent = this;
    return child;
  };

  Container.prototype.invoke = function invoke(fn, dynamicDependencies) {
    try {
      var _handler = this._handlers.get(fn);

      if (_handler === undefined) {
        _handler = this._createInvocationHandler(fn);
        this._handlers.set(fn, _handler);
      }

      return _handler.invoke(this, dynamicDependencies);
    } catch (e) {
      throw new _aureliaPal.AggregateError('Error invoking ' + fn.name + '. Check the inner error for details.', e, true);
    }
  };

  Container.prototype._createInvocationHandler = function _createInvocationHandler(fn) {
    var dependencies = void 0;

    if (fn.inject === undefined) {
      dependencies = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, fn) || _emptyParameters;
    } else {
      dependencies = [];
      var ctor = fn;
      while (typeof ctor === 'function') {
        var _dependencies;

        (_dependencies = dependencies).push.apply(_dependencies, getDependencies(ctor));
        ctor = Object.getPrototypeOf(ctor);
      }
    }

    var invoker = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.invoker, fn) || classInvokers[dependencies.length] || classInvokers.fallback;

    var handler = new InvocationHandler(fn, invoker, dependencies);
    return this._onHandlerCreated !== undefined ? this._onHandlerCreated(handler) : handler;
  };

  return Container;
}();

function autoinject(potentialTarget) {
  var deco = function deco(target) {
    var previousInject = target.inject ? target.inject.slice() : null;
    var autoInject = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target) || _emptyParameters;
    if (!previousInject) {
      target.inject = autoInject;
    } else {
      for (var i = 0; i < autoInject.length; i++) {
        if (previousInject[i] && previousInject[i] !== autoInject[i]) {
          var prevIndex = previousInject.indexOf(autoInject[i]);
          if (prevIndex > -1) {
            previousInject.splice(prevIndex, 1);
          }
          previousInject.splice(prevIndex > -1 && prevIndex < i ? i - 1 : i, 0, autoInject[i]);
        } else if (!previousInject[i]) {
          previousInject[i] = autoInject[i];
        }
      }
      target.inject = previousInject;
    }
  };

  return potentialTarget ? deco(potentialTarget) : deco;
}

function inject() {
  for (var _len5 = arguments.length, rest = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    rest[_key5] = arguments[_key5];
  }

  return function (target, key, descriptor) {
    if (typeof descriptor === 'number' && rest.length === 1) {
      var params = target.inject;
      if (typeof params === 'function') {
        throw new Error('Decorator inject cannot be used with "inject()".  Please use an array instead.');
      }
      if (!params) {
        params = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target).slice();
        target.inject = params;
      }
      params[descriptor] = rest[0];
      return;
    }

    if (descriptor) {
      var _fn = descriptor.value;
      _fn.inject = rest;
    } else {
      target.inject = rest;
    }
  };
}
});

define('aurelia-event-aggregator/dist/commonjs/aurelia-event-aggregator',['require','exports','module','aurelia-logging'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventAggregator = undefined;
exports.includeEventsIn = includeEventsIn;
exports.configure = configure;

var _aureliaLogging = require('aurelia-logging');

var LogManager = _interopRequireWildcard(_aureliaLogging);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }



var logger = LogManager.getLogger('event-aggregator');

var Handler = function () {
  function Handler(messageType, callback) {
    

    this.messageType = messageType;
    this.callback = callback;
  }

  Handler.prototype.handle = function handle(message) {
    if (message instanceof this.messageType) {
      this.callback.call(null, message);
    }
  };

  return Handler;
}();

function invokeCallback(callback, data, event) {
  try {
    callback(data, event);
  } catch (e) {
    logger.error(e);
  }
}

function invokeHandler(handler, data) {
  try {
    handler.handle(data);
  } catch (e) {
    logger.error(e);
  }
}

var EventAggregator = exports.EventAggregator = function () {
  function EventAggregator() {
    

    this.eventLookup = {};
    this.messageHandlers = [];
  }

  EventAggregator.prototype.publish = function publish(event, data) {
    var subscribers = void 0;
    var i = void 0;

    if (!event) {
      throw new Error('Event was invalid.');
    }

    if (typeof event === 'string') {
      subscribers = this.eventLookup[event];
      if (subscribers) {
        subscribers = subscribers.slice();
        i = subscribers.length;

        while (i--) {
          invokeCallback(subscribers[i], data, event);
        }
      }
    } else {
      subscribers = this.messageHandlers.slice();
      i = subscribers.length;

      while (i--) {
        invokeHandler(subscribers[i], event);
      }
    }
  };

  EventAggregator.prototype.subscribe = function subscribe(event, callback) {
    var handler = void 0;
    var subscribers = void 0;

    if (!event) {
      throw new Error('Event channel/type was invalid.');
    }

    if (typeof event === 'string') {
      handler = callback;
      subscribers = this.eventLookup[event] || (this.eventLookup[event] = []);
    } else {
      handler = new Handler(event, callback);
      subscribers = this.messageHandlers;
    }

    subscribers.push(handler);

    return {
      dispose: function dispose() {
        var idx = subscribers.indexOf(handler);
        if (idx !== -1) {
          subscribers.splice(idx, 1);
        }
      }
    };
  };

  EventAggregator.prototype.subscribeOnce = function subscribeOnce(event, callback) {
    var sub = this.subscribe(event, function (a, b) {
      sub.dispose();
      return callback(a, b);
    });

    return sub;
  };

  return EventAggregator;
}();

function includeEventsIn(obj) {
  var ea = new EventAggregator();

  obj.subscribeOnce = function (event, callback) {
    return ea.subscribeOnce(event, callback);
  };

  obj.subscribe = function (event, callback) {
    return ea.subscribe(event, callback);
  };

  obj.publish = function (event, data) {
    ea.publish(event, data);
  };

  return ea;
}

function configure(config) {
  config.instance(EventAggregator, includeEventsIn(config.aurelia));
}
});

define('aurelia-framework/dist/commonjs/aurelia-framework',['require','exports','module','aurelia-dependency-injection','aurelia-binding','aurelia-metadata','aurelia-templating','aurelia-loader','aurelia-task-queue','aurelia-path','aurelia-pal','aurelia-logging'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LogManager = exports.FrameworkConfiguration = exports.Aurelia = undefined;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

Object.keys(_aureliaDependencyInjection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaDependencyInjection[key];
    }
  });
});

var _aureliaBinding = require('aurelia-binding');

Object.keys(_aureliaBinding).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaBinding[key];
    }
  });
});

var _aureliaMetadata = require('aurelia-metadata');

Object.keys(_aureliaMetadata).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaMetadata[key];
    }
  });
});

var _aureliaTemplating = require('aurelia-templating');

Object.keys(_aureliaTemplating).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaTemplating[key];
    }
  });
});

var _aureliaLoader = require('aurelia-loader');

Object.keys(_aureliaLoader).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaLoader[key];
    }
  });
});

var _aureliaTaskQueue = require('aurelia-task-queue');

Object.keys(_aureliaTaskQueue).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaTaskQueue[key];
    }
  });
});

var _aureliaPath = require('aurelia-path');

Object.keys(_aureliaPath).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaPath[key];
    }
  });
});

var _aureliaPal = require('aurelia-pal');

Object.keys(_aureliaPal).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aureliaPal[key];
    }
  });
});

var _aureliaLogging = require('aurelia-logging');

var TheLogManager = _interopRequireWildcard(_aureliaLogging);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }



function preventActionlessFormSubmit() {
  _aureliaPal.DOM.addEventListener('submit', function (evt) {
    var target = evt.target;
    var action = target.action;

    if (target.tagName.toLowerCase() === 'form' && !action) {
      evt.preventDefault();
    }
  });
}

var Aurelia = exports.Aurelia = function () {
  function Aurelia(loader, container, resources) {
    

    this.loader = loader || new _aureliaPal.PLATFORM.Loader();
    this.container = container || new _aureliaDependencyInjection.Container().makeGlobal();
    this.resources = resources || new _aureliaTemplating.ViewResources();
    this.use = new FrameworkConfiguration(this);
    this.logger = TheLogManager.getLogger('aurelia');
    this.hostConfigured = false;
    this.host = null;

    this.use.instance(Aurelia, this);
    this.use.instance(_aureliaLoader.Loader, this.loader);
    this.use.instance(_aureliaTemplating.ViewResources, this.resources);
  }

  Aurelia.prototype.start = function start() {
    var _this = this;

    if (this._started) {
      return this._started;
    }

    this.logger.info('Aurelia Starting');
    return this._started = this.use.apply().then(function () {
      preventActionlessFormSubmit();

      if (!_this.container.hasResolver(_aureliaTemplating.BindingLanguage)) {
        var message = 'You must configure Aurelia with a BindingLanguage implementation.';
        _this.logger.error(message);
        throw new Error(message);
      }

      _this.logger.info('Aurelia Started');
      var evt = _aureliaPal.DOM.createCustomEvent('aurelia-started', { bubbles: true, cancelable: true });
      _aureliaPal.DOM.dispatchEvent(evt);
      return _this;
    });
  };

  Aurelia.prototype.enhance = function enhance() {
    var _this2 = this;

    var bindingContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var applicationHost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    this._configureHost(applicationHost || _aureliaPal.DOM.querySelectorAll('body')[0]);

    return new Promise(function (resolve) {
      var engine = _this2.container.get(_aureliaTemplating.TemplatingEngine);
      _this2.root = engine.enhance({ container: _this2.container, element: _this2.host, resources: _this2.resources, bindingContext: bindingContext });
      _this2.root.attached();
      _this2._onAureliaComposed();
      resolve(_this2);
    });
  };

  Aurelia.prototype.setRoot = function setRoot() {
    var _this3 = this;

    var root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var applicationHost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    var instruction = {};

    if (this.root && this.root.viewModel && this.root.viewModel.router) {
      this.root.viewModel.router.deactivate();
      this.root.viewModel.router.reset();
    }

    this._configureHost(applicationHost);

    var engine = this.container.get(_aureliaTemplating.TemplatingEngine);
    var transaction = this.container.get(_aureliaTemplating.CompositionTransaction);
    delete transaction.initialComposition;

    if (!root) {
      if (this.configModuleId) {
        root = (0, _aureliaPath.relativeToFile)('./app', this.configModuleId);
      } else {
        root = 'app';
      }
    }

    instruction.viewModel = root;
    instruction.container = instruction.childContainer = this.container;
    instruction.viewSlot = this.hostSlot;
    instruction.host = this.host;

    return engine.compose(instruction).then(function (r) {
      _this3.root = r;
      instruction.viewSlot.attached();
      _this3._onAureliaComposed();
      return _this3;
    });
  };

  Aurelia.prototype._configureHost = function _configureHost(applicationHost) {
    if (this.hostConfigured) {
      return;
    }
    applicationHost = applicationHost || this.host;

    if (!applicationHost || typeof applicationHost === 'string') {
      this.host = _aureliaPal.DOM.getElementById(applicationHost || 'applicationHost');
    } else {
      this.host = applicationHost;
    }

    if (!this.host) {
      throw new Error('No applicationHost was specified.');
    }

    this.hostConfigured = true;
    this.host.aurelia = this;
    this.hostSlot = new _aureliaTemplating.ViewSlot(this.host, true);
    this.hostSlot.transformChildNodesIntoView();
    this.container.registerInstance(_aureliaPal.DOM.boundary, this.host);
  };

  Aurelia.prototype._onAureliaComposed = function _onAureliaComposed() {
    var evt = _aureliaPal.DOM.createCustomEvent('aurelia-composed', { bubbles: true, cancelable: true });
    setTimeout(function () {
      return _aureliaPal.DOM.dispatchEvent(evt);
    }, 1);
  };

  return Aurelia;
}();

var logger = TheLogManager.getLogger('aurelia');
var extPattern = /\.[^/.]+$/;

function runTasks(config, tasks) {
  var current = void 0;
  var next = function next() {
    current = tasks.shift();
    if (current) {
      return Promise.resolve(current(config)).then(next);
    }

    return Promise.resolve();
  };

  return next();
}

function loadPlugin(config, loader, info) {
  logger.debug('Loading plugin ' + info.moduleId + '.');
  config.resourcesRelativeTo = info.resourcesRelativeTo;

  var id = info.moduleId;

  if (info.resourcesRelativeTo.length > 1) {
    return loader.normalize(info.moduleId, info.resourcesRelativeTo[1]).then(function (normalizedId) {
      return _loadPlugin(normalizedId);
    });
  }

  return _loadPlugin(id);

  function _loadPlugin(moduleId) {
    return loader.loadModule(moduleId).then(function (m) {
      if ('configure' in m) {
        return Promise.resolve(m.configure(config, info.config || {})).then(function () {
          config.resourcesRelativeTo = null;
          logger.debug('Configured plugin ' + info.moduleId + '.');
        });
      }

      config.resourcesRelativeTo = null;
      logger.debug('Loaded plugin ' + info.moduleId + '.');
    });
  }
}

function loadResources(aurelia, resourcesToLoad, appResources) {
  var viewEngine = aurelia.container.get(_aureliaTemplating.ViewEngine);

  return Promise.all(Object.keys(resourcesToLoad).map(function (n) {
    return _normalize(resourcesToLoad[n]);
  })).then(function (loads) {
    var names = [];
    var importIds = [];

    loads.forEach(function (l) {
      names.push(undefined);
      importIds.push(l.importId);
    });

    return viewEngine.importViewResources(importIds, names, appResources);
  });

  function _normalize(load) {
    var moduleId = load.moduleId;
    var ext = getExt(moduleId);

    if (isOtherResource(moduleId)) {
      moduleId = removeExt(moduleId);
    }

    return aurelia.loader.normalize(moduleId, load.relativeTo).then(function (normalized) {
      return {
        name: load.moduleId,
        importId: isOtherResource(load.moduleId) ? addOriginalExt(normalized, ext) : normalized
      };
    });
  }

  function isOtherResource(name) {
    var ext = getExt(name);
    if (!ext) return false;
    if (ext === '') return false;
    if (ext === '.js' || ext === '.ts') return false;
    return true;
  }

  function removeExt(name) {
    return name.replace(extPattern, '');
  }

  function addOriginalExt(normalized, ext) {
    return removeExt(normalized) + '.' + ext;
  }
}

function getExt(name) {
  var match = name.match(extPattern);
  if (match && match.length > 0) {
    return match[0].split('.')[1];
  }
}

function assertProcessed(plugins) {
  if (plugins.processed) {
    throw new Error('This config instance has already been applied. To load more plugins or global resources, create a new FrameworkConfiguration instance.');
  }
}

var FrameworkConfiguration = function () {
  function FrameworkConfiguration(aurelia) {
    var _this4 = this;

    

    this.aurelia = aurelia;
    this.container = aurelia.container;
    this.info = [];
    this.processed = false;
    this.preTasks = [];
    this.postTasks = [];
    this.resourcesToLoad = {};
    this.preTask(function () {
      return aurelia.loader.normalize('aurelia-bootstrapper').then(function (name) {
        return _this4.bootstrapperName = name;
      });
    });
    this.postTask(function () {
      return loadResources(aurelia, _this4.resourcesToLoad, aurelia.resources);
    });
  }

  FrameworkConfiguration.prototype.instance = function instance(type, _instance) {
    this.container.registerInstance(type, _instance);
    return this;
  };

  FrameworkConfiguration.prototype.singleton = function singleton(type, implementation) {
    this.container.registerSingleton(type, implementation);
    return this;
  };

  FrameworkConfiguration.prototype.transient = function transient(type, implementation) {
    this.container.registerTransient(type, implementation);
    return this;
  };

  FrameworkConfiguration.prototype.preTask = function preTask(task) {
    assertProcessed(this);
    this.preTasks.push(task);
    return this;
  };

  FrameworkConfiguration.prototype.postTask = function postTask(task) {
    assertProcessed(this);
    this.postTasks.push(task);
    return this;
  };

  FrameworkConfiguration.prototype.feature = function feature(plugin) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var hasIndex = /\/index$/i.test(plugin);
    var moduleId = hasIndex || getExt(plugin) ? plugin : plugin + '/index';
    var root = hasIndex ? plugin.substr(0, plugin.length - 6) : plugin;
    return this.plugin({ moduleId: moduleId, resourcesRelativeTo: [root, ''], config: config });
  };

  FrameworkConfiguration.prototype.globalResources = function globalResources(resources) {
    assertProcessed(this);

    var toAdd = Array.isArray(resources) ? resources : arguments;
    var resource = void 0;
    var resourcesRelativeTo = this.resourcesRelativeTo || ['', ''];

    for (var i = 0, ii = toAdd.length; i < ii; ++i) {
      resource = toAdd[i];
      if (typeof resource !== 'string') {
        throw new Error('Invalid resource path [' + resource + ']. Resources must be specified as relative module IDs.');
      }

      var parent = resourcesRelativeTo[0];
      var grandParent = resourcesRelativeTo[1];
      var name = resource;

      if ((resource.startsWith('./') || resource.startsWith('../')) && parent !== '') {
        name = (0, _aureliaPath.join)(parent, resource);
      }

      this.resourcesToLoad[name] = { moduleId: name, relativeTo: grandParent };
    }

    return this;
  };

  FrameworkConfiguration.prototype.globalName = function globalName(resourcePath, newName) {
    assertProcessed(this);
    this.resourcesToLoad[resourcePath] = { moduleId: newName, relativeTo: '' };
    return this;
  };

  FrameworkConfiguration.prototype.plugin = function plugin(_plugin, config) {
    assertProcessed(this);

    if (typeof _plugin === 'string') {
      return this.plugin({ moduleId: _plugin, resourcesRelativeTo: [_plugin, ''], config: config || {} });
    }

    this.info.push(_plugin);
    return this;
  };

  FrameworkConfiguration.prototype._addNormalizedPlugin = function _addNormalizedPlugin(name, config) {
    var _this5 = this;

    var plugin = { moduleId: name, resourcesRelativeTo: [name, ''], config: config || {} };
    this.plugin(plugin);

    this.preTask(function () {
      var relativeTo = [name, _this5.bootstrapperName];
      plugin.moduleId = name;
      plugin.resourcesRelativeTo = relativeTo;
      return Promise.resolve();
    });

    return this;
  };

  FrameworkConfiguration.prototype.defaultBindingLanguage = function defaultBindingLanguage() {
    return this._addNormalizedPlugin('aurelia-templating-binding');
  };

  FrameworkConfiguration.prototype.router = function router() {
    return this._addNormalizedPlugin('aurelia-templating-router');
  };

  FrameworkConfiguration.prototype.history = function history() {
    return this._addNormalizedPlugin('aurelia-history-browser');
  };

  FrameworkConfiguration.prototype.defaultResources = function defaultResources() {
    return this._addNormalizedPlugin('aurelia-templating-resources');
  };

  FrameworkConfiguration.prototype.eventAggregator = function eventAggregator() {
    return this._addNormalizedPlugin('aurelia-event-aggregator');
  };

  FrameworkConfiguration.prototype.basicConfiguration = function basicConfiguration() {
    return this.defaultBindingLanguage().defaultResources().eventAggregator();
  };

  FrameworkConfiguration.prototype.standardConfiguration = function standardConfiguration() {
    return this.basicConfiguration().history().router();
  };

  FrameworkConfiguration.prototype.developmentLogging = function developmentLogging(level) {
    var _this6 = this;

    var logLevel = level ? TheLogManager.logLevel[level] : undefined;

    if (logLevel === undefined) {
      logLevel = TheLogManager.logLevel.debug;
    }

    this.preTask(function () {
      return _this6.aurelia.loader.normalize('aurelia-logging-console', _this6.bootstrapperName).then(function (name) {
        return _this6.aurelia.loader.loadModule(name).then(function (m) {
          TheLogManager.addAppender(new m.ConsoleAppender());
          TheLogManager.setLevel(logLevel);
        });
      });
    });

    return this;
  };

  FrameworkConfiguration.prototype.apply = function apply() {
    var _this7 = this;

    if (this.processed) {
      return Promise.resolve();
    }

    return runTasks(this, this.preTasks).then(function () {
      var loader = _this7.aurelia.loader;
      var info = _this7.info;
      var current = void 0;

      var next = function next() {
        current = info.shift();
        if (current) {
          return loadPlugin(_this7, loader, current).then(next);
        }

        _this7.processed = true;
        return Promise.resolve();
      };

      return next().then(function () {
        return runTasks(_this7, _this7.postTasks);
      });
    });
  };

  return FrameworkConfiguration;
}();

exports.FrameworkConfiguration = FrameworkConfiguration;
var LogManager = exports.LogManager = TheLogManager;
});

define('aurelia-history-browser/dist/commonjs/aurelia-history-browser',['require','exports','module','aurelia-pal','aurelia-history'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BrowserHistory = exports.DefaultLinkHandler = exports.LinkHandler = undefined;

var _class, _temp;

exports.configure = configure;

var _aureliaPal = require('aurelia-pal');

var _aureliaHistory = require('aurelia-history');

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var LinkHandler = exports.LinkHandler = function () {
  function LinkHandler() {
    
  }

  LinkHandler.prototype.activate = function activate(history) {};

  LinkHandler.prototype.deactivate = function deactivate() {};

  return LinkHandler;
}();

var DefaultLinkHandler = exports.DefaultLinkHandler = function (_LinkHandler) {
  _inherits(DefaultLinkHandler, _LinkHandler);

  function DefaultLinkHandler() {
    

    var _this = _possibleConstructorReturn(this, _LinkHandler.call(this));

    _this.handler = function (e) {
      var _DefaultLinkHandler$g = DefaultLinkHandler.getEventInfo(e);

      var shouldHandleEvent = _DefaultLinkHandler$g.shouldHandleEvent;
      var href = _DefaultLinkHandler$g.href;


      if (shouldHandleEvent) {
        e.preventDefault();
        _this.history.navigate(href);
      }
    };
    return _this;
  }

  DefaultLinkHandler.prototype.activate = function activate(history) {
    if (history._hasPushState) {
      this.history = history;
      _aureliaPal.DOM.addEventListener('click', this.handler, true);
    }
  };

  DefaultLinkHandler.prototype.deactivate = function deactivate() {
    _aureliaPal.DOM.removeEventListener('click', this.handler);
  };

  DefaultLinkHandler.getEventInfo = function getEventInfo(event) {
    var info = {
      shouldHandleEvent: false,
      href: null,
      anchor: null
    };

    var target = DefaultLinkHandler.findClosestAnchor(event.target);
    if (!target || !DefaultLinkHandler.targetIsThisWindow(target)) {
      return info;
    }

    if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
      return info;
    }

    var href = target.getAttribute('href');
    info.anchor = target;
    info.href = href;

    var leftButtonClicked = event.which === 1;
    var isRelative = href && !(href.charAt(0) === '#' || /^[a-z]+:/i.test(href));

    info.shouldHandleEvent = leftButtonClicked && isRelative;
    return info;
  };

  DefaultLinkHandler.findClosestAnchor = function findClosestAnchor(el) {
    while (el) {
      if (el.tagName === 'A') {
        return el;
      }

      el = el.parentNode;
    }
  };

  DefaultLinkHandler.targetIsThisWindow = function targetIsThisWindow(target) {
    var targetWindow = target.getAttribute('target');
    var win = _aureliaPal.PLATFORM.global;

    return !targetWindow || targetWindow === win.name || targetWindow === '_self' || targetWindow === 'top' && win === win.top;
  };

  return DefaultLinkHandler;
}(LinkHandler);

function configure(config) {
  config.singleton(_aureliaHistory.History, BrowserHistory);
  config.transient(LinkHandler, DefaultLinkHandler);
}

var BrowserHistory = exports.BrowserHistory = (_temp = _class = function (_History) {
  _inherits(BrowserHistory, _History);

  function BrowserHistory(linkHandler) {
    

    var _this2 = _possibleConstructorReturn(this, _History.call(this));

    _this2._isActive = false;
    _this2._checkUrlCallback = _this2._checkUrl.bind(_this2);

    _this2.location = _aureliaPal.PLATFORM.location;
    _this2.history = _aureliaPal.PLATFORM.history;
    _this2.linkHandler = linkHandler;
    return _this2;
  }

  BrowserHistory.prototype.activate = function activate(options) {
    if (this._isActive) {
      throw new Error('History has already been activated.');
    }

    var wantsPushState = !!options.pushState;

    this._isActive = true;
    this.options = Object.assign({}, { root: '/' }, this.options, options);

    this.root = ('/' + this.options.root + '/').replace(rootStripper, '/');

    this._wantsHashChange = this.options.hashChange !== false;
    this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);

    var eventName = void 0;
    if (this._hasPushState) {
      eventName = 'popstate';
    } else if (this._wantsHashChange) {
      eventName = 'hashchange';
    }

    _aureliaPal.PLATFORM.addEventListener(eventName, this._checkUrlCallback);

    if (this._wantsHashChange && wantsPushState) {
      var loc = this.location;
      var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

      if (!this._hasPushState && !atRoot) {
        this.fragment = this._getFragment(null, true);
        this.location.replace(this.root + this.location.search + '#' + this.fragment);

        return true;
      } else if (this._hasPushState && atRoot && loc.hash) {
          this.fragment = this._getHash().replace(routeStripper, '');
          this.history.replaceState({}, _aureliaPal.DOM.title, this.root + this.fragment + loc.search);
        }
    }

    if (!this.fragment) {
      this.fragment = this._getFragment();
    }

    this.linkHandler.activate(this);

    if (!this.options.silent) {
      return this._loadUrl();
    }
  };

  BrowserHistory.prototype.deactivate = function deactivate() {
    _aureliaPal.PLATFORM.removeEventListener('popstate', this._checkUrlCallback);
    _aureliaPal.PLATFORM.removeEventListener('hashchange', this._checkUrlCallback);
    this._isActive = false;
    this.linkHandler.deactivate();
  };

  BrowserHistory.prototype.getAbsoluteRoot = function getAbsoluteRoot() {
    var origin = createOrigin(this.location.protocol, this.location.hostname, this.location.port);
    return '' + origin + this.root;
  };

  BrowserHistory.prototype.navigate = function navigate(fragment) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var _ref$trigger = _ref.trigger;
    var trigger = _ref$trigger === undefined ? true : _ref$trigger;
    var _ref$replace = _ref.replace;
    var replace = _ref$replace === undefined ? false : _ref$replace;

    if (fragment && absoluteUrl.test(fragment)) {
      this.location.href = fragment;
      return true;
    }

    if (!this._isActive) {
      return false;
    }

    fragment = this._getFragment(fragment || '');

    if (this.fragment === fragment && !replace) {
      return false;
    }

    this.fragment = fragment;

    var url = this.root + fragment;

    if (fragment === '' && url !== '/') {
      url = url.slice(0, -1);
    }

    if (this._hasPushState) {
      url = url.replace('//', '/');
      this.history[replace ? 'replaceState' : 'pushState']({}, _aureliaPal.DOM.title, url);
    } else if (this._wantsHashChange) {
      updateHash(this.location, fragment, replace);
    } else {
      return this.location.assign(url);
    }

    if (trigger) {
      return this._loadUrl(fragment);
    }
  };

  BrowserHistory.prototype.navigateBack = function navigateBack() {
    this.history.back();
  };

  BrowserHistory.prototype.setTitle = function setTitle(title) {
    _aureliaPal.DOM.title = title;
  };

  BrowserHistory.prototype.setState = function setState(key, value) {
    var state = Object.assign({}, this.history.state);
    var _location = this.location;
    var pathname = _location.pathname;
    var search = _location.search;
    var hash = _location.hash;

    state[key] = value;
    this.history.replaceState(state, null, '' + pathname + search + hash);
  };

  BrowserHistory.prototype.getState = function getState(key) {
    var state = Object.assign({}, this.history.state);
    return state[key];
  };

  BrowserHistory.prototype._getHash = function _getHash() {
    return this.location.hash.substr(1);
  };

  BrowserHistory.prototype._getFragment = function _getFragment(fragment, forcePushState) {
    var root = void 0;

    if (!fragment) {
      if (this._hasPushState || !this._wantsHashChange || forcePushState) {
        fragment = this.location.pathname + this.location.search;
        root = this.root.replace(trailingSlash, '');
        if (!fragment.indexOf(root)) {
          fragment = fragment.substr(root.length);
        }
      } else {
        fragment = this._getHash();
      }
    }

    return '/' + fragment.replace(routeStripper, '');
  };

  BrowserHistory.prototype._checkUrl = function _checkUrl() {
    var current = this._getFragment();
    if (current !== this.fragment) {
      this._loadUrl();
    }
  };

  BrowserHistory.prototype._loadUrl = function _loadUrl(fragmentOverride) {
    var fragment = this.fragment = this._getFragment(fragmentOverride);

    return this.options.routeHandler ? this.options.routeHandler(fragment) : false;
  };

  return BrowserHistory;
}(_aureliaHistory.History), _class.inject = [LinkHandler], _temp);

var routeStripper = /^#?\/*|\s+$/g;

var rootStripper = /^\/+|\/+$/g;

var trailingSlash = /\/$/;

var absoluteUrl = /^([a-z][a-z0-9+\-.]*:)?\/\//i;

function updateHash(location, fragment, replace) {
  if (replace) {
    var _href = location.href.replace(/(javascript:|#).*$/, '');
    location.replace(_href + '#' + fragment);
  } else {
    location.hash = '#' + fragment;
  }
}

function createOrigin(protocol, hostname, port) {
  return protocol + '//' + hostname + (port ? ':' + port : '');
}
});

define('aurelia-history/dist/commonjs/aurelia-history',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});



function mi(name) {
  throw new Error('History must implement ' + name + '().');
}

var History = exports.History = function () {
  function History() {
    
  }

  History.prototype.activate = function activate(options) {
    mi('activate');
  };

  History.prototype.deactivate = function deactivate() {
    mi('deactivate');
  };

  History.prototype.getAbsoluteRoot = function getAbsoluteRoot() {
    mi('getAbsoluteRoot');
  };

  History.prototype.navigate = function navigate(fragment, options) {
    mi('navigate');
  };

  History.prototype.navigateBack = function navigateBack() {
    mi('navigateBack');
  };

  History.prototype.setTitle = function setTitle(title) {
    mi('setTitle');
  };

  History.prototype.setState = function setState(key, value) {
    mi('setState');
  };

  History.prototype.getState = function getState(key) {
    mi('getState');
  };

  return History;
}();
});

define('aurelia-loader-default/dist/commonjs/aurelia-loader-default',['require','exports','module','aurelia-loader','aurelia-pal','aurelia-metadata'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DefaultLoader = exports.TextTemplateLoader = undefined;

var _aureliaLoader = require('aurelia-loader');

var _aureliaPal = require('aurelia-pal');

var _aureliaMetadata = require('aurelia-metadata');

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var TextTemplateLoader = exports.TextTemplateLoader = function () {
  function TextTemplateLoader() {
    
  }

  TextTemplateLoader.prototype.loadTemplate = function loadTemplate(loader, entry) {
    return loader.loadText(entry.address).then(function (text) {
      entry.template = _aureliaPal.DOM.createTemplateFromMarkup(text);
    });
  };

  return TextTemplateLoader;
}();

function ensureOriginOnExports(executed, name) {
  var target = executed;
  var key = void 0;
  var exportedValue = void 0;

  if (target.__useDefault) {
    target = target['default'];
  }

  _aureliaMetadata.Origin.set(target, new _aureliaMetadata.Origin(name, 'default'));

  for (key in target) {
    exportedValue = target[key];

    if (typeof exportedValue === 'function') {
      _aureliaMetadata.Origin.set(exportedValue, new _aureliaMetadata.Origin(name, key));
    }
  }

  return executed;
}

var DefaultLoader = exports.DefaultLoader = function (_Loader) {
  _inherits(DefaultLoader, _Loader);

  function DefaultLoader() {
    

    var _this = _possibleConstructorReturn(this, _Loader.call(this));

    _this.textPluginName = 'text';


    _this.moduleRegistry = Object.create(null);
    _this.useTemplateLoader(new TextTemplateLoader());

    var that = _this;

    _this.addPlugin('template-registry-entry', {
      'fetch': function fetch(address) {
        var entry = that.getOrCreateTemplateRegistryEntry(address);
        return entry.templateIsLoaded ? entry : that.templateLoader.loadTemplate(that, entry).then(function (x) {
          return entry;
        });
      }
    });
    return _this;
  }

  DefaultLoader.prototype.useTemplateLoader = function useTemplateLoader(templateLoader) {
    this.templateLoader = templateLoader;
  };

  DefaultLoader.prototype.loadAllModules = function loadAllModules(ids) {
    var loads = [];

    for (var i = 0, ii = ids.length; i < ii; ++i) {
      loads.push(this.loadModule(ids[i]));
    }

    return Promise.all(loads);
  };

  DefaultLoader.prototype.loadTemplate = function loadTemplate(url) {
    return this._import(this.applyPluginToUrl(url, 'template-registry-entry'));
  };

  DefaultLoader.prototype.loadText = function loadText(url) {
    return this._import(this.applyPluginToUrl(url, this.textPluginName)).then(function (textOrModule) {
      if (typeof textOrModule === 'string') {
        return textOrModule;
      }

      return textOrModule['default'];
    });
  };

  return DefaultLoader;
}(_aureliaLoader.Loader);

_aureliaPal.PLATFORM.Loader = DefaultLoader;

if (!_aureliaPal.PLATFORM.global.System || !_aureliaPal.PLATFORM.global.System.import) {
  if (_aureliaPal.PLATFORM.global.requirejs && requirejs.s && requirejs.s.contexts && requirejs.s.contexts._ && requirejs.s.contexts._.defined) {
    _aureliaPal.PLATFORM.eachModule = function (callback) {
      var defined = requirejs.s.contexts._.defined;
      for (var key in defined) {
        try {
          if (callback(key, defined[key])) return;
        } catch (e) {}
      }
    };
  } else {
    _aureliaPal.PLATFORM.eachModule = function (callback) {};
  }

  DefaultLoader.prototype._import = function (moduleId) {
    return new Promise(function (resolve, reject) {
      _aureliaPal.PLATFORM.global.require([moduleId], resolve, reject);
    });
  };

  DefaultLoader.prototype.loadModule = function (id) {
    var _this2 = this;

    var existing = this.moduleRegistry[id];
    if (existing !== undefined) {
      return Promise.resolve(existing);
    }

    return new Promise(function (resolve, reject) {
      _aureliaPal.PLATFORM.global.require([id], function (m) {
        _this2.moduleRegistry[id] = m;
        resolve(ensureOriginOnExports(m, id));
      }, reject);
    });
  };

  DefaultLoader.prototype.map = function (id, source) {};

  DefaultLoader.prototype.normalize = function (moduleId, relativeTo) {
    return Promise.resolve(moduleId);
  };

  DefaultLoader.prototype.normalizeSync = function (moduleId, relativeTo) {
    return moduleId;
  };

  DefaultLoader.prototype.applyPluginToUrl = function (url, pluginName) {
    return pluginName + '!' + url;
  };

  DefaultLoader.prototype.addPlugin = function (pluginName, implementation) {
    var nonAnonDefine = define;
    nonAnonDefine(pluginName, [], {
      'load': function load(name, req, onload) {
        var result = implementation.fetch(name);
        Promise.resolve(result).then(onload);
      }
    });
  };
} else {
  _aureliaPal.PLATFORM.eachModule = function (callback) {
    if (System.registry) {
      var keys = Array.from(System.registry.keys());
      for (var i = 0; i < keys.length; i++) {
        try {
          var key = keys[i];
          if (callback(key, System.registry.get(key))) {
            return;
          }
        } catch (e) {}
      }
      return;
    }

    var modules = System._loader.modules;

    for (var _key in modules) {
      try {
        if (callback(_key, modules[_key].module)) return;
      } catch (e) {}
    }
  };

  System.set('text', System.newModule({
    'translate': function translate(load) {
      return 'module.exports = "' + load.source.replace(/(["\\])/g, '\\$1').replace(/[\f]/g, '\\f').replace(/[\b]/g, '\\b').replace(/[\n]/g, '\\n').replace(/[\t]/g, '\\t').replace(/[\r]/g, '\\r').replace(/[\u2028]/g, '\\u2028').replace(/[\u2029]/g, '\\u2029') + '";';
    }
  }));

  DefaultLoader.prototype._import = function (moduleId) {
    return System.import(moduleId);
  };

  DefaultLoader.prototype.loadModule = function (id) {
    var _this3 = this;

    return System.normalize(id).then(function (newId) {
      var existing = _this3.moduleRegistry[newId];
      if (existing !== undefined) {
        return Promise.resolve(existing);
      }

      return System.import(newId).then(function (m) {
        _this3.moduleRegistry[newId] = m;
        return ensureOriginOnExports(m, newId);
      });
    });
  };

  DefaultLoader.prototype.map = function (id, source) {
    var _map;

    System.config({ map: (_map = {}, _map[id] = source, _map) });
  };

  DefaultLoader.prototype.normalizeSync = function (moduleId, relativeTo) {
    return System.normalizeSync(moduleId, relativeTo);
  };

  DefaultLoader.prototype.normalize = function (moduleId, relativeTo) {
    return System.normalize(moduleId, relativeTo);
  };

  DefaultLoader.prototype.applyPluginToUrl = function (url, pluginName) {
    return url + '!' + pluginName;
  };

  DefaultLoader.prototype.addPlugin = function (pluginName, implementation) {
    System.set(pluginName, System.newModule({
      'fetch': function fetch(load, _fetch) {
        var result = implementation.fetch(load.address);
        return Promise.resolve(result).then(function (x) {
          load.metadata.result = x;
          return '';
        });
      },
      'instantiate': function instantiate(load) {
        return load.metadata.result;
      }
    }));
  };
}
});

define('aurelia-loader/dist/commonjs/aurelia-loader',['require','exports','module','aurelia-path','aurelia-metadata'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Loader = exports.TemplateRegistryEntry = exports.TemplateDependency = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _aureliaPath = require('aurelia-path');

var _aureliaMetadata = require('aurelia-metadata');



var TemplateDependency = exports.TemplateDependency = function TemplateDependency(src, name) {
  

  this.src = src;
  this.name = name;
};

var TemplateRegistryEntry = exports.TemplateRegistryEntry = function () {
  function TemplateRegistryEntry(address) {
    

    this.templateIsLoaded = false;
    this.factoryIsReady = false;
    this.resources = null;
    this.dependencies = null;

    this.address = address;
    this.onReady = null;
    this._template = null;
    this._factory = null;
  }

  TemplateRegistryEntry.prototype.addDependency = function addDependency(src, name) {
    var finalSrc = typeof src === 'string' ? (0, _aureliaPath.relativeToFile)(src, this.address) : _aureliaMetadata.Origin.get(src).moduleId;

    this.dependencies.push(new TemplateDependency(finalSrc, name));
  };

  _createClass(TemplateRegistryEntry, [{
    key: 'template',
    get: function get() {
      return this._template;
    },
    set: function set(value) {
      var address = this.address;
      var requires = void 0;
      var current = void 0;
      var src = void 0;
      var dependencies = void 0;

      this._template = value;
      this.templateIsLoaded = true;

      requires = value.content.querySelectorAll('require');
      dependencies = this.dependencies = new Array(requires.length);

      for (var i = 0, ii = requires.length; i < ii; ++i) {
        current = requires[i];
        src = current.getAttribute('from');

        if (!src) {
          throw new Error('<require> element in ' + address + ' has no "from" attribute.');
        }

        dependencies[i] = new TemplateDependency((0, _aureliaPath.relativeToFile)(src, address), current.getAttribute('as'));

        if (current.parentNode) {
          current.parentNode.removeChild(current);
        }
      }
    }
  }, {
    key: 'factory',
    get: function get() {
      return this._factory;
    },
    set: function set(value) {
      this._factory = value;
      this.factoryIsReady = true;
    }
  }]);

  return TemplateRegistryEntry;
}();

var Loader = exports.Loader = function () {
  function Loader() {
    

    this.templateRegistry = {};
  }

  Loader.prototype.map = function map(id, source) {
    throw new Error('Loaders must implement map(id, source).');
  };

  Loader.prototype.normalizeSync = function normalizeSync(moduleId, relativeTo) {
    throw new Error('Loaders must implement normalizeSync(moduleId, relativeTo).');
  };

  Loader.prototype.normalize = function normalize(moduleId, relativeTo) {
    throw new Error('Loaders must implement normalize(moduleId: string, relativeTo: string): Promise<string>.');
  };

  Loader.prototype.loadModule = function loadModule(id) {
    throw new Error('Loaders must implement loadModule(id).');
  };

  Loader.prototype.loadAllModules = function loadAllModules(ids) {
    throw new Error('Loader must implement loadAllModules(ids).');
  };

  Loader.prototype.loadTemplate = function loadTemplate(url) {
    throw new Error('Loader must implement loadTemplate(url).');
  };

  Loader.prototype.loadText = function loadText(url) {
    throw new Error('Loader must implement loadText(url).');
  };

  Loader.prototype.applyPluginToUrl = function applyPluginToUrl(url, pluginName) {
    throw new Error('Loader must implement applyPluginToUrl(url, pluginName).');
  };

  Loader.prototype.addPlugin = function addPlugin(pluginName, implementation) {
    throw new Error('Loader must implement addPlugin(pluginName, implementation).');
  };

  Loader.prototype.getOrCreateTemplateRegistryEntry = function getOrCreateTemplateRegistryEntry(address) {
    return this.templateRegistry[address] || (this.templateRegistry[address] = new TemplateRegistryEntry(address));
  };

  return Loader;
}();
});

define('aurelia-logging-console/dist/commonjs/aurelia-logging-console',['require','exports','module','aurelia-logging'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConsoleAppender = undefined;

var _aureliaLogging = require('aurelia-logging');



var ConsoleAppender = exports.ConsoleAppender = function () {
  function ConsoleAppender() {
    
  }

  ConsoleAppender.prototype.debug = function debug(logger) {
    var _console;

    for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    (_console = console).debug.apply(_console, ['DEBUG [' + logger.id + ']'].concat(rest));
  };

  ConsoleAppender.prototype.info = function info(logger) {
    var _console2;

    for (var _len2 = arguments.length, rest = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      rest[_key2 - 1] = arguments[_key2];
    }

    (_console2 = console).info.apply(_console2, ['INFO [' + logger.id + ']'].concat(rest));
  };

  ConsoleAppender.prototype.warn = function warn(logger) {
    var _console3;

    for (var _len3 = arguments.length, rest = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      rest[_key3 - 1] = arguments[_key3];
    }

    (_console3 = console).warn.apply(_console3, ['WARN [' + logger.id + ']'].concat(rest));
  };

  ConsoleAppender.prototype.error = function error(logger) {
    var _console4;

    for (var _len4 = arguments.length, rest = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      rest[_key4 - 1] = arguments[_key4];
    }

    (_console4 = console).error.apply(_console4, ['ERROR [' + logger.id + ']'].concat(rest));
  };

  return ConsoleAppender;
}();
});

define('aurelia-logging/dist/commonjs/aurelia-logging',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLogger = getLogger;
exports.addAppender = addAppender;
exports.removeAppender = removeAppender;
exports.getAppenders = getAppenders;
exports.clearAppenders = clearAppenders;
exports.addCustomLevel = addCustomLevel;
exports.removeCustomLevel = removeCustomLevel;
exports.setLevel = setLevel;
exports.getLevel = getLevel;



var logLevel = exports.logLevel = {
  none: 0,
  error: 10,
  warn: 20,
  info: 30,
  debug: 40
};

var loggers = {};
var appenders = [];
var globalDefaultLevel = logLevel.none;

var standardLevels = ['none', 'error', 'warn', 'info', 'debug'];
function isStandardLevel(level) {
  return standardLevels.filter(function (l) {
    return l === level;
  }).length > 0;
}

function appendArgs() {
  return [this].concat(Array.prototype.slice.call(arguments));
}

function logFactory(level) {
  var threshold = logLevel[level];
  return function () {
    if (this.level < threshold) {
      return;
    }

    var args = appendArgs.apply(this, arguments);
    var i = appenders.length;
    while (i--) {
      var _appenders$i;

      (_appenders$i = appenders[i])[level].apply(_appenders$i, args);
    }
  };
}

function logFactoryCustom(level) {
  var threshold = logLevel[level];
  return function () {
    if (this.level < threshold) {
      return;
    }

    var args = appendArgs.apply(this, arguments);
    var i = appenders.length;
    while (i--) {
      var appender = appenders[i];
      if (appender[level] !== undefined) {
        appender[level].apply(appender, args);
      }
    }
  };
}

function connectLoggers() {
  var proto = Logger.prototype;
  for (var _level in logLevel) {
    if (isStandardLevel(_level)) {
      if (_level !== 'none') {
        proto[_level] = logFactory(_level);
      }
    } else {
      proto[_level] = logFactoryCustom(_level);
    }
  }
}

function disconnectLoggers() {
  var proto = Logger.prototype;
  for (var _level2 in logLevel) {
    if (_level2 !== 'none') {
      proto[_level2] = function () {};
    }
  }
}

function getLogger(id) {
  return loggers[id] || new Logger(id);
}

function addAppender(appender) {
  if (appenders.push(appender) === 1) {
    connectLoggers();
  }
}

function removeAppender(appender) {
  appenders = appenders.filter(function (a) {
    return a !== appender;
  });
}

function getAppenders() {
  return [].concat(appenders);
}

function clearAppenders() {
  appenders = [];
  disconnectLoggers();
}

function addCustomLevel(name, value) {
  if (logLevel[name] !== undefined) {
    throw Error('Log level "' + name + '" already exists.');
  }

  if (isNaN(value)) {
    throw Error('Value must be a number.');
  }

  logLevel[name] = value;

  if (appenders.length > 0) {
    connectLoggers();
  } else {
    Logger.prototype[name] = function () {};
  }
}

function removeCustomLevel(name) {
  if (logLevel[name] === undefined) {
    return;
  }

  if (isStandardLevel(name)) {
    throw Error('Built-in log level "' + name + '" cannot be removed.');
  }

  delete logLevel[name];
  delete Logger.prototype[name];
}

function setLevel(level) {
  globalDefaultLevel = level;
  for (var key in loggers) {
    loggers[key].setLevel(level);
  }
}

function getLevel() {
  return globalDefaultLevel;
}

var Logger = exports.Logger = function () {
  function Logger(id) {
    

    var cached = loggers[id];
    if (cached) {
      return cached;
    }

    loggers[id] = this;
    this.id = id;
    this.level = globalDefaultLevel;
  }

  Logger.prototype.debug = function debug(message) {};

  Logger.prototype.info = function info(message) {};

  Logger.prototype.warn = function warn(message) {};

  Logger.prototype.error = function error(message) {};

  Logger.prototype.setLevel = function setLevel(level) {
    this.level = level;
  };

  return Logger;
}();
});

define('aurelia-metadata/dist/commonjs/aurelia-metadata',['require','exports','module','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Origin = exports.metadata = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.decorators = decorators;
exports.deprecated = deprecated;
exports.mixin = mixin;
exports.protocol = protocol;

var _aureliaPal = require('aurelia-pal');



function isObject(val) {
  return val && (typeof val === 'function' || (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object');
}

var metadata = exports.metadata = {
  resource: 'aurelia:resource',
  paramTypes: 'design:paramtypes',
  propertyType: 'design:type',
  properties: 'design:properties',
  get: function get(metadataKey, target, targetKey) {
    if (!isObject(target)) {
      return undefined;
    }
    var result = metadata.getOwn(metadataKey, target, targetKey);
    return result === undefined ? metadata.get(metadataKey, Object.getPrototypeOf(target), targetKey) : result;
  },
  getOwn: function getOwn(metadataKey, target, targetKey) {
    if (!isObject(target)) {
      return undefined;
    }
    return Reflect.getOwnMetadata(metadataKey, target, targetKey);
  },
  define: function define(metadataKey, metadataValue, target, targetKey) {
    Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
  },
  getOrCreateOwn: function getOrCreateOwn(metadataKey, Type, target, targetKey) {
    var result = metadata.getOwn(metadataKey, target, targetKey);

    if (result === undefined) {
      result = new Type();
      Reflect.defineMetadata(metadataKey, result, target, targetKey);
    }

    return result;
  }
};

var originStorage = new Map();
var unknownOrigin = Object.freeze({ moduleId: undefined, moduleMember: undefined });

var Origin = exports.Origin = function () {
  function Origin(moduleId, moduleMember) {
    

    this.moduleId = moduleId;
    this.moduleMember = moduleMember;
  }

  Origin.get = function get(fn) {
    var origin = originStorage.get(fn);

    if (origin === undefined) {
      _aureliaPal.PLATFORM.eachModule(function (key, value) {
        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
          for (var name in value) {
            var exp = value[name];
            if (exp === fn) {
              originStorage.set(fn, origin = new Origin(key, name));
              return true;
            }
          }
        }

        if (value === fn) {
          originStorage.set(fn, origin = new Origin(key, 'default'));
          return true;
        }

        return false;
      });
    }

    return origin || unknownOrigin;
  };

  Origin.set = function set(fn, origin) {
    originStorage.set(fn, origin);
  };

  return Origin;
}();

function decorators() {
  for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
    rest[_key] = arguments[_key];
  }

  var applicator = function applicator(target, key, descriptor) {
    var i = rest.length;

    if (key) {
      descriptor = descriptor || {
        value: target[key],
        writable: true,
        configurable: true,
        enumerable: true
      };

      while (i--) {
        descriptor = rest[i](target, key, descriptor) || descriptor;
      }

      Object.defineProperty(target, key, descriptor);
    } else {
      while (i--) {
        target = rest[i](target) || target;
      }
    }

    return target;
  };

  applicator.on = applicator;
  return applicator;
}

function deprecated(optionsOrTarget, maybeKey, maybeDescriptor) {
  function decorator(target, key, descriptor) {
    var methodSignature = target.constructor.name + '#' + key;
    var options = maybeKey ? {} : optionsOrTarget || {};
    var message = 'DEPRECATION - ' + methodSignature;

    if (typeof descriptor.value !== 'function') {
      throw new SyntaxError('Only methods can be marked as deprecated.');
    }

    if (options.message) {
      message += ' - ' + options.message;
    }

    return _extends({}, descriptor, {
      value: function deprecationWrapper() {
        if (options.error) {
          throw new Error(message);
        } else {
          console.warn(message);
        }

        return descriptor.value.apply(this, arguments);
      }
    });
  }

  return maybeKey ? decorator(optionsOrTarget, maybeKey, maybeDescriptor) : decorator;
}

function mixin(behavior) {
  var instanceKeys = Object.keys(behavior);

  function _mixin(possible) {
    var decorator = function decorator(target) {
      var resolvedTarget = typeof target === 'function' ? target.prototype : target;

      var i = instanceKeys.length;
      while (i--) {
        var property = instanceKeys[i];
        Object.defineProperty(resolvedTarget, property, {
          value: behavior[property],
          writable: true
        });
      }
    };

    return possible ? decorator(possible) : decorator;
  }

  return _mixin;
}

function alwaysValid() {
  return true;
}
function noCompose() {}

function ensureProtocolOptions(options) {
  if (options === undefined) {
    options = {};
  } else if (typeof options === 'function') {
    options = {
      validate: options
    };
  }

  if (!options.validate) {
    options.validate = alwaysValid;
  }

  if (!options.compose) {
    options.compose = noCompose;
  }

  return options;
}

function createProtocolValidator(validate) {
  return function (target) {
    var result = validate(target);
    return result === true;
  };
}

function createProtocolAsserter(name, validate) {
  return function (target) {
    var result = validate(target);
    if (result !== true) {
      throw new Error(result || name + ' was not correctly implemented.');
    }
  };
}

function protocol(name, options) {
  options = ensureProtocolOptions(options);

  var result = function result(target) {
    var resolvedTarget = typeof target === 'function' ? target.prototype : target;

    options.compose(resolvedTarget);
    result.assert(resolvedTarget);

    Object.defineProperty(resolvedTarget, 'protocol:' + name, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: true
    });
  };

  result.validate = createProtocolValidator(options.validate);
  result.assert = createProtocolAsserter(name, options.validate);

  return result;
}

protocol.create = function (name, options) {
  options = ensureProtocolOptions(options);
  var hidden = 'protocol:' + name;
  var result = function result(target) {
    var decorator = protocol(name, options);
    return target ? decorator(target) : decorator;
  };

  result.decorates = function (obj) {
    return obj[hidden] === true;
  };
  result.validate = createProtocolValidator(options.validate);
  result.assert = createProtocolAsserter(name, options.validate);

  return result;
};
});

define('aurelia-pal-browser/dist/commonjs/aurelia-pal-browser',['require','exports','module','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._DOM = exports._FEATURE = exports._PLATFORM = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.initialize = initialize;

var _aureliaPal = require('aurelia-pal');

var _PLATFORM = exports._PLATFORM = {
  location: window.location,
  history: window.history,
  addEventListener: function addEventListener(eventName, callback, capture) {
    this.global.addEventListener(eventName, callback, capture);
  },
  removeEventListener: function removeEventListener(eventName, callback, capture) {
    this.global.removeEventListener(eventName, callback, capture);
  },

  performance: window.performance,
  requestAnimationFrame: function requestAnimationFrame(callback) {
    return this.global.requestAnimationFrame(callback);
  }
};

if (typeof FEATURE_NO_IE === 'undefined') {
  var test = function test() {};

  if (test.name === undefined) {
    Object.defineProperty(Function.prototype, 'name', {
      get: function get() {
        var name = this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];

        Object.defineProperty(this, 'name', { value: name });
        return name;
      }
    });
  }
}

if (typeof FEATURE_NO_IE === 'undefined') {
  if (!('classList' in document.createElement('_')) || document.createElementNS && !('classList' in document.createElementNS('http://www.w3.org/2000/svg', 'g'))) {
    var protoProp = 'prototype';
    var strTrim = String.prototype.trim;
    var arrIndexOf = Array.prototype.indexOf;
    var emptyArray = [];

    var DOMEx = function DOMEx(type, message) {
      this.name = type;
      this.code = DOMException[type];
      this.message = message;
    };

    var checkTokenAndGetIndex = function checkTokenAndGetIndex(classList, token) {
      if (token === '') {
        throw new DOMEx('SYNTAX_ERR', 'An invalid or illegal string was specified');
      }

      if (/\s/.test(token)) {
        throw new DOMEx('INVALID_CHARACTER_ERR', 'String contains an invalid character');
      }

      return arrIndexOf.call(classList, token);
    };

    var ClassList = function ClassList(elem) {
      var trimmedClasses = strTrim.call(elem.getAttribute('class') || '');
      var classes = trimmedClasses ? trimmedClasses.split(/\s+/) : emptyArray;

      for (var i = 0, ii = classes.length; i < ii; ++i) {
        this.push(classes[i]);
      }

      this._updateClassName = function () {
        elem.setAttribute('class', this.toString());
      };
    };

    var classListProto = ClassList[protoProp] = [];

    DOMEx[protoProp] = Error[protoProp];

    classListProto.item = function (i) {
      return this[i] || null;
    };

    classListProto.contains = function (token) {
      token += '';
      return checkTokenAndGetIndex(this, token) !== -1;
    };

    classListProto.add = function () {
      var tokens = arguments;
      var i = 0;
      var ii = tokens.length;
      var token = void 0;
      var updated = false;

      do {
        token = tokens[i] + '';
        if (checkTokenAndGetIndex(this, token) === -1) {
          this.push(token);
          updated = true;
        }
      } while (++i < ii);

      if (updated) {
        this._updateClassName();
      }
    };

    classListProto.remove = function () {
      var tokens = arguments;
      var i = 0;
      var ii = tokens.length;
      var token = void 0;
      var updated = false;
      var index = void 0;

      do {
        token = tokens[i] + '';
        index = checkTokenAndGetIndex(this, token);
        while (index !== -1) {
          this.splice(index, 1);
          updated = true;
          index = checkTokenAndGetIndex(this, token);
        }
      } while (++i < ii);

      if (updated) {
        this._updateClassName();
      }
    };

    classListProto.toggle = function (token, force) {
      token += '';

      var result = this.contains(token);
      var method = result ? force !== true && 'remove' : force !== false && 'add';

      if (method) {
        this[method](token);
      }

      if (force === true || force === false) {
        return force;
      }

      return !result;
    };

    classListProto.toString = function () {
      return this.join(' ');
    };

    Object.defineProperty(Element.prototype, 'classList', {
      get: function get() {
        return new ClassList(this);
      },
      enumerable: true,
      configurable: true
    });
  } else {
    var testElement = document.createElement('_');
    testElement.classList.add('c1', 'c2');

    if (!testElement.classList.contains('c2')) {
      var createMethod = function createMethod(method) {
        var original = DOMTokenList.prototype[method];

        DOMTokenList.prototype[method] = function (token) {
          for (var i = 0, ii = arguments.length; i < ii; ++i) {
            token = arguments[i];
            original.call(this, token);
          }
        };
      };

      createMethod('add');
      createMethod('remove');
    }

    testElement.classList.toggle('c3', false);

    if (testElement.classList.contains('c3')) {
      var _toggle = DOMTokenList.prototype.toggle;

      DOMTokenList.prototype.toggle = function (token, force) {
        if (1 in arguments && !this.contains(token) === !force) {
          return force;
        }

        return _toggle.call(this, token);
      };
    }

    testElement = null;
  }
}

if (typeof FEATURE_NO_IE === 'undefined') {
  var _filterEntries = function _filterEntries(key, value) {
    var i = 0,
        n = _entries.length,
        result = [];
    for (; i < n; i++) {
      if (_entries[i][key] == value) {
        result.push(_entries[i]);
      }
    }
    return result;
  };

  var _clearEntries = function _clearEntries(type, name) {
    var i = _entries.length,
        entry;
    while (i--) {
      entry = _entries[i];
      if (entry.entryType == type && (name === void 0 || entry.name == name)) {
        _entries.splice(i, 1);
      }
    }
  };

  // @license http://opensource.org/licenses/MIT
  if ('performance' in window === false) {
    window.performance = {};
  }

  if ('now' in window.performance === false) {
    var nowOffset = Date.now();

    if (performance.timing && performance.timing.navigationStart) {
      nowOffset = performance.timing.navigationStart;
    }

    window.performance.now = function now() {
      return Date.now() - nowOffset;
    };
  }

  var startOffset = Date.now ? Date.now() : +new Date();
  var _entries = [];
  var _marksIndex = {};

  ;

  if (!window.performance.mark) {
    window.performance.mark = window.performance.webkitMark || function (name) {
      var mark = {
        name: name,
        entryType: "mark",
        startTime: window.performance.now(),
        duration: 0
      };

      _entries.push(mark);
      _marksIndex[name] = mark;
    };
  }

  if (!window.performance.measure) {
    window.performance.measure = window.performance.webkitMeasure || function (name, startMark, endMark) {
      startMark = _marksIndex[startMark].startTime;
      endMark = _marksIndex[endMark].startTime;

      _entries.push({
        name: name,
        entryType: "measure",
        startTime: startMark,
        duration: endMark - startMark
      });
    };
  }

  if (!window.performance.getEntriesByType) {
    window.performance.getEntriesByType = window.performance.webkitGetEntriesByType || function (type) {
      return _filterEntries("entryType", type);
    };
  }

  if (!window.performance.getEntriesByName) {
    window.performance.getEntriesByName = window.performance.webkitGetEntriesByName || function (name) {
      return _filterEntries("name", name);
    };
  }

  if (!window.performance.clearMarks) {
    window.performance.clearMarks = window.performance.webkitClearMarks || function (name) {
      _clearEntries("mark", name);
    };
  }

  if (!window.performance.clearMeasures) {
    window.performance.clearMeasures = window.performance.webkitClearMeasures || function (name) {
      _clearEntries("measure", name);
    };
  }

  _PLATFORM.performance = window.performance;
}

if (typeof FEATURE_NO_IE === 'undefined') {
  var con = window.console = window.console || {};
  var nop = function nop() {};

  if (!con.memory) con.memory = {};
  ('assert,clear,count,debug,dir,dirxml,error,exception,group,' + 'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' + 'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(',').forEach(function (m) {
    if (!con[m]) con[m] = nop;
  });

  if (_typeof(con.log) === 'object') {
    'log,info,warn,error,assert,dir,clear,profile,profileEnd'.split(',').forEach(function (method) {
      console[method] = this.bind(console[method], console);
    }, Function.prototype.call);
  }
}

if (typeof FEATURE_NO_IE === 'undefined') {
  if (!window.CustomEvent || typeof window.CustomEvent !== 'function') {
    var _CustomEvent = function _CustomEvent(event, params) {
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };

      var evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    };

    _CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = _CustomEvent;
  }
}

if (Element && !Element.prototype.matches) {
  var proto = Element.prototype;
  proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
}

var _FEATURE = exports._FEATURE = {
  shadowDOM: !!HTMLElement.prototype.attachShadow,
  scopedCSS: 'scoped' in document.createElement('style'),
  htmlTemplateElement: function () {
    var d = document.createElement('div');
    d.innerHTML = '<template></template>';
    return 'content' in d.children[0];
  }(),
  mutationObserver: !!(window.MutationObserver || window.WebKitMutationObserver),
  ensureHTMLTemplateElement: function ensureHTMLTemplateElement(t) {
    return t;
  }
};

if (typeof FEATURE_NO_IE === 'undefined') {
  var isSVGTemplate = function isSVGTemplate(el) {
    return el.tagName === 'template' && el.namespaceURI === 'http://www.w3.org/2000/svg';
  };

  var fixSVGTemplateElement = function fixSVGTemplateElement(el) {
    var template = el.ownerDocument.createElement('template');
    var attrs = el.attributes;
    var length = attrs.length;
    var attr = void 0;

    el.parentNode.insertBefore(template, el);

    while (length-- > 0) {
      attr = attrs[length];
      template.setAttribute(attr.name, attr.value);
      el.removeAttribute(attr.name);
    }

    el.parentNode.removeChild(el);

    return fixHTMLTemplateElement(template);
  };

  var fixHTMLTemplateElement = function fixHTMLTemplateElement(template) {
    var content = template.content = document.createDocumentFragment();
    var child = void 0;

    while (child = template.firstChild) {
      content.appendChild(child);
    }

    return template;
  };

  var fixHTMLTemplateElementRoot = function fixHTMLTemplateElementRoot(template) {
    var content = fixHTMLTemplateElement(template).content;
    var childTemplates = content.querySelectorAll('template');

    for (var i = 0, ii = childTemplates.length; i < ii; ++i) {
      var child = childTemplates[i];

      if (isSVGTemplate(child)) {
        fixSVGTemplateElement(child);
      } else {
        fixHTMLTemplateElement(child);
      }
    }

    return template;
  };

  if (!_FEATURE.htmlTemplateElement) {
    _FEATURE.ensureHTMLTemplateElement = fixHTMLTemplateElementRoot;
  }
}

var shadowPoly = window.ShadowDOMPolyfill || null;

var _DOM = exports._DOM = {
  Element: Element,
  NodeList: NodeList,
  SVGElement: SVGElement,
  boundary: 'aurelia-dom-boundary',
  addEventListener: function addEventListener(eventName, callback, capture) {
    document.addEventListener(eventName, callback, capture);
  },
  removeEventListener: function removeEventListener(eventName, callback, capture) {
    document.removeEventListener(eventName, callback, capture);
  },
  adoptNode: function adoptNode(node) {
    return document.adoptNode(node);
  },
  createAttribute: function createAttribute(name) {
    return document.createAttribute(name);
  },
  createElement: function createElement(tagName) {
    return document.createElement(tagName);
  },
  createTextNode: function createTextNode(text) {
    return document.createTextNode(text);
  },
  createComment: function createComment(text) {
    return document.createComment(text);
  },
  createDocumentFragment: function createDocumentFragment() {
    return document.createDocumentFragment();
  },
  createTemplateElement: function createTemplateElement() {
    var template = document.createElement('template');
    return _FEATURE.ensureHTMLTemplateElement(template);
  },
  createMutationObserver: function createMutationObserver(callback) {
    return new (window.MutationObserver || window.WebKitMutationObserver)(callback);
  },
  createCustomEvent: function createCustomEvent(eventType, options) {
    return new window.CustomEvent(eventType, options);
  },
  dispatchEvent: function dispatchEvent(evt) {
    document.dispatchEvent(evt);
  },
  getComputedStyle: function getComputedStyle(element) {
    return window.getComputedStyle(element);
  },
  getElementById: function getElementById(id) {
    return document.getElementById(id);
  },
  querySelector: function querySelector(query) {
    return document.querySelector(query);
  },
  querySelectorAll: function querySelectorAll(query) {
    return document.querySelectorAll(query);
  },
  nextElementSibling: function nextElementSibling(element) {
    if (element.nextElementSibling) {
      return element.nextElementSibling;
    }
    do {
      element = element.nextSibling;
    } while (element && element.nodeType !== 1);
    return element;
  },
  createTemplateFromMarkup: function createTemplateFromMarkup(markup) {
    var parser = document.createElement('div');
    parser.innerHTML = markup;

    var temp = parser.firstElementChild;
    if (!temp || temp.nodeName !== 'TEMPLATE') {
      throw new Error('Template markup must be wrapped in a <template> element e.g. <template> <!-- markup here --> </template>');
    }

    return _FEATURE.ensureHTMLTemplateElement(temp);
  },
  appendNode: function appendNode(newNode, parentNode) {
    (parentNode || document.body).appendChild(newNode);
  },
  replaceNode: function replaceNode(newNode, node, parentNode) {
    if (node.parentNode) {
      node.parentNode.replaceChild(newNode, node);
    } else if (shadowPoly !== null) {
      shadowPoly.unwrap(parentNode).replaceChild(shadowPoly.unwrap(newNode), shadowPoly.unwrap(node));
    } else {
      parentNode.replaceChild(newNode, node);
    }
  },
  removeNode: function removeNode(node, parentNode) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    } else if (parentNode) {
      if (shadowPoly !== null) {
        shadowPoly.unwrap(parentNode).removeChild(shadowPoly.unwrap(node));
      } else {
        parentNode.removeChild(node);
      }
    }
  },
  injectStyles: function injectStyles(styles, destination, prepend, id) {
    if (id) {
      var oldStyle = document.getElementById(id);
      if (oldStyle) {
        var isStyleTag = oldStyle.tagName.toLowerCase() === 'style';

        if (isStyleTag) {
          oldStyle.innerHTML = styles;
          return;
        }

        throw new Error('The provided id does not indicate a style tag.');
      }
    }

    var node = document.createElement('style');
    node.innerHTML = styles;
    node.type = 'text/css';

    if (id) {
      node.id = id;
    }

    destination = destination || document.head;

    if (prepend && destination.childNodes.length > 0) {
      destination.insertBefore(node, destination.childNodes[0]);
    } else {
      destination.appendChild(node);
    }

    return node;
  }
};

function initialize() {
  if (_aureliaPal.isInitialized) {
    return;
  }

  (0, _aureliaPal.initializePAL)(function (platform, feature, dom) {
    Object.assign(platform, _PLATFORM);
    Object.assign(feature, _FEATURE);
    Object.assign(dom, _DOM);

    Object.defineProperty(dom, 'title', {
      get: function get() {
        return document.title;
      },
      set: function set(value) {
        document.title = value;
      }
    });

    Object.defineProperty(dom, 'activeElement', {
      get: function get() {
        return document.activeElement;
      }
    });

    Object.defineProperty(platform, 'XMLHttpRequest', {
      get: function get() {
        return platform.global.XMLHttpRequest;
      }
    });
  });
}
});

define('aurelia-pal/dist/commonjs/aurelia-pal',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggregateError = AggregateError;
exports.initializePAL = initializePAL;
exports.reset = reset;
function AggregateError(message, innerError, skipIfAlreadyAggregate) {
  if (innerError) {
    if (innerError.innerError && skipIfAlreadyAggregate) {
      return innerError;
    }

    var separator = '\n------------------------------------------------\n';

    message += separator + 'Inner Error:\n';

    if (typeof innerError === 'string') {
      message += 'Message: ' + innerError;
    } else {
      if (innerError.message) {
        message += 'Message: ' + innerError.message;
      } else {
        message += 'Unknown Inner Error Type. Displaying Inner Error as JSON:\n ' + JSON.stringify(innerError, null, '  ');
      }

      if (innerError.stack) {
        message += '\nInner Error Stack:\n' + innerError.stack;
        message += '\nEnd Inner Error Stack';
      }
    }

    message += separator;
  }

  var e = new Error(message);
  if (innerError) {
    e.innerError = innerError;
  }

  return e;
}

var FEATURE = exports.FEATURE = {};

var PLATFORM = exports.PLATFORM = {
  noop: function noop() {},
  eachModule: function eachModule() {},
  moduleName: function (_moduleName) {
    function moduleName(_x) {
      return _moduleName.apply(this, arguments);
    }

    moduleName.toString = function () {
      return _moduleName.toString();
    };

    return moduleName;
  }(function (moduleName) {
    return moduleName;
  })
};

PLATFORM.global = function () {
  if (typeof self !== 'undefined') {
    return self;
  }

  if (typeof global !== 'undefined') {
    return global;
  }

  return new Function('return this')();
}();

var DOM = exports.DOM = {};
var isInitialized = exports.isInitialized = false;
function initializePAL(callback) {
  if (isInitialized) {
    return;
  }
  exports.isInitialized = isInitialized = true;
  if (typeof Object.getPropertyDescriptor !== 'function') {
    Object.getPropertyDescriptor = function (subject, name) {
      var pd = Object.getOwnPropertyDescriptor(subject, name);
      var proto = Object.getPrototypeOf(subject);
      while (typeof pd === 'undefined' && proto !== null) {
        pd = Object.getOwnPropertyDescriptor(proto, name);
        proto = Object.getPrototypeOf(proto);
      }
      return pd;
    };
  }

  callback(PLATFORM, FEATURE, DOM);
}
function reset() {
  exports.isInitialized = isInitialized = false;
}
});

define('aurelia-path/dist/commonjs/aurelia-path',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.relativeToFile = relativeToFile;
exports.join = join;
exports.buildQueryString = buildQueryString;
exports.parseQueryString = parseQueryString;

function trimDots(ary) {
  for (var i = 0; i < ary.length; ++i) {
    var part = ary[i];
    if (part === '.') {
      ary.splice(i, 1);
      i -= 1;
    } else if (part === '..') {
      if (i === 0 || i === 1 && ary[2] === '..' || ary[i - 1] === '..') {
        continue;
      } else if (i > 0) {
        ary.splice(i - 1, 2);
        i -= 2;
      }
    }
  }
}

function relativeToFile(name, file) {
  var fileParts = file && file.split('/');
  var nameParts = name.trim().split('/');

  if (nameParts[0].charAt(0) === '.' && fileParts) {
    var normalizedBaseParts = fileParts.slice(0, fileParts.length - 1);
    nameParts.unshift.apply(nameParts, normalizedBaseParts);
  }

  trimDots(nameParts);

  return nameParts.join('/');
}

function join(path1, path2) {
  if (!path1) {
    return path2;
  }

  if (!path2) {
    return path1;
  }

  var schemeMatch = path1.match(/^([^/]*?:)\//);
  var scheme = schemeMatch && schemeMatch.length > 0 ? schemeMatch[1] : '';
  path1 = path1.substr(scheme.length);

  var urlPrefix = void 0;
  if (path1.indexOf('///') === 0 && scheme === 'file:') {
    urlPrefix = '///';
  } else if (path1.indexOf('//') === 0) {
    urlPrefix = '//';
  } else if (path1.indexOf('/') === 0) {
    urlPrefix = '/';
  } else {
    urlPrefix = '';
  }

  var trailingSlash = path2.slice(-1) === '/' ? '/' : '';

  var url1 = path1.split('/');
  var url2 = path2.split('/');
  var url3 = [];

  for (var i = 0, ii = url1.length; i < ii; ++i) {
    if (url1[i] === '..') {
      url3.pop();
    } else if (url1[i] === '.' || url1[i] === '') {
      continue;
    } else {
      url3.push(url1[i]);
    }
  }

  for (var _i = 0, _ii = url2.length; _i < _ii; ++_i) {
    if (url2[_i] === '..') {
      url3.pop();
    } else if (url2[_i] === '.' || url2[_i] === '') {
      continue;
    } else {
      url3.push(url2[_i]);
    }
  }

  return scheme + urlPrefix + url3.join('/') + trailingSlash;
}

var encode = encodeURIComponent;
var encodeKey = function encodeKey(k) {
  return encode(k).replace('%24', '$');
};

function buildParam(key, value, traditional) {
  var result = [];
  if (value === null || value === undefined) {
    return result;
  }
  if (Array.isArray(value)) {
    for (var i = 0, l = value.length; i < l; i++) {
      if (traditional) {
        result.push(encodeKey(key) + '=' + encode(value[i]));
      } else {
        var arrayKey = key + '[' + (_typeof(value[i]) === 'object' && value[i] !== null ? i : '') + ']';
        result = result.concat(buildParam(arrayKey, value[i]));
      }
    }
  } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && !traditional) {
    for (var propertyName in value) {
      result = result.concat(buildParam(key + '[' + propertyName + ']', value[propertyName]));
    }
  } else {
    result.push(encodeKey(key) + '=' + encode(value));
  }
  return result;
}

function buildQueryString(params, traditional) {
  var pairs = [];
  var keys = Object.keys(params || {}).sort();
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    pairs = pairs.concat(buildParam(key, params[key], traditional));
  }

  if (pairs.length === 0) {
    return '';
  }

  return pairs.join('&');
}

function processScalarParam(existedParam, value) {
  if (Array.isArray(existedParam)) {
    existedParam.push(value);
    return existedParam;
  }
  if (existedParam !== undefined) {
    return [existedParam, value];
  }

  return value;
}

function parseComplexParam(queryParams, keys, value) {
  var currentParams = queryParams;
  var keysLastIndex = keys.length - 1;
  for (var j = 0; j <= keysLastIndex; j++) {
    var key = keys[j] === '' ? currentParams.length : keys[j];
    if (j < keysLastIndex) {
      var prevValue = !currentParams[key] || _typeof(currentParams[key]) === 'object' ? currentParams[key] : [currentParams[key]];
      currentParams = currentParams[key] = prevValue || (isNaN(keys[j + 1]) ? {} : []);
    } else {
      currentParams = currentParams[key] = value;
    }
  }
}

function parseQueryString(queryString) {
  var queryParams = {};
  if (!queryString || typeof queryString !== 'string') {
    return queryParams;
  }

  var query = queryString;
  if (query.charAt(0) === '?') {
    query = query.substr(1);
  }

  var pairs = query.replace(/\+/g, ' ').split('&');
  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i].split('=');
    var key = decodeURIComponent(pair[0]);
    if (!key) {
      continue;
    }

    var keys = key.split('][');
    var keysLastIndex = keys.length - 1;

    if (/\[/.test(keys[0]) && /\]$/.test(keys[keysLastIndex])) {
      keys[keysLastIndex] = keys[keysLastIndex].replace(/\]$/, '');
      keys = keys.shift().split('[').concat(keys);
      keysLastIndex = keys.length - 1;
    } else {
      keysLastIndex = 0;
    }

    if (pair.length >= 2) {
      var value = pair[1] ? decodeURIComponent(pair[1]) : '';
      if (keysLastIndex) {
        parseComplexParam(queryParams, keys, value);
      } else {
        queryParams[key] = processScalarParam(queryParams[key], value);
      }
    } else {
      queryParams[key] = true;
    }
  }
  return queryParams;
}
});

define('aurelia-polyfills/dist/commonjs/aurelia-polyfills',['require','exports','module','aurelia-pal'],function (require, exports, module) {'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _aureliaPal = require('aurelia-pal');

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  (function (Object, GOPS) {
    'use strict';

    if (GOPS in Object) return;

    var setDescriptor,
        G = _aureliaPal.PLATFORM.global,
        id = 0,
        random = '' + Math.random(),
        prefix = '__\x01symbol:',
        prefixLength = prefix.length,
        internalSymbol = '__\x01symbol@@' + random,
        DP = 'defineProperty',
        DPies = 'defineProperties',
        GOPN = 'getOwnPropertyNames',
        GOPD = 'getOwnPropertyDescriptor',
        PIE = 'propertyIsEnumerable',
        gOPN = Object[GOPN],
        gOPD = Object[GOPD],
        create = Object.create,
        keys = Object.keys,
        defineProperty = Object[DP],
        $defineProperties = Object[DPies],
        descriptor = gOPD(Object, GOPN),
        ObjectProto = Object.prototype,
        hOP = ObjectProto.hasOwnProperty,
        pIE = ObjectProto[PIE],
        toString = ObjectProto.toString,
        indexOf = Array.prototype.indexOf || function (v) {
      for (var i = this.length; i-- && this[i] !== v;) {}
      return i;
    },
        addInternalIfNeeded = function addInternalIfNeeded(o, uid, enumerable) {
      if (!hOP.call(o, internalSymbol)) {
        defineProperty(o, internalSymbol, {
          enumerable: false,
          configurable: false,
          writable: false,
          value: {}
        });
      }
      o[internalSymbol]['@@' + uid] = enumerable;
    },
        createWithSymbols = function createWithSymbols(proto, descriptors) {
      var self = create(proto);
      if (descriptors !== null && (typeof descriptors === 'undefined' ? 'undefined' : _typeof(descriptors)) === 'object') {
        gOPN(descriptors).forEach(function (key) {
          if (propertyIsEnumerable.call(descriptors, key)) {
            $defineProperty(self, key, descriptors[key]);
          }
        });
      }
      return self;
    },
        copyAsNonEnumerable = function copyAsNonEnumerable(descriptor) {
      var newDescriptor = create(descriptor);
      newDescriptor.enumerable = false;
      return newDescriptor;
    },
        get = function get() {},
        onlyNonSymbols = function onlyNonSymbols(name) {
      return name != internalSymbol && !hOP.call(source, name);
    },
        onlySymbols = function onlySymbols(name) {
      return name != internalSymbol && hOP.call(source, name);
    },
        propertyIsEnumerable = function propertyIsEnumerable(key) {
      var uid = '' + key;
      return onlySymbols(uid) ? hOP.call(this, uid) && this[internalSymbol] && this[internalSymbol]['@@' + uid] : pIE.call(this, key);
    },
        setAndGetSymbol = function setAndGetSymbol(uid) {
      var descriptor = {
        enumerable: false,
        configurable: true,
        get: get,
        set: function set(value) {
          setDescriptor(this, uid, {
            enumerable: false,
            configurable: true,
            writable: true,
            value: value
          });
          addInternalIfNeeded(this, uid, true);
        }
      };
      defineProperty(ObjectProto, uid, descriptor);
      return source[uid] = defineProperty(Object(uid), 'constructor', sourceConstructor);
    },
        _Symbol = function _Symbol2(description) {
      if (this && this !== G) {
        throw new TypeError('Symbol is not a constructor');
      }
      return setAndGetSymbol(prefix.concat(description || '', random, ++id));
    },
        source = create(null),
        sourceConstructor = { value: _Symbol },
        sourceMap = function sourceMap(uid) {
      return source[uid];
    },
        $defineProperty = function defineProp(o, key, descriptor) {
      var uid = '' + key;
      if (onlySymbols(uid)) {
        setDescriptor(o, uid, descriptor.enumerable ? copyAsNonEnumerable(descriptor) : descriptor);
        addInternalIfNeeded(o, uid, !!descriptor.enumerable);
      } else {
        defineProperty(o, key, descriptor);
      }
      return o;
    },
        $getOwnPropertySymbols = function getOwnPropertySymbols(o) {
      var cof = toString.call(o);
      o = cof === '[object String]' ? o.split('') : Object(o);
      return gOPN(o).filter(onlySymbols).map(sourceMap);
    };

    descriptor.value = $defineProperty;
    defineProperty(Object, DP, descriptor);

    descriptor.value = $getOwnPropertySymbols;
    defineProperty(Object, GOPS, descriptor);

    var cachedWindowNames = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' ? Object.getOwnPropertyNames(window) : [];
    var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
    descriptor.value = function getOwnPropertyNames(o) {
      if (toString.call(o) === '[object Window]') {
        try {
          return originalObjectGetOwnPropertyNames(o);
        } catch (e) {
          return [].concat([], cachedWindowNames);
        }
      }
      return gOPN(o).filter(onlyNonSymbols);
    };
    defineProperty(Object, GOPN, descriptor);

    descriptor.value = function defineProperties(o, descriptors) {
      var symbols = $getOwnPropertySymbols(descriptors);
      if (symbols.length) {
        keys(descriptors).concat(symbols).forEach(function (uid) {
          if (propertyIsEnumerable.call(descriptors, uid)) {
            $defineProperty(o, uid, descriptors[uid]);
          }
        });
      } else {
        $defineProperties(o, descriptors);
      }
      return o;
    };
    defineProperty(Object, DPies, descriptor);

    descriptor.value = propertyIsEnumerable;
    defineProperty(ObjectProto, PIE, descriptor);

    descriptor.value = _Symbol;
    defineProperty(G, 'Symbol', descriptor);

    descriptor.value = function (key) {
      var uid = prefix.concat(prefix, key, random);
      return uid in ObjectProto ? source[uid] : setAndGetSymbol(uid);
    };
    defineProperty(_Symbol, 'for', descriptor);

    descriptor.value = function (symbol) {
      return hOP.call(source, symbol) ? symbol.slice(prefixLength * 2, -random.length) : void 0;
    };
    defineProperty(_Symbol, 'keyFor', descriptor);

    descriptor.value = function getOwnPropertyDescriptor(o, key) {
      var descriptor = gOPD(o, key);
      if (descriptor && onlySymbols(key)) {
        descriptor.enumerable = propertyIsEnumerable.call(o, key);
      }
      return descriptor;
    };
    defineProperty(Object, GOPD, descriptor);

    descriptor.value = function (proto, descriptors) {
      return arguments.length === 1 ? create(proto) : createWithSymbols(proto, descriptors);
    };
    defineProperty(Object, 'create', descriptor);

    descriptor.value = function () {
      var str = toString.call(this);
      return str === '[object String]' && onlySymbols(this) ? '[object Symbol]' : str;
    };
    defineProperty(ObjectProto, 'toString', descriptor);

    try {
      setDescriptor = create(defineProperty({}, prefix, {
        get: function get() {
          return defineProperty(this, prefix, { value: false })[prefix];
        }
      }))[prefix] || defineProperty;
    } catch (o_O) {
      setDescriptor = function setDescriptor(o, key, descriptor) {
        var protoDescriptor = gOPD(ObjectProto, key);
        delete ObjectProto[key];
        defineProperty(o, key, descriptor);
        defineProperty(ObjectProto, key, protoDescriptor);
      };
    }
  })(Object, 'getOwnPropertySymbols');

  (function (O, S) {
    var dP = O.defineProperty,
        ObjectProto = O.prototype,
        toString = ObjectProto.toString,
        toStringTag = 'toStringTag',
        descriptor;
    ['iterator', 'match', 'replace', 'search', 'split', 'hasInstance', 'isConcatSpreadable', 'unscopables', 'species', 'toPrimitive', toStringTag].forEach(function (name) {
      if (!(name in Symbol)) {
        dP(Symbol, name, { value: Symbol(name) });
        switch (name) {
          case toStringTag:
            descriptor = O.getOwnPropertyDescriptor(ObjectProto, 'toString');
            descriptor.value = function () {
              var str = toString.call(this),
                  tst = typeof this === 'undefined' || this === null ? undefined : this[Symbol.toStringTag];
              return typeof tst === 'undefined' ? str : '[object ' + tst + ']';
            };
            dP(ObjectProto, 'toString', descriptor);
            break;
        }
      }
    });
  })(Object, Symbol);

  (function (Si, AP, SP) {

    function returnThis() {
      return this;
    }

    if (!AP[Si]) AP[Si] = function () {
      var i = 0,
          self = this,
          iterator = {
        next: function next() {
          var done = self.length <= i;
          return done ? { done: done } : { done: done, value: self[i++] };
        }
      };
      iterator[Si] = returnThis;
      return iterator;
    };

    if (!SP[Si]) SP[Si] = function () {
      var fromCodePoint = String.fromCodePoint,
          self = this,
          i = 0,
          length = self.length,
          iterator = {
        next: function next() {
          var done = length <= i,
              c = done ? '' : fromCodePoint(self.codePointAt(i));
          i += c.length;
          return done ? { done: done } : { done: done, value: c };
        }
      };
      iterator[Si] = returnThis;
      return iterator;
    };
  })(Symbol.iterator, Array.prototype, String.prototype);
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  Number.isNaN = Number.isNaN || function (value) {
    return value !== value;
  };

  Number.isFinite = Number.isFinite || function (value) {
    return typeof value === "number" && isFinite(value);
  };
}

if (!String.prototype.endsWith || function () {
  try {
    return !"ab".endsWith("a", 1);
  } catch (e) {
    return true;
  }
}()) {
  String.prototype.endsWith = function (searchString, position) {
    var subjectString = this.toString();
    if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
      position = subjectString.length;
    }
    position -= searchString.length;
    var lastIndex = subjectString.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
}

if (!String.prototype.startsWith || function () {
  try {
    return !"ab".startsWith("b", 1);
  } catch (e) {
    return true;
  }
}()) {
  String.prototype.startsWith = function (searchString, position) {
    position = position || 0;
    return this.substr(position, searchString.length) === searchString;
  };
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  if (!Array.from) {
    Array.from = function () {
      var toInteger = function toInteger(it) {
        return isNaN(it = +it) ? 0 : (it > 0 ? Math.floor : Math.ceil)(it);
      };
      var toLength = function toLength(it) {
        return it > 0 ? Math.min(toInteger(it), 0x1fffffffffffff) : 0;
      };
      var iterCall = function iterCall(iter, fn, val, index) {
        try {
          return fn(val, index);
        } catch (E) {
          if (typeof iter.return == 'function') iter.return();
          throw E;
        }
      };

      return function from(arrayLike) {
        var O = Object(arrayLike),
            C = typeof this == 'function' ? this : Array,
            aLen = arguments.length,
            mapfn = aLen > 1 ? arguments[1] : undefined,
            mapping = mapfn !== undefined,
            index = 0,
            iterFn = O[Symbol.iterator],
            length,
            result,
            step,
            iterator;
        if (mapping) mapfn = mapfn.bind(aLen > 2 ? arguments[2] : undefined);
        if (iterFn != undefined && !Array.isArray(arrayLike)) {
          for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
            result[index] = mapping ? iterCall(iterator, mapfn, step.value, index) : step.value;
          }
        } else {
          length = toLength(O.length);
          for (result = new C(length); length > index; index++) {
            result[index] = mapping ? mapfn(O[index], index) : O[index];
          }
        }
        result.length = index;
        return result;
      };
    }();
  }

  if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: function value(predicate) {
        if (this === null) {
          throw new TypeError('Array.prototype.find called on null or undefined');
        }
        if (typeof predicate !== 'function') {
          throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
          value = list[i];
          if (predicate.call(thisArg, value, i, list)) {
            return value;
          }
        }
        return undefined;
      }
    });
  }

  if (!Array.prototype.findIndex) {
    Object.defineProperty(Array.prototype, 'findIndex', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: function value(predicate) {
        if (this === null) {
          throw new TypeError('Array.prototype.findIndex called on null or undefined');
        }
        if (typeof predicate !== 'function') {
          throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
          value = list[i];
          if (predicate.call(thisArg, value, i, list)) {
            return i;
          }
        }
        return -1;
      }
    });
  }
}

if (typeof FEATURE_NO_ES2016 === 'undefined' && !Array.prototype.includes) {
  Object.defineProperty(Array.prototype, 'includes', {
    configurable: true,
    writable: true,
    enumerable: false,
    value: function value(searchElement) {
      var O = Object(this);
      var len = parseInt(O.length) || 0;
      if (len === 0) {
        return false;
      }
      var n = parseInt(arguments[1]) || 0;
      var k;
      if (n >= 0) {
        k = n;
      } else {
        k = len + n;
        if (k < 0) {
          k = 0;
        }
      }
      var currentElement;
      while (k < len) {
        currentElement = O[k];
        if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
          return true;
        }
        k++;
      }
      return false;
    }
  });
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  (function () {
    var needsFix = false;

    try {
      var s = Object.keys('a');
      needsFix = s.length !== 1 || s[0] !== '0';
    } catch (e) {
      needsFix = true;
    }

    if (needsFix) {
      Object.keys = function () {
        var hasOwnProperty = Object.prototype.hasOwnProperty,
            hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),
            dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
            dontEnumsLength = dontEnums.length;

        return function (obj) {
          if (obj === undefined || obj === null) {
            throw TypeError('Cannot convert undefined or null to object');
          }

          obj = Object(obj);

          var result = [],
              prop,
              i;

          for (prop in obj) {
            if (hasOwnProperty.call(obj, prop)) {
              result.push(prop);
            }
          }

          if (hasDontEnumBug) {
            for (i = 0; i < dontEnumsLength; i++) {
              if (hasOwnProperty.call(obj, dontEnums[i])) {
                result.push(dontEnums[i]);
              }
            }
          }

          return result;
        };
      }();
    }
  })();

  (function (O) {
    if ('assign' in O) {
      return;
    }

    O.defineProperty(O, 'assign', {
      configurable: true,
      writable: true,
      value: function () {
        var gOPS = O.getOwnPropertySymbols,
            pIE = O.propertyIsEnumerable,
            filterOS = gOPS ? function (self) {
          return gOPS(self).filter(pIE, self);
        } : function () {
          return Array.prototype;
        };

        return function assign(where) {
          if (gOPS && !(where instanceof O)) {
            console.warn('problematic Symbols', where);
          }

          function set(keyOrSymbol) {
            where[keyOrSymbol] = arg[keyOrSymbol];
          }

          for (var i = 1, ii = arguments.length; i < ii; ++i) {
            var arg = arguments[i];

            if (arg === null || arg === undefined) {
              continue;
            }

            O.keys(arg).concat(filterOS(arg)).forEach(set);
          }

          return where;
        };
      }()
    });
  })(Object);

  if (!Object.is) {
    Object.is = function (x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    };
  }
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  (function (global) {
    var i;

    var defineProperty = Object.defineProperty,
        is = function is(a, b) {
      return a === b || a !== a && b !== b;
    };

    if (typeof WeakMap == 'undefined') {
      global.WeakMap = createCollection({
        'delete': sharedDelete,

        clear: sharedClear,

        get: sharedGet,

        has: mapHas,

        set: sharedSet
      }, true);
    }

    if (typeof Map == 'undefined' || typeof new Map().values !== 'function' || !new Map().values().next) {
      var _createCollection;

      global.Map = createCollection((_createCollection = {
        'delete': sharedDelete,

        has: mapHas,

        get: sharedGet,

        set: sharedSet,

        keys: sharedKeys,

        values: sharedValues,

        entries: mapEntries,

        forEach: sharedForEach,

        clear: sharedClear
      }, _createCollection[Symbol.iterator] = mapEntries, _createCollection));
    }

    if (typeof Set == 'undefined' || typeof new Set().values !== 'function' || !new Set().values().next) {
      var _createCollection2;

      global.Set = createCollection((_createCollection2 = {
        has: setHas,

        add: sharedAdd,

        'delete': sharedDelete,

        clear: sharedClear,

        keys: sharedValues,
        values: sharedValues,

        entries: setEntries,

        forEach: sharedForEach
      }, _createCollection2[Symbol.iterator] = sharedValues, _createCollection2));
    }

    if (typeof WeakSet == 'undefined') {
      global.WeakSet = createCollection({
        'delete': sharedDelete,

        add: sharedAdd,

        clear: sharedClear,

        has: setHas
      }, true);
    }

    function createCollection(proto, objectOnly) {
      function Collection(a) {
        if (!this || this.constructor !== Collection) return new Collection(a);
        this._keys = [];
        this._values = [];
        this._itp = [];
        this.objectOnly = objectOnly;

        if (a) init.call(this, a);
      }

      if (!objectOnly) {
        defineProperty(proto, 'size', {
          get: sharedSize
        });
      }

      proto.constructor = Collection;
      Collection.prototype = proto;

      return Collection;
    }

    function init(a) {
      var i;

      if (this.add) a.forEach(this.add, this);else a.forEach(function (a) {
          this.set(a[0], a[1]);
        }, this);
    }

    function sharedDelete(key) {
      if (this.has(key)) {
        this._keys.splice(i, 1);
        this._values.splice(i, 1);

        this._itp.forEach(function (p) {
          if (i < p[0]) p[0]--;
        });
      }

      return -1 < i;
    };

    function sharedGet(key) {
      return this.has(key) ? this._values[i] : undefined;
    }

    function has(list, key) {
      if (this.objectOnly && key !== Object(key)) throw new TypeError("Invalid value used as weak collection key");

      if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} else i = list.indexOf(key);
      return -1 < i;
    }

    function setHas(value) {
      return has.call(this, this._values, value);
    }

    function mapHas(value) {
      return has.call(this, this._keys, value);
    }

    function sharedSet(key, value) {
      this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;
      return this;
    }

    function sharedAdd(value) {
      if (!this.has(value)) this._values.push(value);
      return this;
    }

    function sharedClear() {
      (this._keys || 0).length = this._values.length = 0;
    }

    function sharedKeys() {
      return sharedIterator(this._itp, this._keys);
    }

    function sharedValues() {
      return sharedIterator(this._itp, this._values);
    }

    function mapEntries() {
      return sharedIterator(this._itp, this._keys, this._values);
    }

    function setEntries() {
      return sharedIterator(this._itp, this._values, this._values);
    }

    function sharedIterator(itp, array, array2) {
      var _ref;

      var p = [0],
          done = false;
      itp.push(p);
      return _ref = {}, _ref[Symbol.iterator] = function () {
        return this;
      }, _ref.next = function next() {
        var v,
            k = p[0];
        if (!done && k < array.length) {
          v = array2 ? [array[k], array2[k]] : array[k];
          p[0]++;
        } else {
          done = true;
          itp.splice(itp.indexOf(p), 1);
        }
        return { done: done, value: v };
      }, _ref;
    }

    function sharedSize() {
      return this._values.length;
    }

    function sharedForEach(callback, context) {
      var it = this.entries();
      for (;;) {
        var r = it.next();
        if (r.done) break;
        callback.call(context, r.value[1], r.value[0], this);
      }
    }
  })(_aureliaPal.PLATFORM.global);
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {
  (function () {

    var bind = Function.prototype.bind;

    if (typeof _aureliaPal.PLATFORM.global.Reflect === 'undefined') {
      _aureliaPal.PLATFORM.global.Reflect = {};
    }

    if (typeof Reflect.defineProperty !== 'function') {
      Reflect.defineProperty = function (target, propertyKey, descriptor) {
        if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' ? target === null : typeof target !== 'function') {
          throw new TypeError('Reflect.defineProperty called on non-object');
        }
        try {
          Object.defineProperty(target, propertyKey, descriptor);
          return true;
        } catch (e) {
          return false;
        }
      };
    }

    if (typeof Reflect.construct !== 'function') {
      Reflect.construct = function (Target, args) {
        if (args) {
          switch (args.length) {
            case 0:
              return new Target();
            case 1:
              return new Target(args[0]);
            case 2:
              return new Target(args[0], args[1]);
            case 3:
              return new Target(args[0], args[1], args[2]);
            case 4:
              return new Target(args[0], args[1], args[2], args[3]);
          }
        }

        var a = [null];
        a.push.apply(a, args);
        return new (bind.apply(Target, a))();
      };
    }

    if (typeof Reflect.ownKeys !== 'function') {
      Reflect.ownKeys = function (o) {
        return Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o));
      };
    }
  })();
}

if (typeof FEATURE_NO_ESNEXT === 'undefined') {
  (function () {

    var emptyMetadata = Object.freeze({});
    var metadataContainerKey = '__metadata__';

    if (typeof Reflect.getOwnMetadata !== 'function') {
      Reflect.getOwnMetadata = function (metadataKey, target, targetKey) {
        if (target.hasOwnProperty(metadataContainerKey)) {
          return (target[metadataContainerKey][targetKey] || emptyMetadata)[metadataKey];
        }
      };
    }

    if (typeof Reflect.defineMetadata !== 'function') {
      Reflect.defineMetadata = function (metadataKey, metadataValue, target, targetKey) {
        var metadataContainer = target.hasOwnProperty(metadataContainerKey) ? target[metadataContainerKey] : target[metadataContainerKey] = {};
        var targetContainer = metadataContainer[targetKey] || (metadataContainer[targetKey] = {});
        targetContainer[metadataKey] = metadataValue;
      };
    }

    if (typeof Reflect.metadata !== 'function') {
      Reflect.metadata = function (metadataKey, metadataValue) {
        return function (target, targetKey) {
          Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
        };
      };
    }
  })();
}
});

define('aurelia-route-recognizer/dist/commonjs/aurelia-route-recognizer',['require','exports','module','aurelia-path'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RouteRecognizer = exports.EpsilonSegment = exports.StarSegment = exports.DynamicSegment = exports.StaticSegment = exports.State = undefined;

var _aureliaPath = require('aurelia-path');



var State = exports.State = function () {
  function State(charSpec) {
    

    this.charSpec = charSpec;
    this.nextStates = [];
  }

  State.prototype.get = function get(charSpec) {
    for (var _iterator = this.nextStates, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var child = _ref;

      var isEqual = child.charSpec.validChars === charSpec.validChars && child.charSpec.invalidChars === charSpec.invalidChars;

      if (isEqual) {
        return child;
      }
    }

    return undefined;
  };

  State.prototype.put = function put(charSpec) {
    var state = this.get(charSpec);

    if (state) {
      return state;
    }

    state = new State(charSpec);

    this.nextStates.push(state);

    if (charSpec.repeat) {
      state.nextStates.push(state);
    }

    return state;
  };

  State.prototype.match = function match(ch) {
    var nextStates = this.nextStates;
    var results = [];

    for (var i = 0, l = nextStates.length; i < l; i++) {
      var child = nextStates[i];
      var charSpec = child.charSpec;

      if (charSpec.validChars !== undefined) {
        if (charSpec.validChars.indexOf(ch) !== -1) {
          results.push(child);
        }
      } else if (charSpec.invalidChars !== undefined) {
        if (charSpec.invalidChars.indexOf(ch) === -1) {
          results.push(child);
        }
      }
    }

    return results;
  };

  return State;
}();

var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];

var escapeRegex = new RegExp('(\\' + specials.join('|\\') + ')', 'g');

var StaticSegment = exports.StaticSegment = function () {
  function StaticSegment(string, caseSensitive) {
    

    this.string = string;
    this.caseSensitive = caseSensitive;
  }

  StaticSegment.prototype.eachChar = function eachChar(callback) {
    var s = this.string;
    for (var i = 0, ii = s.length; i < ii; ++i) {
      var ch = s[i];
      callback({ validChars: this.caseSensitive ? ch : ch.toUpperCase() + ch.toLowerCase() });
    }
  };

  StaticSegment.prototype.regex = function regex() {
    return this.string.replace(escapeRegex, '\\$1');
  };

  StaticSegment.prototype.generate = function generate() {
    return this.string;
  };

  return StaticSegment;
}();

var DynamicSegment = exports.DynamicSegment = function () {
  function DynamicSegment(name, optional) {
    

    this.name = name;
    this.optional = optional;
  }

  DynamicSegment.prototype.eachChar = function eachChar(callback) {
    callback({ invalidChars: '/', repeat: true });
  };

  DynamicSegment.prototype.regex = function regex() {
    return this.optional ? '([^/]+)?' : '([^/]+)';
  };

  DynamicSegment.prototype.generate = function generate(params, consumed) {
    consumed[this.name] = true;
    return params[this.name];
  };

  return DynamicSegment;
}();

var StarSegment = exports.StarSegment = function () {
  function StarSegment(name) {
    

    this.name = name;
  }

  StarSegment.prototype.eachChar = function eachChar(callback) {
    callback({ invalidChars: '', repeat: true });
  };

  StarSegment.prototype.regex = function regex() {
    return '(.+)';
  };

  StarSegment.prototype.generate = function generate(params, consumed) {
    consumed[this.name] = true;
    return params[this.name];
  };

  return StarSegment;
}();

var EpsilonSegment = exports.EpsilonSegment = function () {
  function EpsilonSegment() {
    
  }

  EpsilonSegment.prototype.eachChar = function eachChar() {};

  EpsilonSegment.prototype.regex = function regex() {
    return '';
  };

  EpsilonSegment.prototype.generate = function generate() {
    return '';
  };

  return EpsilonSegment;
}();

var RouteRecognizer = exports.RouteRecognizer = function () {
  function RouteRecognizer() {
    

    this.rootState = new State();
    this.names = {};
  }

  RouteRecognizer.prototype.add = function add(route) {
    var _this = this;

    if (Array.isArray(route)) {
      route.forEach(function (r) {
        return _this.add(r);
      });
      return undefined;
    }

    var currentState = this.rootState;
    var regex = '^';
    var types = { statics: 0, dynamics: 0, stars: 0 };
    var names = [];
    var routeName = route.handler.name;
    var isEmpty = true;
    var isAllOptional = true;
    var segments = parse(route.path, names, types, route.caseSensitive);

    for (var i = 0, ii = segments.length; i < ii; i++) {
      var segment = segments[i];
      if (segment instanceof EpsilonSegment) {
        continue;
      }

      isEmpty = false;
      isAllOptional = isAllOptional && segment.optional;

      currentState = addSegment(currentState, segment);
      regex += segment.optional ? '/?' : '/';
      regex += segment.regex();
    }

    if (isAllOptional) {
      if (isEmpty) {
        currentState = currentState.put({ validChars: '/' });
        regex += '/';
      } else {
        var finalState = this.rootState.put({ validChars: '/' });
        currentState.epsilon = [finalState];
        currentState = finalState;
      }
    }

    var handlers = [{ handler: route.handler, names: names }];

    if (routeName) {
      var routeNames = Array.isArray(routeName) ? routeName : [routeName];
      for (var _i2 = 0; _i2 < routeNames.length; _i2++) {
        this.names[routeNames[_i2]] = {
          segments: segments,
          handlers: handlers
        };
      }
    }

    currentState.handlers = handlers;
    currentState.regex = new RegExp(regex + '$', route.caseSensitive ? '' : 'i');
    currentState.types = types;

    return currentState;
  };

  RouteRecognizer.prototype.handlersFor = function handlersFor(name) {
    var route = this.names[name];
    if (!route) {
      throw new Error('There is no route named ' + name);
    }

    return [].concat(route.handlers);
  };

  RouteRecognizer.prototype.hasRoute = function hasRoute(name) {
    return !!this.names[name];
  };

  RouteRecognizer.prototype.generate = function generate(name, params) {
    var route = this.names[name];
    if (!route) {
      throw new Error('There is no route named ' + name);
    }

    var handler = route.handlers[0].handler;
    if (handler.generationUsesHref) {
      return handler.href;
    }

    var routeParams = Object.assign({}, params);
    var segments = route.segments;
    var consumed = {};
    var output = '';

    for (var i = 0, l = segments.length; i < l; i++) {
      var segment = segments[i];

      if (segment instanceof EpsilonSegment) {
        continue;
      }

      var segmentValue = segment.generate(routeParams, consumed);
      if (segmentValue === null || segmentValue === undefined) {
        if (!segment.optional) {
          throw new Error('A value is required for route parameter \'' + segment.name + '\' in route \'' + name + '\'.');
        }
      } else {
        output += '/';
        output += segmentValue;
      }
    }

    if (output.charAt(0) !== '/') {
      output = '/' + output;
    }

    for (var param in consumed) {
      delete routeParams[param];
    }

    var queryString = (0, _aureliaPath.buildQueryString)(routeParams);
    output += queryString ? '?' + queryString : '';

    return output;
  };

  RouteRecognizer.prototype.recognize = function recognize(path) {
    var states = [this.rootState];
    var queryParams = {};
    var isSlashDropped = false;
    var normalizedPath = path;

    var queryStart = normalizedPath.indexOf('?');
    if (queryStart !== -1) {
      var queryString = normalizedPath.substr(queryStart + 1, normalizedPath.length);
      normalizedPath = normalizedPath.substr(0, queryStart);
      queryParams = (0, _aureliaPath.parseQueryString)(queryString);
    }

    normalizedPath = decodeURI(normalizedPath);

    if (normalizedPath.charAt(0) !== '/') {
      normalizedPath = '/' + normalizedPath;
    }

    var pathLen = normalizedPath.length;
    if (pathLen > 1 && normalizedPath.charAt(pathLen - 1) === '/') {
      normalizedPath = normalizedPath.substr(0, pathLen - 1);
      isSlashDropped = true;
    }

    for (var i = 0, l = normalizedPath.length; i < l; i++) {
      states = recognizeChar(states, normalizedPath.charAt(i));
      if (!states.length) {
        break;
      }
    }

    var solutions = [];
    for (var _i3 = 0, _l = states.length; _i3 < _l; _i3++) {
      if (states[_i3].handlers) {
        solutions.push(states[_i3]);
      }
    }

    states = sortSolutions(solutions);

    var state = solutions[0];
    if (state && state.handlers) {
      if (isSlashDropped && state.regex.source.slice(-5) === '(.+)$') {
        normalizedPath = normalizedPath + '/';
      }

      return findHandler(state, normalizedPath, queryParams);
    }
  };

  return RouteRecognizer;
}();

var RecognizeResults = function RecognizeResults(queryParams) {
  

  this.splice = Array.prototype.splice;
  this.slice = Array.prototype.slice;
  this.push = Array.prototype.push;
  this.length = 0;
  this.queryParams = queryParams || {};
};

function parse(route, names, types, caseSensitive) {
  var normalizedRoute = route;
  if (route.charAt(0) === '/') {
    normalizedRoute = route.substr(1);
  }

  var results = [];

  var splitRoute = normalizedRoute.split('/');
  for (var i = 0, ii = splitRoute.length; i < ii; ++i) {
    var segment = splitRoute[i];

    var match = segment.match(/^:([^?]+)(\?)?$/);
    if (match) {
      var _match = match,
          _name = _match[1],
          optional = _match[2];

      if (_name.indexOf('=') !== -1) {
        throw new Error('Parameter ' + _name + ' in route ' + route + ' has a default value, which is not supported.');
      }
      results.push(new DynamicSegment(_name, !!optional));
      names.push(_name);
      types.dynamics++;
      continue;
    }

    match = segment.match(/^\*(.+)$/);
    if (match) {
      results.push(new StarSegment(match[1]));
      names.push(match[1]);
      types.stars++;
    } else if (segment === '') {
      results.push(new EpsilonSegment());
    } else {
      results.push(new StaticSegment(segment, caseSensitive));
      types.statics++;
    }
  }

  return results;
}

function sortSolutions(states) {
  return states.sort(function (a, b) {
    if (a.types.stars !== b.types.stars) {
      return a.types.stars - b.types.stars;
    }

    if (a.types.stars) {
      if (a.types.statics !== b.types.statics) {
        return b.types.statics - a.types.statics;
      }
      if (a.types.dynamics !== b.types.dynamics) {
        return b.types.dynamics - a.types.dynamics;
      }
    }

    if (a.types.dynamics !== b.types.dynamics) {
      return a.types.dynamics - b.types.dynamics;
    }

    if (a.types.statics !== b.types.statics) {
      return b.types.statics - a.types.statics;
    }

    return 0;
  });
}

function recognizeChar(states, ch) {
  var nextStates = [];

  for (var i = 0, l = states.length; i < l; i++) {
    var state = states[i];
    nextStates.push.apply(nextStates, state.match(ch));
  }

  var skippableStates = nextStates.filter(function (s) {
    return s.epsilon;
  });

  var _loop = function _loop() {
    var newStates = [];
    skippableStates.forEach(function (s) {
      nextStates.push.apply(nextStates, s.epsilon);
      newStates.push.apply(newStates, s.epsilon);
    });
    skippableStates = newStates.filter(function (s) {
      return s.epsilon;
    });
  };

  while (skippableStates.length > 0) {
    _loop();
  }

  return nextStates;
}

function findHandler(state, path, queryParams) {
  var handlers = state.handlers;
  var regex = state.regex;
  var captures = path.match(regex);
  var currentCapture = 1;
  var result = new RecognizeResults(queryParams);

  for (var i = 0, l = handlers.length; i < l; i++) {
    var _handler = handlers[i];
    var _names = _handler.names;
    var _params = {};

    for (var j = 0, m = _names.length; j < m; j++) {
      _params[_names[j]] = captures[currentCapture++];
    }

    result.push({ handler: _handler.handler, params: _params, isDynamic: !!_names.length });
  }

  return result;
}

function addSegment(currentState, segment) {
  var state = currentState.put({ validChars: '/' });
  segment.eachChar(function (ch) {
    state = state.put(ch);
  });

  if (segment.optional) {
    currentState.epsilon = currentState.epsilon || [];
    currentState.epsilon.push(state);
  }

  return state;
}
});

define('aurelia-router/dist/commonjs/aurelia-router',['require','exports','module','aurelia-logging','aurelia-route-recognizer','aurelia-dependency-injection','aurelia-history','aurelia-event-aggregator'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AppRouter = exports.PipelineProvider = exports.LoadRouteStep = exports.RouteLoader = exports.ActivateNextStep = exports.DeactivatePreviousStep = exports.CanActivateNextStep = exports.CanDeactivatePreviousStep = exports.Router = exports.BuildNavigationPlanStep = exports.activationStrategy = exports.RouterConfiguration = exports.RedirectToRoute = exports.Redirect = exports.NavModel = exports.NavigationInstruction = exports.CommitChangesStep = exports.Pipeline = exports.pipelineStatus = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports._normalizeAbsolutePath = _normalizeAbsolutePath;
exports._createRootedPath = _createRootedPath;
exports._resolveUrl = _resolveUrl;
exports.isNavigationCommand = isNavigationCommand;
exports._buildNavigationPlan = _buildNavigationPlan;

var _aureliaLogging = require('aurelia-logging');

var LogManager = _interopRequireWildcard(_aureliaLogging);

var _aureliaRouteRecognizer = require('aurelia-route-recognizer');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaHistory = require('aurelia-history');

var _aureliaEventAggregator = require('aurelia-event-aggregator');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



function _normalizeAbsolutePath(path, hasPushState) {
  var absolute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!hasPushState && path[0] !== '#') {
    path = '#' + path;
  }

  if (hasPushState && absolute) {
    path = path.substring(1, path.length);
  }

  return path;
}

function _createRootedPath(fragment, baseUrl, hasPushState, absolute) {
  if (isAbsoluteUrl.test(fragment)) {
    return fragment;
  }

  var path = '';

  if (baseUrl.length && baseUrl[0] !== '/') {
    path += '/';
  }

  path += baseUrl;

  if ((!path.length || path[path.length - 1] !== '/') && fragment[0] !== '/') {
    path += '/';
  }

  if (path.length && path[path.length - 1] === '/' && fragment[0] === '/') {
    path = path.substring(0, path.length - 1);
  }

  return _normalizeAbsolutePath(path + fragment, hasPushState, absolute);
}

function _resolveUrl(fragment, baseUrl, hasPushState) {
  if (isRootedPath.test(fragment)) {
    return _normalizeAbsolutePath(fragment, hasPushState);
  }

  return _createRootedPath(fragment, baseUrl, hasPushState);
}

var isRootedPath = /^#?\//;
var isAbsoluteUrl = /^([a-z][a-z0-9+\-.]*:)?\/\//i;

var pipelineStatus = exports.pipelineStatus = {
  completed: 'completed',
  canceled: 'canceled',
  rejected: 'rejected',
  running: 'running'
};

var Pipeline = exports.Pipeline = function () {
  function Pipeline() {
    

    this.steps = [];
  }

  Pipeline.prototype.addStep = function addStep(step) {
    var run = void 0;

    if (typeof step === 'function') {
      run = step;
    } else if (typeof step.getSteps === 'function') {
      var steps = step.getSteps();
      for (var i = 0, l = steps.length; i < l; i++) {
        this.addStep(steps[i]);
      }

      return this;
    } else {
      run = step.run.bind(step);
    }

    this.steps.push(run);

    return this;
  };

  Pipeline.prototype.run = function run(instruction) {
    var index = -1;
    var steps = this.steps;

    function next() {
      index++;

      if (index < steps.length) {
        var currentStep = steps[index];

        try {
          return currentStep(instruction, next);
        } catch (e) {
          return next.reject(e);
        }
      } else {
        return next.complete();
      }
    }

    next.complete = createCompletionHandler(next, pipelineStatus.completed);
    next.cancel = createCompletionHandler(next, pipelineStatus.canceled);
    next.reject = createCompletionHandler(next, pipelineStatus.rejected);

    return next();
  };

  return Pipeline;
}();

function createCompletionHandler(next, status) {
  return function (output) {
    return Promise.resolve({ status: status, output: output, completed: status === pipelineStatus.completed });
  };
}

var CommitChangesStep = exports.CommitChangesStep = function () {
  function CommitChangesStep() {
    
  }

  CommitChangesStep.prototype.run = function run(navigationInstruction, next) {
    return navigationInstruction._commitChanges(true).then(function () {
      navigationInstruction._updateTitle();
      return next();
    });
  };

  return CommitChangesStep;
}();

var NavigationInstruction = exports.NavigationInstruction = function () {
  function NavigationInstruction(init) {
    

    this.plan = null;
    this.options = {};

    Object.assign(this, init);

    this.params = this.params || {};
    this.viewPortInstructions = {};

    var ancestorParams = [];
    var current = this;
    do {
      var currentParams = Object.assign({}, current.params);
      if (current.config && current.config.hasChildRouter) {
        delete currentParams[current.getWildCardName()];
      }

      ancestorParams.unshift(currentParams);
      current = current.parentInstruction;
    } while (current);

    var allParams = Object.assign.apply(Object, [{}, this.queryParams].concat(ancestorParams));
    this.lifecycleArgs = [allParams, this.config, this];
  }

  NavigationInstruction.prototype.getAllInstructions = function getAllInstructions() {
    var instructions = [this];
    for (var key in this.viewPortInstructions) {
      var childInstruction = this.viewPortInstructions[key].childNavigationInstruction;
      if (childInstruction) {
        instructions.push.apply(instructions, childInstruction.getAllInstructions());
      }
    }

    return instructions;
  };

  NavigationInstruction.prototype.getAllPreviousInstructions = function getAllPreviousInstructions() {
    return this.getAllInstructions().map(function (c) {
      return c.previousInstruction;
    }).filter(function (c) {
      return c;
    });
  };

  NavigationInstruction.prototype.addViewPortInstruction = function addViewPortInstruction(viewPortName, strategy, moduleId, component) {
    var config = Object.assign({}, this.lifecycleArgs[1], { currentViewPort: viewPortName });
    var viewportInstruction = this.viewPortInstructions[viewPortName] = {
      name: viewPortName,
      strategy: strategy,
      moduleId: moduleId,
      component: component,
      childRouter: component.childRouter,
      lifecycleArgs: [].concat(this.lifecycleArgs[0], config, this.lifecycleArgs[2])
    };

    return viewportInstruction;
  };

  NavigationInstruction.prototype.getWildCardName = function getWildCardName() {
    var wildcardIndex = this.config.route.lastIndexOf('*');
    return this.config.route.substr(wildcardIndex + 1);
  };

  NavigationInstruction.prototype.getWildcardPath = function getWildcardPath() {
    var wildcardName = this.getWildCardName();
    var path = this.params[wildcardName] || '';

    if (this.queryString) {
      path += '?' + this.queryString;
    }

    return path;
  };

  NavigationInstruction.prototype.getBaseUrl = function getBaseUrl() {
    var _this = this;

    var fragment = decodeURI(this.fragment);

    if (fragment === '') {
      var nonEmptyRoute = this.router.routes.find(function (route) {
        return route.name === _this.config.name && route.route !== '';
      });
      if (nonEmptyRoute) {
        fragment = nonEmptyRoute.route;
      }
    }

    if (!this.params) {
      return encodeURI(fragment);
    }

    var wildcardName = this.getWildCardName();
    var path = this.params[wildcardName] || '';

    if (!path) {
      return encodeURI(fragment);
    }

    return encodeURI(fragment.substr(0, fragment.lastIndexOf(path)));
  };

  NavigationInstruction.prototype._commitChanges = function _commitChanges(waitToSwap) {
    var _this2 = this;

    var router = this.router;
    router.currentInstruction = this;

    if (this.previousInstruction) {
      this.previousInstruction.config.navModel.isActive = false;
    }

    this.config.navModel.isActive = true;

    router._refreshBaseUrl();
    router.refreshNavigation();

    var loads = [];
    var delaySwaps = [];

    var _loop = function _loop(viewPortName) {
      var viewPortInstruction = _this2.viewPortInstructions[viewPortName];
      var viewPort = router.viewPorts[viewPortName];

      if (!viewPort) {
        throw new Error('There was no router-view found in the view for ' + viewPortInstruction.moduleId + '.');
      }

      if (viewPortInstruction.strategy === activationStrategy.replace) {
        if (viewPortInstruction.childNavigationInstruction && viewPortInstruction.childNavigationInstruction.parentCatchHandler) {
          loads.push(viewPortInstruction.childNavigationInstruction._commitChanges(waitToSwap));
        } else {
          if (waitToSwap) {
            delaySwaps.push({ viewPort: viewPort, viewPortInstruction: viewPortInstruction });
          }
          loads.push(viewPort.process(viewPortInstruction, waitToSwap).then(function (x) {
            if (viewPortInstruction.childNavigationInstruction) {
              return viewPortInstruction.childNavigationInstruction._commitChanges(waitToSwap);
            }
          }));
        }
      } else {
        if (viewPortInstruction.childNavigationInstruction) {
          loads.push(viewPortInstruction.childNavigationInstruction._commitChanges(waitToSwap));
        }
      }
    };

    for (var viewPortName in this.viewPortInstructions) {
      _loop(viewPortName);
    }

    return Promise.all(loads).then(function () {
      delaySwaps.forEach(function (x) {
        return x.viewPort.swap(x.viewPortInstruction);
      });
      return null;
    }).then(function () {
      return prune(_this2);
    });
  };

  NavigationInstruction.prototype._updateTitle = function _updateTitle() {
    var title = this._buildTitle();
    if (title) {
      this.router.history.setTitle(title);
    }
  };

  NavigationInstruction.prototype._buildTitle = function _buildTitle() {
    var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ' | ';

    var title = '';
    var childTitles = [];

    if (this.config.navModel.title) {
      title = this.router.transformTitle(this.config.navModel.title);
    }

    for (var viewPortName in this.viewPortInstructions) {
      var _viewPortInstruction = this.viewPortInstructions[viewPortName];

      if (_viewPortInstruction.childNavigationInstruction) {
        var childTitle = _viewPortInstruction.childNavigationInstruction._buildTitle(separator);
        if (childTitle) {
          childTitles.push(childTitle);
        }
      }
    }

    if (childTitles.length) {
      title = childTitles.join(separator) + (title ? separator : '') + title;
    }

    if (this.router.title) {
      title += (title ? separator : '') + this.router.transformTitle(this.router.title);
    }

    return title;
  };

  return NavigationInstruction;
}();

function prune(instruction) {
  instruction.previousInstruction = null;
  instruction.plan = null;
}

var NavModel = exports.NavModel = function () {
  function NavModel(router, relativeHref) {
    

    this.isActive = false;
    this.title = null;
    this.href = null;
    this.relativeHref = null;
    this.settings = {};
    this.config = null;

    this.router = router;
    this.relativeHref = relativeHref;
  }

  NavModel.prototype.setTitle = function setTitle(title) {
    this.title = title;

    if (this.isActive) {
      this.router.updateTitle();
    }
  };

  return NavModel;
}();

function isNavigationCommand(obj) {
  return obj && typeof obj.navigate === 'function';
}

var Redirect = exports.Redirect = function () {
  function Redirect(url) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    

    this.url = url;
    this.options = Object.assign({ trigger: true, replace: true }, options);
    this.shouldContinueProcessing = false;
  }

  Redirect.prototype.setRouter = function setRouter(router) {
    this.router = router;
  };

  Redirect.prototype.navigate = function navigate(appRouter) {
    var navigatingRouter = this.options.useAppRouter ? appRouter : this.router || appRouter;
    navigatingRouter.navigate(this.url, this.options);
  };

  return Redirect;
}();

var RedirectToRoute = exports.RedirectToRoute = function () {
  function RedirectToRoute(route) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    

    this.route = route;
    this.params = params;
    this.options = Object.assign({ trigger: true, replace: true }, options);
    this.shouldContinueProcessing = false;
  }

  RedirectToRoute.prototype.setRouter = function setRouter(router) {
    this.router = router;
  };

  RedirectToRoute.prototype.navigate = function navigate(appRouter) {
    var navigatingRouter = this.options.useAppRouter ? appRouter : this.router || appRouter;
    navigatingRouter.navigateToRoute(this.route, this.params, this.options);
  };

  return RedirectToRoute;
}();

var RouterConfiguration = exports.RouterConfiguration = function () {
  function RouterConfiguration() {
    

    this.instructions = [];
    this.options = {};
    this.pipelineSteps = [];
  }

  RouterConfiguration.prototype.addPipelineStep = function addPipelineStep(name, step) {
    this.pipelineSteps.push({ name: name, step: step });
    return this;
  };

  RouterConfiguration.prototype.addAuthorizeStep = function addAuthorizeStep(step) {
    return this.addPipelineStep('authorize', step);
  };

  RouterConfiguration.prototype.addPreActivateStep = function addPreActivateStep(step) {
    return this.addPipelineStep('preActivate', step);
  };

  RouterConfiguration.prototype.addPreRenderStep = function addPreRenderStep(step) {
    return this.addPipelineStep('preRender', step);
  };

  RouterConfiguration.prototype.addPostRenderStep = function addPostRenderStep(step) {
    return this.addPipelineStep('postRender', step);
  };

  RouterConfiguration.prototype.fallbackRoute = function fallbackRoute(fragment) {
    this._fallbackRoute = fragment;
    return this;
  };

  RouterConfiguration.prototype.map = function map(route) {
    if (Array.isArray(route)) {
      route.forEach(this.map.bind(this));
      return this;
    }

    return this.mapRoute(route);
  };

  RouterConfiguration.prototype.useViewPortDefaults = function useViewPortDefaults(viewPortConfig) {
    this.viewPortDefaults = viewPortConfig;
    return this;
  };

  RouterConfiguration.prototype.mapRoute = function mapRoute(config) {
    this.instructions.push(function (router) {
      var routeConfigs = [];

      if (Array.isArray(config.route)) {
        for (var i = 0, ii = config.route.length; i < ii; ++i) {
          var _current = Object.assign({}, config);
          _current.route = config.route[i];
          routeConfigs.push(_current);
        }
      } else {
        routeConfigs.push(Object.assign({}, config));
      }

      var navModel = void 0;
      for (var _i = 0, _ii = routeConfigs.length; _i < _ii; ++_i) {
        var _routeConfig = routeConfigs[_i];
        _routeConfig.settings = _routeConfig.settings || {};
        if (!navModel) {
          navModel = router.createNavModel(_routeConfig);
        }

        router.addRoute(_routeConfig, navModel);
      }
    });

    return this;
  };

  RouterConfiguration.prototype.mapUnknownRoutes = function mapUnknownRoutes(config) {
    this.unknownRouteConfig = config;
    return this;
  };

  RouterConfiguration.prototype.exportToRouter = function exportToRouter(router) {
    var instructions = this.instructions;
    for (var i = 0, ii = instructions.length; i < ii; ++i) {
      instructions[i](router);
    }

    if (this.title) {
      router.title = this.title;
    }

    if (this.unknownRouteConfig) {
      router.handleUnknownRoutes(this.unknownRouteConfig);
    }

    if (this._fallbackRoute) {
      router.fallbackRoute = this._fallbackRoute;
    }

    if (this.viewPortDefaults) {
      router.useViewPortDefaults(this.viewPortDefaults);
    }

    router.options = this.options;

    var pipelineSteps = this.pipelineSteps;
    if (pipelineSteps.length) {
      if (!router.isRoot) {
        throw new Error('Pipeline steps can only be added to the root router');
      }

      var pipelineProvider = router.pipelineProvider;
      for (var _i2 = 0, _ii2 = pipelineSteps.length; _i2 < _ii2; ++_i2) {
        var _pipelineSteps$_i = pipelineSteps[_i2],
            _name = _pipelineSteps$_i.name,
            step = _pipelineSteps$_i.step;

        pipelineProvider.addStep(_name, step);
      }
    }
  };

  return RouterConfiguration;
}();

var activationStrategy = exports.activationStrategy = {
  noChange: 'no-change',
  invokeLifecycle: 'invoke-lifecycle',
  replace: 'replace'
};

var BuildNavigationPlanStep = exports.BuildNavigationPlanStep = function () {
  function BuildNavigationPlanStep() {
    
  }

  BuildNavigationPlanStep.prototype.run = function run(navigationInstruction, next) {
    return _buildNavigationPlan(navigationInstruction).then(function (plan) {
      navigationInstruction.plan = plan;
      return next();
    }).catch(next.cancel);
  };

  return BuildNavigationPlanStep;
}();

function _buildNavigationPlan(instruction, forceLifecycleMinimum) {
  var config = instruction.config;

  if ('redirect' in config) {
    var redirectLocation = _resolveUrl(config.redirect, getInstructionBaseUrl(instruction));
    if (instruction.queryString) {
      redirectLocation += '?' + instruction.queryString;
    }

    return Promise.reject(new Redirect(redirectLocation));
  }

  var prev = instruction.previousInstruction;
  var plan = {};
  var defaults = instruction.router.viewPortDefaults;

  if (prev) {
    var newParams = hasDifferentParameterValues(prev, instruction);
    var pending = [];

    var _loop2 = function _loop2(viewPortName) {
      var prevViewPortInstruction = prev.viewPortInstructions[viewPortName];
      var nextViewPortConfig = viewPortName in config.viewPorts ? config.viewPorts[viewPortName] : prevViewPortInstruction;
      if (nextViewPortConfig.moduleId === null && viewPortName in instruction.router.viewPortDefaults) {
        nextViewPortConfig = defaults[viewPortName];
      }

      var viewPortPlan = plan[viewPortName] = {
        name: viewPortName,
        config: nextViewPortConfig,
        prevComponent: prevViewPortInstruction.component,
        prevModuleId: prevViewPortInstruction.moduleId
      };

      if (prevViewPortInstruction.moduleId !== nextViewPortConfig.moduleId) {
        viewPortPlan.strategy = activationStrategy.replace;
      } else if ('determineActivationStrategy' in prevViewPortInstruction.component.viewModel) {
        var _prevViewPortInstruct;

        viewPortPlan.strategy = (_prevViewPortInstruct = prevViewPortInstruction.component.viewModel).determineActivationStrategy.apply(_prevViewPortInstruct, instruction.lifecycleArgs);
      } else if (config.activationStrategy) {
        viewPortPlan.strategy = config.activationStrategy;
      } else if (newParams || forceLifecycleMinimum) {
        viewPortPlan.strategy = activationStrategy.invokeLifecycle;
      } else {
        viewPortPlan.strategy = activationStrategy.noChange;
      }

      if (viewPortPlan.strategy !== activationStrategy.replace && prevViewPortInstruction.childRouter) {
        var path = instruction.getWildcardPath();
        var task = prevViewPortInstruction.childRouter._createNavigationInstruction(path, instruction).then(function (childInstruction) {
          viewPortPlan.childNavigationInstruction = childInstruction;

          return _buildNavigationPlan(childInstruction, viewPortPlan.strategy === activationStrategy.invokeLifecycle).then(function (childPlan) {
            childInstruction.plan = childPlan;
          });
        });

        pending.push(task);
      }
    };

    for (var viewPortName in prev.viewPortInstructions) {
      _loop2(viewPortName);
    }

    return Promise.all(pending).then(function () {
      return plan;
    });
  }

  for (var viewPortName in config.viewPorts) {
    var viewPortConfig = config.viewPorts[viewPortName];
    if (viewPortConfig.moduleId === null && viewPortName in instruction.router.viewPortDefaults) {
      viewPortConfig = defaults[viewPortName];
    }
    plan[viewPortName] = {
      name: viewPortName,
      strategy: activationStrategy.replace,
      config: viewPortConfig
    };
  }

  return Promise.resolve(plan);
}

function hasDifferentParameterValues(prev, next) {
  var prevParams = prev.params;
  var nextParams = next.params;
  var nextWildCardName = next.config.hasChildRouter ? next.getWildCardName() : null;

  for (var key in nextParams) {
    if (key === nextWildCardName) {
      continue;
    }

    if (prevParams[key] !== nextParams[key]) {
      return true;
    }
  }

  for (var _key in prevParams) {
    if (_key === nextWildCardName) {
      continue;
    }

    if (prevParams[_key] !== nextParams[_key]) {
      return true;
    }
  }

  if (!next.options.compareQueryParams) {
    return false;
  }

  var prevQueryParams = prev.queryParams;
  var nextQueryParams = next.queryParams;
  for (var _key2 in nextQueryParams) {
    if (prevQueryParams[_key2] !== nextQueryParams[_key2]) {
      return true;
    }
  }

  for (var _key3 in prevQueryParams) {
    if (prevQueryParams[_key3] !== nextQueryParams[_key3]) {
      return true;
    }
  }

  return false;
}

function getInstructionBaseUrl(instruction) {
  var instructionBaseUrlParts = [];
  instruction = instruction.parentInstruction;

  while (instruction) {
    instructionBaseUrlParts.unshift(instruction.getBaseUrl());
    instruction = instruction.parentInstruction;
  }

  instructionBaseUrlParts.unshift('/');
  return instructionBaseUrlParts.join('');
}

var Router = exports.Router = function () {
  function Router(container, history) {
    var _this3 = this;

    

    this.parent = null;
    this.options = {};
    this.viewPortDefaults = {};

    this.transformTitle = function (title) {
      if (_this3.parent) {
        return _this3.parent.transformTitle(title);
      }
      return title;
    };

    this.container = container;
    this.history = history;
    this.reset();
  }

  Router.prototype.reset = function reset() {
    var _this4 = this;

    this.viewPorts = {};
    this.routes = [];
    this.baseUrl = '';
    this.isConfigured = false;
    this.isNavigating = false;
    this.isExplicitNavigation = false;
    this.isExplicitNavigationBack = false;
    this.isNavigatingFirst = false;
    this.isNavigatingNew = false;
    this.isNavigatingRefresh = false;
    this.isNavigatingForward = false;
    this.isNavigatingBack = false;
    this.navigation = [];
    this.currentInstruction = null;
    this.viewPortDefaults = {};
    this._fallbackOrder = 100;
    this._recognizer = new _aureliaRouteRecognizer.RouteRecognizer();
    this._childRecognizer = new _aureliaRouteRecognizer.RouteRecognizer();
    this._configuredPromise = new Promise(function (resolve) {
      _this4._resolveConfiguredPromise = resolve;
    });
  };

  Router.prototype.registerViewPort = function registerViewPort(viewPort, name) {
    name = name || 'default';
    this.viewPorts[name] = viewPort;
  };

  Router.prototype.ensureConfigured = function ensureConfigured() {
    return this._configuredPromise;
  };

  Router.prototype.configure = function configure(callbackOrConfig) {
    var _this5 = this;

    this.isConfigured = true;

    var result = callbackOrConfig;
    var config = void 0;
    if (typeof callbackOrConfig === 'function') {
      config = new RouterConfiguration();
      result = callbackOrConfig(config);
    }

    return Promise.resolve(result).then(function (c) {
      if (c && c.exportToRouter) {
        config = c;
      }

      config.exportToRouter(_this5);
      _this5.isConfigured = true;
      _this5._resolveConfiguredPromise();
    });
  };

  Router.prototype.navigate = function navigate(fragment, options) {
    if (!this.isConfigured && this.parent) {
      return this.parent.navigate(fragment, options);
    }

    this.isExplicitNavigation = true;
    return this.history.navigate(_resolveUrl(fragment, this.baseUrl, this.history._hasPushState), options);
  };

  Router.prototype.navigateToRoute = function navigateToRoute(route, params, options) {
    var path = this.generate(route, params);
    return this.navigate(path, options);
  };

  Router.prototype.navigateBack = function navigateBack() {
    this.isExplicitNavigationBack = true;
    this.history.navigateBack();
  };

  Router.prototype.createChild = function createChild(container) {
    var childRouter = new Router(container || this.container.createChild(), this.history);
    childRouter.parent = this;
    return childRouter;
  };

  Router.prototype.generate = function generate(name, params) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var hasRoute = this._recognizer.hasRoute(name);
    if ((!this.isConfigured || !hasRoute) && this.parent) {
      return this.parent.generate(name, params);
    }

    if (!hasRoute) {
      throw new Error('A route with name \'' + name + '\' could not be found. Check that `name: \'' + name + '\'` was specified in the route\'s config.');
    }

    var path = this._recognizer.generate(name, params);
    var rootedPath = _createRootedPath(path, this.baseUrl, this.history._hasPushState, options.absolute);
    return options.absolute ? '' + this.history.getAbsoluteRoot() + rootedPath : rootedPath;
  };

  Router.prototype.createNavModel = function createNavModel(config) {
    var navModel = new NavModel(this, 'href' in config ? config.href : config.route);
    navModel.title = config.title;
    navModel.order = config.nav;
    navModel.href = config.href;
    navModel.settings = config.settings;
    navModel.config = config;

    return navModel;
  };

  Router.prototype.addRoute = function addRoute(config, navModel) {
    validateRouteConfig(config, this.routes);

    if (!('viewPorts' in config) && !config.navigationStrategy) {
      config.viewPorts = {
        'default': {
          moduleId: config.moduleId,
          view: config.view
        }
      };
    }

    if (!navModel) {
      navModel = this.createNavModel(config);
    }

    this.routes.push(config);

    var path = config.route;
    if (path.charAt(0) === '/') {
      path = path.substr(1);
    }
    var caseSensitive = config.caseSensitive === true;
    var state = this._recognizer.add({ path: path, handler: config, caseSensitive: caseSensitive });

    if (path) {
      var _settings = config.settings;
      delete config.settings;
      var withChild = JSON.parse(JSON.stringify(config));
      config.settings = _settings;
      withChild.route = path + '/*childRoute';
      withChild.hasChildRouter = true;
      this._childRecognizer.add({
        path: withChild.route,
        handler: withChild,
        caseSensitive: caseSensitive
      });

      withChild.navModel = navModel;
      withChild.settings = config.settings;
      withChild.navigationStrategy = config.navigationStrategy;
    }

    config.navModel = navModel;

    if ((navModel.order || navModel.order === 0) && this.navigation.indexOf(navModel) === -1) {
      if (!navModel.href && navModel.href !== '' && (state.types.dynamics || state.types.stars)) {
        throw new Error('Invalid route config for "' + config.route + '" : dynamic routes must specify an "href:" to be included in the navigation model.');
      }

      if (typeof navModel.order !== 'number') {
        navModel.order = ++this._fallbackOrder;
      }

      this.navigation.push(navModel);
      this.navigation = this.navigation.sort(function (a, b) {
        return a.order - b.order;
      });
    }
  };

  Router.prototype.hasRoute = function hasRoute(name) {
    return !!(this._recognizer.hasRoute(name) || this.parent && this.parent.hasRoute(name));
  };

  Router.prototype.hasOwnRoute = function hasOwnRoute(name) {
    return this._recognizer.hasRoute(name);
  };

  Router.prototype.handleUnknownRoutes = function handleUnknownRoutes(config) {
    var _this6 = this;

    if (!config) {
      throw new Error('Invalid unknown route handler');
    }

    this.catchAllHandler = function (instruction) {
      return _this6._createRouteConfig(config, instruction).then(function (c) {
        instruction.config = c;
        return instruction;
      });
    };
  };

  Router.prototype.updateTitle = function updateTitle() {
    if (this.parent) {
      return this.parent.updateTitle();
    }

    if (this.currentInstruction) {
      this.currentInstruction._updateTitle();
    }
    return undefined;
  };

  Router.prototype.refreshNavigation = function refreshNavigation() {
    var nav = this.navigation;

    for (var i = 0, length = nav.length; i < length; i++) {
      var _current2 = nav[i];
      if (!_current2.config.href) {
        _current2.href = _createRootedPath(_current2.relativeHref, this.baseUrl, this.history._hasPushState);
      } else {
        _current2.href = _normalizeAbsolutePath(_current2.config.href, this.history._hasPushState);
      }
    }
  };

  Router.prototype.useViewPortDefaults = function useViewPortDefaults(viewPortDefaults) {
    for (var viewPortName in viewPortDefaults) {
      var viewPortConfig = viewPortDefaults[viewPortName];
      this.viewPortDefaults[viewPortName] = {
        moduleId: viewPortConfig.moduleId
      };
    }
  };

  Router.prototype._refreshBaseUrl = function _refreshBaseUrl() {
    if (this.parent) {
      var baseUrl = this.parent.currentInstruction.getBaseUrl();
      this.baseUrl = this.parent.baseUrl + baseUrl;
    }
  };

  Router.prototype._createNavigationInstruction = function _createNavigationInstruction() {
    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var parentInstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    var fragment = url;
    var queryString = '';

    var queryIndex = url.indexOf('?');
    if (queryIndex !== -1) {
      fragment = url.substr(0, queryIndex);
      queryString = url.substr(queryIndex + 1);
    }

    var results = this._recognizer.recognize(url);
    if (!results || !results.length) {
      results = this._childRecognizer.recognize(url);
    }

    var instructionInit = {
      fragment: fragment,
      queryString: queryString,
      config: null,
      parentInstruction: parentInstruction,
      previousInstruction: this.currentInstruction,
      router: this,
      options: {
        compareQueryParams: this.options.compareQueryParams
      }
    };

    if (results && results.length) {
      var first = results[0];
      var _instruction = new NavigationInstruction(Object.assign({}, instructionInit, {
        params: first.params,
        queryParams: first.queryParams || results.queryParams,
        config: first.config || first.handler
      }));

      if (typeof first.handler === 'function') {
        return evaluateNavigationStrategy(_instruction, first.handler, first);
      } else if (first.handler && typeof first.handler.navigationStrategy === 'function') {
        return evaluateNavigationStrategy(_instruction, first.handler.navigationStrategy, first.handler);
      }

      return Promise.resolve(_instruction);
    } else if (this.catchAllHandler) {
      var _instruction2 = new NavigationInstruction(Object.assign({}, instructionInit, {
        params: { path: fragment },
        queryParams: results ? results.queryParams : {},
        config: null }));

      return evaluateNavigationStrategy(_instruction2, this.catchAllHandler);
    } else if (this.parent) {
      var _router = this._parentCatchAllHandler(this.parent);

      if (_router) {
        var newParentInstruction = this._findParentInstructionFromRouter(_router, parentInstruction);

        var _instruction3 = new NavigationInstruction(Object.assign({}, instructionInit, {
          params: { path: fragment },
          queryParams: results ? results.queryParams : {},
          router: _router,
          parentInstruction: newParentInstruction,
          parentCatchHandler: true,
          config: null }));

        return evaluateNavigationStrategy(_instruction3, _router.catchAllHandler);
      }
    }

    return Promise.reject(new Error('Route not found: ' + url));
  };

  Router.prototype._findParentInstructionFromRouter = function _findParentInstructionFromRouter(router, instruction) {
    if (instruction.router === router) {
      instruction.fragment = router.baseUrl;
      return instruction;
    } else if (instruction.parentInstruction) {
      return this._findParentInstructionFromRouter(router, instruction.parentInstruction);
    }
    return undefined;
  };

  Router.prototype._parentCatchAllHandler = function _parentCatchAllHandler(router) {
    if (router.catchAllHandler) {
      return router;
    } else if (router.parent) {
      return this._parentCatchAllHandler(router.parent);
    }
    return false;
  };

  Router.prototype._createRouteConfig = function _createRouteConfig(config, instruction) {
    var _this7 = this;

    return Promise.resolve(config).then(function (c) {
      if (typeof c === 'string') {
        return { moduleId: c };
      } else if (typeof c === 'function') {
        return c(instruction);
      }

      return c;
    }).then(function (c) {
      return typeof c === 'string' ? { moduleId: c } : c;
    }).then(function (c) {
      c.route = instruction.params.path;
      validateRouteConfig(c, _this7.routes);

      if (!c.navModel) {
        c.navModel = _this7.createNavModel(c);
      }

      return c;
    });
  };

  _createClass(Router, [{
    key: 'isRoot',
    get: function get() {
      return !this.parent;
    }
  }]);

  return Router;
}();

function validateRouteConfig(config, routes) {
  if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) !== 'object') {
    throw new Error('Invalid Route Config');
  }

  if (typeof config.route !== 'string') {
    var _name2 = config.name || '(no name)';
    throw new Error('Invalid Route Config for "' + _name2 + '": You must specify a "route:" pattern.');
  }

  if (!('redirect' in config || config.moduleId || config.navigationStrategy || config.viewPorts)) {
    throw new Error('Invalid Route Config for "' + config.route + '": You must specify a "moduleId:", "redirect:", "navigationStrategy:", or "viewPorts:".');
  }
}

function evaluateNavigationStrategy(instruction, evaluator, context) {
  return Promise.resolve(evaluator.call(context, instruction)).then(function () {
    if (!('viewPorts' in instruction.config)) {
      instruction.config.viewPorts = {
        'default': {
          moduleId: instruction.config.moduleId
        }
      };
    }

    return instruction;
  });
}

var CanDeactivatePreviousStep = exports.CanDeactivatePreviousStep = function () {
  function CanDeactivatePreviousStep() {
    
  }

  CanDeactivatePreviousStep.prototype.run = function run(navigationInstruction, next) {
    return processDeactivatable(navigationInstruction, 'canDeactivate', next);
  };

  return CanDeactivatePreviousStep;
}();

var CanActivateNextStep = exports.CanActivateNextStep = function () {
  function CanActivateNextStep() {
    
  }

  CanActivateNextStep.prototype.run = function run(navigationInstruction, next) {
    return processActivatable(navigationInstruction, 'canActivate', next);
  };

  return CanActivateNextStep;
}();

var DeactivatePreviousStep = exports.DeactivatePreviousStep = function () {
  function DeactivatePreviousStep() {
    
  }

  DeactivatePreviousStep.prototype.run = function run(navigationInstruction, next) {
    return processDeactivatable(navigationInstruction, 'deactivate', next, true);
  };

  return DeactivatePreviousStep;
}();

var ActivateNextStep = exports.ActivateNextStep = function () {
  function ActivateNextStep() {
    
  }

  ActivateNextStep.prototype.run = function run(navigationInstruction, next) {
    return processActivatable(navigationInstruction, 'activate', next, true);
  };

  return ActivateNextStep;
}();

function processDeactivatable(navigationInstruction, callbackName, next, ignoreResult) {
  var plan = navigationInstruction.plan;
  var infos = findDeactivatable(plan, callbackName);
  var i = infos.length;

  function inspect(val) {
    if (ignoreResult || shouldContinue(val)) {
      return iterate();
    }

    return next.cancel(val);
  }

  function iterate() {
    if (i--) {
      try {
        var viewModel = infos[i];
        var _result = viewModel[callbackName](navigationInstruction);
        return processPotential(_result, inspect, next.cancel);
      } catch (error) {
        return next.cancel(error);
      }
    }

    return next();
  }

  return iterate();
}

function findDeactivatable(plan, callbackName) {
  var list = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  for (var viewPortName in plan) {
    var _viewPortPlan = plan[viewPortName];
    var prevComponent = _viewPortPlan.prevComponent;

    if ((_viewPortPlan.strategy === activationStrategy.invokeLifecycle || _viewPortPlan.strategy === activationStrategy.replace) && prevComponent) {
      var viewModel = prevComponent.viewModel;

      if (callbackName in viewModel) {
        list.push(viewModel);
      }
    }

    if (_viewPortPlan.strategy === activationStrategy.replace && prevComponent) {
      addPreviousDeactivatable(prevComponent, callbackName, list);
    } else if (_viewPortPlan.childNavigationInstruction) {
      findDeactivatable(_viewPortPlan.childNavigationInstruction.plan, callbackName, list);
    }
  }

  return list;
}

function addPreviousDeactivatable(component, callbackName, list) {
  var childRouter = component.childRouter;

  if (childRouter && childRouter.currentInstruction) {
    var viewPortInstructions = childRouter.currentInstruction.viewPortInstructions;

    for (var viewPortName in viewPortInstructions) {
      var _viewPortInstruction2 = viewPortInstructions[viewPortName];
      var prevComponent = _viewPortInstruction2.component;
      var prevViewModel = prevComponent.viewModel;

      if (callbackName in prevViewModel) {
        list.push(prevViewModel);
      }

      addPreviousDeactivatable(prevComponent, callbackName, list);
    }
  }
}

function processActivatable(navigationInstruction, callbackName, next, ignoreResult) {
  var infos = findActivatable(navigationInstruction, callbackName);
  var length = infos.length;
  var i = -1;

  function inspect(val, router) {
    if (ignoreResult || shouldContinue(val, router)) {
      return iterate();
    }

    return next.cancel(val);
  }

  function iterate() {
    i++;

    if (i < length) {
      try {
        var _current3$viewModel;

        var _current3 = infos[i];
        var _result2 = (_current3$viewModel = _current3.viewModel)[callbackName].apply(_current3$viewModel, _current3.lifecycleArgs);
        return processPotential(_result2, function (val) {
          return inspect(val, _current3.router);
        }, next.cancel);
      } catch (error) {
        return next.cancel(error);
      }
    }

    return next();
  }

  return iterate();
}

function findActivatable(navigationInstruction, callbackName) {
  var list = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var router = arguments[3];

  var plan = navigationInstruction.plan;

  Object.keys(plan).filter(function (viewPortName) {
    var viewPortPlan = plan[viewPortName];
    var viewPortInstruction = navigationInstruction.viewPortInstructions[viewPortName];
    var viewModel = viewPortInstruction.component.viewModel;

    if ((viewPortPlan.strategy === activationStrategy.invokeLifecycle || viewPortPlan.strategy === activationStrategy.replace) && callbackName in viewModel) {
      list.push({
        viewModel: viewModel,
        lifecycleArgs: viewPortInstruction.lifecycleArgs,
        router: router
      });
    }

    if (viewPortPlan.childNavigationInstruction) {
      findActivatable(viewPortPlan.childNavigationInstruction, callbackName, list, viewPortInstruction.component.childRouter || router);
    }
  });

  return list;
}

function shouldContinue(output, router) {
  if (output instanceof Error) {
    return false;
  }

  if (isNavigationCommand(output)) {
    if (typeof output.setRouter === 'function') {
      output.setRouter(router);
    }

    return !!output.shouldContinueProcessing;
  }

  if (output === undefined) {
    return true;
  }

  return output;
}

var SafeSubscription = function () {
  function SafeSubscription(subscriptionFunc) {
    

    this._subscribed = true;
    this._subscription = subscriptionFunc(this);

    if (!this._subscribed) this.unsubscribe();
  }

  SafeSubscription.prototype.unsubscribe = function unsubscribe() {
    if (this._subscribed && this._subscription) this._subscription.unsubscribe();

    this._subscribed = false;
  };

  _createClass(SafeSubscription, [{
    key: 'subscribed',
    get: function get() {
      return this._subscribed;
    }
  }]);

  return SafeSubscription;
}();

function processPotential(obj, resolve, reject) {
  if (obj && typeof obj.then === 'function') {
    return Promise.resolve(obj).then(resolve).catch(reject);
  }

  if (obj && typeof obj.subscribe === 'function') {
    var obs = obj;
    return new SafeSubscription(function (sub) {
      return obs.subscribe({
        next: function next() {
          if (sub.subscribed) {
            sub.unsubscribe();
            resolve(obj);
          }
        },
        error: function error(_error) {
          if (sub.subscribed) {
            sub.unsubscribe();
            reject(_error);
          }
        },
        complete: function complete() {
          if (sub.subscribed) {
            sub.unsubscribe();
            resolve(obj);
          }
        }
      });
    });
  }

  try {
    return resolve(obj);
  } catch (error) {
    return reject(error);
  }
}

var RouteLoader = exports.RouteLoader = function () {
  function RouteLoader() {
    
  }

  RouteLoader.prototype.loadRoute = function loadRoute(router, config, navigationInstruction) {
    throw Error('Route loaders must implement "loadRoute(router, config, navigationInstruction)".');
  };

  return RouteLoader;
}();

var LoadRouteStep = exports.LoadRouteStep = function () {
  LoadRouteStep.inject = function inject() {
    return [RouteLoader];
  };

  function LoadRouteStep(routeLoader) {
    

    this.routeLoader = routeLoader;
  }

  LoadRouteStep.prototype.run = function run(navigationInstruction, next) {
    return loadNewRoute(this.routeLoader, navigationInstruction).then(next).catch(next.cancel);
  };

  return LoadRouteStep;
}();

function loadNewRoute(routeLoader, navigationInstruction) {
  var toLoad = determineWhatToLoad(navigationInstruction);
  var loadPromises = toLoad.map(function (current) {
    return loadRoute(routeLoader, current.navigationInstruction, current.viewPortPlan);
  });

  return Promise.all(loadPromises);
}

function determineWhatToLoad(navigationInstruction) {
  var toLoad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var plan = navigationInstruction.plan;

  for (var viewPortName in plan) {
    var _viewPortPlan2 = plan[viewPortName];

    if (_viewPortPlan2.strategy === activationStrategy.replace) {
      toLoad.push({ viewPortPlan: _viewPortPlan2, navigationInstruction: navigationInstruction });

      if (_viewPortPlan2.childNavigationInstruction) {
        determineWhatToLoad(_viewPortPlan2.childNavigationInstruction, toLoad);
      }
    } else {
      var _viewPortInstruction3 = navigationInstruction.addViewPortInstruction(viewPortName, _viewPortPlan2.strategy, _viewPortPlan2.prevModuleId, _viewPortPlan2.prevComponent);

      if (_viewPortPlan2.childNavigationInstruction) {
        _viewPortInstruction3.childNavigationInstruction = _viewPortPlan2.childNavigationInstruction;
        determineWhatToLoad(_viewPortPlan2.childNavigationInstruction, toLoad);
      }
    }
  }

  return toLoad;
}

function loadRoute(routeLoader, navigationInstruction, viewPortPlan) {
  var moduleId = viewPortPlan.config ? viewPortPlan.config.moduleId : null;

  return loadComponent(routeLoader, navigationInstruction, viewPortPlan.config).then(function (component) {
    var viewPortInstruction = navigationInstruction.addViewPortInstruction(viewPortPlan.name, viewPortPlan.strategy, moduleId, component);

    var childRouter = component.childRouter;
    if (childRouter) {
      var path = navigationInstruction.getWildcardPath();

      return childRouter._createNavigationInstruction(path, navigationInstruction).then(function (childInstruction) {
        viewPortPlan.childNavigationInstruction = childInstruction;

        return _buildNavigationPlan(childInstruction).then(function (childPlan) {
          childInstruction.plan = childPlan;
          viewPortInstruction.childNavigationInstruction = childInstruction;

          return loadNewRoute(routeLoader, childInstruction);
        });
      });
    }

    return undefined;
  });
}

function loadComponent(routeLoader, navigationInstruction, config) {
  var router = navigationInstruction.router;
  var lifecycleArgs = navigationInstruction.lifecycleArgs;

  return routeLoader.loadRoute(router, config, navigationInstruction).then(function (component) {
    var viewModel = component.viewModel,
        childContainer = component.childContainer;

    component.router = router;
    component.config = config;

    if ('configureRouter' in viewModel) {
      var childRouter = childContainer.getChildRouter();
      component.childRouter = childRouter;

      return childRouter.configure(function (c) {
        return viewModel.configureRouter.apply(viewModel, [c, childRouter].concat(lifecycleArgs));
      }).then(function () {
        return component;
      });
    }

    return component;
  });
}

var PipelineSlot = function () {
  function PipelineSlot(container, name, alias) {
    

    this.steps = [];

    this.container = container;
    this.slotName = name;
    this.slotAlias = alias;
  }

  PipelineSlot.prototype.getSteps = function getSteps() {
    var _this8 = this;

    return this.steps.map(function (x) {
      return _this8.container.get(x);
    });
  };

  return PipelineSlot;
}();

var PipelineProvider = exports.PipelineProvider = function () {
  PipelineProvider.inject = function inject() {
    return [_aureliaDependencyInjection.Container];
  };

  function PipelineProvider(container) {
    

    this.container = container;
    this.steps = [BuildNavigationPlanStep, CanDeactivatePreviousStep, LoadRouteStep, this._createPipelineSlot('authorize'), CanActivateNextStep, this._createPipelineSlot('preActivate', 'modelbind'), DeactivatePreviousStep, ActivateNextStep, this._createPipelineSlot('preRender', 'precommit'), CommitChangesStep, this._createPipelineSlot('postRender', 'postcomplete')];
  }

  PipelineProvider.prototype.createPipeline = function createPipeline() {
    var _this9 = this;

    var pipeline = new Pipeline();
    this.steps.forEach(function (step) {
      return pipeline.addStep(_this9.container.get(step));
    });
    return pipeline;
  };

  PipelineProvider.prototype._findStep = function _findStep(name) {
    return this.steps.find(function (x) {
      return x.slotName === name || x.slotAlias === name;
    });
  };

  PipelineProvider.prototype.addStep = function addStep(name, step) {
    var found = this._findStep(name);
    if (found) {
      if (!found.steps.includes(step)) {
        found.steps.push(step);
      }
    } else {
      throw new Error('Invalid pipeline slot name: ' + name + '.');
    }
  };

  PipelineProvider.prototype.removeStep = function removeStep(name, step) {
    var slot = this._findStep(name);
    if (slot) {
      slot.steps.splice(slot.steps.indexOf(step), 1);
    }
  };

  PipelineProvider.prototype._clearSteps = function _clearSteps() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    var slot = this._findStep(name);
    if (slot) {
      slot.steps = [];
    }
  };

  PipelineProvider.prototype.reset = function reset() {
    this._clearSteps('authorize');
    this._clearSteps('preActivate');
    this._clearSteps('preRender');
    this._clearSteps('postRender');
  };

  PipelineProvider.prototype._createPipelineSlot = function _createPipelineSlot(name, alias) {
    return new PipelineSlot(this.container, name, alias);
  };

  return PipelineProvider;
}();

var logger = LogManager.getLogger('app-router');

var AppRouter = exports.AppRouter = function (_Router) {
  _inherits(AppRouter, _Router);

  AppRouter.inject = function inject() {
    return [_aureliaDependencyInjection.Container, _aureliaHistory.History, PipelineProvider, _aureliaEventAggregator.EventAggregator];
  };

  function AppRouter(container, history, pipelineProvider, events) {
    

    var _this10 = _possibleConstructorReturn(this, _Router.call(this, container, history));

    _this10.pipelineProvider = pipelineProvider;
    _this10.events = events;
    return _this10;
  }

  AppRouter.prototype.reset = function reset() {
    _Router.prototype.reset.call(this);
    this.maxInstructionCount = 10;
    if (!this._queue) {
      this._queue = [];
    } else {
      this._queue.length = 0;
    }
  };

  AppRouter.prototype.loadUrl = function loadUrl(url) {
    var _this11 = this;

    return this._createNavigationInstruction(url).then(function (instruction) {
      return _this11._queueInstruction(instruction);
    }).catch(function (error) {
      logger.error(error);
      restorePreviousLocation(_this11);
    });
  };

  AppRouter.prototype.registerViewPort = function registerViewPort(viewPort, name) {
    var _this12 = this;

    _Router.prototype.registerViewPort.call(this, viewPort, name);

    if (!this.isActive) {
      var viewModel = this._findViewModel(viewPort);
      if ('configureRouter' in viewModel) {
        if (!this.isConfigured) {
          var resolveConfiguredPromise = this._resolveConfiguredPromise;
          this._resolveConfiguredPromise = function () {};
          return this.configure(function (config) {
            return viewModel.configureRouter(config, _this12);
          }).then(function () {
            _this12.activate();
            resolveConfiguredPromise();
          });
        }
      } else {
        this.activate();
      }
    } else {
      this._dequeueInstruction();
    }

    return Promise.resolve();
  };

  AppRouter.prototype.activate = function activate(options) {
    if (this.isActive) {
      return;
    }

    this.isActive = true;
    this.options = Object.assign({ routeHandler: this.loadUrl.bind(this) }, this.options, options);
    this.history.activate(this.options);
    this._dequeueInstruction();
  };

  AppRouter.prototype.deactivate = function deactivate() {
    this.isActive = false;
    this.history.deactivate();
  };

  AppRouter.prototype._queueInstruction = function _queueInstruction(instruction) {
    var _this13 = this;

    return new Promise(function (resolve) {
      instruction.resolve = resolve;
      _this13._queue.unshift(instruction);
      _this13._dequeueInstruction();
    });
  };

  AppRouter.prototype._dequeueInstruction = function _dequeueInstruction() {
    var _this14 = this;

    var instructionCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    return Promise.resolve().then(function () {
      if (_this14.isNavigating && !instructionCount) {
        return undefined;
      }

      var instruction = _this14._queue.shift();
      _this14._queue.length = 0;

      if (!instruction) {
        return undefined;
      }

      _this14.isNavigating = true;

      var navtracker = _this14.history.getState('NavigationTracker');
      if (!navtracker && !_this14.currentNavigationTracker) {
        _this14.isNavigatingFirst = true;
        _this14.isNavigatingNew = true;
      } else if (!navtracker) {
        _this14.isNavigatingNew = true;
      } else if (!_this14.currentNavigationTracker) {
        _this14.isNavigatingRefresh = true;
      } else if (_this14.currentNavigationTracker < navtracker) {
        _this14.isNavigatingForward = true;
      } else if (_this14.currentNavigationTracker > navtracker) {
        _this14.isNavigatingBack = true;
      }if (!navtracker) {
        navtracker = Date.now();
        _this14.history.setState('NavigationTracker', navtracker);
      }
      _this14.currentNavigationTracker = navtracker;

      instruction.previousInstruction = _this14.currentInstruction;

      if (!instructionCount) {
        _this14.events.publish('router:navigation:processing', { instruction: instruction });
      } else if (instructionCount === _this14.maxInstructionCount - 1) {
        logger.error(instructionCount + 1 + ' navigation instructions have been attempted without success. Restoring last known good location.');
        restorePreviousLocation(_this14);
        return _this14._dequeueInstruction(instructionCount + 1);
      } else if (instructionCount > _this14.maxInstructionCount) {
        throw new Error('Maximum navigation attempts exceeded. Giving up.');
      }

      var pipeline = _this14.pipelineProvider.createPipeline();

      return pipeline.run(instruction).then(function (result) {
        return processResult(instruction, result, instructionCount, _this14);
      }).catch(function (error) {
        return { output: error instanceof Error ? error : new Error(error) };
      }).then(function (result) {
        return resolveInstruction(instruction, result, !!instructionCount, _this14);
      });
    });
  };

  AppRouter.prototype._findViewModel = function _findViewModel(viewPort) {
    if (this.container.viewModel) {
      return this.container.viewModel;
    }

    if (viewPort.container) {
      var container = viewPort.container;

      while (container) {
        if (container.viewModel) {
          this.container.viewModel = container.viewModel;
          return container.viewModel;
        }

        container = container.parent;
      }
    }

    return undefined;
  };

  return AppRouter;
}(Router);

function processResult(instruction, result, instructionCount, router) {
  if (!(result && 'completed' in result && 'output' in result)) {
    result = result || {};
    result.output = new Error('Expected router pipeline to return a navigation result, but got [' + JSON.stringify(result) + '] instead.');
  }

  var finalResult = null;
  if (isNavigationCommand(result.output)) {
    result.output.navigate(router);
  } else {
    finalResult = result;

    if (!result.completed) {
      if (result.output instanceof Error) {
        logger.error(result.output);
      }

      restorePreviousLocation(router);
    }
  }

  return router._dequeueInstruction(instructionCount + 1).then(function (innerResult) {
    return finalResult || innerResult || result;
  });
}

function resolveInstruction(instruction, result, isInnerInstruction, router) {
  instruction.resolve(result);

  var eventArgs = { instruction: instruction, result: result };
  if (!isInnerInstruction) {
    router.isNavigating = false;
    router.isExplicitNavigation = false;
    router.isExplicitNavigationBack = false;
    router.isNavigatingFirst = false;
    router.isNavigatingNew = false;
    router.isNavigatingRefresh = false;
    router.isNavigatingForward = false;
    router.isNavigatingBack = false;

    var eventName = void 0;

    if (result.output instanceof Error) {
      eventName = 'error';
    } else if (!result.completed) {
      eventName = 'canceled';
    } else {
      var _queryString = instruction.queryString ? '?' + instruction.queryString : '';
      router.history.previousLocation = instruction.fragment + _queryString;
      eventName = 'success';
    }

    router.events.publish('router:navigation:' + eventName, eventArgs);
    router.events.publish('router:navigation:complete', eventArgs);
  } else {
    router.events.publish('router:navigation:child:complete', eventArgs);
  }

  return result;
}

function restorePreviousLocation(router) {
  var previousLocation = router.history.previousLocation;
  if (previousLocation) {
    router.navigate(router.history.previousLocation, { trigger: false, replace: true });
  } else if (router.fallbackRoute) {
    router.navigate(router.fallbackRoute, { trigger: true, replace: true });
  } else {
    logger.error('Router navigation failed, and no previous location or fallbackRoute could be restored.');
  }
}
});

define('aurelia-task-queue/dist/commonjs/aurelia-task-queue',['require','exports','module','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TaskQueue = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _aureliaPal = require('aurelia-pal');



var hasSetImmediate = typeof setImmediate === 'function';
var stackSeparator = '\nEnqueued in TaskQueue by:\n';
var microStackSeparator = '\nEnqueued in MicroTaskQueue by:\n';

function makeRequestFlushFromMutationObserver(flush) {
  var toggle = 1;
  var observer = _aureliaPal.DOM.createMutationObserver(flush);
  var node = _aureliaPal.DOM.createTextNode('');
  observer.observe(node, { characterData: true });
  return function requestFlush() {
    toggle = -toggle;
    node.data = toggle;
  };
}

function makeRequestFlushFromTimer(flush) {
  return function requestFlush() {
    var timeoutHandle = setTimeout(handleFlushTimer, 0);

    var intervalHandle = setInterval(handleFlushTimer, 50);
    function handleFlushTimer() {
      clearTimeout(timeoutHandle);
      clearInterval(intervalHandle);
      flush();
    }
  };
}

function onError(error, task, longStacks) {
  if (longStacks && task.stack && (typeof error === 'undefined' ? 'undefined' : _typeof(error)) === 'object' && error !== null) {
    error.stack = filterFlushStack(error.stack) + task.stack;
  }

  if ('onError' in task) {
    task.onError(error);
  } else if (hasSetImmediate) {
    setImmediate(function () {
      throw error;
    });
  } else {
    setTimeout(function () {
      throw error;
    }, 0);
  }
}

var TaskQueue = exports.TaskQueue = function () {
  function TaskQueue() {
    var _this = this;

    

    this.flushing = false;
    this.longStacks = false;

    this.microTaskQueue = [];
    this.microTaskQueueCapacity = 1024;
    this.taskQueue = [];

    if (_aureliaPal.FEATURE.mutationObserver) {
      this.requestFlushMicroTaskQueue = makeRequestFlushFromMutationObserver(function () {
        return _this.flushMicroTaskQueue();
      });
    } else {
      this.requestFlushMicroTaskQueue = makeRequestFlushFromTimer(function () {
        return _this.flushMicroTaskQueue();
      });
    }

    this.requestFlushTaskQueue = makeRequestFlushFromTimer(function () {
      return _this.flushTaskQueue();
    });
  }

  TaskQueue.prototype._flushQueue = function _flushQueue(queue, capacity) {
    var index = 0;
    var task = void 0;

    try {
      this.flushing = true;
      while (index < queue.length) {
        task = queue[index];
        if (this.longStacks) {
          this.stack = typeof task.stack === 'string' ? task.stack : undefined;
        }
        task.call();
        index++;

        if (index > capacity) {
          for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
            queue[scan] = queue[scan + index];
          }

          queue.length -= index;
          index = 0;
        }
      }
    } catch (error) {
      onError(error, task, this.longStacks);
    } finally {
      this.flushing = false;
    }
  };

  TaskQueue.prototype.queueMicroTask = function queueMicroTask(task) {
    if (this.microTaskQueue.length < 1) {
      this.requestFlushMicroTaskQueue();
    }

    if (this.longStacks) {
      task.stack = this.prepareQueueStack(microStackSeparator);
    }

    this.microTaskQueue.push(task);
  };

  TaskQueue.prototype.queueTask = function queueTask(task) {
    if (this.taskQueue.length < 1) {
      this.requestFlushTaskQueue();
    }

    if (this.longStacks) {
      task.stack = this.prepareQueueStack(stackSeparator);
    }

    this.taskQueue.push(task);
  };

  TaskQueue.prototype.flushTaskQueue = function flushTaskQueue() {
    var queue = this.taskQueue;
    this.taskQueue = [];
    this._flushQueue(queue, Number.MAX_VALUE);
  };

  TaskQueue.prototype.flushMicroTaskQueue = function flushMicroTaskQueue() {
    var queue = this.microTaskQueue;
    this._flushQueue(queue, this.microTaskQueueCapacity);
    queue.length = 0;
  };

  TaskQueue.prototype.prepareQueueStack = function prepareQueueStack(separator) {
    var stack = separator + filterQueueStack(captureStack());

    if (typeof this.stack === 'string') {
      stack = filterFlushStack(stack) + this.stack;
    }

    return stack;
  };

  return TaskQueue;
}();

function captureStack() {
  var error = new Error();

  if (error.stack) {
    return error.stack;
  }

  try {
    throw error;
  } catch (e) {
    return e.stack;
  }
}

function filterQueueStack(stack) {
  return stack.replace(/^[\s\S]*?\bqueue(Micro)?Task\b[^\n]*\n/, '');
}

function filterFlushStack(stack) {
  var index = stack.lastIndexOf('flushMicroTaskQueue');

  if (index < 0) {
    index = stack.lastIndexOf('flushTaskQueue');
    if (index < 0) {
      return stack;
    }
  }

  index = stack.lastIndexOf('\n', index);

  return index < 0 ? stack : stack.substr(0, index);
}
});

define('aurelia-templating-binding/dist/commonjs/aurelia-templating-binding',['require','exports','module','aurelia-logging','aurelia-binding','aurelia-templating'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TemplatingBindingLanguage = exports.SyntaxInterpreter = exports.ChildInterpolationBinding = exports.InterpolationBinding = exports.InterpolationBindingExpression = exports.AttributeMap = undefined;

var _class, _temp, _dec, _class2, _class3, _temp2, _class4, _temp3;

exports.configure = configure;

var _aureliaLogging = require('aurelia-logging');

var LogManager = _interopRequireWildcard(_aureliaLogging);

var _aureliaBinding = require('aurelia-binding');

var _aureliaTemplating = require('aurelia-templating');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var AttributeMap = exports.AttributeMap = (_temp = _class = function () {
  function AttributeMap(svg) {
    

    this.elements = Object.create(null);
    this.allElements = Object.create(null);

    this.svg = svg;

    this.registerUniversal('accesskey', 'accessKey');
    this.registerUniversal('contenteditable', 'contentEditable');
    this.registerUniversal('tabindex', 'tabIndex');
    this.registerUniversal('textcontent', 'textContent');
    this.registerUniversal('innerhtml', 'innerHTML');
    this.registerUniversal('scrolltop', 'scrollTop');
    this.registerUniversal('scrollleft', 'scrollLeft');
    this.registerUniversal('readonly', 'readOnly');

    this.register('label', 'for', 'htmlFor');

    this.register('img', 'usemap', 'useMap');

    this.register('input', 'maxlength', 'maxLength');
    this.register('input', 'minlength', 'minLength');
    this.register('input', 'formaction', 'formAction');
    this.register('input', 'formenctype', 'formEncType');
    this.register('input', 'formmethod', 'formMethod');
    this.register('input', 'formnovalidate', 'formNoValidate');
    this.register('input', 'formtarget', 'formTarget');

    this.register('textarea', 'maxlength', 'maxLength');

    this.register('td', 'rowspan', 'rowSpan');
    this.register('td', 'colspan', 'colSpan');
    this.register('th', 'rowspan', 'rowSpan');
    this.register('th', 'colspan', 'colSpan');
  }

  AttributeMap.prototype.register = function register(elementName, attributeName, propertyName) {
    elementName = elementName.toLowerCase();
    attributeName = attributeName.toLowerCase();
    var element = this.elements[elementName] = this.elements[elementName] || Object.create(null);
    element[attributeName] = propertyName;
  };

  AttributeMap.prototype.registerUniversal = function registerUniversal(attributeName, propertyName) {
    attributeName = attributeName.toLowerCase();
    this.allElements[attributeName] = propertyName;
  };

  AttributeMap.prototype.map = function map(elementName, attributeName) {
    if (this.svg.isStandardSvgAttribute(elementName, attributeName)) {
      return attributeName;
    }
    elementName = elementName.toLowerCase();
    attributeName = attributeName.toLowerCase();
    var element = this.elements[elementName];
    if (element !== undefined && attributeName in element) {
      return element[attributeName];
    }
    if (attributeName in this.allElements) {
      return this.allElements[attributeName];
    }

    if (/(?:^data-)|(?:^aria-)|:/.test(attributeName)) {
      return attributeName;
    }
    return (0, _aureliaBinding.camelCase)(attributeName);
  };

  return AttributeMap;
}(), _class.inject = [_aureliaBinding.SVGAnalyzer], _temp);

var InterpolationBindingExpression = exports.InterpolationBindingExpression = function () {
  function InterpolationBindingExpression(observerLocator, targetProperty, parts, mode, lookupFunctions, attribute) {
    

    this.observerLocator = observerLocator;
    this.targetProperty = targetProperty;
    this.parts = parts;
    this.mode = mode;
    this.lookupFunctions = lookupFunctions;
    this.attribute = this.attrToRemove = attribute;
    this.discrete = false;
  }

  InterpolationBindingExpression.prototype.createBinding = function createBinding(target) {
    if (this.parts.length === 3) {
      return new ChildInterpolationBinding(target, this.observerLocator, this.parts[1], this.mode, this.lookupFunctions, this.targetProperty, this.parts[0], this.parts[2]);
    }
    return new InterpolationBinding(this.observerLocator, this.parts, target, this.targetProperty, this.mode, this.lookupFunctions);
  };

  return InterpolationBindingExpression;
}();

function validateTarget(target, propertyName) {
  if (propertyName === 'style') {
    LogManager.getLogger('templating-binding').info('Internet Explorer does not support interpolation in "style" attributes.  Use the style attribute\'s alias, "css" instead.');
  } else if (target.parentElement && target.parentElement.nodeName === 'TEXTAREA' && propertyName === 'textContent') {
    throw new Error('Interpolation binding cannot be used in the content of a textarea element.  Use <textarea value.bind="expression"></textarea> instead.');
  }
}

var InterpolationBinding = exports.InterpolationBinding = function () {
  function InterpolationBinding(observerLocator, parts, target, targetProperty, mode, lookupFunctions) {
    

    validateTarget(target, targetProperty);
    this.observerLocator = observerLocator;
    this.parts = parts;
    this.target = target;
    this.targetProperty = targetProperty;
    this.targetAccessor = observerLocator.getAccessor(target, targetProperty);
    this.mode = mode;
    this.lookupFunctions = lookupFunctions;
  }

  InterpolationBinding.prototype.interpolate = function interpolate() {
    if (this.isBound) {
      var value = '';
      var parts = this.parts;
      for (var i = 0, ii = parts.length; i < ii; i++) {
        value += i % 2 === 0 ? parts[i] : this['childBinding' + i].value;
      }
      this.targetAccessor.setValue(value, this.target, this.targetProperty);
    }
  };

  InterpolationBinding.prototype.updateOneTimeBindings = function updateOneTimeBindings() {
    for (var i = 1, ii = this.parts.length; i < ii; i += 2) {
      var child = this['childBinding' + i];
      if (child.mode === _aureliaBinding.bindingMode.oneTime) {
        child.call();
      }
    }
  };

  InterpolationBinding.prototype.bind = function bind(source) {
    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.source = source;

    var parts = this.parts;
    for (var i = 1, ii = parts.length; i < ii; i += 2) {
      var binding = new ChildInterpolationBinding(this, this.observerLocator, parts[i], this.mode, this.lookupFunctions);
      binding.bind(source);
      this['childBinding' + i] = binding;
    }

    this.isBound = true;
    this.interpolate();
  };

  InterpolationBinding.prototype.unbind = function unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    this.source = null;
    var parts = this.parts;
    for (var i = 1, ii = parts.length; i < ii; i += 2) {
      var name = 'childBinding' + i;
      this[name].unbind();
    }
  };

  return InterpolationBinding;
}();

var ChildInterpolationBinding = exports.ChildInterpolationBinding = (_dec = (0, _aureliaBinding.connectable)(), _dec(_class2 = function () {
  function ChildInterpolationBinding(target, observerLocator, sourceExpression, mode, lookupFunctions, targetProperty, left, right) {
    

    if (target instanceof InterpolationBinding) {
      this.parent = target;
    } else {
      validateTarget(target, targetProperty);
      this.target = target;
      this.targetProperty = targetProperty;
      this.targetAccessor = observerLocator.getAccessor(target, targetProperty);
    }
    this.observerLocator = observerLocator;
    this.sourceExpression = sourceExpression;
    this.mode = mode;
    this.lookupFunctions = lookupFunctions;
    this.left = left;
    this.right = right;
  }

  ChildInterpolationBinding.prototype.updateTarget = function updateTarget(value) {
    value = value === null || value === undefined ? '' : value.toString();
    if (value !== this.value) {
      this.value = value;
      if (this.parent) {
        this.parent.interpolate();
      } else {
        this.targetAccessor.setValue(this.left + value + this.right, this.target, this.targetProperty);
      }
    }
  };

  ChildInterpolationBinding.prototype.call = function call() {
    if (!this.isBound) {
      return;
    }

    this.rawValue = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
    this.updateTarget(this.rawValue);

    if (this.mode !== _aureliaBinding.bindingMode.oneTime) {
      this._version++;
      this.sourceExpression.connect(this, this.source);
      if (this.rawValue instanceof Array) {
        this.observeArray(this.rawValue);
      }
      this.unobserve(false);
    }
  };

  ChildInterpolationBinding.prototype.bind = function bind(source) {
    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this.source = source;

    var sourceExpression = this.sourceExpression;
    if (sourceExpression.bind) {
      sourceExpression.bind(this, source, this.lookupFunctions);
    }

    this.rawValue = sourceExpression.evaluate(source, this.lookupFunctions);
    this.updateTarget(this.rawValue);

    if (this.mode === _aureliaBinding.bindingMode.oneWay) {
      (0, _aureliaBinding.enqueueBindingConnect)(this);
    }
  };

  ChildInterpolationBinding.prototype.unbind = function unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    var sourceExpression = this.sourceExpression;
    if (sourceExpression.unbind) {
      sourceExpression.unbind(this, this.source);
    }
    this.source = null;
    this.value = null;
    this.rawValue = null;
    this.unobserve(true);
  };

  ChildInterpolationBinding.prototype.connect = function connect(evaluate) {
    if (!this.isBound) {
      return;
    }
    if (evaluate) {
      this.rawValue = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
      this.updateTarget(this.rawValue);
    }
    this.sourceExpression.connect(this, this.source);
    if (this.rawValue instanceof Array) {
      this.observeArray(this.rawValue);
    }
  };

  return ChildInterpolationBinding;
}()) || _class2);
var SyntaxInterpreter = exports.SyntaxInterpreter = (_temp2 = _class3 = function () {
  function SyntaxInterpreter(parser, observerLocator, eventManager, attributeMap) {
    

    this.parser = parser;
    this.observerLocator = observerLocator;
    this.eventManager = eventManager;
    this.attributeMap = attributeMap;
  }

  SyntaxInterpreter.prototype.interpret = function interpret(resources, element, info, existingInstruction, context) {
    if (info.command in this) {
      return this[info.command](resources, element, info, existingInstruction, context);
    }

    return this.handleUnknownCommand(resources, element, info, existingInstruction, context);
  };

  SyntaxInterpreter.prototype.handleUnknownCommand = function handleUnknownCommand(resources, element, info, existingInstruction, context) {
    LogManager.getLogger('templating-binding').warn('Unknown binding command.', info);
    return existingInstruction;
  };

  SyntaxInterpreter.prototype.determineDefaultBindingMode = function determineDefaultBindingMode(element, attrName, context) {
    var tagName = element.tagName.toLowerCase();

    if (tagName === 'input' && (attrName === 'value' || attrName === 'files') && element.type !== 'checkbox' && element.type !== 'radio' || tagName === 'input' && attrName === 'checked' && (element.type === 'checkbox' || element.type === 'radio') || (tagName === 'textarea' || tagName === 'select') && attrName === 'value' || (attrName === 'textcontent' || attrName === 'innerhtml') && element.contentEditable === 'true' || attrName === 'scrolltop' || attrName === 'scrollleft') {
      return _aureliaBinding.bindingMode.twoWay;
    }

    if (context && attrName in context.attributes && context.attributes[attrName] && context.attributes[attrName].defaultBindingMode >= _aureliaBinding.bindingMode.oneTime) {
      return context.attributes[attrName].defaultBindingMode;
    }

    return _aureliaBinding.bindingMode.oneWay;
  };

  SyntaxInterpreter.prototype.bind = function bind(resources, element, info, existingInstruction, context) {
    var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

    instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), info.defaultBindingMode === undefined || info.defaultBindingMode === null ? this.determineDefaultBindingMode(element, info.attrName, context) : info.defaultBindingMode, resources.lookupFunctions);

    return instruction;
  };

  SyntaxInterpreter.prototype.trigger = function trigger(resources, element, info) {
    return new _aureliaBinding.ListenerExpression(this.eventManager, info.attrName, this.parser.parse(info.attrValue), _aureliaBinding.delegationStrategy.none, true, resources.lookupFunctions);
  };

  SyntaxInterpreter.prototype.capture = function capture(resources, element, info) {
    return new _aureliaBinding.ListenerExpression(this.eventManager, info.attrName, this.parser.parse(info.attrValue), _aureliaBinding.delegationStrategy.capturing, true, resources.lookupFunctions);
  };

  SyntaxInterpreter.prototype.delegate = function delegate(resources, element, info) {
    return new _aureliaBinding.ListenerExpression(this.eventManager, info.attrName, this.parser.parse(info.attrValue), _aureliaBinding.delegationStrategy.bubbling, true, resources.lookupFunctions);
  };

  SyntaxInterpreter.prototype.call = function call(resources, element, info, existingInstruction) {
    var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

    instruction.attributes[info.attrName] = new _aureliaBinding.CallExpression(this.observerLocator, info.attrName, this.parser.parse(info.attrValue), resources.lookupFunctions);

    return instruction;
  };

  SyntaxInterpreter.prototype.options = function options(resources, element, info, existingInstruction, context) {
    var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);
    var attrValue = info.attrValue;
    var language = this.language;
    var name = null;
    var target = '';
    var current = void 0;
    var i = void 0;
    var ii = void 0;
    var inString = false;
    var inEscape = false;
    var foundName = false;

    for (i = 0, ii = attrValue.length; i < ii; ++i) {
      current = attrValue[i];

      if (current === ';' && !inString) {
        if (!foundName) {
          name = this._getPrimaryPropertyName(resources, context);
        }
        info = language.inspectAttribute(resources, '?', name, target.trim());
        language.createAttributeInstruction(resources, element, info, instruction, context);

        if (!instruction.attributes[info.attrName]) {
          instruction.attributes[info.attrName] = info.attrValue;
        }

        target = '';
        name = null;
      } else if (current === ':' && name === null) {
        foundName = true;
        name = target.trim();
        target = '';
      } else if (current === '\\') {
        target += current;
        inEscape = true;
        continue;
      } else {
        target += current;

        if (name !== null && inEscape === false && current === '\'') {
          inString = !inString;
        }
      }

      inEscape = false;
    }

    if (!foundName) {
      name = this._getPrimaryPropertyName(resources, context);
    }

    if (name !== null) {
      info = language.inspectAttribute(resources, '?', name, target.trim());
      language.createAttributeInstruction(resources, element, info, instruction, context);

      if (!instruction.attributes[info.attrName]) {
        instruction.attributes[info.attrName] = info.attrValue;
      }
    }

    return instruction;
  };

  SyntaxInterpreter.prototype._getPrimaryPropertyName = function _getPrimaryPropertyName(resources, context) {
    var type = resources.getAttribute(context.attributeName);
    if (type && type.primaryProperty) {
      return type.primaryProperty.attribute;
    }
    return null;
  };

  SyntaxInterpreter.prototype['for'] = function _for(resources, element, info, existingInstruction) {
    var parts = void 0;
    var keyValue = void 0;
    var instruction = void 0;
    var attrValue = void 0;
    var isDestructuring = void 0;

    attrValue = info.attrValue;
    isDestructuring = attrValue.match(/^ *[[].+[\]]/);
    parts = isDestructuring ? attrValue.split('of ') : attrValue.split(' of ');

    if (parts.length !== 2) {
      throw new Error('Incorrect syntax for "for". The form is: "$local of $items" or "[$key, $value] of $items".');
    }

    instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

    if (isDestructuring) {
      keyValue = parts[0].replace(/[[\]]/g, '').replace(/,/g, ' ').replace(/\s+/g, ' ').trim().split(' ');
      instruction.attributes.key = keyValue[0];
      instruction.attributes.value = keyValue[1];
    } else {
      instruction.attributes.local = parts[0];
    }

    instruction.attributes.items = new _aureliaBinding.BindingExpression(this.observerLocator, 'items', this.parser.parse(parts[1]), _aureliaBinding.bindingMode.oneWay, resources.lookupFunctions);

    return instruction;
  };

  SyntaxInterpreter.prototype['two-way'] = function twoWay(resources, element, info, existingInstruction) {
    var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

    instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.twoWay, resources.lookupFunctions);

    return instruction;
  };

  SyntaxInterpreter.prototype['to-view'] = function toView(resources, element, info, existingInstruction) {
    var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

    instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.toView, resources.lookupFunctions);

    return instruction;
  };

  SyntaxInterpreter.prototype['from-view'] = function fromView(resources, element, info, existingInstruction) {
    var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

    instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.fromView, resources.lookupFunctions);

    return instruction;
  };

  SyntaxInterpreter.prototype['one-time'] = function oneTime(resources, element, info, existingInstruction) {
    var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

    instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.oneTime, resources.lookupFunctions);

    return instruction;
  };

  return SyntaxInterpreter;
}(), _class3.inject = [_aureliaBinding.Parser, _aureliaBinding.ObserverLocator, _aureliaBinding.EventManager, AttributeMap], _temp2);


SyntaxInterpreter.prototype['one-way'] = SyntaxInterpreter.prototype['to-view'];

var info = {};

var TemplatingBindingLanguage = exports.TemplatingBindingLanguage = (_temp3 = _class4 = function (_BindingLanguage) {
  _inherits(TemplatingBindingLanguage, _BindingLanguage);

  function TemplatingBindingLanguage(parser, observerLocator, syntaxInterpreter, attributeMap) {
    

    var _this = _possibleConstructorReturn(this, _BindingLanguage.call(this));

    _this.parser = parser;
    _this.observerLocator = observerLocator;
    _this.syntaxInterpreter = syntaxInterpreter;
    _this.emptyStringExpression = _this.parser.parse('\'\'');
    syntaxInterpreter.language = _this;
    _this.attributeMap = attributeMap;
    return _this;
  }

  TemplatingBindingLanguage.prototype.inspectAttribute = function inspectAttribute(resources, elementName, attrName, attrValue) {
    var parts = attrName.split('.');

    info.defaultBindingMode = null;

    if (parts.length === 2) {
      info.attrName = parts[0].trim();
      info.attrValue = attrValue;
      info.command = parts[1].trim();

      if (info.command === 'ref') {
        info.expression = new _aureliaBinding.NameExpression(this.parser.parse(attrValue), info.attrName, resources.lookupFunctions);
        info.command = null;
        info.attrName = 'ref';
      } else {
        info.expression = null;
      }
    } else if (attrName === 'ref') {
      info.attrName = attrName;
      info.attrValue = attrValue;
      info.command = null;
      info.expression = new _aureliaBinding.NameExpression(this.parser.parse(attrValue), 'element', resources.lookupFunctions);
    } else {
      info.attrName = attrName;
      info.attrValue = attrValue;
      info.command = null;
      var interpolationParts = this.parseInterpolation(resources, attrValue);
      if (interpolationParts === null) {
        info.expression = null;
      } else {
        info.expression = new InterpolationBindingExpression(this.observerLocator, this.attributeMap.map(elementName, attrName), interpolationParts, _aureliaBinding.bindingMode.oneWay, resources.lookupFunctions, attrName);
      }
    }

    return info;
  };

  TemplatingBindingLanguage.prototype.createAttributeInstruction = function createAttributeInstruction(resources, element, theInfo, existingInstruction, context) {
    var instruction = void 0;

    if (theInfo.expression) {
      if (theInfo.attrName === 'ref') {
        return theInfo.expression;
      }

      instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(theInfo.attrName);
      instruction.attributes[theInfo.attrName] = theInfo.expression;
    } else if (theInfo.command) {
      instruction = this.syntaxInterpreter.interpret(resources, element, theInfo, existingInstruction, context);
    }

    return instruction;
  };

  TemplatingBindingLanguage.prototype.inspectTextContent = function inspectTextContent(resources, value) {
    var parts = this.parseInterpolation(resources, value);
    if (parts === null) {
      return null;
    }
    return new InterpolationBindingExpression(this.observerLocator, 'textContent', parts, _aureliaBinding.bindingMode.oneWay, resources.lookupFunctions, 'textContent');
  };

  TemplatingBindingLanguage.prototype.parseInterpolation = function parseInterpolation(resources, value) {
    var i = value.indexOf('${', 0);
    var ii = value.length;
    var char = void 0;
    var pos = 0;
    var open = 0;
    var quote = null;
    var interpolationStart = void 0;
    var parts = void 0;
    var partIndex = 0;

    while (i >= 0 && i < ii - 2) {
      open = 1;
      interpolationStart = i;
      i += 2;

      do {
        char = value[i];
        i++;

        if (char === "'" || char === '"') {
          if (quote === null) {
            quote = char;
          } else if (quote === char) {
            quote = null;
          }
          continue;
        }

        if (char === '\\') {
          i++;
          continue;
        }

        if (quote !== null) {
          continue;
        }

        if (char === '{') {
          open++;
        } else if (char === '}') {
          open--;
        }
      } while (open > 0 && i < ii);

      if (open === 0) {
        parts = parts || [];
        if (value[interpolationStart - 1] === '\\' && value[interpolationStart - 2] !== '\\') {
          parts[partIndex] = value.substring(pos, interpolationStart - 1) + value.substring(interpolationStart, i);
          partIndex++;
          parts[partIndex] = this.emptyStringExpression;
          partIndex++;
        } else {
          parts[partIndex] = value.substring(pos, interpolationStart);
          partIndex++;
          parts[partIndex] = this.parser.parse(value.substring(interpolationStart + 2, i - 1));
          partIndex++;
        }
        pos = i;
        i = value.indexOf('${', i);
      } else {
        break;
      }
    }

    if (partIndex === 0) {
      return null;
    }

    parts[partIndex] = value.substr(pos);
    return parts;
  };

  return TemplatingBindingLanguage;
}(_aureliaTemplating.BindingLanguage), _class4.inject = [_aureliaBinding.Parser, _aureliaBinding.ObserverLocator, SyntaxInterpreter, AttributeMap], _temp3);
function configure(config) {
  config.container.registerSingleton(_aureliaTemplating.BindingLanguage, TemplatingBindingLanguage);
  config.container.registerAlias(_aureliaTemplating.BindingLanguage, TemplatingBindingLanguage);
}
});

define('aurelia-templating-resources/dist/commonjs/abstract-repeater',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});



var AbstractRepeater = exports.AbstractRepeater = function () {
  function AbstractRepeater(options) {
    

    Object.assign(this, {
      local: 'items',
      viewsRequireLifecycle: true
    }, options);
  }

  AbstractRepeater.prototype.viewCount = function viewCount() {
    throw new Error('subclass must implement `viewCount`');
  };

  AbstractRepeater.prototype.views = function views() {
    throw new Error('subclass must implement `views`');
  };

  AbstractRepeater.prototype.view = function view(index) {
    throw new Error('subclass must implement `view`');
  };

  AbstractRepeater.prototype.matcher = function matcher() {
    throw new Error('subclass must implement `matcher`');
  };

  AbstractRepeater.prototype.addView = function addView(bindingContext, overrideContext) {
    throw new Error('subclass must implement `addView`');
  };

  AbstractRepeater.prototype.insertView = function insertView(index, bindingContext, overrideContext) {
    throw new Error('subclass must implement `insertView`');
  };

  AbstractRepeater.prototype.moveView = function moveView(sourceIndex, targetIndex) {
    throw new Error('subclass must implement `moveView`');
  };

  AbstractRepeater.prototype.removeAllViews = function removeAllViews(returnToCache, skipAnimation) {
    throw new Error('subclass must implement `removeAllViews`');
  };

  AbstractRepeater.prototype.removeViews = function removeViews(viewsToRemove, returnToCache, skipAnimation) {
    throw new Error('subclass must implement `removeView`');
  };

  AbstractRepeater.prototype.removeView = function removeView(index, returnToCache, skipAnimation) {
    throw new Error('subclass must implement `removeView`');
  };

  AbstractRepeater.prototype.updateBindings = function updateBindings(view) {
    throw new Error('subclass must implement `updateBindings`');
  };

  return AbstractRepeater;
}();
});

define('aurelia-templating-resources/dist/commonjs/analyze-view-factory',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.viewsRequireLifecycle = viewsRequireLifecycle;
var lifecycleOptionalBehaviors = exports.lifecycleOptionalBehaviors = ['focus', 'if', 'else', 'repeat', 'show', 'hide', 'with'];

function behaviorRequiresLifecycle(instruction) {
  var t = instruction.type;
  var name = t.elementName !== null ? t.elementName : t.attributeName;
  return lifecycleOptionalBehaviors.indexOf(name) === -1 && (t.handlesAttached || t.handlesBind || t.handlesCreated || t.handlesDetached || t.handlesUnbind) || t.viewFactory && viewsRequireLifecycle(t.viewFactory) || instruction.viewFactory && viewsRequireLifecycle(instruction.viewFactory);
}

function targetRequiresLifecycle(instruction) {
  var behaviors = instruction.behaviorInstructions;
  if (behaviors) {
    var i = behaviors.length;
    while (i--) {
      if (behaviorRequiresLifecycle(behaviors[i])) {
        return true;
      }
    }
  }

  return instruction.viewFactory && viewsRequireLifecycle(instruction.viewFactory);
}

function viewsRequireLifecycle(viewFactory) {
  if ('_viewsRequireLifecycle' in viewFactory) {
    return viewFactory._viewsRequireLifecycle;
  }

  viewFactory._viewsRequireLifecycle = false;

  if (viewFactory.viewFactory) {
    viewFactory._viewsRequireLifecycle = viewsRequireLifecycle(viewFactory.viewFactory);
    return viewFactory._viewsRequireLifecycle;
  }

  if (viewFactory.template.querySelector('.au-animate')) {
    viewFactory._viewsRequireLifecycle = true;
    return true;
  }

  for (var id in viewFactory.instructions) {
    if (targetRequiresLifecycle(viewFactory.instructions[id])) {
      viewFactory._viewsRequireLifecycle = true;
      return true;
    }
  }

  viewFactory._viewsRequireLifecycle = false;
  return false;
}
});

define('aurelia-templating-resources/dist/commonjs/array-repeat-strategy',['require','exports','module','./repeat-utilities','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayRepeatStrategy = undefined;

var _repeatUtilities = require('./repeat-utilities');

var _aureliaBinding = require('aurelia-binding');



var ArrayRepeatStrategy = exports.ArrayRepeatStrategy = function () {
  function ArrayRepeatStrategy() {
    
  }

  ArrayRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {
    return observerLocator.getArrayObserver(items);
  };

  ArrayRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
    var _this = this;

    var itemsLength = items.length;

    if (!items || itemsLength === 0) {
      repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
      return;
    }

    var children = repeat.views();
    var viewsLength = children.length;

    if (viewsLength === 0) {
      this._standardProcessInstanceChanged(repeat, items);
      return;
    }

    if (repeat.viewsRequireLifecycle) {
      var childrenSnapshot = children.slice(0);
      var itemNameInBindingContext = repeat.local;
      var matcher = repeat.matcher();

      var itemsPreviouslyInViews = [];
      var viewsToRemove = [];

      for (var index = 0; index < viewsLength; index++) {
        var view = childrenSnapshot[index];
        var oldItem = view.bindingContext[itemNameInBindingContext];

        if ((0, _repeatUtilities.indexOf)(items, oldItem, matcher) === -1) {
          viewsToRemove.push(view);
        } else {
          itemsPreviouslyInViews.push(oldItem);
        }
      }

      var updateViews = void 0;
      var removePromise = void 0;

      if (itemsPreviouslyInViews.length > 0) {
        removePromise = repeat.removeViews(viewsToRemove, true, !repeat.viewsRequireLifecycle);
        updateViews = function updateViews() {
          for (var _index = 0; _index < itemsLength; _index++) {
            var item = items[_index];
            var indexOfView = (0, _repeatUtilities.indexOf)(itemsPreviouslyInViews, item, matcher, _index);
            var _view = void 0;

            if (indexOfView === -1) {
              var overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, items[_index], _index, itemsLength);
              repeat.insertView(_index, overrideContext.bindingContext, overrideContext);

              itemsPreviouslyInViews.splice(_index, 0, undefined);
            } else if (indexOfView === _index) {
              _view = children[indexOfView];
              itemsPreviouslyInViews[indexOfView] = undefined;
            } else {
              _view = children[indexOfView];
              repeat.moveView(indexOfView, _index);
              itemsPreviouslyInViews.splice(indexOfView, 1);
              itemsPreviouslyInViews.splice(_index, 0, undefined);
            }

            if (_view) {
              (0, _repeatUtilities.updateOverrideContext)(_view.overrideContext, _index, itemsLength);
            }
          }

          _this._inPlaceProcessItems(repeat, items);
        };
      } else {
        removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
        updateViews = function updateViews() {
          return _this._standardProcessInstanceChanged(repeat, items);
        };
      }

      if (removePromise instanceof Promise) {
        removePromise.then(updateViews);
      } else {
        updateViews();
      }
    } else {
      this._inPlaceProcessItems(repeat, items);
    }
  };

  ArrayRepeatStrategy.prototype._standardProcessInstanceChanged = function _standardProcessInstanceChanged(repeat, items) {
    for (var i = 0, ii = items.length; i < ii; i++) {
      var overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, items[i], i, ii);
      repeat.addView(overrideContext.bindingContext, overrideContext);
    }
  };

  ArrayRepeatStrategy.prototype._inPlaceProcessItems = function _inPlaceProcessItems(repeat, items) {
    var itemsLength = items.length;
    var viewsLength = repeat.viewCount();

    while (viewsLength > itemsLength) {
      viewsLength--;
      repeat.removeView(viewsLength, true, !repeat.viewsRequireLifecycle);
    }

    var local = repeat.local;

    for (var i = 0; i < viewsLength; i++) {
      var view = repeat.view(i);
      var last = i === itemsLength - 1;
      var middle = i !== 0 && !last;

      if (view.bindingContext[local] === items[i] && view.overrideContext.$middle === middle && view.overrideContext.$last === last) {
        continue;
      }

      view.bindingContext[local] = items[i];
      view.overrideContext.$middle = middle;
      view.overrideContext.$last = last;
      repeat.updateBindings(view);
    }

    for (var _i = viewsLength; _i < itemsLength; _i++) {
      var overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, items[_i], _i, itemsLength);
      repeat.addView(overrideContext.bindingContext, overrideContext);
    }
  };

  ArrayRepeatStrategy.prototype.instanceMutated = function instanceMutated(repeat, array, splices) {
    var _this2 = this;

    if (repeat.__queuedSplices) {
      for (var i = 0, ii = splices.length; i < ii; ++i) {
        var _splices$i = splices[i],
            index = _splices$i.index,
            removed = _splices$i.removed,
            addedCount = _splices$i.addedCount;

        (0, _aureliaBinding.mergeSplice)(repeat.__queuedSplices, index, removed, addedCount);
      }

      repeat.__array = array.slice(0);
      return;
    }

    var maybePromise = this._runSplices(repeat, array.slice(0), splices);
    if (maybePromise instanceof Promise) {
      var queuedSplices = repeat.__queuedSplices = [];

      var runQueuedSplices = function runQueuedSplices() {
        if (!queuedSplices.length) {
          repeat.__queuedSplices = undefined;
          repeat.__array = undefined;
          return;
        }

        var nextPromise = _this2._runSplices(repeat, repeat.__array, queuedSplices) || Promise.resolve();
        queuedSplices = repeat.__queuedSplices = [];
        nextPromise.then(runQueuedSplices);
      };

      maybePromise.then(runQueuedSplices);
    }
  };

  ArrayRepeatStrategy.prototype._runSplices = function _runSplices(repeat, array, splices) {
    var _this3 = this;

    var removeDelta = 0;
    var rmPromises = [];

    for (var i = 0, ii = splices.length; i < ii; ++i) {
      var splice = splices[i];
      var removed = splice.removed;

      for (var j = 0, jj = removed.length; j < jj; ++j) {
        var viewOrPromise = repeat.removeView(splice.index + removeDelta + rmPromises.length, true);
        if (viewOrPromise instanceof Promise) {
          rmPromises.push(viewOrPromise);
        }
      }
      removeDelta -= splice.addedCount;
    }

    if (rmPromises.length > 0) {
      return Promise.all(rmPromises).then(function () {
        var spliceIndexLow = _this3._handleAddedSplices(repeat, array, splices);
        (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), spliceIndexLow);
      });
    }

    var spliceIndexLow = this._handleAddedSplices(repeat, array, splices);
    (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), spliceIndexLow);

    return undefined;
  };

  ArrayRepeatStrategy.prototype._handleAddedSplices = function _handleAddedSplices(repeat, array, splices) {
    var spliceIndex = void 0;
    var spliceIndexLow = void 0;
    var arrayLength = array.length;
    for (var i = 0, ii = splices.length; i < ii; ++i) {
      var splice = splices[i];
      var addIndex = spliceIndex = splice.index;
      var end = splice.index + splice.addedCount;

      if (typeof spliceIndexLow === 'undefined' || spliceIndexLow === null || spliceIndexLow > splice.index) {
        spliceIndexLow = spliceIndex;
      }

      for (; addIndex < end; ++addIndex) {
        var overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, array[addIndex], addIndex, arrayLength);
        repeat.insertView(addIndex, overrideContext.bindingContext, overrideContext);
      }
    }

    return spliceIndexLow;
  };

  return ArrayRepeatStrategy;
}();
});

define('aurelia-templating-resources/dist/commonjs/attr-binding-behavior',['require','exports','module','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AttrBindingBehavior = undefined;

var _aureliaBinding = require('aurelia-binding');



var AttrBindingBehavior = exports.AttrBindingBehavior = function () {
  function AttrBindingBehavior() {
    
  }

  AttrBindingBehavior.prototype.bind = function bind(binding, source) {
    binding.targetObserver = new _aureliaBinding.DataAttributeObserver(binding.target, binding.targetProperty);
  };

  AttrBindingBehavior.prototype.unbind = function unbind(binding, source) {};

  return AttrBindingBehavior;
}();
});

define('aurelia-templating-resources/dist/commonjs/aurelia-hide-style',['require','exports','module','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.aureliaHideClassName = undefined;
exports.injectAureliaHideStyleAtHead = injectAureliaHideStyleAtHead;
exports.injectAureliaHideStyleAtBoundary = injectAureliaHideStyleAtBoundary;

var _aureliaPal = require('aurelia-pal');

var aureliaHideClassName = exports.aureliaHideClassName = 'aurelia-hide';

var aureliaHideClass = '.' + aureliaHideClassName + ' { display:none !important; }';

function injectAureliaHideStyleAtHead() {
  _aureliaPal.DOM.injectStyles(aureliaHideClass);
}

function injectAureliaHideStyleAtBoundary(domBoundary) {
  if (_aureliaPal.FEATURE.shadowDOM && domBoundary && !domBoundary.hasAureliaHideStyle) {
    domBoundary.hasAureliaHideStyle = true;
    _aureliaPal.DOM.injectStyles(aureliaHideClass, domBoundary);
  }
}
});

define('aurelia-templating-resources/dist/commonjs/aurelia-templating-resources',['require','exports','module','aurelia-pal','./compose','./if','./else','./with','./repeat','./show','./hide','./sanitize-html','./replaceable','./focus','aurelia-templating','./css-resource','./html-sanitizer','./attr-binding-behavior','./binding-mode-behaviors','./throttle-binding-behavior','./debounce-binding-behavior','./self-binding-behavior','./signal-binding-behavior','./binding-signaler','./update-trigger-binding-behavior','./abstract-repeater','./repeat-strategy-locator','./html-resource-plugin','./null-repeat-strategy','./array-repeat-strategy','./map-repeat-strategy','./set-repeat-strategy','./number-repeat-strategy','./repeat-utilities','./analyze-view-factory','./aurelia-hide-style'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.viewsRequireLifecycle = exports.unwrapExpression = exports.updateOneTimeBinding = exports.isOneTime = exports.getItemsSourceExpression = exports.updateOverrideContext = exports.createFullOverrideContext = exports.NumberRepeatStrategy = exports.SetRepeatStrategy = exports.MapRepeatStrategy = exports.ArrayRepeatStrategy = exports.NullRepeatStrategy = exports.RepeatStrategyLocator = exports.AbstractRepeater = exports.UpdateTriggerBindingBehavior = exports.BindingSignaler = exports.SignalBindingBehavior = exports.SelfBindingBehavior = exports.DebounceBindingBehavior = exports.ThrottleBindingBehavior = exports.TwoWayBindingBehavior = exports.OneWayBindingBehavior = exports.OneTimeBindingBehavior = exports.AttrBindingBehavior = exports.configure = exports.Focus = exports.Replaceable = exports.SanitizeHTMLValueConverter = exports.HTMLSanitizer = exports.Hide = exports.Show = exports.Repeat = exports.With = exports.Else = exports.If = exports.Compose = undefined;

var _aureliaPal = require('aurelia-pal');

var _compose = require('./compose');

var _if = require('./if');

var _else = require('./else');

var _with = require('./with');

var _repeat = require('./repeat');

var _show = require('./show');

var _hide = require('./hide');

var _sanitizeHtml = require('./sanitize-html');

var _replaceable = require('./replaceable');

var _focus = require('./focus');

var _aureliaTemplating = require('aurelia-templating');

var _cssResource = require('./css-resource');

var _htmlSanitizer = require('./html-sanitizer');

var _attrBindingBehavior = require('./attr-binding-behavior');

var _bindingModeBehaviors = require('./binding-mode-behaviors');

var _throttleBindingBehavior = require('./throttle-binding-behavior');

var _debounceBindingBehavior = require('./debounce-binding-behavior');

var _selfBindingBehavior = require('./self-binding-behavior');

var _signalBindingBehavior = require('./signal-binding-behavior');

var _bindingSignaler = require('./binding-signaler');

var _updateTriggerBindingBehavior = require('./update-trigger-binding-behavior');

var _abstractRepeater = require('./abstract-repeater');

var _repeatStrategyLocator = require('./repeat-strategy-locator');

var _htmlResourcePlugin = require('./html-resource-plugin');

var _nullRepeatStrategy = require('./null-repeat-strategy');

var _arrayRepeatStrategy = require('./array-repeat-strategy');

var _mapRepeatStrategy = require('./map-repeat-strategy');

var _setRepeatStrategy = require('./set-repeat-strategy');

var _numberRepeatStrategy = require('./number-repeat-strategy');

var _repeatUtilities = require('./repeat-utilities');

var _analyzeViewFactory = require('./analyze-view-factory');

var _aureliaHideStyle = require('./aurelia-hide-style');

function configure(config) {
  (0, _aureliaHideStyle.injectAureliaHideStyleAtHead)();

  config.globalResources(_aureliaPal.PLATFORM.moduleName('./compose'), _aureliaPal.PLATFORM.moduleName('./if'), _aureliaPal.PLATFORM.moduleName('./else'), _aureliaPal.PLATFORM.moduleName('./with'), _aureliaPal.PLATFORM.moduleName('./repeat'), _aureliaPal.PLATFORM.moduleName('./show'), _aureliaPal.PLATFORM.moduleName('./hide'), _aureliaPal.PLATFORM.moduleName('./replaceable'), _aureliaPal.PLATFORM.moduleName('./sanitize-html'), _aureliaPal.PLATFORM.moduleName('./focus'), _aureliaPal.PLATFORM.moduleName('./binding-mode-behaviors'), _aureliaPal.PLATFORM.moduleName('./self-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./throttle-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./debounce-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./signal-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./update-trigger-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./attr-binding-behavior'));

  (0, _htmlResourcePlugin.configure)(config);

  var viewEngine = config.container.get(_aureliaTemplating.ViewEngine);
  var styleResourcePlugin = {
    fetch: function fetch(address) {
      var _ref;

      return _ref = {}, _ref[address] = (0, _cssResource._createCSSResource)(address), _ref;
    }
  };
  ['.css', '.less', '.sass', '.scss', '.styl'].forEach(function (ext) {
    return viewEngine.addResourcePlugin(ext, styleResourcePlugin);
  });
}

exports.Compose = _compose.Compose;
exports.If = _if.If;
exports.Else = _else.Else;
exports.With = _with.With;
exports.Repeat = _repeat.Repeat;
exports.Show = _show.Show;
exports.Hide = _hide.Hide;
exports.HTMLSanitizer = _htmlSanitizer.HTMLSanitizer;
exports.SanitizeHTMLValueConverter = _sanitizeHtml.SanitizeHTMLValueConverter;
exports.Replaceable = _replaceable.Replaceable;
exports.Focus = _focus.Focus;
exports.configure = configure;
exports.AttrBindingBehavior = _attrBindingBehavior.AttrBindingBehavior;
exports.OneTimeBindingBehavior = _bindingModeBehaviors.OneTimeBindingBehavior;
exports.OneWayBindingBehavior = _bindingModeBehaviors.OneWayBindingBehavior;
exports.TwoWayBindingBehavior = _bindingModeBehaviors.TwoWayBindingBehavior;
exports.ThrottleBindingBehavior = _throttleBindingBehavior.ThrottleBindingBehavior;
exports.DebounceBindingBehavior = _debounceBindingBehavior.DebounceBindingBehavior;
exports.SelfBindingBehavior = _selfBindingBehavior.SelfBindingBehavior;
exports.SignalBindingBehavior = _signalBindingBehavior.SignalBindingBehavior;
exports.BindingSignaler = _bindingSignaler.BindingSignaler;
exports.UpdateTriggerBindingBehavior = _updateTriggerBindingBehavior.UpdateTriggerBindingBehavior;
exports.AbstractRepeater = _abstractRepeater.AbstractRepeater;
exports.RepeatStrategyLocator = _repeatStrategyLocator.RepeatStrategyLocator;
exports.NullRepeatStrategy = _nullRepeatStrategy.NullRepeatStrategy;
exports.ArrayRepeatStrategy = _arrayRepeatStrategy.ArrayRepeatStrategy;
exports.MapRepeatStrategy = _mapRepeatStrategy.MapRepeatStrategy;
exports.SetRepeatStrategy = _setRepeatStrategy.SetRepeatStrategy;
exports.NumberRepeatStrategy = _numberRepeatStrategy.NumberRepeatStrategy;
exports.createFullOverrideContext = _repeatUtilities.createFullOverrideContext;
exports.updateOverrideContext = _repeatUtilities.updateOverrideContext;
exports.getItemsSourceExpression = _repeatUtilities.getItemsSourceExpression;
exports.isOneTime = _repeatUtilities.isOneTime;
exports.updateOneTimeBinding = _repeatUtilities.updateOneTimeBinding;
exports.unwrapExpression = _repeatUtilities.unwrapExpression;
exports.viewsRequireLifecycle = _analyzeViewFactory.viewsRequireLifecycle;
});

define('aurelia-templating-resources/dist/commonjs/binding-mode-behaviors',['require','exports','module','aurelia-binding','aurelia-metadata'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TwoWayBindingBehavior = exports.OneWayBindingBehavior = exports.OneTimeBindingBehavior = undefined;

var _dec, _class, _dec2, _class2, _dec3, _class3;

var _aureliaBinding = require('aurelia-binding');

var _aureliaMetadata = require('aurelia-metadata');



var modeBindingBehavior = {
  bind: function bind(binding, source, lookupFunctions) {
    binding.originalMode = binding.mode;
    binding.mode = this.mode;
  },
  unbind: function unbind(binding, source) {
    binding.mode = binding.originalMode;
    binding.originalMode = null;
  }
};

var OneTimeBindingBehavior = exports.OneTimeBindingBehavior = (_dec = (0, _aureliaMetadata.mixin)(modeBindingBehavior), _dec(_class = function OneTimeBindingBehavior() {
  

  this.mode = _aureliaBinding.bindingMode.oneTime;
}) || _class);
var OneWayBindingBehavior = exports.OneWayBindingBehavior = (_dec2 = (0, _aureliaMetadata.mixin)(modeBindingBehavior), _dec2(_class2 = function OneWayBindingBehavior() {
  

  this.mode = _aureliaBinding.bindingMode.oneWay;
}) || _class2);
var TwoWayBindingBehavior = exports.TwoWayBindingBehavior = (_dec3 = (0, _aureliaMetadata.mixin)(modeBindingBehavior), _dec3(_class3 = function TwoWayBindingBehavior() {
  

  this.mode = _aureliaBinding.bindingMode.twoWay;
}) || _class3);
});

define('aurelia-templating-resources/dist/commonjs/binding-signaler',['require','exports','module','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BindingSignaler = undefined;

var _aureliaBinding = require('aurelia-binding');



var BindingSignaler = exports.BindingSignaler = function () {
  function BindingSignaler() {
    

    this.signals = {};
  }

  BindingSignaler.prototype.signal = function signal(name) {
    var bindings = this.signals[name];
    if (!bindings) {
      return;
    }
    var i = bindings.length;
    while (i--) {
      bindings[i].call(_aureliaBinding.sourceContext);
    }
  };

  return BindingSignaler;
}();
});

define('aurelia-templating-resources/dist/commonjs/compose',['require','exports','module','aurelia-dependency-injection','aurelia-logging','aurelia-task-queue','aurelia-templating','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Compose = undefined;

var _dec, _dec2, _class, _desc, _value, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaLogging = require('aurelia-logging');

var LogManager = _interopRequireWildcard(_aureliaLogging);

var _aureliaTaskQueue = require('aurelia-task-queue');

var _aureliaTemplating = require('aurelia-templating');

var _aureliaPal = require('aurelia-pal');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}



function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var logger = LogManager.getLogger('templating-resources');

var Compose = exports.Compose = (_dec = (0, _aureliaTemplating.customElement)('compose'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element, _aureliaDependencyInjection.Container, _aureliaTemplating.CompositionEngine, _aureliaTemplating.ViewSlot, _aureliaTemplating.ViewResources, _aureliaTaskQueue.TaskQueue), _dec(_class = (0, _aureliaTemplating.noView)(_class = _dec2(_class = (_class2 = function () {
  function Compose(element, container, compositionEngine, viewSlot, viewResources, taskQueue) {
    

    _initDefineProp(this, 'model', _descriptor, this);

    _initDefineProp(this, 'view', _descriptor2, this);

    _initDefineProp(this, 'viewModel', _descriptor3, this);

    _initDefineProp(this, 'swapOrder', _descriptor4, this);

    this.element = element;
    this.container = container;
    this.compositionEngine = compositionEngine;
    this.viewSlot = viewSlot;
    this.viewResources = viewResources;
    this.taskQueue = taskQueue;
    this.currentController = null;
    this.currentViewModel = null;
    this.changes = Object.create(null);
  }

  Compose.prototype.created = function created(owningView) {
    this.owningView = owningView;
  };

  Compose.prototype.bind = function bind(bindingContext, overrideContext) {
    this.bindingContext = bindingContext;
    this.overrideContext = overrideContext;
    this.changes.view = this.view;
    this.changes.viewModel = this.viewModel;
    this.changes.model = this.model;
    processChanges(this);
  };

  Compose.prototype.unbind = function unbind() {
    this.changes = Object.create(null);
    this.pendingTask = null;
    this.bindingContext = null;
    this.overrideContext = null;
    var returnToCache = true;
    var skipAnimation = true;
    this.viewSlot.removeAll(returnToCache, skipAnimation);
  };

  Compose.prototype.modelChanged = function modelChanged(newValue, oldValue) {
    this.changes.model = newValue;
    requestUpdate(this);
  };

  Compose.prototype.viewChanged = function viewChanged(newValue, oldValue) {
    this.changes.view = newValue;
    requestUpdate(this);
  };

  Compose.prototype.viewModelChanged = function viewModelChanged(newValue, oldValue) {
    this.changes.viewModel = newValue;
    requestUpdate(this);
  };

  return Compose;
}(), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'model', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'view', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, 'viewModel', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, 'swapOrder', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
})), _class2)) || _class) || _class) || _class);


function isEmpty(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
}

function tryActivateViewModel(vm, model) {
  if (vm && typeof vm.activate === 'function') {
    return Promise.resolve(vm.activate(model));
  }
}

function createInstruction(composer, instruction) {
  return Object.assign(instruction, {
    bindingContext: composer.bindingContext,
    overrideContext: composer.overrideContext,
    owningView: composer.owningView,
    container: composer.container,
    viewSlot: composer.viewSlot,
    viewResources: composer.viewResources,
    currentController: composer.currentController,
    host: composer.element,
    swapOrder: composer.swapOrder
  });
}

function processChanges(composer) {
  var changes = composer.changes;
  composer.changes = Object.create(null);

  if (!('view' in changes) && !('viewModel' in changes) && 'model' in changes) {
    composer.pendingTask = tryActivateViewModel(composer.currentViewModel, changes.model);
    if (!composer.pendingTask) {
      return;
    }
  } else {
    var instruction = {
      view: composer.view,
      viewModel: composer.currentViewModel || composer.viewModel,
      model: composer.model
    };

    instruction = Object.assign(instruction, changes);

    instruction = createInstruction(composer, instruction);
    composer.pendingTask = composer.compositionEngine.compose(instruction).then(function (controller) {
      composer.currentController = controller;
      composer.currentViewModel = controller ? controller.viewModel : null;
    });
  }

  composer.pendingTask = composer.pendingTask.catch(function (e) {
    logger.error(e);
  }).then(function () {
    if (!composer.pendingTask) {
      return;
    }

    composer.pendingTask = null;
    if (!isEmpty(composer.changes)) {
      processChanges(composer);
    }
  });
}

function requestUpdate(composer) {
  if (composer.pendingTask || composer.updateRequested) {
    return;
  }
  composer.updateRequested = true;
  composer.taskQueue.queueMicroTask(function () {
    composer.updateRequested = false;
    processChanges(composer);
  });
}
});

define('aurelia-templating-resources/dist/commonjs/css-resource',['require','exports','module','aurelia-templating','aurelia-loader','aurelia-dependency-injection','aurelia-path','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._createCSSResource = _createCSSResource;

var _aureliaTemplating = require('aurelia-templating');

var _aureliaLoader = require('aurelia-loader');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaPath = require('aurelia-path');

var _aureliaPal = require('aurelia-pal');

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var cssUrlMatcher = /url\((?!['"]data)([^)]+)\)/gi;

function fixupCSSUrls(address, css) {
  if (typeof css !== 'string') {
    throw new Error('Failed loading required CSS file: ' + address);
  }
  return css.replace(cssUrlMatcher, function (match, p1) {
    var quote = p1.charAt(0);
    if (quote === '\'' || quote === '"') {
      p1 = p1.substr(1, p1.length - 2);
    }
    return 'url(\'' + (0, _aureliaPath.relativeToFile)(p1, address) + '\')';
  });
}

var CSSResource = function () {
  function CSSResource(address) {
    

    this.address = address;
    this._scoped = null;
    this._global = false;
    this._alreadyGloballyInjected = false;
  }

  CSSResource.prototype.initialize = function initialize(container, target) {
    this._scoped = new target(this);
  };

  CSSResource.prototype.register = function register(registry, name) {
    if (name === 'scoped') {
      registry.registerViewEngineHooks(this._scoped);
    } else {
      this._global = true;
    }
  };

  CSSResource.prototype.load = function load(container) {
    var _this = this;

    return container.get(_aureliaLoader.Loader).loadText(this.address).catch(function (err) {
      return null;
    }).then(function (text) {
      text = fixupCSSUrls(_this.address, text);
      _this._scoped.css = text;
      if (_this._global) {
        _this._alreadyGloballyInjected = true;
        _aureliaPal.DOM.injectStyles(text);
      }
    });
  };

  return CSSResource;
}();

var CSSViewEngineHooks = function () {
  function CSSViewEngineHooks(owner) {
    

    this.owner = owner;
    this.css = null;
  }

  CSSViewEngineHooks.prototype.beforeCompile = function beforeCompile(content, resources, instruction) {
    if (instruction.targetShadowDOM) {
      _aureliaPal.DOM.injectStyles(this.css, content, true);
    } else if (_aureliaPal.FEATURE.scopedCSS) {
      var styleNode = _aureliaPal.DOM.injectStyles(this.css, content, true);
      styleNode.setAttribute('scoped', 'scoped');
    } else if (this._global && !this.owner._alreadyGloballyInjected) {
      _aureliaPal.DOM.injectStyles(this.css);
      this.owner._alreadyGloballyInjected = true;
    }
  };

  return CSSViewEngineHooks;
}();

function _createCSSResource(address) {
  var _dec, _class;

  var ViewCSS = (_dec = (0, _aureliaTemplating.resource)(new CSSResource(address)), _dec(_class = function (_CSSViewEngineHooks) {
    _inherits(ViewCSS, _CSSViewEngineHooks);

    function ViewCSS() {
      

      return _possibleConstructorReturn(this, _CSSViewEngineHooks.apply(this, arguments));
    }

    return ViewCSS;
  }(CSSViewEngineHooks)) || _class);

  return ViewCSS;
}
});

define('aurelia-templating-resources/dist/commonjs/debounce-binding-behavior',['require','exports','module','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebounceBindingBehavior = undefined;

var _aureliaBinding = require('aurelia-binding');



var unset = {};

function debounceCallSource(event) {
  var _this = this;

  var state = this.debounceState;
  clearTimeout(state.timeoutId);
  state.timeoutId = setTimeout(function () {
    return _this.debouncedMethod(event);
  }, state.delay);
}

function debounceCall(context, newValue, oldValue) {
  var _this2 = this;

  var state = this.debounceState;
  clearTimeout(state.timeoutId);
  if (context !== state.callContextToDebounce) {
    state.oldValue = unset;
    this.debouncedMethod(context, newValue, oldValue);
    return;
  }
  if (state.oldValue === unset) {
    state.oldValue = oldValue;
  }
  state.timeoutId = setTimeout(function () {
    var ov = state.oldValue;
    state.oldValue = unset;
    _this2.debouncedMethod(context, newValue, ov);
  }, state.delay);
}

var DebounceBindingBehavior = exports.DebounceBindingBehavior = function () {
  function DebounceBindingBehavior() {
    
  }

  DebounceBindingBehavior.prototype.bind = function bind(binding, source) {
    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;

    var isCallSource = binding.callSource !== undefined;
    var methodToDebounce = isCallSource ? 'callSource' : 'call';
    var debouncer = isCallSource ? debounceCallSource : debounceCall;
    var mode = binding.mode;
    var callContextToDebounce = mode === _aureliaBinding.bindingMode.twoWay || mode === _aureliaBinding.bindingMode.fromView ? _aureliaBinding.targetContext : _aureliaBinding.sourceContext;

    binding.debouncedMethod = binding[methodToDebounce];
    binding.debouncedMethod.originalName = methodToDebounce;

    binding[methodToDebounce] = debouncer;

    binding.debounceState = {
      callContextToDebounce: callContextToDebounce,
      delay: delay,
      timeoutId: 0,
      oldValue: unset
    };
  };

  DebounceBindingBehavior.prototype.unbind = function unbind(binding, source) {
    var methodToRestore = binding.debouncedMethod.originalName;
    binding[methodToRestore] = binding.debouncedMethod;
    binding.debouncedMethod = null;
    clearTimeout(binding.debounceState.timeoutId);
    binding.debounceState = null;
  };

  return DebounceBindingBehavior;
}();
});

define('aurelia-templating-resources/dist/commonjs/dynamic-element',['require','exports','module','aurelia-templating'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._createDynamicElement = _createDynamicElement;

var _aureliaTemplating = require('aurelia-templating');



function _createDynamicElement(name, viewUrl, bindableNames) {
  var _dec, _dec2, _class;

  var DynamicElement = (_dec = (0, _aureliaTemplating.customElement)(name), _dec2 = (0, _aureliaTemplating.useView)(viewUrl), _dec(_class = _dec2(_class = function () {
    function DynamicElement() {
      
    }

    DynamicElement.prototype.bind = function bind(bindingContext) {
      this.$parent = bindingContext;
    };

    return DynamicElement;
  }()) || _class) || _class);

  for (var i = 0, ii = bindableNames.length; i < ii; ++i) {
    (0, _aureliaTemplating.bindable)(bindableNames[i])(DynamicElement);
  }
  return DynamicElement;
}
});

define('aurelia-templating-resources/dist/commonjs/else',['require','exports','module','aurelia-templating','aurelia-dependency-injection','./if-core'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Else = undefined;

var _dec, _dec2, _class;

var _aureliaTemplating = require('aurelia-templating');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _ifCore = require('./if-core');



function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Else = exports.Else = (_dec = (0, _aureliaTemplating.customAttribute)('else'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = function (_IfCore) {
  _inherits(Else, _IfCore);

  function Else(viewFactory, viewSlot) {
    

    var _this = _possibleConstructorReturn(this, _IfCore.call(this, viewFactory, viewSlot));

    _this._registerInIf();
    return _this;
  }

  Else.prototype.bind = function bind(bindingContext, overrideContext) {
    _IfCore.prototype.bind.call(this, bindingContext, overrideContext);

    if (this.ifVm.condition) {
      this._hide();
    } else {
      this._show();
    }
  };

  Else.prototype._registerInIf = function _registerInIf() {
    var previous = this.viewSlot.anchor.previousSibling;
    while (previous && !previous.au) {
      previous = previous.previousSibling;
    }
    if (!previous || !previous.au.if) {
      throw new Error("Can't find matching If for Else custom attribute.");
    }
    this.ifVm = previous.au.if.viewModel;
    this.ifVm.elseVm = this;
  };

  return Else;
}(_ifCore.IfCore)) || _class) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/focus',['require','exports','module','aurelia-templating','aurelia-binding','aurelia-dependency-injection','aurelia-task-queue','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Focus = undefined;

var _dec, _dec2, _class;

var _aureliaTemplating = require('aurelia-templating');

var _aureliaBinding = require('aurelia-binding');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaTaskQueue = require('aurelia-task-queue');

var _aureliaPal = require('aurelia-pal');



var Focus = exports.Focus = (_dec = (0, _aureliaTemplating.customAttribute)('focus', _aureliaBinding.bindingMode.twoWay), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element, _aureliaTaskQueue.TaskQueue), _dec(_class = _dec2(_class = function () {
  function Focus(element, taskQueue) {
    

    this.element = element;
    this.taskQueue = taskQueue;
    this.isAttached = false;
    this.needsApply = false;
  }

  Focus.prototype.valueChanged = function valueChanged(newValue) {
    if (this.isAttached) {
      this._apply();
    } else {
      this.needsApply = true;
    }
  };

  Focus.prototype._apply = function _apply() {
    var _this = this;

    if (this.value) {
      this.taskQueue.queueMicroTask(function () {
        if (_this.value) {
          _this.element.focus();
        }
      });
    } else {
      this.element.blur();
    }
  };

  Focus.prototype.attached = function attached() {
    this.isAttached = true;
    if (this.needsApply) {
      this.needsApply = false;
      this._apply();
    }
    this.element.addEventListener('focus', this);
    this.element.addEventListener('blur', this);
  };

  Focus.prototype.detached = function detached() {
    this.isAttached = false;
    this.element.removeEventListener('focus', this);
    this.element.removeEventListener('blur', this);
  };

  Focus.prototype.handleEvent = function handleEvent(e) {
    if (e.type === 'focus') {
      this.value = true;
    } else if (_aureliaPal.DOM.activeElement !== this.element) {
      this.value = false;
    }
  };

  return Focus;
}()) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/hide',['require','exports','module','aurelia-dependency-injection','aurelia-templating','aurelia-pal','./aurelia-hide-style'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Hide = undefined;

var _dec, _dec2, _class;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaTemplating = require('aurelia-templating');

var _aureliaPal = require('aurelia-pal');

var _aureliaHideStyle = require('./aurelia-hide-style');



var Hide = exports.Hide = (_dec = (0, _aureliaTemplating.customAttribute)('hide'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element, _aureliaTemplating.Animator, _aureliaDependencyInjection.Optional.of(_aureliaPal.DOM.boundary, true)), _dec(_class = _dec2(_class = function () {
  function Hide(element, animator, domBoundary) {
    

    this.element = element;
    this.animator = animator;
    this.domBoundary = domBoundary;
  }

  Hide.prototype.created = function created() {
    (0, _aureliaHideStyle.injectAureliaHideStyleAtBoundary)(this.domBoundary);
  };

  Hide.prototype.valueChanged = function valueChanged(newValue) {
    if (newValue) {
      this.animator.addClass(this.element, _aureliaHideStyle.aureliaHideClassName);
    } else {
      this.animator.removeClass(this.element, _aureliaHideStyle.aureliaHideClassName);
    }
  };

  Hide.prototype.bind = function bind(bindingContext) {
    this.valueChanged(this.value);
  };

  return Hide;
}()) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/html-resource-plugin',['require','exports','module','aurelia-templating','./dynamic-element'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getElementName = getElementName;
exports.configure = configure;

var _aureliaTemplating = require('aurelia-templating');

var _dynamicElement = require('./dynamic-element');

function getElementName(address) {
  return (/([^\/^\?]+)\.html/i.exec(address)[1].toLowerCase()
  );
}

function configure(config) {
  var viewEngine = config.container.get(_aureliaTemplating.ViewEngine);
  var loader = config.aurelia.loader;

  viewEngine.addResourcePlugin('.html', {
    'fetch': function fetch(address) {
      return loader.loadTemplate(address).then(function (registryEntry) {
        var _ref;

        var bindable = registryEntry.template.getAttribute('bindable');
        var elementName = getElementName(address);

        if (bindable) {
          bindable = bindable.split(',').map(function (x) {
            return x.trim();
          });
          registryEntry.template.removeAttribute('bindable');
        } else {
          bindable = [];
        }

        return _ref = {}, _ref[elementName] = (0, _dynamicElement._createDynamicElement)(elementName, address, bindable), _ref;
      });
    }
  });
}
});

define('aurelia-templating-resources/dist/commonjs/html-sanitizer',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});



var SCRIPT_REGEX = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;

var HTMLSanitizer = exports.HTMLSanitizer = function () {
  function HTMLSanitizer() {
    
  }

  HTMLSanitizer.prototype.sanitize = function sanitize(input) {
    return input.replace(SCRIPT_REGEX, '');
  };

  return HTMLSanitizer;
}();
});

define('aurelia-templating-resources/dist/commonjs/if',['require','exports','module','aurelia-templating','aurelia-dependency-injection','./if-core'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.If = undefined;

var _dec, _dec2, _dec3, _class, _desc, _value, _class2, _descriptor, _descriptor2;

var _aureliaTemplating = require('aurelia-templating');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _ifCore = require('./if-core');

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}



function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var If = exports.If = (_dec = (0, _aureliaTemplating.customAttribute)('if'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot), _dec3 = (0, _aureliaTemplating.bindable)({ primaryProperty: true }), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = (_class2 = function (_IfCore) {
  _inherits(If, _IfCore);

  function If() {
    var _temp, _this, _ret;

    

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _IfCore.call.apply(_IfCore, [this].concat(args))), _this), _initDefineProp(_this, 'condition', _descriptor, _this), _initDefineProp(_this, 'swapOrder', _descriptor2, _this), _temp), _possibleConstructorReturn(_this, _ret);
  }

  If.prototype.bind = function bind(bindingContext, overrideContext) {
    _IfCore.prototype.bind.call(this, bindingContext, overrideContext);
    if (this.condition) {
      this._show();
    } else {
      this._hide();
    }
  };

  If.prototype.conditionChanged = function conditionChanged(newValue) {
    this._update(newValue);
  };

  If.prototype._update = function _update(show) {
    var _this2 = this;

    if (this.animating) {
      return;
    }

    var promise = void 0;
    if (this.elseVm) {
      promise = show ? this._swap(this.elseVm, this) : this._swap(this, this.elseVm);
    } else {
      promise = show ? this._show() : this._hide();
    }

    if (promise) {
      this.animating = true;
      promise.then(function () {
        _this2.animating = false;
        if (_this2.condition !== _this2.showing) {
          _this2._update(_this2.condition);
        }
      });
    }
  };

  If.prototype._swap = function _swap(remove, add) {
    switch (this.swapOrder) {
      case 'before':
        return Promise.resolve(add._show()).then(function () {
          return remove._hide();
        });
      case 'with':
        return Promise.all([remove._hide(), add._show()]);
      default:
        var promise = remove._hide();
        return promise ? promise.then(function () {
          return add._show();
        }) : add._show();
    }
  };

  return If;
}(_ifCore.IfCore), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'condition', [_dec3], {
  enumerable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'swapOrder', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
})), _class2)) || _class) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/if-core',['require','exports','module'],function (require, exports, module) {"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});



var IfCore = exports.IfCore = function () {
  function IfCore(viewFactory, viewSlot) {
    

    this.viewFactory = viewFactory;
    this.viewSlot = viewSlot;
    this.view = null;
    this.bindingContext = null;
    this.overrideContext = null;

    this.showing = false;
  }

  IfCore.prototype.bind = function bind(bindingContext, overrideContext) {
    this.bindingContext = bindingContext;
    this.overrideContext = overrideContext;
  };

  IfCore.prototype.unbind = function unbind() {
    if (this.view === null) {
      return;
    }

    this.view.unbind();

    if (!this.viewFactory.isCaching) {
      return;
    }

    if (this.showing) {
      this.showing = false;
      this.viewSlot.remove(this.view, true, true);
    } else {
      this.view.returnToCache();
    }

    this.view = null;
  };

  IfCore.prototype._show = function _show() {
    if (this.showing) {
      if (!this.view.isBound) {
        this.view.bind(this.bindingContext, this.overrideContext);
      }
      return;
    }

    if (this.view === null) {
      this.view = this.viewFactory.create();
    }

    if (!this.view.isBound) {
      this.view.bind(this.bindingContext, this.overrideContext);
    }

    this.showing = true;
    return this.viewSlot.add(this.view);
  };

  IfCore.prototype._hide = function _hide() {
    var _this = this;

    if (!this.showing) {
      return;
    }

    this.showing = false;
    var removed = this.viewSlot.remove(this.view);

    if (removed instanceof Promise) {
      return removed.then(function () {
        return _this.view.unbind();
      });
    }

    this.view.unbind();
  };

  return IfCore;
}();
});

define('aurelia-templating-resources/dist/commonjs/map-repeat-strategy',['require','exports','module','./repeat-utilities'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MapRepeatStrategy = undefined;

var _repeatUtilities = require('./repeat-utilities');



var MapRepeatStrategy = exports.MapRepeatStrategy = function () {
  function MapRepeatStrategy() {
    
  }

  MapRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {
    return observerLocator.getMapObserver(items);
  };

  MapRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
    var _this = this;

    var removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
    if (removePromise instanceof Promise) {
      removePromise.then(function () {
        return _this._standardProcessItems(repeat, items);
      });
      return;
    }
    this._standardProcessItems(repeat, items);
  };

  MapRepeatStrategy.prototype._standardProcessItems = function _standardProcessItems(repeat, items) {
    var index = 0;
    var overrideContext = void 0;

    items.forEach(function (value, key) {
      overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, value, index, items.size, key);
      repeat.addView(overrideContext.bindingContext, overrideContext);
      ++index;
    });
  };

  MapRepeatStrategy.prototype.instanceMutated = function instanceMutated(repeat, map, records) {
    var key = void 0;
    var i = void 0;
    var ii = void 0;
    var overrideContext = void 0;
    var removeIndex = void 0;
    var addIndex = void 0;
    var record = void 0;
    var rmPromises = [];
    var viewOrPromise = void 0;

    for (i = 0, ii = records.length; i < ii; ++i) {
      record = records[i];
      key = record.key;
      switch (record.type) {
        case 'update':
          removeIndex = this._getViewIndexByKey(repeat, key);
          viewOrPromise = repeat.removeView(removeIndex, true, !repeat.viewsRequireLifecycle);
          if (viewOrPromise instanceof Promise) {
            rmPromises.push(viewOrPromise);
          }
          overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, map.get(key), removeIndex, map.size, key);
          repeat.insertView(removeIndex, overrideContext.bindingContext, overrideContext);
          break;
        case 'add':
          addIndex = repeat.viewCount() <= map.size - 1 ? repeat.viewCount() : map.size - 1;
          overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, map.get(key), addIndex, map.size, key);
          repeat.insertView(map.size - 1, overrideContext.bindingContext, overrideContext);
          break;
        case 'delete':
          if (record.oldValue === undefined) {
            return;
          }
          removeIndex = this._getViewIndexByKey(repeat, key);
          viewOrPromise = repeat.removeView(removeIndex, true, !repeat.viewsRequireLifecycle);
          if (viewOrPromise instanceof Promise) {
            rmPromises.push(viewOrPromise);
          }
          break;
        case 'clear':
          repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
          break;
        default:
          continue;
      }
    }

    if (rmPromises.length > 0) {
      Promise.all(rmPromises).then(function () {
        (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
      });
    } else {
      (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
    }
  };

  MapRepeatStrategy.prototype._getViewIndexByKey = function _getViewIndexByKey(repeat, key) {
    var i = void 0;
    var ii = void 0;
    var child = void 0;

    for (i = 0, ii = repeat.viewCount(); i < ii; ++i) {
      child = repeat.view(i);
      if (child.bindingContext[repeat.key] === key) {
        return i;
      }
    }

    return undefined;
  };

  return MapRepeatStrategy;
}();
});

define('aurelia-templating-resources/dist/commonjs/null-repeat-strategy',['require','exports','module'],function (require, exports, module) {"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});



var NullRepeatStrategy = exports.NullRepeatStrategy = function () {
  function NullRepeatStrategy() {
    
  }

  NullRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
    repeat.removeAllViews(true);
  };

  NullRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {};

  return NullRepeatStrategy;
}();
});

define('aurelia-templating-resources/dist/commonjs/number-repeat-strategy',['require','exports','module','./repeat-utilities'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NumberRepeatStrategy = undefined;

var _repeatUtilities = require('./repeat-utilities');



var NumberRepeatStrategy = exports.NumberRepeatStrategy = function () {
  function NumberRepeatStrategy() {
    
  }

  NumberRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver() {
    return null;
  };

  NumberRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, value) {
    var _this = this;

    var removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
    if (removePromise instanceof Promise) {
      removePromise.then(function () {
        return _this._standardProcessItems(repeat, value);
      });
      return;
    }
    this._standardProcessItems(repeat, value);
  };

  NumberRepeatStrategy.prototype._standardProcessItems = function _standardProcessItems(repeat, value) {
    var childrenLength = repeat.viewCount();
    var i = void 0;
    var ii = void 0;
    var overrideContext = void 0;
    var viewsToRemove = void 0;

    value = Math.floor(value);
    viewsToRemove = childrenLength - value;

    if (viewsToRemove > 0) {
      if (viewsToRemove > childrenLength) {
        viewsToRemove = childrenLength;
      }

      for (i = 0, ii = viewsToRemove; i < ii; ++i) {
        repeat.removeView(childrenLength - (i + 1), true, !repeat.viewsRequireLifecycle);
      }

      return;
    }

    for (i = childrenLength, ii = value; i < ii; ++i) {
      overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, i, i, ii);
      repeat.addView(overrideContext.bindingContext, overrideContext);
    }

    (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
  };

  return NumberRepeatStrategy;
}();
});

define('aurelia-templating-resources/dist/commonjs/repeat',['require','exports','module','aurelia-dependency-injection','aurelia-binding','aurelia-templating','./repeat-strategy-locator','./repeat-utilities','./analyze-view-factory','./abstract-repeater'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Repeat = undefined;

var _dec, _dec2, _class, _desc, _value, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaBinding = require('aurelia-binding');

var _aureliaTemplating = require('aurelia-templating');

var _repeatStrategyLocator = require('./repeat-strategy-locator');

var _repeatUtilities = require('./repeat-utilities');

var _analyzeViewFactory = require('./analyze-view-factory');

var _abstractRepeater = require('./abstract-repeater');

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}



function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var Repeat = exports.Repeat = (_dec = (0, _aureliaTemplating.customAttribute)('repeat'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.TargetInstruction, _aureliaTemplating.ViewSlot, _aureliaTemplating.ViewResources, _aureliaBinding.ObserverLocator, _repeatStrategyLocator.RepeatStrategyLocator), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = (_class2 = function (_AbstractRepeater) {
  _inherits(Repeat, _AbstractRepeater);

  function Repeat(viewFactory, instruction, viewSlot, viewResources, observerLocator, strategyLocator) {
    

    var _this = _possibleConstructorReturn(this, _AbstractRepeater.call(this, {
      local: 'item',
      viewsRequireLifecycle: (0, _analyzeViewFactory.viewsRequireLifecycle)(viewFactory)
    }));

    _initDefineProp(_this, 'items', _descriptor, _this);

    _initDefineProp(_this, 'local', _descriptor2, _this);

    _initDefineProp(_this, 'key', _descriptor3, _this);

    _initDefineProp(_this, 'value', _descriptor4, _this);

    _this.viewFactory = viewFactory;
    _this.instruction = instruction;
    _this.viewSlot = viewSlot;
    _this.lookupFunctions = viewResources.lookupFunctions;
    _this.observerLocator = observerLocator;
    _this.key = 'key';
    _this.value = 'value';
    _this.strategyLocator = strategyLocator;
    _this.ignoreMutation = false;
    _this.sourceExpression = (0, _repeatUtilities.getItemsSourceExpression)(_this.instruction, 'repeat.for');
    _this.isOneTime = (0, _repeatUtilities.isOneTime)(_this.sourceExpression);
    _this.viewsRequireLifecycle = (0, _analyzeViewFactory.viewsRequireLifecycle)(viewFactory);
    return _this;
  }

  Repeat.prototype.call = function call(context, changes) {
    this[context](this.items, changes);
  };

  Repeat.prototype.bind = function bind(bindingContext, overrideContext) {
    this.scope = { bindingContext: bindingContext, overrideContext: overrideContext };
    this.matcherBinding = this._captureAndRemoveMatcherBinding();
    this.itemsChanged();
  };

  Repeat.prototype.unbind = function unbind() {
    this.scope = null;
    this.items = null;
    this.matcherBinding = null;
    this.viewSlot.removeAll(true, true);
    this._unsubscribeCollection();
  };

  Repeat.prototype._unsubscribeCollection = function _unsubscribeCollection() {
    if (this.collectionObserver) {
      this.collectionObserver.unsubscribe(this.callContext, this);
      this.collectionObserver = null;
      this.callContext = null;
    }
  };

  Repeat.prototype.itemsChanged = function itemsChanged() {
    this._unsubscribeCollection();

    if (!this.scope) {
      return;
    }

    var items = this.items;
    this.strategy = this.strategyLocator.getStrategy(items);
    if (!this.strategy) {
      throw new Error('Value for \'' + this.sourceExpression + '\' is non-repeatable');
    }

    if (!this.isOneTime && !this._observeInnerCollection()) {
      this._observeCollection();
    }
    this.strategy.instanceChanged(this, items);
  };

  Repeat.prototype._getInnerCollection = function _getInnerCollection() {
    var expression = (0, _repeatUtilities.unwrapExpression)(this.sourceExpression);
    if (!expression) {
      return null;
    }
    return expression.evaluate(this.scope, null);
  };

  Repeat.prototype.handleCollectionMutated = function handleCollectionMutated(collection, changes) {
    if (!this.collectionObserver) {
      return;
    }
    this.strategy.instanceMutated(this, collection, changes);
  };

  Repeat.prototype.handleInnerCollectionMutated = function handleInnerCollectionMutated(collection, changes) {
    var _this2 = this;

    if (!this.collectionObserver) {
      return;
    }

    if (this.ignoreMutation) {
      return;
    }
    this.ignoreMutation = true;
    var newItems = this.sourceExpression.evaluate(this.scope, this.lookupFunctions);
    this.observerLocator.taskQueue.queueMicroTask(function () {
      return _this2.ignoreMutation = false;
    });

    if (newItems === this.items) {
      this.itemsChanged();
    } else {
      this.items = newItems;
    }
  };

  Repeat.prototype._observeInnerCollection = function _observeInnerCollection() {
    var items = this._getInnerCollection();
    var strategy = this.strategyLocator.getStrategy(items);
    if (!strategy) {
      return false;
    }
    this.collectionObserver = strategy.getCollectionObserver(this.observerLocator, items);
    if (!this.collectionObserver) {
      return false;
    }
    this.callContext = 'handleInnerCollectionMutated';
    this.collectionObserver.subscribe(this.callContext, this);
    return true;
  };

  Repeat.prototype._observeCollection = function _observeCollection() {
    var items = this.items;
    this.collectionObserver = this.strategy.getCollectionObserver(this.observerLocator, items);
    if (this.collectionObserver) {
      this.callContext = 'handleCollectionMutated';
      this.collectionObserver.subscribe(this.callContext, this);
    }
  };

  Repeat.prototype._captureAndRemoveMatcherBinding = function _captureAndRemoveMatcherBinding() {
    if (this.viewFactory.viewFactory) {
      var instructions = this.viewFactory.viewFactory.instructions;
      var instructionIds = Object.keys(instructions);
      for (var i = 0; i < instructionIds.length; i++) {
        var expressions = instructions[instructionIds[i]].expressions;
        if (expressions) {
          for (var ii = 0; i < expressions.length; i++) {
            if (expressions[ii].targetProperty === 'matcher') {
              var matcherBinding = expressions[ii];
              expressions.splice(ii, 1);
              return matcherBinding;
            }
          }
        }
      }
    }

    return undefined;
  };

  Repeat.prototype.viewCount = function viewCount() {
    return this.viewSlot.children.length;
  };

  Repeat.prototype.views = function views() {
    return this.viewSlot.children;
  };

  Repeat.prototype.view = function view(index) {
    return this.viewSlot.children[index];
  };

  Repeat.prototype.matcher = function matcher() {
    return this.matcherBinding ? this.matcherBinding.sourceExpression.evaluate(this.scope, this.matcherBinding.lookupFunctions) : null;
  };

  Repeat.prototype.addView = function addView(bindingContext, overrideContext) {
    var view = this.viewFactory.create();
    view.bind(bindingContext, overrideContext);
    this.viewSlot.add(view);
  };

  Repeat.prototype.insertView = function insertView(index, bindingContext, overrideContext) {
    var view = this.viewFactory.create();
    view.bind(bindingContext, overrideContext);
    this.viewSlot.insert(index, view);
  };

  Repeat.prototype.moveView = function moveView(sourceIndex, targetIndex) {
    this.viewSlot.move(sourceIndex, targetIndex);
  };

  Repeat.prototype.removeAllViews = function removeAllViews(returnToCache, skipAnimation) {
    return this.viewSlot.removeAll(returnToCache, skipAnimation);
  };

  Repeat.prototype.removeViews = function removeViews(viewsToRemove, returnToCache, skipAnimation) {
    return this.viewSlot.removeMany(viewsToRemove, returnToCache, skipAnimation);
  };

  Repeat.prototype.removeView = function removeView(index, returnToCache, skipAnimation) {
    return this.viewSlot.removeAt(index, returnToCache, skipAnimation);
  };

  Repeat.prototype.updateBindings = function updateBindings(view) {
    var j = view.bindings.length;
    while (j--) {
      (0, _repeatUtilities.updateOneTimeBinding)(view.bindings[j]);
    }
    j = view.controllers.length;
    while (j--) {
      var k = view.controllers[j].boundProperties.length;
      while (k--) {
        var binding = view.controllers[j].boundProperties[k].binding;
        (0, _repeatUtilities.updateOneTimeBinding)(binding);
      }
    }
  };

  return Repeat;
}(_abstractRepeater.AbstractRepeater), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'items', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'local', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, 'key', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, 'value', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
})), _class2)) || _class) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/repeat-strategy-locator',['require','exports','module','./null-repeat-strategy','./array-repeat-strategy','./map-repeat-strategy','./set-repeat-strategy','./number-repeat-strategy'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RepeatStrategyLocator = undefined;

var _nullRepeatStrategy = require('./null-repeat-strategy');

var _arrayRepeatStrategy = require('./array-repeat-strategy');

var _mapRepeatStrategy = require('./map-repeat-strategy');

var _setRepeatStrategy = require('./set-repeat-strategy');

var _numberRepeatStrategy = require('./number-repeat-strategy');



var RepeatStrategyLocator = exports.RepeatStrategyLocator = function () {
  function RepeatStrategyLocator() {
    

    this.matchers = [];
    this.strategies = [];

    this.addStrategy(function (items) {
      return items === null || items === undefined;
    }, new _nullRepeatStrategy.NullRepeatStrategy());
    this.addStrategy(function (items) {
      return items instanceof Array;
    }, new _arrayRepeatStrategy.ArrayRepeatStrategy());
    this.addStrategy(function (items) {
      return items instanceof Map;
    }, new _mapRepeatStrategy.MapRepeatStrategy());
    this.addStrategy(function (items) {
      return items instanceof Set;
    }, new _setRepeatStrategy.SetRepeatStrategy());
    this.addStrategy(function (items) {
      return typeof items === 'number';
    }, new _numberRepeatStrategy.NumberRepeatStrategy());
  }

  RepeatStrategyLocator.prototype.addStrategy = function addStrategy(matcher, strategy) {
    this.matchers.push(matcher);
    this.strategies.push(strategy);
  };

  RepeatStrategyLocator.prototype.getStrategy = function getStrategy(items) {
    var matchers = this.matchers;

    for (var i = 0, ii = matchers.length; i < ii; ++i) {
      if (matchers[i](items)) {
        return this.strategies[i];
      }
    }

    return null;
  };

  return RepeatStrategyLocator;
}();
});

define('aurelia-templating-resources/dist/commonjs/repeat-utilities',['require','exports','module','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateOverrideContexts = updateOverrideContexts;
exports.createFullOverrideContext = createFullOverrideContext;
exports.updateOverrideContext = updateOverrideContext;
exports.getItemsSourceExpression = getItemsSourceExpression;
exports.unwrapExpression = unwrapExpression;
exports.isOneTime = isOneTime;
exports.updateOneTimeBinding = updateOneTimeBinding;
exports.indexOf = indexOf;

var _aureliaBinding = require('aurelia-binding');

var oneTime = _aureliaBinding.bindingMode.oneTime;

function updateOverrideContexts(views, startIndex) {
  var length = views.length;

  if (startIndex > 0) {
    startIndex = startIndex - 1;
  }

  for (; startIndex < length; ++startIndex) {
    updateOverrideContext(views[startIndex].overrideContext, startIndex, length);
  }
}

function createFullOverrideContext(repeat, data, index, length, key) {
  var bindingContext = {};
  var overrideContext = (0, _aureliaBinding.createOverrideContext)(bindingContext, repeat.scope.overrideContext);

  if (typeof key !== 'undefined') {
    bindingContext[repeat.key] = key;
    bindingContext[repeat.value] = data;
  } else {
    bindingContext[repeat.local] = data;
  }
  updateOverrideContext(overrideContext, index, length);
  return overrideContext;
}

function updateOverrideContext(overrideContext, index, length) {
  var first = index === 0;
  var last = index === length - 1;
  var even = index % 2 === 0;

  overrideContext.$index = index;
  overrideContext.$first = first;
  overrideContext.$last = last;
  overrideContext.$middle = !(first || last);
  overrideContext.$odd = !even;
  overrideContext.$even = even;
}

function getItemsSourceExpression(instruction, attrName) {
  return instruction.behaviorInstructions.filter(function (bi) {
    return bi.originalAttrName === attrName;
  })[0].attributes.items.sourceExpression;
}

function unwrapExpression(expression) {
  var unwrapped = false;
  while (expression instanceof _aureliaBinding.BindingBehavior) {
    expression = expression.expression;
  }
  while (expression instanceof _aureliaBinding.ValueConverter) {
    expression = expression.expression;
    unwrapped = true;
  }
  return unwrapped ? expression : null;
}

function isOneTime(expression) {
  while (expression instanceof _aureliaBinding.BindingBehavior) {
    if (expression.name === 'oneTime') {
      return true;
    }
    expression = expression.expression;
  }
  return false;
}

function updateOneTimeBinding(binding) {
  if (binding.call && binding.mode === oneTime) {
    binding.call(_aureliaBinding.sourceContext);
  } else if (binding.updateOneTimeBindings) {
    binding.updateOneTimeBindings();
  }
}

function indexOf(array, item, matcher, startIndex) {
  if (!matcher) {
    return array.indexOf(item);
  }
  var length = array.length;
  for (var index = startIndex || 0; index < length; index++) {
    if (matcher(array[index], item)) {
      return index;
    }
  }
  return -1;
}
});

define('aurelia-templating-resources/dist/commonjs/replaceable',['require','exports','module','aurelia-dependency-injection','aurelia-templating'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Replaceable = undefined;

var _dec, _dec2, _class;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaTemplating = require('aurelia-templating');



var Replaceable = exports.Replaceable = (_dec = (0, _aureliaTemplating.customAttribute)('replaceable'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = function () {
  function Replaceable(viewFactory, viewSlot) {
    

    this.viewFactory = viewFactory;
    this.viewSlot = viewSlot;
    this.view = null;
  }

  Replaceable.prototype.bind = function bind(bindingContext, overrideContext) {
    if (this.view === null) {
      this.view = this.viewFactory.create();
      this.viewSlot.add(this.view);
    }

    this.view.bind(bindingContext, overrideContext);
  };

  Replaceable.prototype.unbind = function unbind() {
    this.view.unbind();
  };

  return Replaceable;
}()) || _class) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/sanitize-html',['require','exports','module','aurelia-binding','aurelia-dependency-injection','./html-sanitizer'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SanitizeHTMLValueConverter = undefined;

var _dec, _dec2, _class;

var _aureliaBinding = require('aurelia-binding');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _htmlSanitizer = require('./html-sanitizer');



var SanitizeHTMLValueConverter = exports.SanitizeHTMLValueConverter = (_dec = (0, _aureliaBinding.valueConverter)('sanitizeHTML'), _dec2 = (0, _aureliaDependencyInjection.inject)(_htmlSanitizer.HTMLSanitizer), _dec(_class = _dec2(_class = function () {
  function SanitizeHTMLValueConverter(sanitizer) {
    

    this.sanitizer = sanitizer;
  }

  SanitizeHTMLValueConverter.prototype.toView = function toView(untrustedMarkup) {
    if (untrustedMarkup === null || untrustedMarkup === undefined) {
      return null;
    }

    return this.sanitizer.sanitize(untrustedMarkup);
  };

  return SanitizeHTMLValueConverter;
}()) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/self-binding-behavior',['require','exports','module'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});



function findOriginalEventTarget(event) {
  return event.path && event.path[0] || event.deepPath && event.deepPath[0] || event.target;
}

function handleSelfEvent(event) {
  var target = findOriginalEventTarget(event);
  if (this.target !== target) return;
  this.selfEventCallSource(event);
}

var SelfBindingBehavior = exports.SelfBindingBehavior = function () {
  function SelfBindingBehavior() {
    
  }

  SelfBindingBehavior.prototype.bind = function bind(binding, source) {
    if (!binding.callSource || !binding.targetEvent) throw new Error('Self binding behavior only supports event.');
    binding.selfEventCallSource = binding.callSource;
    binding.callSource = handleSelfEvent;
  };

  SelfBindingBehavior.prototype.unbind = function unbind(binding, source) {
    binding.callSource = binding.selfEventCallSource;
    binding.selfEventCallSource = null;
  };

  return SelfBindingBehavior;
}();
});

define('aurelia-templating-resources/dist/commonjs/set-repeat-strategy',['require','exports','module','./repeat-utilities'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SetRepeatStrategy = undefined;

var _repeatUtilities = require('./repeat-utilities');



var SetRepeatStrategy = exports.SetRepeatStrategy = function () {
  function SetRepeatStrategy() {
    
  }

  SetRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {
    return observerLocator.getSetObserver(items);
  };

  SetRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
    var _this = this;

    var removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
    if (removePromise instanceof Promise) {
      removePromise.then(function () {
        return _this._standardProcessItems(repeat, items);
      });
      return;
    }
    this._standardProcessItems(repeat, items);
  };

  SetRepeatStrategy.prototype._standardProcessItems = function _standardProcessItems(repeat, items) {
    var index = 0;
    var overrideContext = void 0;

    items.forEach(function (value) {
      overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, value, index, items.size);
      repeat.addView(overrideContext.bindingContext, overrideContext);
      ++index;
    });
  };

  SetRepeatStrategy.prototype.instanceMutated = function instanceMutated(repeat, set, records) {
    var value = void 0;
    var i = void 0;
    var ii = void 0;
    var overrideContext = void 0;
    var removeIndex = void 0;
    var record = void 0;
    var rmPromises = [];
    var viewOrPromise = void 0;

    for (i = 0, ii = records.length; i < ii; ++i) {
      record = records[i];
      value = record.value;
      switch (record.type) {
        case 'add':
          var size = Math.max(set.size - 1, 0);
          overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, value, size, set.size);
          repeat.insertView(size, overrideContext.bindingContext, overrideContext);
          break;
        case 'delete':
          removeIndex = this._getViewIndexByValue(repeat, value);
          viewOrPromise = repeat.removeView(removeIndex, true, !repeat.viewsRequireLifecycle);
          if (viewOrPromise instanceof Promise) {
            rmPromises.push(viewOrPromise);
          }
          break;
        case 'clear':
          repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
          break;
        default:
          continue;
      }
    }

    if (rmPromises.length > 0) {
      Promise.all(rmPromises).then(function () {
        (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
      });
    } else {
      (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
    }
  };

  SetRepeatStrategy.prototype._getViewIndexByValue = function _getViewIndexByValue(repeat, value) {
    var i = void 0;
    var ii = void 0;
    var child = void 0;

    for (i = 0, ii = repeat.viewCount(); i < ii; ++i) {
      child = repeat.view(i);
      if (child.bindingContext[repeat.local] === value) {
        return i;
      }
    }

    return undefined;
  };

  return SetRepeatStrategy;
}();
});

define('aurelia-templating-resources/dist/commonjs/show',['require','exports','module','aurelia-dependency-injection','aurelia-templating','aurelia-pal','./aurelia-hide-style'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Show = undefined;

var _dec, _dec2, _class;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaTemplating = require('aurelia-templating');

var _aureliaPal = require('aurelia-pal');

var _aureliaHideStyle = require('./aurelia-hide-style');



var Show = exports.Show = (_dec = (0, _aureliaTemplating.customAttribute)('show'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element, _aureliaTemplating.Animator, _aureliaDependencyInjection.Optional.of(_aureliaPal.DOM.boundary, true)), _dec(_class = _dec2(_class = function () {
  function Show(element, animator, domBoundary) {
    

    this.element = element;
    this.animator = animator;
    this.domBoundary = domBoundary;
  }

  Show.prototype.created = function created() {
    (0, _aureliaHideStyle.injectAureliaHideStyleAtBoundary)(this.domBoundary);
  };

  Show.prototype.valueChanged = function valueChanged(newValue) {
    if (newValue) {
      this.animator.removeClass(this.element, _aureliaHideStyle.aureliaHideClassName);
    } else {
      this.animator.addClass(this.element, _aureliaHideStyle.aureliaHideClassName);
    }
  };

  Show.prototype.bind = function bind(bindingContext) {
    this.valueChanged(this.value);
  };

  return Show;
}()) || _class) || _class);
});

define('aurelia-templating-resources/dist/commonjs/signal-binding-behavior',['require','exports','module','./binding-signaler'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SignalBindingBehavior = undefined;

var _bindingSignaler = require('./binding-signaler');



var SignalBindingBehavior = exports.SignalBindingBehavior = function () {
  SignalBindingBehavior.inject = function inject() {
    return [_bindingSignaler.BindingSignaler];
  };

  function SignalBindingBehavior(bindingSignaler) {
    

    this.signals = bindingSignaler.signals;
  }

  SignalBindingBehavior.prototype.bind = function bind(binding, source) {
    if (!binding.updateTarget) {
      throw new Error('Only property bindings and string interpolation bindings can be signaled.  Trigger, delegate and call bindings cannot be signaled.');
    }
    if (arguments.length === 3) {
      var name = arguments[2];
      var bindings = this.signals[name] || (this.signals[name] = []);
      bindings.push(binding);
      binding.signalName = name;
    } else if (arguments.length > 3) {
      var names = Array.prototype.slice.call(arguments, 2);
      var i = names.length;
      while (i--) {
        var _name = names[i];
        var _bindings = this.signals[_name] || (this.signals[_name] = []);
        _bindings.push(binding);
      }
      binding.signalName = names;
    } else {
      throw new Error('Signal name is required.');
    }
  };

  SignalBindingBehavior.prototype.unbind = function unbind(binding, source) {
    var name = binding.signalName;
    binding.signalName = null;
    if (Array.isArray(name)) {
      var names = name;
      var i = names.length;
      while (i--) {
        var n = names[i];
        var bindings = this.signals[n];
        bindings.splice(bindings.indexOf(binding), 1);
      }
    } else {
      var _bindings2 = this.signals[name];
      _bindings2.splice(_bindings2.indexOf(binding), 1);
    }
  };

  return SignalBindingBehavior;
}();
});

define('aurelia-templating-resources/dist/commonjs/throttle-binding-behavior',['require','exports','module','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThrottleBindingBehavior = undefined;

var _aureliaBinding = require('aurelia-binding');



function throttle(newValue) {
  var _this = this;

  var state = this.throttleState;
  var elapsed = +new Date() - state.last;
  if (elapsed >= state.delay) {
    clearTimeout(state.timeoutId);
    state.timeoutId = null;
    state.last = +new Date();
    this.throttledMethod(newValue);
    return;
  }
  state.newValue = newValue;
  if (state.timeoutId === null) {
    state.timeoutId = setTimeout(function () {
      state.timeoutId = null;
      state.last = +new Date();
      _this.throttledMethod(state.newValue);
    }, state.delay - elapsed);
  }
}

var ThrottleBindingBehavior = exports.ThrottleBindingBehavior = function () {
  function ThrottleBindingBehavior() {
    
  }

  ThrottleBindingBehavior.prototype.bind = function bind(binding, source) {
    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;

    var methodToThrottle = 'updateTarget';
    if (binding.callSource) {
      methodToThrottle = 'callSource';
    } else if (binding.updateSource && binding.mode === _aureliaBinding.bindingMode.twoWay) {
      methodToThrottle = 'updateSource';
    }

    binding.throttledMethod = binding[methodToThrottle];
    binding.throttledMethod.originalName = methodToThrottle;

    binding[methodToThrottle] = throttle;

    binding.throttleState = {
      delay: delay,
      last: 0,
      timeoutId: null
    };
  };

  ThrottleBindingBehavior.prototype.unbind = function unbind(binding, source) {
    var methodToRestore = binding.throttledMethod.originalName;
    binding[methodToRestore] = binding.throttledMethod;
    binding.throttledMethod = null;
    clearTimeout(binding.throttleState.timeoutId);
    binding.throttleState = null;
  };

  return ThrottleBindingBehavior;
}();
});

define('aurelia-templating-resources/dist/commonjs/update-trigger-binding-behavior',['require','exports','module','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UpdateTriggerBindingBehavior = undefined;

var _aureliaBinding = require('aurelia-binding');



var eventNamesRequired = 'The updateTrigger binding behavior requires at least one event name argument: eg <input value.bind="firstName & updateTrigger:\'blur\'">';
var notApplicableMessage = 'The updateTrigger binding behavior can only be applied to two-way/ from-view bindings on input/select elements.';

var UpdateTriggerBindingBehavior = exports.UpdateTriggerBindingBehavior = function () {
  function UpdateTriggerBindingBehavior() {
    
  }

  UpdateTriggerBindingBehavior.prototype.bind = function bind(binding, source) {
    for (var _len = arguments.length, events = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      events[_key - 2] = arguments[_key];
    }

    if (events.length === 0) {
      throw new Error(eventNamesRequired);
    }
    if (binding.mode !== _aureliaBinding.bindingMode.twoWay && binding.mode !== _aureliaBinding.bindingMode.fromView) {
      throw new Error(notApplicableMessage);
    }

    var targetObserver = binding.observerLocator.getObserver(binding.target, binding.targetProperty);
    if (!targetObserver.handler) {
      throw new Error(notApplicableMessage);
    }
    binding.targetObserver = targetObserver;

    targetObserver.originalHandler = binding.targetObserver.handler;

    var handler = new _aureliaBinding.EventSubscriber(events);
    targetObserver.handler = handler;
  };

  UpdateTriggerBindingBehavior.prototype.unbind = function unbind(binding, source) {
    binding.targetObserver.handler.dispose();
    binding.targetObserver.handler = binding.targetObserver.originalHandler;
    binding.targetObserver.originalHandler = null;
  };

  return UpdateTriggerBindingBehavior;
}();
});

define('aurelia-templating-resources/dist/commonjs/with',['require','exports','module','aurelia-dependency-injection','aurelia-templating','aurelia-binding'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.With = undefined;

var _dec, _dec2, _class;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaTemplating = require('aurelia-templating');

var _aureliaBinding = require('aurelia-binding');



var With = exports.With = (_dec = (0, _aureliaTemplating.customAttribute)('with'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = function () {
  function With(viewFactory, viewSlot) {
    

    this.viewFactory = viewFactory;
    this.viewSlot = viewSlot;
    this.parentOverrideContext = null;
    this.view = null;
  }

  With.prototype.bind = function bind(bindingContext, overrideContext) {
    this.parentOverrideContext = overrideContext;
    this.valueChanged(this.value);
  };

  With.prototype.valueChanged = function valueChanged(newValue) {
    var overrideContext = (0, _aureliaBinding.createOverrideContext)(newValue, this.parentOverrideContext);
    if (!this.view) {
      this.view = this.viewFactory.create();
      this.view.bind(newValue, overrideContext);
      this.viewSlot.add(this.view);
    } else {
      this.view.bind(newValue, overrideContext);
    }
  };

  With.prototype.unbind = function unbind() {
    this.parentOverrideContext = null;

    if (this.view) {
      this.view.unbind();
    }
  };

  return With;
}()) || _class) || _class) || _class);
});

define('aurelia-templating-router/dist/commonjs/aurelia-templating-router',['require','exports','module','aurelia-pal','aurelia-router','./route-loader','./router-view','./route-href'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configure = exports.RouteHref = exports.RouterView = exports.TemplatingRouteLoader = undefined;

var _aureliaPal = require('aurelia-pal');

var _aureliaRouter = require('aurelia-router');

var _routeLoader = require('./route-loader');

var _routerView = require('./router-view');

var _routeHref = require('./route-href');

function configure(config) {
  config.singleton(_aureliaRouter.RouteLoader, _routeLoader.TemplatingRouteLoader).singleton(_aureliaRouter.Router, _aureliaRouter.AppRouter).globalResources(_aureliaPal.PLATFORM.moduleName('./router-view'), _aureliaPal.PLATFORM.moduleName('./route-href'));

  config.container.registerAlias(_aureliaRouter.Router, _aureliaRouter.AppRouter);
}

exports.TemplatingRouteLoader = _routeLoader.TemplatingRouteLoader;
exports.RouterView = _routerView.RouterView;
exports.RouteHref = _routeHref.RouteHref;
exports.configure = configure;
});

define('aurelia-templating-router/dist/commonjs/route-href',['require','exports','module','aurelia-templating','aurelia-dependency-injection','aurelia-router','aurelia-pal','aurelia-logging'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RouteHref = undefined;

var _dec, _dec2, _dec3, _dec4, _dec5, _class;

var _aureliaTemplating = require('aurelia-templating');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaRouter = require('aurelia-router');

var _aureliaPal = require('aurelia-pal');

var _aureliaLogging = require('aurelia-logging');

var LogManager = _interopRequireWildcard(_aureliaLogging);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }



var logger = LogManager.getLogger('route-href');

var RouteHref = exports.RouteHref = (_dec = (0, _aureliaTemplating.customAttribute)('route-href'), _dec2 = (0, _aureliaTemplating.bindable)({ name: 'route', changeHandler: 'processChange', primaryProperty: true }), _dec3 = (0, _aureliaTemplating.bindable)({ name: 'params', changeHandler: 'processChange' }), _dec4 = (0, _aureliaTemplating.bindable)({ name: 'attribute', defaultValue: 'href' }), _dec5 = (0, _aureliaDependencyInjection.inject)(_aureliaRouter.Router, _aureliaPal.DOM.Element), _dec(_class = _dec2(_class = _dec3(_class = _dec4(_class = _dec5(_class = function () {
  function RouteHref(router, element) {
    

    this.router = router;
    this.element = element;
  }

  RouteHref.prototype.bind = function bind() {
    this.isActive = true;
    this.processChange();
  };

  RouteHref.prototype.unbind = function unbind() {
    this.isActive = false;
  };

  RouteHref.prototype.attributeChanged = function attributeChanged(value, previous) {
    if (previous) {
      this.element.removeAttribute(previous);
    }

    this.processChange();
  };

  RouteHref.prototype.processChange = function processChange() {
    var _this = this;

    return this.router.ensureConfigured().then(function () {
      if (!_this.isActive) {
        return null;
      }

      var href = _this.router.generate(_this.route, _this.params);

      if (_this.element.au.controller) {
        _this.element.au.controller.viewModel[_this.attribute] = href;
      } else {
        _this.element.setAttribute(_this.attribute, href);
      }

      return null;
    }).catch(function (reason) {
      logger.error(reason);
    });
  };

  return RouteHref;
}()) || _class) || _class) || _class) || _class) || _class);
});

define('aurelia-templating-router/dist/commonjs/route-loader',['require','exports','module','aurelia-dependency-injection','aurelia-templating','aurelia-router','aurelia-path','aurelia-metadata','./router-view'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TemplatingRouteLoader = undefined;

var _dec, _class, _dec2, _class2;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaTemplating = require('aurelia-templating');

var _aureliaRouter = require('aurelia-router');

var _aureliaPath = require('aurelia-path');

var _aureliaMetadata = require('aurelia-metadata');

var _routerView = require('./router-view');

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var EmptyClass = (_dec = (0, _aureliaTemplating.inlineView)('<template></template>'), _dec(_class = function EmptyClass() {
  
}) || _class);
var TemplatingRouteLoader = exports.TemplatingRouteLoader = (_dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.CompositionEngine), _dec2(_class2 = function (_RouteLoader) {
  _inherits(TemplatingRouteLoader, _RouteLoader);

  function TemplatingRouteLoader(compositionEngine) {
    

    var _this = _possibleConstructorReturn(this, _RouteLoader.call(this));

    _this.compositionEngine = compositionEngine;
    return _this;
  }

  TemplatingRouteLoader.prototype.loadRoute = function loadRoute(router, config) {
    var childContainer = router.container.createChild();

    var viewModel = void 0;
    if (config.moduleId === null) {
      viewModel = EmptyClass;
    } else if (/\.html/i.test(config.moduleId)) {
      viewModel = createDynamicClass(config.moduleId);
    } else {
      viewModel = (0, _aureliaPath.relativeToFile)(config.moduleId, _aureliaMetadata.Origin.get(router.container.viewModel.constructor).moduleId);
    }

    config = config || {};

    var instruction = {
      viewModel: viewModel,
      childContainer: childContainer,
      view: config.view || config.viewStrategy,
      router: router
    };

    childContainer.registerSingleton(_routerView.RouterViewLocator);

    childContainer.getChildRouter = function () {
      var childRouter = void 0;

      childContainer.registerHandler(_aureliaRouter.Router, function (c) {
        return childRouter || (childRouter = router.createChild(childContainer));
      });

      return childContainer.get(_aureliaRouter.Router);
    };

    return this.compositionEngine.ensureViewModel(instruction);
  };

  return TemplatingRouteLoader;
}(_aureliaRouter.RouteLoader)) || _class2);


function createDynamicClass(moduleId) {
  var _dec3, _dec4, _class3;

  var name = /([^\/^\?]+)\.html/i.exec(moduleId)[1];

  var DynamicClass = (_dec3 = (0, _aureliaTemplating.customElement)(name), _dec4 = (0, _aureliaTemplating.useView)(moduleId), _dec3(_class3 = _dec4(_class3 = function () {
    function DynamicClass() {
      
    }

    DynamicClass.prototype.bind = function bind(bindingContext) {
      this.$parent = bindingContext;
    };

    return DynamicClass;
  }()) || _class3) || _class3);


  return DynamicClass;
}
});

define('aurelia-templating-router/dist/commonjs/router-view',['require','exports','module','aurelia-dependency-injection','aurelia-binding','aurelia-templating','aurelia-router','aurelia-metadata','aurelia-pal'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RouterViewLocator = exports.RouterView = undefined;

var _dec, _dec2, _class, _desc, _value, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaBinding = require('aurelia-binding');

var _aureliaTemplating = require('aurelia-templating');

var _aureliaRouter = require('aurelia-router');

var _aureliaMetadata = require('aurelia-metadata');

var _aureliaPal = require('aurelia-pal');

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}



function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var RouterView = exports.RouterView = (_dec = (0, _aureliaTemplating.customElement)('router-view'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element, _aureliaDependencyInjection.Container, _aureliaTemplating.ViewSlot, _aureliaRouter.Router, _aureliaTemplating.ViewLocator, _aureliaTemplating.CompositionTransaction, _aureliaTemplating.CompositionEngine), _dec(_class = (0, _aureliaTemplating.noView)(_class = _dec2(_class = (_class2 = function () {
  function RouterView(element, container, viewSlot, router, viewLocator, compositionTransaction, compositionEngine) {
    

    _initDefineProp(this, 'swapOrder', _descriptor, this);

    _initDefineProp(this, 'layoutView', _descriptor2, this);

    _initDefineProp(this, 'layoutViewModel', _descriptor3, this);

    _initDefineProp(this, 'layoutModel', _descriptor4, this);

    this.element = element;
    this.container = container;
    this.viewSlot = viewSlot;
    this.router = router;
    this.viewLocator = viewLocator;
    this.compositionTransaction = compositionTransaction;
    this.compositionEngine = compositionEngine;
    this.router.registerViewPort(this, this.element.getAttribute('name'));

    if (!('initialComposition' in compositionTransaction)) {
      compositionTransaction.initialComposition = true;
      this.compositionTransactionNotifier = compositionTransaction.enlist();
    }
  }

  RouterView.prototype.created = function created(owningView) {
    this.owningView = owningView;
  };

  RouterView.prototype.bind = function bind(bindingContext, overrideContext) {
    this.container.viewModel = bindingContext;
    this.overrideContext = overrideContext;
  };

  RouterView.prototype.process = function process(viewPortInstruction, waitToSwap) {
    var _this = this;

    var component = viewPortInstruction.component;
    var childContainer = component.childContainer;
    var viewModel = component.viewModel;
    var viewModelResource = component.viewModelResource;
    var metadata = viewModelResource.metadata;
    var config = component.router.currentInstruction.config;
    var viewPort = config.viewPorts ? config.viewPorts[viewPortInstruction.name] || {} : {};

    childContainer.get(RouterViewLocator)._notify(this);

    var layoutInstruction = {
      viewModel: viewPort.layoutViewModel || config.layoutViewModel || this.layoutViewModel,
      view: viewPort.layoutView || config.layoutView || this.layoutView,
      model: viewPort.layoutModel || config.layoutModel || this.layoutModel,
      router: viewPortInstruction.component.router,
      childContainer: childContainer,
      viewSlot: this.viewSlot
    };

    var viewStrategy = this.viewLocator.getViewStrategy(component.view || viewModel);
    if (viewStrategy && component.view) {
      viewStrategy.makeRelativeTo(_aureliaMetadata.Origin.get(component.router.container.viewModel.constructor).moduleId);
    }

    return metadata.load(childContainer, viewModelResource.value, null, viewStrategy, true).then(function (viewFactory) {
      if (!_this.compositionTransactionNotifier) {
        _this.compositionTransactionOwnershipToken = _this.compositionTransaction.tryCapture();
      }

      if (layoutInstruction.viewModel || layoutInstruction.view) {
        viewPortInstruction.layoutInstruction = layoutInstruction;
      }

      viewPortInstruction.controller = metadata.create(childContainer, _aureliaTemplating.BehaviorInstruction.dynamic(_this.element, viewModel, viewFactory));

      if (waitToSwap) {
        return null;
      }

      _this.swap(viewPortInstruction);
    });
  };

  RouterView.prototype.swap = function swap(viewPortInstruction) {
    var _this2 = this;

    var layoutInstruction = viewPortInstruction.layoutInstruction;
    var previousView = this.view;

    var work = function work() {
      var swapStrategy = _aureliaTemplating.SwapStrategies[_this2.swapOrder] || _aureliaTemplating.SwapStrategies.after;
      var viewSlot = _this2.viewSlot;

      swapStrategy(viewSlot, previousView, function () {
        return Promise.resolve(viewSlot.add(_this2.view));
      }).then(function () {
        _this2._notify();
      });
    };

    var ready = function ready(owningView) {
      viewPortInstruction.controller.automate(_this2.overrideContext, owningView);
      if (_this2.compositionTransactionOwnershipToken) {
        return _this2.compositionTransactionOwnershipToken.waitForCompositionComplete().then(function () {
          _this2.compositionTransactionOwnershipToken = null;
          return work();
        });
      }

      return work();
    };

    if (layoutInstruction) {
      if (!layoutInstruction.viewModel) {
        layoutInstruction.viewModel = {};
      }

      return this.compositionEngine.createController(layoutInstruction).then(function (controller) {
        _aureliaTemplating.ShadowDOM.distributeView(viewPortInstruction.controller.view, controller.slots || controller.view.slots);
        controller.automate((0, _aureliaBinding.createOverrideContext)(layoutInstruction.viewModel), _this2.owningView);
        controller.view.children.push(viewPortInstruction.controller.view);
        return controller.view || controller;
      }).then(function (newView) {
        _this2.view = newView;
        return ready(newView);
      });
    }

    this.view = viewPortInstruction.controller.view;

    return ready(this.owningView);
  };

  RouterView.prototype._notify = function _notify() {
    if (this.compositionTransactionNotifier) {
      this.compositionTransactionNotifier.done();
      this.compositionTransactionNotifier = null;
    }
  };

  return RouterView;
}(), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'swapOrder', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'layoutView', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, 'layoutViewModel', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, 'layoutModel', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
})), _class2)) || _class) || _class) || _class);

var RouterViewLocator = exports.RouterViewLocator = function () {
  function RouterViewLocator() {
    var _this3 = this;

    

    this.promise = new Promise(function (resolve) {
      return _this3.resolve = resolve;
    });
  }

  RouterViewLocator.prototype.findNearest = function findNearest() {
    return this.promise;
  };

  RouterViewLocator.prototype._notify = function _notify(routerView) {
    this.resolve(routerView);
  };

  return RouterViewLocator;
}();
});

define('aurelia-templating/dist/commonjs/aurelia-templating',['require','exports','module','aurelia-logging','aurelia-metadata','aurelia-pal','aurelia-path','aurelia-loader','aurelia-dependency-injection','aurelia-binding','aurelia-task-queue'],function (require, exports, module) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TemplatingEngine = exports.ElementConfigResource = exports.CompositionEngine = exports.SwapStrategies = exports.HtmlBehaviorResource = exports.BindableProperty = exports.BehaviorPropertyObserver = exports.Controller = exports.ViewEngine = exports.ModuleAnalyzer = exports.ResourceDescription = exports.ResourceModule = exports.ViewCompiler = exports.ViewFactory = exports.BoundViewFactory = exports.ViewSlot = exports.View = exports.ViewResources = exports.ShadowDOM = exports.ShadowSlot = exports.PassThroughSlot = exports.SlotCustomAttribute = exports.BindingLanguage = exports.ViewLocator = exports.InlineViewStrategy = exports.TemplateRegistryViewStrategy = exports.NoViewStrategy = exports.ConventionalViewStrategy = exports.RelativeViewStrategy = exports.viewStrategy = exports.TargetInstruction = exports.BehaviorInstruction = exports.ViewCompileInstruction = exports.ResourceLoadContext = exports.ElementEvents = exports.ViewEngineHooksResource = exports.CompositionTransaction = exports.CompositionTransactionOwnershipToken = exports.CompositionTransactionNotifier = exports.Animator = exports.animationEvent = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp, _dec, _class2, _dec2, _class3, _dec3, _class4, _dec4, _class5, _dec5, _class6, _class7, _temp2, _dec6, _class8, _class9, _temp3, _class11, _dec7, _class13, _dec8, _class14, _class15, _temp4, _dec9, _class16, _dec10, _class17, _dec11, _class18;

exports._hyphenate = _hyphenate;
exports._isAllWhitespace = _isAllWhitespace;
exports.viewEngineHooks = viewEngineHooks;
exports.children = children;
exports.child = child;
exports.resource = resource;
exports.behavior = behavior;
exports.customElement = customElement;
exports.customAttribute = customAttribute;
exports.templateController = templateController;
exports.bindable = bindable;
exports.dynamicOptions = dynamicOptions;
exports.useShadowDOM = useShadowDOM;
exports.processAttributes = processAttributes;
exports.processContent = processContent;
exports.containerless = containerless;
exports.useViewStrategy = useViewStrategy;
exports.useView = useView;
exports.inlineView = inlineView;
exports.noView = noView;
exports.elementConfig = elementConfig;
exports.viewResources = viewResources;

var _aureliaLogging = require('aurelia-logging');

var LogManager = _interopRequireWildcard(_aureliaLogging);

var _aureliaMetadata = require('aurelia-metadata');

var _aureliaPal = require('aurelia-pal');

var _aureliaPath = require('aurelia-path');

var _aureliaLoader = require('aurelia-loader');

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaBinding = require('aurelia-binding');

var _aureliaTaskQueue = require('aurelia-task-queue');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }



var animationEvent = exports.animationEvent = {
  enterBegin: 'animation:enter:begin',
  enterActive: 'animation:enter:active',
  enterDone: 'animation:enter:done',
  enterTimeout: 'animation:enter:timeout',

  leaveBegin: 'animation:leave:begin',
  leaveActive: 'animation:leave:active',
  leaveDone: 'animation:leave:done',
  leaveTimeout: 'animation:leave:timeout',

  staggerNext: 'animation:stagger:next',

  removeClassBegin: 'animation:remove-class:begin',
  removeClassActive: 'animation:remove-class:active',
  removeClassDone: 'animation:remove-class:done',
  removeClassTimeout: 'animation:remove-class:timeout',

  addClassBegin: 'animation:add-class:begin',
  addClassActive: 'animation:add-class:active',
  addClassDone: 'animation:add-class:done',
  addClassTimeout: 'animation:add-class:timeout',

  animateBegin: 'animation:animate:begin',
  animateActive: 'animation:animate:active',
  animateDone: 'animation:animate:done',
  animateTimeout: 'animation:animate:timeout',

  sequenceBegin: 'animation:sequence:begin',
  sequenceDone: 'animation:sequence:done'
};

var Animator = exports.Animator = function () {
  function Animator() {
    
  }

  Animator.prototype.enter = function enter(element) {
    return Promise.resolve(false);
  };

  Animator.prototype.leave = function leave(element) {
    return Promise.resolve(false);
  };

  Animator.prototype.removeClass = function removeClass(element, className) {
    element.classList.remove(className);
    return Promise.resolve(false);
  };

  Animator.prototype.addClass = function addClass(element, className) {
    element.classList.add(className);
    return Promise.resolve(false);
  };

  Animator.prototype.animate = function animate(element, className) {
    return Promise.resolve(false);
  };

  Animator.prototype.runSequence = function runSequence(animations) {};

  Animator.prototype.registerEffect = function registerEffect(effectName, properties) {};

  Animator.prototype.unregisterEffect = function unregisterEffect(effectName) {};

  return Animator;
}();

var CompositionTransactionNotifier = exports.CompositionTransactionNotifier = function () {
  function CompositionTransactionNotifier(owner) {
    

    this.owner = owner;
    this.owner._compositionCount++;
  }

  CompositionTransactionNotifier.prototype.done = function done() {
    this.owner._compositionCount--;
    this.owner._tryCompleteTransaction();
  };

  return CompositionTransactionNotifier;
}();

var CompositionTransactionOwnershipToken = exports.CompositionTransactionOwnershipToken = function () {
  function CompositionTransactionOwnershipToken(owner) {
    

    this.owner = owner;
    this.owner._ownershipToken = this;
    this.thenable = this._createThenable();
  }

  CompositionTransactionOwnershipToken.prototype.waitForCompositionComplete = function waitForCompositionComplete() {
    this.owner._tryCompleteTransaction();
    return this.thenable;
  };

  CompositionTransactionOwnershipToken.prototype.resolve = function resolve() {
    this._resolveCallback();
  };

  CompositionTransactionOwnershipToken.prototype._createThenable = function _createThenable() {
    var _this = this;

    return new Promise(function (resolve, reject) {
      _this._resolveCallback = resolve;
    });
  };

  return CompositionTransactionOwnershipToken;
}();

var CompositionTransaction = exports.CompositionTransaction = function () {
  function CompositionTransaction() {
    

    this._ownershipToken = null;
    this._compositionCount = 0;
  }

  CompositionTransaction.prototype.tryCapture = function tryCapture() {
    return this._ownershipToken === null ? new CompositionTransactionOwnershipToken(this) : null;
  };

  CompositionTransaction.prototype.enlist = function enlist() {
    return new CompositionTransactionNotifier(this);
  };

  CompositionTransaction.prototype._tryCompleteTransaction = function _tryCompleteTransaction() {
    if (this._compositionCount <= 0) {
      this._compositionCount = 0;

      if (this._ownershipToken !== null) {
        var token = this._ownershipToken;
        this._ownershipToken = null;
        token.resolve();
      }
    }
  };

  return CompositionTransaction;
}();

var capitalMatcher = /([A-Z])/g;

function addHyphenAndLower(char) {
  return '-' + char.toLowerCase();
}

function _hyphenate(name) {
  return (name.charAt(0).toLowerCase() + name.slice(1)).replace(capitalMatcher, addHyphenAndLower);
}

function _isAllWhitespace(node) {
  return !(node.auInterpolationTarget || /[^\t\n\r ]/.test(node.textContent));
}

var ViewEngineHooksResource = exports.ViewEngineHooksResource = function () {
  function ViewEngineHooksResource() {
    
  }

  ViewEngineHooksResource.prototype.initialize = function initialize(container, target) {
    this.instance = container.get(target);
  };

  ViewEngineHooksResource.prototype.register = function register(registry, name) {
    registry.registerViewEngineHooks(this.instance);
  };

  ViewEngineHooksResource.prototype.load = function load(container, target) {};

  ViewEngineHooksResource.convention = function convention(name) {
    if (name.endsWith('ViewEngineHooks')) {
      return new ViewEngineHooksResource();
    }
  };

  return ViewEngineHooksResource;
}();

function viewEngineHooks(target) {
  var deco = function deco(t) {
    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ViewEngineHooksResource(), t);
  };

  return target ? deco(target) : deco;
}

var ElementEvents = exports.ElementEvents = function () {
  function ElementEvents(element) {
    

    this.element = element;
    this.subscriptions = {};
  }

  ElementEvents.prototype._enqueueHandler = function _enqueueHandler(handler) {
    this.subscriptions[handler.eventName] = this.subscriptions[handler.eventName] || [];
    this.subscriptions[handler.eventName].push(handler);
  };

  ElementEvents.prototype._dequeueHandler = function _dequeueHandler(handler) {
    var index = void 0;
    var subscriptions = this.subscriptions[handler.eventName];
    if (subscriptions) {
      index = subscriptions.indexOf(handler);
      if (index > -1) {
        subscriptions.splice(index, 1);
      }
    }
    return handler;
  };

  ElementEvents.prototype.publish = function publish(eventName) {
    var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var bubbles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var cancelable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    var event = _aureliaPal.DOM.createCustomEvent(eventName, { cancelable: cancelable, bubbles: bubbles, detail: detail });
    this.element.dispatchEvent(event);
  };

  ElementEvents.prototype.subscribe = function subscribe(eventName, handler) {
    var captureOrOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (typeof handler === 'function') {
      var eventHandler = new EventHandlerImpl(this, eventName, handler, captureOrOptions, false);
      return eventHandler;
    }

    return undefined;
  };

  ElementEvents.prototype.subscribeOnce = function subscribeOnce(eventName, handler) {
    var captureOrOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (typeof handler === 'function') {
      var eventHandler = new EventHandlerImpl(this, eventName, handler, captureOrOptions, true);
      return eventHandler;
    }

    return undefined;
  };

  ElementEvents.prototype.dispose = function dispose(eventName) {
    if (eventName && typeof eventName === 'string') {
      var subscriptions = this.subscriptions[eventName];
      if (subscriptions) {
        while (subscriptions.length) {
          var subscription = subscriptions.pop();
          if (subscription) {
            subscription.dispose();
          }
        }
      }
    } else {
      this.disposeAll();
    }
  };

  ElementEvents.prototype.disposeAll = function disposeAll() {
    for (var key in this.subscriptions) {
      this.dispose(key);
    }
  };

  return ElementEvents;
}();

var EventHandlerImpl = function () {
  function EventHandlerImpl(owner, eventName, handler, captureOrOptions, once) {
    

    this.owner = owner;
    this.eventName = eventName;
    this.handler = handler;

    this.capture = typeof captureOrOptions === 'boolean' ? captureOrOptions : captureOrOptions.capture;
    this.bubbles = !this.capture;
    this.captureOrOptions = captureOrOptions;
    this.once = once;
    owner.element.addEventListener(eventName, this, captureOrOptions);
    owner._enqueueHandler(this);
  }

  EventHandlerImpl.prototype.handleEvent = function handleEvent(e) {
    var fn = this.handler;
    fn(e);
    if (this.once) {
      this.dispose();
    }
  };

  EventHandlerImpl.prototype.dispose = function dispose() {
    this.owner.element.removeEventListener(this.eventName, this, this.captureOrOptions);
    this.owner._dequeueHandler(this);
    this.owner = this.handler = null;
  };

  return EventHandlerImpl;
}();

var ResourceLoadContext = exports.ResourceLoadContext = function () {
  function ResourceLoadContext() {
    

    this.dependencies = {};
  }

  ResourceLoadContext.prototype.addDependency = function addDependency(url) {
    this.dependencies[url] = true;
  };

  ResourceLoadContext.prototype.hasDependency = function hasDependency(url) {
    return url in this.dependencies;
  };

  return ResourceLoadContext;
}();

var ViewCompileInstruction = exports.ViewCompileInstruction = function ViewCompileInstruction() {
  var targetShadowDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var compileSurrogate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  

  this.targetShadowDOM = targetShadowDOM;
  this.compileSurrogate = compileSurrogate;
  this.associatedModuleId = null;
};

ViewCompileInstruction.normal = new ViewCompileInstruction();

var BehaviorInstruction = exports.BehaviorInstruction = function () {
  BehaviorInstruction.enhance = function enhance() {
    var instruction = new BehaviorInstruction();
    instruction.enhance = true;
    return instruction;
  };

  BehaviorInstruction.unitTest = function unitTest(type, attributes) {
    var instruction = new BehaviorInstruction();
    instruction.type = type;
    instruction.attributes = attributes || {};
    return instruction;
  };

  BehaviorInstruction.element = function element(node, type) {
    var instruction = new BehaviorInstruction();
    instruction.type = type;
    instruction.attributes = {};
    instruction.anchorIsContainer = !(node.hasAttribute('containerless') || type.containerless);
    instruction.initiatedByBehavior = true;
    return instruction;
  };

  BehaviorInstruction.attribute = function attribute(attrName, type) {
    var instruction = new BehaviorInstruction();
    instruction.attrName = attrName;
    instruction.type = type || null;
    instruction.attributes = {};
    return instruction;
  };

  BehaviorInstruction.dynamic = function dynamic(host, viewModel, viewFactory) {
    var instruction = new BehaviorInstruction();
    instruction.host = host;
    instruction.viewModel = viewModel;
    instruction.viewFactory = viewFactory;
    instruction.inheritBindingContext = true;
    return instruction;
  };

  function BehaviorInstruction() {
    

    this.initiatedByBehavior = false;
    this.enhance = false;
    this.partReplacements = null;
    this.viewFactory = null;
    this.originalAttrName = null;
    this.skipContentProcessing = false;
    this.contentFactory = null;
    this.viewModel = null;
    this.anchorIsContainer = false;
    this.host = null;
    this.attributes = null;
    this.type = null;
    this.attrName = null;
    this.inheritBindingContext = false;
  }

  return BehaviorInstruction;
}();

BehaviorInstruction.normal = new BehaviorInstruction();

var TargetInstruction = exports.TargetInstruction = (_temp = _class = function () {
  TargetInstruction.shadowSlot = function shadowSlot(parentInjectorId) {
    var instruction = new TargetInstruction();
    instruction.parentInjectorId = parentInjectorId;
    instruction.shadowSlot = true;
    return instruction;
  };

  TargetInstruction.contentExpression = function contentExpression(expression) {
    var instruction = new TargetInstruction();
    instruction.contentExpression = expression;
    return instruction;
  };

  TargetInstruction.lifting = function lifting(parentInjectorId, liftingInstruction) {
    var instruction = new TargetInstruction();
    instruction.parentInjectorId = parentInjectorId;
    instruction.expressions = TargetInstruction.noExpressions;
    instruction.behaviorInstructions = [liftingInstruction];
    instruction.viewFactory = liftingInstruction.viewFactory;
    instruction.providers = [liftingInstruction.type.target];
    instruction.lifting = true;
    return instruction;
  };

  TargetInstruction.normal = function normal(injectorId, parentInjectorId, providers, behaviorInstructions, expressions, elementInstruction) {
    var instruction = new TargetInstruction();
    instruction.injectorId = injectorId;
    instruction.parentInjectorId = parentInjectorId;
    instruction.providers = providers;
    instruction.behaviorInstructions = behaviorInstructions;
    instruction.expressions = expressions;
    instruction.anchorIsContainer = elementInstruction ? elementInstruction.anchorIsContainer : true;
    instruction.elementInstruction = elementInstruction;
    return instruction;
  };

  TargetInstruction.surrogate = function surrogate(providers, behaviorInstructions, expressions, values) {
    var instruction = new TargetInstruction();
    instruction.expressions = expressions;
    instruction.behaviorInstructions = behaviorInstructions;
    instruction.providers = providers;
    instruction.values = values;
    return instruction;
  };

  function TargetInstruction() {
    

    this.injectorId = null;
    this.parentInjectorId = null;

    this.shadowSlot = false;
    this.slotName = null;
    this.slotFallbackFactory = null;

    this.contentExpression = null;

    this.expressions = null;
    this.behaviorInstructions = null;
    this.providers = null;

    this.viewFactory = null;

    this.anchorIsContainer = false;
    this.elementInstruction = null;
    this.lifting = false;

    this.values = null;
  }

  return TargetInstruction;
}(), _class.noExpressions = Object.freeze([]), _temp);
var viewStrategy = exports.viewStrategy = _aureliaMetadata.protocol.create('aurelia:view-strategy', {
  validate: function validate(target) {
    if (!(typeof target.loadViewFactory === 'function')) {
      return 'View strategies must implement: loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewFactory>';
    }

    return true;
  },
  compose: function compose(target) {
    if (!(typeof target.makeRelativeTo === 'function')) {
      target.makeRelativeTo = _aureliaPal.PLATFORM.noop;
    }
  }
});

var RelativeViewStrategy = exports.RelativeViewStrategy = (_dec = viewStrategy(), _dec(_class2 = function () {
  function RelativeViewStrategy(path) {
    

    this.path = path;
    this.absolutePath = null;
  }

  RelativeViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
    if (this.absolutePath === null && this.moduleId) {
      this.absolutePath = (0, _aureliaPath.relativeToFile)(this.path, this.moduleId);
    }

    compileInstruction.associatedModuleId = this.moduleId;
    return viewEngine.loadViewFactory(this.absolutePath || this.path, compileInstruction, loadContext, target);
  };

  RelativeViewStrategy.prototype.makeRelativeTo = function makeRelativeTo(file) {
    if (this.absolutePath === null) {
      this.absolutePath = (0, _aureliaPath.relativeToFile)(this.path, file);
    }
  };

  return RelativeViewStrategy;
}()) || _class2);
var ConventionalViewStrategy = exports.ConventionalViewStrategy = (_dec2 = viewStrategy(), _dec2(_class3 = function () {
  function ConventionalViewStrategy(viewLocator, origin) {
    

    this.moduleId = origin.moduleId;
    this.viewUrl = viewLocator.convertOriginToViewUrl(origin);
  }

  ConventionalViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
    compileInstruction.associatedModuleId = this.moduleId;
    return viewEngine.loadViewFactory(this.viewUrl, compileInstruction, loadContext, target);
  };

  return ConventionalViewStrategy;
}()) || _class3);
var NoViewStrategy = exports.NoViewStrategy = (_dec3 = viewStrategy(), _dec3(_class4 = function () {
  function NoViewStrategy(dependencies, dependencyBaseUrl) {
    

    this.dependencies = dependencies || null;
    this.dependencyBaseUrl = dependencyBaseUrl || '';
  }

  NoViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
    var entry = this.entry;
    var dependencies = this.dependencies;

    if (entry && entry.factoryIsReady) {
      return Promise.resolve(null);
    }

    this.entry = entry = new _aureliaLoader.TemplateRegistryEntry(this.moduleId || this.dependencyBaseUrl);

    entry.dependencies = [];
    entry.templateIsLoaded = true;

    if (dependencies !== null) {
      for (var i = 0, ii = dependencies.length; i < ii; ++i) {
        var current = dependencies[i];

        if (typeof current === 'string' || typeof current === 'function') {
          entry.addDependency(current);
        } else {
          entry.addDependency(current.from, current.as);
        }
      }
    }

    compileInstruction.associatedModuleId = this.moduleId;

    return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
  };

  return NoViewStrategy;
}()) || _class4);
var TemplateRegistryViewStrategy = exports.TemplateRegistryViewStrategy = (_dec4 = viewStrategy(), _dec4(_class5 = function () {
  function TemplateRegistryViewStrategy(moduleId, entry) {
    

    this.moduleId = moduleId;
    this.entry = entry;
  }

  TemplateRegistryViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
    var entry = this.entry;

    if (entry.factoryIsReady) {
      return Promise.resolve(entry.factory);
    }

    compileInstruction.associatedModuleId = this.moduleId;
    return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
  };

  return TemplateRegistryViewStrategy;
}()) || _class5);
var InlineViewStrategy = exports.InlineViewStrategy = (_dec5 = viewStrategy(), _dec5(_class6 = function () {
  function InlineViewStrategy(markup, dependencies, dependencyBaseUrl) {
    

    this.markup = markup;
    this.dependencies = dependencies || null;
    this.dependencyBaseUrl = dependencyBaseUrl || '';
  }

  InlineViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
    var entry = this.entry;
    var dependencies = this.dependencies;

    if (entry && entry.factoryIsReady) {
      return Promise.resolve(entry.factory);
    }

    this.entry = entry = new _aureliaLoader.TemplateRegistryEntry(this.moduleId || this.dependencyBaseUrl);
    entry.template = _aureliaPal.DOM.createTemplateFromMarkup(this.markup);

    if (dependencies !== null) {
      for (var i = 0, ii = dependencies.length; i < ii; ++i) {
        var current = dependencies[i];

        if (typeof current === 'string' || typeof current === 'function') {
          entry.addDependency(current);
        } else {
          entry.addDependency(current.from, current.as);
        }
      }
    }

    compileInstruction.associatedModuleId = this.moduleId;
    return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
  };

  return InlineViewStrategy;
}()) || _class6);
var ViewLocator = exports.ViewLocator = (_temp2 = _class7 = function () {
  function ViewLocator() {
    
  }

  ViewLocator.prototype.getViewStrategy = function getViewStrategy(value) {
    if (!value) {
      return null;
    }

    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && 'getViewStrategy' in value) {
      var _origin = _aureliaMetadata.Origin.get(value.constructor);

      value = value.getViewStrategy();

      if (typeof value === 'string') {
        value = new RelativeViewStrategy(value);
      }

      viewStrategy.assert(value);

      if (_origin.moduleId) {
        value.makeRelativeTo(_origin.moduleId);
      }

      return value;
    }

    if (typeof value === 'string') {
      value = new RelativeViewStrategy(value);
    }

    if (viewStrategy.validate(value)) {
      return value;
    }

    if (typeof value !== 'function') {
      value = value.constructor;
    }

    var origin = _aureliaMetadata.Origin.get(value);
    var strategy = _aureliaMetadata.metadata.get(ViewLocator.viewStrategyMetadataKey, value);

    if (!strategy) {
      if (!origin.moduleId) {
        throw new Error('Cannot determine default view strategy for object.', value);
      }

      strategy = this.createFallbackViewStrategy(origin);
    } else if (origin.moduleId) {
      strategy.moduleId = origin.moduleId;
    }

    return strategy;
  };

  ViewLocator.prototype.createFallbackViewStrategy = function createFallbackViewStrategy(origin) {
    return new ConventionalViewStrategy(this, origin);
  };

  ViewLocator.prototype.convertOriginToViewUrl = function convertOriginToViewUrl(origin) {
    var moduleId = origin.moduleId;
    var id = moduleId.endsWith('.js') || moduleId.endsWith('.ts') ? moduleId.substring(0, moduleId.length - 3) : moduleId;
    return id + '.html';
  };

  return ViewLocator;
}(), _class7.viewStrategyMetadataKey = 'aurelia:view-strategy', _temp2);


function mi(name) {
  throw new Error('BindingLanguage must implement ' + name + '().');
}

var BindingLanguage = exports.BindingLanguage = function () {
  function BindingLanguage() {
    
  }

  BindingLanguage.prototype.inspectAttribute = function inspectAttribute(resources, elementName, attrName, attrValue) {
    mi('inspectAttribute');
  };

  BindingLanguage.prototype.createAttributeInstruction = function createAttributeInstruction(resources, element, info, existingInstruction) {
    mi('createAttributeInstruction');
  };

  BindingLanguage.prototype.inspectTextContent = function inspectTextContent(resources, value) {
    mi('inspectTextContent');
  };

  return BindingLanguage;
}();

var noNodes = Object.freeze([]);

var SlotCustomAttribute = exports.SlotCustomAttribute = (_dec6 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element), _dec6(_class8 = function () {
  function SlotCustomAttribute(element) {
    

    this.element = element;
    this.element.auSlotAttribute = this;
  }

  SlotCustomAttribute.prototype.valueChanged = function valueChanged(newValue, oldValue) {};

  return SlotCustomAttribute;
}()) || _class8);

var PassThroughSlot = exports.PassThroughSlot = function () {
  function PassThroughSlot(anchor, name, destinationName, fallbackFactory) {
    

    this.anchor = anchor;
    this.anchor.viewSlot = this;
    this.name = name;
    this.destinationName = destinationName;
    this.fallbackFactory = fallbackFactory;
    this.destinationSlot = null;
    this.projections = 0;
    this.contentView = null;

    var attr = new SlotCustomAttribute(this.anchor);
    attr.value = this.destinationName;
  }

  PassThroughSlot.prototype.renderFallbackContent = function renderFallbackContent(view, nodes, projectionSource, index) {
    if (this.contentView === null) {
      this.contentView = this.fallbackFactory.create(this.ownerView.container);
      this.contentView.bind(this.ownerView.bindingContext, this.ownerView.overrideContext);

      var slots = Object.create(null);
      slots[this.destinationSlot.name] = this.destinationSlot;

      ShadowDOM.distributeView(this.contentView, slots, projectionSource, index, this.destinationSlot.name);
    }
  };

  PassThroughSlot.prototype.passThroughTo = function passThroughTo(destinationSlot) {
    this.destinationSlot = destinationSlot;
  };

  PassThroughSlot.prototype.addNode = function addNode(view, node, projectionSource, index) {
    if (this.contentView !== null) {
      this.contentView.removeNodes();
      this.contentView.detached();
      this.contentView.unbind();
      this.contentView = null;
    }

    if (node.viewSlot instanceof PassThroughSlot) {
      node.viewSlot.passThroughTo(this);
      return;
    }

    this.projections++;
    this.destinationSlot.addNode(view, node, projectionSource, index);
  };

  PassThroughSlot.prototype.removeView = function removeView(view, projectionSource) {
    this.projections--;
    this.destinationSlot.removeView(view, projectionSource);

    if (this.needsFallbackRendering) {
      this.renderFallbackContent(null, noNodes, projectionSource);
    }
  };

  PassThroughSlot.prototype.removeAll = function removeAll(projectionSource) {
    this.projections = 0;
    this.destinationSlot.removeAll(projectionSource);

    if (this.needsFallbackRendering) {
      this.renderFallbackContent(null, noNodes, projectionSource);
    }
  };

  PassThroughSlot.prototype.projectFrom = function projectFrom(view, projectionSource) {
    this.destinationSlot.projectFrom(view, projectionSource);
  };

  PassThroughSlot.prototype.created = function created(ownerView) {
    this.ownerView = ownerView;
  };

  PassThroughSlot.prototype.bind = function bind(view) {
    if (this.contentView) {
      this.contentView.bind(view.bindingContext, view.overrideContext);
    }
  };

  PassThroughSlot.prototype.attached = function attached() {
    if (this.contentView) {
      this.contentView.attached();
    }
  };

  PassThroughSlot.prototype.detached = function detached() {
    if (this.contentView) {
      this.contentView.detached();
    }
  };

  PassThroughSlot.prototype.unbind = function unbind() {
    if (this.contentView) {
      this.contentView.unbind();
    }
  };

  _createClass(PassThroughSlot, [{
    key: 'needsFallbackRendering',
    get: function get() {
      return this.fallbackFactory && this.projections === 0;
    }
  }]);

  return PassThroughSlot;
}();

var ShadowSlot = exports.ShadowSlot = function () {
  function ShadowSlot(anchor, name, fallbackFactory) {
    

    this.anchor = anchor;
    this.anchor.isContentProjectionSource = true;
    this.anchor.viewSlot = this;
    this.name = name;
    this.fallbackFactory = fallbackFactory;
    this.contentView = null;
    this.projections = 0;
    this.children = [];
    this.projectFromAnchors = null;
    this.destinationSlots = null;
  }

  ShadowSlot.prototype.addNode = function addNode(view, node, projectionSource, index, destination) {
    if (this.contentView !== null) {
      this.contentView.removeNodes();
      this.contentView.detached();
      this.contentView.unbind();
      this.contentView = null;
    }

    if (node.viewSlot instanceof PassThroughSlot) {
      node.viewSlot.passThroughTo(this);
      return;
    }

    if (this.destinationSlots !== null) {
      ShadowDOM.distributeNodes(view, [node], this.destinationSlots, this, index);
    } else {
      node.auOwnerView = view;
      node.auProjectionSource = projectionSource;
      node.auAssignedSlot = this;

      var anchor = this._findAnchor(view, node, projectionSource, index);
      var parent = anchor.parentNode;

      parent.insertBefore(node, anchor);
      this.children.push(node);
      this.projections++;
    }
  };

  ShadowSlot.prototype.removeView = function removeView(view, projectionSource) {
    if (this.destinationSlots !== null) {
      ShadowDOM.undistributeView(view, this.destinationSlots, this);
    } else if (this.contentView && this.contentView.hasSlots) {
      ShadowDOM.undistributeView(view, this.contentView.slots, projectionSource);
    } else {
      var found = this.children.find(function (x) {
        return x.auSlotProjectFrom === projectionSource;
      });
      if (found) {
        var _children = found.auProjectionChildren;

        for (var i = 0, ii = _children.length; i < ii; ++i) {
          var _child = _children[i];

          if (_child.auOwnerView === view) {
            _children.splice(i, 1);
            view.fragment.appendChild(_child);
            i--;ii--;
            this.projections--;
          }
        }

        if (this.needsFallbackRendering) {
          this.renderFallbackContent(view, noNodes, projectionSource);
        }
      }
    }
  };

  ShadowSlot.prototype.removeAll = function removeAll(projectionSource) {
    if (this.destinationSlots !== null) {
      ShadowDOM.undistributeAll(this.destinationSlots, this);
    } else if (this.contentView && this.contentView.hasSlots) {
      ShadowDOM.undistributeAll(this.contentView.slots, projectionSource);
    } else {
      var found = this.children.find(function (x) {
        return x.auSlotProjectFrom === projectionSource;
      });

      if (found) {
        var _children2 = found.auProjectionChildren;
        for (var i = 0, ii = _children2.length; i < ii; ++i) {
          var _child2 = _children2[i];
          _child2.auOwnerView.fragment.appendChild(_child2);
          this.projections--;
        }

        found.auProjectionChildren = [];

        if (this.needsFallbackRendering) {
          this.renderFallbackContent(null, noNodes, projectionSource);
        }
      }
    }
  };

  ShadowSlot.prototype._findAnchor = function _findAnchor(view, node, projectionSource, index) {
    if (projectionSource) {
      var found = this.children.find(function (x) {
        return x.auSlotProjectFrom === projectionSource;
      });
      if (found) {
        if (index !== undefined) {
          var _children3 = found.auProjectionChildren;
          var viewIndex = -1;
          var lastView = void 0;

          for (var i = 0, ii = _children3.length; i < ii; ++i) {
            var current = _children3[i];

            if (current.auOwnerView !== lastView) {
              viewIndex++;
              lastView = current.auOwnerView;

              if (viewIndex >= index && lastView !== view) {
                _children3.splice(i, 0, node);
                return current;
              }
            }
          }
        }

        found.auProjectionChildren.push(node);
        return found;
      }
    }

    return this.anchor;
  };

  ShadowSlot.prototype.projectTo = function projectTo(slots) {
    this.destinationSlots = slots;
  };

  ShadowSlot.prototype.projectFrom = function projectFrom(view, projectionSource) {
    var anchor = _aureliaPal.DOM.createComment('anchor');
    var parent = this.anchor.parentNode;
    anchor.auSlotProjectFrom = projectionSource;
    anchor.auOwnerView = view;
    anchor.auProjectionChildren = [];
    parent.insertBefore(anchor, this.anchor);
    this.children.push(anchor);

    if (this.projectFromAnchors === null) {
      this.projectFromAnchors = [];
    }

    this.projectFromAnchors.push(anchor);
  };

  ShadowSlot.prototype.renderFallbackContent = function renderFallbackContent(view, nodes, projectionSource, index) {
    if (this.contentView === null) {
      this.contentView = this.fallbackFactory.create(this.ownerView.container);
      this.contentView.bind(this.ownerView.bindingContext, this.ownerView.overrideContext);
      this.contentView.insertNodesBefore(this.anchor);
    }

    if (this.contentView.hasSlots) {
      var slots = this.contentView.slots;
      var projectFromAnchors = this.projectFromAnchors;

      if (projectFromAnchors !== null) {
        for (var slotName in slots) {
          var slot = slots[slotName];

          for (var i = 0, ii = projectFromAnchors.length; i < ii; ++i) {
            var anchor = projectFromAnchors[i];
            slot.projectFrom(anchor.auOwnerView, anchor.auSlotProjectFrom);
          }
        }
      }

      this.fallbackSlots = slots;
      ShadowDOM.distributeNodes(view, nodes, slots, projectionSource, index);
    }
  };

  ShadowSlot.prototype.created = function created(ownerView) {
    this.ownerView = ownerView;
  };

  ShadowSlot.prototype.bind = function bind(view) {
    if (this.contentView) {
      this.contentView.bind(view.bindingContext, view.overrideContext);
    }
  };

  ShadowSlot.prototype.attached = function attached() {
    if (this.contentView) {
      this.contentView.attached();
    }
  };

  ShadowSlot.prototype.detached = function detached() {
    if (this.contentView) {
      this.contentView.detached();
    }
  };

  ShadowSlot.prototype.unbind = function unbind() {
    if (this.contentView) {
      this.contentView.unbind();
    }
  };

  _createClass(ShadowSlot, [{
    key: 'needsFallbackRendering',
    get: function get() {
      return this.fallbackFactory && this.projections === 0;
    }
  }]);

  return ShadowSlot;
}();

var ShadowDOM = exports.ShadowDOM = (_temp3 = _class9 = function () {
  function ShadowDOM() {
    
  }

  ShadowDOM.getSlotName = function getSlotName(node) {
    if (node.auSlotAttribute === undefined) {
      return ShadowDOM.defaultSlotKey;
    }

    return node.auSlotAttribute.value;
  };

  ShadowDOM.distributeView = function distributeView(view, slots, projectionSource, index, destinationOverride) {
    var nodes = void 0;

    if (view === null) {
      nodes = noNodes;
    } else {
      var childNodes = view.fragment.childNodes;
      var ii = childNodes.length;
      nodes = new Array(ii);

      for (var i = 0; i < ii; ++i) {
        nodes[i] = childNodes[i];
      }
    }

    ShadowDOM.distributeNodes(view, nodes, slots, projectionSource, index, destinationOverride);
  };

  ShadowDOM.undistributeView = function undistributeView(view, slots, projectionSource) {
    for (var slotName in slots) {
      slots[slotName].removeView(view, projectionSource);
    }
  };

  ShadowDOM.undistributeAll = function undistributeAll(slots, projectionSource) {
    for (var slotName in slots) {
      slots[slotName].removeAll(projectionSource);
    }
  };

  ShadowDOM.distributeNodes = function distributeNodes(view, nodes, slots, projectionSource, index, destinationOverride) {
    for (var i = 0, ii = nodes.length; i < ii; ++i) {
      var currentNode = nodes[i];
      var nodeType = currentNode.nodeType;

      if (currentNode.isContentProjectionSource) {
        currentNode.viewSlot.projectTo(slots);

        for (var slotName in slots) {
          slots[slotName].projectFrom(view, currentNode.viewSlot);
        }

        nodes.splice(i, 1);
        ii--;i--;
      } else if (nodeType === 1 || nodeType === 3 || currentNode.viewSlot instanceof PassThroughSlot) {
        if (nodeType === 3 && _isAllWhitespace(currentNode)) {
          nodes.splice(i, 1);
          ii--;i--;
        } else {
          var found = slots[destinationOverride || ShadowDOM.getSlotName(currentNode)];

          if (found) {
            found.addNode(view, currentNode, projectionSource, index);
            nodes.splice(i, 1);
            ii--;i--;
          }
        }
      } else {
        nodes.splice(i, 1);
        ii--;i--;
      }
    }

    for (var _slotName in slots) {
      var slot = slots[_slotName];

      if (slot.needsFallbackRendering) {
        slot.renderFallbackContent(view, nodes, projectionSource, index);
      }
    }
  };

  return ShadowDOM;
}(), _class9.defaultSlotKey = '__au-default-slot-key__', _temp3);


function register(lookup, name, resource, type) {
  if (!name) {
    return;
  }

  var existing = lookup[name];
  if (existing) {
    if (existing !== resource) {
      throw new Error('Attempted to register ' + type + ' when one with the same name already exists. Name: ' + name + '.');
    }

    return;
  }

  lookup[name] = resource;
}

var ViewResources = exports.ViewResources = function () {
  function ViewResources(parent, viewUrl) {
    

    this.bindingLanguage = null;

    this.parent = parent || null;
    this.hasParent = this.parent !== null;
    this.viewUrl = viewUrl || '';
    this.lookupFunctions = {
      valueConverters: this.getValueConverter.bind(this),
      bindingBehaviors: this.getBindingBehavior.bind(this)
    };
    this.attributes = Object.create(null);
    this.elements = Object.create(null);
    this.valueConverters = Object.create(null);
    this.bindingBehaviors = Object.create(null);
    this.attributeMap = Object.create(null);
    this.values = Object.create(null);
    this.beforeCompile = this.afterCompile = this.beforeCreate = this.afterCreate = this.beforeBind = this.beforeUnbind = false;
  }

  ViewResources.prototype._tryAddHook = function _tryAddHook(obj, name) {
    if (typeof obj[name] === 'function') {
      var func = obj[name].bind(obj);
      var counter = 1;
      var callbackName = void 0;

      while (this[callbackName = name + counter.toString()] !== undefined) {
        counter++;
      }

      this[name] = true;
      this[callbackName] = func;
    }
  };

  ViewResources.prototype._invokeHook = function _invokeHook(name, one, two, three, four) {
    if (this.hasParent) {
      this.parent._invokeHook(name, one, two, three, four);
    }

    if (this[name]) {
      this[name + '1'](one, two, three, four);

      var callbackName = name + '2';
      if (this[callbackName]) {
        this[callbackName](one, two, three, four);

        callbackName = name + '3';
        if (this[callbackName]) {
          this[callbackName](one, two, three, four);

          var counter = 4;

          while (this[callbackName = name + counter.toString()] !== undefined) {
            this[callbackName](one, two, three, four);
            counter++;
          }
        }
      }
    }
  };

  ViewResources.prototype.registerViewEngineHooks = function registerViewEngineHooks(hooks) {
    this._tryAddHook(hooks, 'beforeCompile');
    this._tryAddHook(hooks, 'afterCompile');
    this._tryAddHook(hooks, 'beforeCreate');
    this._tryAddHook(hooks, 'afterCreate');
    this._tryAddHook(hooks, 'beforeBind');
    this._tryAddHook(hooks, 'beforeUnbind');
  };

  ViewResources.prototype.getBindingLanguage = function getBindingLanguage(bindingLanguageFallback) {
    return this.bindingLanguage || (this.bindingLanguage = bindingLanguageFallback);
  };

  ViewResources.prototype.patchInParent = function patchInParent(newParent) {
    var originalParent = this.parent;

    this.parent = newParent || null;
    this.hasParent = this.parent !== null;

    if (newParent.parent === null) {
      newParent.parent = originalParent;
      newParent.hasParent = originalParent !== null;
    }
  };

  ViewResources.prototype.relativeToView = function relativeToView(path) {
    return (0, _aureliaPath.relativeToFile)(path, this.viewUrl);
  };

  ViewResources.prototype.registerElement = function registerElement(tagName, behavior) {
    register(this.elements, tagName, behavior, 'an Element');
  };

  ViewResources.prototype.getElement = function getElement(tagName) {
    return this.elements[tagName] || (this.hasParent ? this.parent.getElement(tagName) : null);
  };

  ViewResources.prototype.mapAttribute = function mapAttribute(attribute) {
    return this.attributeMap[attribute] || (this.hasParent ? this.parent.mapAttribute(attribute) : null);
  };

  ViewResources.prototype.registerAttribute = function registerAttribute(attribute, behavior, knownAttribute) {
    this.attributeMap[attribute] = knownAttribute;
    register(this.attributes, attribute, behavior, 'an Attribute');
  };

  ViewResources.prototype.getAttribute = function getAttribute(attribute) {
    return this.attributes[attribute] || (this.hasParent ? this.parent.getAttribute(attribute) : null);
  };

  ViewResources.prototype.registerValueConverter = function registerValueConverter(name, valueConverter) {
    register(this.valueConverters, name, valueConverter, 'a ValueConverter');
  };

  ViewResources.prototype.getValueConverter = function getValueConverter(name) {
    return this.valueConverters[name] || (this.hasParent ? this.parent.getValueConverter(name) : null);
  };

  ViewResources.prototype.registerBindingBehavior = function registerBindingBehavior(name, bindingBehavior) {
    register(this.bindingBehaviors, name, bindingBehavior, 'a BindingBehavior');
  };

  ViewResources.prototype.getBindingBehavior = function getBindingBehavior(name) {
    return this.bindingBehaviors[name] || (this.hasParent ? this.parent.getBindingBehavior(name) : null);
  };

  ViewResources.prototype.registerValue = function registerValue(name, value) {
    register(this.values, name, value, 'a value');
  };

  ViewResources.prototype.getValue = function getValue(name) {
    return this.values[name] || (this.hasParent ? this.parent.getValue(name) : null);
  };

  return ViewResources;
}();

var View = exports.View = function () {
  function View(container, viewFactory, fragment, controllers, bindings, children, slots) {
    

    this.container = container;
    this.viewFactory = viewFactory;
    this.resources = viewFactory.resources;
    this.fragment = fragment;
    this.firstChild = fragment.firstChild;
    this.lastChild = fragment.lastChild;
    this.controllers = controllers;
    this.bindings = bindings;
    this.children = children;
    this.slots = slots;
    this.hasSlots = false;
    this.fromCache = false;
    this.isBound = false;
    this.isAttached = false;
    this.bindingContext = null;
    this.overrideContext = null;
    this.controller = null;
    this.viewModelScope = null;
    this.animatableElement = undefined;
    this._isUserControlled = false;
    this.contentView = null;

    for (var key in slots) {
      this.hasSlots = true;
      break;
    }
  }

  View.prototype.returnToCache = function returnToCache() {
    this.viewFactory.returnViewToCache(this);
  };

  View.prototype.created = function created() {
    var i = void 0;
    var ii = void 0;
    var controllers = this.controllers;

    for (i = 0, ii = controllers.length; i < ii; ++i) {
      controllers[i].created(this);
    }
  };

  View.prototype.bind = function bind(bindingContext, overrideContext, _systemUpdate) {
    var controllers = void 0;
    var bindings = void 0;
    var children = void 0;
    var i = void 0;
    var ii = void 0;

    if (_systemUpdate && this._isUserControlled) {
      return;
    }

    if (this.isBound) {
      if (this.bindingContext === bindingContext) {
        return;
      }

      this.unbind();
    }

    this.isBound = true;
    this.bindingContext = bindingContext;
    this.overrideContext = overrideContext || (0, _aureliaBinding.createOverrideContext)(bindingContext);

    this.resources._invokeHook('beforeBind', this);

    bindings = this.bindings;
    for (i = 0, ii = bindings.length; i < ii; ++i) {
      bindings[i].bind(this);
    }

    if (this.viewModelScope !== null) {
      bindingContext.bind(this.viewModelScope.bindingContext, this.viewModelScope.overrideContext);
      this.viewModelScope = null;
    }

    controllers = this.controllers;
    for (i = 0, ii = controllers.length; i < ii; ++i) {
      controllers[i].bind(this);
    }

    children = this.children;
    for (i = 0, ii = children.length; i < ii; ++i) {
      children[i].bind(bindingContext, overrideContext, true);
    }

    if (this.hasSlots) {
      ShadowDOM.distributeView(this.contentView, this.slots);
    }
  };

  View.prototype.addBinding = function addBinding(binding) {
    this.bindings.push(binding);

    if (this.isBound) {
      binding.bind(this);
    }
  };

  View.prototype.unbind = function unbind() {
    var controllers = void 0;
    var bindings = void 0;
    var children = void 0;
    var i = void 0;
    var ii = void 0;

    if (this.isBound) {
      this.isBound = false;
      this.resources._invokeHook('beforeUnbind', this);

      if (this.controller !== null) {
        this.controller.unbind();
      }

      bindings = this.bindings;
      for (i = 0, ii = bindings.length; i < ii; ++i) {
        bindings[i].unbind();
      }

      controllers = this.controllers;
      for (i = 0, ii = controllers.length; i < ii; ++i) {
        controllers[i].unbind();
      }

      children = this.children;
      for (i = 0, ii = children.length; i < ii; ++i) {
        children[i].unbind();
      }

      this.bindingContext = null;
      this.overrideContext = null;
    }
  };

  View.prototype.insertNodesBefore = function insertNodesBefore(refNode) {
    refNode.parentNode.insertBefore(this.fragment, refNode);
  };

  View.prototype.appendNodesTo = function appendNodesTo(parent) {
    parent.appendChild(this.fragment);
  };

  View.prototype.removeNodes = function removeNodes() {
    var fragment = this.fragment;
    var current = this.firstChild;
    var end = this.lastChild;
    var next = void 0;

    while (current) {
      next = current.nextSibling;
      fragment.appendChild(current);

      if (current === end) {
        break;
      }

      current = next;
    }
  };

  View.prototype.attached = function attached() {
    var controllers = void 0;
    var children = void 0;
    var i = void 0;
    var ii = void 0;

    if (this.isAttached) {
      return;
    }

    this.isAttached = true;

    if (this.controller !== null) {
      this.controller.attached();
    }

    controllers = this.controllers;
    for (i = 0, ii = controllers.length; i < ii; ++i) {
      controllers[i].attached();
    }

    children = this.children;
    for (i = 0, ii = children.length; i < ii; ++i) {
      children[i].attached();
    }
  };

  View.prototype.detached = function detached() {
    var controllers = void 0;
    var children = void 0;
    var i = void 0;
    var ii = void 0;

    if (this.isAttached) {
      this.isAttached = false;

      if (this.controller !== null) {
        this.controller.detached();
      }

      controllers = this.controllers;
      for (i = 0, ii = controllers.length; i < ii; ++i) {
        controllers[i].detached();
      }

      children = this.children;
      for (i = 0, ii = children.length; i < ii; ++i) {
        children[i].detached();
      }
    }
  };

  return View;
}();

function getAnimatableElement(view) {
  if (view.animatableElement !== undefined) {
    return view.animatableElement;
  }

  var current = view.firstChild;

  while (current && current.nodeType !== 1) {
    current = current.nextSibling;
  }

  if (current && current.nodeType === 1) {
    return view.animatableElement = current.classList.contains('au-animate') ? current : null;
  }

  return view.animatableElement = null;
}

var ViewSlot = exports.ViewSlot = function () {
  function ViewSlot(anchor, anchorIsContainer) {
    var animator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Animator.instance;

    

    this.anchor = anchor;
    this.anchorIsContainer = anchorIsContainer;
    this.bindingContext = null;
    this.overrideContext = null;
    this.animator = animator;
    this.children = [];
    this.isBound = false;
    this.isAttached = false;
    this.contentSelectors = null;
    anchor.viewSlot = this;
    anchor.isContentProjectionSource = false;
  }

  ViewSlot.prototype.animateView = function animateView(view) {
    var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'enter';

    var animatableElement = getAnimatableElement(view);

    if (animatableElement !== null) {
      switch (direction) {
        case 'enter':
          return this.animator.enter(animatableElement);
        case 'leave':
          return this.animator.leave(animatableElement);
        default:
          throw new Error('Invalid animation direction: ' + direction);
      }
    }
  };

  ViewSlot.prototype.transformChildNodesIntoView = function transformChildNodesIntoView() {
    var parent = this.anchor;

    this.children.push({
      fragment: parent,
      firstChild: parent.firstChild,
      lastChild: parent.lastChild,
      returnToCache: function returnToCache() {},
      removeNodes: function removeNodes() {
        var last = void 0;

        while (last = parent.lastChild) {
          parent.removeChild(last);
        }
      },
      created: function created() {},
      bind: function bind() {},
      unbind: function unbind() {},
      attached: function attached() {},
      detached: function detached() {}
    });
  };

  ViewSlot.prototype.bind = function bind(bindingContext, overrideContext) {
    var i = void 0;
    var ii = void 0;
    var children = void 0;

    if (this.isBound) {
      if (this.bindingContext === bindingContext) {
        return;
      }

      this.unbind();
    }

    this.isBound = true;
    this.bindingContext = bindingContext = bindingContext || this.bindingContext;
    this.overrideContext = overrideContext = overrideContext || this.overrideContext;

    children = this.children;
    for (i = 0, ii = children.length; i < ii; ++i) {
      children[i].bind(bindingContext, overrideContext, true);
    }
  };

  ViewSlot.prototype.unbind = function unbind() {
    if (this.isBound) {
      var i = void 0;
      var ii = void 0;
      var _children4 = this.children;

      this.isBound = false;
      this.bindingContext = null;
      this.overrideContext = null;

      for (i = 0, ii = _children4.length; i < ii; ++i) {
        _children4[i].unbind();
      }
    }
  };

  ViewSlot.prototype.add = function add(view) {
    if (this.anchorIsContainer) {
      view.appendNodesTo(this.anchor);
    } else {
      view.insertNodesBefore(this.anchor);
    }

    this.children.push(view);

    if (this.isAttached) {
      view.attached();
      return this.animateView(view, 'enter');
    }
  };

  ViewSlot.prototype.insert = function insert(index, view) {
    var children = this.children;
    var length = children.length;

    if (index === 0 && length === 0 || index >= length) {
      return this.add(view);
    }

    view.insertNodesBefore(children[index].firstChild);
    children.splice(index, 0, view);

    if (this.isAttached) {
      view.attached();
      return this.animateView(view, 'enter');
    }
  };

  ViewSlot.prototype.move = function move(sourceIndex, targetIndex) {
    if (sourceIndex === targetIndex) {
      return;
    }

    var children = this.children;
    var view = children[sourceIndex];

    view.removeNodes();
    view.insertNodesBefore(children[targetIndex].firstChild);
    children.splice(sourceIndex, 1);
    children.splice(targetIndex, 0, view);
  };

  ViewSlot.prototype.remove = function remove(view, returnToCache, skipAnimation) {
    return this.removeAt(this.children.indexOf(view), returnToCache, skipAnimation);
  };

  ViewSlot.prototype.removeMany = function removeMany(viewsToRemove, returnToCache, skipAnimation) {
    var _this2 = this;

    var children = this.children;
    var ii = viewsToRemove.length;
    var i = void 0;
    var rmPromises = [];

    viewsToRemove.forEach(function (child) {
      if (skipAnimation) {
        child.removeNodes();
        return;
      }

      var animation = _this2.animateView(child, 'leave');
      if (animation) {
        rmPromises.push(animation.then(function () {
          return child.removeNodes();
        }));
      } else {
        child.removeNodes();
      }
    });

    var removeAction = function removeAction() {
      if (_this2.isAttached) {
        for (i = 0; i < ii; ++i) {
          viewsToRemove[i].detached();
        }
      }

      if (returnToCache) {
        for (i = 0; i < ii; ++i) {
          viewsToRemove[i].returnToCache();
        }
      }

      for (i = 0; i < ii; ++i) {
        var index = children.indexOf(viewsToRemove[i]);
        if (index >= 0) {
          children.splice(index, 1);
        }
      }
    };

    if (rmPromises.length > 0) {
      return Promise.all(rmPromises).then(function () {
        return removeAction();
      });
    }

    return removeAction();
  };

  ViewSlot.prototype.removeAt = function removeAt(index, returnToCache, skipAnimation) {
    var _this3 = this;

    var view = this.children[index];

    var removeAction = function removeAction() {
      index = _this3.children.indexOf(view);
      view.removeNodes();
      _this3.children.splice(index, 1);

      if (_this3.isAttached) {
        view.detached();
      }

      if (returnToCache) {
        view.returnToCache();
      }

      return view;
    };

    if (!skipAnimation) {
      var animation = this.animateView(view, 'leave');
      if (animation) {
        return animation.then(function () {
          return removeAction();
        });
      }
    }

    return removeAction();
  };

  ViewSlot.prototype.removeAll = function removeAll(returnToCache, skipAnimation) {
    var _this4 = this;

    var children = this.children;
    var ii = children.length;
    var i = void 0;
    var rmPromises = [];

    children.forEach(function (child) {
      if (skipAnimation) {
        child.removeNodes();
        return;
      }

      var animation = _this4.animateView(child, 'leave');
      if (animation) {
        rmPromises.push(animation.then(function () {
          return child.removeNodes();
        }));
      } else {
        child.removeNodes();
      }
    });

    var removeAction = function removeAction() {
      if (_this4.isAttached) {
        for (i = 0; i < ii; ++i) {
          children[i].detached();
        }
      }

      if (returnToCache) {
        for (i = 0; i < ii; ++i) {
          var _child3 = children[i];

          if (_child3) {
            _child3.returnToCache();
          }
        }
      }

      _this4.children = [];
    };

    if (rmPromises.length > 0) {
      return Promise.all(rmPromises).then(function () {
        return removeAction();
      });
    }

    return removeAction();
  };

  ViewSlot.prototype.attached = function attached() {
    var i = void 0;
    var ii = void 0;
    var children = void 0;
    var child = void 0;

    if (this.isAttached) {
      return;
    }

    this.isAttached = true;

    children = this.children;
    for (i = 0, ii = children.length; i < ii; ++i) {
      child = children[i];
      child.attached();
      this.animateView(child, 'enter');
    }
  };

  ViewSlot.prototype.detached = function detached() {
    var i = void 0;
    var ii = void 0;
    var children = void 0;

    if (this.isAttached) {
      this.isAttached = false;
      children = this.children;
      for (i = 0, ii = children.length; i < ii; ++i) {
        children[i].detached();
      }
    }
  };

  ViewSlot.prototype.projectTo = function projectTo(slots) {
    var _this5 = this;

    this.projectToSlots = slots;
    this.add = this._projectionAdd;
    this.insert = this._projectionInsert;
    this.move = this._projectionMove;
    this.remove = this._projectionRemove;
    this.removeAt = this._projectionRemoveAt;
    this.removeMany = this._projectionRemoveMany;
    this.removeAll = this._projectionRemoveAll;
    this.children.forEach(function (view) {
      return ShadowDOM.distributeView(view, slots, _this5);
    });
  };

  ViewSlot.prototype._projectionAdd = function _projectionAdd(view) {
    ShadowDOM.distributeView(view, this.projectToSlots, this);

    this.children.push(view);

    if (this.isAttached) {
      view.attached();
    }
  };

  ViewSlot.prototype._projectionInsert = function _projectionInsert(index, view) {
    if (index === 0 && !this.children.length || index >= this.children.length) {
      this.add(view);
    } else {
      ShadowDOM.distributeView(view, this.projectToSlots, this, index);

      this.children.splice(index, 0, view);

      if (this.isAttached) {
        view.attached();
      }
    }
  };

  ViewSlot.prototype._projectionMove = function _projectionMove(sourceIndex, targetIndex) {
    if (sourceIndex === targetIndex) {
      return;
    }

    var children = this.children;
    var view = children[sourceIndex];

    ShadowDOM.undistributeView(view, this.projectToSlots, this);
    ShadowDOM.distributeView(view, this.projectToSlots, this, targetIndex);

    children.splice(sourceIndex, 1);
    children.splice(targetIndex, 0, view);
  };

  ViewSlot.prototype._projectionRemove = function _projectionRemove(view, returnToCache) {
    ShadowDOM.undistributeView(view, this.projectToSlots, this);
    this.children.splice(this.children.indexOf(view), 1);

    if (this.isAttached) {
      view.detached();
    }
  };

  ViewSlot.prototype._projectionRemoveAt = function _projectionRemoveAt(index, returnToCache) {
    var view = this.children[index];

    ShadowDOM.undistributeView(view, this.projectToSlots, this);
    this.children.splice(index, 1);

    if (this.isAttached) {
      view.detached();
    }
  };

  ViewSlot.prototype._projectionRemoveMany = function _projectionRemoveMany(viewsToRemove, returnToCache) {
    var _this6 = this;

    viewsToRemove.forEach(function (view) {
      return _this6.remove(view, returnToCache);
    });
  };

  ViewSlot.prototype._projectionRemoveAll = function _projectionRemoveAll(returnToCache) {
    ShadowDOM.undistributeAll(this.projectToSlots, this);

    var children = this.children;

    if (this.isAttached) {
      for (var i = 0, ii = children.length; i < ii; ++i) {
        children[i].detached();
      }
    }

    this.children = [];
  };

  return ViewSlot;
}();

var ProviderResolver = (0, _aureliaDependencyInjection.resolver)(_class11 = function () {
  function ProviderResolver() {
    
  }

  ProviderResolver.prototype.get = function get(container, key) {
    var id = key.__providerId__;
    return id in container ? container[id] : container[id] = container.invoke(key);
  };

  return ProviderResolver;
}()) || _class11;

var providerResolverInstance = new ProviderResolver();

function elementContainerGet(key) {
  if (key === _aureliaPal.DOM.Element) {
    return this.element;
  }

  if (key === BoundViewFactory) {
    if (this.boundViewFactory) {
      return this.boundViewFactory;
    }

    var factory = this.instruction.viewFactory;
    var _partReplacements = this.partReplacements;

    if (_partReplacements) {
      factory = _partReplacements[factory.part] || factory;
    }

    this.boundViewFactory = new BoundViewFactory(this, factory, _partReplacements);
    return this.boundViewFactory;
  }

  if (key === ViewSlot) {
    if (this.viewSlot === undefined) {
      this.viewSlot = new ViewSlot(this.element, this.instruction.anchorIsContainer);
      this.element.isContentProjectionSource = this.instruction.lifting;
      this.children.push(this.viewSlot);
    }

    return this.viewSlot;
  }

  if (key === ElementEvents) {
    return this.elementEvents || (this.elementEvents = new ElementEvents(this.element));
  }

  if (key === CompositionTransaction) {
    return this.compositionTransaction || (this.compositionTransaction = this.parent.get(key));
  }

  if (key === ViewResources) {
    return this.viewResources;
  }

  if (key === TargetInstruction) {
    return this.instruction;
  }

  return this.superGet(key);
}

function createElementContainer(parent, element, instruction, children, partReplacements, resources) {
  var container = parent.createChild();
  var providers = void 0;
  var i = void 0;

  container.element = element;
  container.instruction = instruction;
  container.children = children;
  container.viewResources = resources;
  container.partReplacements = partReplacements;

  providers = instruction.providers;
  i = providers.length;

  while (i--) {
    container._resolvers.set(providers[i], providerResolverInstance);
  }

  container.superGet = container.get;
  container.get = elementContainerGet;

  return container;
}

function hasAttribute(name) {
  return this._element.hasAttribute(name);
}

function getAttribute(name) {
  return this._element.getAttribute(name);
}

function setAttribute(name, value) {
  this._element.setAttribute(name, value);
}

function makeElementIntoAnchor(element, elementInstruction) {
  var anchor = _aureliaPal.DOM.createComment('anchor');

  if (elementInstruction) {
    var firstChild = element.firstChild;

    if (firstChild && firstChild.tagName === 'AU-CONTENT') {
      anchor.contentElement = firstChild;
    }

    anchor._element = element;

    anchor.hasAttribute = hasAttribute;
    anchor.getAttribute = getAttribute;
    anchor.setAttribute = setAttribute;
  }

  _aureliaPal.DOM.replaceNode(anchor, element);

  return anchor;
}

function applyInstructions(containers, element, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources) {
  var behaviorInstructions = instruction.behaviorInstructions;
  var expressions = instruction.expressions;
  var elementContainer = void 0;
  var i = void 0;
  var ii = void 0;
  var current = void 0;
  var instance = void 0;

  if (instruction.contentExpression) {
    bindings.push(instruction.contentExpression.createBinding(element.nextSibling));
    element.nextSibling.auInterpolationTarget = true;
    element.parentNode.removeChild(element);
    return;
  }

  if (instruction.shadowSlot) {
    var commentAnchor = _aureliaPal.DOM.createComment('slot');
    var slot = void 0;

    if (instruction.slotDestination) {
      slot = new PassThroughSlot(commentAnchor, instruction.slotName, instruction.slotDestination, instruction.slotFallbackFactory);
    } else {
      slot = new ShadowSlot(commentAnchor, instruction.slotName, instruction.slotFallbackFactory);
    }

    _aureliaPal.DOM.replaceNode(commentAnchor, element);
    shadowSlots[instruction.slotName] = slot;
    controllers.push(slot);
    return;
  }

  if (behaviorInstructions.length) {
    if (!instruction.anchorIsContainer) {
      element = makeElementIntoAnchor(element, instruction.elementInstruction);
    }

    containers[instruction.injectorId] = elementContainer = createElementContainer(containers[instruction.parentInjectorId], element, instruction, children, partReplacements, resources);

    for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
      current = behaviorInstructions[i];
      instance = current.type.create(elementContainer, current, element, bindings);
      controllers.push(instance);
    }
  }

  for (i = 0, ii = expressions.length; i < ii; ++i) {
    bindings.push(expressions[i].createBinding(element));
  }
}

function styleStringToObject(style, target) {
  var attributes = style.split(';');
  var firstIndexOfColon = void 0;
  var i = void 0;
  var current = void 0;
  var key = void 0;
  var value = void 0;

  target = target || {};

  for (i = 0; i < attributes.length; i++) {
    current = attributes[i];
    firstIndexOfColon = current.indexOf(':');
    key = current.substring(0, firstIndexOfColon).trim();
    value = current.substring(firstIndexOfColon + 1).trim();
    target[key] = value;
  }

  return target;
}

function styleObjectToString(obj) {
  var result = '';

  for (var key in obj) {
    result += key + ':' + obj[key] + ';';
  }

  return result;
}

function applySurrogateInstruction(container, element, instruction, controllers, bindings, children) {
  var behaviorInstructions = instruction.behaviorInstructions;
  var expressions = instruction.expressions;
  var providers = instruction.providers;
  var values = instruction.values;
  var i = void 0;
  var ii = void 0;
  var current = void 0;
  var instance = void 0;
  var currentAttributeValue = void 0;

  i = providers.length;
  while (i--) {
    container._resolvers.set(providers[i], providerResolverInstance);
  }

  for (var key in values) {
    currentAttributeValue = element.getAttribute(key);

    if (currentAttributeValue) {
      if (key === 'class') {
        element.setAttribute('class', currentAttributeValue + ' ' + values[key]);
      } else if (key === 'style') {
        var styleObject = styleStringToObject(values[key]);
        styleStringToObject(currentAttributeValue, styleObject);
        element.setAttribute('style', styleObjectToString(styleObject));
      }
    } else {
      element.setAttribute(key, values[key]);
    }
  }

  if (behaviorInstructions.length) {
    for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
      current = behaviorInstructions[i];
      instance = current.type.create(container, current, element, bindings);

      if (instance.contentView) {
        children.push(instance.contentView);
      }

      controllers.push(instance);
    }
  }

  for (i = 0, ii = expressions.length; i < ii; ++i) {
    bindings.push(expressions[i].createBinding(element));
  }
}

var BoundViewFactory = exports.BoundViewFactory = function () {
  function BoundViewFactory(parentContainer, viewFactory, partReplacements) {
    

    this.parentContainer = parentContainer;
    this.viewFactory = viewFactory;
    this.factoryCreateInstruction = { partReplacements: partReplacements };
  }

  BoundViewFactory.prototype.create = function create() {
    var view = this.viewFactory.create(this.parentContainer.createChild(), this.factoryCreateInstruction);
    view._isUserControlled = true;
    return view;
  };

  BoundViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
    this.viewFactory.setCacheSize(size, doNotOverrideIfAlreadySet);
  };

  BoundViewFactory.prototype.getCachedView = function getCachedView() {
    return this.viewFactory.getCachedView();
  };

  BoundViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
    this.viewFactory.returnViewToCache(view);
  };

  _createClass(BoundViewFactory, [{
    key: 'isCaching',
    get: function get() {
      return this.viewFactory.isCaching;
    }
  }]);

  return BoundViewFactory;
}();

var ViewFactory = exports.ViewFactory = function () {
  function ViewFactory(template, instructions, resources) {
    

    this.isCaching = false;

    this.template = template;
    this.instructions = instructions;
    this.resources = resources;
    this.cacheSize = -1;
    this.cache = null;
  }

  ViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
    if (size) {
      if (size === '*') {
        size = Number.MAX_VALUE;
      } else if (typeof size === 'string') {
        size = parseInt(size, 10);
      }
    }

    if (this.cacheSize === -1 || !doNotOverrideIfAlreadySet) {
      this.cacheSize = size;
    }

    if (this.cacheSize > 0) {
      this.cache = [];
    } else {
      this.cache = null;
    }

    this.isCaching = this.cacheSize > 0;
  };

  ViewFactory.prototype.getCachedView = function getCachedView() {
    return this.cache !== null ? this.cache.pop() || null : null;
  };

  ViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
    if (view.isAttached) {
      view.detached();
    }

    if (view.isBound) {
      view.unbind();
    }

    if (this.cache !== null && this.cache.length < this.cacheSize) {
      view.fromCache = true;
      this.cache.push(view);
    }
  };

  ViewFactory.prototype.create = function create(container, createInstruction, element) {
    createInstruction = createInstruction || BehaviorInstruction.normal;

    var cachedView = this.getCachedView();
    if (cachedView !== null) {
      return cachedView;
    }

    var fragment = createInstruction.enhance ? this.template : this.template.cloneNode(true);
    var instructables = fragment.querySelectorAll('.au-target');
    var instructions = this.instructions;
    var resources = this.resources;
    var controllers = [];
    var bindings = [];
    var children = [];
    var shadowSlots = Object.create(null);
    var containers = { root: container };
    var partReplacements = createInstruction.partReplacements;
    var i = void 0;
    var ii = void 0;
    var view = void 0;
    var instructable = void 0;
    var instruction = void 0;

    this.resources._invokeHook('beforeCreate', this, container, fragment, createInstruction);

    if (element && this.surrogateInstruction !== null) {
      applySurrogateInstruction(container, element, this.surrogateInstruction, controllers, bindings, children);
    }

    if (createInstruction.enhance && fragment.hasAttribute('au-target-id')) {
      instructable = fragment;
      instruction = instructions[instructable.getAttribute('au-target-id')];
      applyInstructions(containers, instructable, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources);
    }

    for (i = 0, ii = instructables.length; i < ii; ++i) {
      instructable = instructables[i];
      instruction = instructions[instructable.getAttribute('au-target-id')];
      applyInstructions(containers, instructable, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources);
    }

    view = new View(container, this, fragment, controllers, bindings, children, shadowSlots);

    if (!createInstruction.initiatedByBehavior) {
      view.created();
    }

    this.resources._invokeHook('afterCreate', view);

    return view;
  };

  return ViewFactory;
}();

var nextInjectorId = 0;
function getNextInjectorId() {
  return ++nextInjectorId;
}

var lastAUTargetID = 0;
function getNextAUTargetID() {
  return (++lastAUTargetID).toString();
}

function makeIntoInstructionTarget(element) {
  var value = element.getAttribute('class');
  var auTargetID = getNextAUTargetID();

  element.setAttribute('class', value ? value + ' au-target' : 'au-target');
  element.setAttribute('au-target-id', auTargetID);

  return auTargetID;
}

function makeShadowSlot(compiler, resources, node, instructions, parentInjectorId) {
  var auShadowSlot = _aureliaPal.DOM.createElement('au-shadow-slot');
  _aureliaPal.DOM.replaceNode(auShadowSlot, node);

  var auTargetID = makeIntoInstructionTarget(auShadowSlot);
  var instruction = TargetInstruction.shadowSlot(parentInjectorId);

  instruction.slotName = node.getAttribute('name') || ShadowDOM.defaultSlotKey;
  instruction.slotDestination = node.getAttribute('slot');

  if (node.innerHTML.trim()) {
    var fragment = _aureliaPal.DOM.createDocumentFragment();
    var _child4 = void 0;

    while (_child4 = node.firstChild) {
      fragment.appendChild(_child4);
    }

    instruction.slotFallbackFactory = compiler.compile(fragment, resources);
  }

  instructions[auTargetID] = instruction;

  return auShadowSlot;
}

var ViewCompiler = exports.ViewCompiler = (_dec7 = (0, _aureliaDependencyInjection.inject)(BindingLanguage, ViewResources), _dec7(_class13 = function () {
  function ViewCompiler(bindingLanguage, resources) {
    

    this.bindingLanguage = bindingLanguage;
    this.resources = resources;
  }

  ViewCompiler.prototype.compile = function compile(source, resources, compileInstruction) {
    resources = resources || this.resources;
    compileInstruction = compileInstruction || ViewCompileInstruction.normal;
    source = typeof source === 'string' ? _aureliaPal.DOM.createTemplateFromMarkup(source) : source;

    var content = void 0;
    var part = void 0;
    var cacheSize = void 0;

    if (source.content) {
      part = source.getAttribute('part');
      cacheSize = source.getAttribute('view-cache');
      content = _aureliaPal.DOM.adoptNode(source.content);
    } else {
      content = source;
    }

    compileInstruction.targetShadowDOM = compileInstruction.targetShadowDOM && _aureliaPal.FEATURE.shadowDOM;
    resources._invokeHook('beforeCompile', content, resources, compileInstruction);

    var instructions = {};
    this._compileNode(content, resources, instructions, source, 'root', !compileInstruction.targetShadowDOM);

    var firstChild = content.firstChild;
    if (firstChild && firstChild.nodeType === 1) {
      var targetId = firstChild.getAttribute('au-target-id');
      if (targetId) {
        var ins = instructions[targetId];

        if (ins.shadowSlot || ins.lifting || ins.elementInstruction && !ins.elementInstruction.anchorIsContainer) {
          content.insertBefore(_aureliaPal.DOM.createComment('view'), firstChild);
        }
      }
    }

    var factory = new ViewFactory(content, instructions, resources);

    factory.surrogateInstruction = compileInstruction.compileSurrogate ? this._compileSurrogate(source, resources) : null;
    factory.part = part;

    if (cacheSize) {
      factory.setCacheSize(cacheSize);
    }

    resources._invokeHook('afterCompile', factory);

    return factory;
  };

  ViewCompiler.prototype._compileNode = function _compileNode(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM) {
    switch (node.nodeType) {
      case 1:
        return this._compileElement(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM);
      case 3:
        var expression = resources.getBindingLanguage(this.bindingLanguage).inspectTextContent(resources, node.wholeText);
        if (expression) {
          var marker = _aureliaPal.DOM.createElement('au-marker');
          var auTargetID = makeIntoInstructionTarget(marker);
          (node.parentNode || parentNode).insertBefore(marker, node);
          node.textContent = ' ';
          instructions[auTargetID] = TargetInstruction.contentExpression(expression);

          while (node.nextSibling && node.nextSibling.nodeType === 3) {
            (node.parentNode || parentNode).removeChild(node.nextSibling);
          }
        } else {
          while (node.nextSibling && node.nextSibling.nodeType === 3) {
            node = node.nextSibling;
          }
        }
        return node.nextSibling;
      case 11:
        var currentChild = node.firstChild;
        while (currentChild) {
          currentChild = this._compileNode(currentChild, resources, instructions, node, parentInjectorId, targetLightDOM);
        }
        break;
      default:
        break;
    }

    return node.nextSibling;
  };

  ViewCompiler.prototype._compileSurrogate = function _compileSurrogate(node, resources) {
    var tagName = node.tagName.toLowerCase();
    var attributes = node.attributes;
    var bindingLanguage = resources.getBindingLanguage(this.bindingLanguage);
    var knownAttribute = void 0;
    var property = void 0;
    var instruction = void 0;
    var i = void 0;
    var ii = void 0;
    var attr = void 0;
    var attrName = void 0;
    var attrValue = void 0;
    var info = void 0;
    var type = void 0;
    var expressions = [];
    var expression = void 0;
    var behaviorInstructions = [];
    var values = {};
    var hasValues = false;
    var providers = [];

    for (i = 0, ii = attributes.length; i < ii; ++i) {
      attr = attributes[i];
      attrName = attr.name;
      attrValue = attr.value;

      info = bindingLanguage.inspectAttribute(resources, tagName, attrName, attrValue);
      type = resources.getAttribute(info.attrName);

      if (type) {
        knownAttribute = resources.mapAttribute(info.attrName);
        if (knownAttribute) {
          property = type.attributes[knownAttribute];

          if (property) {
            info.defaultBindingMode = property.defaultBindingMode;

            if (!info.command && !info.expression) {
              info.command = property.hasOptions ? 'options' : null;
            }

            if (info.command && info.command !== 'options' && type.primaryProperty) {
              var primaryProperty = type.primaryProperty;
              attrName = info.attrName = primaryProperty.attribute;

              info.defaultBindingMode = primaryProperty.defaultBindingMode;
            }
          }
        }
      }

      instruction = bindingLanguage.createAttributeInstruction(resources, node, info, undefined, type);

      if (instruction) {
        if (instruction.alteredAttr) {
          type = resources.getAttribute(instruction.attrName);
        }

        if (instruction.discrete) {
          expressions.push(instruction);
        } else {
          if (type) {
            instruction.type = type;
            this._configureProperties(instruction, resources);

            if (type.liftsContent) {
              throw new Error('You cannot place a template controller on a surrogate element.');
            } else {
              behaviorInstructions.push(instruction);
            }
          } else {
            expressions.push(instruction.attributes[instruction.attrName]);
          }
        }
      } else {
        if (type) {
          instruction = BehaviorInstruction.attribute(attrName, type);
          instruction.attributes[resources.mapAttribute(attrName)] = attrValue;

          if (type.liftsContent) {
            throw new Error('You cannot place a template controller on a surrogate element.');
          } else {
            behaviorInstructions.push(instruction);
          }
        } else if (attrName !== 'id' && attrName !== 'part' && attrName !== 'replace-part') {
          hasValues = true;
          values[attrName] = attrValue;
        }
      }
    }

    if (expressions.length || behaviorInstructions.length || hasValues) {
      for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
        instruction = behaviorInstructions[i];
        instruction.type.compile(this, resources, node, instruction);
        providers.push(instruction.type.target);
      }

      for (i = 0, ii = expressions.length; i < ii; ++i) {
        expression = expressions[i];
        if (expression.attrToRemove !== undefined) {
          node.removeAttribute(expression.attrToRemove);
        }
      }

      return TargetInstruction.surrogate(providers, behaviorInstructions, expressions, values);
    }

    return null;
  };

  ViewCompiler.prototype._compileElement = function _compileElement(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM) {
    var tagName = node.tagName.toLowerCase();
    var attributes = node.attributes;
    var expressions = [];
    var expression = void 0;
    var behaviorInstructions = [];
    var providers = [];
    var bindingLanguage = resources.getBindingLanguage(this.bindingLanguage);
    var liftingInstruction = void 0;
    var viewFactory = void 0;
    var type = void 0;
    var elementInstruction = void 0;
    var elementProperty = void 0;
    var i = void 0;
    var ii = void 0;
    var attr = void 0;
    var attrName = void 0;
    var attrValue = void 0;
    var originalAttrName = void 0;
    var instruction = void 0;
    var info = void 0;
    var property = void 0;
    var knownAttribute = void 0;
    var auTargetID = void 0;
    var injectorId = void 0;

    if (tagName === 'slot') {
      if (targetLightDOM) {
        node = makeShadowSlot(this, resources, node, instructions, parentInjectorId);
      }
      return node.nextSibling;
    } else if (tagName === 'template') {
      if (!('content' in node)) {
        throw new Error('You cannot place a template element within ' + node.namespaceURI + ' namespace');
      }
      viewFactory = this.compile(node, resources);
      viewFactory.part = node.getAttribute('part');
    } else {
      type = resources.getElement(node.getAttribute('as-element') || tagName);
      if (type) {
        elementInstruction = BehaviorInstruction.element(node, type);
        type.processAttributes(this, resources, node, attributes, elementInstruction);
        behaviorInstructions.push(elementInstruction);
      }
    }

    for (i = 0, ii = attributes.length; i < ii; ++i) {
      attr = attributes[i];
      originalAttrName = attrName = attr.name;
      attrValue = attr.value;
      info = bindingLanguage.inspectAttribute(resources, tagName, attrName, attrValue);

      if (targetLightDOM && info.attrName === 'slot') {
        info.attrName = attrName = 'au-slot';
      }

      type = resources.getAttribute(info.attrName);
      elementProperty = null;

      if (type) {
        knownAttribute = resources.mapAttribute(info.attrName);
        if (knownAttribute) {
          property = type.attributes[knownAttribute];

          if (property) {
            info.defaultBindingMode = property.defaultBindingMode;

            if (!info.command && !info.expression) {
              info.command = property.hasOptions ? 'options' : null;
            }

            if (info.command && info.command !== 'options' && type.primaryProperty) {
              var primaryProperty = type.primaryProperty;
              attrName = info.attrName = primaryProperty.attribute;

              info.defaultBindingMode = primaryProperty.defaultBindingMode;
            }
          }
        }
      } else if (elementInstruction) {
        elementProperty = elementInstruction.type.attributes[info.attrName];
        if (elementProperty) {
          info.defaultBindingMode = elementProperty.defaultBindingMode;
        }
      }

      if (elementProperty) {
        instruction = bindingLanguage.createAttributeInstruction(resources, node, info, elementInstruction);
      } else {
        instruction = bindingLanguage.createAttributeInstruction(resources, node, info, undefined, type);
      }

      if (instruction) {
        if (instruction.alteredAttr) {
          type = resources.getAttribute(instruction.attrName);
        }

        if (instruction.discrete) {
          expressions.push(instruction);
        } else {
          if (type) {
            instruction.type = type;
            this._configureProperties(instruction, resources);

            if (type.liftsContent) {
              instruction.originalAttrName = originalAttrName;
              liftingInstruction = instruction;
              break;
            } else {
              behaviorInstructions.push(instruction);
            }
          } else if (elementProperty) {
            elementInstruction.attributes[info.attrName].targetProperty = elementProperty.name;
          } else {
            expressions.push(instruction.attributes[instruction.attrName]);
          }
        }
      } else {
        if (type) {
          instruction = BehaviorInstruction.attribute(attrName, type);
          instruction.attributes[resources.mapAttribute(attrName)] = attrValue;

          if (type.liftsContent) {
            instruction.originalAttrName = originalAttrName;
            liftingInstruction = instruction;
            break;
          } else {
            behaviorInstructions.push(instruction);
          }
        } else if (elementProperty) {
          elementInstruction.attributes[attrName] = attrValue;
        }
      }
    }

    if (liftingInstruction) {
      liftingInstruction.viewFactory = viewFactory;
      node = liftingInstruction.type.compile(this, resources, node, liftingInstruction, parentNode);
      auTargetID = makeIntoInstructionTarget(node);
      instructions[auTargetID] = TargetInstruction.lifting(parentInjectorId, liftingInstruction);
    } else {
      var skipContentProcessing = false;

      if (expressions.length || behaviorInstructions.length) {
        injectorId = behaviorInstructions.length ? getNextInjectorId() : false;

        for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
          instruction = behaviorInstructions[i];
          instruction.type.compile(this, resources, node, instruction, parentNode);
          providers.push(instruction.type.target);
          skipContentProcessing = skipContentProcessing || instruction.skipContentProcessing;
        }

        for (i = 0, ii = expressions.length; i < ii; ++i) {
          expression = expressions[i];
          if (expression.attrToRemove !== undefined) {
            node.removeAttribute(expression.attrToRemove);
          }
        }

        auTargetID = makeIntoInstructionTarget(node);
        instructions[auTargetID] = TargetInstruction.normal(injectorId, parentInjectorId, providers, behaviorInstructions, expressions, elementInstruction);
      }

      if (skipContentProcessing) {
        return node.nextSibling;
      }

      var currentChild = node.firstChild;
      while (currentChild) {
        currentChild = this._compileNode(currentChild, resources, instructions, node, injectorId || parentInjectorId, targetLightDOM);
      }
    }

    return node.nextSibling;
  };

  ViewCompiler.prototype._configureProperties = function _configureProperties(instruction, resources) {
    var type = instruction.type;
    var attrName = instruction.attrName;
    var attributes = instruction.attributes;
    var property = void 0;
    var key = void 0;
    var value = void 0;

    var knownAttribute = resources.mapAttribute(attrName);
    if (knownAttribute && attrName in attributes && knownAttribute !== attrName) {
      attributes[knownAttribute] = attributes[attrName];
      delete attributes[attrName];
    }

    for (key in attributes) {
      value = attributes[key];

      if (value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
        property = type.attributes[key];

        if (property !== undefined) {
          value.targetProperty = property.name;
        } else {
          value.targetProperty = key;
        }
      }
    }
  };

  return ViewCompiler;
}()) || _class13);

var ResourceModule = exports.ResourceModule = function () {
  function ResourceModule(moduleId) {
    

    this.id = moduleId;
    this.moduleInstance = null;
    this.mainResource = null;
    this.resources = null;
    this.viewStrategy = null;
    this.isInitialized = false;
    this.onLoaded = null;
    this.loadContext = null;
  }

  ResourceModule.prototype.initialize = function initialize(container) {
    var current = this.mainResource;
    var resources = this.resources;
    var vs = this.viewStrategy;

    if (this.isInitialized) {
      return;
    }

    this.isInitialized = true;

    if (current !== undefined) {
      current.metadata.viewStrategy = vs;
      current.initialize(container);
    }

    for (var i = 0, ii = resources.length; i < ii; ++i) {
      current = resources[i];
      current.metadata.viewStrategy = vs;
      current.initialize(container);
    }
  };

  ResourceModule.prototype.register = function register(registry, name) {
    var main = this.mainResource;
    var resources = this.resources;

    if (main !== undefined) {
      main.register(registry, name);
      name = null;
    }

    for (var i = 0, ii = resources.length; i < ii; ++i) {
      resources[i].register(registry, name);
      name = null;
    }
  };

  ResourceModule.prototype.load = function load(container, loadContext) {
    if (this.onLoaded !== null) {
      return this.loadContext === loadContext ? Promise.resolve() : this.onLoaded;
    }

    var main = this.mainResource;
    var resources = this.resources;
    var loads = void 0;

    if (main !== undefined) {
      loads = new Array(resources.length + 1);
      loads[0] = main.load(container, loadContext);
      for (var i = 0, ii = resources.length; i < ii; ++i) {
        loads[i + 1] = resources[i].load(container, loadContext);
      }
    } else {
      loads = new Array(resources.length);
      for (var _i = 0, _ii = resources.length; _i < _ii; ++_i) {
        loads[_i] = resources[_i].load(container, loadContext);
      }
    }

    this.loadContext = loadContext;
    this.onLoaded = Promise.all(loads);
    return this.onLoaded;
  };

  return ResourceModule;
}();

var ResourceDescription = exports.ResourceDescription = function () {
  function ResourceDescription(key, exportedValue, resourceTypeMeta) {
    

    if (!resourceTypeMeta) {
      resourceTypeMeta = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.resource, exportedValue);

      if (!resourceTypeMeta) {
        resourceTypeMeta = new HtmlBehaviorResource();
        resourceTypeMeta.elementName = _hyphenate(key);
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, resourceTypeMeta, exportedValue);
      }
    }

    if (resourceTypeMeta instanceof HtmlBehaviorResource) {
      if (resourceTypeMeta.elementName === undefined) {
        resourceTypeMeta.elementName = _hyphenate(key);
      } else if (resourceTypeMeta.attributeName === undefined) {
        resourceTypeMeta.attributeName = _hyphenate(key);
      } else if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
        HtmlBehaviorResource.convention(key, resourceTypeMeta);
      }
    } else if (!resourceTypeMeta.name) {
      resourceTypeMeta.name = _hyphenate(key);
    }

    this.metadata = resourceTypeMeta;
    this.value = exportedValue;
  }

  ResourceDescription.prototype.initialize = function initialize(container) {
    this.metadata.initialize(container, this.value);
  };

  ResourceDescription.prototype.register = function register(registry, name) {
    this.metadata.register(registry, name);
  };

  ResourceDescription.prototype.load = function load(container, loadContext) {
    return this.metadata.load(container, this.value, loadContext);
  };

  return ResourceDescription;
}();

var ModuleAnalyzer = exports.ModuleAnalyzer = function () {
  function ModuleAnalyzer() {
    

    this.cache = Object.create(null);
  }

  ModuleAnalyzer.prototype.getAnalysis = function getAnalysis(moduleId) {
    return this.cache[moduleId];
  };

  ModuleAnalyzer.prototype.analyze = function analyze(moduleId, moduleInstance, mainResourceKey) {
    var mainResource = void 0;
    var fallbackValue = void 0;
    var fallbackKey = void 0;
    var resourceTypeMeta = void 0;
    var key = void 0;
    var exportedValue = void 0;
    var resources = [];
    var conventional = void 0;
    var vs = void 0;
    var resourceModule = void 0;

    resourceModule = this.cache[moduleId];
    if (resourceModule) {
      return resourceModule;
    }

    resourceModule = new ResourceModule(moduleId);
    this.cache[moduleId] = resourceModule;

    if (typeof moduleInstance === 'function') {
      moduleInstance = { 'default': moduleInstance };
    }

    if (mainResourceKey) {
      mainResource = new ResourceDescription(mainResourceKey, moduleInstance[mainResourceKey]);
    }

    for (key in moduleInstance) {
      exportedValue = moduleInstance[key];

      if (key === mainResourceKey || typeof exportedValue !== 'function') {
        continue;
      }

      resourceTypeMeta = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.resource, exportedValue);

      if (resourceTypeMeta) {
        if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
          HtmlBehaviorResource.convention(key, resourceTypeMeta);
        }

        if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
          resourceTypeMeta.elementName = _hyphenate(key);
        }

        if (!mainResource && resourceTypeMeta instanceof HtmlBehaviorResource && resourceTypeMeta.elementName !== null) {
          mainResource = new ResourceDescription(key, exportedValue, resourceTypeMeta);
        } else {
          resources.push(new ResourceDescription(key, exportedValue, resourceTypeMeta));
        }
      } else if (viewStrategy.decorates(exportedValue)) {
        vs = exportedValue;
      } else if (exportedValue instanceof _aureliaLoader.TemplateRegistryEntry) {
        vs = new TemplateRegistryViewStrategy(moduleId, exportedValue);
      } else {
        if (conventional = HtmlBehaviorResource.convention(key)) {
          if (conventional.elementName !== null && !mainResource) {
            mainResource = new ResourceDescription(key, exportedValue, conventional);
          } else {
            resources.push(new ResourceDescription(key, exportedValue, conventional));
          }

          _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, conventional, exportedValue);
        } else if (conventional = _aureliaBinding.ValueConverterResource.convention(key) || _aureliaBinding.BindingBehaviorResource.convention(key) || ViewEngineHooksResource.convention(key)) {
          resources.push(new ResourceDescription(key, exportedValue, conventional));
          _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, conventional, exportedValue);
        } else if (!fallbackValue) {
          fallbackValue = exportedValue;
          fallbackKey = key;
        }
      }
    }

    if (!mainResource && fallbackValue) {
      mainResource = new ResourceDescription(fallbackKey, fallbackValue);
    }

    resourceModule.moduleInstance = moduleInstance;
    resourceModule.mainResource = mainResource;
    resourceModule.resources = resources;
    resourceModule.viewStrategy = vs;

    return resourceModule;
  };

  return ModuleAnalyzer;
}();

var logger = LogManager.getLogger('templating');

function ensureRegistryEntry(loader, urlOrRegistryEntry) {
  if (urlOrRegistryEntry instanceof _aureliaLoader.TemplateRegistryEntry) {
    return Promise.resolve(urlOrRegistryEntry);
  }

  return loader.loadTemplate(urlOrRegistryEntry);
}

var ProxyViewFactory = function () {
  function ProxyViewFactory(promise) {
    var _this7 = this;

    

    promise.then(function (x) {
      return _this7.viewFactory = x;
    });
  }

  ProxyViewFactory.prototype.create = function create(container, bindingContext, createInstruction, element) {
    return this.viewFactory.create(container, bindingContext, createInstruction, element);
  };

  ProxyViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
    this.viewFactory.setCacheSize(size, doNotOverrideIfAlreadySet);
  };

  ProxyViewFactory.prototype.getCachedView = function getCachedView() {
    return this.viewFactory.getCachedView();
  };

  ProxyViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
    this.viewFactory.returnViewToCache(view);
  };

  _createClass(ProxyViewFactory, [{
    key: 'isCaching',
    get: function get() {
      return this.viewFactory.isCaching;
    }
  }]);

  return ProxyViewFactory;
}();

var auSlotBehavior = null;

var ViewEngine = exports.ViewEngine = (_dec8 = (0, _aureliaDependencyInjection.inject)(_aureliaLoader.Loader, _aureliaDependencyInjection.Container, ViewCompiler, ModuleAnalyzer, ViewResources), _dec8(_class14 = (_temp4 = _class15 = function () {
  function ViewEngine(loader, container, viewCompiler, moduleAnalyzer, appResources) {
    

    this.loader = loader;
    this.container = container;
    this.viewCompiler = viewCompiler;
    this.moduleAnalyzer = moduleAnalyzer;
    this.appResources = appResources;
    this._pluginMap = {};

    if (auSlotBehavior === null) {
      auSlotBehavior = new HtmlBehaviorResource();
      auSlotBehavior.attributeName = 'au-slot';
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, auSlotBehavior, SlotCustomAttribute);
    }

    auSlotBehavior.initialize(container, SlotCustomAttribute);
    auSlotBehavior.register(appResources);
  }

  ViewEngine.prototype.addResourcePlugin = function addResourcePlugin(extension, implementation) {
    var name = extension.replace('.', '') + '-resource-plugin';
    this._pluginMap[extension] = name;
    this.loader.addPlugin(name, implementation);
  };

  ViewEngine.prototype.loadViewFactory = function loadViewFactory(urlOrRegistryEntry, compileInstruction, loadContext, target) {
    var _this8 = this;

    loadContext = loadContext || new ResourceLoadContext();

    return ensureRegistryEntry(this.loader, urlOrRegistryEntry).then(function (registryEntry) {
      var url = registryEntry.address;

      if (registryEntry.onReady) {
        if (!loadContext.hasDependency(url)) {
          loadContext.addDependency(url);
          return registryEntry.onReady;
        }

        if (registryEntry.template === null) {
          return registryEntry.onReady;
        }

        return Promise.resolve(new ProxyViewFactory(registryEntry.onReady));
      }

      loadContext.addDependency(url);

      registryEntry.onReady = _this8.loadTemplateResources(registryEntry, compileInstruction, loadContext, target).then(function (resources) {
        registryEntry.resources = resources;

        if (registryEntry.template === null) {
          return registryEntry.factory = null;
        }

        var viewFactory = _this8.viewCompiler.compile(registryEntry.template, resources, compileInstruction);
        return registryEntry.factory = viewFactory;
      });

      return registryEntry.onReady;
    });
  };

  ViewEngine.prototype.loadTemplateResources = function loadTemplateResources(registryEntry, compileInstruction, loadContext, target) {
    var resources = new ViewResources(this.appResources, registryEntry.address);
    var dependencies = registryEntry.dependencies;
    var importIds = void 0;
    var names = void 0;

    compileInstruction = compileInstruction || ViewCompileInstruction.normal;

    if (dependencies.length === 0 && !compileInstruction.associatedModuleId) {
      return Promise.resolve(resources);
    }

    importIds = dependencies.map(function (x) {
      return x.src;
    });
    names = dependencies.map(function (x) {
      return x.name;
    });
    logger.debug('importing resources for ' + registryEntry.address, importIds);

    if (target) {
      var viewModelRequires = _aureliaMetadata.metadata.get(ViewEngine.viewModelRequireMetadataKey, target);
      if (viewModelRequires) {
        var templateImportCount = importIds.length;
        for (var i = 0, ii = viewModelRequires.length; i < ii; ++i) {
          var req = viewModelRequires[i];
          var importId = typeof req === 'function' ? _aureliaMetadata.Origin.get(req).moduleId : (0, _aureliaPath.relativeToFile)(req.src || req, registryEntry.address);

          if (importIds.indexOf(importId) === -1) {
            importIds.push(importId);
            names.push(req.as);
          }
        }
        logger.debug('importing ViewModel resources for ' + compileInstruction.associatedModuleId, importIds.slice(templateImportCount));
      }
    }

    return this.importViewResources(importIds, names, resources, compileInstruction, loadContext);
  };

  ViewEngine.prototype.importViewModelResource = function importViewModelResource(moduleImport, moduleMember) {
    var _this9 = this;

    return this.loader.loadModule(moduleImport).then(function (viewModelModule) {
      var normalizedId = _aureliaMetadata.Origin.get(viewModelModule).moduleId;
      var resourceModule = _this9.moduleAnalyzer.analyze(normalizedId, viewModelModule, moduleMember);

      if (!resourceModule.mainResource) {
        throw new Error('No view model found in module "' + moduleImport + '".');
      }

      resourceModule.initialize(_this9.container);

      return resourceModule.mainResource;
    });
  };

  ViewEngine.prototype.importViewResources = function importViewResources(moduleIds, names, resources, compileInstruction, loadContext) {
    var _this10 = this;

    loadContext = loadContext || new ResourceLoadContext();
    compileInstruction = compileInstruction || ViewCompileInstruction.normal;

    moduleIds = moduleIds.map(function (x) {
      return _this10._applyLoaderPlugin(x);
    });

    return this.loader.loadAllModules(moduleIds).then(function (imports) {
      var i = void 0;
      var ii = void 0;
      var analysis = void 0;
      var normalizedId = void 0;
      var current = void 0;
      var associatedModule = void 0;
      var container = _this10.container;
      var moduleAnalyzer = _this10.moduleAnalyzer;
      var allAnalysis = new Array(imports.length);

      for (i = 0, ii = imports.length; i < ii; ++i) {
        current = imports[i];
        normalizedId = _aureliaMetadata.Origin.get(current).moduleId;

        analysis = moduleAnalyzer.analyze(normalizedId, current);
        analysis.initialize(container);
        analysis.register(resources, names[i]);

        allAnalysis[i] = analysis;
      }

      if (compileInstruction.associatedModuleId) {
        associatedModule = moduleAnalyzer.getAnalysis(compileInstruction.associatedModuleId);

        if (associatedModule) {
          associatedModule.register(resources);
        }
      }

      for (i = 0, ii = allAnalysis.length; i < ii; ++i) {
        allAnalysis[i] = allAnalysis[i].load(container, loadContext);
      }

      return Promise.all(allAnalysis).then(function () {
        return resources;
      });
    });
  };

  ViewEngine.prototype._applyLoaderPlugin = function _applyLoaderPlugin(id) {
    var index = id.lastIndexOf('.');
    if (index !== -1) {
      var ext = id.substring(index);
      var pluginName = this._pluginMap[ext];

      if (pluginName === undefined) {
        return id;
      }

      return this.loader.applyPluginToUrl(id, pluginName);
    }

    return id;
  };

  return ViewEngine;
}(), _class15.viewModelRequireMetadataKey = 'aurelia:view-model-require', _temp4)) || _class14);

var Controller = exports.Controller = function () {
  function Controller(behavior, instruction, viewModel, container) {
    

    this.behavior = behavior;
    this.instruction = instruction;
    this.viewModel = viewModel;
    this.isAttached = false;
    this.view = null;
    this.isBound = false;
    this.scope = null;
    this.container = container;
    this.elementEvents = container.elementEvents || null;

    var observerLookup = behavior.observerLocator.getOrCreateObserversLookup(viewModel);
    var handlesBind = behavior.handlesBind;
    var attributes = instruction.attributes;
    var boundProperties = this.boundProperties = [];
    var properties = behavior.properties;
    var i = void 0;
    var ii = void 0;

    behavior._ensurePropertiesDefined(viewModel, observerLookup);

    for (i = 0, ii = properties.length; i < ii; ++i) {
      properties[i]._initialize(viewModel, observerLookup, attributes, handlesBind, boundProperties);
    }
  }

  Controller.prototype.created = function created(owningView) {
    if (this.behavior.handlesCreated) {
      this.viewModel.created(owningView, this.view);
    }
  };

  Controller.prototype.automate = function automate(overrideContext, owningView) {
    this.view.bindingContext = this.viewModel;
    this.view.overrideContext = overrideContext || (0, _aureliaBinding.createOverrideContext)(this.viewModel);
    this.view._isUserControlled = true;

    if (this.behavior.handlesCreated) {
      this.viewModel.created(owningView || null, this.view);
    }

    this.bind(this.view);
  };

  Controller.prototype.bind = function bind(scope) {
    var skipSelfSubscriber = this.behavior.handlesBind;
    var boundProperties = this.boundProperties;
    var i = void 0;
    var ii = void 0;
    var x = void 0;
    var observer = void 0;
    var selfSubscriber = void 0;

    if (this.isBound) {
      if (this.scope === scope) {
        return;
      }

      this.unbind();
    }

    this.isBound = true;
    this.scope = scope;

    for (i = 0, ii = boundProperties.length; i < ii; ++i) {
      x = boundProperties[i];
      observer = x.observer;
      selfSubscriber = observer.selfSubscriber;
      observer.publishing = false;

      if (skipSelfSubscriber) {
        observer.selfSubscriber = null;
      }

      x.binding.bind(scope);
      observer.call();

      observer.publishing = true;
      observer.selfSubscriber = selfSubscriber;
    }

    var overrideContext = void 0;
    if (this.view !== null) {
      if (skipSelfSubscriber) {
        this.view.viewModelScope = scope;
      }

      if (this.viewModel === scope.overrideContext.bindingContext) {
        overrideContext = scope.overrideContext;
      } else if (this.instruction.inheritBindingContext) {
        overrideContext = (0, _aureliaBinding.createOverrideContext)(this.viewModel, scope.overrideContext);
      } else {
        overrideContext = (0, _aureliaBinding.createOverrideContext)(this.viewModel);
        overrideContext.__parentOverrideContext = scope.overrideContext;
      }

      this.view.bind(this.viewModel, overrideContext);
    } else if (skipSelfSubscriber) {
      overrideContext = scope.overrideContext;

      if (scope.overrideContext.__parentOverrideContext !== undefined && this.viewModel.viewFactory && this.viewModel.viewFactory.factoryCreateInstruction.partReplacements) {
        overrideContext = Object.assign({}, scope.overrideContext);
        overrideContext.parentOverrideContext = scope.overrideContext.__parentOverrideContext;
      }
      this.viewModel.bind(scope.bindingContext, overrideContext);
    }
  };

  Controller.prototype.unbind = function unbind() {
    if (this.isBound) {
      var _boundProperties = this.boundProperties;
      var _i2 = void 0;
      var _ii2 = void 0;

      this.isBound = false;
      this.scope = null;

      if (this.view !== null) {
        this.view.unbind();
      }

      if (this.behavior.handlesUnbind) {
        this.viewModel.unbind();
      }

      if (this.elementEvents !== null) {
        this.elementEvents.disposeAll();
      }

      for (_i2 = 0, _ii2 = _boundProperties.length; _i2 < _ii2; ++_i2) {
        _boundProperties[_i2].binding.unbind();
      }
    }
  };

  Controller.prototype.attached = function attached() {
    if (this.isAttached) {
      return;
    }

    this.isAttached = true;

    if (this.behavior.handlesAttached) {
      this.viewModel.attached();
    }

    if (this.view !== null) {
      this.view.attached();
    }
  };

  Controller.prototype.detached = function detached() {
    if (this.isAttached) {
      this.isAttached = false;

      if (this.view !== null) {
        this.view.detached();
      }

      if (this.behavior.handlesDetached) {
        this.viewModel.detached();
      }
    }
  };

  return Controller;
}();

var BehaviorPropertyObserver = exports.BehaviorPropertyObserver = (_dec9 = (0, _aureliaBinding.subscriberCollection)(), _dec9(_class16 = function () {
  function BehaviorPropertyObserver(taskQueue, obj, propertyName, selfSubscriber, initialValue) {
    

    this.taskQueue = taskQueue;
    this.obj = obj;
    this.propertyName = propertyName;
    this.notqueued = true;
    this.publishing = false;
    this.selfSubscriber = selfSubscriber;
    this.currentValue = this.oldValue = initialValue;
  }

  BehaviorPropertyObserver.prototype.getValue = function getValue() {
    return this.currentValue;
  };

  BehaviorPropertyObserver.prototype.setValue = function setValue(newValue) {
    var oldValue = this.currentValue;

    if (oldValue !== newValue) {
      this.oldValue = oldValue;
      this.currentValue = newValue;

      if (this.publishing && this.notqueued) {
        if (this.taskQueue.flushing) {
          this.call();
        } else {
          this.notqueued = false;
          this.taskQueue.queueMicroTask(this);
        }
      }
    }
  };

  BehaviorPropertyObserver.prototype.call = function call() {
    var oldValue = this.oldValue;
    var newValue = this.currentValue;

    this.notqueued = true;

    if (newValue === oldValue) {
      return;
    }

    if (this.selfSubscriber) {
      this.selfSubscriber(newValue, oldValue);
    }

    this.callSubscribers(newValue, oldValue);
    this.oldValue = newValue;
  };

  BehaviorPropertyObserver.prototype.subscribe = function subscribe(context, callable) {
    this.addSubscriber(context, callable);
  };

  BehaviorPropertyObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
    this.removeSubscriber(context, callable);
  };

  return BehaviorPropertyObserver;
}()) || _class16);


function getObserver(instance, name) {
  var lookup = instance.__observers__;

  if (lookup === undefined) {
    var ctor = Object.getPrototypeOf(instance).constructor;
    var _behavior = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.resource, ctor);
    if (!_behavior.isInitialized) {
      _behavior.initialize(_aureliaDependencyInjection.Container.instance || new _aureliaDependencyInjection.Container(), instance.constructor);
    }

    lookup = _behavior.observerLocator.getOrCreateObserversLookup(instance);
    _behavior._ensurePropertiesDefined(instance, lookup);
  }

  return lookup[name];
}

var BindableProperty = exports.BindableProperty = function () {
  function BindableProperty(nameOrConfig) {
    

    if (typeof nameOrConfig === 'string') {
      this.name = nameOrConfig;
    } else {
      Object.assign(this, nameOrConfig);
    }

    this.attribute = this.attribute || _hyphenate(this.name);
    if (this.defaultBindingMode === null || this.defaultBindingMode === undefined) {
      this.defaultBindingMode = _aureliaBinding.bindingMode.oneWay;
    }
    this.changeHandler = this.changeHandler || null;
    this.owner = null;
    this.descriptor = null;
  }

  BindableProperty.prototype.registerWith = function registerWith(target, behavior, descriptor) {
    behavior.properties.push(this);
    behavior.attributes[this.attribute] = this;
    this.owner = behavior;

    if (descriptor) {
      this.descriptor = descriptor;
      return this._configureDescriptor(descriptor);
    }

    return undefined;
  };

  BindableProperty.prototype._configureDescriptor = function _configureDescriptor(descriptor) {
    var name = this.name;

    descriptor.configurable = true;
    descriptor.enumerable = true;

    if ('initializer' in descriptor) {
      this.defaultValue = descriptor.initializer;
      delete descriptor.initializer;
      delete descriptor.writable;
    }

    if ('value' in descriptor) {
      this.defaultValue = descriptor.value;
      delete descriptor.value;
      delete descriptor.writable;
    }

    descriptor.get = function () {
      return getObserver(this, name).getValue();
    };

    descriptor.set = function (value) {
      getObserver(this, name).setValue(value);
    };

    descriptor.get.getObserver = function (obj) {
      return getObserver(obj, name);
    };

    return descriptor;
  };

  BindableProperty.prototype.defineOn = function defineOn(target, behavior) {
    var name = this.name;
    var handlerName = void 0;

    if (this.changeHandler === null) {
      handlerName = name + 'Changed';
      if (handlerName in target.prototype) {
        this.changeHandler = handlerName;
      }
    }

    if (this.descriptor === null) {
      Object.defineProperty(target.prototype, name, this._configureDescriptor(behavior, {}));
    }
  };

  BindableProperty.prototype.createObserver = function createObserver(viewModel) {
    var selfSubscriber = null;
    var defaultValue = this.defaultValue;
    var changeHandlerName = this.changeHandler;
    var name = this.name;
    var initialValue = void 0;

    if (this.hasOptions) {
      return undefined;
    }

    if (changeHandlerName in viewModel) {
      if ('propertyChanged' in viewModel) {
        selfSubscriber = function selfSubscriber(newValue, oldValue) {
          viewModel[changeHandlerName](newValue, oldValue);
          viewModel.propertyChanged(name, newValue, oldValue);
        };
      } else {
        selfSubscriber = function selfSubscriber(newValue, oldValue) {
          return viewModel[changeHandlerName](newValue, oldValue);
        };
      }
    } else if ('propertyChanged' in viewModel) {
      selfSubscriber = function selfSubscriber(newValue, oldValue) {
        return viewModel.propertyChanged(name, newValue, oldValue);
      };
    } else if (changeHandlerName !== null) {
      throw new Error('Change handler ' + changeHandlerName + ' was specified but not declared on the class.');
    }

    if (defaultValue !== undefined) {
      initialValue = typeof defaultValue === 'function' ? defaultValue.call(viewModel) : defaultValue;
    }

    return new BehaviorPropertyObserver(this.owner.taskQueue, viewModel, this.name, selfSubscriber, initialValue);
  };

  BindableProperty.prototype._initialize = function _initialize(viewModel, observerLookup, attributes, behaviorHandlesBind, boundProperties) {
    var selfSubscriber = void 0;
    var observer = void 0;
    var attribute = void 0;
    var defaultValue = this.defaultValue;

    if (this.isDynamic) {
      for (var key in attributes) {
        this._createDynamicProperty(viewModel, observerLookup, behaviorHandlesBind, key, attributes[key], boundProperties);
      }
    } else if (!this.hasOptions) {
      observer = observerLookup[this.name];

      if (attributes !== null) {
        selfSubscriber = observer.selfSubscriber;
        attribute = attributes[this.attribute];

        if (behaviorHandlesBind) {
          observer.selfSubscriber = null;
        }

        if (typeof attribute === 'string') {
          viewModel[this.name] = attribute;
          observer.call();
        } else if (attribute) {
          boundProperties.push({ observer: observer, binding: attribute.createBinding(viewModel) });
        } else if (defaultValue !== undefined) {
          observer.call();
        }

        observer.selfSubscriber = selfSubscriber;
      }

      observer.publishing = true;
    }
  };

  BindableProperty.prototype._createDynamicProperty = function _createDynamicProperty(viewModel, observerLookup, behaviorHandlesBind, name, attribute, boundProperties) {
    var changeHandlerName = name + 'Changed';
    var selfSubscriber = null;
    var observer = void 0;
    var info = void 0;

    if (changeHandlerName in viewModel) {
      if ('propertyChanged' in viewModel) {
        selfSubscriber = function selfSubscriber(newValue, oldValue) {
          viewModel[changeHandlerName](newValue, oldValue);
          viewModel.propertyChanged(name, newValue, oldValue);
        };
      } else {
        selfSubscriber = function selfSubscriber(newValue, oldValue) {
          return viewModel[changeHandlerName](newValue, oldValue);
        };
      }
    } else if ('propertyChanged' in viewModel) {
      selfSubscriber = function selfSubscriber(newValue, oldValue) {
        return viewModel.propertyChanged(name, newValue, oldValue);
      };
    }

    observer = observerLookup[name] = new BehaviorPropertyObserver(this.owner.taskQueue, viewModel, name, selfSubscriber);

    Object.defineProperty(viewModel, name, {
      configurable: true,
      enumerable: true,
      get: observer.getValue.bind(observer),
      set: observer.setValue.bind(observer)
    });

    if (behaviorHandlesBind) {
      observer.selfSubscriber = null;
    }

    if (typeof attribute === 'string') {
      viewModel[name] = attribute;
      observer.call();
    } else if (attribute) {
      info = { observer: observer, binding: attribute.createBinding(viewModel) };
      boundProperties.push(info);
    }

    observer.publishing = true;
    observer.selfSubscriber = selfSubscriber;
  };

  return BindableProperty;
}();

var lastProviderId = 0;

function nextProviderId() {
  return ++lastProviderId;
}

function doProcessContent() {
  return true;
}
function doProcessAttributes() {}

var HtmlBehaviorResource = exports.HtmlBehaviorResource = function () {
  function HtmlBehaviorResource() {
    

    this.elementName = null;
    this.attributeName = null;
    this.attributeDefaultBindingMode = undefined;
    this.liftsContent = false;
    this.targetShadowDOM = false;
    this.shadowDOMOptions = null;
    this.processAttributes = doProcessAttributes;
    this.processContent = doProcessContent;
    this.usesShadowDOM = false;
    this.childBindings = null;
    this.hasDynamicOptions = false;
    this.containerless = false;
    this.properties = [];
    this.attributes = {};
    this.isInitialized = false;
    this.primaryProperty = null;
  }

  HtmlBehaviorResource.convention = function convention(name, existing) {
    var behavior = void 0;

    if (name.endsWith('CustomAttribute')) {
      behavior = existing || new HtmlBehaviorResource();
      behavior.attributeName = _hyphenate(name.substring(0, name.length - 15));
    }

    if (name.endsWith('CustomElement')) {
      behavior = existing || new HtmlBehaviorResource();
      behavior.elementName = _hyphenate(name.substring(0, name.length - 13));
    }

    return behavior;
  };

  HtmlBehaviorResource.prototype.addChildBinding = function addChildBinding(behavior) {
    if (this.childBindings === null) {
      this.childBindings = [];
    }

    this.childBindings.push(behavior);
  };

  HtmlBehaviorResource.prototype.initialize = function initialize(container, target) {
    var proto = target.prototype;
    var properties = this.properties;
    var attributeName = this.attributeName;
    var attributeDefaultBindingMode = this.attributeDefaultBindingMode;
    var i = void 0;
    var ii = void 0;
    var current = void 0;

    if (this.isInitialized) {
      return;
    }

    this.isInitialized = true;
    target.__providerId__ = nextProviderId();

    this.observerLocator = container.get(_aureliaBinding.ObserverLocator);
    this.taskQueue = container.get(_aureliaTaskQueue.TaskQueue);

    this.target = target;
    this.usesShadowDOM = this.targetShadowDOM && _aureliaPal.FEATURE.shadowDOM;
    this.handlesCreated = 'created' in proto;
    this.handlesBind = 'bind' in proto;
    this.handlesUnbind = 'unbind' in proto;
    this.handlesAttached = 'attached' in proto;
    this.handlesDetached = 'detached' in proto;
    this.htmlName = this.elementName || this.attributeName;

    if (attributeName !== null) {
      if (properties.length === 0) {
        new BindableProperty({
          name: 'value',
          changeHandler: 'valueChanged' in proto ? 'valueChanged' : null,
          attribute: attributeName,
          defaultBindingMode: attributeDefaultBindingMode
        }).registerWith(target, this);
      }

      current = properties[0];

      if (properties.length === 1 && current.name === 'value') {
        current.isDynamic = current.hasOptions = this.hasDynamicOptions;
        current.defineOn(target, this);
      } else {
        for (i = 0, ii = properties.length; i < ii; ++i) {
          properties[i].defineOn(target, this);
          if (properties[i].primaryProperty) {
            if (this.primaryProperty) {
              throw new Error('Only one bindable property on a custom element can be defined as the default');
            }
            this.primaryProperty = properties[i];
          }
        }

        current = new BindableProperty({
          name: 'value',
          changeHandler: 'valueChanged' in proto ? 'valueChanged' : null,
          attribute: attributeName,
          defaultBindingMode: attributeDefaultBindingMode
        });

        current.hasOptions = true;
        current.registerWith(target, this);
      }
    } else {
      for (i = 0, ii = properties.length; i < ii; ++i) {
        properties[i].defineOn(target, this);
      }

      this._copyInheritedProperties(container, target);
    }
  };

  HtmlBehaviorResource.prototype.register = function register(registry, name) {
    var _this11 = this;

    if (this.attributeName !== null) {
      registry.registerAttribute(name || this.attributeName, this, this.attributeName);

      if (Array.isArray(this.aliases)) {
        this.aliases.forEach(function (alias) {
          registry.registerAttribute(alias, _this11, _this11.attributeName);
        });
      }
    }

    if (this.elementName !== null) {
      registry.registerElement(name || this.elementName, this);
    }
  };

  HtmlBehaviorResource.prototype.load = function load(container, target, loadContext, viewStrategy, transientView) {
    var _this12 = this;

    var options = void 0;

    if (this.elementName !== null) {
      viewStrategy = container.get(ViewLocator).getViewStrategy(viewStrategy || this.viewStrategy || target);
      options = new ViewCompileInstruction(this.targetShadowDOM, true);

      if (!viewStrategy.moduleId) {
        viewStrategy.moduleId = _aureliaMetadata.Origin.get(target).moduleId;
      }

      return viewStrategy.loadViewFactory(container.get(ViewEngine), options, loadContext, target).then(function (viewFactory) {
        if (!transientView || !_this12.viewFactory) {
          _this12.viewFactory = viewFactory;
        }

        return viewFactory;
      });
    }

    return Promise.resolve(this);
  };

  HtmlBehaviorResource.prototype.compile = function compile(compiler, resources, node, instruction, parentNode) {
    if (this.liftsContent) {
      if (!instruction.viewFactory) {
        var template = _aureliaPal.DOM.createElement('template');
        var fragment = _aureliaPal.DOM.createDocumentFragment();
        var cacheSize = node.getAttribute('view-cache');
        var part = node.getAttribute('part');

        node.removeAttribute(instruction.originalAttrName);
        _aureliaPal.DOM.replaceNode(template, node, parentNode);
        fragment.appendChild(node);
        instruction.viewFactory = compiler.compile(fragment, resources);

        if (part) {
          instruction.viewFactory.part = part;
          node.removeAttribute('part');
        }

        if (cacheSize) {
          instruction.viewFactory.setCacheSize(cacheSize);
          node.removeAttribute('view-cache');
        }

        node = template;
      }
    } else if (this.elementName !== null) {
      var _partReplacements2 = {};

      if (this.processContent(compiler, resources, node, instruction) && node.hasChildNodes()) {
        var currentChild = node.firstChild;
        var contentElement = this.usesShadowDOM ? null : _aureliaPal.DOM.createElement('au-content');
        var nextSibling = void 0;
        var toReplace = void 0;

        while (currentChild) {
          nextSibling = currentChild.nextSibling;

          if (currentChild.tagName === 'TEMPLATE' && (toReplace = currentChild.getAttribute('replace-part'))) {
            _partReplacements2[toReplace] = compiler.compile(currentChild, resources);
            _aureliaPal.DOM.removeNode(currentChild, parentNode);
            instruction.partReplacements = _partReplacements2;
          } else if (contentElement !== null) {
            if (currentChild.nodeType === 3 && _isAllWhitespace(currentChild)) {
              _aureliaPal.DOM.removeNode(currentChild, parentNode);
            } else {
              contentElement.appendChild(currentChild);
            }
          }

          currentChild = nextSibling;
        }

        if (contentElement !== null && contentElement.hasChildNodes()) {
          node.appendChild(contentElement);
        }

        instruction.skipContentProcessing = false;
      } else {
        instruction.skipContentProcessing = true;
      }
    } else if (!this.processContent(compiler, resources, node, instruction)) {
      instruction.skipContentProcessing = true;
    }

    return node;
  };

  HtmlBehaviorResource.prototype.create = function create(container, instruction, element, bindings) {
    var viewHost = void 0;
    var au = null;

    instruction = instruction || BehaviorInstruction.normal;
    element = element || null;
    bindings = bindings || null;

    if (this.elementName !== null && element) {
      if (this.usesShadowDOM) {
        viewHost = element.attachShadow(this.shadowDOMOptions);
        container.registerInstance(_aureliaPal.DOM.boundary, viewHost);
      } else {
        viewHost = element;
        if (this.targetShadowDOM) {
          container.registerInstance(_aureliaPal.DOM.boundary, viewHost);
        }
      }
    }

    if (element !== null) {
      element.au = au = element.au || {};
    }

    var viewModel = instruction.viewModel || container.get(this.target);
    var controller = new Controller(this, instruction, viewModel, container);
    var childBindings = this.childBindings;
    var viewFactory = void 0;

    if (this.liftsContent) {
      au.controller = controller;
    } else if (this.elementName !== null) {
      viewFactory = instruction.viewFactory || this.viewFactory;
      container.viewModel = viewModel;

      if (viewFactory) {
        controller.view = viewFactory.create(container, instruction, element);
      }

      if (element !== null) {
        au.controller = controller;

        if (controller.view) {
          if (!this.usesShadowDOM && (element.childNodes.length === 1 || element.contentElement)) {
            var contentElement = element.childNodes[0] || element.contentElement;
            controller.view.contentView = { fragment: contentElement };
            contentElement.parentNode && _aureliaPal.DOM.removeNode(contentElement);
          }

          if (instruction.anchorIsContainer) {
            if (childBindings !== null) {
              for (var _i3 = 0, _ii3 = childBindings.length; _i3 < _ii3; ++_i3) {
                controller.view.addBinding(childBindings[_i3].create(element, viewModel, controller));
              }
            }

            controller.view.appendNodesTo(viewHost);
          } else {
            controller.view.insertNodesBefore(viewHost);
          }
        } else if (childBindings !== null) {
          for (var _i4 = 0, _ii4 = childBindings.length; _i4 < _ii4; ++_i4) {
            bindings.push(childBindings[_i4].create(element, viewModel, controller));
          }
        }
      } else if (controller.view) {
        controller.view.controller = controller;

        if (childBindings !== null) {
          for (var _i5 = 0, _ii5 = childBindings.length; _i5 < _ii5; ++_i5) {
            controller.view.addBinding(childBindings[_i5].create(instruction.host, viewModel, controller));
          }
        }
      } else if (childBindings !== null) {
        for (var _i6 = 0, _ii6 = childBindings.length; _i6 < _ii6; ++_i6) {
          bindings.push(childBindings[_i6].create(instruction.host, viewModel, controller));
        }
      }
    } else if (childBindings !== null) {
      for (var _i7 = 0, _ii7 = childBindings.length; _i7 < _ii7; ++_i7) {
        bindings.push(childBindings[_i7].create(element, viewModel, controller));
      }
    }

    if (au !== null) {
      au[this.htmlName] = controller;
    }

    if (instruction.initiatedByBehavior && viewFactory) {
      controller.view.created();
    }

    return controller;
  };

  HtmlBehaviorResource.prototype._ensurePropertiesDefined = function _ensurePropertiesDefined(instance, lookup) {
    var properties = void 0;
    var i = void 0;
    var ii = void 0;
    var observer = void 0;

    if ('__propertiesDefined__' in lookup) {
      return;
    }

    lookup.__propertiesDefined__ = true;
    properties = this.properties;

    for (i = 0, ii = properties.length; i < ii; ++i) {
      observer = properties[i].createObserver(instance);

      if (observer !== undefined) {
        lookup[observer.propertyName] = observer;
      }
    }
  };

  HtmlBehaviorResource.prototype._copyInheritedProperties = function _copyInheritedProperties(container, target) {
    var _this13 = this;

    var behavior = void 0;
    var derived = target;

    while (true) {
      var proto = Object.getPrototypeOf(target.prototype);
      target = proto && proto.constructor;
      if (!target) {
        return;
      }
      behavior = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.resource, target);
      if (behavior) {
        break;
      }
    }
    behavior.initialize(container, target);

    var _loop = function _loop(_i8, _ii8) {
      var prop = behavior.properties[_i8];

      if (_this13.properties.some(function (p) {
        return p.name === prop.name;
      })) {
        return 'continue';
      }

      new BindableProperty(prop).registerWith(derived, _this13);
    };

    for (var _i8 = 0, _ii8 = behavior.properties.length; _i8 < _ii8; ++_i8) {
      var _ret = _loop(_i8, _ii8);

      if (_ret === 'continue') continue;
    }
  };

  return HtmlBehaviorResource;
}();

function createChildObserverDecorator(selectorOrConfig, all) {
  return function (target, key, descriptor) {
    var actualTarget = typeof key === 'string' ? target.constructor : target;
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, actualTarget);

    if (typeof selectorOrConfig === 'string') {
      selectorOrConfig = {
        selector: selectorOrConfig,
        name: key
      };
    }

    if (descriptor) {
      descriptor.writable = true;
      descriptor.configurable = true;
    }

    selectorOrConfig.all = all;
    r.addChildBinding(new ChildObserver(selectorOrConfig));
  };
}

function children(selectorOrConfig) {
  return createChildObserverDecorator(selectorOrConfig, true);
}

function child(selectorOrConfig) {
  return createChildObserverDecorator(selectorOrConfig, false);
}

var ChildObserver = function () {
  function ChildObserver(config) {
    

    this.name = config.name;
    this.changeHandler = config.changeHandler || this.name + 'Changed';
    this.selector = config.selector;
    this.all = config.all;
  }

  ChildObserver.prototype.create = function create(viewHost, viewModel, controller) {
    return new ChildObserverBinder(this.selector, viewHost, this.name, viewModel, controller, this.changeHandler, this.all);
  };

  return ChildObserver;
}();

var noMutations = [];

function trackMutation(groupedMutations, binder, record) {
  var mutations = groupedMutations.get(binder);

  if (!mutations) {
    mutations = [];
    groupedMutations.set(binder, mutations);
  }

  mutations.push(record);
}

function onChildChange(mutations, observer) {
  var binders = observer.binders;
  var bindersLength = binders.length;
  var groupedMutations = new Map();

  for (var _i9 = 0, _ii9 = mutations.length; _i9 < _ii9; ++_i9) {
    var record = mutations[_i9];
    var added = record.addedNodes;
    var removed = record.removedNodes;

    for (var j = 0, jj = removed.length; j < jj; ++j) {
      var node = removed[j];
      if (node.nodeType === 1) {
        for (var k = 0; k < bindersLength; ++k) {
          var binder = binders[k];
          if (binder.onRemove(node)) {
            trackMutation(groupedMutations, binder, record);
          }
        }
      }
    }

    for (var _j = 0, _jj = added.length; _j < _jj; ++_j) {
      var _node = added[_j];
      if (_node.nodeType === 1) {
        for (var _k = 0; _k < bindersLength; ++_k) {
          var _binder = binders[_k];
          if (_binder.onAdd(_node)) {
            trackMutation(groupedMutations, _binder, record);
          }
        }
      }
    }
  }

  groupedMutations.forEach(function (value, key) {
    if (key.changeHandler !== null) {
      key.viewModel[key.changeHandler](value);
    }
  });
}

var ChildObserverBinder = function () {
  function ChildObserverBinder(selector, viewHost, property, viewModel, controller, changeHandler, all) {
    

    this.selector = selector;
    this.viewHost = viewHost;
    this.property = property;
    this.viewModel = viewModel;
    this.controller = controller;
    this.changeHandler = changeHandler in viewModel ? changeHandler : null;
    this.usesShadowDOM = controller.behavior.usesShadowDOM;
    this.all = all;

    if (!this.usesShadowDOM && controller.view && controller.view.contentView) {
      this.contentView = controller.view.contentView;
    } else {
      this.contentView = null;
    }
  }

  ChildObserverBinder.prototype.matches = function matches(element) {
    if (element.matches(this.selector)) {
      if (this.contentView === null) {
        return true;
      }

      var contentView = this.contentView;
      var assignedSlot = element.auAssignedSlot;

      if (assignedSlot && assignedSlot.projectFromAnchors) {
        var anchors = assignedSlot.projectFromAnchors;

        for (var _i10 = 0, _ii10 = anchors.length; _i10 < _ii10; ++_i10) {
          if (anchors[_i10].auOwnerView === contentView) {
            return true;
          }
        }

        return false;
      }

      return element.auOwnerView === contentView;
    }

    return false;
  };

  ChildObserverBinder.prototype.bind = function bind(source) {
    var viewHost = this.viewHost;
    var viewModel = this.viewModel;
    var observer = viewHost.__childObserver__;

    if (!observer) {
      observer = viewHost.__childObserver__ = _aureliaPal.DOM.createMutationObserver(onChildChange);

      var options = {
        childList: true,
        subtree: !this.usesShadowDOM
      };

      observer.observe(viewHost, options);
      observer.binders = [];
    }

    observer.binders.push(this);

    if (this.usesShadowDOM) {
      var current = viewHost.firstElementChild;

      if (this.all) {
        var items = viewModel[this.property];
        if (!items) {
          items = viewModel[this.property] = [];
        } else {
          items.length = 0;
        }

        while (current) {
          if (this.matches(current)) {
            items.push(current.au && current.au.controller ? current.au.controller.viewModel : current);
          }

          current = current.nextElementSibling;
        }

        if (this.changeHandler !== null) {
          this.viewModel[this.changeHandler](noMutations);
        }
      } else {
        while (current) {
          if (this.matches(current)) {
            var value = current.au && current.au.controller ? current.au.controller.viewModel : current;
            this.viewModel[this.property] = value;

            if (this.changeHandler !== null) {
              this.viewModel[this.changeHandler](value);
            }

            break;
          }

          current = current.nextElementSibling;
        }
      }
    }
  };

  ChildObserverBinder.prototype.onRemove = function onRemove(element) {
    if (this.matches(element)) {
      var value = element.au && element.au.controller ? element.au.controller.viewModel : element;

      if (this.all) {
        var items = this.viewModel[this.property] || (this.viewModel[this.property] = []);
        var index = items.indexOf(value);

        if (index !== -1) {
          items.splice(index, 1);
        }

        return true;
      }

      return false;
    }

    return false;
  };

  ChildObserverBinder.prototype.onAdd = function onAdd(element) {
    if (this.matches(element)) {
      var value = element.au && element.au.controller ? element.au.controller.viewModel : element;

      if (this.all) {
        var items = this.viewModel[this.property] || (this.viewModel[this.property] = []);

        if (this.selector === '*') {
          items.push(value);
          return true;
        }

        var index = 0;
        var prev = element.previousElementSibling;

        while (prev) {
          if (this.matches(prev)) {
            index++;
          }

          prev = prev.previousElementSibling;
        }

        items.splice(index, 0, value);
        return true;
      }

      this.viewModel[this.property] = value;

      if (this.changeHandler !== null) {
        this.viewModel[this.changeHandler](value);
      }
    }

    return false;
  };

  ChildObserverBinder.prototype.unbind = function unbind() {
    if (this.viewHost.__childObserver__) {
      this.viewHost.__childObserver__.disconnect();
      this.viewHost.__childObserver__ = null;
    }
  };

  return ChildObserverBinder;
}();

function remove(viewSlot, previous) {
  return Array.isArray(previous) ? viewSlot.removeMany(previous, true) : viewSlot.remove(previous, true);
}

var SwapStrategies = exports.SwapStrategies = {
  before: function before(viewSlot, previous, callback) {
    return previous === undefined ? callback() : callback().then(function () {
      return remove(viewSlot, previous);
    });
  },
  with: function _with(viewSlot, previous, callback) {
    return previous === undefined ? callback() : Promise.all([remove(viewSlot, previous), callback()]);
  },
  after: function after(viewSlot, previous, callback) {
    return Promise.resolve(viewSlot.removeAll(true)).then(callback);
  }
};

function tryActivateViewModel(context) {
  if (context.skipActivation || typeof context.viewModel.activate !== 'function') {
    return Promise.resolve();
  }

  return context.viewModel.activate(context.model) || Promise.resolve();
}

var CompositionEngine = exports.CompositionEngine = (_dec10 = (0, _aureliaDependencyInjection.inject)(ViewEngine, ViewLocator), _dec10(_class17 = function () {
  function CompositionEngine(viewEngine, viewLocator) {
    

    this.viewEngine = viewEngine;
    this.viewLocator = viewLocator;
  }

  CompositionEngine.prototype._swap = function _swap(context, view) {
    var swapStrategy = SwapStrategies[context.swapOrder] || SwapStrategies.after;
    var previousViews = context.viewSlot.children.slice();

    return swapStrategy(context.viewSlot, previousViews, function () {
      return Promise.resolve(context.viewSlot.add(view)).then(function () {
        if (context.currentController) {
          context.currentController.unbind();
        }
      });
    }).then(function () {
      if (context.compositionTransactionNotifier) {
        context.compositionTransactionNotifier.done();
      }
    });
  };

  CompositionEngine.prototype._createControllerAndSwap = function _createControllerAndSwap(context) {
    var _this14 = this;

    return this.createController(context).then(function (controller) {
      controller.automate(context.overrideContext, context.owningView);

      if (context.compositionTransactionOwnershipToken) {
        return context.compositionTransactionOwnershipToken.waitForCompositionComplete().then(function () {
          return _this14._swap(context, controller.view);
        }).then(function () {
          return controller;
        });
      }

      return _this14._swap(context, controller.view).then(function () {
        return controller;
      });
    });
  };

  CompositionEngine.prototype.createController = function createController(context) {
    var _this15 = this;

    var childContainer = void 0;
    var viewModel = void 0;
    var viewModelResource = void 0;
    var m = void 0;

    return this.ensureViewModel(context).then(tryActivateViewModel).then(function () {
      childContainer = context.childContainer;
      viewModel = context.viewModel;
      viewModelResource = context.viewModelResource;
      m = viewModelResource.metadata;

      var viewStrategy = _this15.viewLocator.getViewStrategy(context.view || viewModel);

      if (context.viewResources) {
        viewStrategy.makeRelativeTo(context.viewResources.viewUrl);
      }

      return m.load(childContainer, viewModelResource.value, null, viewStrategy, true);
    }).then(function (viewFactory) {
      return m.create(childContainer, BehaviorInstruction.dynamic(context.host, viewModel, viewFactory));
    });
  };

  CompositionEngine.prototype.ensureViewModel = function ensureViewModel(context) {
    var childContainer = context.childContainer = context.childContainer || context.container.createChild();

    if (typeof context.viewModel === 'string') {
      context.viewModel = context.viewResources ? context.viewResources.relativeToView(context.viewModel) : context.viewModel;

      return this.viewEngine.importViewModelResource(context.viewModel).then(function (viewModelResource) {
        childContainer.autoRegister(viewModelResource.value);

        if (context.host) {
          childContainer.registerInstance(_aureliaPal.DOM.Element, context.host);
        }

        context.viewModel = childContainer.viewModel = childContainer.get(viewModelResource.value);
        context.viewModelResource = viewModelResource;
        return context;
      });
    }

    var m = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, context.viewModel.constructor);
    m.elementName = m.elementName || 'dynamic-element';
    m.initialize(context.container || childContainer, context.viewModel.constructor);
    context.viewModelResource = { metadata: m, value: context.viewModel.constructor };
    childContainer.viewModel = context.viewModel;
    return Promise.resolve(context);
  };

  CompositionEngine.prototype.compose = function compose(context) {
    var _this16 = this;

    context.childContainer = context.childContainer || context.container.createChild();
    context.view = this.viewLocator.getViewStrategy(context.view);

    var transaction = context.childContainer.get(CompositionTransaction);
    var compositionTransactionOwnershipToken = transaction.tryCapture();

    if (compositionTransactionOwnershipToken) {
      context.compositionTransactionOwnershipToken = compositionTransactionOwnershipToken;
    } else {
      context.compositionTransactionNotifier = transaction.enlist();
    }

    if (context.viewModel) {
      return this._createControllerAndSwap(context);
    } else if (context.view) {
      if (context.viewResources) {
        context.view.makeRelativeTo(context.viewResources.viewUrl);
      }

      return context.view.loadViewFactory(this.viewEngine, new ViewCompileInstruction()).then(function (viewFactory) {
        var result = viewFactory.create(context.childContainer);
        result.bind(context.bindingContext, context.overrideContext);

        if (context.compositionTransactionOwnershipToken) {
          return context.compositionTransactionOwnershipToken.waitForCompositionComplete().then(function () {
            return _this16._swap(context, result);
          }).then(function () {
            return result;
          });
        }

        return _this16._swap(context, result).then(function () {
          return result;
        });
      });
    } else if (context.viewSlot) {
      context.viewSlot.removeAll();

      if (context.compositionTransactionNotifier) {
        context.compositionTransactionNotifier.done();
      }

      return Promise.resolve(null);
    }

    return Promise.resolve(null);
  };

  return CompositionEngine;
}()) || _class17);

var ElementConfigResource = exports.ElementConfigResource = function () {
  function ElementConfigResource() {
    
  }

  ElementConfigResource.prototype.initialize = function initialize(container, target) {};

  ElementConfigResource.prototype.register = function register(registry, name) {};

  ElementConfigResource.prototype.load = function load(container, target) {
    var config = new target();
    var eventManager = container.get(_aureliaBinding.EventManager);
    eventManager.registerElementConfig(config);
  };

  return ElementConfigResource;
}();

function validateBehaviorName(name, type) {
  if (/[A-Z]/.test(name)) {
    var newName = _hyphenate(name);
    LogManager.getLogger('templating').warn('\'' + name + '\' is not a valid ' + type + ' name and has been converted to \'' + newName + '\'. Upper-case letters are not allowed because the DOM is not case-sensitive.');
    return newName;
  }
  return name;
}

function resource(instance) {
  return function (target) {
    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, instance, target);
  };
}

function behavior(override) {
  return function (target) {
    if (override instanceof HtmlBehaviorResource) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, override, target);
    } else {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
      Object.assign(r, override);
    }
  };
}

function customElement(name) {
  return function (target) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
    r.elementName = validateBehaviorName(name, 'custom element');
  };
}

function customAttribute(name, defaultBindingMode, aliases) {
  return function (target) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
    r.attributeName = validateBehaviorName(name, 'custom attribute');
    r.attributeDefaultBindingMode = defaultBindingMode;
    r.aliases = aliases;
  };
}

function templateController(target) {
  var deco = function deco(t) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
    r.liftsContent = true;
  };

  return target ? deco(target) : deco;
}

function bindable(nameOrConfigOrTarget, key, descriptor) {
  var deco = function deco(target, key2, descriptor2) {
    var actualTarget = key2 ? target.constructor : target;
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, actualTarget);
    var prop = void 0;

    if (key2) {
      nameOrConfigOrTarget = nameOrConfigOrTarget || {};
      nameOrConfigOrTarget.name = key2;
    }

    prop = new BindableProperty(nameOrConfigOrTarget);
    return prop.registerWith(actualTarget, r, descriptor2);
  };

  if (!nameOrConfigOrTarget) {
    return deco;
  }

  if (key) {
    var _target = nameOrConfigOrTarget;
    nameOrConfigOrTarget = null;
    return deco(_target, key, descriptor);
  }

  return deco;
}

function dynamicOptions(target) {
  var deco = function deco(t) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
    r.hasDynamicOptions = true;
  };

  return target ? deco(target) : deco;
}

var defaultShadowDOMOptions = { mode: 'open' };
function useShadowDOM(targetOrOptions) {
  var options = typeof targetOrOptions === 'function' || !targetOrOptions ? defaultShadowDOMOptions : targetOrOptions;

  var deco = function deco(t) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
    r.targetShadowDOM = true;
    r.shadowDOMOptions = options;
  };

  return typeof targetOrOptions === 'function' ? deco(targetOrOptions) : deco;
}

function processAttributes(processor) {
  return function (t) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
    r.processAttributes = function (compiler, resources, node, attributes, elementInstruction) {
      try {
        processor(compiler, resources, node, attributes, elementInstruction);
      } catch (error) {
        LogManager.getLogger('templating').error(error);
      }
    };
  };
}

function doNotProcessContent() {
  return false;
}

function processContent(processor) {
  return function (t) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
    r.processContent = processor ? function (compiler, resources, node, instruction) {
      try {
        return processor(compiler, resources, node, instruction);
      } catch (error) {
        LogManager.getLogger('templating').error(error);
        return false;
      }
    } : doNotProcessContent;
  };
}

function containerless(target) {
  var deco = function deco(t) {
    var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
    r.containerless = true;
  };

  return target ? deco(target) : deco;
}

function useViewStrategy(strategy) {
  return function (target) {
    _aureliaMetadata.metadata.define(ViewLocator.viewStrategyMetadataKey, strategy, target);
  };
}

function useView(path) {
  return useViewStrategy(new RelativeViewStrategy(path));
}

function inlineView(markup, dependencies, dependencyBaseUrl) {
  return useViewStrategy(new InlineViewStrategy(markup, dependencies, dependencyBaseUrl));
}

function noView(targetOrDependencies, dependencyBaseUrl) {
  var target = void 0;
  var dependencies = void 0;
  if (typeof targetOrDependencies === 'function') {
    target = targetOrDependencies;
  } else {
    dependencies = targetOrDependencies;
    target = undefined;
  }

  var deco = function deco(t) {
    _aureliaMetadata.metadata.define(ViewLocator.viewStrategyMetadataKey, new NoViewStrategy(dependencies, dependencyBaseUrl), t);
  };

  return target ? deco(target) : deco;
}

function elementConfig(target) {
  var deco = function deco(t) {
    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ElementConfigResource(), t);
  };

  return target ? deco(target) : deco;
}

function viewResources() {
  for (var _len = arguments.length, resources = Array(_len), _key = 0; _key < _len; _key++) {
    resources[_key] = arguments[_key];
  }

  return function (target) {
    _aureliaMetadata.metadata.define(ViewEngine.viewModelRequireMetadataKey, resources, target);
  };
}

var TemplatingEngine = exports.TemplatingEngine = (_dec11 = (0, _aureliaDependencyInjection.inject)(_aureliaDependencyInjection.Container, ModuleAnalyzer, ViewCompiler, CompositionEngine), _dec11(_class18 = function () {
  function TemplatingEngine(container, moduleAnalyzer, viewCompiler, compositionEngine) {
    

    this._container = container;
    this._moduleAnalyzer = moduleAnalyzer;
    this._viewCompiler = viewCompiler;
    this._compositionEngine = compositionEngine;
    container.registerInstance(Animator, Animator.instance = new Animator());
  }

  TemplatingEngine.prototype.configureAnimator = function configureAnimator(animator) {
    this._container.unregister(Animator);
    this._container.registerInstance(Animator, Animator.instance = animator);
  };

  TemplatingEngine.prototype.compose = function compose(context) {
    return this._compositionEngine.compose(context);
  };

  TemplatingEngine.prototype.enhance = function enhance(instruction) {
    if (instruction instanceof _aureliaPal.DOM.Element) {
      instruction = { element: instruction };
    }

    var compilerInstructions = {};
    var resources = instruction.resources || this._container.get(ViewResources);

    this._viewCompiler._compileNode(instruction.element, resources, compilerInstructions, instruction.element.parentNode, 'root', true);

    var factory = new ViewFactory(instruction.element, compilerInstructions, resources);
    var container = instruction.container || this._container.createChild();
    var view = factory.create(container, BehaviorInstruction.enhance());

    view.bind(instruction.bindingContext || {}, instruction.overrideContext);

    view.firstChild = view.lastChild = view.fragment;
    view.fragment = _aureliaPal.DOM.createDocumentFragment();
    view.attached();

    return view;
  };

  return TemplatingEngine;
}()) || _class18);
});

define('aurelia-testing/dist/commonjs/aurelia-testing',['require','exports','module','./compile-spy','./view-spy','./component-tester','./wait'],function (require, exports, module) {"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./compile-spy"));
__export(require("./view-spy"));
__export(require("./component-tester"));
__export(require("./wait"));
function configure(config) {
    config.globalResources([
        './compile-spy',
        './view-spy'
    ]);
}
exports.configure = configure;

});

define('aurelia-testing/dist/commonjs/compile-spy',['require','exports','module','aurelia-templating','aurelia-dependency-injection','aurelia-logging','aurelia-pal'],function (require, exports, module) {"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var aurelia_templating_1 = require("aurelia-templating");
var aurelia_dependency_injection_1 = require("aurelia-dependency-injection");
var aurelia_logging_1 = require("aurelia-logging");
var aurelia_pal_1 = require("aurelia-pal");
/**
 * Attribute to be placed on any element to have it emit the View Compiler's
 * TargetInstruction into the debug console, giving you insight into all the
 * parsed bindings, behaviors and event handers for the targeted element.
 */
var CompileSpy = /** @class */ (function () {
    /**
     * Creates and instanse of CompileSpy.
     * @param element target element on where attribute is placed on.
     * @param instruction instructions for how the target element should be enhanced.
     */
    function CompileSpy(element, instruction) {
        aurelia_logging_1.getLogger('compile-spy').info(element.toString(), instruction);
    }
    CompileSpy = __decorate([
        aurelia_templating_1.customAttribute('compile-spy'),
        aurelia_dependency_injection_1.inject(aurelia_pal_1.DOM.Element, aurelia_templating_1.TargetInstruction)
    ], CompileSpy);
    return CompileSpy;
}());
exports.CompileSpy = CompileSpy;

});

define('aurelia-testing/dist/commonjs/component-tester',['require','exports','module','aurelia-templating','./wait'],function (require, exports, module) {"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var aurelia_templating_1 = require("aurelia-templating");
var wait_1 = require("./wait");
var StageComponent = /** @class */ (function () {
    function StageComponent() {
    }
    StageComponent.withResources = function (resources) {
        if (resources === void 0) { resources = []; }
        return new ComponentTester().withResources(resources);
    };
    return StageComponent;
}());
exports.StageComponent = StageComponent;
var ComponentTester = /** @class */ (function () {
    function ComponentTester() {
        this.resources = [];
    }
    ComponentTester.prototype.configure = function (aurelia) {
        return aurelia.use.standardConfiguration();
    };
    ComponentTester.prototype.bootstrap = function (configure) {
        this.configure = configure;
    };
    ComponentTester.prototype.withResources = function (resources) {
        this.resources = resources;
        return this;
    };
    ComponentTester.prototype.inView = function (html) {
        this.html = html;
        return this;
    };
    ComponentTester.prototype.boundTo = function (bindingContext) {
        this.bindingContext = bindingContext;
        return this;
    };
    ComponentTester.prototype.manuallyHandleLifecycle = function () {
        this._prepareLifecycle();
        return this;
    };
    ComponentTester.prototype.create = function (bootstrap) {
        var _this = this;
        return bootstrap(function (aurelia) {
            return Promise.resolve(_this.configure(aurelia)).then(function () {
                if (_this.resources) {
                    aurelia.use.globalResources(_this.resources);
                }
                return aurelia.start().then(function () {
                    _this.host = document.createElement('div');
                    _this.host.innerHTML = _this.html;
                    document.body.appendChild(_this.host);
                    return aurelia.enhance(_this.bindingContext, _this.host).then(function () {
                        _this.rootView = aurelia.root;
                        _this.element = _this.host.firstElementChild;
                        if (aurelia.root.controllers.length) {
                            _this.viewModel = aurelia.root.controllers[0].viewModel;
                        }
                        return new Promise(function (resolve) { return setTimeout(function () { return resolve(); }, 0); });
                    });
                });
            });
        });
    };
    ComponentTester.prototype.dispose = function () {
        if (this.host === undefined || this.rootView === undefined) {
            throw new Error('Cannot call ComponentTester.dispose() before ComponentTester.create()');
        }
        this.rootView.detached();
        this.rootView.unbind();
        return this.host.parentNode.removeChild(this.host);
    };
    ComponentTester.prototype._prepareLifecycle = function () {
        var _this = this;
        // bind
        var bindPrototype = aurelia_templating_1.View.prototype.bind;
        // tslint:disable-next-line:no-empty
        aurelia_templating_1.View.prototype.bind = function () { };
        this.bind = function (bindingContext) { return new Promise(function (resolve) {
            aurelia_templating_1.View.prototype.bind = bindPrototype;
            if (bindingContext !== undefined) {
                _this.bindingContext = bindingContext;
            }
            _this.rootView.bind(_this.bindingContext);
            setTimeout(function () { return resolve(); }, 0);
        }); };
        // attached
        var attachedPrototype = aurelia_templating_1.View.prototype.attached;
        // tslint:disable-next-line:no-empty
        aurelia_templating_1.View.prototype.attached = function () { };
        this.attached = function () { return new Promise(function (resolve) {
            aurelia_templating_1.View.prototype.attached = attachedPrototype;
            _this.rootView.attached();
            setTimeout(function () { return resolve(); }, 0);
        }); };
        // detached
        this.detached = function () { return new Promise(function (resolve) {
            _this.rootView.detached();
            setTimeout(function () { return resolve(); }, 0);
        }); };
        // unbind
        this.unbind = function () { return new Promise(function (resolve) {
            _this.rootView.unbind();
            setTimeout(function () { return resolve(); }, 0);
        }); };
    };
    ComponentTester.prototype.waitForElement = function (selector, options) {
        var _this = this;
        return wait_1.waitFor(function () { return _this.element.querySelector(selector); }, options);
    };
    ComponentTester.prototype.waitForElements = function (selector, options) {
        var _this = this;
        return wait_1.waitFor(function () { return _this.element.querySelectorAll(selector); }, options);
    };
    return ComponentTester;
}());
exports.ComponentTester = ComponentTester;

});

define('aurelia-testing/dist/commonjs/view-spy',['require','exports','module','aurelia-templating','aurelia-logging'],function (require, exports, module) {"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var aurelia_templating_1 = require("aurelia-templating");
var aurelia_logging_1 = require("aurelia-logging");
/**
 * Attribute to be placed on any HTML element in a view to emit the View instance
 * to the debug console, giving you insight into the live View instance, including
 * all child views, live bindings, behaviors and more.
 */
var ViewSpy = /** @class */ (function () {
    /**
     * Creates a new instance of ViewSpy.
     */
    function ViewSpy() {
        this.logger = aurelia_logging_1.getLogger('view-spy');
    }
    ViewSpy.prototype._log = function (lifecycleName, context) {
        if (!this.value && lifecycleName === 'created') {
            this.logger.info(lifecycleName, this.view);
        }
        else if (this.value && this.value.indexOf(lifecycleName) !== -1) {
            this.logger.info(lifecycleName, this.view, context);
        }
    };
    /**
     * Invoked when the target view is created.
     * @param view The target view.
     */
    ViewSpy.prototype.created = function (view) {
        this.view = view;
        this._log('created');
    };
    /**
     * Invoked when the target view is bound.
     * @param bindingContext The target view's binding context.
     */
    ViewSpy.prototype.bind = function (bindingContext) {
        this._log('bind', bindingContext);
    };
    /**
     * Invoked when the target element is attached to the DOM.
     */
    ViewSpy.prototype.attached = function () {
        this._log('attached');
    };
    /**
     * Invoked when the target element is detached from the DOM.
     */
    ViewSpy.prototype.detached = function () {
        this._log('detached');
    };
    /**
     * Invoked when the target element is unbound.
     */
    ViewSpy.prototype.unbind = function () {
        this._log('unbind');
    };
    ViewSpy = __decorate([
        aurelia_templating_1.customAttribute('view-spy')
    ], ViewSpy);
    return ViewSpy;
}());
exports.ViewSpy = ViewSpy;

});

define('aurelia-testing/dist/commonjs/wait',['require','exports','module'],function (require, exports, module) {"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Generic function to wait for something to happen. Uses polling
 * @param getter: a getter function that returns anything else than `null` or an
 *                empty array or an empty jQuery object when the
 *                condition is met
 * @param options: lookup options, defaults to
 *                 `{present: true, interval: 50, timeout: 5000}`
 */
function waitFor(getter, options) {
    if (options === void 0) { options = { present: true, interval: 50, timeout: 5000 }; }
    // prevents infinite recursion if the request times out
    var timedOut = false;
    options = __assign({ present: true, interval: 50, timeout: 5000 }, options);
    function wait() {
        var element = getter();
        // boolean is needed here, hence the length > 0
        var found = element !== null && (!(element instanceof NodeList) &&
            !element.jquery || element.length > 0);
        if (!options.present === !found || timedOut) {
            return Promise.resolve(element);
        }
        return new Promise(function (rs) { return setTimeout(rs, options.interval); }).then(wait);
    }
    return Promise.race([
        new Promise(function (_, rj) { return setTimeout(function () {
            timedOut = true;
            rj(options.present ? 'Element not found' : 'Element not removed');
        }, options.timeout); }),
        wait()
    ]);
}
exports.waitFor = waitFor;
function waitForDocumentElement(selector, options) {
    return waitFor(function () { return document.querySelector(selector); }, options);
}
exports.waitForDocumentElement = waitForDocumentElement;
function waitForDocumentElements(selector, options) {
    return waitFor(function () { return document.querySelectorAll(selector); }, options);
}
exports.waitForDocumentElements = waitForDocumentElements;

});

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("aurelia-event-aggregator")):"function"==typeof define&&define.amd?define('bcx-aurelia-dnd/dist/index',["exports","aurelia-event-aggregator"],t):t(e.BcxAureliaDnd={},e.AureliaEventAggregator)}(this,function(e,t){"use strict";var n="undefined"!=typeof self?self:"undefined"!=typeof global?global:new Function("return this")();function i(e){if("TR"===e.tagName&&e.parentNode&&e.parentNode.parentNode&&"TABLE"===e.parentNode.parentNode.tagName){for(var t=e.cloneNode(!0),i=e.childElementCount,r=0;r<i-1;r++){var s=n.getComputedStyle(e.children[r]);t.children[r].style.width=s.width,t.children[r].style.height=s.height}var o=e.parentNode,a=o.cloneNode();a.appendChild(t);var d=o.parentNode,h=d.cloneNode();h.appendChild(a);var l=n.getComputedStyle(d);return h.style.width=l.width,h}}function r(e){if("LI"===e.tagName&&e.parentNode&&("UL"===e.parentNode.tagName||"OL"===e.parentNode.tagName)){var t=e.cloneNode(!0),i=n.getComputedStyle(e);t.style.width=i.width,t.style.height=i.height,t.style.flex="0 0 auto";var r=e.parentNode.cloneNode();return r.appendChild(t),r.style.width="auto",r.style.height="auto",r.style.listStyleType="none",r}}function s(e){var t=e.cloneNode(!0),i=n.getComputedStyle(e);return t.style.width=i.width,t.style.height=i.height,t}var o=function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")},a=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),d=n.document,h=d&&d.documentElement,l="\n/* bcx-aurelia-dnd styles */\n\n/*\nbcx-aurelia-dnd relies on html/body margin 0.\nYour css stack should have done this.\nAdded here as safe guard.\n*/\nhtml, body {\n  margin: 0;\n}\n\n.bcx-dnd-preview {\n  position: absolute !important;\n  margin: 0 !important;\n  z-index: 9999 !important;\n  opacity: 0.8;\n  box-shadow: 0 0 16px gray;\n}\n\n.bcx-dnd-preview .bcx-dnd-preview-hide {\n  visibility: hidden !important;\n}\n\n.bcx-dnd-hide {\n  display: none !important;\n}\n\n.bcx-dnd-hide-cursor .bcx-dnd-preview {\n  cursor: none !important;\n}\n\n.bcx-dnd-unselectable {\n  -webkit-user-select: none !important;\n  -moz-user-select: none !important;\n  -ms-user-select: none !important;\n  user-select: none !important;\n}\n",u=!1;var c=function(){var e={},t="(?:^|\\s)",n="(?:\\s|$)";function i(i){var r=e[i];return r?r.lastIndex=0:e[i]=r=new RegExp(t+i+n,"g"),r}return{add:function(e,t){var n=e.className;n.length?i(t).test(n)||(e.className+=" "+t):e.className=t},rm:function(e,t){e.className=e.className.replace(i(t)," ").trim()}}}();function v(e){if(void 0!==e.touches)return e.touches.length;if(void 0!==e.which&&0!==e.which)return e.which;if(void 0!==e.buttons)return e.buttons;var t=e.button;return void 0!==t?1&t?1:2&t?3:4&t?2:0:void 0}function g(e){var t=e.getBoundingClientRect();return{x:t.left+f("scrollLeft","pageXOffset"),y:t.top+f("scrollTop","pageYOffset"),width:m(t),height:p(t)}}function f(e,t){return void 0!==window[t]?window[t]:h.clientHeight?h[e]:d.body[e]}function m(e){return e.width||e.right-e.left}function p(e){return e.height||e.bottom-e.top}function _(e){return e.parentNode===d?null:e.parentNode}function w(e){return"INPUT"===e.tagName||"TEXTAREA"===e.tagName||"SELECT"===e.tagName||function e(t){if(!t)return!1;if("false"===t.contentEditable)return!1;if("true"===t.contentEditable)return!0;return e(_(t))}(e)}function b(e,t){var n=function(e){return e.targetTouches&&e.targetTouches.length?e.targetTouches[0]:e.changedTouches&&e.changedTouches.length?e.changedTouches[0]:e}(t),i={pageX:"clientX",pageY:"clientY"};return e in i&&!(e in n)&&i[e]in n&&(e=i[e]),n[e]}function y(e,t){for(var i=t instanceof n.Element?function(e){return e.element===t}:function(e){return e.delegate===t},r=e.length,s=0;s<r;s+=1)if(i(e[s]))return s;return-1}var E=function(){function e(t){o(this,e),this.dndSources=[],this.dndTargets=[],this.previewDrawers=[],this.ea=t,function(){if(!u){u=!0;var e=d.createElement("style");e.innerHTML=l,e.type="text/css",d.head.childNodes.length>0?d.head.insertBefore(e,d.head.childNodes[0]):d.head.appendChild(e)}}(),this.addPreviewDrawer(s),this.addPreviewDrawer(r),this.addPreviewDrawer(i),this._grab=this._grab.bind(this),this._release=this._release.bind(this),this._startBecauseMouseMoved=this._startBecauseMouseMoved.bind(this),this._preventGrabbed=this._preventGrabbed.bind(this),this._drag=this._drag.bind(this),h.addEventListener("mousedown",this._grab,{passive:!1}),h.addEventListener("touchstart",this._grab,{passive:!1}),h.addEventListener("mouseup",this._release,{passive:!1})}return a(e,[{key:"addPreviewDrawer",value:function(e){this.previewDrawers.unshift(e)}},{key:"addSource",value:function(e,t){this.dndSources.push(new function e(t){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(o(this,e),!t)throw new Error("Missing delegate for dnd source.");if("function"!=typeof t.dndModel)throw new Error("Missing dndModel() method on dnd source delegate.");if(this.delegate=t,i.element?this.element=i.element:this.element=t.dndElement,i.handler){if(!(i.handler instanceof n.Element))throw new Error("specified handler is not a DOM element");this.handler=i.handler}else this.handler=this.element;if(!(this.element instanceof n.Element))throw new Error("Missing dndElement or options.element on dnd source delegate.");i.noPreview&&(this.noPreview=!0),i.hideCursor&&(this.hideCursor=!0),i.centerPreviewToMousePosition&&(this.centerPreviewToMousePosition=!0)}(e,t))}},{key:"removeSource",value:function(e){var t=y(this.dndSources,e);t>=0&&this.dndSources.splice(t,1)}},{key:"addTarget",value:function(e,t){e.dnd={};var i=new function e(t){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(o(this,e),!t)throw new Error("Missing delegate for dnd target.");if("function"!=typeof t.dndCanDrop)throw new Error("Missing dndCanDrop() method on delegate.");if("function"!=typeof t.dndDrop)throw new Error("Missing dndDrop() method on dnd target delegate.");if(this.delegate=t,i.element?this.element=i.element:this.element=t.dndElement,!(this.element instanceof n.Element))throw new Error("Missing dndElement or options.element on dnd target delegate.");"function"==typeof t.dndHover&&(this.dndHover=t.dndHover.bind(t))}(e,t);if(this.isProcessing){var r=i.delegate.dndCanDrop(this.model),s=i.delegate.dnd;s.canDrop=r,s.isProcessing=!0,s.model=this.model}this.dndTargets.push(i)}},{key:"removeTarget",value:function(e){var t=y(this.dndTargets,e);t>=0&&(this.dndTargets[t].delegate.dnd=null,this.dndTargets.splice(t,1))}},{key:"_sourceOf",value:function(e){var t=function(e,t){for(var n=e.length,i=0;i<n;i+=1)if(e[i].handler===t)return i;return-1}(this.dndSources,e);return t>=0?this.dndSources[t]:void 0}},{key:"_startListeningEventualMovements",value:function(){h.addEventListener("mousemove",this._startBecauseMouseMoved,{passive:!1}),this._element&&this._element.addEventListener("touchmove",this._startBecauseMouseMoved,{passive:!1}),this._element&&this._element.addEventListener("touchend",this._release,{passive:!1})}},{key:"_stopListeningEventualMovements",value:function(){h.removeEventListener("mousemove",this._startBecauseMouseMoved),this._element&&this._element.removeEventListener("touchmove",this._startBecauseMouseMoved)}},{key:"_startListeningMovements",value:function(){h.addEventListener("selectstart",this._preventGrabbed),h.addEventListener("click",this._preventGrabbed),h.addEventListener("mousemove",this._drag,{passive:!1}),this._element&&this._element.addEventListener("touchmove",this._drag,{passive:!1})}},{key:"_stopListeningMovements",value:function(){h.removeEventListener("selectstart",this._preventGrabbed),h.removeEventListener("click",this._preventGrabbed),h.removeEventListener("mousemove",this._drag),this._element&&this._element.removeEventListener("touchmove",this._drag),this._element&&this._element.removeEventListener("touchend",this._release)}},{key:"_preventGrabbed",value:function(e){this._grabbed&&e.preventDefault()}},{key:"_grab",value:function(e){if(this._moveX=e.clientX,this._moveY=e.clientY,!(1!==v(e)||e.metaKey||e.ctrlKey)){var t=e.target;this._element=t;var n=this._startingSource(t);n&&(this._grabbed=n,this._startListeningEventualMovements(),"mousedown"===e.type&&w(t)?t.focus():e.preventDefault())}}},{key:"_ungrab",value:function(){this._grabbed=void 0,this._stopListeningEventualMovements(),this._stopListeningMovements(),this._element=void 0}},{key:"_release",value:function(e){if(this._ungrab(),this.isProcessing){this.ea&&this.ea.publish("dnd:willEnd");var t=this._landingTargets(e).shallowTarget;t&&t.delegate.dndDrop(this._locationInfo(t.element,e)),this._cleanup(),this.ea&&this.ea.publish("dnd:didEnd")}}},{key:"_startingSource",value:function(e){if(!this.isProcessing){for(var t=this._sourceOf(e);!t&&e&&(e=_(e));)t=this._sourceOf(e);return t}}},{key:"_startBecauseMouseMoved",value:function(e){if(this._grabbed)if(0!==v(e)){if(void 0===e.clientX||e.clientX!==this._moveX||void 0===e.clientY||e.clientY!==this._moveY){var t=b("clientX",e),n=b("clientY",e);if(!w(d.elementFromPoint(t,n))){var i=this._grabbed;this._stopListeningEventualMovements(),this._startListeningMovements(),this.isProcessing&&this._cleanup(),this._start(i),this._sourceElementRect=g(this._sourceElement),this._offsetX=b("pageX",e)-this._sourceElementRect.x,this._offsetY=b("pageY",e)-this._sourceElementRect.y,this._renderPreviewImage(),this._drag(e)}}}else this._cleanup()}},{key:"_start",value:function(e){var t=this;this.ea&&this.ea.publish("dnd:willStart"),this.isProcessing=!0,this.model=e.delegate.dndModel(),this._sourceElement=e.element,e.noPreview?this._noPreview=!0:e.delegate.dndPreview&&(this._sourcePreview=e.delegate.dndPreview(this.model)),this._noPreview||(e.hideCursor&&(this._hideCursor=!0),e.centerPreviewToMousePosition&&(this._centerPreviewToMousePosition=!0)),this.dndTargets.forEach(function(e){var n=e.delegate.dndCanDrop(t.model),i=e.delegate.dnd;i.canDrop=n,i.isProcessing=!0,i.model=t.model}),this.ea&&this.ea.publish("dnd:didStart")}},{key:"_cleanup",value:function(){this._ungrab(),this._removePreviewImage(),this.isProcessing=void 0,this.model=void 0,this._sourceElement=void 0,this._noPreview=void 0,this._hideCursor=void 0,this._centerPreviewToMousePosition=void 0,this._sourcePreview=void 0,this._sourceElementRect=void 0,this._offsetX=0,this._offsetY=0,this.dndTargets.forEach(function(e){var t=e.delegate.dnd;t.canDrop=void 0,t.isProcessing=void 0,t.isHoveringShallowly=void 0,t.isHovering=void 0,t.model=void 0})}},{key:"_landingTargets",value:function(e){if(!this.isProcessing)return{shallowTarget:null,possibleTargets:[]};for(var t,n,i,r,s,o,a,h=b("clientX",e),l=b("clientY",e),u=this.dndTargets.filter(function(e){if(e.delegate.dnd.canDrop){var t=e.element.getBoundingClientRect();return t.left<=h&&t.right>=h&&t.top<=l&&t.bottom>=l}}),c=void 0,v=(t=this._preview,n=h,i=l,o=(s=t||{}).className,s.className+=" bcx-dnd-hide",r=d.elementFromPoint(n,i),s.className=o,r);!c&&v;){var g=y(u,v);g>=0?c=u[g]:v=_(v)}if(c)u.splice(u.indexOf(c),1);else if(u.length>0){var f=(a=u,Array.isArray(a)?a:Array.from(a));c=f[0],u=f.slice(1)}return{shallowTarget:c,possibleTargets:u}}},{key:"_drag",value:function(e){var t=this;if(this.isProcessing){e.preventDefault(),this._updatePreviewLocation(e);var n=this._landingTargets(e),i=n.shallowTarget,r=n.possibleTargets;this.dndTargets.forEach(function(n){var s=n.delegate.dnd;s.isProcessing&&(n===i?(s.isHoveringShallowly=!0,s.isHovering=!0,n.dndHover&&n.dndHover(t._locationInfo(n.element,e))):r.indexOf(n)>=0?(s.isHoveringShallowly=!1,s.isHovering=!0,n.dndHover&&n.dndHover(t._locationInfo(n.element,e))):(s.isHoveringShallowly=!1,s.isHovering=!1))})}}},{key:"_updatePreviewLocation",value:function(e){if(this._preview){var t=b("pageX",e),n=b("pageY",e);if(this._centerPreviewToMousePosition){var i=this._preview.getBoundingClientRect(),r=m(i),s=p(i);this._preview.style.left=t-Math.floor(r/2)+"px",this._preview.style.top=n-Math.floor(s/2)+"px"}else this._preview.style.left=t-this._offsetX+"px",this._preview.style.top=n-this._offsetY+"px"}}},{key:"_locationInfo",value:function(e,t){var n={x:this._sourceElementRect.x+this._offsetX,y:this._sourceElementRect.y+this._offsetY},i=b("pageX",t),r=b("pageY",t),s={x:i,y:r},o=g(e),a=void 0;return a=this._preview?g(this._preview):{x:i-this._offsetX,y:r-this._offsetY,width:this._sourceElementRect.width,height:this._sourceElementRect.height},{mouseStartAt:n,mouseEndAt:s,sourceElementRect:this._sourceElementRect,targetElementRect:o,previewElementRect:a}}},{key:"_renderPreviewImage",value:function(){if(!this._preview&&!this._noPreview){if(this._sourcePreview)this._preview=this._sourcePreview,this._sourcePreview=void 0;else{var e=this._sourceElement;if(!e)return;for(var t=0;t<this.previewDrawers.length&&(this._preview=this.previewDrawers[t](e),!this._preview);t++);if(!this._preview)return}c.add(this._preview,"bcx-dnd-preview"),d.body.appendChild(this._preview),c.add(d.body,"bcx-dnd-unselectable"),"rgba(0, 0, 0, 0)"===n.getComputedStyle(this._preview).backgroundColor&&(this._preview.style.backgroundColor="white"),this._hideCursor&&c.add(d.body,"bcx-dnd-hide-cursor")}}},{key:"_removePreviewImage",value:function(){this._preview&&(c.rm(d.body,"bcx-dnd-unselectable"),c.rm(d.body,"bcx-dnd-hide-cursor"),_(this._preview).removeChild(this._preview),this._preview=null)}}]),e}();E.inject=[t.EventAggregator],e.DndService=E,Object.defineProperty(e,"__esModule",{value:!0})});

define('bcx-aurelia-reorderable-repeat/dist/index',['require','exports','module','aurelia-pal','./reorderable-repeat','./reorderable-direction','./reorderable-dnd-preview','./reorderable-dnd-handler-selector','./reorderable-after-reordering'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.ReorderableAfterReordering = exports.ReorderableDndHandlerSelector = exports.ReorderableDndPreview = exports.ReorderableDirection = exports.ReorderableRepeat = undefined;
exports.configure = configure;

var _aureliaPal = require('aurelia-pal');

var _reorderableRepeat = require('./reorderable-repeat');

var _reorderableDirection = require('./reorderable-direction');

var _reorderableDndPreview = require('./reorderable-dnd-preview');

var _reorderableDndHandlerSelector = require('./reorderable-dnd-handler-selector');

var _reorderableAfterReordering = require('./reorderable-after-reordering');

var css = '\n.reorderable-repeat-dragging-me {\n  visibility: hidden;\n}\n';

function configure(config) {
  _aureliaPal.DOM.injectStyles(css);

  config.globalResources([_aureliaPal.PLATFORM.moduleName('./reorderable-repeat'), _aureliaPal.PLATFORM.moduleName('./reorderable-direction'), _aureliaPal.PLATFORM.moduleName('./reorderable-dnd-preview'), _aureliaPal.PLATFORM.moduleName('./reorderable-dnd-handler-selector'), _aureliaPal.PLATFORM.moduleName('./reorderable-after-reordering')]);
}

exports.ReorderableRepeat = _reorderableRepeat.ReorderableRepeat;
exports.ReorderableDirection = _reorderableDirection.ReorderableDirection;
exports.ReorderableDndPreview = _reorderableDndPreview.ReorderableDndPreview;
exports.ReorderableDndHandlerSelector = _reorderableDndHandlerSelector.ReorderableDndHandlerSelector;
exports.ReorderableAfterReordering = _reorderableAfterReordering.ReorderableAfterReordering;
});

define('bcx-aurelia-reorderable-repeat/dist/reorderable-after-reordering',['require','exports','module','aurelia-templating'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.ReorderableAfterReordering = undefined;

var _dec, _class;

var _aureliaTemplating = require('aurelia-templating');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReorderableAfterReordering = exports.ReorderableAfterReordering = (_dec = (0, _aureliaTemplating.customAttribute)('reorderable-after-reordering'), _dec(_class = function () {
  function ReorderableAfterReordering() {
    _classCallCheck(this, ReorderableAfterReordering);
  }

  ReorderableAfterReordering.prototype.attached = function attached() {};

  ReorderableAfterReordering.prototype.bind = function bind(bindingContext, overrideContext) {
    this.scope = { bindingContext: bindingContext, overrideContext: overrideContext };
  };

  return ReorderableAfterReordering;
}()) || _class);
});

define('bcx-aurelia-reorderable-repeat/dist/reorderable-direction',['require','exports','module','aurelia-templating'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.ReorderableDirection = undefined;

var _dec, _class;

var _aureliaTemplating = require('aurelia-templating');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReorderableDirection = exports.ReorderableDirection = (_dec = (0, _aureliaTemplating.customAttribute)('reorderable-direction'), _dec(_class = function () {
  function ReorderableDirection() {
    _classCallCheck(this, ReorderableDirection);
  }

  ReorderableDirection.prototype.attached = function attached() {};

  ReorderableDirection.prototype.bind = function bind(bindingContext, overrideContext) {
    this.scope = { bindingContext: bindingContext, overrideContext: overrideContext };
  };

  return ReorderableDirection;
}()) || _class);
});

define('bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-handler-selector',['require','exports','module','aurelia-templating'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.ReorderableDndHandlerSelector = undefined;

var _dec, _class;

var _aureliaTemplating = require('aurelia-templating');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReorderableDndHandlerSelector = exports.ReorderableDndHandlerSelector = (_dec = (0, _aureliaTemplating.customAttribute)('reorderable-dnd-handler-selector'), _dec(_class = function () {
  function ReorderableDndHandlerSelector() {
    _classCallCheck(this, ReorderableDndHandlerSelector);
  }

  ReorderableDndHandlerSelector.prototype.attached = function attached() {};

  ReorderableDndHandlerSelector.prototype.bind = function bind(bindingContext, overrideContext) {
    this.scope = { bindingContext: bindingContext, overrideContext: overrideContext };
  };

  return ReorderableDndHandlerSelector;
}()) || _class);
});

define('bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-preview',['require','exports','module','aurelia-templating'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.ReorderableDndPreview = undefined;

var _dec, _class;

var _aureliaTemplating = require('aurelia-templating');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReorderableDndPreview = exports.ReorderableDndPreview = (_dec = (0, _aureliaTemplating.customAttribute)('reorderable-dnd-preview'), _dec(_class = function () {
  function ReorderableDndPreview() {
    _classCallCheck(this, ReorderableDndPreview);
  }

  ReorderableDndPreview.prototype.attached = function attached() {};

  ReorderableDndPreview.prototype.bind = function bind(bindingContext, overrideContext) {
    this.scope = { bindingContext: bindingContext, overrideContext: overrideContext };
  };

  return ReorderableDndPreview;
}()) || _class);
});

define('bcx-aurelia-reorderable-repeat/dist/reorderable-repeat',['require','exports','module','aurelia-dependency-injection','aurelia-binding','aurelia-templating','aurelia-templating-resources','./reorderable-repeat-strategy-locator','bcx-aurelia-dnd','aurelia-event-aggregator','aurelia-task-queue'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.ReorderableRepeat = undefined;

var _dec, _dec2, _class, _desc, _value, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;

var _aureliaDependencyInjection = require('aurelia-dependency-injection');

var _aureliaBinding = require('aurelia-binding');

var _aureliaTemplating = require('aurelia-templating');

var _aureliaTemplatingResources = require('aurelia-templating-resources');

var _reorderableRepeatStrategyLocator = require('./reorderable-repeat-strategy-locator');

var _bcxAureliaDnd = require('bcx-aurelia-dnd');

var _aureliaEventAggregator = require('aurelia-event-aggregator');

var _aureliaTaskQueue = require('aurelia-task-queue');

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var seed = 0;

var classes = function () {
  var cache = {};
  var start = '(?:^|\\s)';
  var end = '(?:\\s|$)';

  function lookupClass(className) {
    var cached = cache[className];
    if (cached) {
      cached.lastIndex = 0;
    } else {
      cache[className] = cached = new RegExp(start + className + end, 'g');
    }
    return cached;
  }

  function addClass(el, className) {
    var current = el.className;
    if (!current.length) {
      el.className = className;
    } else if (!lookupClass(className).test(current)) {
      el.className += ' ' + className;
    }
  }

  function rmClass(el, className) {
    el.className = el.className.replace(lookupClass(className), ' ').trim();
  }
  return { add: addClass, rm: rmClass };
}();

var ReorderableRepeat = exports.ReorderableRepeat = (_dec = (0, _aureliaTemplating.customAttribute)('reorderable-repeat'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaEventAggregator.EventAggregator, _aureliaTaskQueue.TaskQueue, _aureliaBinding.BindingEngine, _bcxAureliaDnd.DndService, _aureliaTemplating.BoundViewFactory, _aureliaTemplating.TargetInstruction, _aureliaTemplating.ViewSlot, _aureliaTemplating.ViewResources, _aureliaBinding.ObserverLocator, _reorderableRepeatStrategyLocator.ReorderableRepeatStrategyLocator), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = (_class2 = function (_AbstractRepeater) {
  _inherits(ReorderableRepeat, _AbstractRepeater);

  function ReorderableRepeat(ea, taskQueue, bindingEngine, dndService, viewFactory, instruction, viewSlot, viewResources, observerLocator, strategyLocator) {
    _classCallCheck(this, ReorderableRepeat);

    var _this = _possibleConstructorReturn(this, _AbstractRepeater.call(this, {
      local: 'item',
      viewsRequireLifecycle: (0, _aureliaTemplatingResources.viewsRequireLifecycle)(viewFactory)
    }));

    _initDefineProp(_this, 'items', _descriptor, _this);

    _initDefineProp(_this, 'local', _descriptor2, _this);

    _initDefineProp(_this, 'intention', _descriptor3, _this);

    _initDefineProp(_this, 'patchedItems', _descriptor4, _this);

    _this.type = 'reorder-' + seed;
    seed += 1;

    _this.ea = ea;
    _this.taskQueue = taskQueue;
    _this.bindingEngine = bindingEngine;
    _this.dndService = dndService;
    _this.viewFactory = viewFactory;
    _this.instruction = instruction;
    _this.viewSlot = viewSlot;
    _this.lookupFunctions = viewResources.lookupFunctions;
    _this.observerLocator = observerLocator;
    _this.strategyLocator = strategyLocator;
    _this.ignoreMutation = false;
    _this.sourceExpression = (0, _aureliaTemplatingResources.getItemsSourceExpression)(_this.instruction, 'reorderable-repeat.for');
    if (_this.sourceExpression instanceof _aureliaBinding.BindingBehavior) {
      throw new Error('BindingBehavior is not supported in reorderable-repeat');
    }
    if (_this.sourceExpression instanceof _aureliaBinding.ValueConverter) {
      throw new Error('ValueConverter is not supported in reorderable-repeat');
    }
    if ((0, _aureliaTemplatingResources.isOneTime)(_this.sourceExpression)) {
      throw new Error('oneTime binding is not supported in reorderable-repeat');
    }
    _this.viewsRequireLifecycle = (0, _aureliaTemplatingResources.viewsRequireLifecycle)(viewFactory);
    return _this;
  }

  ReorderableRepeat.prototype.call = function call(context, changes) {
    this[context](this.items, changes);
  };

  ReorderableRepeat.prototype.bind = function bind(bindingContext, overrideContext) {
    var _this2 = this;

    this.scope = { bindingContext: bindingContext, overrideContext: overrideContext };
    this.matcherBinding = this._captureAndRemoveMatcherBinding();
    this.arrayObserver = this.bindingEngine.collectionObserver(this.items).subscribe(this._itemsMutated.bind(this));
    this._subsribers = [this.ea.subscribe('dnd:willStart', function () {
      _this2.intention = null;
      _this2.views().forEach(function (v) {
        classes.rm(v.firstChild, 'reorderable-repeat-reordering');
        classes.rm(v.firstChild, 'reorderable-repeat-dragging-me');
      });
    }), this.ea.subscribe('dnd:didEnd', function () {
      _this2.views().forEach(function (v) {
        classes.rm(v.firstChild, 'reorderable-repeat-reordering');
        classes.rm(v.firstChild, 'reorderable-repeat-dragging-me');
      });

      if (!_this2.intention) return;
      var _intention = _this2.intention,
          fromIndex = _intention.fromIndex,
          toIndex = _intention.toIndex;

      _this2.intention = null;

      if (fromIndex === toIndex) return;

      var item = _this2.items[fromIndex];
      _this2.items.splice(fromIndex, 1);
      _this2.items.splice(toIndex, 0, item);

      var afterReordering = _this2._reorderableAfterReorderingFunc();
      if (afterReordering) afterReordering(_this2.items);
    })];
    this.patchedItems = [].concat(this.items);
    this.patchedItemsChanged();
  };

  ReorderableRepeat.prototype.unbind = function unbind() {
    this.scope = null;
    this.items = null;
    this.matcherBinding = null;
    this.viewSlot.removeAll(true);
    if (this.arrayObserver) {
      this.arrayObserver.dispose();
      this.arrayObserver = null;
    }
    this._subsribers.forEach(function (s) {
      return s.dispose();
    });
    this._subsribers = [];
  };

  ReorderableRepeat.prototype.intentionChanged = function intentionChanged(newIntention) {
    if (newIntention) {
      var fromIndex = newIntention.fromIndex,
          toIndex = newIntention.toIndex;

      var patched = [].concat(this.items);
      var item = this.items[fromIndex];
      patched.splice(fromIndex, 1);
      patched.splice(toIndex, 0, item);
      this.patchedItems = patched;
    }
  };

  ReorderableRepeat.prototype.itemsChanged = function itemsChanged(newVal, oldVal) {
    if (!this.scope) {
      return;
    }

    if (this.arrayObserver) {
      this.arrayObserver.dispose();
      this.arrayObserver = null;
    }

    this.arrayObserver = this.bindingEngine.collectionObserver(this.items).subscribe(this._itemsMutated.bind(this));

    if (this.intention === null) {
      this.patchedItems = [].concat(this.items);
    } else {
      this.intention = null;
    }
  };

  ReorderableRepeat.prototype._itemsMutated = function _itemsMutated() {
    if (this.intention === null) {
      this.patchedItems = [].concat(this.items);
    } else {
      this.intention = null;
    }
  };

  ReorderableRepeat.prototype.patchedItemsChanged = function patchedItemsChanged() {
    if (!this.scope) {
      return;
    }

    this.strategy = this.strategyLocator.getStrategy(this.patchedItems);
    if (!this.strategy) {
      throw new Error('Value for \'' + this.sourceExpression + '\' is non-repeatable');
    }

    this.strategy.instanceChanged(this, this.patchedItems);
  };

  ReorderableRepeat.prototype._captureAndRemoveMatcherBinding = function _captureAndRemoveMatcherBinding() {
    if (this.viewFactory.viewFactory) {
      var instructions = this.viewFactory.viewFactory.instructions;
      var instructionIds = Object.keys(instructions);
      for (var i = 0; i < instructionIds.length; i++) {
        var expressions = instructions[instructionIds[i]].expressions;
        if (expressions) {
          for (var ii = 0; i < expressions.length; i++) {
            if (expressions[ii].targetProperty === 'matcher') {
              var matcherBinding = expressions[ii];
              expressions.splice(ii, 1);
              return matcherBinding;
            }
          }
        }
      }
    }

    return undefined;
  };

  ReorderableRepeat.prototype.viewCount = function viewCount() {
    return this.viewSlot.children.length;
  };

  ReorderableRepeat.prototype.views = function views() {
    return this.viewSlot.children;
  };

  ReorderableRepeat.prototype.view = function view(index) {
    return this.viewSlot.children[index];
  };

  ReorderableRepeat.prototype.matcher = function matcher() {
    return this.matcherBinding ? this.matcherBinding.sourceExpression.evaluate(this.scope, this.matcherBinding.lookupFunctions) : null;
  };

  ReorderableRepeat.prototype.addView = function addView(bindingContext, overrideContext) {
    var view = this.viewFactory.create();
    window.ttview = view;
    view.bind(bindingContext, overrideContext);
    this.viewSlot.add(view);
    window.ttview = view;
    this._registerDnd(view);
  };

  ReorderableRepeat.prototype.insertView = function insertView(index, bindingContext, overrideContext) {
    var view = this.viewFactory.create();
    view.bind(bindingContext, overrideContext);
    this.viewSlot.insert(index, view);
    this._registerDnd(view);
  };

  ReorderableRepeat.prototype.moveView = function moveView(sourceIndex, targetIndex) {
    this.viewSlot.move(sourceIndex, targetIndex);
  };

  ReorderableRepeat.prototype.removeAllViews = function removeAllViews(returnToCache, skipAnimation) {
    var _this3 = this;

    this.views().forEach(function (view) {
      return _this3._unRegisterDnd(view);
    });
    return this.viewSlot.removeAll(returnToCache, skipAnimation);
  };

  ReorderableRepeat.prototype.removeViews = function removeViews(viewsToRemove, returnToCache, skipAnimation) {
    var _this4 = this;

    viewsToRemove.forEach(function (view) {
      return _this4._unRegisterDnd(view);
    });
    return this.viewSlot.removeMany(viewsToRemove, returnToCache, skipAnimation);
  };

  ReorderableRepeat.prototype.removeView = function removeView(index, returnToCache, skipAnimation) {
    this._unRegisterDnd(this.view(index));
    return this.viewSlot.removeAt(index, returnToCache, skipAnimation);
  };

  ReorderableRepeat.prototype.updateBindings = function updateBindings(view) {
    this._unRegisterDnd(view);

    var j = view.bindings.length;
    while (j--) {
      (0, _aureliaTemplatingResources.updateOneTimeBinding)(view.bindings[j]);
    }
    j = view.controllers.length;
    while (j--) {
      var k = view.controllers[j].boundProperties.length;
      while (k--) {
        var binding = view.controllers[j].boundProperties[k].binding;
        (0, _aureliaTemplatingResources.updateOneTimeBinding)(binding);
      }
    }

    this._registerDnd(view);
  };

  ReorderableRepeat.prototype._additionalAttribute = function _additionalAttribute(view, attribute) {
    return view && view.firstChild && view.firstChild.au && view.firstChild.au[attribute] ? view.firstChild.au[attribute].instruction.attributes[attribute] : undefined;
  };

  ReorderableRepeat.prototype._reorderableDirection = function _reorderableDirection(view) {
    var attr = this._additionalAttribute(view, 'reorderable-direction');
    if (attr && attr.sourceExpression) {
      attr = attr.sourceExpression.evaluate(this.scope);
    }

    if (typeof attr === 'string') {
      return attr.toLowerCase() || 'down';
    }
    return 'down';
  };

  ReorderableRepeat.prototype._dndHandlerSelector = function _dndHandlerSelector(view) {
    var attr = this._additionalAttribute(view, 'reorderable-dnd-handler-selector');
    if (attr && attr.sourceExpression) {
      attr = attr.sourceExpression.evaluate(this.scope);
    }

    if (typeof attr === 'string') {
      return attr;
    }
  };

  ReorderableRepeat.prototype._dndPreviewFunc = function _dndPreviewFunc(view) {
    var func = this._additionalAttribute(view, 'reorderable-dnd-preview');

    if (!func) {
      return null;
    } else if (typeof func === 'string') {
      var funcCall = this.scope.overrideContext.bindingContext[func];

      if (typeof funcCall === 'function') {
        return funcCall.bind(this.scope.overrideContext.bindingContext);
      }
      throw new Error("'reorderable-dnd-preview' must be a function or evaluate to one");
    } else if (func.sourceExpression) {
      return function (item, scope) {
        return func.sourceExpression.evaluate(scope);
      };
    } else {
      throw new Error("'reorderable-dnd-preview' must be a function or evaluate to one");
    }
  };

  ReorderableRepeat.prototype._reorderableAfterReorderingFunc = function _reorderableAfterReorderingFunc() {
    var _this5 = this;

    var func = this._additionalAttribute(this.view(0), 'reorderable-after-reordering');

    if (!func) {
      return null;
    } else if (typeof func === 'string') {
      var funcCall = this.scope.overrideContext.bindingContext[func];

      if (typeof funcCall === 'function') {
        return funcCall.bind(this.scope.overrideContext.bindingContext);
      }
      throw new Error("'reorderable-after-reordering' must be a function or evaluate to one");
    } else if (func.sourceExpression) {
      return function () {
        return func.sourceExpression.evaluate(_this5.scope);
      };
    } else {
      throw new Error("'reorderable-after-reordering' must be a function or evaluate to one");
    }
  };

  ReorderableRepeat.prototype._dndHover = function _dndHover(location, index, direction) {
    var mouseEndAt = location.mouseEndAt,
        targetElementRect = location.targetElementRect;

    var x = mouseEndAt.x - targetElementRect.x;
    var y = mouseEndAt.y - targetElementRect.y;

    var inLeastHalf = void 0;

    if (direction === 'left') {
      inLeastHalf = x > targetElementRect.width / 2;
    } else if (direction === 'right') {
      inLeastHalf = x < targetElementRect.width / 2;
    } else if (direction === 'up') {
      inLeastHalf = y > targetElementRect.height / 2;
    } else {
        inLeastHalf = y < targetElementRect.height / 2;
      }

    if (inLeastHalf) {
      this._updateIntention(index, true);
    } else {
      this._updateIntention(index, false);
    }
  };

  ReorderableRepeat.prototype._registerDnd = function _registerDnd(view) {
    var _this6 = this;

    var local = this.local;

    var el = view.firstChild;
    var item = view.bindingContext[local];
    var index = view.overrideContext.$index;
    var handlerSelector = this._dndHandlerSelector(view);
    var handler = void 0;
    if (handlerSelector) {
      handler = view.firstChild.querySelector(handlerSelector);
    }
    var direction = this._reorderableDirection(view);
    var _previewFunc = this._dndPreviewFunc(view);

    this.dndService.addSource({
      dndModel: function dndModel() {
        return { type: _this6.type, index: index };
      },
      dndPreview: _previewFunc && function () {
        return _previewFunc(item, view);
      },
      dndElement: el
    }, handler && { handler: handler });

    this.dndService.addTarget({
      dndElement: el,
      dndCanDrop: function dndCanDrop(model) {
        var canDrop = model.type === _this6.type && (_this6.intention ? _this6.intention.toIndex !== index : model.index !== index);

        if (model.type === _this6.type) {
          _this6.taskQueue.queueMicroTask(function () {
            classes.add(el, 'reorderable-repeat-reordering');
          });
        }

        if (model.type === _this6.type && !canDrop) {
          _this6.taskQueue.queueMicroTask(function () {
            classes.add(el, 'reorderable-repeat-dragging-me');
          });
        }
        return canDrop;
      },
      dndHover: function dndHover(location) {
        _this6._dndHover(location, index, direction);
      },
      dndDrop: function dndDrop() {}
    });
  };

  ReorderableRepeat.prototype._unRegisterDnd = function _unRegisterDnd(view) {
    classes.rm(view.firstChild, 'reorderable-repeat-reordering');
    classes.rm(view.firstChild, 'reorderable-repeat-dragging-me');
    this.dndService.removeSource(view.firstChild);
    this.dndService.removeTarget(view.firstChild);
  };

  ReorderableRepeat.prototype._updateIntention = function _updateIntention(targetIndex, beforeTarget) {
    var _dndService = this.dndService,
        isProcessing = _dndService.isProcessing,
        model = _dndService.model;

    if (!isProcessing) return;
    if (model.type !== this.type) return;

    if (targetIndex < 0) return;

    var originalIndex = void 0;
    var currentIndex = void 0;
    var nextIndex = void 0;
    if (this.intention) {
      originalIndex = this.intention.fromIndex;
      currentIndex = this.intention.toIndex;
    } else {
      originalIndex = model.index;
      if (originalIndex < 0) return;
      currentIndex = originalIndex;
    }

    if (currentIndex < targetIndex) {
      if (beforeTarget) {
        nextIndex = targetIndex - 1;
      } else {
        nextIndex = targetIndex;
      }
    } else {
        if (beforeTarget) {
          nextIndex = targetIndex;
        } else {
          nextIndex = targetIndex + 1;
        }
      }

    if (!this.intention || this.intention.fromIndex !== originalIndex || this.intention.toIndex !== nextIndex) {
      this.intention = {
        fromIndex: originalIndex,
        toIndex: nextIndex
      };
    }
  };

  return ReorderableRepeat;
}(_aureliaTemplatingResources.AbstractRepeater), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'items', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'local', [_aureliaTemplating.bindable], {
  enumerable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, 'intention', [_aureliaBinding.observable], {
  enumerable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, 'patchedItems', [_aureliaBinding.observable], {
  enumerable: true,
  initializer: null
})), _class2)) || _class) || _class) || _class);
});

define('bcx-aurelia-reorderable-repeat/dist/reorderable-repeat-strategy-locator',['require','exports','module','./simple-array-repeat-strategy'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.ReorderableRepeatStrategyLocator = undefined;

var _simpleArrayRepeatStrategy = require('./simple-array-repeat-strategy');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReorderableRepeatStrategyLocator = exports.ReorderableRepeatStrategyLocator = function () {
  function ReorderableRepeatStrategyLocator() {
    _classCallCheck(this, ReorderableRepeatStrategyLocator);

    this.matchers = [];
    this.strategies = [];
    this.addStrategy(function (items) {
      return items instanceof Array;
    }, new _simpleArrayRepeatStrategy.SimpleArrayRepeatStrategy());
  }

  ReorderableRepeatStrategyLocator.prototype.addStrategy = function addStrategy(matcher, strategy) {
    this.matchers.push(matcher);
    this.strategies.push(strategy);
  };

  ReorderableRepeatStrategyLocator.prototype.getStrategy = function getStrategy(items) {
    var matchers = this.matchers;

    for (var i = 0, ii = matchers.length; i < ii; ++i) {
      if (matchers[i](items)) {
        return this.strategies[i];
      }
    }

    return null;
  };

  return ReorderableRepeatStrategyLocator;
}();
});

define('bcx-aurelia-reorderable-repeat/dist/simple-array-repeat-strategy',['require','exports','module','aurelia-templating-resources'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.SimpleArrayRepeatStrategy = undefined;

var _aureliaTemplatingResources = require('aurelia-templating-resources');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SimpleArrayRepeatStrategy = exports.SimpleArrayRepeatStrategy = function () {
  function SimpleArrayRepeatStrategy() {
    _classCallCheck(this, SimpleArrayRepeatStrategy);
  }

  SimpleArrayRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {
    return observerLocator.getArrayObserver(items);
  };

  SimpleArrayRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
    repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);

    var itemsLength = items.length;
    if (items && itemsLength > 0) {
      this._standardProcessInstanceChanged(repeat, items);
    }
  };

  SimpleArrayRepeatStrategy.prototype._standardProcessInstanceChanged = function _standardProcessInstanceChanged(repeat, items) {
    for (var i = 0, ii = items.length; i < ii; i++) {
      var overrideContext = (0, _aureliaTemplatingResources.createFullOverrideContext)(repeat, items[i], i, ii);
      repeat.addView(overrideContext.bindingContext, overrideContext);
    }
  };

  return SimpleArrayRepeatStrategy;
}();
});

define('bcx-doc-base/dist/binding-behaviors/left-click',['require','exports','module'],function (require, exports, module) {'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function handleLeftClickEvent(event) {
  if (event.button != 0) return;

  this.leftClickEventCallSource(event);
}

var LeftClickBindingBehavior = exports.LeftClickBindingBehavior = function () {
  function LeftClickBindingBehavior() {
    _classCallCheck(this, LeftClickBindingBehavior);
  }

  LeftClickBindingBehavior.prototype.bind = function bind(binding) {
    if (!binding.callSource || !binding.targetEvent) throw new Error('leftClick binding behavior only supports event.');
    binding.leftClickEventCallSource = binding.callSource;
    binding.callSource = handleLeftClickEvent;
  };

  LeftClickBindingBehavior.prototype.unbind = function unbind(binding) {
    binding.callSource = binding.leftClickEventCallSource;
    binding.leftClickEventCallSource = null;
  };

  return LeftClickBindingBehavior;
}();
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJpbmRpbmctYmVoYXZpb3JzL2xlZnQtY2xpY2suanMiXSwibmFtZXMiOlsiaGFuZGxlTGVmdENsaWNrRXZlbnQiLCJldmVudCIsImJ1dHRvbiIsImxlZnRDbGlja0V2ZW50Q2FsbFNvdXJjZSIsIkxlZnRDbGlja0JpbmRpbmdCZWhhdmlvciIsImJpbmQiLCJiaW5kaW5nIiwiY2FsbFNvdXJjZSIsInRhcmdldEV2ZW50IiwiRXJyb3IiLCJ1bmJpbmQiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLFNBQVNBLG9CQUFULENBQThCQyxLQUE5QixFQUFxQztBQUNuQyxNQUFJQSxNQUFNQyxNQUFOLElBQWdCLENBQXBCLEVBQXVCOztBQUV2QixPQUFLQyx3QkFBTCxDQUE4QkYsS0FBOUI7QUFDRDs7SUFFWUcsd0IsV0FBQUEsd0I7Ozs7O3FDQUNYQyxJLGlCQUFLQyxPLEVBQVM7QUFDWixRQUFJLENBQUNBLFFBQVFDLFVBQVQsSUFBdUIsQ0FBQ0QsUUFBUUUsV0FBcEMsRUFBaUQsTUFBTSxJQUFJQyxLQUFKLENBQVUsaURBQVYsQ0FBTjtBQUNqREgsWUFBUUgsd0JBQVIsR0FBbUNHLFFBQVFDLFVBQTNDO0FBQ0FELFlBQVFDLFVBQVIsR0FBcUJQLG9CQUFyQjtBQUNELEc7O3FDQUVEVSxNLG1CQUFPSixPLEVBQVM7QUFDZEEsWUFBUUMsVUFBUixHQUFxQkQsUUFBUUgsd0JBQTdCO0FBQ0FHLFlBQVFILHdCQUFSLEdBQW1DLElBQW5DO0FBQ0QsRyIsImZpbGUiOiJiaW5kaW5nLWJlaGF2aW9ycy9sZWZ0LWNsaWNrLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaGFuZGxlTGVmdENsaWNrRXZlbnQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmJ1dHRvbiAhPSAwKSByZXR1cm47XG4gIC8vIG9ubHkgY2FsbCByZWFsIGNhbGxiYWNrIHdoZW4gaXQgaXMgZWl0aGVyIGxlZnQgbW91c2UgY2xpY2sgb3IgdG91Y2ggZXZlbnQuXG4gIHRoaXMubGVmdENsaWNrRXZlbnRDYWxsU291cmNlKGV2ZW50KTtcbn1cblxuZXhwb3J0IGNsYXNzIExlZnRDbGlja0JpbmRpbmdCZWhhdmlvciB7XG4gIGJpbmQoYmluZGluZykge1xuICAgIGlmICghYmluZGluZy5jYWxsU291cmNlIHx8ICFiaW5kaW5nLnRhcmdldEV2ZW50KSB0aHJvdyBuZXcgRXJyb3IoJ2xlZnRDbGljayBiaW5kaW5nIGJlaGF2aW9yIG9ubHkgc3VwcG9ydHMgZXZlbnQuJyk7XG4gICAgYmluZGluZy5sZWZ0Q2xpY2tFdmVudENhbGxTb3VyY2UgPSBiaW5kaW5nLmNhbGxTb3VyY2U7XG4gICAgYmluZGluZy5jYWxsU291cmNlID0gaGFuZGxlTGVmdENsaWNrRXZlbnQ7XG4gIH1cblxuICB1bmJpbmQoYmluZGluZykge1xuICAgIGJpbmRpbmcuY2FsbFNvdXJjZSA9IGJpbmRpbmcubGVmdENsaWNrRXZlbnRDYWxsU291cmNlO1xuICAgIGJpbmRpbmcubGVmdENsaWNrRXZlbnRDYWxsU291cmNlID0gbnVsbDtcbiAgfVxufVxuIl19

});

define('text!bcx-doc-base/dist/css/doc.css', ['module'], function(module) { module.exports = "/*! normalize.css v8.0.0 | MIT License | github.com/necolas/normalize.css */\n/* Document\n   ========================================================================== */\n/**\n * 1. Correct the line height in all browsers.\n * 2. Prevent adjustments of font size after orientation changes in iOS.\n */\nhtml {\n  line-height: 1.15;\n  /* 1 */\n  -webkit-text-size-adjust: 100%;\n  /* 2 */ }\n\n/* Sections\n   ========================================================================== */\n/**\n * Remove the margin in all browsers.\n */\nbody {\n  margin: 0; }\n\n/**\n * Correct the font size and margin on `h1` elements within `section` and\n * `article` contexts in Chrome, Firefox, and Safari.\n */\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0; }\n\n/* Grouping content\n   ========================================================================== */\n/**\n * 1. Add the correct box sizing in Firefox.\n * 2. Show the overflow in Edge and IE.\n */\nhr {\n  box-sizing: content-box;\n  /* 1 */\n  height: 0;\n  /* 1 */\n  overflow: visible;\n  /* 2 */ }\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\npre {\n  font-family: monospace, monospace;\n  /* 1 */\n  font-size: 1em;\n  /* 2 */ }\n\n/* Text-level semantics\n   ========================================================================== */\n/**\n * Remove the gray background on active links in IE 10.\n */\na {\n  background-color: transparent; }\n\n/**\n * 1. Remove the bottom border in Chrome 57-\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n */\nabbr[title] {\n  border-bottom: none;\n  /* 1 */\n  text-decoration: underline;\n  /* 2 */\n  -webkit-text-decoration: underline dotted;\n          text-decoration: underline dotted;\n  /* 2 */ }\n\n/**\n * Add the correct font weight in Chrome, Edge, and Safari.\n */\nb,\nstrong {\n  font-weight: bolder; }\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\ncode,\nkbd,\nsamp {\n  font-family: monospace, monospace;\n  /* 1 */\n  font-size: 1em;\n  /* 2 */ }\n\n/**\n * Add the correct font size in all browsers.\n */\nsmall {\n  font-size: 80%; }\n\n/**\n * Prevent `sub` and `sup` elements from affecting the line height in\n * all browsers.\n */\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline; }\n\nsub {\n  bottom: -0.25em; }\n\nsup {\n  top: -0.5em; }\n\n/* Embedded content\n   ========================================================================== */\n/**\n * Remove the border on images inside links in IE 10.\n */\nimg {\n  border-style: none; }\n\n/* Forms\n   ========================================================================== */\n/**\n * 1. Change the font styles in all browsers.\n * 2. Remove the margin in Firefox and Safari.\n */\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit;\n  /* 1 */\n  font-size: 100%;\n  /* 1 */\n  line-height: 1.15;\n  /* 1 */\n  margin: 0;\n  /* 2 */ }\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\nbutton,\ninput {\n  /* 1 */\n  overflow: visible; }\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\nbutton,\nselect {\n  /* 1 */\n  text-transform: none; }\n\n/**\n * Correct the inability to style clickable types in iOS and Safari.\n */\nbutton,\n[type=\"button\"],\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button; }\n\n/**\n * Remove the inner border and padding in Firefox.\n */\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0; }\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText; }\n\n/**\n * Correct the padding in Firefox.\n */\nfieldset {\n  padding: 0.35em 0.75em 0.625em; }\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\nlegend {\n  box-sizing: border-box;\n  /* 1 */\n  color: inherit;\n  /* 2 */\n  display: table;\n  /* 1 */\n  max-width: 100%;\n  /* 1 */\n  padding: 0;\n  /* 3 */\n  white-space: normal;\n  /* 1 */ }\n\n/**\n * Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\nprogress {\n  vertical-align: baseline; }\n\n/**\n * Remove the default vertical scrollbar in IE 10+.\n */\ntextarea {\n  overflow: auto; }\n\n/**\n * 1. Add the correct box sizing in IE 10.\n * 2. Remove the padding in IE 10.\n */\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box;\n  /* 1 */\n  padding: 0;\n  /* 2 */ }\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto; }\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n[type=\"search\"] {\n  -webkit-appearance: textfield;\n  /* 1 */\n  outline-offset: -2px;\n  /* 2 */ }\n\n/**\n * Remove the inner padding in Chrome and Safari on macOS.\n */\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none; }\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n::-webkit-file-upload-button {\n  -webkit-appearance: button;\n  /* 1 */\n  font: inherit;\n  /* 2 */ }\n\n/* Interactive\n   ========================================================================== */\n/*\n * Add the correct display in Edge, IE 10+, and Firefox.\n */\ndetails {\n  display: block; }\n\n/*\n * Add the correct display in all browsers.\n */\nsummary {\n  display: list-item; }\n\n/* Misc\n   ========================================================================== */\n/**\n * Add the correct display in IE 10+.\n */\ntemplate {\n  display: none; }\n\n/**\n * Add the correct display in IE 10.\n */\n[hidden] {\n  display: none; }\n\n@font-face {\n  font-family: 'Font Awesome 5 Brands';\n  font-style: normal;\n  font-weight: normal;\n  src: url(\"data:application/font-woff;base64,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\") format(\"woff\"); }\n\n.fab {\n  font-family: 'Font Awesome 5 Brands'; }\n\n@font-face {\n  font-family: 'Font Awesome 5 Pro';\n  font-style: normal;\n  font-weight: 300;\n  src: url(\"data:application/font-woff;base64,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\") format(\"woff\"); }\n\n.fal {\n  font-family: 'Font Awesome 5 Pro';\n  font-weight: 300; }\n\n@font-face {\n  font-family: 'Font Awesome 5 Pro';\n  font-style: normal;\n  font-weight: 400;\n  src: url(\"data:application/font-woff;base64,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\") format(\"woff\"); }\n\n.far {\n  font-family: 'Font Awesome 5 Pro';\n  font-weight: 400; }\n\n@font-face {\n  font-family: 'Font Awesome 5 Pro';\n  font-style: normal;\n  font-weight: 900;\n  src: url(\"data:application/font-woff;base64,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\") format(\"woff\"); }\n\n.fa,\n.fas {\n  font-family: 'Font Awesome 5 Pro';\n  font-weight: 900; }\n\n/*!\n * Font Awesome Pro 5.0.7 by @fontawesome - https://fontawesome.com\n * License - https://fontawesome.com/license (Commercial License)\n */\n.fa,\n.fas,\n.far,\n.fal,\n.fab {\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  display: inline-block;\n  font-style: normal;\n  font-variant: normal;\n  text-rendering: auto;\n  line-height: 1; }\n\n.fa-lg {\n  font-size: 1.33333em;\n  line-height: 0.75em;\n  vertical-align: -.0667em; }\n\n.fa-xs {\n  font-size: .75em; }\n\n.fa-sm {\n  font-size: .875em; }\n\n.fa-1x {\n  font-size: 1em; }\n\n.fa-2x {\n  font-size: 2em; }\n\n.fa-3x {\n  font-size: 3em; }\n\n.fa-4x {\n  font-size: 4em; }\n\n.fa-5x {\n  font-size: 5em; }\n\n.fa-6x {\n  font-size: 6em; }\n\n.fa-7x {\n  font-size: 7em; }\n\n.fa-8x {\n  font-size: 8em; }\n\n.fa-9x {\n  font-size: 9em; }\n\n.fa-10x {\n  font-size: 10em; }\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em; }\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: 2.5em;\n  padding-left: 0; }\n  .fa-ul > li {\n    position: relative; }\n\n.fa-li {\n  left: -2em;\n  position: absolute;\n  text-align: center;\n  width: 2em;\n  line-height: inherit; }\n\n.fa-border {\n  border: solid 0.08em #eee;\n  border-radius: .1em;\n  padding: .2em .25em .15em; }\n\n.fa-pull-left {\n  float: left; }\n\n.fa-pull-right {\n  float: right; }\n\n.fa.fa-pull-left,\n.fas.fa-pull-left,\n.far.fa-pull-left,\n.fal.fa-pull-left,\n.fab.fa-pull-left {\n  margin-right: .3em; }\n\n.fa.fa-pull-right,\n.fas.fa-pull-right,\n.far.fa-pull-right,\n.fal.fa-pull-right,\n.fab.fa-pull-right {\n  margin-left: .3em; }\n\n.fa-spin {\n  -webkit-animation: fa-spin 2s infinite linear;\n          animation: fa-spin 2s infinite linear; }\n\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n          animation: fa-spin 1s infinite steps(8); }\n\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n.fa-rotate-90 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\";\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg); }\n\n.fa-rotate-180 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)\";\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg); }\n\n.fa-rotate-270 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)\";\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg); }\n\n.fa-flip-horizontal {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)\";\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1); }\n\n.fa-flip-vertical {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\";\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1); }\n\n.fa-flip-horizontal.fa-flip-vertical {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\";\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1); }\n\n:root .fa-rotate-90,\n:root .fa-rotate-180,\n:root .fa-rotate-270,\n:root .fa-flip-horizontal,\n:root .fa-flip-vertical {\n  -webkit-filter: none;\n          filter: none; }\n\n.fa-stack {\n  display: inline-block;\n  height: 2em;\n  line-height: 2em;\n  position: relative;\n  vertical-align: middle;\n  width: 2em; }\n\n.fa-stack-1x,\n.fa-stack-2x {\n  left: 0;\n  position: absolute;\n  text-align: center;\n  width: 100%; }\n\n.fa-stack-1x {\n  line-height: inherit; }\n\n.fa-stack-2x {\n  font-size: 2em; }\n\n.fa-inverse {\n  color: #fff; }\n\n/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen\nreaders do not read off random characters that represent icons */\n.fa-500px:before {\n  content: \"\\f26e\"; }\n\n.fa-accessible-icon:before {\n  content: \"\\f368\"; }\n\n.fa-accusoft:before {\n  content: \"\\f369\"; }\n\n.fa-address-book:before {\n  content: \"\\f2b9\"; }\n\n.fa-address-card:before {\n  content: \"\\f2bb\"; }\n\n.fa-adjust:before {\n  content: \"\\f042\"; }\n\n.fa-adn:before {\n  content: \"\\f170\"; }\n\n.fa-adversal:before {\n  content: \"\\f36a\"; }\n\n.fa-affiliatetheme:before {\n  content: \"\\f36b\"; }\n\n.fa-alarm-clock:before {\n  content: \"\\f34e\"; }\n\n.fa-algolia:before {\n  content: \"\\f36c\"; }\n\n.fa-align-center:before {\n  content: \"\\f037\"; }\n\n.fa-align-justify:before {\n  content: \"\\f039\"; }\n\n.fa-align-left:before {\n  content: \"\\f036\"; }\n\n.fa-align-right:before {\n  content: \"\\f038\"; }\n\n.fa-allergies:before {\n  content: \"\\f461\"; }\n\n.fa-amazon:before {\n  content: \"\\f270\"; }\n\n.fa-amazon-pay:before {\n  content: \"\\f42c\"; }\n\n.fa-ambulance:before {\n  content: \"\\f0f9\"; }\n\n.fa-american-sign-language-interpreting:before {\n  content: \"\\f2a3\"; }\n\n.fa-amilia:before {\n  content: \"\\f36d\"; }\n\n.fa-anchor:before {\n  content: \"\\f13d\"; }\n\n.fa-android:before {\n  content: \"\\f17b\"; }\n\n.fa-angellist:before {\n  content: \"\\f209\"; }\n\n.fa-angle-double-down:before {\n  content: \"\\f103\"; }\n\n.fa-angle-double-left:before {\n  content: \"\\f100\"; }\n\n.fa-angle-double-right:before {\n  content: \"\\f101\"; }\n\n.fa-angle-double-up:before {\n  content: \"\\f102\"; }\n\n.fa-angle-down:before {\n  content: \"\\f107\"; }\n\n.fa-angle-left:before {\n  content: \"\\f104\"; }\n\n.fa-angle-right:before {\n  content: \"\\f105\"; }\n\n.fa-angle-up:before {\n  content: \"\\f106\"; }\n\n.fa-angrycreative:before {\n  content: \"\\f36e\"; }\n\n.fa-angular:before {\n  content: \"\\f420\"; }\n\n.fa-app-store:before {\n  content: \"\\f36f\"; }\n\n.fa-app-store-ios:before {\n  content: \"\\f370\"; }\n\n.fa-apper:before {\n  content: \"\\f371\"; }\n\n.fa-apple:before {\n  content: \"\\f179\"; }\n\n.fa-apple-pay:before {\n  content: \"\\f415\"; }\n\n.fa-archive:before {\n  content: \"\\f187\"; }\n\n.fa-arrow-alt-circle-down:before {\n  content: \"\\f358\"; }\n\n.fa-arrow-alt-circle-left:before {\n  content: \"\\f359\"; }\n\n.fa-arrow-alt-circle-right:before {\n  content: \"\\f35a\"; }\n\n.fa-arrow-alt-circle-up:before {\n  content: \"\\f35b\"; }\n\n.fa-arrow-alt-down:before {\n  content: \"\\f354\"; }\n\n.fa-arrow-alt-from-bottom:before {\n  content: \"\\f346\"; }\n\n.fa-arrow-alt-from-left:before {\n  content: \"\\f347\"; }\n\n.fa-arrow-alt-from-right:before {\n  content: \"\\f348\"; }\n\n.fa-arrow-alt-from-top:before {\n  content: \"\\f349\"; }\n\n.fa-arrow-alt-left:before {\n  content: \"\\f355\"; }\n\n.fa-arrow-alt-right:before {\n  content: \"\\f356\"; }\n\n.fa-arrow-alt-square-down:before {\n  content: \"\\f350\"; }\n\n.fa-arrow-alt-square-left:before {\n  content: \"\\f351\"; }\n\n.fa-arrow-alt-square-right:before {\n  content: \"\\f352\"; }\n\n.fa-arrow-alt-square-up:before {\n  content: \"\\f353\"; }\n\n.fa-arrow-alt-to-bottom:before {\n  content: \"\\f34a\"; }\n\n.fa-arrow-alt-to-left:before {\n  content: \"\\f34b\"; }\n\n.fa-arrow-alt-to-right:before {\n  content: \"\\f34c\"; }\n\n.fa-arrow-alt-to-top:before {\n  content: \"\\f34d\"; }\n\n.fa-arrow-alt-up:before {\n  content: \"\\f357\"; }\n\n.fa-arrow-circle-down:before {\n  content: \"\\f0ab\"; }\n\n.fa-arrow-circle-left:before {\n  content: \"\\f0a8\"; }\n\n.fa-arrow-circle-right:before {\n  content: \"\\f0a9\"; }\n\n.fa-arrow-circle-up:before {\n  content: \"\\f0aa\"; }\n\n.fa-arrow-down:before {\n  content: \"\\f063\"; }\n\n.fa-arrow-from-bottom:before {\n  content: \"\\f342\"; }\n\n.fa-arrow-from-left:before {\n  content: \"\\f343\"; }\n\n.fa-arrow-from-right:before {\n  content: \"\\f344\"; }\n\n.fa-arrow-from-top:before {\n  content: \"\\f345\"; }\n\n.fa-arrow-left:before {\n  content: \"\\f060\"; }\n\n.fa-arrow-right:before {\n  content: \"\\f061\"; }\n\n.fa-arrow-square-down:before {\n  content: \"\\f339\"; }\n\n.fa-arrow-square-left:before {\n  content: \"\\f33a\"; }\n\n.fa-arrow-square-right:before {\n  content: \"\\f33b\"; }\n\n.fa-arrow-square-up:before {\n  content: \"\\f33c\"; }\n\n.fa-arrow-to-bottom:before {\n  content: \"\\f33d\"; }\n\n.fa-arrow-to-left:before {\n  content: \"\\f33e\"; }\n\n.fa-arrow-to-right:before {\n  content: \"\\f340\"; }\n\n.fa-arrow-to-top:before {\n  content: \"\\f341\"; }\n\n.fa-arrow-up:before {\n  content: \"\\f062\"; }\n\n.fa-arrows:before {\n  content: \"\\f047\"; }\n\n.fa-arrows-alt:before {\n  content: \"\\f0b2\"; }\n\n.fa-arrows-alt-h:before {\n  content: \"\\f337\"; }\n\n.fa-arrows-alt-v:before {\n  content: \"\\f338\"; }\n\n.fa-arrows-h:before {\n  content: \"\\f07e\"; }\n\n.fa-arrows-v:before {\n  content: \"\\f07d\"; }\n\n.fa-assistive-listening-systems:before {\n  content: \"\\f2a2\"; }\n\n.fa-asterisk:before {\n  content: \"\\f069\"; }\n\n.fa-asymmetrik:before {\n  content: \"\\f372\"; }\n\n.fa-at:before {\n  content: \"\\f1fa\"; }\n\n.fa-audible:before {\n  content: \"\\f373\"; }\n\n.fa-audio-description:before {\n  content: \"\\f29e\"; }\n\n.fa-autoprefixer:before {\n  content: \"\\f41c\"; }\n\n.fa-avianex:before {\n  content: \"\\f374\"; }\n\n.fa-aviato:before {\n  content: \"\\f421\"; }\n\n.fa-aws:before {\n  content: \"\\f375\"; }\n\n.fa-backward:before {\n  content: \"\\f04a\"; }\n\n.fa-badge:before {\n  content: \"\\f335\"; }\n\n.fa-badge-check:before {\n  content: \"\\f336\"; }\n\n.fa-balance-scale:before {\n  content: \"\\f24e\"; }\n\n.fa-ban:before {\n  content: \"\\f05e\"; }\n\n.fa-band-aid:before {\n  content: \"\\f462\"; }\n\n.fa-bandcamp:before {\n  content: \"\\f2d5\"; }\n\n.fa-barcode:before {\n  content: \"\\f02a\"; }\n\n.fa-barcode-alt:before {\n  content: \"\\f463\"; }\n\n.fa-barcode-read:before {\n  content: \"\\f464\"; }\n\n.fa-barcode-scan:before {\n  content: \"\\f465\"; }\n\n.fa-bars:before {\n  content: \"\\f0c9\"; }\n\n.fa-baseball:before {\n  content: \"\\f432\"; }\n\n.fa-baseball-ball:before {\n  content: \"\\f433\"; }\n\n.fa-basketball-ball:before {\n  content: \"\\f434\"; }\n\n.fa-basketball-hoop:before {\n  content: \"\\f435\"; }\n\n.fa-bath:before {\n  content: \"\\f2cd\"; }\n\n.fa-battery-bolt:before {\n  content: \"\\f376\"; }\n\n.fa-battery-empty:before {\n  content: \"\\f244\"; }\n\n.fa-battery-full:before {\n  content: \"\\f240\"; }\n\n.fa-battery-half:before {\n  content: \"\\f242\"; }\n\n.fa-battery-quarter:before {\n  content: \"\\f243\"; }\n\n.fa-battery-slash:before {\n  content: \"\\f377\"; }\n\n.fa-battery-three-quarters:before {\n  content: \"\\f241\"; }\n\n.fa-bed:before {\n  content: \"\\f236\"; }\n\n.fa-beer:before {\n  content: \"\\f0fc\"; }\n\n.fa-behance:before {\n  content: \"\\f1b4\"; }\n\n.fa-behance-square:before {\n  content: \"\\f1b5\"; }\n\n.fa-bell:before {\n  content: \"\\f0f3\"; }\n\n.fa-bell-slash:before {\n  content: \"\\f1f6\"; }\n\n.fa-bicycle:before {\n  content: \"\\f206\"; }\n\n.fa-bimobject:before {\n  content: \"\\f378\"; }\n\n.fa-binoculars:before {\n  content: \"\\f1e5\"; }\n\n.fa-birthday-cake:before {\n  content: \"\\f1fd\"; }\n\n.fa-bitbucket:before {\n  content: \"\\f171\"; }\n\n.fa-bitcoin:before {\n  content: \"\\f379\"; }\n\n.fa-bity:before {\n  content: \"\\f37a\"; }\n\n.fa-black-tie:before {\n  content: \"\\f27e\"; }\n\n.fa-blackberry:before {\n  content: \"\\f37b\"; }\n\n.fa-blind:before {\n  content: \"\\f29d\"; }\n\n.fa-blogger:before {\n  content: \"\\f37c\"; }\n\n.fa-blogger-b:before {\n  content: \"\\f37d\"; }\n\n.fa-bluetooth:before {\n  content: \"\\f293\"; }\n\n.fa-bluetooth-b:before {\n  content: \"\\f294\"; }\n\n.fa-bold:before {\n  content: \"\\f032\"; }\n\n.fa-bolt:before {\n  content: \"\\f0e7\"; }\n\n.fa-bomb:before {\n  content: \"\\f1e2\"; }\n\n.fa-book:before {\n  content: \"\\f02d\"; }\n\n.fa-bookmark:before {\n  content: \"\\f02e\"; }\n\n.fa-bowling-ball:before {\n  content: \"\\f436\"; }\n\n.fa-bowling-pins:before {\n  content: \"\\f437\"; }\n\n.fa-box:before {\n  content: \"\\f466\"; }\n\n.fa-box-check:before {\n  content: \"\\f467\"; }\n\n.fa-boxes:before {\n  content: \"\\f468\"; }\n\n.fa-boxing-glove:before {\n  content: \"\\f438\"; }\n\n.fa-braille:before {\n  content: \"\\f2a1\"; }\n\n.fa-briefcase:before {\n  content: \"\\f0b1\"; }\n\n.fa-briefcase-medical:before {\n  content: \"\\f469\"; }\n\n.fa-browser:before {\n  content: \"\\f37e\"; }\n\n.fa-btc:before {\n  content: \"\\f15a\"; }\n\n.fa-bug:before {\n  content: \"\\f188\"; }\n\n.fa-building:before {\n  content: \"\\f1ad\"; }\n\n.fa-bullhorn:before {\n  content: \"\\f0a1\"; }\n\n.fa-bullseye:before {\n  content: \"\\f140\"; }\n\n.fa-burn:before {\n  content: \"\\f46a\"; }\n\n.fa-buromobelexperte:before {\n  content: \"\\f37f\"; }\n\n.fa-bus:before {\n  content: \"\\f207\"; }\n\n.fa-buysellads:before {\n  content: \"\\f20d\"; }\n\n.fa-calculator:before {\n  content: \"\\f1ec\"; }\n\n.fa-calendar:before {\n  content: \"\\f133\"; }\n\n.fa-calendar-alt:before {\n  content: \"\\f073\"; }\n\n.fa-calendar-check:before {\n  content: \"\\f274\"; }\n\n.fa-calendar-edit:before {\n  content: \"\\f333\"; }\n\n.fa-calendar-exclamation:before {\n  content: \"\\f334\"; }\n\n.fa-calendar-minus:before {\n  content: \"\\f272\"; }\n\n.fa-calendar-plus:before {\n  content: \"\\f271\"; }\n\n.fa-calendar-times:before {\n  content: \"\\f273\"; }\n\n.fa-camera:before {\n  content: \"\\f030\"; }\n\n.fa-camera-alt:before {\n  content: \"\\f332\"; }\n\n.fa-camera-retro:before {\n  content: \"\\f083\"; }\n\n.fa-capsules:before {\n  content: \"\\f46b\"; }\n\n.fa-car:before {\n  content: \"\\f1b9\"; }\n\n.fa-caret-circle-down:before {\n  content: \"\\f32d\"; }\n\n.fa-caret-circle-left:before {\n  content: \"\\f32e\"; }\n\n.fa-caret-circle-right:before {\n  content: \"\\f330\"; }\n\n.fa-caret-circle-up:before {\n  content: \"\\f331\"; }\n\n.fa-caret-down:before {\n  content: \"\\f0d7\"; }\n\n.fa-caret-left:before {\n  content: \"\\f0d9\"; }\n\n.fa-caret-right:before {\n  content: \"\\f0da\"; }\n\n.fa-caret-square-down:before {\n  content: \"\\f150\"; }\n\n.fa-caret-square-left:before {\n  content: \"\\f191\"; }\n\n.fa-caret-square-right:before {\n  content: \"\\f152\"; }\n\n.fa-caret-square-up:before {\n  content: \"\\f151\"; }\n\n.fa-caret-up:before {\n  content: \"\\f0d8\"; }\n\n.fa-cart-arrow-down:before {\n  content: \"\\f218\"; }\n\n.fa-cart-plus:before {\n  content: \"\\f217\"; }\n\n.fa-cc-amazon-pay:before {\n  content: \"\\f42d\"; }\n\n.fa-cc-amex:before {\n  content: \"\\f1f3\"; }\n\n.fa-cc-apple-pay:before {\n  content: \"\\f416\"; }\n\n.fa-cc-diners-club:before {\n  content: \"\\f24c\"; }\n\n.fa-cc-discover:before {\n  content: \"\\f1f2\"; }\n\n.fa-cc-jcb:before {\n  content: \"\\f24b\"; }\n\n.fa-cc-mastercard:before {\n  content: \"\\f1f1\"; }\n\n.fa-cc-paypal:before {\n  content: \"\\f1f4\"; }\n\n.fa-cc-stripe:before {\n  content: \"\\f1f5\"; }\n\n.fa-cc-visa:before {\n  content: \"\\f1f0\"; }\n\n.fa-centercode:before {\n  content: \"\\f380\"; }\n\n.fa-certificate:before {\n  content: \"\\f0a3\"; }\n\n.fa-chart-area:before {\n  content: \"\\f1fe\"; }\n\n.fa-chart-bar:before {\n  content: \"\\f080\"; }\n\n.fa-chart-line:before {\n  content: \"\\f201\"; }\n\n.fa-chart-pie:before {\n  content: \"\\f200\"; }\n\n.fa-check:before {\n  content: \"\\f00c\"; }\n\n.fa-check-circle:before {\n  content: \"\\f058\"; }\n\n.fa-check-square:before {\n  content: \"\\f14a\"; }\n\n.fa-chess:before {\n  content: \"\\f439\"; }\n\n.fa-chess-bishop:before {\n  content: \"\\f43a\"; }\n\n.fa-chess-bishop-alt:before {\n  content: \"\\f43b\"; }\n\n.fa-chess-board:before {\n  content: \"\\f43c\"; }\n\n.fa-chess-clock:before {\n  content: \"\\f43d\"; }\n\n.fa-chess-clock-alt:before {\n  content: \"\\f43e\"; }\n\n.fa-chess-king:before {\n  content: \"\\f43f\"; }\n\n.fa-chess-king-alt:before {\n  content: \"\\f440\"; }\n\n.fa-chess-knight:before {\n  content: \"\\f441\"; }\n\n.fa-chess-knight-alt:before {\n  content: \"\\f442\"; }\n\n.fa-chess-pawn:before {\n  content: \"\\f443\"; }\n\n.fa-chess-pawn-alt:before {\n  content: \"\\f444\"; }\n\n.fa-chess-queen:before {\n  content: \"\\f445\"; }\n\n.fa-chess-queen-alt:before {\n  content: \"\\f446\"; }\n\n.fa-chess-rook:before {\n  content: \"\\f447\"; }\n\n.fa-chess-rook-alt:before {\n  content: \"\\f448\"; }\n\n.fa-chevron-circle-down:before {\n  content: \"\\f13a\"; }\n\n.fa-chevron-circle-left:before {\n  content: \"\\f137\"; }\n\n.fa-chevron-circle-right:before {\n  content: \"\\f138\"; }\n\n.fa-chevron-circle-up:before {\n  content: \"\\f139\"; }\n\n.fa-chevron-double-down:before {\n  content: \"\\f322\"; }\n\n.fa-chevron-double-left:before {\n  content: \"\\f323\"; }\n\n.fa-chevron-double-right:before {\n  content: \"\\f324\"; }\n\n.fa-chevron-double-up:before {\n  content: \"\\f325\"; }\n\n.fa-chevron-down:before {\n  content: \"\\f078\"; }\n\n.fa-chevron-left:before {\n  content: \"\\f053\"; }\n\n.fa-chevron-right:before {\n  content: \"\\f054\"; }\n\n.fa-chevron-square-down:before {\n  content: \"\\f329\"; }\n\n.fa-chevron-square-left:before {\n  content: \"\\f32a\"; }\n\n.fa-chevron-square-right:before {\n  content: \"\\f32b\"; }\n\n.fa-chevron-square-up:before {\n  content: \"\\f32c\"; }\n\n.fa-chevron-up:before {\n  content: \"\\f077\"; }\n\n.fa-child:before {\n  content: \"\\f1ae\"; }\n\n.fa-chrome:before {\n  content: \"\\f268\"; }\n\n.fa-circle:before {\n  content: \"\\f111\"; }\n\n.fa-circle-notch:before {\n  content: \"\\f1ce\"; }\n\n.fa-clipboard:before {\n  content: \"\\f328\"; }\n\n.fa-clipboard-check:before {\n  content: \"\\f46c\"; }\n\n.fa-clipboard-list:before {\n  content: \"\\f46d\"; }\n\n.fa-clock:before {\n  content: \"\\f017\"; }\n\n.fa-clone:before {\n  content: \"\\f24d\"; }\n\n.fa-closed-captioning:before {\n  content: \"\\f20a\"; }\n\n.fa-cloud:before {\n  content: \"\\f0c2\"; }\n\n.fa-cloud-download:before {\n  content: \"\\f0ed\"; }\n\n.fa-cloud-download-alt:before {\n  content: \"\\f381\"; }\n\n.fa-cloud-upload:before {\n  content: \"\\f0ee\"; }\n\n.fa-cloud-upload-alt:before {\n  content: \"\\f382\"; }\n\n.fa-cloudscale:before {\n  content: \"\\f383\"; }\n\n.fa-cloudsmith:before {\n  content: \"\\f384\"; }\n\n.fa-cloudversify:before {\n  content: \"\\f385\"; }\n\n.fa-club:before {\n  content: \"\\f327\"; }\n\n.fa-code:before {\n  content: \"\\f121\"; }\n\n.fa-code-branch:before {\n  content: \"\\f126\"; }\n\n.fa-code-commit:before {\n  content: \"\\f386\"; }\n\n.fa-code-merge:before {\n  content: \"\\f387\"; }\n\n.fa-codepen:before {\n  content: \"\\f1cb\"; }\n\n.fa-codiepie:before {\n  content: \"\\f284\"; }\n\n.fa-coffee:before {\n  content: \"\\f0f4\"; }\n\n.fa-cog:before {\n  content: \"\\f013\"; }\n\n.fa-cogs:before {\n  content: \"\\f085\"; }\n\n.fa-columns:before {\n  content: \"\\f0db\"; }\n\n.fa-comment:before {\n  content: \"\\f075\"; }\n\n.fa-comment-alt:before {\n  content: \"\\f27a\"; }\n\n.fa-comments:before {\n  content: \"\\f086\"; }\n\n.fa-compass:before {\n  content: \"\\f14e\"; }\n\n.fa-compress:before {\n  content: \"\\f066\"; }\n\n.fa-compress-alt:before {\n  content: \"\\f422\"; }\n\n.fa-compress-wide:before {\n  content: \"\\f326\"; }\n\n.fa-connectdevelop:before {\n  content: \"\\f20e\"; }\n\n.fa-contao:before {\n  content: \"\\f26d\"; }\n\n.fa-conveyor-belt:before {\n  content: \"\\f46e\"; }\n\n.fa-conveyor-belt-alt:before {\n  content: \"\\f46f\"; }\n\n.fa-copy:before {\n  content: \"\\f0c5\"; }\n\n.fa-copyright:before {\n  content: \"\\f1f9\"; }\n\n.fa-cpanel:before {\n  content: \"\\f388\"; }\n\n.fa-creative-commons:before {\n  content: \"\\f25e\"; }\n\n.fa-credit-card:before {\n  content: \"\\f09d\"; }\n\n.fa-credit-card-blank:before {\n  content: \"\\f389\"; }\n\n.fa-credit-card-front:before {\n  content: \"\\f38a\"; }\n\n.fa-cricket:before {\n  content: \"\\f449\"; }\n\n.fa-crop:before {\n  content: \"\\f125\"; }\n\n.fa-crosshairs:before {\n  content: \"\\f05b\"; }\n\n.fa-css3:before {\n  content: \"\\f13c\"; }\n\n.fa-css3-alt:before {\n  content: \"\\f38b\"; }\n\n.fa-cube:before {\n  content: \"\\f1b2\"; }\n\n.fa-cubes:before {\n  content: \"\\f1b3\"; }\n\n.fa-curling:before {\n  content: \"\\f44a\"; }\n\n.fa-cut:before {\n  content: \"\\f0c4\"; }\n\n.fa-cuttlefish:before {\n  content: \"\\f38c\"; }\n\n.fa-d-and-d:before {\n  content: \"\\f38d\"; }\n\n.fa-dashcube:before {\n  content: \"\\f210\"; }\n\n.fa-database:before {\n  content: \"\\f1c0\"; }\n\n.fa-deaf:before {\n  content: \"\\f2a4\"; }\n\n.fa-delicious:before {\n  content: \"\\f1a5\"; }\n\n.fa-deploydog:before {\n  content: \"\\f38e\"; }\n\n.fa-deskpro:before {\n  content: \"\\f38f\"; }\n\n.fa-desktop:before {\n  content: \"\\f108\"; }\n\n.fa-desktop-alt:before {\n  content: \"\\f390\"; }\n\n.fa-deviantart:before {\n  content: \"\\f1bd\"; }\n\n.fa-diagnoses:before {\n  content: \"\\f470\"; }\n\n.fa-diamond:before {\n  content: \"\\f219\"; }\n\n.fa-digg:before {\n  content: \"\\f1a6\"; }\n\n.fa-digital-ocean:before {\n  content: \"\\f391\"; }\n\n.fa-discord:before {\n  content: \"\\f392\"; }\n\n.fa-discourse:before {\n  content: \"\\f393\"; }\n\n.fa-dna:before {\n  content: \"\\f471\"; }\n\n.fa-dochub:before {\n  content: \"\\f394\"; }\n\n.fa-docker:before {\n  content: \"\\f395\"; }\n\n.fa-dollar-sign:before {\n  content: \"\\f155\"; }\n\n.fa-dolly:before {\n  content: \"\\f472\"; }\n\n.fa-dolly-empty:before {\n  content: \"\\f473\"; }\n\n.fa-dolly-flatbed:before {\n  content: \"\\f474\"; }\n\n.fa-dolly-flatbed-alt:before {\n  content: \"\\f475\"; }\n\n.fa-dolly-flatbed-empty:before {\n  content: \"\\f476\"; }\n\n.fa-dot-circle:before {\n  content: \"\\f192\"; }\n\n.fa-download:before {\n  content: \"\\f019\"; }\n\n.fa-draft2digital:before {\n  content: \"\\f396\"; }\n\n.fa-dribbble:before {\n  content: \"\\f17d\"; }\n\n.fa-dribbble-square:before {\n  content: \"\\f397\"; }\n\n.fa-dropbox:before {\n  content: \"\\f16b\"; }\n\n.fa-drupal:before {\n  content: \"\\f1a9\"; }\n\n.fa-dumbbell:before {\n  content: \"\\f44b\"; }\n\n.fa-dyalog:before {\n  content: \"\\f399\"; }\n\n.fa-earlybirds:before {\n  content: \"\\f39a\"; }\n\n.fa-edge:before {\n  content: \"\\f282\"; }\n\n.fa-edit:before {\n  content: \"\\f044\"; }\n\n.fa-eject:before {\n  content: \"\\f052\"; }\n\n.fa-elementor:before {\n  content: \"\\f430\"; }\n\n.fa-ellipsis-h:before {\n  content: \"\\f141\"; }\n\n.fa-ellipsis-h-alt:before {\n  content: \"\\f39b\"; }\n\n.fa-ellipsis-v:before {\n  content: \"\\f142\"; }\n\n.fa-ellipsis-v-alt:before {\n  content: \"\\f39c\"; }\n\n.fa-ember:before {\n  content: \"\\f423\"; }\n\n.fa-empire:before {\n  content: \"\\f1d1\"; }\n\n.fa-envelope:before {\n  content: \"\\f0e0\"; }\n\n.fa-envelope-open:before {\n  content: \"\\f2b6\"; }\n\n.fa-envelope-square:before {\n  content: \"\\f199\"; }\n\n.fa-envira:before {\n  content: \"\\f299\"; }\n\n.fa-eraser:before {\n  content: \"\\f12d\"; }\n\n.fa-erlang:before {\n  content: \"\\f39d\"; }\n\n.fa-ethereum:before {\n  content: \"\\f42e\"; }\n\n.fa-etsy:before {\n  content: \"\\f2d7\"; }\n\n.fa-euro-sign:before {\n  content: \"\\f153\"; }\n\n.fa-exchange:before {\n  content: \"\\f0ec\"; }\n\n.fa-exchange-alt:before {\n  content: \"\\f362\"; }\n\n.fa-exclamation:before {\n  content: \"\\f12a\"; }\n\n.fa-exclamation-circle:before {\n  content: \"\\f06a\"; }\n\n.fa-exclamation-square:before {\n  content: \"\\f321\"; }\n\n.fa-exclamation-triangle:before {\n  content: \"\\f071\"; }\n\n.fa-expand:before {\n  content: \"\\f065\"; }\n\n.fa-expand-alt:before {\n  content: \"\\f424\"; }\n\n.fa-expand-arrows:before {\n  content: \"\\f31d\"; }\n\n.fa-expand-arrows-alt:before {\n  content: \"\\f31e\"; }\n\n.fa-expand-wide:before {\n  content: \"\\f320\"; }\n\n.fa-expeditedssl:before {\n  content: \"\\f23e\"; }\n\n.fa-external-link:before {\n  content: \"\\f08e\"; }\n\n.fa-external-link-alt:before {\n  content: \"\\f35d\"; }\n\n.fa-external-link-square:before {\n  content: \"\\f14c\"; }\n\n.fa-external-link-square-alt:before {\n  content: \"\\f360\"; }\n\n.fa-eye:before {\n  content: \"\\f06e\"; }\n\n.fa-eye-dropper:before {\n  content: \"\\f1fb\"; }\n\n.fa-eye-slash:before {\n  content: \"\\f070\"; }\n\n.fa-facebook:before {\n  content: \"\\f09a\"; }\n\n.fa-facebook-f:before {\n  content: \"\\f39e\"; }\n\n.fa-facebook-messenger:before {\n  content: \"\\f39f\"; }\n\n.fa-facebook-square:before {\n  content: \"\\f082\"; }\n\n.fa-fast-backward:before {\n  content: \"\\f049\"; }\n\n.fa-fast-forward:before {\n  content: \"\\f050\"; }\n\n.fa-fax:before {\n  content: \"\\f1ac\"; }\n\n.fa-female:before {\n  content: \"\\f182\"; }\n\n.fa-field-hockey:before {\n  content: \"\\f44c\"; }\n\n.fa-fighter-jet:before {\n  content: \"\\f0fb\"; }\n\n.fa-file:before {\n  content: \"\\f15b\"; }\n\n.fa-file-alt:before {\n  content: \"\\f15c\"; }\n\n.fa-file-archive:before {\n  content: \"\\f1c6\"; }\n\n.fa-file-audio:before {\n  content: \"\\f1c7\"; }\n\n.fa-file-check:before {\n  content: \"\\f316\"; }\n\n.fa-file-code:before {\n  content: \"\\f1c9\"; }\n\n.fa-file-edit:before {\n  content: \"\\f31c\"; }\n\n.fa-file-excel:before {\n  content: \"\\f1c3\"; }\n\n.fa-file-exclamation:before {\n  content: \"\\f31a\"; }\n\n.fa-file-image:before {\n  content: \"\\f1c5\"; }\n\n.fa-file-medical:before {\n  content: \"\\f477\"; }\n\n.fa-file-medical-alt:before {\n  content: \"\\f478\"; }\n\n.fa-file-minus:before {\n  content: \"\\f318\"; }\n\n.fa-file-pdf:before {\n  content: \"\\f1c1\"; }\n\n.fa-file-plus:before {\n  content: \"\\f319\"; }\n\n.fa-file-powerpoint:before {\n  content: \"\\f1c4\"; }\n\n.fa-file-times:before {\n  content: \"\\f317\"; }\n\n.fa-file-video:before {\n  content: \"\\f1c8\"; }\n\n.fa-file-word:before {\n  content: \"\\f1c2\"; }\n\n.fa-film:before {\n  content: \"\\f008\"; }\n\n.fa-film-alt:before {\n  content: \"\\f3a0\"; }\n\n.fa-filter:before {\n  content: \"\\f0b0\"; }\n\n.fa-fire:before {\n  content: \"\\f06d\"; }\n\n.fa-fire-extinguisher:before {\n  content: \"\\f134\"; }\n\n.fa-firefox:before {\n  content: \"\\f269\"; }\n\n.fa-first-aid:before {\n  content: \"\\f479\"; }\n\n.fa-first-order:before {\n  content: \"\\f2b0\"; }\n\n.fa-firstdraft:before {\n  content: \"\\f3a1\"; }\n\n.fa-flag:before {\n  content: \"\\f024\"; }\n\n.fa-flag-checkered:before {\n  content: \"\\f11e\"; }\n\n.fa-flask:before {\n  content: \"\\f0c3\"; }\n\n.fa-flickr:before {\n  content: \"\\f16e\"; }\n\n.fa-flipboard:before {\n  content: \"\\f44d\"; }\n\n.fa-fly:before {\n  content: \"\\f417\"; }\n\n.fa-folder:before {\n  content: \"\\f07b\"; }\n\n.fa-folder-open:before {\n  content: \"\\f07c\"; }\n\n.fa-font:before {\n  content: \"\\f031\"; }\n\n.fa-font-awesome:before {\n  content: \"\\f2b4\"; }\n\n.fa-font-awesome-alt:before {\n  content: \"\\f35c\"; }\n\n.fa-font-awesome-flag:before {\n  content: \"\\f425\"; }\n\n.fa-fonticons:before {\n  content: \"\\f280\"; }\n\n.fa-fonticons-fi:before {\n  content: \"\\f3a2\"; }\n\n.fa-football-ball:before {\n  content: \"\\f44e\"; }\n\n.fa-football-helmet:before {\n  content: \"\\f44f\"; }\n\n.fa-forklift:before {\n  content: \"\\f47a\"; }\n\n.fa-fort-awesome:before {\n  content: \"\\f286\"; }\n\n.fa-fort-awesome-alt:before {\n  content: \"\\f3a3\"; }\n\n.fa-forumbee:before {\n  content: \"\\f211\"; }\n\n.fa-forward:before {\n  content: \"\\f04e\"; }\n\n.fa-foursquare:before {\n  content: \"\\f180\"; }\n\n.fa-free-code-camp:before {\n  content: \"\\f2c5\"; }\n\n.fa-freebsd:before {\n  content: \"\\f3a4\"; }\n\n.fa-frown:before {\n  content: \"\\f119\"; }\n\n.fa-futbol:before {\n  content: \"\\f1e3\"; }\n\n.fa-gamepad:before {\n  content: \"\\f11b\"; }\n\n.fa-gavel:before {\n  content: \"\\f0e3\"; }\n\n.fa-gem:before {\n  content: \"\\f3a5\"; }\n\n.fa-genderless:before {\n  content: \"\\f22d\"; }\n\n.fa-get-pocket:before {\n  content: \"\\f265\"; }\n\n.fa-gg:before {\n  content: \"\\f260\"; }\n\n.fa-gg-circle:before {\n  content: \"\\f261\"; }\n\n.fa-gift:before {\n  content: \"\\f06b\"; }\n\n.fa-git:before {\n  content: \"\\f1d3\"; }\n\n.fa-git-square:before {\n  content: \"\\f1d2\"; }\n\n.fa-github:before {\n  content: \"\\f09b\"; }\n\n.fa-github-alt:before {\n  content: \"\\f113\"; }\n\n.fa-github-square:before {\n  content: \"\\f092\"; }\n\n.fa-gitkraken:before {\n  content: \"\\f3a6\"; }\n\n.fa-gitlab:before {\n  content: \"\\f296\"; }\n\n.fa-gitter:before {\n  content: \"\\f426\"; }\n\n.fa-glass-martini:before {\n  content: \"\\f000\"; }\n\n.fa-glide:before {\n  content: \"\\f2a5\"; }\n\n.fa-glide-g:before {\n  content: \"\\f2a6\"; }\n\n.fa-globe:before {\n  content: \"\\f0ac\"; }\n\n.fa-gofore:before {\n  content: \"\\f3a7\"; }\n\n.fa-golf-ball:before {\n  content: \"\\f450\"; }\n\n.fa-golf-club:before {\n  content: \"\\f451\"; }\n\n.fa-goodreads:before {\n  content: \"\\f3a8\"; }\n\n.fa-goodreads-g:before {\n  content: \"\\f3a9\"; }\n\n.fa-google:before {\n  content: \"\\f1a0\"; }\n\n.fa-google-drive:before {\n  content: \"\\f3aa\"; }\n\n.fa-google-play:before {\n  content: \"\\f3ab\"; }\n\n.fa-google-plus:before {\n  content: \"\\f2b3\"; }\n\n.fa-google-plus-g:before {\n  content: \"\\f0d5\"; }\n\n.fa-google-plus-square:before {\n  content: \"\\f0d4\"; }\n\n.fa-google-wallet:before {\n  content: \"\\f1ee\"; }\n\n.fa-graduation-cap:before {\n  content: \"\\f19d\"; }\n\n.fa-gratipay:before {\n  content: \"\\f184\"; }\n\n.fa-grav:before {\n  content: \"\\f2d6\"; }\n\n.fa-gripfire:before {\n  content: \"\\f3ac\"; }\n\n.fa-grunt:before {\n  content: \"\\f3ad\"; }\n\n.fa-gulp:before {\n  content: \"\\f3ae\"; }\n\n.fa-h-square:before {\n  content: \"\\f0fd\"; }\n\n.fa-h1:before {\n  content: \"\\f313\"; }\n\n.fa-h2:before {\n  content: \"\\f314\"; }\n\n.fa-h3:before {\n  content: \"\\f315\"; }\n\n.fa-hacker-news:before {\n  content: \"\\f1d4\"; }\n\n.fa-hacker-news-square:before {\n  content: \"\\f3af\"; }\n\n.fa-hand-holding-box:before {\n  content: \"\\f47b\"; }\n\n.fa-hand-lizard:before {\n  content: \"\\f258\"; }\n\n.fa-hand-paper:before {\n  content: \"\\f256\"; }\n\n.fa-hand-peace:before {\n  content: \"\\f25b\"; }\n\n.fa-hand-point-down:before {\n  content: \"\\f0a7\"; }\n\n.fa-hand-point-left:before {\n  content: \"\\f0a5\"; }\n\n.fa-hand-point-right:before {\n  content: \"\\f0a4\"; }\n\n.fa-hand-point-up:before {\n  content: \"\\f0a6\"; }\n\n.fa-hand-pointer:before {\n  content: \"\\f25a\"; }\n\n.fa-hand-receiving:before {\n  content: \"\\f47c\"; }\n\n.fa-hand-rock:before {\n  content: \"\\f255\"; }\n\n.fa-hand-scissors:before {\n  content: \"\\f257\"; }\n\n.fa-hand-spock:before {\n  content: \"\\f259\"; }\n\n.fa-handshake:before {\n  content: \"\\f2b5\"; }\n\n.fa-hashtag:before {\n  content: \"\\f292\"; }\n\n.fa-hdd:before {\n  content: \"\\f0a0\"; }\n\n.fa-heading:before {\n  content: \"\\f1dc\"; }\n\n.fa-headphones:before {\n  content: \"\\f025\"; }\n\n.fa-heart:before {\n  content: \"\\f004\"; }\n\n.fa-heartbeat:before {\n  content: \"\\f21e\"; }\n\n.fa-hexagon:before {\n  content: \"\\f312\"; }\n\n.fa-hips:before {\n  content: \"\\f452\"; }\n\n.fa-hire-a-helper:before {\n  content: \"\\f3b0\"; }\n\n.fa-history:before {\n  content: \"\\f1da\"; }\n\n.fa-hockey-puck:before {\n  content: \"\\f453\"; }\n\n.fa-hockey-sticks:before {\n  content: \"\\f454\"; }\n\n.fa-home:before {\n  content: \"\\f015\"; }\n\n.fa-hooli:before {\n  content: \"\\f427\"; }\n\n.fa-hospital:before {\n  content: \"\\f0f8\"; }\n\n.fa-hospital-alt:before {\n  content: \"\\f47d\"; }\n\n.fa-hospital-symbol:before {\n  content: \"\\f47e\"; }\n\n.fa-hotjar:before {\n  content: \"\\f3b1\"; }\n\n.fa-hourglass:before {\n  content: \"\\f254\"; }\n\n.fa-hourglass-end:before {\n  content: \"\\f253\"; }\n\n.fa-hourglass-half:before {\n  content: \"\\f252\"; }\n\n.fa-hourglass-start:before {\n  content: \"\\f251\"; }\n\n.fa-houzz:before {\n  content: \"\\f27c\"; }\n\n.fa-html5:before {\n  content: \"\\f13b\"; }\n\n.fa-hubspot:before {\n  content: \"\\f3b2\"; }\n\n.fa-i-cursor:before {\n  content: \"\\f246\"; }\n\n.fa-id-badge:before {\n  content: \"\\f2c1\"; }\n\n.fa-id-card:before {\n  content: \"\\f2c2\"; }\n\n.fa-id-card-alt:before {\n  content: \"\\f47f\"; }\n\n.fa-image:before {\n  content: \"\\f03e\"; }\n\n.fa-images:before {\n  content: \"\\f302\"; }\n\n.fa-imdb:before {\n  content: \"\\f2d8\"; }\n\n.fa-inbox:before {\n  content: \"\\f01c\"; }\n\n.fa-inbox-in:before {\n  content: \"\\f310\"; }\n\n.fa-inbox-out:before {\n  content: \"\\f311\"; }\n\n.fa-indent:before {\n  content: \"\\f03c\"; }\n\n.fa-industry:before {\n  content: \"\\f275\"; }\n\n.fa-industry-alt:before {\n  content: \"\\f3b3\"; }\n\n.fa-info:before {\n  content: \"\\f129\"; }\n\n.fa-info-circle:before {\n  content: \"\\f05a\"; }\n\n.fa-info-square:before {\n  content: \"\\f30f\"; }\n\n.fa-instagram:before {\n  content: \"\\f16d\"; }\n\n.fa-internet-explorer:before {\n  content: \"\\f26b\"; }\n\n.fa-inventory:before {\n  content: \"\\f480\"; }\n\n.fa-ioxhost:before {\n  content: \"\\f208\"; }\n\n.fa-italic:before {\n  content: \"\\f033\"; }\n\n.fa-itunes:before {\n  content: \"\\f3b4\"; }\n\n.fa-itunes-note:before {\n  content: \"\\f3b5\"; }\n\n.fa-jack-o-lantern:before {\n  content: \"\\f30e\"; }\n\n.fa-jenkins:before {\n  content: \"\\f3b6\"; }\n\n.fa-joget:before {\n  content: \"\\f3b7\"; }\n\n.fa-joomla:before {\n  content: \"\\f1aa\"; }\n\n.fa-js:before {\n  content: \"\\f3b8\"; }\n\n.fa-js-square:before {\n  content: \"\\f3b9\"; }\n\n.fa-jsfiddle:before {\n  content: \"\\f1cc\"; }\n\n.fa-key:before {\n  content: \"\\f084\"; }\n\n.fa-keyboard:before {\n  content: \"\\f11c\"; }\n\n.fa-keycdn:before {\n  content: \"\\f3ba\"; }\n\n.fa-kickstarter:before {\n  content: \"\\f3bb\"; }\n\n.fa-kickstarter-k:before {\n  content: \"\\f3bc\"; }\n\n.fa-korvue:before {\n  content: \"\\f42f\"; }\n\n.fa-language:before {\n  content: \"\\f1ab\"; }\n\n.fa-laptop:before {\n  content: \"\\f109\"; }\n\n.fa-laravel:before {\n  content: \"\\f3bd\"; }\n\n.fa-lastfm:before {\n  content: \"\\f202\"; }\n\n.fa-lastfm-square:before {\n  content: \"\\f203\"; }\n\n.fa-leaf:before {\n  content: \"\\f06c\"; }\n\n.fa-leanpub:before {\n  content: \"\\f212\"; }\n\n.fa-lemon:before {\n  content: \"\\f094\"; }\n\n.fa-less:before {\n  content: \"\\f41d\"; }\n\n.fa-level-down:before {\n  content: \"\\f149\"; }\n\n.fa-level-down-alt:before {\n  content: \"\\f3be\"; }\n\n.fa-level-up:before {\n  content: \"\\f148\"; }\n\n.fa-level-up-alt:before {\n  content: \"\\f3bf\"; }\n\n.fa-life-ring:before {\n  content: \"\\f1cd\"; }\n\n.fa-lightbulb:before {\n  content: \"\\f0eb\"; }\n\n.fa-line:before {\n  content: \"\\f3c0\"; }\n\n.fa-link:before {\n  content: \"\\f0c1\"; }\n\n.fa-linkedin:before {\n  content: \"\\f08c\"; }\n\n.fa-linkedin-in:before {\n  content: \"\\f0e1\"; }\n\n.fa-linode:before {\n  content: \"\\f2b8\"; }\n\n.fa-linux:before {\n  content: \"\\f17c\"; }\n\n.fa-lira-sign:before {\n  content: \"\\f195\"; }\n\n.fa-list:before {\n  content: \"\\f03a\"; }\n\n.fa-list-alt:before {\n  content: \"\\f022\"; }\n\n.fa-list-ol:before {\n  content: \"\\f0cb\"; }\n\n.fa-list-ul:before {\n  content: \"\\f0ca\"; }\n\n.fa-location-arrow:before {\n  content: \"\\f124\"; }\n\n.fa-lock:before {\n  content: \"\\f023\"; }\n\n.fa-lock-alt:before {\n  content: \"\\f30d\"; }\n\n.fa-lock-open:before {\n  content: \"\\f3c1\"; }\n\n.fa-lock-open-alt:before {\n  content: \"\\f3c2\"; }\n\n.fa-long-arrow-alt-down:before {\n  content: \"\\f309\"; }\n\n.fa-long-arrow-alt-left:before {\n  content: \"\\f30a\"; }\n\n.fa-long-arrow-alt-right:before {\n  content: \"\\f30b\"; }\n\n.fa-long-arrow-alt-up:before {\n  content: \"\\f30c\"; }\n\n.fa-long-arrow-down:before {\n  content: \"\\f175\"; }\n\n.fa-long-arrow-left:before {\n  content: \"\\f177\"; }\n\n.fa-long-arrow-right:before {\n  content: \"\\f178\"; }\n\n.fa-long-arrow-up:before {\n  content: \"\\f176\"; }\n\n.fa-low-vision:before {\n  content: \"\\f2a8\"; }\n\n.fa-luchador:before {\n  content: \"\\f455\"; }\n\n.fa-lyft:before {\n  content: \"\\f3c3\"; }\n\n.fa-magento:before {\n  content: \"\\f3c4\"; }\n\n.fa-magic:before {\n  content: \"\\f0d0\"; }\n\n.fa-magnet:before {\n  content: \"\\f076\"; }\n\n.fa-male:before {\n  content: \"\\f183\"; }\n\n.fa-map:before {\n  content: \"\\f279\"; }\n\n.fa-map-marker:before {\n  content: \"\\f041\"; }\n\n.fa-map-marker-alt:before {\n  content: \"\\f3c5\"; }\n\n.fa-map-pin:before {\n  content: \"\\f276\"; }\n\n.fa-map-signs:before {\n  content: \"\\f277\"; }\n\n.fa-mars:before {\n  content: \"\\f222\"; }\n\n.fa-mars-double:before {\n  content: \"\\f227\"; }\n\n.fa-mars-stroke:before {\n  content: \"\\f229\"; }\n\n.fa-mars-stroke-h:before {\n  content: \"\\f22b\"; }\n\n.fa-mars-stroke-v:before {\n  content: \"\\f22a\"; }\n\n.fa-maxcdn:before {\n  content: \"\\f136\"; }\n\n.fa-medapps:before {\n  content: \"\\f3c6\"; }\n\n.fa-medium:before {\n  content: \"\\f23a\"; }\n\n.fa-medium-m:before {\n  content: \"\\f3c7\"; }\n\n.fa-medkit:before {\n  content: \"\\f0fa\"; }\n\n.fa-medrt:before {\n  content: \"\\f3c8\"; }\n\n.fa-meetup:before {\n  content: \"\\f2e0\"; }\n\n.fa-meh:before {\n  content: \"\\f11a\"; }\n\n.fa-mercury:before {\n  content: \"\\f223\"; }\n\n.fa-microchip:before {\n  content: \"\\f2db\"; }\n\n.fa-microphone:before {\n  content: \"\\f130\"; }\n\n.fa-microphone-alt:before {\n  content: \"\\f3c9\"; }\n\n.fa-microphone-slash:before {\n  content: \"\\f131\"; }\n\n.fa-microsoft:before {\n  content: \"\\f3ca\"; }\n\n.fa-minus:before {\n  content: \"\\f068\"; }\n\n.fa-minus-circle:before {\n  content: \"\\f056\"; }\n\n.fa-minus-hexagon:before {\n  content: \"\\f307\"; }\n\n.fa-minus-octagon:before {\n  content: \"\\f308\"; }\n\n.fa-minus-square:before {\n  content: \"\\f146\"; }\n\n.fa-mix:before {\n  content: \"\\f3cb\"; }\n\n.fa-mixcloud:before {\n  content: \"\\f289\"; }\n\n.fa-mizuni:before {\n  content: \"\\f3cc\"; }\n\n.fa-mobile:before {\n  content: \"\\f10b\"; }\n\n.fa-mobile-alt:before {\n  content: \"\\f3cd\"; }\n\n.fa-mobile-android:before {\n  content: \"\\f3ce\"; }\n\n.fa-mobile-android-alt:before {\n  content: \"\\f3cf\"; }\n\n.fa-modx:before {\n  content: \"\\f285\"; }\n\n.fa-monero:before {\n  content: \"\\f3d0\"; }\n\n.fa-money-bill:before {\n  content: \"\\f0d6\"; }\n\n.fa-money-bill-alt:before {\n  content: \"\\f3d1\"; }\n\n.fa-moon:before {\n  content: \"\\f186\"; }\n\n.fa-motorcycle:before {\n  content: \"\\f21c\"; }\n\n.fa-mouse-pointer:before {\n  content: \"\\f245\"; }\n\n.fa-music:before {\n  content: \"\\f001\"; }\n\n.fa-napster:before {\n  content: \"\\f3d2\"; }\n\n.fa-neuter:before {\n  content: \"\\f22c\"; }\n\n.fa-newspaper:before {\n  content: \"\\f1ea\"; }\n\n.fa-nintendo-switch:before {\n  content: \"\\f418\"; }\n\n.fa-node:before {\n  content: \"\\f419\"; }\n\n.fa-node-js:before {\n  content: \"\\f3d3\"; }\n\n.fa-notes-medical:before {\n  content: \"\\f481\"; }\n\n.fa-npm:before {\n  content: \"\\f3d4\"; }\n\n.fa-ns8:before {\n  content: \"\\f3d5\"; }\n\n.fa-nutritionix:before {\n  content: \"\\f3d6\"; }\n\n.fa-object-group:before {\n  content: \"\\f247\"; }\n\n.fa-object-ungroup:before {\n  content: \"\\f248\"; }\n\n.fa-octagon:before {\n  content: \"\\f306\"; }\n\n.fa-odnoklassniki:before {\n  content: \"\\f263\"; }\n\n.fa-odnoklassniki-square:before {\n  content: \"\\f264\"; }\n\n.fa-opencart:before {\n  content: \"\\f23d\"; }\n\n.fa-openid:before {\n  content: \"\\f19b\"; }\n\n.fa-opera:before {\n  content: \"\\f26a\"; }\n\n.fa-optin-monster:before {\n  content: \"\\f23c\"; }\n\n.fa-osi:before {\n  content: \"\\f41a\"; }\n\n.fa-outdent:before {\n  content: \"\\f03b\"; }\n\n.fa-page4:before {\n  content: \"\\f3d7\"; }\n\n.fa-pagelines:before {\n  content: \"\\f18c\"; }\n\n.fa-paint-brush:before {\n  content: \"\\f1fc\"; }\n\n.fa-palfed:before {\n  content: \"\\f3d8\"; }\n\n.fa-pallet:before {\n  content: \"\\f482\"; }\n\n.fa-pallet-alt:before {\n  content: \"\\f483\"; }\n\n.fa-paper-plane:before {\n  content: \"\\f1d8\"; }\n\n.fa-paperclip:before {\n  content: \"\\f0c6\"; }\n\n.fa-paragraph:before {\n  content: \"\\f1dd\"; }\n\n.fa-paste:before {\n  content: \"\\f0ea\"; }\n\n.fa-patreon:before {\n  content: \"\\f3d9\"; }\n\n.fa-pause:before {\n  content: \"\\f04c\"; }\n\n.fa-pause-circle:before {\n  content: \"\\f28b\"; }\n\n.fa-paw:before {\n  content: \"\\f1b0\"; }\n\n.fa-paypal:before {\n  content: \"\\f1ed\"; }\n\n.fa-pen:before {\n  content: \"\\f304\"; }\n\n.fa-pen-alt:before {\n  content: \"\\f305\"; }\n\n.fa-pen-square:before {\n  content: \"\\f14b\"; }\n\n.fa-pencil:before {\n  content: \"\\f040\"; }\n\n.fa-pencil-alt:before {\n  content: \"\\f303\"; }\n\n.fa-pennant:before {\n  content: \"\\f456\"; }\n\n.fa-percent:before {\n  content: \"\\f295\"; }\n\n.fa-periscope:before {\n  content: \"\\f3da\"; }\n\n.fa-phabricator:before {\n  content: \"\\f3db\"; }\n\n.fa-phoenix-framework:before {\n  content: \"\\f3dc\"; }\n\n.fa-phone:before {\n  content: \"\\f095\"; }\n\n.fa-phone-slash:before {\n  content: \"\\f3dd\"; }\n\n.fa-phone-square:before {\n  content: \"\\f098\"; }\n\n.fa-phone-volume:before {\n  content: \"\\f2a0\"; }\n\n.fa-php:before {\n  content: \"\\f457\"; }\n\n.fa-pied-piper:before {\n  content: \"\\f2ae\"; }\n\n.fa-pied-piper-alt:before {\n  content: \"\\f1a8\"; }\n\n.fa-pied-piper-pp:before {\n  content: \"\\f1a7\"; }\n\n.fa-pills:before {\n  content: \"\\f484\"; }\n\n.fa-pinterest:before {\n  content: \"\\f0d2\"; }\n\n.fa-pinterest-p:before {\n  content: \"\\f231\"; }\n\n.fa-pinterest-square:before {\n  content: \"\\f0d3\"; }\n\n.fa-plane:before {\n  content: \"\\f072\"; }\n\n.fa-plane-alt:before {\n  content: \"\\f3de\"; }\n\n.fa-play:before {\n  content: \"\\f04b\"; }\n\n.fa-play-circle:before {\n  content: \"\\f144\"; }\n\n.fa-playstation:before {\n  content: \"\\f3df\"; }\n\n.fa-plug:before {\n  content: \"\\f1e6\"; }\n\n.fa-plus:before {\n  content: \"\\f067\"; }\n\n.fa-plus-circle:before {\n  content: \"\\f055\"; }\n\n.fa-plus-hexagon:before {\n  content: \"\\f300\"; }\n\n.fa-plus-octagon:before {\n  content: \"\\f301\"; }\n\n.fa-plus-square:before {\n  content: \"\\f0fe\"; }\n\n.fa-podcast:before {\n  content: \"\\f2ce\"; }\n\n.fa-poo:before {\n  content: \"\\f2fe\"; }\n\n.fa-portrait:before {\n  content: \"\\f3e0\"; }\n\n.fa-pound-sign:before {\n  content: \"\\f154\"; }\n\n.fa-power-off:before {\n  content: \"\\f011\"; }\n\n.fa-prescription-bottle:before {\n  content: \"\\f485\"; }\n\n.fa-prescription-bottle-alt:before {\n  content: \"\\f486\"; }\n\n.fa-print:before {\n  content: \"\\f02f\"; }\n\n.fa-procedures:before {\n  content: \"\\f487\"; }\n\n.fa-product-hunt:before {\n  content: \"\\f288\"; }\n\n.fa-pushed:before {\n  content: \"\\f3e1\"; }\n\n.fa-puzzle-piece:before {\n  content: \"\\f12e\"; }\n\n.fa-python:before {\n  content: \"\\f3e2\"; }\n\n.fa-qq:before {\n  content: \"\\f1d6\"; }\n\n.fa-qrcode:before {\n  content: \"\\f029\"; }\n\n.fa-question:before {\n  content: \"\\f128\"; }\n\n.fa-question-circle:before {\n  content: \"\\f059\"; }\n\n.fa-question-square:before {\n  content: \"\\f2fd\"; }\n\n.fa-quidditch:before {\n  content: \"\\f458\"; }\n\n.fa-quinscape:before {\n  content: \"\\f459\"; }\n\n.fa-quora:before {\n  content: \"\\f2c4\"; }\n\n.fa-quote-left:before {\n  content: \"\\f10d\"; }\n\n.fa-quote-right:before {\n  content: \"\\f10e\"; }\n\n.fa-racquet:before {\n  content: \"\\f45a\"; }\n\n.fa-random:before {\n  content: \"\\f074\"; }\n\n.fa-ravelry:before {\n  content: \"\\f2d9\"; }\n\n.fa-react:before {\n  content: \"\\f41b\"; }\n\n.fa-rebel:before {\n  content: \"\\f1d0\"; }\n\n.fa-rectangle-landscape:before {\n  content: \"\\f2fa\"; }\n\n.fa-rectangle-portrait:before {\n  content: \"\\f2fb\"; }\n\n.fa-rectangle-wide:before {\n  content: \"\\f2fc\"; }\n\n.fa-recycle:before {\n  content: \"\\f1b8\"; }\n\n.fa-red-river:before {\n  content: \"\\f3e3\"; }\n\n.fa-reddit:before {\n  content: \"\\f1a1\"; }\n\n.fa-reddit-alien:before {\n  content: \"\\f281\"; }\n\n.fa-reddit-square:before {\n  content: \"\\f1a2\"; }\n\n.fa-redo:before {\n  content: \"\\f01e\"; }\n\n.fa-redo-alt:before {\n  content: \"\\f2f9\"; }\n\n.fa-registered:before {\n  content: \"\\f25d\"; }\n\n.fa-rendact:before {\n  content: \"\\f3e4\"; }\n\n.fa-renren:before {\n  content: \"\\f18b\"; }\n\n.fa-repeat:before {\n  content: \"\\f363\"; }\n\n.fa-repeat-1:before {\n  content: \"\\f365\"; }\n\n.fa-repeat-1-alt:before {\n  content: \"\\f366\"; }\n\n.fa-repeat-alt:before {\n  content: \"\\f364\"; }\n\n.fa-reply:before {\n  content: \"\\f3e5\"; }\n\n.fa-reply-all:before {\n  content: \"\\f122\"; }\n\n.fa-replyd:before {\n  content: \"\\f3e6\"; }\n\n.fa-resolving:before {\n  content: \"\\f3e7\"; }\n\n.fa-retweet:before {\n  content: \"\\f079\"; }\n\n.fa-retweet-alt:before {\n  content: \"\\f361\"; }\n\n.fa-road:before {\n  content: \"\\f018\"; }\n\n.fa-rocket:before {\n  content: \"\\f135\"; }\n\n.fa-rocketchat:before {\n  content: \"\\f3e8\"; }\n\n.fa-rockrms:before {\n  content: \"\\f3e9\"; }\n\n.fa-rss:before {\n  content: \"\\f09e\"; }\n\n.fa-rss-square:before {\n  content: \"\\f143\"; }\n\n.fa-ruble-sign:before {\n  content: \"\\f158\"; }\n\n.fa-rupee-sign:before {\n  content: \"\\f156\"; }\n\n.fa-safari:before {\n  content: \"\\f267\"; }\n\n.fa-sass:before {\n  content: \"\\f41e\"; }\n\n.fa-save:before {\n  content: \"\\f0c7\"; }\n\n.fa-scanner:before {\n  content: \"\\f488\"; }\n\n.fa-scanner-keyboard:before {\n  content: \"\\f489\"; }\n\n.fa-scanner-touchscreen:before {\n  content: \"\\f48a\"; }\n\n.fa-schlix:before {\n  content: \"\\f3ea\"; }\n\n.fa-scribd:before {\n  content: \"\\f28a\"; }\n\n.fa-scrubber:before {\n  content: \"\\f2f8\"; }\n\n.fa-search:before {\n  content: \"\\f002\"; }\n\n.fa-search-minus:before {\n  content: \"\\f010\"; }\n\n.fa-search-plus:before {\n  content: \"\\f00e\"; }\n\n.fa-searchengin:before {\n  content: \"\\f3eb\"; }\n\n.fa-sellcast:before {\n  content: \"\\f2da\"; }\n\n.fa-sellsy:before {\n  content: \"\\f213\"; }\n\n.fa-server:before {\n  content: \"\\f233\"; }\n\n.fa-servicestack:before {\n  content: \"\\f3ec\"; }\n\n.fa-share:before {\n  content: \"\\f064\"; }\n\n.fa-share-all:before {\n  content: \"\\f367\"; }\n\n.fa-share-alt:before {\n  content: \"\\f1e0\"; }\n\n.fa-share-alt-square:before {\n  content: \"\\f1e1\"; }\n\n.fa-share-square:before {\n  content: \"\\f14d\"; }\n\n.fa-shekel-sign:before {\n  content: \"\\f20b\"; }\n\n.fa-shield:before {\n  content: \"\\f132\"; }\n\n.fa-shield-alt:before {\n  content: \"\\f3ed\"; }\n\n.fa-shield-check:before {\n  content: \"\\f2f7\"; }\n\n.fa-ship:before {\n  content: \"\\f21a\"; }\n\n.fa-shipping-fast:before {\n  content: \"\\f48b\"; }\n\n.fa-shipping-timed:before {\n  content: \"\\f48c\"; }\n\n.fa-shirtsinbulk:before {\n  content: \"\\f214\"; }\n\n.fa-shopping-bag:before {\n  content: \"\\f290\"; }\n\n.fa-shopping-basket:before {\n  content: \"\\f291\"; }\n\n.fa-shopping-cart:before {\n  content: \"\\f07a\"; }\n\n.fa-shower:before {\n  content: \"\\f2cc\"; }\n\n.fa-shuttlecock:before {\n  content: \"\\f45b\"; }\n\n.fa-sign-in:before {\n  content: \"\\f090\"; }\n\n.fa-sign-in-alt:before {\n  content: \"\\f2f6\"; }\n\n.fa-sign-language:before {\n  content: \"\\f2a7\"; }\n\n.fa-sign-out:before {\n  content: \"\\f08b\"; }\n\n.fa-sign-out-alt:before {\n  content: \"\\f2f5\"; }\n\n.fa-signal:before {\n  content: \"\\f012\"; }\n\n.fa-simplybuilt:before {\n  content: \"\\f215\"; }\n\n.fa-sistrix:before {\n  content: \"\\f3ee\"; }\n\n.fa-sitemap:before {\n  content: \"\\f0e8\"; }\n\n.fa-skyatlas:before {\n  content: \"\\f216\"; }\n\n.fa-skype:before {\n  content: \"\\f17e\"; }\n\n.fa-slack:before {\n  content: \"\\f198\"; }\n\n.fa-slack-hash:before {\n  content: \"\\f3ef\"; }\n\n.fa-sliders-h:before {\n  content: \"\\f1de\"; }\n\n.fa-sliders-h-square:before {\n  content: \"\\f3f0\"; }\n\n.fa-sliders-v:before {\n  content: \"\\f3f1\"; }\n\n.fa-sliders-v-square:before {\n  content: \"\\f3f2\"; }\n\n.fa-slideshare:before {\n  content: \"\\f1e7\"; }\n\n.fa-smile:before {\n  content: \"\\f118\"; }\n\n.fa-smoking:before {\n  content: \"\\f48d\"; }\n\n.fa-snapchat:before {\n  content: \"\\f2ab\"; }\n\n.fa-snapchat-ghost:before {\n  content: \"\\f2ac\"; }\n\n.fa-snapchat-square:before {\n  content: \"\\f2ad\"; }\n\n.fa-snowflake:before {\n  content: \"\\f2dc\"; }\n\n.fa-sort:before {\n  content: \"\\f0dc\"; }\n\n.fa-sort-alpha-down:before {\n  content: \"\\f15d\"; }\n\n.fa-sort-alpha-up:before {\n  content: \"\\f15e\"; }\n\n.fa-sort-amount-down:before {\n  content: \"\\f160\"; }\n\n.fa-sort-amount-up:before {\n  content: \"\\f161\"; }\n\n.fa-sort-down:before {\n  content: \"\\f0dd\"; }\n\n.fa-sort-numeric-down:before {\n  content: \"\\f162\"; }\n\n.fa-sort-numeric-up:before {\n  content: \"\\f163\"; }\n\n.fa-sort-up:before {\n  content: \"\\f0de\"; }\n\n.fa-soundcloud:before {\n  content: \"\\f1be\"; }\n\n.fa-space-shuttle:before {\n  content: \"\\f197\"; }\n\n.fa-spade:before {\n  content: \"\\f2f4\"; }\n\n.fa-speakap:before {\n  content: \"\\f3f3\"; }\n\n.fa-spinner:before {\n  content: \"\\f110\"; }\n\n.fa-spinner-third:before {\n  content: \"\\f3f4\"; }\n\n.fa-spotify:before {\n  content: \"\\f1bc\"; }\n\n.fa-square:before {\n  content: \"\\f0c8\"; }\n\n.fa-square-full:before {\n  content: \"\\f45c\"; }\n\n.fa-stack-exchange:before {\n  content: \"\\f18d\"; }\n\n.fa-stack-overflow:before {\n  content: \"\\f16c\"; }\n\n.fa-star:before {\n  content: \"\\f005\"; }\n\n.fa-star-exclamation:before {\n  content: \"\\f2f3\"; }\n\n.fa-star-half:before {\n  content: \"\\f089\"; }\n\n.fa-staylinked:before {\n  content: \"\\f3f5\"; }\n\n.fa-steam:before {\n  content: \"\\f1b6\"; }\n\n.fa-steam-square:before {\n  content: \"\\f1b7\"; }\n\n.fa-steam-symbol:before {\n  content: \"\\f3f6\"; }\n\n.fa-step-backward:before {\n  content: \"\\f048\"; }\n\n.fa-step-forward:before {\n  content: \"\\f051\"; }\n\n.fa-stethoscope:before {\n  content: \"\\f0f1\"; }\n\n.fa-sticker-mule:before {\n  content: \"\\f3f7\"; }\n\n.fa-sticky-note:before {\n  content: \"\\f249\"; }\n\n.fa-stop:before {\n  content: \"\\f04d\"; }\n\n.fa-stop-circle:before {\n  content: \"\\f28d\"; }\n\n.fa-stopwatch:before {\n  content: \"\\f2f2\"; }\n\n.fa-strava:before {\n  content: \"\\f428\"; }\n\n.fa-street-view:before {\n  content: \"\\f21d\"; }\n\n.fa-strikethrough:before {\n  content: \"\\f0cc\"; }\n\n.fa-stripe:before {\n  content: \"\\f429\"; }\n\n.fa-stripe-s:before {\n  content: \"\\f42a\"; }\n\n.fa-studiovinari:before {\n  content: \"\\f3f8\"; }\n\n.fa-stumbleupon:before {\n  content: \"\\f1a4\"; }\n\n.fa-stumbleupon-circle:before {\n  content: \"\\f1a3\"; }\n\n.fa-subscript:before {\n  content: \"\\f12c\"; }\n\n.fa-subway:before {\n  content: \"\\f239\"; }\n\n.fa-suitcase:before {\n  content: \"\\f0f2\"; }\n\n.fa-sun:before {\n  content: \"\\f185\"; }\n\n.fa-superpowers:before {\n  content: \"\\f2dd\"; }\n\n.fa-superscript:before {\n  content: \"\\f12b\"; }\n\n.fa-supple:before {\n  content: \"\\f3f9\"; }\n\n.fa-sync:before {\n  content: \"\\f021\"; }\n\n.fa-sync-alt:before {\n  content: \"\\f2f1\"; }\n\n.fa-syringe:before {\n  content: \"\\f48e\"; }\n\n.fa-table:before {\n  content: \"\\f0ce\"; }\n\n.fa-table-tennis:before {\n  content: \"\\f45d\"; }\n\n.fa-tablet:before {\n  content: \"\\f10a\"; }\n\n.fa-tablet-alt:before {\n  content: \"\\f3fa\"; }\n\n.fa-tablet-android:before {\n  content: \"\\f3fb\"; }\n\n.fa-tablet-android-alt:before {\n  content: \"\\f3fc\"; }\n\n.fa-tablet-rugged:before {\n  content: \"\\f48f\"; }\n\n.fa-tablets:before {\n  content: \"\\f490\"; }\n\n.fa-tachometer:before {\n  content: \"\\f0e4\"; }\n\n.fa-tachometer-alt:before {\n  content: \"\\f3fd\"; }\n\n.fa-tag:before {\n  content: \"\\f02b\"; }\n\n.fa-tags:before {\n  content: \"\\f02c\"; }\n\n.fa-tasks:before {\n  content: \"\\f0ae\"; }\n\n.fa-taxi:before {\n  content: \"\\f1ba\"; }\n\n.fa-telegram:before {\n  content: \"\\f2c6\"; }\n\n.fa-telegram-plane:before {\n  content: \"\\f3fe\"; }\n\n.fa-tencent-weibo:before {\n  content: \"\\f1d5\"; }\n\n.fa-tennis-ball:before {\n  content: \"\\f45e\"; }\n\n.fa-terminal:before {\n  content: \"\\f120\"; }\n\n.fa-text-height:before {\n  content: \"\\f034\"; }\n\n.fa-text-width:before {\n  content: \"\\f035\"; }\n\n.fa-th:before {\n  content: \"\\f00a\"; }\n\n.fa-th-large:before {\n  content: \"\\f009\"; }\n\n.fa-th-list:before {\n  content: \"\\f00b\"; }\n\n.fa-themeisle:before {\n  content: \"\\f2b2\"; }\n\n.fa-thermometer:before {\n  content: \"\\f491\"; }\n\n.fa-thermometer-empty:before {\n  content: \"\\f2cb\"; }\n\n.fa-thermometer-full:before {\n  content: \"\\f2c7\"; }\n\n.fa-thermometer-half:before {\n  content: \"\\f2c9\"; }\n\n.fa-thermometer-quarter:before {\n  content: \"\\f2ca\"; }\n\n.fa-thermometer-three-quarters:before {\n  content: \"\\f2c8\"; }\n\n.fa-thumbs-down:before {\n  content: \"\\f165\"; }\n\n.fa-thumbs-up:before {\n  content: \"\\f164\"; }\n\n.fa-thumbtack:before {\n  content: \"\\f08d\"; }\n\n.fa-ticket:before {\n  content: \"\\f145\"; }\n\n.fa-ticket-alt:before {\n  content: \"\\f3ff\"; }\n\n.fa-times:before {\n  content: \"\\f00d\"; }\n\n.fa-times-circle:before {\n  content: \"\\f057\"; }\n\n.fa-times-hexagon:before {\n  content: \"\\f2ee\"; }\n\n.fa-times-octagon:before {\n  content: \"\\f2f0\"; }\n\n.fa-times-square:before {\n  content: \"\\f2d3\"; }\n\n.fa-tint:before {\n  content: \"\\f043\"; }\n\n.fa-toggle-off:before {\n  content: \"\\f204\"; }\n\n.fa-toggle-on:before {\n  content: \"\\f205\"; }\n\n.fa-trademark:before {\n  content: \"\\f25c\"; }\n\n.fa-train:before {\n  content: \"\\f238\"; }\n\n.fa-transgender:before {\n  content: \"\\f224\"; }\n\n.fa-transgender-alt:before {\n  content: \"\\f225\"; }\n\n.fa-trash:before {\n  content: \"\\f1f8\"; }\n\n.fa-trash-alt:before {\n  content: \"\\f2ed\"; }\n\n.fa-tree:before {\n  content: \"\\f1bb\"; }\n\n.fa-tree-alt:before {\n  content: \"\\f400\"; }\n\n.fa-trello:before {\n  content: \"\\f181\"; }\n\n.fa-triangle:before {\n  content: \"\\f2ec\"; }\n\n.fa-tripadvisor:before {\n  content: \"\\f262\"; }\n\n.fa-trophy:before {\n  content: \"\\f091\"; }\n\n.fa-trophy-alt:before {\n  content: \"\\f2eb\"; }\n\n.fa-truck:before {\n  content: \"\\f0d1\"; }\n\n.fa-tty:before {\n  content: \"\\f1e4\"; }\n\n.fa-tumblr:before {\n  content: \"\\f173\"; }\n\n.fa-tumblr-square:before {\n  content: \"\\f174\"; }\n\n.fa-tv:before {\n  content: \"\\f26c\"; }\n\n.fa-tv-retro:before {\n  content: \"\\f401\"; }\n\n.fa-twitch:before {\n  content: \"\\f1e8\"; }\n\n.fa-twitter:before {\n  content: \"\\f099\"; }\n\n.fa-twitter-square:before {\n  content: \"\\f081\"; }\n\n.fa-typo3:before {\n  content: \"\\f42b\"; }\n\n.fa-uber:before {\n  content: \"\\f402\"; }\n\n.fa-uikit:before {\n  content: \"\\f403\"; }\n\n.fa-umbrella:before {\n  content: \"\\f0e9\"; }\n\n.fa-underline:before {\n  content: \"\\f0cd\"; }\n\n.fa-undo:before {\n  content: \"\\f0e2\"; }\n\n.fa-undo-alt:before {\n  content: \"\\f2ea\"; }\n\n.fa-uniregistry:before {\n  content: \"\\f404\"; }\n\n.fa-universal-access:before {\n  content: \"\\f29a\"; }\n\n.fa-university:before {\n  content: \"\\f19c\"; }\n\n.fa-unlink:before {\n  content: \"\\f127\"; }\n\n.fa-unlock:before {\n  content: \"\\f09c\"; }\n\n.fa-unlock-alt:before {\n  content: \"\\f13e\"; }\n\n.fa-untappd:before {\n  content: \"\\f405\"; }\n\n.fa-upload:before {\n  content: \"\\f093\"; }\n\n.fa-usb:before {\n  content: \"\\f287\"; }\n\n.fa-usd-circle:before {\n  content: \"\\f2e8\"; }\n\n.fa-usd-square:before {\n  content: \"\\f2e9\"; }\n\n.fa-user:before {\n  content: \"\\f007\"; }\n\n.fa-user-alt:before {\n  content: \"\\f406\"; }\n\n.fa-user-circle:before {\n  content: \"\\f2bd\"; }\n\n.fa-user-md:before {\n  content: \"\\f0f0\"; }\n\n.fa-user-plus:before {\n  content: \"\\f234\"; }\n\n.fa-user-secret:before {\n  content: \"\\f21b\"; }\n\n.fa-user-times:before {\n  content: \"\\f235\"; }\n\n.fa-users:before {\n  content: \"\\f0c0\"; }\n\n.fa-ussunnah:before {\n  content: \"\\f407\"; }\n\n.fa-utensil-fork:before {\n  content: \"\\f2e3\"; }\n\n.fa-utensil-knife:before {\n  content: \"\\f2e4\"; }\n\n.fa-utensil-spoon:before {\n  content: \"\\f2e5\"; }\n\n.fa-utensils:before {\n  content: \"\\f2e7\"; }\n\n.fa-utensils-alt:before {\n  content: \"\\f2e6\"; }\n\n.fa-vaadin:before {\n  content: \"\\f408\"; }\n\n.fa-venus:before {\n  content: \"\\f221\"; }\n\n.fa-venus-double:before {\n  content: \"\\f226\"; }\n\n.fa-venus-mars:before {\n  content: \"\\f228\"; }\n\n.fa-viacoin:before {\n  content: \"\\f237\"; }\n\n.fa-viadeo:before {\n  content: \"\\f2a9\"; }\n\n.fa-viadeo-square:before {\n  content: \"\\f2aa\"; }\n\n.fa-vial:before {\n  content: \"\\f492\"; }\n\n.fa-vials:before {\n  content: \"\\f493\"; }\n\n.fa-viber:before {\n  content: \"\\f409\"; }\n\n.fa-video:before {\n  content: \"\\f03d\"; }\n\n.fa-vimeo:before {\n  content: \"\\f40a\"; }\n\n.fa-vimeo-square:before {\n  content: \"\\f194\"; }\n\n.fa-vimeo-v:before {\n  content: \"\\f27d\"; }\n\n.fa-vine:before {\n  content: \"\\f1ca\"; }\n\n.fa-vk:before {\n  content: \"\\f189\"; }\n\n.fa-vnv:before {\n  content: \"\\f40b\"; }\n\n.fa-volleyball-ball:before {\n  content: \"\\f45f\"; }\n\n.fa-volume-down:before {\n  content: \"\\f027\"; }\n\n.fa-volume-mute:before {\n  content: \"\\f2e2\"; }\n\n.fa-volume-off:before {\n  content: \"\\f026\"; }\n\n.fa-volume-up:before {\n  content: \"\\f028\"; }\n\n.fa-vuejs:before {\n  content: \"\\f41f\"; }\n\n.fa-warehouse:before {\n  content: \"\\f494\"; }\n\n.fa-warehouse-alt:before {\n  content: \"\\f495\"; }\n\n.fa-watch:before {\n  content: \"\\f2e1\"; }\n\n.fa-weibo:before {\n  content: \"\\f18a\"; }\n\n.fa-weight:before {\n  content: \"\\f496\"; }\n\n.fa-weixin:before {\n  content: \"\\f1d7\"; }\n\n.fa-whatsapp:before {\n  content: \"\\f232\"; }\n\n.fa-whatsapp-square:before {\n  content: \"\\f40c\"; }\n\n.fa-wheelchair:before {\n  content: \"\\f193\"; }\n\n.fa-whistle:before {\n  content: \"\\f460\"; }\n\n.fa-whmcs:before {\n  content: \"\\f40d\"; }\n\n.fa-wifi:before {\n  content: \"\\f1eb\"; }\n\n.fa-wikipedia-w:before {\n  content: \"\\f266\"; }\n\n.fa-window:before {\n  content: \"\\f40e\"; }\n\n.fa-window-alt:before {\n  content: \"\\f40f\"; }\n\n.fa-window-close:before {\n  content: \"\\f410\"; }\n\n.fa-window-maximize:before {\n  content: \"\\f2d0\"; }\n\n.fa-window-minimize:before {\n  content: \"\\f2d1\"; }\n\n.fa-window-restore:before {\n  content: \"\\f2d2\"; }\n\n.fa-windows:before {\n  content: \"\\f17a\"; }\n\n.fa-won-sign:before {\n  content: \"\\f159\"; }\n\n.fa-wordpress:before {\n  content: \"\\f19a\"; }\n\n.fa-wordpress-simple:before {\n  content: \"\\f411\"; }\n\n.fa-wpbeginner:before {\n  content: \"\\f297\"; }\n\n.fa-wpexplorer:before {\n  content: \"\\f2de\"; }\n\n.fa-wpforms:before {\n  content: \"\\f298\"; }\n\n.fa-wrench:before {\n  content: \"\\f0ad\"; }\n\n.fa-x-ray:before {\n  content: \"\\f497\"; }\n\n.fa-xbox:before {\n  content: \"\\f412\"; }\n\n.fa-xing:before {\n  content: \"\\f168\"; }\n\n.fa-xing-square:before {\n  content: \"\\f169\"; }\n\n.fa-y-combinator:before {\n  content: \"\\f23b\"; }\n\n.fa-yahoo:before {\n  content: \"\\f19e\"; }\n\n.fa-yandex:before {\n  content: \"\\f413\"; }\n\n.fa-yandex-international:before {\n  content: \"\\f414\"; }\n\n.fa-yelp:before {\n  content: \"\\f1e9\"; }\n\n.fa-yen-sign:before {\n  content: \"\\f157\"; }\n\n.fa-yoast:before {\n  content: \"\\f2b1\"; }\n\n.fa-youtube:before {\n  content: \"\\f167\"; }\n\n.fa-youtube-square:before {\n  content: \"\\f431\"; }\n\n.sr-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px; }\n\n.sr-only-focusable:active, .sr-only-focusable:focus {\n  clip: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  position: static;\n  width: auto; }\n\nblockquote {\n  margin: 0;\n  padding: 0; }\n  blockquote p {\n    border: 1px solid #e8e8e8;\n    border-left: 0.5rem solid #e8e8e8;\n    margin: .5rem 0;\n    padding: .5rem 1rem .5rem 1.5rem; }\n\npre, code {\n  border-radius: .25em;\n  background-color: #f8f8f8; }\n\npre {\n  overflow-x: auto;\n  font-size: .9rem;\n  padding: 1rem; }\n  pre code {\n    padding: 0; }\n\ncode {\n  padding: .2em .5em; }\n\nhtml {\n  font-family: -apple-system, BlinkMacSystemFont, Helvetica, Arial;\n  font-size: 16px;\n  line-height: 1.5;\n  color: #2B2D33; }\n\nbody {\n  height: 100%; }\n\n* {\n  box-sizing: border-box; }\n\n.bcx-doc-nav {\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  width: 300px;\n  overflow-x: hidden;\n  overflow-y: auto;\n  background-color: #f2f2f2;\n  padding: .5rem;\n  transition: left ease 200ms;\n  border-right: 1px solid #e8e8e8; }\n  .bcx-doc-nav h1, .bcx-doc-nav h2, .bcx-doc-nav h3, .bcx-doc-nav h4, .bcx-doc-nav h5, .bcx-doc-nav h6 {\n    margin: .8em 0 .4em; }\n  .bcx-doc-nav .close-menu {\n    display: none; }\n\n.bcx-doc-nav-backdrop {\n  display: none; }\n\na.link {\n  display: block;\n  text-decoration: none;\n  font-size: .85rem; }\n  a.link.remote-link {\n    font-size: 0.75rem;\n    margin: 4px 0; }\n  a.link.deprecated, a.link.deprecated:visited {\n    text-decoration: line-through;\n    color: #666; }\n  a.link, a.link:visited {\n    color: #2B2D33;\n    padding: 4px 5px 4px 10px;\n    margin: 2px 0; }\n  a.link.active, a.link.active.deprecated, a.link.active:visited, a.link.active:visited.deprecated {\n    background-color: #5D99BD;\n    color: #fff; }\n  a.link:hover, a.link:hover.deprecated, a.link:hover:visited, a.link:hover:visited.deprecated {\n    background-color: #666;\n    color: #fff; }\n    a.link:hover.active, a.link:hover.deprecated.active, a.link:hover:visited.active, a.link:hover:visited.deprecated.active {\n      background-color: #5D99BD;\n      color: #fff; }\n\n.bcx-doc-main {\n  z-index: 1;\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 300px;\n  bottom: 0;\n  right: 0;\n  padding: 1rem .75rem;\n  transition: left ease 200ms;\n  overflow-x: hidden;\n  overflow-y: auto; }\n\n.bcx-overlay-spinner {\n  color: #30A1C1;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  color: #5D99BD; }\n\n.bcx-doc-demo {\n  display: flex;\n  flex-wrap: nowrap;\n  align-items: stretch;\n  margin-left: -.75rem;\n  margin-right: -.75rem; }\n  .bcx-doc-main > .bcx-doc-demo {\n    flex-direction: column;\n    height: 100%; }\n  compose > .bcx-doc-demo {\n    flex-direction: row;\n    box-shadow: 0 0 1rem #e8e8e8; }\n  .bcx-doc-demo .demo-app {\n    margin: 1rem;\n    flex-grow: 0; }\n  .bcx-doc-demo .demo-code {\n    position: relative;\n    flex-grow: 1;\n    display: flex;\n    align-items: stretch;\n    flex-direction: column; }\n    .bcx-doc-demo .demo-code .bcx-select {\n      flex-grow: 0;\n      flex-shrink: 0; }\n    .bcx-doc-demo .demo-code display-source {\n      flex: 1 1 0;\n      position: relative; }\n\n.display-source {\n  display: block;\n  position: relative; }\n\nselect.bcx-select {\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  border-radius: 0;\n  border: 0;\n  color: #fff;\n  padding: .25rem .5rem .25rem 1.5rem;\n  font-size: .85rem;\n  background: #6d90a3 url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'%3E%3Cpath fill='white' d='M2 0L0 2h4zm0 5L0 3h4z'/%3E%3C/svg%3E\") no-repeat left 0.5rem center;\n  background-size: 8px 10px; }\n\n.bcx-open-menu {\n  display: block;\n  position: absolute;\n  z-index: 2;\n  top: 0;\n  left: 0;\n  max-width: 100%;\n  padding: .4rem .6rem .4rem .5rem;\n  color: #fff;\n  background-color: #5D99BD;\n  border-bottom-right-radius: .6rem;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  cursor: default; }\n  .bcx-open-menu .fa-bars {\n    margin-right: .25rem; }\n\n@media screen and (min-width: 720px) {\n  .bcx-doc-main > .bcx-doc-demo .demo-app {\n    min-height: 100px; }\n  compose > .bcx-doc-demo .demo-app {\n    min-width: 300px; }\n  compose > .bcx-doc-demo .demo-code {\n    min-height: 300px; }\n  .CodeMirror-fullscreen {\n    left: 300px; }\n  .bcx-open-menu {\n    left: 300px;\n    max-width: calc(100% - 300px); }\n    .bcx-open-menu .fa-bars {\n      display: none; } }\n\n@media screen and (max-width: 1020px) {\n  compose > .bcx-doc-demo {\n    flex-direction: column; } }\n\n@media screen and (max-width: 720px) {\n  compose > .bcx-doc-demo .demo-code {\n    min-height: 200px; }\n  .bcx-doc-nav {\n    z-index: 4;\n    left: -300px; }\n    .bcx-doc-nav.menu-open {\n      left: 0;\n      box-shadow: 0 0 2rem rgba(0, 0, 0, 0.3); }\n      .bcx-doc-nav.menu-open .open-menu {\n        display: none; }\n    .bcx-doc-nav .close-menu {\n      display: block;\n      position: absolute;\n      z-index: 2;\n      top: 0;\n      right: 0;\n      font-size: 1.1rem;\n      padding: .4rem .5rem .4rem .6rem;\n      color: #666;\n      background-color: #e8e8e8;\n      border-bottom-left-radius: .6rem; }\n  .bcx-doc-nav-backdrop {\n    z-index: 3;\n    display: block;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background-color: rgba(102, 102, 102, 0.6); }\n  .bcx-doc-main {\n    left: 0; } }\n\n/*# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3MiLCJjc3MvZG9jLmNzcyIsImNzcy9fZmEtZm9udC5zY3NzIiwiLi4vLi4vZmE1L3Njc3MvZm9udGF3ZXNvbWUuc2NzcyIsIi4uLy4uL2ZhNS9zY3NzL19jb3JlLnNjc3MiLCIuLi8uLi9mYTUvc2Nzcy9fbGFyZ2VyLnNjc3MiLCIuLi8uLi9mYTUvc2Nzcy9fZml4ZWQtd2lkdGguc2NzcyIsIi4uLy4uL2ZhNS9zY3NzL19saXN0LnNjc3MiLCIuLi8uLi9mYTUvc2Nzcy9fdmFyaWFibGVzLnNjc3MiLCIuLi8uLi9mYTUvc2Nzcy9fYm9yZGVyZWQtcHVsbGVkLnNjc3MiLCIuLi8uLi9mYTUvc2Nzcy9fYW5pbWF0ZWQuc2NzcyIsIi4uLy4uL2ZhNS9zY3NzL19yb3RhdGVkLWZsaXBwZWQuc2NzcyIsIi4uLy4uL2ZhNS9zY3NzL19taXhpbnMuc2NzcyIsIi4uLy4uL2ZhNS9zY3NzL19zdGFja2VkLnNjc3MiLCIuLi8uLi9mYTUvc2Nzcy9faWNvbnMuc2NzcyIsIi4uLy4uL2ZhNS9zY3NzL19zY3JlZW4tcmVhZGVyLnNjc3MiLCJjc3MvX21hcmstZG93bi5zY3NzIiwiY3NzL19jb2xvcnMuc2NzcyIsImNzcy9kb2Muc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw0RUFBNEU7QUFFNUU7Z0ZBQ2dGO0FBRWhGOzs7R0FHRztBQUVIO0VBQ0Usa0JBQWlCO0VBQUUsT0FBTztFQUMxQiwrQkFBOEI7RUFBRSxPQUFPLEVBQ3hDOztBQUVEO2dGQUNnRjtBQUVoRjs7R0FFRztBQUVIO0VBQ0UsVUFBUyxFQUNWOztBQUVEOzs7R0FHRztBQUVIO0VBQ0UsZUFBYztFQUNkLGlCQUFnQixFQUNqQjs7QUFFRDtnRkFDZ0Y7QUFFaEY7OztHQUdHO0FBRUg7RUFDRSx3QkFBdUI7RUFBRSxPQUFPO0VBQ2hDLFVBQVM7RUFBRSxPQUFPO0VBQ2xCLGtCQUFpQjtFQUFFLE9BQU8sRUFDM0I7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QUFDNUY7RUFBcUMsaUJOUUEsRU1SeUM7O0FBQzlFO0VBQXlDLGlCTk9KLEVNUGlEOztBQUN0RjtFQUF5QyxpQk5NSixFTU5pRDs7QUFDdEY7RUFBbUMsaUJOS0UsRU1McUM7O0FBQzFFO0VBQWdDLGlCTklLLEVNSitCOztBQUNwRTtFQUFxQyxpQk5HQSxFTUh5Qzs7QUFDOUU7RUFBMkMsaUJORU4sRU1GcUQ7O0FBQzFGO0VBQXdDLGlCTkNILEVNRCtDOztBQUNwRjtFQUFvQyxpQk5BQyxFTUF1Qzs7QUFDNUU7RUFBeUMsaUJOREosRU1DaUQ7O0FBQ3RGO0VBQTBDLGlCTkZMLEVNRW1EOztBQUN4RjtFQUF1QyxpQk5IRixFTUc2Qzs7QUFDbEY7RUFBd0MsaUJOSkgsRU1JK0M7O0FBQ3BGO0VBQXNDLGlCTkxELEVNSzJDOztBQUNoRjtFQUFtQyxpQk5ORSxFTU1xQzs7QUFDMUU7RUFBdUMsaUJOUEYsRU1PNkM7O0FBQ2xGO0VBQXNDLGlCTlJELEVNUTJDOztBQUNoRjtFQUFnRSxpQk5UM0IsRU1TK0Y7O0FBQ3BJO0VBQW1DLGlCTlZFLEVNVXFDOztBQUMxRTtFQUFtQyxpQk5YRSxFTVdxQzs7QUFDMUU7RUFBb0MsaUJOWkMsRU1ZdUM7O0FBQzVFO0VBQXNDLGlCTmJELEVNYTJDOztBQUNoRjtFQUE4QyxpQk5kVCxFTWMyRDs7QUFDaEc7RUFBOEMsaUJOZlQsRU1lMkQ7O0FBQ2hHO0VBQStDLGlCTmhCVixFTWdCNkQ7O0FBQ2xHO0VBQTRDLGlCTmpCUCxFTWlCdUQ7O0FBQzVGO0VBQXVDLGlCTmxCRixFTWtCNkM7O0FBQ2xGO0VBQXVDLGlCTm5CRixFTW1CNkM7O0FBQ2xGO0VBQXdDLGlCTnBCSCxFTW9CK0M7O0FBQ3BGO0VBQXFDLGlCTnJCQSxFTXFCeUM7O0FBQzlFO0VBQTBDLGlCTnRCTCxFTXNCbUQ7O0FBQ3hGO0VBQW9DLGlCTnZCQyxFTXVCdUM7O0FBQzVFO0VBQXNDLGlCTnhCRCxFTXdCMkM7O0FBQ2hGO0VBQTBDLGlCTnpCTCxFTXlCbUQ7O0FBQ3hGO0VBQWtDLGlCTjFCRyxFTTBCbUM7O0FBQ3hFO0VBQWtDLGlCTjNCRyxFTTJCbUM7O0FBQ3hFO0VBQXNDLGlCTjVCRCxFTTRCMkM7O0FBQ2hGO0VBQW9DLGlCTjdCQyxFTTZCdUM7O0FBQzVFO0VBQWtELGlCTjlCYixFTThCbUU7O0FBQ3hHO0VBQWtELGlCTi9CYixFTStCbUU7O0FBQ3hHO0VBQW1ELGlCTmhDZCxFTWdDcUU7O0FBQzFHO0VBQWdELGlCTmpDWCxFTWlDK0Q7O0FBQ3BHO0VBQTJDLGlCTmxDTixFTWtDcUQ7O0FBQzFGO0VBQWtELGlCTm5DYixFTW1DbUU7O0FBQ3hHO0VBQWdELGlCTnBDWCxFTW9DK0Q7O0FBQ3BHO0VBQWlELGlCTnJDWixFTXFDaUU7O0FBQ3RHO0VBQStDLGlCTnRDVixFTXNDNkQ7O0FBQ2xHO0VBQTJDLGlCTnZDTixFTXVDcUQ7O0FBQzFGO0VBQTRDLGlCTnhDUCxFTXdDdUQ7O0FBQzVGO0VBQWtELGlCTnpDYixFTXlDbUU7O0FBQ3hHO0VBQWtELGlCTjFDYixFTTBDbUU7O0FBQ3hHO0VBQW1ELGlCTjNDZCxFTTJDcUU7O0FBQzFHO0VBQWdELGlCTjVDWCxFTTRDK0Q7O0FBQ3BHO0VBQWdELGlCTjdDWCxFTTZDK0Q7O0FBQ3BHO0VBQThDLGlCTjlDVCxFTThDMkQ7O0FBQ2hHO0VBQStDLGlCTi9DVixFTStDNkQ7O0FBQ2xHO0VBQTZDLGlCTmhEUixFTWdEeUQ7O0FBQzlGO0VBQXlDLGlCTmpESixFTWlEaUQ7O0FBQ3RGO0VBQThDLGlCTmxEVCxFTWtEMkQ7O0FBQ2hHO0VBQThDLGlCTm5EVCxFTW1EMkQ7O0FBQ2hHO0VBQStDLGlCTnBEVixFTW9ENkQ7O0FBQ2xHO0VBQTRDLGlCTnJEUCxFTXFEdUQ7O0FBQzVGO0VBQXVDLGlCTnRERixFTXNENkM7O0FBQ2xGO0VBQThDLGlCTnZEVCxFTXVEMkQ7O0FBQ2hHO0VBQTRDLGlCTnhEUCxFTXdEdUQ7O0FBQzVGO0VBQTZDLGlCTnpEUixFTXlEeUQ7O0FBQzlGO0VBQTJDLGlCTjFETixFTTBEcUQ7O0FBQzFGO0VBQXVDLGlCTjNERixFTTJENkM7O0FBQ2xGO0VBQXdDLGlCTjVESCxFTTREK0M7O0FBQ3BGO0VBQThDLGlCTjdEVCxFTTZEMkQ7O0FBQ2hHO0VBQThDLGlCTjlEVCxFTThEMkQ7O0FBQ2hHO0VBQStDLGlCTi9EVixFTStENkQ7O0FBQ2xHO0VBQTRDLGlCTmhFUCxFTWdFdUQ7O0FBQzVGO0VBQTRDLGlCTmpFUCxFTWlFdUQ7O0FBQzVGO0VBQTBDLGlCTmxFTCxFTWtFbUQ7O0FBQ3hGO0VBQTJDLGlCTm5FTixFTW1FcUQ7O0FBQzFGO0VBQXlDLGlCTnBFSixFTW9FaUQ7O0FBQ3RGO0VBQXFDLGlCTnJFQSxFTXFFeUM7O0FBQzlFO0VBQW1DLGlCTnRFRSxFTXNFcUM7O0FBQzFFO0VBQXVDLGlCTnZFRixFTXVFNkM7O0FBQ2xGO0VBQXlDLGlCTnhFSixFTXdFaUQ7O0FBQ3RGO0VBQXlDLGlCTnpFSixFTXlFaUQ7O0FBQ3RGO0VBQXFDLGlCTjFFQSxFTTBFeUM7O0FBQzlFO0VBQXFDLGlCTjNFQSxFTTJFeUM7O0FBQzlFO0VBQXdELGlCTjVFbkIsRU00RStFOztBQUNwSDtFQUFxQyxpQk43RUEsRU02RXlDOztBQUM5RTtFQUF1QyxpQk45RUYsRU04RTZDOztBQUNsRjtFQUErQixpQk4vRU0sRU0rRTZCOztBQUNsRTtFQUFvQyxpQk5oRkMsRU1nRnVDOztBQUM1RTtFQUE4QyxpQk5qRlQsRU1pRjJEOztBQUNoRztFQUF5QyxpQk5sRkosRU1rRmlEOztBQUN0RjtFQUFvQyxpQk5uRkMsRU1tRnVDOztBQUM1RTtFQUFtQyxpQk5wRkUsRU1vRnFDOztBQUMxRTtFQUFnQyxpQk5yRkssRU1xRitCOztBQUNwRTtFQUFxQyxpQk50RkEsRU1zRnlDOztBQUM5RTtFQUFrQyxpQk52RkcsRU11Rm1DOztBQUN4RTtFQUF3QyxpQk54RkgsRU13RitDOztBQUNwRjtFQUEwQyxpQk56RkwsRU15Rm1EOztBQUN4RjtFQUFnQyxpQk4xRkssRU0wRitCOztBQUNwRTtFQUFxQyxpQk4zRkEsRU0yRnlDOztBQUM5RTtFQUFxQyxpQk41RkEsRU00RnlDOztBQUM5RTtFQUFvQyxpQk43RkMsRU02RnVDOztBQUM1RTtFQUF3QyxpQk45RkgsRU04RitDOztBQUNwRjtFQUF5QyxpQk4vRkosRU0rRmlEOztBQUN0RjtFQUF5QyxpQk5oR0osRU1nR2lEOztBQUN0RjtFQUFpQyxpQk5qR0ksRU1pR2lDOztBQUN0RTtFQUFxQyxpQk5sR0EsRU1rR3lDOztBQUM5RTtFQUEwQyxpQk5uR0wsRU1tR21EOztBQUN4RjtFQUE0QyxpQk5wR1AsRU1vR3VEOztBQUM1RjtFQUE0QyxpQk5yR1AsRU1xR3VEOztBQUM1RjtFQUFpQyxpQk50R0ksRU1zR2lDOztBQUN0RTtFQUF5QyxpQk52R0osRU11R2lEOztBQUN0RjtFQUEwQyxpQk54R0wsRU13R21EOztBQUN4RjtFQUF5QyxpQk56R0osRU15R2lEOztBQUN0RjtFQUF5QyxpQk4xR0osRU0wR2lEOztBQUN0RjtFQUE0QyxpQk4zR1AsRU0yR3VEOztBQUM1RjtFQUEwQyxpQk41R0wsRU00R21EOztBQUN4RjtFQUFtRCxpQk43R2QsRU02R3FFOztBQUMxRztFQUFnQyxpQk45R0ssRU04RytCOztBQUNwRTtFQUFpQyxpQk4vR0ksRU0rR2lDOztBQUN0RTtFQUFvQyxpQk5oSEMsRU1nSHVDOztBQUM1RTtFQUEyQyxpQk5qSE4sRU1pSHFEOztBQUMxRjtFQUFpQyxpQk5sSEksRU1rSGlDOztBQUN0RTtFQUF1QyxpQk5uSEYsRU1tSDZDOztBQUNsRjtFQUFvQyxpQk5wSEMsRU1vSHVDOztBQUM1RTtFQUFzQyxpQk5ySEQsRU1xSDJDOztBQUNoRjtFQUF1QyxpQk50SEYsRU1zSDZDOztBQUNsRjtFQUEwQyxpQk52SEwsRU11SG1EOztBQUN4RjtFQUFzQyxpQk54SEQsRU13SDJDOztBQUNoRjtFQUFvQyxpQk56SEMsRU15SHVDOztBQUM1RTtFQUFpQyxpQk4xSEksRU0wSGlDOztBQUN0RTtFQUFzQyxpQk4zSEQsRU0ySDJDOztBQUNoRjtFQUF1QyxpQk41SEYsRU00SDZDOztBQUNsRjtFQUFrQyxpQk43SEcsRU02SG1DOztBQUN4RTtFQUFvQyxpQk45SEMsRU04SHVDOztBQUM1RTtFQUFzQyxpQk4vSEQsRU0rSDJDOztBQUNoRjtFQUFzQyxpQk5oSUQsRU1nSTJDOztBQUNoRjtFQUF3QyxpQk5qSUgsRU1pSStDOztBQUNwRjtFQUFpQyxpQk5sSUksRU1rSWlDOztBQUN0RTtFQUFpQyxpQk5uSUksRU1tSWlDOztBQUN0RTtFQUFpQyxpQk5wSUksRU1vSWlDOztBQUN0RTtFQUFpQyxpQk5ySUksRU1xSWlDOztBQUN0RTtFQUFxQyxpQk50SUEsRU1zSXlDOztBQUM5RTtFQUF5QyxpQk52SUosRU11SWlEOztBQUN0RjtFQUF5QyxpQk54SUosRU13SWlEOztBQUN0RjtFQUFnQyxpQk56SUssRU15SStCOztBQUNwRTtFQUFzQyxpQk4xSUQsRU0wSTJDOztBQUNoRjtFQUFrQyxpQk4zSUcsRU0ySW1DOztBQUN4RTtFQUF5QyxpQk41SUosRU00SWlEOztBQUN0RjtFQUFvQyxpQk43SUMsRU02SXVDOztBQUM1RTtFQUFzQyxpQk45SUQsRU04STJDOztBQUNoRjtFQUE4QyxpQk4vSVQsRU0rSTJEOztBQUNoRztFQUFvQyxpQk5oSkMsRU1nSnVDOztBQUM1RTtFQUFnQyxpQk5qSkssRU1pSitCOztBQUNwRTtFQUFnQyxpQk5sSkssRU1rSitCOztBQUNwRTtFQUFxQyxpQk5uSkEsRU1tSnlDOztBQUM5RTtFQUFxQyxpQk5wSkEsRU1vSnlDOztBQUM5RTtFQUFxQyxpQk5ySkEsRU1xSnlDOztBQUM5RTtFQUFpQyxpQk50SkksRU1zSmlDOztBQUN0RTtFQUE2QyxpQk52SlIsRU11SnlEOztBQUM5RjtFQUFnQyxpQk54SkssRU13SitCOztBQUNwRTtFQUF1QyxpQk56SkYsRU15SjZDOztBQUNsRjtFQUF1QyxpQk4xSkYsRU0wSjZDOztBQUNsRjtFQUFxQyxpQk4zSkEsRU0ySnlDOztBQUM5RTtFQUF5QyxpQk41SkosRU00SmlEOztBQUN0RjtFQUEyQyxpQk43Sk4sRU02SnFEOztBQUMxRjtFQUEwQyxpQk45SkwsRU04Sm1EOztBQUN4RjtFQUFpRCxpQk4vSlosRU0rSmlFOztBQUN0RztFQUEyQyxpQk5oS04sRU1nS3FEOztBQUMxRjtFQUEwQyxpQk5qS0wsRU1pS21EOztBQUN4RjtFQUEyQyxpQk5sS04sRU1rS3FEOztBQUMxRjtFQUFtQyxpQk5uS0UsRU1tS3FDOztBQUMxRTtFQUF1QyxpQk5wS0YsRU1vSzZDOztBQUNsRjtFQUF5QyxpQk5yS0osRU1xS2lEOztBQUN0RjtFQUFxQyxpQk50S0EsRU1zS3lDOztBQUM5RTtFQUFnQyxpQk52S0ssRU11SytCOztBQUNwRTtFQUE4QyxpQk54S1QsRU13SzJEOztBQUNoRztFQUE4QyxpQk56S1QsRU15SzJEOztBQUNoRztFQUErQyxpQk4xS1YsRU0wSzZEOztBQUNsRztFQUE0QyxpQk4zS1AsRU0yS3VEOztBQUM1RjtFQUF1QyxpQk41S0YsRU00SzZDOztBQUNsRjtFQUF1QyxpQk43S0YsRU02SzZDOztBQUNsRjtFQUF3QyxpQk45S0gsRU04SytDOztBQUNwRjtFQUE4QyxpQk4vS1QsRU0rSzJEOztBQUNoRztFQUE4QyxpQk5oTFQsRU1nTDJEOztBQUNoRztFQUErQyxpQk5qTFYsRU1pTDZEOztBQUNsRztFQUE0QyxpQk5sTFAsRU1rTHVEOztBQUM1RjtFQUFxQyxpQk5uTEEsRU1tTHlDOztBQUM5RTtFQUE0QyxpQk5wTFAsRU1vTHVEOztBQUM1RjtFQUFzQyxpQk5yTEQsRU1xTDJDOztBQUNoRjtFQUEwQyxpQk50TEwsRU1zTG1EOztBQUN4RjtFQUFvQyxpQk52TEMsRU11THVDOztBQUM1RTtFQUF5QyxpQk54TEosRU13TGlEOztBQUN0RjtFQUEyQyxpQk56TE4sRU15THFEOztBQUMxRjtFQUF3QyxpQk4xTEgsRU0wTCtDOztBQUNwRjtFQUFtQyxpQk4zTEUsRU0yTHFDOztBQUMxRTtFQUEwQyxpQk41TEwsRU00TG1EOztBQUN4RjtFQUFzQyxpQk43TEQsRU02TDJDOztBQUNoRjtFQUFzQyxpQk45TEQsRU04TDJDOztBQUNoRjtFQUFvQyxpQk4vTEMsRU0rTHVDOztBQUM1RTtFQUF1QyxpQk5oTUYsRU1nTTZDOztBQUNsRjtFQUF3QyxpQk5qTUgsRU1pTStDOztBQUNwRjtFQUF1QyxpQk5sTUYsRU1rTTZDOztBQUNsRjtFQUFzQyxpQk5uTUQsRU1tTTJDOztBQUNoRjtFQUF1QyxpQk5wTUYsRU1vTTZDOztBQUNsRjtFQUFzQyxpQk5yTUQsRU1xTTJDOztBQUNoRjtFQUFrQyxpQk50TUcsRU1zTW1DOztBQUN4RTtFQUF5QyxpQk52TUosRU11TWlEOztBQUN0RjtFQUF5QyxpQk54TUosRU13TWlEOztBQUN0RjtFQUFrQyxpQk56TUcsRU15TW1DOztBQUN4RTtFQUF5QyxpQk4xTUosRU0wTWlEOztBQUN0RjtFQUE2QyxpQk4zTVIsRU0yTXlEOztBQUM5RjtFQUF3QyxpQk41TUgsRU00TStDOztBQUNwRjtFQUF3QyxpQk43TUgsRU02TStDOztBQUNwRjtFQUE0QyxpQk45TVAsRU04TXVEOztBQUM1RjtFQUF1QyxpQk4vTUYsRU0rTTZDOztBQUNsRjtFQUEyQyxpQk5oTk4sRU1nTnFEOztBQUMxRjtFQUF5QyxpQk5qTkosRU1pTmlEOztBQUN0RjtFQUE2QyxpQk5sTlIsRU1rTnlEOztBQUM5RjtFQUF1QyxpQk5uTkYsRU1tTjZDOztBQUNsRjtFQUEyQyxpQk5wTk4sRU1vTnFEOztBQUMxRjtFQUF3QyxpQk5yTkgsRU1xTitDOztBQUNwRjtFQUE0QyxpQk50TlAsRU1zTnVEOztBQUM1RjtFQUF1QyxpQk52TkYsRU11TjZDOztBQUNsRjtFQUEyQyxpQk54Tk4sRU13TnFEOztBQUMxRjtFQUFnRCxpQk56TlgsRU15TitEOztBQUNwRztFQUFnRCxpQk4xTlgsRU0wTitEOztBQUNwRztFQUFpRCxpQk4zTlosRU0yTmlFOztBQUN0RztFQUE4QyxpQk41TlQsRU00TjJEOztBQUNoRztFQUFnRCxpQk43TlgsRU02TitEOztBQUNwRztFQUFnRCxpQk45TlgsRU04TitEOztBQUNwRztFQUFpRCxpQk4vTlosRU0rTmlFOztBQUN0RztFQUE4QyxpQk5oT1QsRU1nTzJEOztBQUNoRztFQUF5QyxpQk5qT0osRU1pT2lEOztBQUN0RjtFQUF5QyxpQk5sT0osRU1rT2lEOztBQUN0RjtFQUEwQyxpQk5uT0wsRU1tT21EOztBQUN4RjtFQUFnRCxpQk5wT1gsRU1vTytEOztBQUNwRztFQUFnRCxpQk5yT1gsRU1xTytEOztBQUNwRztFQUFpRCxpQk50T1osRU1zT2lFOztBQUN0RztFQUE4QyxpQk52T1QsRU11TzJEOztBQUNoRztFQUF1QyxpQk54T0YsRU13TzZDOztBQUNsRjtFQUFrQyxpQk56T0csRU15T21DOztBQUN4RTtFQUFtQyxpQk4xT0UsRU0wT3FDOztBQUMxRTtFQUFtQyxpQk4zT0UsRU0yT3FDOztBQUMxRTtFQUF5QyxpQk41T0osRU00T2lEOztBQUN0RjtFQUFzQyxpQk43T0QsRU02TzJDOztBQUNoRjtFQUE0QyxpQk45T1AsRU04T3VEOztBQUM1RjtFQUEyQyxpQk4vT04sRU0rT3FEOztBQUMxRjtFQUFrQyxpQk5oUEcsRU1nUG1DOztBQUN4RTtFQUFrQyxpQk5qUEcsRU1pUG1DOztBQUN4RTtFQUE4QyxpQk5sUFQsRU1rUDJEOztBQUNoRztFQUFrQyxpQk5uUEcsRU1tUG1DOztBQUN4RTtFQUEyQyxpQk5wUE4sRU1vUHFEOztBQUMxRjtFQUErQyxpQk5yUFYsRU1xUDZEOztBQUNsRztFQUF5QyxpQk50UEosRU1zUGlEOztBQUN0RjtFQUE2QyxpQk52UFIsRU11UHlEOztBQUM5RjtFQUF1QyxpQk54UEYsRU13UDZDOztBQUNsRjtFQUF1QyxpQk56UEYsRU15UDZDOztBQUNsRjtFQUF5QyxpQk4xUEosRU0wUGlEOztBQUN0RjtFQUFpQyxpQk4zUEksRU0yUGlDOztBQUN0RTtFQUFpQyxpQk41UEksRU00UGlDOztBQUN0RTtFQUF3QyxpQk43UEgsRU02UCtDOztBQUNwRjtFQUF3QyxpQk45UEgsRU04UCtDOztBQUNwRjtFQUF1QyxpQk4vUEYsRU0rUDZDOztBQUNsRjtFQUFvQyxpQk5oUUMsRU1nUXVDOztBQUM1RTtFQUFxQyxpQk5qUUEsRU1pUXlDOztBQUM5RTtFQUFtQyxpQk5sUUUsRU1rUXFDOztBQUMxRTtFQUFnQyxpQk5uUUssRU1tUStCOztBQUNwRTtFQUFpQyxpQk5wUUksRU1vUWlDOztBQUN0RTtFQUFvQyxpQk5yUUMsRU1xUXVDOztBQUM1RTtFQUFvQyxpQk50UUMsRU1zUXVDOztBQUM1RTtFQUF3QyxpQk52UUgsRU11UStDOztBQUNwRjtFQUFxQyxpQk54UUEsRU13UXlDOztBQUM5RTtFQUFvQyxpQk56UUMsRU15UXVDOztBQUM1RTtFQUFxQyxpQk4xUUEsRU0wUXlDOztBQUM5RTtFQUF5QyxpQk4zUUosRU0yUWlEOztBQUN0RjtFQUEwQyxpQk41UUwsRU00UW1EOztBQUN4RjtFQUEyQyxpQk43UU4sRU02UXFEOztBQUMxRjtFQUFtQyxpQk45UUUsRU04UXFDOztBQUMxRTtFQUEwQyxpQk4vUUwsRU0rUW1EOztBQUN4RjtFQUE4QyxpQk5oUlQsRU1nUjJEOztBQUNoRztFQUFpQyxpQk5qUkksRU1pUmlDOztBQUN0RTtFQUFzQyxpQk5sUkQsRU1rUjJDOztBQUNoRjtFQUFtQyxpQk5uUkUsRU1tUnFDOztBQUMxRTtFQUE2QyxpQk5wUlIsRU1vUnlEOztBQUM5RjtFQUF3QyxpQk5yUkgsRU1xUitDOztBQUNwRjtFQUE4QyxpQk50UlQsRU1zUjJEOztBQUNoRztFQUE4QyxpQk52UlQsRU11UjJEOztBQUNoRztFQUFvQyxpQk54UkMsRU13UnVDOztBQUM1RTtFQUFpQyxpQk56UkksRU15UmlDOztBQUN0RTtFQUF1QyxpQk4xUkYsRU0wUjZDOztBQUNsRjtFQUFpQyxpQk4zUkksRU0yUmlDOztBQUN0RTtFQUFxQyxpQk41UkEsRU00UnlDOztBQUM5RTtFQUFpQyxpQk43UkksRU02UmlDOztBQUN0RTtFQUFrQyxpQk45UkcsRU04Um1DOztBQUN4RTtFQUFvQyxpQk4vUkMsRU0rUnVDOztBQUM1RTtFQUFnQyxpQk5oU0ssRU1nUytCOztBQUNwRTtFQUF1QyxpQk5qU0YsRU1pUzZDOztBQUNsRjtFQUFvQyxpQk5sU0MsRU1rU3VDOztBQUM1RTtFQUFxQyxpQk5uU0EsRU1tU3lDOztBQUM5RTtFQUFxQyxpQk5wU0EsRU1vU3lDOztBQUM5RTtFQUFpQyxpQk5yU0ksRU1xU2lDOztBQUN0RTtFQUFzQyxpQk50U0QsRU1zUzJDOztBQUNoRjtFQUFzQyxpQk52U0QsRU11UzJDOztBQUNoRjtFQUFvQyxpQk54U0MsRU13U3VDOztBQUM1RTtFQUFvQyxpQk56U0MsRU15U3VDOztBQUM1RTtFQUF3QyxpQk4xU0gsRU0wUytDOztBQUNwRjtFQUF1QyxpQk4zU0YsRU0yUzZDOztBQUNsRjtFQUFzQyxpQk41U0QsRU00UzJDOztBQUNoRjtFQUFvQyxpQk43U0MsRU02U3VDOztBQUM1RTtFQUFpQyxpQk45U0ksRU04U2lDOztBQUN0RTtFQUEwQyxpQk4vU0wsRU0rU21EOztBQUN4RjtFQUFvQyxpQk5oVEMsRU1nVHVDOztBQUM1RTtFQUFzQyxpQk5qVEQsRU1pVDJDOztBQUNoRjtFQUFnQyxpQk5sVEssRU1rVCtCOztBQUNwRTtFQUFtQyxpQk5uVEUsRU1tVHFDOztBQUMxRTtFQUFtQyxpQk5wVEUsRU1vVHFDOztBQUMxRTtFQUF3QyxpQk5yVEgsRU1xVCtDOztBQUNwRjtFQUFrQyxpQk50VEcsRU1zVG1DOztBQUN4RTtFQUF3QyxpQk52VEgsRU11VCtDOztBQUNwRjtFQUEwQyxpQk54VEwsRU13VG1EOztBQUN4RjtFQUE4QyxpQk56VFQsRU15VDJEOztBQUNoRztFQUFnRCxpQk4xVFgsRU0wVCtEOztBQUNwRztFQUF1QyxpQk4zVEYsRU0yVDZDOztBQUNsRjtFQUFxQyxpQk41VEEsRU00VHlDOztBQUM5RTtFQUEwQyxpQk43VEwsRU02VG1EOztBQUN4RjtFQUFxQyxpQk45VEEsRU04VHlDOztBQUM5RTtFQUE0QyxpQk4vVFAsRU0rVHVEOztBQUM1RjtFQUFvQyxpQk5oVUMsRU1nVXVDOztBQUM1RTtFQUFtQyxpQk5qVUUsRU1pVXFDOztBQUMxRTtFQUFxQyxpQk5sVUEsRU1rVXlDOztBQUM5RTtFQUFtQyxpQk5uVUUsRU1tVXFDOztBQUMxRTtFQUF1QyxpQk5wVUYsRU1vVTZDOztBQUNsRjtFQUFpQyxpQk5yVUksRU1xVWlDOztBQUN0RTtFQUFpQyxpQk50VUksRU1zVWlDOztBQUN0RTtFQUFrQyxpQk52VUcsRU11VW1DOztBQUN4RTtFQUFzQyxpQk54VUQsRU13VTJDOztBQUNoRjtFQUF1QyxpQk56VUYsRU15VTZDOztBQUNsRjtFQUEyQyxpQk4xVU4sRU0wVXFEOztBQUMxRjtFQUF1QyxpQk4zVUYsRU0yVTZDOztBQUNsRjtFQUEyQyxpQk41VU4sRU00VXFEOztBQUMxRjtFQUFrQyxpQk43VUcsRU02VW1DOztBQUN4RTtFQUFtQyxpQk45VUUsRU04VXFDOztBQUMxRTtFQUFxQyxpQk4vVUEsRU0rVXlDOztBQUM5RTtFQUEwQyxpQk5oVkwsRU1nVm1EOztBQUN4RjtFQUE0QyxpQk5qVlAsRU1pVnVEOztBQUM1RjtFQUFtQyxpQk5sVkUsRU1rVnFDOztBQUMxRTtFQUFtQyxpQk5uVkUsRU1tVnFDOztBQUMxRTtFQUFtQyxpQk5wVkUsRU1vVnFDOztBQUMxRTtFQUFxQyxpQk5yVkEsRU1xVnlDOztBQUM5RTtFQUFpQyxpQk50VkksRU1zVmlDOztBQUN0RTtFQUFzQyxpQk52VkQsRU11VjJDOztBQUNoRjtFQUFxQyxpQk54VkEsRU13VnlDOztBQUM5RTtFQUF5QyxpQk56VkosRU15VmlEOztBQUN0RjtFQUF3QyxpQk4xVkgsRU0wVitDOztBQUNwRjtFQUErQyxpQk4zVlYsRU0yVjZEOztBQUNsRztFQUErQyxpQk41VlYsRU00VjZEOztBQUNsRztFQUFpRCxpQk43VlosRU02VmlFOztBQUN0RztFQUFtQyxpQk45VkUsRU04VnFDOztBQUMxRTtFQUF1QyxpQk4vVkYsRU0rVjZDOztBQUNsRjtFQUEwQyxpQk5oV0wsRU1nV21EOztBQUN4RjtFQUE4QyxpQk5qV1QsRU1pVzJEOztBQUNoRztFQUF3QyxpQk5sV0gsRU1rVytDOztBQUNwRjtFQUF5QyxpQk5uV0osRU1tV2lEOztBQUN0RjtFQUEwQyxpQk5wV0wsRU1vV21EOztBQUN4RjtFQUE4QyxpQk5yV1QsRU1xVzJEOztBQUNoRztFQUFpRCxpQk50V1osRU1zV2lFOztBQUN0RztFQUFxRCxpQk52V2hCLEVNdVd5RTs7QUFDOUc7RUFBZ0MsaUJOeFdLLEVNd1crQjs7QUFDcEU7RUFBd0MsaUJOeldILEVNeVcrQzs7QUFDcEY7RUFBc0MsaUJOMVdELEVNMFcyQzs7QUFDaEY7RUFBcUMsaUJOM1dBLEVNMld5Qzs7QUFDOUU7RUFBdUMsaUJONVdGLEVNNFc2Qzs7QUFDbEY7RUFBK0MsaUJON1dWLEVNNlc2RDs7QUFDbEc7RUFBNEMsaUJOOVdQLEVNOFd1RDs7QUFDNUY7RUFBMEMsaUJOL1dMLEVNK1dtRDs7QUFDeEY7RUFBeUMsaUJOaFhKLEVNZ1hpRDs7QUFDdEY7RUFBZ0MsaUJOalhLLEVNaVgrQjs7QUFDcEU7RUFBbUMsaUJObFhFLEVNa1hxQzs7QUFDMUU7RUFBeUMsaUJOblhKLEVNbVhpRDs7QUFDdEY7RUFBd0MsaUJOcFhILEVNb1grQzs7QUFDcEY7RUFBaUMsaUJOclhJLEVNcVhpQzs7QUFDdEU7RUFBcUMsaUJOdFhBLEVNc1h5Qzs7QUFDOUU7RUFBeUMsaUJOdlhKLEVNdVhpRDs7QUFDdEY7RUFBdUMsaUJOeFhGLEVNd1g2Qzs7QUFDbEY7RUFBdUMsaUJOelhGLEVNeVg2Qzs7QUFDbEY7RUFBc0MsaUJOMVhELEVNMFgyQzs7QUFDaEY7RUFBc0MsaUJOM1hELEVNMlgyQzs7QUFDaEY7RUFBdUMsaUJONVhGLEVNNFg2Qzs7QUFDbEY7RUFBNkMsaUJON1hSLEVNNlh5RDs7QUFDOUY7RUFBdUMsaUJOOVhGLEVNOFg2Qzs7QUFDbEY7RUFBeUMsaUJOL1hKLEVNK1hpRDs7QUFDdEY7RUFBNkMsaUJOaFlSLEVNZ1l5RDs7QUFDOUY7RUFBdUMsaUJOallGLEVNaVk2Qzs7QUFDbEY7RUFBcUMsaUJObFlBLEVNa1l5Qzs7QUFDOUU7RUFBc0MsaUJObllELEVNbVkyQzs7QUFDaEY7RUFBNEMsaUJOcFlQLEVNb1l1RDs7QUFDNUY7RUFBdUMsaUJOcllGLEVNcVk2Qzs7QUFDbEY7RUFBdUMsaUJOdFlGLEVNc1k2Qzs7QUFDbEY7RUFBc0MsaUJOdllELEVNdVkyQzs7QUFDaEY7RUFBaUMsaUJOeFlJLEVNd1lpQzs7QUFDdEU7RUFBcUMsaUJOellBLEVNeVl5Qzs7QUFDOUU7RUFBbUMsaUJOMVlFLEVNMFlxQzs7QUFDMUU7RUFBaUMsaUJOM1lJLEVNMllpQzs7QUFDdEU7RUFBOEMsaUJONVlULEVNNFkyRDs7QUFDaEc7RUFBb0MsaUJON1lDLEVNNll1Qzs7QUFDNUU7RUFBc0MsaUJOOVlELEVNOFkyQzs7QUFDaEY7RUFBd0MsaUJOL1lILEVNK1krQzs7QUFDcEY7RUFBdUMsaUJOaFpGLEVNZ1o2Qzs7QUFDbEY7RUFBaUMsaUJOalpJLEVNaVppQzs7QUFDdEU7RUFBMkMsaUJObFpOLEVNa1pxRDs7QUFDMUY7RUFBa0MsaUJOblpHLEVNbVptQzs7QUFDeEU7RUFBbUMsaUJOcFpFLEVNb1pxQzs7QUFDMUU7RUFBc0MsaUJOclpELEVNcVoyQzs7QUFDaEY7RUFBZ0MsaUJOdFpLLEVNc1orQjs7QUFDcEU7RUFBbUMsaUJOdlpFLEVNdVpxQzs7QUFDMUU7RUFBd0MsaUJOeFpILEVNd1orQzs7QUFDcEY7RUFBaUMsaUJOelpJLEVNeVppQzs7QUFDdEU7RUFBeUMsaUJOMVpKLEVNMFppRDs7QUFDdEY7RUFBNkMsaUJOM1pSLEVNMlp5RDs7QUFDOUY7RUFBOEMsaUJONVpULEVNNFoyRDs7QUFDaEc7RUFBc0MsaUJON1pELEVNNloyQzs7QUFDaEY7RUFBeUMsaUJOOVpKLEVNOFppRDs7QUFDdEY7RUFBMEMsaUJOL1pMLEVNK1ptRDs7QUFDeEY7RUFBNEMsaUJOaGFQLEVNZ2F1RDs7QUFDNUY7RUFBcUMsaUJOamFBLEVNaWF5Qzs7QUFDOUU7RUFBeUMsaUJObGFKLEVNa2FpRDs7QUFDdEY7RUFBNkMsaUJObmFSLEVNbWF5RDs7QUFDOUY7RUFBcUMsaUJOcGFBLEVNb2F5Qzs7QUFDOUU7RUFBb0MsaUJOcmFDLEVNcWF1Qzs7QUFDNUU7RUFBdUMsaUJOdGFGLEVNc2E2Qzs7QUFDbEY7RUFBMkMsaUJOdmFOLEVNdWFxRDs7QUFDMUY7RUFBb0MsaUJOeGFDLEVNd2F1Qzs7QUFDNUU7RUFBa0MsaUJOemFHLEVNeWFtQzs7QUFDeEU7RUFBbUMsaUJOMWFFLEVNMGFxQzs7QUFDMUU7RUFBb0MsaUJOM2FDLEVNMmF1Qzs7QUFDNUU7RUFBa0MsaUJONWFHLEVNNGFtQzs7QUFDeEU7RUFBZ0MsaUJON2FLLEVNNmErQjs7QUFDcEU7RUFBdUMsaUJOOWFGLEVNOGE2Qzs7QUFDbEY7RUFBdUMsaUJOL2FGLEVNK2E2Qzs7QUFDbEY7RUFBK0IsaUJOaGJNLEVNZ2I2Qjs7QUFDbEU7RUFBc0MsaUJOamJELEVNaWIyQzs7QUFDaEY7RUFBaUMsaUJObGJJLEVNa2JpQzs7QUFDdEU7RUFBZ0MsaUJObmJLLEVNbWIrQjs7QUFDcEU7RUFBdUMsaUJOcGJGLEVNb2I2Qzs7QUFDbEY7RUFBbUMsaUJOcmJFLEVNcWJxQzs7QUFDMUU7RUFBdUMsaUJOdGJGLEVNc2I2Qzs7QUFDbEY7RUFBMEMsaUJOdmJMLEVNdWJtRDs7QUFDeEY7RUFBc0MsaUJOeGJELEVNd2IyQzs7QUFDaEY7RUFBbUMsaUJOemJFLEVNeWJxQzs7QUFDMUU7RUFBbUMsaUJOMWJFLEVNMGJxQzs7QUFDMUU7RUFBMEMsaUJOM2JMLEVNMmJtRDs7QUFDeEY7RUFBa0MsaUJONWJHLEVNNGJtQzs7QUFDeEU7RUFBb0MsaUJON2JDLEVNNmJ1Qzs7QUFDNUU7RUFBa0MsaUJOOWJHLEVNOGJtQzs7QUFDeEU7RUFBbUMsaUJOL2JFLEVNK2JxQzs7QUFDMUU7RUFBc0MsaUJOaGNELEVNZ2MyQzs7QUFDaEY7RUFBc0MsaUJOamNELEVNaWMyQzs7QUFDaEY7RUFBc0MsaUJObGNELEVNa2MyQzs7QUFDaEY7RUFBd0MsaUJObmNILEVNbWMrQzs7QUFDcEY7RUFBbUMsaUJOcGNFLEVNb2NxQzs7QUFDMUU7RUFBeUMsaUJOcmNKLEVNcWNpRDs7QUFDdEY7RUFBd0MsaUJOdGNILEVNc2MrQzs7QUFDcEY7RUFBd0MsaUJOdmNILEVNdWMrQzs7QUFDcEY7RUFBMEMsaUJOeGNMLEVNd2NtRDs7QUFDeEY7RUFBK0MsaUJOemNWLEVNeWM2RDs7QUFDbEc7RUFBMEMsaUJOMWNMLEVNMGNtRDs7QUFDeEY7RUFBMkMsaUJOM2NOLEVNMmNxRDs7QUFDMUY7RUFBcUMsaUJONWNBLEVNNGN5Qzs7QUFDOUU7RUFBaUMsaUJON2NJLEVNNmNpQzs7QUFDdEU7RUFBcUMsaUJOOWNBLEVNOGN5Qzs7QUFDOUU7RUFBa0MsaUJOL2NHLEVNK2NtQzs7QUFDeEU7RUFBaUMsaUJOaGRJLEVNZ2RpQzs7QUFDdEU7RUFBcUMsaUJOamRBLEVNaWR5Qzs7QUFDOUU7RUFBK0IsaUJObGRNLEVNa2Q2Qjs7QUFDbEU7RUFBK0IsaUJObmRNLEVNbWQ2Qjs7QUFDbEU7RUFBK0IsaUJOcGRNLEVNb2Q2Qjs7QUFDbEU7RUFBd0MsaUJOcmRILEVNcWQrQzs7QUFDcEY7RUFBK0MsaUJOdGRWLEVNc2Q2RDs7QUFDbEc7RUFBNkMsaUJOdmRSLEVNdWR5RDs7QUFDOUY7RUFBd0MsaUJOeGRILEVNd2QrQzs7QUFDcEY7RUFBdUMsaUJOemRGLEVNeWQ2Qzs7QUFDbEY7RUFBdUMsaUJOMWRGLEVNMGQ2Qzs7QUFDbEY7RUFBNEMsaUJOM2RQLEVNMmR1RDs7QUFDNUY7RUFBNEMsaUJONWRQLEVNNGR1RDs7QUFDNUY7RUFBNkMsaUJON2RSLEVNNmR5RDs7QUFDOUY7RUFBMEMsaUJOOWRMLEVNOGRtRDs7QUFDeEY7RUFBeUMsaUJOL2RKLEVNK2RpRDs7QUFDdEY7RUFBMkMsaUJOaGVOLEVNZ2VxRDs7QUFDMUY7RUFBc0MsaUJOamVELEVNaWUyQzs7QUFDaEY7RUFBMEMsaUJObGVMLEVNa2VtRDs7QUFDeEY7RUFBdUMsaUJObmVGLEVNbWU2Qzs7QUFDbEY7RUFBc0MsaUJOcGVELEVNb2UyQzs7QUFDaEY7RUFBb0MsaUJOcmVDLEVNcWV1Qzs7QUFDNUU7RUFBZ0MsaUJOdGVLLEVNc2UrQjs7QUFDcEU7RUFBb0MsaUJOdmVDLEVNdWV1Qzs7QUFDNUU7RUFBdUMsaUJOeGVGLEVNd2U2Qzs7QUFDbEY7RUFBa0MsaUJOemVHLEVNeWVtQzs7QUFDeEU7RUFBc0MsaUJOMWVELEVNMGUyQzs7QUFDaEY7RUFBb0MsaUJOM2VDLEVNMmV1Qzs7QUFDNUU7RUFBaUMsaUJONWVJLEVNNGVpQzs7QUFDdEU7RUFBMEMsaUJON2VMLEVNNmVtRDs7QUFDeEY7RUFBb0MsaUJOOWVDLEVNOGV1Qzs7QUFDNUU7RUFBd0MsaUJOL2VILEVNK2UrQzs7QUFDcEY7RUFBMEMsaUJOaGZMLEVNZ2ZtRDs7QUFDeEY7RUFBaUMsaUJOamZJLEVNaWZpQzs7QUFDdEU7RUFBa0MsaUJObGZHLEVNa2ZtQzs7QUFDeEU7RUFBcUMsaUJObmZBLEVNbWZ5Qzs7QUFDOUU7RUFBeUMsaUJOcGZKLEVNb2ZpRDs7QUFDdEY7RUFBNEMsaUJOcmZQLEVNcWZ1RDs7QUFDNUY7RUFBbUMsaUJOdGZFLEVNc2ZxQzs7QUFDMUU7RUFBc0MsaUJOdmZELEVNdWYyQzs7QUFDaEY7RUFBMEMsaUJOeGZMLEVNd2ZtRDs7QUFDeEY7RUFBMkMsaUJOemZOLEVNeWZxRDs7QUFDMUY7RUFBNEMsaUJOMWZQLEVNMGZ1RDs7QUFDNUY7RUFBa0MsaUJOM2ZHLEVNMmZtQzs7QUFDeEU7RUFBa0MsaUJONWZHLEVNNGZtQzs7QUFDeEU7RUFBb0MsaUJON2ZDLEVNNmZ1Qzs7QUFDNUU7RUFBcUMsaUJOOWZBLEVNOGZ5Qzs7QUFDOUU7RUFBcUMsaUJOL2ZBLEVNK2Z5Qzs7QUFDOUU7RUFBb0MsaUJOaGdCQyxFTWdnQnVDOztBQUM1RTtFQUF3QyxpQk5qZ0JILEVNaWdCK0M7O0FBQ3BGO0VBQWtDLGlCTmxnQkcsRU1rZ0JtQzs7QUFDeEU7RUFBbUMsaUJObmdCRSxFTW1nQnFDOztBQUMxRTtFQUFpQyxpQk5wZ0JJLEVNb2dCaUM7O0FBQ3RFO0VBQWtDLGlCTnJnQkcsRU1xZ0JtQzs7QUFDeEU7RUFBcUMsaUJOdGdCQSxFTXNnQnlDOztBQUM5RTtFQUFzQyxpQk52Z0JELEVNdWdCMkM7O0FBQ2hGO0VBQW1DLGlCTnhnQkUsRU13Z0JxQzs7QUFDMUU7RUFBcUMsaUJOemdCQSxFTXlnQnlDOztBQUM5RTtFQUF5QyxpQk4xZ0JKLEVNMGdCaUQ7O0FBQ3RGO0VBQWlDLGlCTjNnQkksRU0yZ0JpQzs7QUFDdEU7RUFBd0MsaUJONWdCSCxFTTRnQitDOztBQUNwRjtFQUF3QyxpQk43Z0JILEVNNmdCK0M7O0FBQ3BGO0VBQXNDLGlCTjlnQkQsRU04Z0IyQzs7QUFDaEY7RUFBOEMsaUJOL2dCVCxFTStnQjJEOztBQUNoRztFQUFzQyxpQk5oaEJELEVNZ2hCMkM7O0FBQ2hGO0VBQW9DLGlCTmpoQkMsRU1paEJ1Qzs7QUFDNUU7RUFBbUMsaUJObGhCRSxFTWtoQnFDOztBQUMxRTtFQUFtQyxpQk5uaEJFLEVNbWhCcUM7O0FBQzFFO0VBQXdDLGlCTnBoQkgsRU1vaEIrQzs7QUFDcEY7RUFBMkMsaUJOcmhCTixFTXFoQnFEOztBQUMxRjtFQUFvQyxpQk50aEJDLEVNc2hCdUM7O0FBQzVFO0VBQWtDLGlCTnZoQkcsRU11aEJtQzs7QUFDeEU7RUFBbUMsaUJOeGhCRSxFTXdoQnFDOztBQUMxRTtFQUErQixpQk56aEJNLEVNeWhCNkI7O0FBQ2xFO0VBQXNDLGlCTjFoQkQsRU0waEIyQzs7QUFDaEY7RUFBcUMsaUJOM2hCQSxFTTJoQnlDOztBQUM5RTtFQUFnQyxpQk41aEJLLEVNNGhCK0I7O0FBQ3BFO0VBQXFDLGlCTjdoQkEsRU02aEJ5Qzs7QUFDOUU7RUFBbUMsaUJOOWhCRSxFTThoQnFDOztBQUMxRTtFQUF3QyxpQk4vaEJILEVNK2hCK0M7O0FBQ3BGO0VBQTBDLGlCTmhpQkwsRU1naUJtRDs7QUFDeEY7RUFBbUMsaUJOamlCRSxFTWlpQnFDOztBQUMxRTtFQUFxQyxpQk5saUJBLEVNa2lCeUM7O0FBQzlFO0VBQW1DLGlCTm5pQkUsRU1taUJxQzs7QUFDMUU7RUFBb0MsaUJOcGlCQyxFTW9pQnVDOztBQUM1RTtFQUFtQyxpQk5yaUJFLEVNcWlCcUM7O0FBQzFFO0VBQTBDLGlCTnRpQkwsRU1zaUJtRDs7QUFDeEY7RUFBaUMsaUJOdmlCSSxFTXVpQmlDOztBQUN0RTtFQUFvQyxpQk54aUJDLEVNd2lCdUM7O0FBQzVFO0VBQWtDLGlCTnppQkcsRU15aUJtQzs7QUFDeEU7RUFBaUMsaUJOMWlCSSxFTTBpQmlDOztBQUN0RTtFQUF1QyxpQk4zaUJGLEVNMmlCNkM7O0FBQ2xGO0VBQTJDLGlCTjVpQk4sRU00aUJxRDs7QUFDMUY7RUFBcUMsaUJON2lCQSxFTTZpQnlDOztBQUM5RTtFQUF5QyxpQk45aUJKLEVNOGlCaUQ7O0FBQ3RGO0VBQXNDLGlCTi9pQkQsRU0raUIyQzs7QUFDaEY7RUFBc0MsaUJOaGpCRCxFTWdqQjJDOztBQUNoRjtFQUFpQyxpQk5qakJJLEVNaWpCaUM7O0FBQ3RFO0VBQWlDLGlCTmxqQkksRU1rakJpQzs7QUFDdEU7RUFBcUMsaUJObmpCQSxFTW1qQnlDOztBQUM5RTtFQUF3QyxpQk5wakJILEVNb2pCK0M7O0FBQ3BGO0VBQW1DLGlCTnJqQkUsRU1xakJxQzs7QUFDMUU7RUFBa0MsaUJOdGpCRyxFTXNqQm1DOztBQUN4RTtFQUFzQyxpQk52akJELEVNdWpCMkM7O0FBQ2hGO0VBQWlDLGlCTnhqQkksRU13akJpQzs7QUFDdEU7RUFBcUMsaUJOempCQSxFTXlqQnlDOztBQUM5RTtFQUFvQyxpQk4xakJDLEVNMGpCdUM7O0FBQzVFO0VBQW9DLGlCTjNqQkMsRU0yakJ1Qzs7QUFDNUU7RUFBMkMsaUJONWpCTixFTTRqQnFEOztBQUMxRjtFQUFpQyxpQk43akJJLEVNNmpCaUM7O0FBQ3RFO0VBQXFDLGlCTjlqQkEsRU04akJ5Qzs7QUFDOUU7RUFBc0MsaUJOL2pCRCxFTStqQjJDOztBQUNoRjtFQUEwQyxpQk5oa0JMLEVNZ2tCbUQ7O0FBQ3hGO0VBQWdELGlCTmprQlgsRU1pa0IrRDs7QUFDcEc7RUFBZ0QsaUJObGtCWCxFTWtrQitEOztBQUNwRztFQUFpRCxpQk5ua0JaLEVNbWtCaUU7O0FBQ3RHO0VBQThDLGlCTnBrQlQsRU1va0IyRDs7QUFDaEc7RUFBNEMsaUJOcmtCUCxFTXFrQnVEOztBQUM1RjtFQUE0QyxpQk50a0JQLEVNc2tCdUQ7O0FBQzVGO0VBQTZDLGlCTnZrQlIsRU11a0J5RDs7QUFDOUY7RUFBMEMsaUJOeGtCTCxFTXdrQm1EOztBQUN4RjtFQUF1QyxpQk56a0JGLEVNeWtCNkM7O0FBQ2xGO0VBQXFDLGlCTjFrQkEsRU0wa0J5Qzs7QUFDOUU7RUFBaUMsaUJOM2tCSSxFTTJrQmlDOztBQUN0RTtFQUFvQyxpQk41a0JDLEVNNGtCdUM7O0FBQzVFO0VBQWtDLGlCTjdrQkcsRU02a0JtQzs7QUFDeEU7RUFBbUMsaUJOOWtCRSxFTThrQnFDOztBQUMxRTtFQUFpQyxpQk4va0JJLEVNK2tCaUM7O0FBQ3RFO0VBQWdDLGlCTmhsQkssRU1nbEIrQjs7QUFDcEU7RUFBdUMsaUJOamxCRixFTWlsQjZDOztBQUNsRjtFQUEyQyxpQk5sbEJOLEVNa2xCcUQ7O0FBQzFGO0VBQW9DLGlCTm5sQkMsRU1tbEJ1Qzs7QUFDNUU7RUFBc0MsaUJOcGxCRCxFTW9sQjJDOztBQUNoRjtFQUFpQyxpQk5ybEJJLEVNcWxCaUM7O0FBQ3RFO0VBQXdDLGlCTnRsQkgsRU1zbEIrQzs7QUFDcEY7RUFBd0MsaUJOdmxCSCxFTXVsQitDOztBQUNwRjtFQUEwQyxpQk54bEJMLEVNd2xCbUQ7O0FBQ3hGO0VBQTBDLGlCTnpsQkwsRU15bEJtRDs7QUFDeEY7RUFBbUMsaUJOMWxCRSxFTTBsQnFDOztBQUMxRTtFQUFvQyxpQk4zbEJDLEVNMmxCdUM7O0FBQzVFO0VBQW1DLGlCTjVsQkUsRU00bEJxQzs7QUFDMUU7RUFBcUMsaUJON2xCQSxFTTZsQnlDOztBQUM5RTtFQUFtQyxpQk45bEJFLEVNOGxCcUM7O0FBQzFFO0VBQWtDLGlCTi9sQkcsRU0rbEJtQzs7QUFDeEU7RUFBbUMsaUJOaG1CRSxFTWdtQnFDOztBQUMxRTtFQUFnQyxpQk5qbUJLLEVNaW1CK0I7O0FBQ3BFO0VBQW9DLGlCTmxtQkMsRU1rbUJ1Qzs7QUFDNUU7RUFBc0MsaUJObm1CRCxFTW1tQjJDOztBQUNoRjtFQUF1QyxpQk5wbUJGLEVNb21CNkM7O0FBQ2xGO0VBQTJDLGlCTnJtQk4sRU1xbUJxRDs7QUFDMUY7RUFBNkMsaUJOdG1CUixFTXNtQnlEOztBQUM5RjtFQUFzQyxpQk52bUJELEVNdW1CMkM7O0FBQ2hGO0VBQWtDLGlCTnhtQkcsRU13bUJtQzs7QUFDeEU7RUFBeUMsaUJOem1CSixFTXltQmlEOztBQUN0RjtFQUEwQyxpQk4xbUJMLEVNMG1CbUQ7O0FBQ3hGO0VBQTBDLGlCTjNtQkwsRU0ybUJtRDs7QUFDeEY7RUFBeUMsaUJONW1CSixFTTRtQmlEOztBQUN0RjtFQUFnQyxpQk43bUJLLEVNNm1CK0I7O0FBQ3BFO0VBQXFDLGlCTjltQkEsRU04bUJ5Qzs7QUFDOUU7RUFBbUMsaUJOL21CRSxFTSttQnFDOztBQUMxRTtFQUFtQyxpQk5obkJFLEVNZ25CcUM7O0FBQzFFO0VBQXVDLGlCTmpuQkYsRU1pbkI2Qzs7QUFDbEY7RUFBMkMsaUJObG5CTixFTWtuQnFEOztBQUMxRjtFQUErQyxpQk5ubkJWLEVNbW5CNkQ7O0FBQ2xHO0VBQWlDLGlCTnBuQkksRU1vbkJpQzs7QUFDdEU7RUFBbUMsaUJOcm5CRSxFTXFuQnFDOztBQUMxRTtFQUF1QyxpQk50bkJGLEVNc25CNkM7O0FBQ2xGO0VBQTJDLGlCTnZuQk4sRU11bkJxRDs7QUFDMUY7RUFBaUMsaUJOeG5CSSxFTXduQmlDOztBQUN0RTtFQUF1QyxpQk56bkJGLEVNeW5CNkM7O0FBQ2xGO0VBQTBDLGlCTjFuQkwsRU0wbkJtRDs7QUFDeEY7RUFBa0MsaUJOM25CRyxFTTJuQm1DOztBQUN4RTtFQUFvQyxpQk41bkJDLEVNNG5CdUM7O0FBQzVFO0VBQW1DLGlCTjduQkUsRU02bkJxQzs7QUFDMUU7RUFBc0MsaUJOOW5CRCxFTThuQjJDOztBQUNoRjtFQUE0QyxpQk4vbkJQLEVNK25CdUQ7O0FBQzVGO0VBQWlDLGlCTmhvQkksRU1nb0JpQzs7QUFDdEU7RUFBb0MsaUJOam9CQyxFTWlvQnVDOztBQUM1RTtFQUEwQyxpQk5sb0JMLEVNa29CbUQ7O0FBQ3hGO0VBQWdDLGlCTm5vQkssRU1tb0IrQjs7QUFDcEU7RUFBZ0MsaUJOcG9CSyxFTW9vQitCOztBQUNwRTtFQUF3QyxpQk5yb0JILEVNcW9CK0M7O0FBQ3BGO0VBQXlDLGlCTnRvQkosRU1zb0JpRDs7QUFDdEY7RUFBMkMsaUJOdm9CTixFTXVvQnFEOztBQUMxRjtFQUFvQyxpQk54b0JDLEVNd29CdUM7O0FBQzVFO0VBQTBDLGlCTnpvQkwsRU15b0JtRDs7QUFDeEY7RUFBaUQsaUJOMW9CWixFTTBvQmlFOztBQUN0RztFQUFxQyxpQk4zb0JBLEVNMm9CeUM7O0FBQzlFO0VBQW1DLGlCTjVvQkUsRU00b0JxQzs7QUFDMUU7RUFBa0MsaUJON29CRyxFTTZvQm1DOztBQUN4RTtFQUEwQyxpQk45b0JMLEVNOG9CbUQ7O0FBQ3hGO0VBQWdDLGlCTi9vQkssRU0rb0IrQjs7QUFDcEU7RUFBb0MsaUJOaHBCQyxFTWdwQnVDOztBQUM1RTtFQUFrQyxpQk5qcEJHLEVNaXBCbUM7O0FBQ3hFO0VBQXNDLGlCTmxwQkQsRU1rcEIyQzs7QUFDaEY7RUFBd0MsaUJObnBCSCxFTW1wQitDOztBQUNwRjtFQUFtQyxpQk5wcEJFLEVNb3BCcUM7O0FBQzFFO0VBQW1DLGlCTnJwQkUsRU1xcEJxQzs7QUFDMUU7RUFBdUMsaUJOdHBCRixFTXNwQjZDOztBQUNsRjtFQUF3QyxpQk52cEJILEVNdXBCK0M7O0FBQ3BGO0VBQXNDLGlCTnhwQkQsRU13cEIyQzs7QUFDaEY7RUFBc0MsaUJOenBCRCxFTXlwQjJDOztBQUNoRjtFQUFrQyxpQk4xcEJHLEVNMHBCbUM7O0FBQ3hFO0VBQW9DLGlCTjNwQkMsRU0ycEJ1Qzs7QUFDNUU7RUFBa0MsaUJONXBCRyxFTTRwQm1DOztBQUN4RTtFQUF5QyxpQk43cEJKLEVNNnBCaUQ7O0FBQ3RGO0VBQWdDLGlCTjlwQkssRU04cEIrQjs7QUFDcEU7RUFBbUMsaUJOL3BCRSxFTStwQnFDOztBQUMxRTtFQUFnQyxpQk5ocUJLLEVNZ3FCK0I7O0FBQ3BFO0VBQW9DLGlCTmpxQkMsRU1pcUJ1Qzs7QUFDNUU7RUFBdUMsaUJObHFCRixFTWtxQjZDOztBQUNsRjtFQUFtQyxpQk5ucUJFLEVNbXFCcUM7O0FBQzFFO0VBQXVDLGlCTnBxQkYsRU1vcUI2Qzs7QUFDbEY7RUFBb0MsaUJOcnFCQyxFTXFxQnVDOztBQUM1RTtFQUFvQyxpQk50cUJDLEVNc3FCdUM7O0FBQzVFO0VBQXNDLGlCTnZxQkQsRU11cUIyQzs7QUFDaEY7RUFBd0MsaUJOeHFCSCxFTXdxQitDOztBQUNwRjtFQUE4QyxpQk56cUJULEVNeXFCMkQ7O0FBQ2hHO0VBQWtDLGlCTjFxQkcsRU0wcUJtQzs7QUFDeEU7RUFBd0MsaUJOM3FCSCxFTTJxQitDOztBQUNwRjtFQUF5QyxpQk41cUJKLEVNNHFCaUQ7O0FBQ3RGO0VBQXlDLGlCTjdxQkosRU02cUJpRDs7QUFDdEY7RUFBZ0MsaUJOOXFCSyxFTThxQitCOztBQUNwRTtFQUF1QyxpQk4vcUJGLEVNK3FCNkM7O0FBQ2xGO0VBQTJDLGlCTmhyQk4sRU1nckJxRDs7QUFDMUY7RUFBMEMsaUJOanJCTCxFTWlyQm1EOztBQUN4RjtFQUFrQyxpQk5sckJHLEVNa3JCbUM7O0FBQ3hFO0VBQXNDLGlCTm5yQkQsRU1tckIyQzs7QUFDaEY7RUFBd0MsaUJOcHJCSCxFTW9yQitDOztBQUNwRjtFQUE2QyxpQk5yckJSLEVNcXJCeUQ7O0FBQzlGO0VBQWtDLGlCTnRyQkcsRU1zckJtQzs7QUFDeEU7RUFBc0MsaUJOdnJCRCxFTXVyQjJDOztBQUNoRjtFQUFpQyxpQk54ckJJLEVNd3JCaUM7O0FBQ3RFO0VBQXdDLGlCTnpyQkgsRU15ckIrQzs7QUFDcEY7RUFBd0MsaUJOMXJCSCxFTTByQitDOztBQUNwRjtFQUFpQyxpQk4zckJJLEVNMnJCaUM7O0FBQ3RFO0VBQWlDLGlCTjVyQkksRU00ckJpQzs7QUFDdEU7RUFBd0MsaUJON3JCSCxFTTZyQitDOztBQUNwRjtFQUF5QyxpQk45ckJKLEVNOHJCaUQ7O0FBQ3RGO0VBQXlDLGlCTi9yQkosRU0rckJpRDs7QUFDdEY7RUFBd0MsaUJOaHNCSCxFTWdzQitDOztBQUNwRjtFQUFvQyxpQk5qc0JDLEVNaXNCdUM7O0FBQzVFO0VBQWdDLGlCTmxzQkssRU1rc0IrQjs7QUFDcEU7RUFBcUMsaUJObnNCQSxFTW1zQnlDOztBQUM5RTtFQUF1QyxpQk5wc0JGLEVNb3NCNkM7O0FBQ2xGO0VBQXNDLGlCTnJzQkQsRU1xc0IyQzs7QUFDaEY7RUFBZ0QsaUJOdHNCWCxFTXNzQitEOztBQUNwRztFQUFvRCxpQk52c0JmLEVNdXNCdUU7O0FBQzVHO0VBQWtDLGlCTnhzQkcsRU13c0JtQzs7QUFDeEU7RUFBdUMsaUJOenNCRixFTXlzQjZDOztBQUNsRjtFQUF5QyxpQk4xc0JKLEVNMHNCaUQ7O0FBQ3RGO0VBQW1DLGlCTjNzQkUsRU0yc0JxQzs7QUFDMUU7RUFBeUMsaUJONXNCSixFTTRzQmlEOztBQUN0RjtFQUFtQyxpQk43c0JFLEVNNnNCcUM7O0FBQzFFO0VBQStCLGlCTjlzQk0sRU04c0I2Qjs7QUFDbEU7RUFBbUMsaUJOL3NCRSxFTStzQnFDOztBQUMxRTtFQUFxQyxpQk5odEJBLEVNZ3RCeUM7O0FBQzlFO0VBQTRDLGlCTmp0QlAsRU1pdEJ1RDs7QUFDNUY7RUFBNEMsaUJObHRCUCxFTWt0QnVEOztBQUM1RjtFQUFzQyxpQk5udEJELEVNbXRCMkM7O0FBQ2hGO0VBQXNDLGlCTnB0QkQsRU1vdEIyQzs7QUFDaEY7RUFBa0MsaUJOcnRCRyxFTXF0Qm1DOztBQUN4RTtFQUF1QyxpQk50dEJGLEVNc3RCNkM7O0FBQ2xGO0VBQXdDLGlCTnZ0QkgsRU11dEIrQzs7QUFDcEY7RUFBb0MsaUJOeHRCQyxFTXd0QnVDOztBQUM1RTtFQUFtQyxpQk56dEJFLEVNeXRCcUM7O0FBQzFFO0VBQW9DLGlCTjF0QkMsRU0wdEJ1Qzs7QUFDNUU7RUFBa0MsaUJOM3RCRyxFTTJ0Qm1DOztBQUN4RTtFQUFrQyxpQk41dEJHLEVNNHRCbUM7O0FBQ3hFO0VBQWdELGlCTjd0QlgsRU02dEIrRDs7QUFDcEc7RUFBK0MsaUJOOXRCVixFTTh0QjZEOztBQUNsRztFQUEyQyxpQk4vdEJOLEVNK3RCcUQ7O0FBQzFGO0VBQW9DLGlCTmh1QkMsRU1ndUJ1Qzs7QUFDNUU7RUFBc0MsaUJOanVCRCxFTWl1QjJDOztBQUNoRjtFQUFtQyxpQk5sdUJFLEVNa3VCcUM7O0FBQzFFO0VBQXlDLGlCTm51QkosRU1tdUJpRDs7QUFDdEY7RUFBMEMsaUJOcHVCTCxFTW91Qm1EOztBQUN4RjtFQUFpQyxpQk5ydUJJLEVNcXVCaUM7O0FBQ3RFO0VBQXFDLGlCTnR1QkEsRU1zdUJ5Qzs7QUFDOUU7RUFBdUMsaUJOdnVCRixFTXV1QjZDOztBQUNsRjtFQUFvQyxpQk54dUJDLEVNd3VCdUM7O0FBQzVFO0VBQW1DLGlCTnp1QkUsRU15dUJxQzs7QUFDMUU7RUFBbUMsaUJOMXVCRSxFTTB1QnFDOztBQUMxRTtFQUFxQyxpQk4zdUJBLEVNMnVCeUM7O0FBQzlFO0VBQXlDLGlCTjV1QkosRU00dUJpRDs7QUFDdEY7RUFBdUMsaUJON3VCRixFTTZ1QjZDOztBQUNsRjtFQUFrQyxpQk45dUJHLEVNOHVCbUM7O0FBQ3hFO0VBQXNDLGlCTi91QkQsRU0rdUIyQzs7QUFDaEY7RUFBbUMsaUJOaHZCRSxFTWd2QnFDOztBQUMxRTtFQUFzQyxpQk5qdkJELEVNaXZCMkM7O0FBQ2hGO0VBQW9DLGlCTmx2QkMsRU1rdkJ1Qzs7QUFDNUU7RUFBd0MsaUJObnZCSCxFTW12QitDOztBQUNwRjtFQUFpQyxpQk5wdkJJLEVNb3ZCaUM7O0FBQ3RFO0VBQW1DLGlCTnJ2QkUsRU1xdkJxQzs7QUFDMUU7RUFBdUMsaUJOdHZCRixFTXN2QjZDOztBQUNsRjtFQUFvQyxpQk52dkJDLEVNdXZCdUM7O0FBQzVFO0VBQWdDLGlCTnh2QkssRU13dkIrQjs7QUFDcEU7RUFBdUMsaUJOenZCRixFTXl2QjZDOztBQUNsRjtFQUF1QyxpQk4xdkJGLEVNMHZCNkM7O0FBQ2xGO0VBQXVDLGlCTjN2QkYsRU0ydkI2Qzs7QUFDbEY7RUFBbUMsaUJONXZCRSxFTTR2QnFDOztBQUMxRTtFQUFpQyxpQk43dkJJLEVNNnZCaUM7O0FBQ3RFO0VBQWlDLGlCTjl2QkksRU04dkJpQzs7QUFDdEU7RUFBb0MsaUJOL3ZCQyxFTSt2QnVDOztBQUM1RTtFQUE2QyxpQk5od0JSLEVNZ3dCeUQ7O0FBQzlGO0VBQWdELGlCTmp3QlgsRU1pd0IrRDs7QUFDcEc7RUFBbUMsaUJObHdCRSxFTWt3QnFDOztBQUMxRTtFQUFtQyxpQk5ud0JFLEVNbXdCcUM7O0FBQzFFO0VBQXFDLGlCTnB3QkEsRU1vd0J5Qzs7QUFDOUU7RUFBbUMsaUJOcndCRSxFTXF3QnFDOztBQUMxRTtFQUF5QyxpQk50d0JKLEVNc3dCaUQ7O0FBQ3RGO0VBQXdDLGlCTnZ3QkgsRU11d0IrQzs7QUFDcEY7RUFBd0MsaUJOeHdCSCxFTXd3QitDOztBQUNwRjtFQUFxQyxpQk56d0JBLEVNeXdCeUM7O0FBQzlFO0VBQW1DLGlCTjF3QkUsRU0wd0JxQzs7QUFDMUU7RUFBbUMsaUJOM3dCRSxFTTJ3QnFDOztBQUMxRTtFQUF5QyxpQk41d0JKLEVNNHdCaUQ7O0FBQ3RGO0VBQWtDLGlCTjd3QkcsRU02d0JtQzs7QUFDeEU7RUFBc0MsaUJOOXdCRCxFTTh3QjJDOztBQUNoRjtFQUFzQyxpQk4vd0JELEVNK3dCMkM7O0FBQ2hGO0VBQTZDLGlCTmh4QlIsRU1neEJ5RDs7QUFDOUY7RUFBeUMsaUJOanhCSixFTWl4QmlEOztBQUN0RjtFQUF3QyxpQk5seEJILEVNa3hCK0M7O0FBQ3BGO0VBQW1DLGlCTm54QkUsRU1teEJxQzs7QUFDMUU7RUFBdUMsaUJOcHhCRixFTW94QjZDOztBQUNsRjtFQUF5QyxpQk5yeEJKLEVNcXhCaUQ7O0FBQ3RGO0VBQWlDLGlCTnR4QkksRU1zeEJpQzs7QUFDdEU7RUFBMEMsaUJOdnhCTCxFTXV4Qm1EOztBQUN4RjtFQUEyQyxpQk54eEJOLEVNd3hCcUQ7O0FBQzFGO0VBQXlDLGlCTnp4QkosRU15eEJpRDs7QUFDdEY7RUFBeUMsaUJOMXhCSixFTTB4QmlEOztBQUN0RjtFQUE0QyxpQk4zeEJQLEVNMnhCdUQ7O0FBQzVGO0VBQTBDLGlCTjV4QkwsRU00eEJtRDs7QUFDeEY7RUFBbUMsaUJON3hCRSxFTTZ4QnFDOztBQUMxRTtFQUF3QyxpQk45eEJILEVNOHhCK0M7O0FBQ3BGO0VBQW9DLGlCTi94QkMsRU0reEJ1Qzs7QUFDNUU7RUFBd0MsaUJOaHlCSCxFTWd5QitDOztBQUNwRjtFQUEwQyxpQk5qeUJMLEVNaXlCbUQ7O0FBQ3hGO0VBQXFDLGlCTmx5QkEsRU1reUJ5Qzs7QUFDOUU7RUFBeUMsaUJObnlCSixFTW15QmlEOztBQUN0RjtFQUFtQyxpQk5weUJFLEVNb3lCcUM7O0FBQzFFO0VBQXdDLGlCTnJ5QkgsRU1xeUIrQzs7QUFDcEY7RUFBb0MsaUJOdHlCQyxFTXN5QnVDOztBQUM1RTtFQUFvQyxpQk52eUJDLEVNdXlCdUM7O0FBQzVFO0VBQXFDLGlCTnh5QkEsRU13eUJ5Qzs7QUFDOUU7RUFBa0MsaUJOenlCRyxFTXl5Qm1DOztBQUN4RTtFQUFrQyxpQk4xeUJHLEVNMHlCbUM7O0FBQ3hFO0VBQXVDLGlCTjN5QkYsRU0yeUI2Qzs7QUFDbEY7RUFBc0MsaUJONXlCRCxFTTR5QjJDOztBQUNoRjtFQUE2QyxpQk43eUJSLEVNNnlCeUQ7O0FBQzlGO0VBQXNDLGlCTjl5QkQsRU04eUIyQzs7QUFDaEY7RUFBNkMsaUJOL3lCUixFTSt5QnlEOztBQUM5RjtFQUF1QyxpQk5oekJGLEVNZ3pCNkM7O0FBQ2xGO0VBQWtDLGlCTmp6QkcsRU1pekJtQzs7QUFDeEU7RUFBb0MsaUJObHpCQyxFTWt6QnVDOztBQUM1RTtFQUFxQyxpQk5uekJBLEVNbXpCeUM7O0FBQzlFO0VBQTJDLGlCTnB6Qk4sRU1vekJxRDs7QUFDMUY7RUFBNEMsaUJOcnpCUCxFTXF6QnVEOztBQUM1RjtFQUFzQyxpQk50ekJELEVNc3pCMkM7O0FBQ2hGO0VBQWlDLGlCTnZ6QkksRU11ekJpQzs7QUFDdEU7RUFBNEMsaUJOeHpCUCxFTXd6QnVEOztBQUM1RjtFQUEwQyxpQk56ekJMLEVNeXpCbUQ7O0FBQ3hGO0VBQTZDLGlCTjF6QlIsRU0wekJ5RDs7QUFDOUY7RUFBMkMsaUJOM3pCTixFTTJ6QnFEOztBQUMxRjtFQUFzQyxpQk41ekJELEVNNHpCMkM7O0FBQ2hGO0VBQThDLGlCTjd6QlQsRU02ekIyRDs7QUFDaEc7RUFBNEMsaUJOOXpCUCxFTTh6QnVEOztBQUM1RjtFQUFvQyxpQk4vekJDLEVNK3pCdUM7O0FBQzVFO0VBQXVDLGlCTmgwQkYsRU1nMEI2Qzs7QUFDbEY7RUFBMEMsaUJOajBCTCxFTWkwQm1EOztBQUN4RjtFQUFrQyxpQk5sMEJHLEVNazBCbUM7O0FBQ3hFO0VBQW9DLGlCTm4wQkMsRU1tMEJ1Qzs7QUFDNUU7RUFBb0MsaUJOcDBCQyxFTW8wQnVDOztBQUM1RTtFQUEwQyxpQk5yMEJMLEVNcTBCbUQ7O0FBQ3hGO0VBQW9DLGlCTnQwQkMsRU1zMEJ1Qzs7QUFDNUU7RUFBbUMsaUJOdjBCRSxFTXUwQnFDOztBQUMxRTtFQUF3QyxpQk54MEJILEVNdzBCK0M7O0FBQ3BGO0VBQTJDLGlCTnowQk4sRU15MEJxRDs7QUFDMUY7RUFBMkMsaUJOMTBCTixFTTAwQnFEOztBQUMxRjtFQUFpQyxpQk4zMEJJLEVNMjBCaUM7O0FBQ3RFO0VBQTZDLGlCTjUwQlIsRU00MEJ5RDs7QUFDOUY7RUFBc0MsaUJONzBCRCxFTTYwQjJDOztBQUNoRjtFQUF1QyxpQk45MEJGLEVNODBCNkM7O0FBQ2xGO0VBQWtDLGlCTi8wQkcsRU0rMEJtQzs7QUFDeEU7RUFBeUMsaUJOaDFCSixFTWcxQmlEOztBQUN0RjtFQUF5QyxpQk5qMUJKLEVNaTFCaUQ7O0FBQ3RGO0VBQTBDLGlCTmwxQkwsRU1rMUJtRDs7QUFDeEY7RUFBeUMsaUJObjFCSixFTW0xQmlEOztBQUN0RjtFQUF3QyxpQk5wMUJILEVNbzFCK0M7O0FBQ3BGO0VBQXlDLGlCTnIxQkosRU1xMUJpRDs7QUFDdEY7RUFBd0MsaUJOdDFCSCxFTXMxQitDOztBQUNwRjtFQUFpQyxpQk52MUJJLEVNdTFCaUM7O0FBQ3RFO0VBQXdDLGlCTngxQkgsRU13MUIrQzs7QUFDcEY7RUFBc0MsaUJOejFCRCxFTXkxQjJDOztBQUNoRjtFQUFtQyxpQk4xMUJFLEVNMDFCcUM7O0FBQzFFO0VBQXdDLGlCTjMxQkgsRU0yMUIrQzs7QUFDcEY7RUFBMEMsaUJONTFCTCxFTTQxQm1EOztBQUN4RjtFQUFtQyxpQk43MUJFLEVNNjFCcUM7O0FBQzFFO0VBQXFDLGlCTjkxQkEsRU04MUJ5Qzs7QUFDOUU7RUFBeUMsaUJOLzFCSixFTSsxQmlEOztBQUN0RjtFQUF3QyxpQk5oMkJILEVNZzJCK0M7O0FBQ3BGO0VBQStDLGlCTmoyQlYsRU1pMkI2RDs7QUFDbEc7RUFBc0MsaUJObDJCRCxFTWsyQjJDOztBQUNoRjtFQUFtQyxpQk5uMkJFLEVNbTJCcUM7O0FBQzFFO0VBQXFDLGlCTnAyQkEsRU1vMkJ5Qzs7QUFDOUU7RUFBZ0MsaUJOcjJCSyxFTXEyQitCOztBQUNwRTtFQUF3QyxpQk50MkJILEVNczJCK0M7O0FBQ3BGO0VBQXdDLGlCTnYyQkgsRU11MkIrQzs7QUFDcEY7RUFBbUMsaUJOeDJCRSxFTXcyQnFDOztBQUMxRTtFQUFpQyxpQk56MkJJLEVNeTJCaUM7O0FBQ3RFO0VBQXFDLGlCTjEyQkEsRU0wMkJ5Qzs7QUFDOUU7RUFBb0MsaUJOMzJCQyxFTTIyQnVDOztBQUM1RTtFQUFrQyxpQk41MkJHLEVNNDJCbUM7O0FBQ3hFO0VBQXlDLGlCTjcyQkosRU02MkJpRDs7QUFDdEY7RUFBbUMsaUJOOTJCRSxFTTgyQnFDOztBQUMxRTtFQUF1QyxpQk4vMkJGLEVNKzJCNkM7O0FBQ2xGO0VBQTJDLGlCTmgzQk4sRU1nM0JxRDs7QUFDMUY7RUFBK0MsaUJOajNCVixFTWkzQjZEOztBQUNsRztFQUEwQyxpQk5sM0JMLEVNazNCbUQ7O0FBQ3hGO0VBQW9DLGlCTm4zQkMsRU1tM0J1Qzs7QUFDNUU7RUFBdUMsaUJOcDNCRixFTW8zQjZDOztBQUNsRjtFQUEyQyxpQk5yM0JOLEVNcTNCcUQ7O0FBQzFGO0VBQWdDLGlCTnQzQkssRU1zM0IrQjs7QUFDcEU7RUFBaUMsaUJOdjNCSSxFTXUzQmlDOztBQUN0RTtFQUFrQyxpQk54M0JHLEVNdzNCbUM7O0FBQ3hFO0VBQWlDLGlCTnozQkksRU15M0JpQzs7QUFDdEU7RUFBcUMsaUJOMTNCQSxFTTAzQnlDOztBQUM5RTtFQUEyQyxpQk4zM0JOLEVNMjNCcUQ7O0FBQzFGO0VBQTBDLGlCTjUzQkwsRU00M0JtRDs7QUFDeEY7RUFBd0MsaUJONzNCSCxFTTYzQitDOztBQUNwRjtFQUFxQyxpQk45M0JBLEVNODNCeUM7O0FBQzlFO0VBQXdDLGlCTi8zQkgsRU0rM0IrQzs7QUFDcEY7RUFBdUMsaUJOaDRCRixFTWc0QjZDOztBQUNsRjtFQUErQixpQk5qNEJNLEVNaTRCNkI7O0FBQ2xFO0VBQXFDLGlCTmw0QkEsRU1rNEJ5Qzs7QUFDOUU7RUFBb0MsaUJObjRCQyxFTW00QnVDOztBQUM1RTtFQUFzQyxpQk5wNEJELEVNbzRCMkM7O0FBQ2hGO0VBQXdDLGlCTnI0QkgsRU1xNEIrQzs7QUFDcEY7RUFBOEMsaUJOdDRCVCxFTXM0QjJEOztBQUNoRztFQUE2QyxpQk52NEJSLEVNdTRCeUQ7O0FBQzlGO0VBQTZDLGlCTng0QlIsRU13NEJ5RDs7QUFDOUY7RUFBZ0QsaUJOejRCWCxFTXk0QitEOztBQUNwRztFQUF1RCxpQk4xNEJsQixFTTA0QjZFOztBQUNsSDtFQUF3QyxpQk4zNEJILEVNMjRCK0M7O0FBQ3BGO0VBQXNDLGlCTjU0QkQsRU00NEIyQzs7QUFDaEY7RUFBc0MsaUJONzRCRCxFTTY0QjJDOztBQUNoRjtFQUFtQyxpQk45NEJFLEVNODRCcUM7O0FBQzFFO0VBQXVDLGlCTi80QkYsRU0rNEI2Qzs7QUFDbEY7RUFBa0MsaUJOaDVCRyxFTWc1Qm1DOztBQUN4RTtFQUF5QyxpQk5qNUJKLEVNaTVCaUQ7O0FBQ3RGO0VBQTBDLGlCTmw1QkwsRU1rNUJtRDs7QUFDeEY7RUFBMEMsaUJObjVCTCxFTW01Qm1EOztBQUN4RjtFQUF5QyxpQk5wNUJKLEVNbzVCaUQ7O0FBQ3RGO0VBQWlDLGlCTnI1QkksRU1xNUJpQzs7QUFDdEU7RUFBdUMsaUJOdDVCRixFTXM1QjZDOztBQUNsRjtFQUFzQyxpQk52NUJELEVNdTVCMkM7O0FBQ2hGO0VBQXNDLGlCTng1QkQsRU13NUIyQzs7QUFDaEY7RUFBa0MsaUJOejVCRyxFTXk1Qm1DOztBQUN4RTtFQUF3QyxpQk4xNUJILEVNMDVCK0M7O0FBQ3BGO0VBQTRDLGlCTjM1QlAsRU0yNUJ1RDs7QUFDNUY7RUFBa0MsaUJONTVCRyxFTTQ1Qm1DOztBQUN4RTtFQUFzQyxpQk43NUJELEVNNjVCMkM7O0FBQ2hGO0VBQWlDLGlCTjk1QkksRU04NUJpQzs7QUFDdEU7RUFBcUMsaUJOLzVCQSxFTSs1QnlDOztBQUM5RTtFQUFtQyxpQk5oNkJFLEVNZzZCcUM7O0FBQzFFO0VBQXFDLGlCTmo2QkEsRU1pNkJ5Qzs7QUFDOUU7RUFBd0MsaUJObDZCSCxFTWs2QitDOztBQUNwRjtFQUFtQyxpQk5uNkJFLEVNbTZCcUM7O0FBQzFFO0VBQXVDLGlCTnA2QkYsRU1vNkI2Qzs7QUFDbEY7RUFBa0MsaUJOcjZCRyxFTXE2Qm1DOztBQUN4RTtFQUFnQyxpQk50NkJLLEVNczZCK0I7O0FBQ3BFO0VBQW1DLGlCTnY2QkUsRU11NkJxQzs7QUFDMUU7RUFBMEMsaUJOeDZCTCxFTXc2Qm1EOztBQUN4RjtFQUErQixpQk56NkJNLEVNeTZCNkI7O0FBQ2xFO0VBQXFDLGlCTjE2QkEsRU0wNkJ5Qzs7QUFDOUU7RUFBbUMsaUJOMzZCRSxFTTI2QnFDOztBQUMxRTtFQUFvQyxpQk41NkJDLEVNNDZCdUM7O0FBQzVFO0VBQTJDLGlCTjc2Qk4sRU02NkJxRDs7QUFDMUY7RUFBa0MsaUJOOTZCRyxFTTg2Qm1DOztBQUN4RTtFQUFpQyxpQk4vNkJJLEVNKzZCaUM7O0FBQ3RFO0VBQWtDLGlCTmg3QkcsRU1nN0JtQzs7QUFDeEU7RUFBcUMsaUJOajdCQSxFTWk3QnlDOztBQUM5RTtFQUFzQyxpQk5sN0JELEVNazdCMkM7O0FBQ2hGO0VBQWlDLGlCTm43QkksRU1tN0JpQzs7QUFDdEU7RUFBcUMsaUJOcDdCQSxFTW83QnlDOztBQUM5RTtFQUF3QyxpQk5yN0JILEVNcTdCK0M7O0FBQ3BGO0VBQTZDLGlCTnQ3QlIsRU1zN0J5RDs7QUFDOUY7RUFBdUMsaUJOdjdCRixFTXU3QjZDOztBQUNsRjtFQUFtQyxpQk54N0JFLEVNdzdCcUM7O0FBQzFFO0VBQW1DLGlCTno3QkUsRU15N0JxQzs7QUFDMUU7RUFBdUMsaUJOMTdCRixFTTA3QjZDOztBQUNsRjtFQUFvQyxpQk4zN0JDLEVNMjdCdUM7O0FBQzVFO0VBQW1DLGlCTjU3QkUsRU00N0JxQzs7QUFDMUU7RUFBZ0MsaUJONzdCSyxFTTY3QitCOztBQUNwRTtFQUF1QyxpQk45N0JGLEVNODdCNkM7O0FBQ2xGO0VBQXVDLGlCTi83QkYsRU0rN0I2Qzs7QUFDbEY7RUFBaUMsaUJOaDhCSSxFTWc4QmlDOztBQUN0RTtFQUFxQyxpQk5qOEJBLEVNaThCeUM7O0FBQzlFO0VBQXdDLGlCTmw4QkgsRU1rOEIrQzs7QUFDcEY7RUFBb0MsaUJObjhCQyxFTW04QnVDOztBQUM1RTtFQUFzQyxpQk5wOEJELEVNbzhCMkM7O0FBQ2hGO0VBQXdDLGlCTnI4QkgsRU1xOEIrQzs7QUFDcEY7RUFBdUMsaUJOdDhCRixFTXM4QjZDOztBQUNsRjtFQUFrQyxpQk52OEJHLEVNdThCbUM7O0FBQ3hFO0VBQXFDLGlCTng4QkEsRU13OEJ5Qzs7QUFDOUU7RUFBeUMsaUJOejhCSixFTXk4QmlEOztBQUN0RjtFQUEwQyxpQk4xOEJMLEVNMDhCbUQ7O0FBQ3hGO0VBQTBDLGlCTjM4QkwsRU0yOEJtRDs7QUFDeEY7RUFBcUMsaUJONThCQSxFTTQ4QnlDOztBQUM5RTtFQUF5QyxpQk43OEJKLEVNNjhCaUQ7O0FBQ3RGO0VBQW1DLGlCTjk4QkUsRU04OEJxQzs7QUFDMUU7RUFBa0MsaUJOLzhCRyxFTSs4Qm1DOztBQUN4RTtFQUF5QyxpQk5oOUJKLEVNZzlCaUQ7O0FBQ3RGO0VBQXVDLGlCTmo5QkYsRU1pOUI2Qzs7QUFDbEY7RUFBb0MsaUJObDlCQyxFTWs5QnVDOztBQUM1RTtFQUFtQyxpQk5uOUJFLEVNbTlCcUM7O0FBQzFFO0VBQTBDLGlCTnA5QkwsRU1vOUJtRDs7QUFDeEY7RUFBaUMsaUJOcjlCSSxFTXE5QmlDOztBQUN0RTtFQUFrQyxpQk50OUJHLEVNczlCbUM7O0FBQ3hFO0VBQWtDLGlCTnY5QkcsRU11OUJtQzs7QUFDeEU7RUFBa0MsaUJOeDlCRyxFTXc5Qm1DOztBQUN4RTtFQUFrQyxpQk56OUJHLEVNeTlCbUM7O0FBQ3hFO0VBQXlDLGlCTjE5QkosRU0wOUJpRDs7QUFDdEY7RUFBb0MsaUJOMzlCQyxFTTI5QnVDOztBQUM1RTtFQUFpQyxpQk41OUJJLEVNNDlCaUM7O0FBQ3RFO0VBQStCLGlCTjc5Qk0sRU02OUI2Qjs7QUFDbEU7RUFBZ0MsaUJOOTlCSyxFTTg5QitCOztBQUNwRTtFQUE0QyxpQk4vOUJQLEVNKzlCdUQ7O0FBQzVGO0VBQXdDLGlCTmgrQkgsRU1nK0IrQzs7QUFDcEY7RUFBd0MsaUJOaitCSCxFTWkrQitDOztBQUNwRjtFQUF1QyxpQk5sK0JGLEVNaytCNkM7O0FBQ2xGO0VBQXNDLGlCTm4rQkQsRU1tK0IyQzs7QUFDaEY7RUFBa0MsaUJOcCtCRyxFTW8rQm1DOztBQUN4RTtFQUFzQyxpQk5yK0JELEVNcStCMkM7O0FBQ2hGO0VBQTBDLGlCTnQrQkwsRU1zK0JtRDs7QUFDeEY7RUFBa0MsaUJOditCRyxFTXUrQm1DOztBQUN4RTtFQUFrQyxpQk54K0JHLEVNdytCbUM7O0FBQ3hFO0VBQW1DLGlCTnorQkUsRU15K0JxQzs7QUFDMUU7RUFBbUMsaUJOMStCRSxFTTArQnFDOztBQUMxRTtFQUFxQyxpQk4zK0JBLEVNMitCeUM7O0FBQzlFO0VBQTRDLGlCTjUrQlAsRU00K0J1RDs7QUFDNUY7RUFBdUMsaUJONytCRixFTTYrQjZDOztBQUNsRjtFQUFvQyxpQk45K0JDLEVNOCtCdUM7O0FBQzVFO0VBQWtDLGlCTi8rQkcsRU0rK0JtQzs7QUFDeEU7RUFBaUMsaUJOaC9CSSxFTWcvQmlDOztBQUN0RTtFQUF3QyxpQk5qL0JILEVNaS9CK0M7O0FBQ3BGO0VBQW1DLGlCTmwvQkUsRU1rL0JxQzs7QUFDMUU7RUFBdUMsaUJObi9CRixFTW0vQjZDOztBQUNsRjtFQUF5QyxpQk5wL0JKLEVNby9CaUQ7O0FBQ3RGO0VBQTRDLGlCTnIvQlAsRU1xL0J1RDs7QUFDNUY7RUFBNEMsaUJOdC9CUCxFTXMvQnVEOztBQUM1RjtFQUEyQyxpQk52L0JOLEVNdS9CcUQ7O0FBQzFGO0VBQW9DLGlCTngvQkMsRU13L0J1Qzs7QUFDNUU7RUFBcUMsaUJOei9CQSxFTXkvQnlDOztBQUM5RTtFQUFzQyxpQk4xL0JELEVNMC9CMkM7O0FBQ2hGO0VBQTZDLGlCTjMvQlIsRU0yL0J5RDs7QUFDOUY7RUFBdUMsaUJONS9CRixFTTQvQjZDOztBQUNsRjtFQUF1QyxpQk43L0JGLEVNNi9CNkM7O0FBQ2xGO0VBQW9DLGlC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QWtCO01BQ2xCLFdBQVU7TUFDVixPQUFNO01BQ04sU0FBUTtNQUNSLGtCQUFpQjtNQUNqQixpQ0FBZ0M7TUFDaEMsWURsUUs7TUNtUUwsMEJEdFFhO01DdVFiLGlDQUFnQyxFQUNqQztFQUdIO0lBQ0UsV0FBVTtJQUNWLGVBQWM7SUFDZCxnQkFBZTtJQUNmLE9BQU07SUFDTixRQUFPO0lBQ1AsU0FBUTtJQUNSLFVBQVM7SUFDVCwyQ0FBMkMsRUFDNUM7RUFFRDtJQUNFLFFBQU8sRUFDUixFQUFBIiwiZmlsZSI6ImNzcy9kb2MuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vcm1hbGl6ZS5jc3MgdjguMC4wIHwgTUlUIExpY2Vuc2UgfCBnaXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcyAqL1xuXG4vKiBEb2N1bWVudFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLyoqXG4gKiAxLiBDb3JyZWN0IHRoZSBsaW5lIGhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXG4gKiAyLiBQcmV2ZW50IGFkanVzdG1lbnRzIG9mIGZvbnQgc2l6ZSBhZnRlciBvcmllbnRhdGlvbiBjaGFuZ2VzIGluIGlPUy5cbiAqL1xuXG5odG1sIHtcbiAgbGluZS1oZWlnaHQ6IDEuMTU7IC8qIDEgKi9cbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlOyAvKiAyICovXG59XG5cbi8qIFNlY3Rpb25zXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbWFyZ2luIGluIGFsbCBicm93c2Vycy5cbiAqL1xuXG5ib2R5IHtcbiAgbWFyZ2luOiAwO1xufVxuXG4vKipcbiAqIENvcnJlY3QgdGhlIGZvbnQgc2l6ZSBhbmQgbWFyZ2luIG9uIGBoMWAgZWxlbWVudHMgd2l0aGluIGBzZWN0aW9uYCBhbmRcbiAqIGBhcnRpY2xlYCBjb250ZXh0cyBpbiBDaHJvbWUsIEZpcmVmb3gsIGFuZCBTYWZhcmkuXG4gKi9cblxuaDEge1xuICBmb250LXNpemU6IDJlbTtcbiAgbWFyZ2luOiAwLjY3ZW0gMDtcbn1cblxuLyogR3JvdXBpbmcgY29udGVudFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLyoqXG4gKiAxLiBBZGQgdGhlIGNvcnJlY3QgYm94IHNpemluZyBpbiBGaXJlZm94LlxuICogMi4gU2hvdyB0aGUgb3ZlcmZsb3cgaW4gRWRnZSBhbmQgSUUuXG4gKi9cblxuaHIge1xuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDsgLyogMSAqL1xuICBoZWlnaHQ6IDA7IC8qIDEgKi9cbiAgb3ZlcmZsb3c6IHZpc2libGU7IC8qIDIgKi9cbn1cblxuLyoqXG4gKiAxLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBhbmQgc2NhbGluZyBvZiBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxuICogMi4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxuICovXG5cbnByZSB7XG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2UsIG1vbm9zcGFjZTsgLyogMSAqL1xuICBmb250LXNpemU6IDFlbTsgLyogMiAqL1xufVxuXG4vKiBUZXh0LWxldmVsIHNlbWFudGljc1xuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdyYXkgYmFja2dyb3VuZCBvbiBhY3RpdmUgbGlua3MgaW4gSUUgMTAuXG4gKi9cblxuYSB7XG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xufVxuXG4vKipcbiAqIDEuIFJlbW92ZSB0aGUgYm90dG9tIGJvcmRlciBpbiBDaHJvbWUgNTctXG4gKiAyLiBBZGQgdGhlIGNvcnJlY3QgdGV4dCBkZWNvcmF0aW9uIGluIENocm9tZSwgRWRnZSwgSUUsIE9wZXJhLCBhbmQgU2FmYXJpLlxuICovXG5cbmFiYnJbdGl0bGVdIHtcbiAgYm9yZGVyLWJvdHRvbTogbm9uZTsgLyogMSAqL1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsgLyogMiAqL1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7IC8qIDIgKi9cbn1cblxuLyoqXG4gKiBBZGQgdGhlIGNvcnJlY3QgZm9udCB3ZWlnaHQgaW4gQ2hyb21lLCBFZGdlLCBhbmQgU2FmYXJpLlxuICovXG5cbmIsXG5zdHJvbmcge1xuICBmb250LXdlaWdodDogYm9sZGVyO1xufVxuXG4vKipcbiAqIDEuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIGFuZCBzY2FsaW5nIG9mIGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXG4gKiAyLiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXG4gKi9cblxuY29kZSxcbmtiZCxcbnNhbXAge1xuICBmb250LWZhbWlseTogbW9ub3NwYWNlLCBtb25vc3BhY2U7IC8qIDEgKi9cbiAgZm9udC1zaXplOiAxZW07IC8qIDIgKi9cbn1cblxuLyoqXG4gKiBBZGQgdGhlIGNvcnJlY3QgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cbiAqL1xuXG5zbWFsbCB7XG4gIGZvbnQtc2l6ZTogODAlO1xufVxuXG4vKipcbiAqIFByZXZlbnQgYHN1YmAgYW5kIGBzdXBgIGVsZW1lbnRzIGZyb20gYWZmZWN0aW5nIHRoZSBsaW5lIGhlaWdodCBpblxuICogYWxsIGJyb3dzZXJzLlxuICovXG5cbnN1YixcbnN1cCB7XG4gIGZvbnQtc2l6ZTogNzUlO1xuICBsaW5lLWhlaWdodDogMDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XG59XG5cbnN1YiB7XG4gIGJvdHRvbTogLTAuMjVlbTtcbn1cblxuc3VwIHtcbiAgdG9wOiAtMC41ZW07XG59XG5cbi8qIEVtYmVkZGVkIGNvbnRlbnRcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbi8qKlxuICogUmVtb3ZlIHRoZSBib3JkZXIgb24gaW1hZ2VzIGluc2lkZSBsaW5rcyBpbiBJRSAxMC5cbiAqL1xuXG5pbWcge1xuICBib3JkZXItc3R5bGU6IG5vbmU7XG59XG5cbi8qIEZvcm1zXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4vKipcbiAqIDEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzLlxuICogMi4gUmVtb3ZlIHRoZSBtYXJnaW4gaW4gRmlyZWZveCBhbmQgU2FmYXJpLlxuICovXG5cbmJ1dHRvbixcbmlucHV0LFxub3B0Z3JvdXAsXG5zZWxlY3QsXG50ZXh0YXJlYSB7XG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0OyAvKiAxICovXG4gIGZvbnQtc2l6ZTogMTAwJTsgLyogMSAqL1xuICBsaW5lLWhlaWdodDogMS4xNTsgLyogMSAqL1xuICBtYXJnaW46IDA7IC8qIDIgKi9cbn1cblxuLyoqXG4gKiBTaG93IHRoZSBvdmVyZmxvdyBpbiBJRS5cbiAqIDEuIFNob3cgdGhlIG92ZXJmbG93IGluIEVkZ2UuXG4gKi9cblxuYnV0dG9uLFxuaW5wdXQgeyAvKiAxICovXG4gIG92ZXJmbG93OiB2aXNpYmxlO1xufVxuXG4vKipcbiAqIFJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRWRnZSwgRmlyZWZveCwgYW5kIElFLlxuICogMS4gUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBGaXJlZm94LlxuICovXG5cbmJ1dHRvbixcbnNlbGVjdCB7IC8qIDEgKi9cbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XG59XG5cbi8qKlxuICogQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cbiAqL1xuXG5idXR0b24sXG5bdHlwZT1cImJ1dHRvblwiXSxcblt0eXBlPVwicmVzZXRcIl0sXG5bdHlwZT1cInN1Ym1pdFwiXSB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xufVxuXG4vKipcbiAqIFJlbW92ZSB0aGUgaW5uZXIgYm9yZGVyIGFuZCBwYWRkaW5nIGluIEZpcmVmb3guXG4gKi9cblxuYnV0dG9uOjotbW96LWZvY3VzLWlubmVyLFxuW3R5cGU9XCJidXR0b25cIl06Oi1tb3otZm9jdXMtaW5uZXIsXG5bdHlwZT1cInJlc2V0XCJdOjotbW96LWZvY3VzLWlubmVyLFxuW3R5cGU9XCJzdWJtaXRcIl06Oi1tb3otZm9jdXMtaW5uZXIge1xuICBib3JkZXItc3R5bGU6IG5vbmU7XG4gIHBhZGRpbmc6IDA7XG59XG5cbi8qKlxuICogUmVzdG9yZSB0aGUgZm9jdXMgc3R5bGVzIHVuc2V0IGJ5IHRoZSBwcmV2aW91cyBydWxlLlxuICovXG5cbmJ1dHRvbjotbW96LWZvY3VzcmluZyxcblt0eXBlPVwiYnV0dG9uXCJdOi1tb3otZm9jdXNyaW5nLFxuW3R5cGU9XCJyZXNldFwiXTotbW96LWZvY3VzcmluZyxcblt0eXBlPVwic3VibWl0XCJdOi1tb3otZm9jdXNyaW5nIHtcbiAgb3V0bGluZTogMXB4IGRvdHRlZCBCdXR0b25UZXh0O1xufVxuXG4vKipcbiAqIENvcnJlY3QgdGhlIHBhZGRpbmcgaW4gRmlyZWZveC5cbiAqL1xuXG5maWVsZHNldCB7XG4gIHBhZGRpbmc6IDAuMzVlbSAwLjc1ZW0gMC42MjVlbTtcbn1cblxuLyoqXG4gKiAxLiBDb3JyZWN0IHRoZSB0ZXh0IHdyYXBwaW5nIGluIEVkZ2UgYW5kIElFLlxuICogMi4gQ29ycmVjdCB0aGUgY29sb3IgaW5oZXJpdGFuY2UgZnJvbSBgZmllbGRzZXRgIGVsZW1lbnRzIGluIElFLlxuICogMy4gUmVtb3ZlIHRoZSBwYWRkaW5nIHNvIGRldmVsb3BlcnMgYXJlIG5vdCBjYXVnaHQgb3V0IHdoZW4gdGhleSB6ZXJvIG91dFxuICogICAgYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBhbGwgYnJvd3NlcnMuXG4gKi9cblxubGVnZW5kIHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgLyogMSAqL1xuICBjb2xvcjogaW5oZXJpdDsgLyogMiAqL1xuICBkaXNwbGF5OiB0YWJsZTsgLyogMSAqL1xuICBtYXgtd2lkdGg6IDEwMCU7IC8qIDEgKi9cbiAgcGFkZGluZzogMDsgLyogMyAqL1xuICB3aGl0ZS1zcGFjZTogbm9ybWFsOyAvKiAxICovXG59XG5cbi8qKlxuICogQWRkIHRoZSBjb3JyZWN0IHZlcnRpY2FsIGFsaWdubWVudCBpbiBDaHJvbWUsIEZpcmVmb3gsIGFuZCBPcGVyYS5cbiAqL1xuXG5wcm9ncmVzcyB7XG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGRlZmF1bHQgdmVydGljYWwgc2Nyb2xsYmFyIGluIElFIDEwKy5cbiAqL1xuXG50ZXh0YXJlYSB7XG4gIG92ZXJmbG93OiBhdXRvO1xufVxuXG4vKipcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBib3ggc2l6aW5nIGluIElFIDEwLlxuICogMi4gUmVtb3ZlIHRoZSBwYWRkaW5nIGluIElFIDEwLlxuICovXG5cblt0eXBlPVwiY2hlY2tib3hcIl0sXG5bdHlwZT1cInJhZGlvXCJdIHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgLyogMSAqL1xuICBwYWRkaW5nOiAwOyAvKiAyICovXG59XG5cbi8qKlxuICogQ29ycmVjdCB0aGUgY3Vyc29yIHN0eWxlIG9mIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGJ1dHRvbnMgaW4gQ2hyb21lLlxuICovXG5cblt0eXBlPVwibnVtYmVyXCJdOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxuW3R5cGU9XCJudW1iZXJcIl06Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xuICBoZWlnaHQ6IGF1dG87XG59XG5cbi8qKlxuICogMS4gQ29ycmVjdCB0aGUgb2RkIGFwcGVhcmFuY2UgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXG4gKiAyLiBDb3JyZWN0IHRoZSBvdXRsaW5lIHN0eWxlIGluIFNhZmFyaS5cbiAqL1xuXG5bdHlwZT1cInNlYXJjaFwiXSB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogdGV4dGZpZWxkOyAvKiAxICovXG4gIG91dGxpbmUtb2Zmc2V0OiAtMnB4OyAvKiAyICovXG59XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBpbm5lciBwYWRkaW5nIGluIENocm9tZSBhbmQgU2FmYXJpIG9uIG1hY09TLlxuICovXG5cblt0eXBlPVwic2VhcmNoXCJdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xufVxuXG4vKipcbiAqIDEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXG4gKiAyLiBDaGFuZ2UgZm9udCBwcm9wZXJ0aWVzIHRvIGBpbmhlcml0YCBpbiBTYWZhcmkuXG4gKi9cblxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXG4gIGZvbnQ6IGluaGVyaXQ7IC8qIDIgKi9cbn1cblxuLyogSW50ZXJhY3RpdmVcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbi8qXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBFZGdlLCBJRSAxMCssIGFuZCBGaXJlZm94LlxuICovXG5cbmRldGFpbHMge1xuICBkaXNwbGF5OiBibG9jaztcbn1cblxuLypcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIGFsbCBicm93c2Vycy5cbiAqL1xuXG5zdW1tYXJ5IHtcbiAgZGlzcGxheTogbGlzdC1pdGVtO1xufVxuXG4vKiBNaXNjXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4vKipcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFIDEwKy5cbiAqL1xuXG50ZW1wbGF0ZSB7XG4gIGRpc3BsYXk6IG5vbmU7XG59XG5cbi8qKlxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgMTAuXG4gKi9cblxuW2hpZGRlbl0ge1xuICBkaXNwbGF5OiBub25lO1xufVxuIiwiLyohIG5vcm1hbGl6ZS5jc3MgdjguMC4wIHwgTUlUIExpY2Vuc2UgfCBnaXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcyAqL1xuLyogRG9jdW1lbnRcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIDEuIENvcnJlY3QgdGhlIGxpbmUgaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cbiAqIDIuIFByZXZlbnQgYWRqdXN0bWVudHMgb2YgZm9udCBzaXplIGFmdGVyIG9yaWVudGF0aW9uIGNoYW5nZXMgaW4gaU9TLlxuICovXG5odG1sIHtcbiAgbGluZS1oZWlnaHQ6IDEuMTU7XG4gIC8qIDEgKi9cbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xuICAvKiAyICovIH1cblxuLyogU2VjdGlvbnNcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIFJlbW92ZSB0aGUgbWFyZ2luIGluIGFsbCBicm93c2Vycy5cbiAqL1xuYm9keSB7XG4gIG1hcmdpbjogMDsgfVxuXG4vKipcbiAqIENvcnJlY3QgdGhlIGZvbnQgc2l6ZSBhbmQgbWFyZ2luIG9uIGBoMWAgZWxlbWVudHMgd2l0aGluIGBzZWN0aW9uYCBhbmRcbiAqIGBhcnRpY2xlYCBjb250ZXh0cyBpbiBDaHJvbWUsIEZpcmVmb3gsIGFuZCBTYWZhcmkuXG4gKi9cbmgxIHtcbiAgZm9udC1zaXplOiAyZW07XG4gIG1hcmdpbjogMC42N2VtIDA7IH1cblxuLyogR3JvdXBpbmcgY29udGVudFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qKlxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGJveCBzaXppbmcgaW4gRmlyZWZveC5cbiAqIDIuIFNob3cgdGhlIG92ZXJmbG93IGluIEVkZ2UgYW5kIElFLlxuICovXG5ociB7XG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuICAvKiAxICovXG4gIGhlaWdodDogMDtcbiAgLyogMSAqL1xuICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgLyogMiAqLyB9XG5cbi8qKlxuICogMS4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2UgYW5kIHNjYWxpbmcgb2YgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cbiAqIDIuIENvcnJlY3QgdGhlIG9kZCBgZW1gIGZvbnQgc2l6aW5nIGluIGFsbCBicm93c2Vycy5cbiAqL1xucHJlIHtcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZSwgbW9ub3NwYWNlO1xuICAvKiAxICovXG4gIGZvbnQtc2l6ZTogMWVtO1xuICAvKiAyICovIH1cblxuLyogVGV4dC1sZXZlbCBzZW1hbnRpY3NcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIFJlbW92ZSB0aGUgZ3JheSBiYWNrZ3JvdW5kIG9uIGFjdGl2ZSBsaW5rcyBpbiBJRSAxMC5cbiAqL1xuYSB7XG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyB9XG5cbi8qKlxuICogMS4gUmVtb3ZlIHRoZSBib3R0b20gYm9yZGVyIGluIENocm9tZSA1Ny1cbiAqIDIuIEFkZCB0aGUgY29ycmVjdCB0ZXh0IGRlY29yYXRpb24gaW4gQ2hyb21lLCBFZGdlLCBJRSwgT3BlcmEsIGFuZCBTYWZhcmkuXG4gKi9cbmFiYnJbdGl0bGVdIHtcbiAgYm9yZGVyLWJvdHRvbTogbm9uZTtcbiAgLyogMSAqL1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgLyogMiAqL1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XG4gIC8qIDIgKi8gfVxuXG4vKipcbiAqIEFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXG4gKi9cbmIsXG5zdHJvbmcge1xuICBmb250LXdlaWdodDogYm9sZGVyOyB9XG5cbi8qKlxuICogMS4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2UgYW5kIHNjYWxpbmcgb2YgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cbiAqIDIuIENvcnJlY3QgdGhlIG9kZCBgZW1gIGZvbnQgc2l6aW5nIGluIGFsbCBicm93c2Vycy5cbiAqL1xuY29kZSxcbmtiZCxcbnNhbXAge1xuICBmb250LWZhbWlseTogbW9ub3NwYWNlLCBtb25vc3BhY2U7XG4gIC8qIDEgKi9cbiAgZm9udC1zaXplOiAxZW07XG4gIC8qIDIgKi8gfVxuXG4vKipcbiAqIEFkZCB0aGUgY29ycmVjdCBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxuICovXG5zbWFsbCB7XG4gIGZvbnQtc2l6ZTogODAlOyB9XG5cbi8qKlxuICogUHJldmVudCBgc3ViYCBhbmQgYHN1cGAgZWxlbWVudHMgZnJvbSBhZmZlY3RpbmcgdGhlIGxpbmUgaGVpZ2h0IGluXG4gKiBhbGwgYnJvd3NlcnMuXG4gKi9cbnN1YixcbnN1cCB7XG4gIGZvbnQtc2l6ZTogNzUlO1xuICBsaW5lLWhlaWdodDogMDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7IH1cblxuc3ViIHtcbiAgYm90dG9tOiAtMC4yNWVtOyB9XG5cbnN1cCB7XG4gIHRvcDogLTAuNWVtOyB9XG5cbi8qIEVtYmVkZGVkIGNvbnRlbnRcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIFJlbW92ZSB0aGUgYm9yZGVyIG9uIGltYWdlcyBpbnNpZGUgbGlua3MgaW4gSUUgMTAuXG4gKi9cbmltZyB7XG4gIGJvcmRlci1zdHlsZTogbm9uZTsgfVxuXG4vKiBGb3Jtc1xuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qKlxuICogMS4gQ2hhbmdlIHRoZSBmb250IHN0eWxlcyBpbiBhbGwgYnJvd3NlcnMuXG4gKiAyLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBGaXJlZm94IGFuZCBTYWZhcmkuXG4gKi9cbmJ1dHRvbixcbmlucHV0LFxub3B0Z3JvdXAsXG5zZWxlY3QsXG50ZXh0YXJlYSB7XG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xuICAvKiAxICovXG4gIGZvbnQtc2l6ZTogMTAwJTtcbiAgLyogMSAqL1xuICBsaW5lLWhlaWdodDogMS4xNTtcbiAgLyogMSAqL1xuICBtYXJnaW46IDA7XG4gIC8qIDIgKi8gfVxuXG4vKipcbiAqIFNob3cgdGhlIG92ZXJmbG93IGluIElFLlxuICogMS4gU2hvdyB0aGUgb3ZlcmZsb3cgaW4gRWRnZS5cbiAqL1xuYnV0dG9uLFxuaW5wdXQge1xuICAvKiAxICovXG4gIG92ZXJmbG93OiB2aXNpYmxlOyB9XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBFZGdlLCBGaXJlZm94LCBhbmQgSUUuXG4gKiAxLiBSZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEZpcmVmb3guXG4gKi9cbmJ1dHRvbixcbnNlbGVjdCB7XG4gIC8qIDEgKi9cbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7IH1cblxuLyoqXG4gKiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxuICovXG5idXR0b24sXG5bdHlwZT1cImJ1dHRvblwiXSxcblt0eXBlPVwicmVzZXRcIl0sXG5bdHlwZT1cInN1Ym1pdFwiXSB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyB9XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBpbm5lciBib3JkZXIgYW5kIHBhZGRpbmcgaW4gRmlyZWZveC5cbiAqL1xuYnV0dG9uOjotbW96LWZvY3VzLWlubmVyLFxuW3R5cGU9XCJidXR0b25cIl06Oi1tb3otZm9jdXMtaW5uZXIsXG5bdHlwZT1cInJlc2V0XCJdOjotbW96LWZvY3VzLWlubmVyLFxuW3R5cGU9XCJzdWJtaXRcIl06Oi1tb3otZm9jdXMtaW5uZXIge1xuICBib3JkZXItc3R5bGU6IG5vbmU7XG4gIHBhZGRpbmc6IDA7IH1cblxuLyoqXG4gKiBSZXN0b3JlIHRoZSBmb2N1cyBzdHlsZXMgdW5zZXQgYnkgdGhlIHByZXZpb3VzIHJ1bGUuXG4gKi9cbmJ1dHRvbjotbW96LWZvY3VzcmluZyxcblt0eXBlPVwiYnV0dG9uXCJdOi1tb3otZm9jdXNyaW5nLFxuW3R5cGU9XCJyZXNldFwiXTotbW96LWZvY3VzcmluZyxcblt0eXBlPVwic3VibWl0XCJdOi1tb3otZm9jdXNyaW5nIHtcbiAgb3V0bGluZTogMXB4IGRvdHRlZCBCdXR0b25UZXh0OyB9XG5cbi8qKlxuICogQ29ycmVjdCB0aGUgcGFkZGluZyBpbiBGaXJlZm94LlxuICovXG5maWVsZHNldCB7XG4gIHBhZGRpbmc6IDAuMzVlbSAwLjc1ZW0gMC42MjVlbTsgfVxuXG4vKipcbiAqIDEuIENvcnJlY3QgdGhlIHRleHQgd3JhcHBpbmcgaW4gRWRnZSBhbmQgSUUuXG4gKiAyLiBDb3JyZWN0IHRoZSBjb2xvciBpbmhlcml0YW5jZSBmcm9tIGBmaWVsZHNldGAgZWxlbWVudHMgaW4gSUUuXG4gKiAzLiBSZW1vdmUgdGhlIHBhZGRpbmcgc28gZGV2ZWxvcGVycyBhcmUgbm90IGNhdWdodCBvdXQgd2hlbiB0aGV5IHplcm8gb3V0XG4gKiAgICBgZmllbGRzZXRgIGVsZW1lbnRzIGluIGFsbCBicm93c2Vycy5cbiAqL1xubGVnZW5kIHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgLyogMSAqL1xuICBjb2xvcjogaW5oZXJpdDtcbiAgLyogMiAqL1xuICBkaXNwbGF5OiB0YWJsZTtcbiAgLyogMSAqL1xuICBtYXgtd2lkdGg6IDEwMCU7XG4gIC8qIDEgKi9cbiAgcGFkZGluZzogMDtcbiAgLyogMyAqL1xuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xuICAvKiAxICovIH1cblxuLyoqXG4gKiBBZGQgdGhlIGNvcnJlY3QgdmVydGljYWwgYWxpZ25tZW50IGluIENocm9tZSwgRmlyZWZveCwgYW5kIE9wZXJhLlxuICovXG5wcm9ncmVzcyB7XG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTsgfVxuXG4vKipcbiAqIFJlbW92ZSB0aGUgZGVmYXVsdCB2ZXJ0aWNhbCBzY3JvbGxiYXIgaW4gSUUgMTArLlxuICovXG50ZXh0YXJlYSB7XG4gIG92ZXJmbG93OiBhdXRvOyB9XG5cbi8qKlxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGJveCBzaXppbmcgaW4gSUUgMTAuXG4gKiAyLiBSZW1vdmUgdGhlIHBhZGRpbmcgaW4gSUUgMTAuXG4gKi9cblt0eXBlPVwiY2hlY2tib3hcIl0sXG5bdHlwZT1cInJhZGlvXCJdIHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgLyogMSAqL1xuICBwYWRkaW5nOiAwO1xuICAvKiAyICovIH1cblxuLyoqXG4gKiBDb3JyZWN0IHRoZSBjdXJzb3Igc3R5bGUgb2YgaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgYnV0dG9ucyBpbiBDaHJvbWUuXG4gKi9cblt0eXBlPVwibnVtYmVyXCJdOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxuW3R5cGU9XCJudW1iZXJcIl06Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xuICBoZWlnaHQ6IGF1dG87IH1cblxuLyoqXG4gKiAxLiBDb3JyZWN0IHRoZSBvZGQgYXBwZWFyYW5jZSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cbiAqIDIuIENvcnJlY3QgdGhlIG91dGxpbmUgc3R5bGUgaW4gU2FmYXJpLlxuICovXG5bdHlwZT1cInNlYXJjaFwiXSB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogdGV4dGZpZWxkO1xuICAvKiAxICovXG4gIG91dGxpbmUtb2Zmc2V0OiAtMnB4O1xuICAvKiAyICovIH1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGlubmVyIHBhZGRpbmcgaW4gQ2hyb21lIGFuZCBTYWZhcmkgb24gbWFjT1MuXG4gKi9cblt0eXBlPVwic2VhcmNoXCJdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lOyB9XG5cbi8qKlxuICogMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cbiAqIDIuIENoYW5nZSBmb250IHByb3BlcnRpZXMgdG8gYGluaGVyaXRgIGluIFNhZmFyaS5cbiAqL1xuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xuICAvKiAxICovXG4gIGZvbnQ6IGluaGVyaXQ7XG4gIC8qIDIgKi8gfVxuXG4vKiBJbnRlcmFjdGl2ZVxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBFZGdlLCBJRSAxMCssIGFuZCBGaXJlZm94LlxuICovXG5kZXRhaWxzIHtcbiAgZGlzcGxheTogYmxvY2s7IH1cblxuLypcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIGFsbCBicm93c2Vycy5cbiAqL1xuc3VtbWFyeSB7XG4gIGRpc3BsYXk6IGxpc3QtaXRlbTsgfVxuXG4vKiBNaXNjXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuLyoqXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSAxMCsuXG4gKi9cbnRlbXBsYXRlIHtcbiAgZGlzcGxheTogbm9uZTsgfVxuXG4vKipcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFIDEwLlxuICovXG5baGlkZGVuXSB7XG4gIGRpc3BsYXk6IG5vbmU7IH1cblxuQGZvbnQtZmFjZSB7XG4gIGZvbnQtZmFtaWx5OiAnRm9udCBBd2Vzb21lIDUgQnJhbmRzJztcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xuICBmb250LXdlaWdodDogbm9ybWFsO1xuICBzcmM6IHVybChcImRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBUGp3QUFzQUFBQUJnR1FBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkhVMVZDQUFBQkNBQUFBRHNBQUFCVUlJc2xlazlUTHpJQUFBRkVBQUFBUXdBQUFGWkFPbEM0WTIxaGNBQUFBWWdBQUFvZUFBQVdOdjg1RnlKbmJIbG1BQUFMcUFBQTNkSUFBVTVjbUlaT0FHaGxZV1FBQU9sOEFBQUFNQUFBQURZUERJWXNhR2hsWVFBQTZhd0FBQUFoQUFBQUpBUThBM3RvYlhSNEFBRHAwQUFBQVpJQUFBVXNjWnYvWW14dlkyRUFBT3RrQUFBQ21BQUFBcGhlWmJDRWJXRjRjQUFBN2Z3QUFBQWZBQUFBSUFKOEFmOXVZVzFsQUFEdUhBQUFBV1VBQUFNcVh3cTA3bkJ2YzNRQUFPK0VBQUFKYXdBQUR2bXY3WkwzZUp4allHUmdZT0JpTUdDd1kyQnljZk1KWWVETFNTekpZNUJpWUdHQUFKQThNcHN4SnpNOWtZRUR4Z1BLc1lCcERpQm1nNGdDQUNZN0JVZ0FlSnhqWUdSOHdqaUJnWldCZ1hFYVl4b0RBNE03bFA3S0lNblF3c0RBeE1ES3pJQVZCS1M1cGpBNGZHajhFc2w0NFA4QkJqM0dFd3p1UUdGR2tCd0FFTjROZUFCNG5OWFkrLytYOHgzSDhjZnJtMDRJSFNUa05IUE9JWnRzRlRPejJSeDJzSU01ckpsdFNHb2htNmhVWWttWUpLckpPUW9OQ3lGbTA1cWxiUzBTelNrenRKSFArLzIrc3RtQlBkL2ZweC8ySDJ6cnV0MTc2M3Y3M3E3cmZiMnY2M3E5bnk5QVI2Q0Q5Sk9Ob05NQ1F2OUZ4OXYxMDJqL2VRYzJidi81UmgzSDZOLzNNNTVPREdoTmJFMXRUV3ZOYnExcXJVMDkwNEEwT0IyZmhxWVI2Y3cwS28xTEU5S2tkRm1hbnE1TnM5T2NORDg5a0I1Tnk5UHF0QzZ0VHh0eWg5dzFiNVo3NS8zemdmbmdmRlFla29mbEVYbGtIcGNuNWlsNWVwNlo1K1lGZVdGZWxKZm1OZm5GL0hJNXNaeFR4cGJ4NWFJeXVWeFJyaW16eXZYbGxuSnZlYVE4VnBhVUo4cnlzcUk4WDE0cXI1WTN5OXVsbEhmTGUwM0hwbHV6VTdOejA3ODV1am1tT2JZNTd2MzNvVFdoZmQ0eld5cy9tUGNnemZ2VU5DeU5UR2VuMFdtODVuMUorN3huYWQ0M3BJVnBjVnFXVnFUWDAxdXBsZHR5bDl3dGI1SDdhOTREODVHYTkwbDV1T1k5Sm8vUGsvSlZlVWErTmMvTGQydmVTL0txL0VMN3ZFOHI1NVlMeW9XYTk2WGx5akt6WEZkdUxIUExRczM3OGJLMExOTzhWMnJlYTh0clpiM212VUh6Ym1zNk45MDE3MTMrYzk3L2gzOUM3OHFpOW1NeHYvamdXS0xqQ1g3TENsYnlQQy9xZUszOWVFUEhQNk10T3NYRzBTZjZ4dmF4ZSt3Wi9XS2ZHQmlEZFJ3V245RnhZZ3pSY1hLY0VtZkZxRGd2eHNURmNibU9hZkhqbU5OK0xJcGZ4Sko0UXNlS2VENWVqRmZpalRiYWV1am8xZGFucmErTy9YUU1hRHUwN1RBZFIrazRwbTFJMnpnZE0zeG8yanR3RWo5aGRPekl0emhQcy93REYzTVJDemlYaGN6Z0VIYUxJK0xRK0NSZmlpN001THY2YXJhUDdhSXZQV01nbTNBUFgrUmZqSXh0bUJMOTQ2Tzh5ZStpYyt6Tit6R1laWEVZbC9CbjFrV1A2TWxoZkpabldjMHgzRUJmdG8xTmRlK2RPRHcyaXYzNE9EZHJWYjdPOS9rQlA0bytySTBEQXEzSzRWcTN5WHlFL2RpSHZlalAvc3huSHJQWmxEMFl4S2Y0SG5md1Y5N2w3L3lUTlhGZzdNRUQ4U21XODJ1K3diN3N6Y0djdzZqWVZzL2dWNXdkSHlkeEFDZnpKTE1Zck9mVmxhdGpIM2JpREQyTnJ6S1FSeGtSdStvWkxhWmhWM1poVEJ3VW4rQTRMbUJjN0tYbjB5RWkybmlPYjhkblkydCt5T25jelI4NU03WmlHeTdsUks3bFZkNkpYbkV3RDNJYWJhb2tIVlU3T3F1ZWRHTUxOcWM3dmRpU3JkaWE3ZGlCSGZrUUgyWm5kdWVqRE9CQVBzWkJmSUpQY2lpZjVqTjhqaU00a3FNNG1zL3pCYjdNVnppZUlYeVQ3ekNNNFp6RithcExFNW5BaFV4aUtwZHhPVmN3amVsY3czWDhtRGxjejAzY3lDM001Vlp1NXk3dTVhZmMxLzZHUHNURFBNTFBlS3o5L2Z3bFM5dmZ6OS96RkUremloZDRpWmQ1bmIvd0Z1dDVteGFGRGZ5TmYvQmVkSXl1c1VsMGkrNnhaZlNPRDhYTzhlSFlKWGJUdTlzdjlvMzlZMEI4TEFiRklYcHpQMDBQVmRKVCtUbVA4eHYrUkcvdUpNZEgySXcrSE10UXhuSlZiQlpieE9heEUxM1lreE80amEvRjV6aUZLM21HVi9SV2R2cHZmODcvQTM4MnJYOXRQdG4vaUNOcU5UZDlzN1FtbXI1ZVdsTk4zekd0YWNab2pUTXRkdFE0eS9TVjA1cHQrdDVwclRSOStiU2VNdFVBV2srYnFnR3RWYWE2UUd1dHFVS1FlcHBxQldtQXFXcVFCcG5xQjJtd3FaS1FqamQyMDNpcTFmdEtwMWtjcW5Hb3FlS1FoaGxmMG5pR3FRcVJocHZxRVdtRXFUS1JSbHJkMmRPWnh2WWF6N2JZVHVNb1V3VWpqVGJxZlp4bnFtcWs4MDMxalRUR1ZPbElZMDAxanpUT1ZQMUk0NDE2L1FtbWlraWFaRXpSZUlsRmY0MVRUUFdTZEttcGNwS21Hci9UZUpsRlo0M1RUWFdWZEsyaFhUTE5zcWhyUE50WXBuR09xZjZTYmpEcTlXODAxV1RTVGNZNmpUZGI5TkI0aTBWZGsxdU5lcDY1cGlwT3VzMVV6MG0zbXlvN2FaNnB4cFBtRy9YNkM0MjY1dmNaMjJxODMwSnZlbnJBUXVrckxiWmFCZElqeHVFYUg3V296M2VaYWZjZ1BXbmFSMGpMalhwUEsweDdDK24zcGwyR3ROSzAzNUNlTXUwOHBLZU5IMmxjWmRxTlNNOFlldS9UYW9zRE5MNXVOVGltTnl6cSs3Yk9vczc1TGFOZWM3MXBUeU8xVExzYktSbjFYckpweHlNVjA5NUhhb3o2L213dzdZZmtOdFBPU081ZzJpUEpYVXk3SmJtcjFZcVN1NWwyVVBKbXByMlV2SVZwVnlWM04rMnY1QjZtblpiYzA3VG5rbnVaZGwveWxxWjltTnpidENPVCt4dHJOTzV2Y2FER0QwU2R3MEJEeno0UHNxaHpHR3phemNrSG1mWjE4c0dtSFo1OHBHbXZKeDlsMnZYSlE0ejZ1eWVaa2dENVc0YSsvM3l5S1IyUXYyM0tDZVR2bUJJRCtidUdha2MreFpRaXlLZWE4Z1Q1TkZPeUlBODE2cmxQTjZVTjhqQlQ3aUFQTityOWpiRDZBdVdSUm4xV1k0eXJOWTQxSlJYeU9GTm1JWTgzcFJmeUJGT09JVTgwSlJyeUpLT3U4VVdtbEVPKzJLalgvNkVwK1pBbm16SVErUkpUR2lKUE1lVWk4bFZHL2YzcHBxeEVubUhVdVY5alVaL2J0YVlrUlo1cHlsVGtXMDNwaWp6WHFQYzN6MEx2Zko1dnNhZkdPeXpxTzM2blJWMjN1eXpxZDdEQWxOSElkeHYxMmQ1am9kcVY3elVsT1BKUGpib0dDNDM2M0JZWjlSeExURW1QL0V0RCswcGVha3AvNUZXbUhFaCt4cFFJeWF0TjJaRDhyRkhYNHpsVFhpU3ZNZDdSK0lKRi9iWmV0S2p2OE11bVhFazUwWlF3S1I5UTFxUU10ZHJkbHRPdGRydGxtQ21KVXM0d1pWTEtjS3ZkYmhsaHlxbVU3NWtTSzJXa0tidFN6alNsV01wWnBqeExPZHVVYkNtalRCbVhjbzRwN1ZMT05lVmV5bWhUQXFhY1o4ckNsUE5OcVpneXhwU1BLV05OU1pseWdTa3pVOGFiMGpQbFFsT09wa3d5SldyS1JhWnNUWmxzU3RtVVMwMTVtekxWbEx3cGw1a3lPT1Z5VXhxblhHSEs1WlFyVFFtZE1zMlUxU2xYbVZJN1pib3B2MU91TmlWNXlneFRwcWRjWTByM2xKbW1uRStaWlVyOGxPdE0yWjh5eDlRRlVLNDM5UU9VRzAyZEFlVW1vejd6bTQzNm5HOHg2bk9iYTlUMXZzMm9hM203cWF1Z3pEUDFGNVQ1Umwzak80eTZ4bmNhZGYzdU11cjZMVERxK3YzRXFPdDN0MUhYN0I2anJ0TzlSbDJQaFVhOTcvdE0zUXpsZnFPdXdRTkdYWU5GUnIzdkI0MjZIZzhaOWI0Zk51cDlMemIxUkpSSGpIcmZqeG4xUGg0MzZyeVdtSG9ueWxLanp1dFhScDNYRTBhZHl6S2pYdjlKbzE1L3VWR3Z1Y0xVZ1ZGV0d2WDZUNW02TXNyVFJyMytLbE9uUm5uR3FITlpiZXJlS004YTlkelBtVG82eWhxam52c1BSajMzODBZOTkwdW16byt5MXFnL2U4WFVEVkwrYU9vTEthK2FPa1RLYTZaZWtmSzZxV3VrdkdIcUh5bnJUSjBrNWMrbW5wTHlGMU4zU1huVDFHZFMxcHM2VHNyYnhuc2FpMFd0YVJzc3RGZVdkeXlVMWN0ZkxXb2QrNXRGclZmdld0UWE5WjZGTWtyVFpxR2EwM1N3VUoxcE5ySlEvV2s2V21pUGF6cGJxSDlwdWxpb0ZqVmRMZnBwM05oQ21hVFp4RUs1cDluVVFqV3E2V2FodXRSMHQxRHVhWHBZSEtLeHA0VnFUdFBMMUZmVGJHblUzKzF0OWY5bU5sdVp1bTZhUHFiK20yWnJVeWRPczQycEo2ZloxdFNkMC9RMTZ2bTJNM1hzTk5zYnlxUE5EcVl1bm1aSFV6OVBzNU5ScjdtenFjZW4yY1hVN2RQc2F1cjdhWFl6VkN1YjNTM3FlZmF3MEw3VDdHbWhmYWZaeTZKZXA1OVIxMzV2by83dVBzWUpHdmMxVk5lYS9ZeXZhZXh2b2JyZEhHMG96elhIR0tycHpiR0d2ckhtT09PVmZ3TjcxU3htQUFCNG5KUzlDYmhsUjEwdnVxcldxcW8xejhPZXg3UDNPdk93eHpPZjAzUFNTWS9wZE5LZE5KMTBRaVpDREFtRU1JVk9RcEJCRUNRUk5JQU5YZ1lSTlloRG1CTkZpVDVRRksvM2VaODhBL2M2OGJ5ZitrUmZsTWZwKzY5YSszU2ZCTDNmZDAvdnZmWWFhdFdxVmZVZmZ2K2hxaVZGa2k0K2l6NkNmbE02Sk4wc3ZWWjZ2eVFOMitzb1R1S2t2NDQ2Y1JUYUtHMzNCa2xuT09qMzJnMUdHYTJpZURCY1I3MVozSUFqQi9FU2E2ZzNXRUdkY0FvbGcrRUFibzlDeHM4SE5CNE9vTEs0c3c1SDhBOXFDT0F1dnR0clU3aFNRVU80WXhhbElkU2JMSFEyRUp6c0RPWVFQK253bXhyd1JFWnZKemlraXVxaXBhUExyWlU2MGNoMG1KOWNEQ3haUnFoMVE4MFB3OVo4ZjhGM0tKSlZ6YWJLLzZ1cXo2TldkKzUwcVp5TzNiUFFHMGNhM2J2UkdGTmxneWkxNmRaNHZaajd6dmlnKy9LeHR1azRTSnNjZjgzcXJnV1pXYitwSUtKZ0ZQZ1lFNE40dmt3TjdNT0JZaXArZ080d1ZLYW9zZit5MW5CcHZOcU5kT3hZMkhUYTVWYnNCSFovTVdmVy9QbitmRHNNQTBkRGlvSVY5UXNLcXo0MnJtdk5kS0szT1oxR1NSNnRVMTh1UkdhSnFJWmNkU3pFMk5ZdmpWdG1PWjFjSlRJakcvTXo0NmE5b0Zqc0RsbEJDb0xuSTJSUmFJdE9aYjV2Szc0dlM1SUUzNHRmUko5Q3owcVRVbGZhSzBrdDZQYjJCbUl3QUpTbEEram5aZ04rTjFESzZDemFRT3VvaWlyUXJ6QklhV2NBSTByRFdHN01vbUZLb3pBYmpKU2lUMXE0V2tiNmhCdUhhWWtVUzVOcE9XM09YajNWZGFxYXZaZUYyanROWWl6ZlpRZTdvMHBsc2xMNWNEbzA0dkY2UG5kNGFtWXNMVHp6b2NEeWc5ZmpXcXN5ak5McTBXS2xrTmJVay9sWnk2eGJheFNUWTJyTjNFTlIrQlA4NXNuSzFvYzdCMnZwSlBSYXM2M0k1WEZma2kvKzhPTGY0OGZRZTZWUW1wTFc0TDNhYzZnOUJCb2JkRHN4VUlxRGFOb2VBaVdsL0FKUUlZMFRBblMyZ1FacFM1QWxCVkphU0h1RERkeEgzNVZmOTJxTktoNWVYZzVNOWsxSGZVQWo2bDBySzdyT3RLVVZsL3lNaG1TMDZxcTI5cENxYnoydUtKcjZUNFJaOXlOWk9YUDZhdm5KSnd3WkkwVjdJU0R6Q2tKZW9VQ0lZaHpVRUY2VUtUb0FCRWdPVS93bEJHUDlqNHkwU29xTUc5Y2dhVFErWDBQL2lKNldzT1JJc1NRRlNiTUZQQVU5M2dQK3FpQ1dzdTZ3bTd5dzZ4RzB0T2UrdDk2M1IyeHVmZnp4U3VPVERaUy9SZDh6T3JYbnZwOSsvdmxlRCtxa1VPZGZZSVErQWpYdWthNlZIcERld3ZrVzFSczA4c0s0Vys4TStsNnZUV0JzT1E4MmdRYUFYWUVOSzhCYUxJbzUxOFdVZDV0ZzBiUU4vQ2NLREFja3BNMjB6aG9nQXBKdUJ6bzdEcnl3MmFEcExHcEFqM0t1YmZOeVVGa2YyZzhGSWs1djRnRmNab1Nrd1IvWDcwRUpHSW00akdLS3ZydTE0cG1HajM3SE44MnRMMXZOQ3BVcFF5NER6azIwdFUzUHdmQXlDR0VxbTAyaUtHcHBUeTR2NHlneUEzTk9zeEZHSHFOazZ6VUtZNGhTOHJ1L1N5aklBY1dEWTBXV2krdHhYdFh5ekEzenRUR3NPWnJkMDhiR3RDU25WdXE2amJhK3hmbkcwbld2RVJNWnRkRUYwOXQ2dlc4WUFYcUxiMzVSOTEyR0VaYXBEYXhZTGJCaWJEZnlhcXI3TnRVSVBKWDYyUEdxY1dwUVdhWllvZjZmcUREWXNnc2JCUjNhK3JZTkxUY3dkbGd1UDkzcHVKYUhsZWlBcldQay9HM2lPa0czNDFtNkU0eFZ1bGhodG1IQkZyaFprZk1OVGh2NDRzV0x6ME1GajBtbVZBYTVhK04yYjEyT2JkU0N2ZFJHcklLNklEYjd2UXVGeFU2cDNGbnFsRkFKN1IrNythWXJyUHpKZnZ2dXRZTnZ1dkpielFVMzZ1L2JQKy9GdmYzSjJyRmt1cnV3MzU3cEhYem9Lbk9iVnRBejZJS2tBaWVOU1FOcHYzUU5VQ0ZuZTZpN25jQllnK3p1Y3RJWXZvU0FtQkRwTUlaQUZDRDVHKzArR3c0NndIc3c1SXdDK2ZTU1MyUU1KUDJYclY3dllBLzFDeXRJbG9PNmhzNXUvVWF1MmN5aGc3RDlycUhPcUNZSTFmRUE0V3MxNmxJVnk3ckRNRmJwWTQzbFJtTjVIOThnRGFxQXoySVZvVDB5Q2wzNUQ1cTV5OVZjcTVxbTZnQ2xVSVFpblJBVlkrWnFNdFRoL24xamVlOUtWZzN2VzNieEluVHdyZWk4MUFBZU9TNDlJcjFYZWtyNlUwbnFENnFDVXVPTWpDdUlTd3F1MVpwTTZDZGdpNkRSNVBJamJVK2hCb1czaDA0WTlyZHY0QVZZVDZpNEVJUlBBNGg5T0Q4bGFvR2lRUFBBWldYRW1ZQlh5aDgwNEJwTjFOSEw2azlDZmdsWWlzdmlUa1JBOS9IQ05vcTduRW14RUdhY2ZUZ1BDZkVHRGFuaVdEUjBEalhnT1VuY2hmWnM0TUVVNTB1WlZWZjMxS3R6ODduU3RZZUpKbE9LSjVkYTdYSXViK2FLRStteFhjcUhnYjBpRDBpZEdVUW1FU2lVWXFNTTZnbHBWcFd1b0hoQkpZcFdEd0wwRFFUcXpLY3NGM3Ftamp3bnRFT05Zamx3cG1IY0VEQWRwMzdOTWhMa2h4clRLVXZzUEp4SHJoVUdPUmVFcEZ3SWJlb2kxWVNDQkNOVjlobCtDN1VLV0VuZ3FTc1lhOFJncWtwVW5SVXNLaDhBUmdvcG5uNERWZHlLeHhRR3QrbDFLRVVWVlBGTjJFSUJacGVYS2FJSVd3VFVIL2tUUXE3Q01TT1ZJRjhPcXhSTkFMdkpPYnRsVlRCSWk0ZVFRakRWR2FZZ2hTMjlBRFVRNWx0ZXJHdk1RUVloZDZzRWFBZWo4eGhaMEY0bGlGU2s0QTlUQXVKYk1lQUxid0Z2V2lrUmtFdndCa3BTTjM3Q0g5dFBGUHBUbE1ZR2wxWkVWK0VTVlBsWnFwQ0hnTjQ0am5vZWZRRms4ampvNGF1a20wQWV3MmdKbFRvWXhzbVFEejB3R3Y5cHdGQkhIQ1oxRnpveGw4Z2NLb0hNQlBKS0JDazJNa3JNS0hVbzhCU0hUQm41T1FndXI0TU9CeDVZbTl3ZGg1dHJMbXN2cVRwVmRUTXVIYStWYXdmMXhOQ0ZXTFdNWnI0YzE5L0cvR0p0NnV4Y3UxRndDVldVUVdOMTdlb1RsRFEwazNjV1NDV2FPa0FpeFVJWmVyeU1nOHJ1TkJkcitZSXh0c2gwM2JMZTUzaXg2YnJPZko1VlRXclpXblN1N05nbzhXdTJnYjZ1V2I3cGhFNHhEQWlWY2QzS0lUUU9HQ3pTRlprWURyUWR4a0F4WlZrdGdoYms4dWd6MEU5OWtFUWdod1NYUk5zd3NNczdwSXlva0RDQ3pvSFNBWG9Pb3dwT3VqRVhTMmxiN29tKzR2OGkyb1RlK0llRjJXNWJsMkhBVFZLY21FbExlUVh2UFhoa2lzbXFtYXN0TkdZbnEwQ00rZmF5T3J2d09heFlRWDJzbW80M0hCMWRzSndpdGVXQ3ptVEZ0eDNQTTBwdHpYR0NOQnFqYmxEMkVzdjA4cURpZ1NvWm10aG90cmVleHRqVFhXcG9odnlLbkc5SUl4bjc1NENoUHlvWlVsTWFTcHZTbGRKSmtPZUF3SVJ3SGNCTGhTQUJvakFlcktIdTZLY0RtK2F3Q1pwU2pQU2drOEE0T3pDdWFRYktPb1BoOWs0aXhGRE03K2kxVDdzNTMwODgzVGZEVXJGZExJV20vOElMLzlvc0I1aWhzTENVRHhIRFFibnhLYXBSK0x5S3FveXA5S3poZVludmYvL1ZNSWptcXczWC9hVGxyZm1XN2EzQjF2TFhQT3V6ZXJYdk5FR2hOZzJqS2N0SzArbm5GSDRya0l2NFdYVE4rMGQzajk3NUdmUSt3SjFUVWsvYURUcmxwNlFQQUVyalJnSUFUaUUrQVRkRUFPcXozeVN5ZVFlSTRlUTZEUWdjUmpzS0hUUUhQWlFBcE11UWFwdDFFbUUrOEpHZGhZS0RCUFl5aE5FWm5RYVJTSUZnT29PMDIra0NidzB5NWdFSUE1S1NDdmpSRlVZSE1CZE5vV3FBR3pmTTVzSjh5WTJZUEd3bHlTUXhOYStxRm5OVFkrbmMwc3prbkdidGpWd0RVTTdiRGMxMEdzUWttb0ptc09YWnBrR0pGbm9WKzh2VHUyYjJlQ3BHcmorcnlTRENUTjltME9CRXdVekc0d0FFTEROUTJ5cDI2R3h1bXBqMXRPUHFNdGFNTjFKYjA0eS9mYWdhbFlhVjFZQjl2SnhVSDdCSTAxZER6TVpLclgxUlhDeWNXV3BIeGZzM1hmL05NdjFaMVRTY2laY0QwYUhYZmlJZmxndGdjRVRCdkU2ZHp5L01UVVN1NDIzb0NtSEVTK3c0ckpic0ZjeTB1aHBHdmtVZE5VSkVLekNLbUdZREJHcE1uTU15WWh3S1NNYkZINEpPZkJnZGxqd3BBdTQ3THAyV1hnWlczd2VrRDROdS9DeU1ub09IL0lQZ2t3NlRJUU03Z29CZ0dISnUzTVo5MEoxY3kyMmdyRENVRVFVZEdRcW1iQll4RzhkY000R2c0c1VCb2c5VE5nZWxvYUQ0c0w2b0tLc0dIaU5xU21PV01QNG9KaVNncUd1NGpxR1NtSThyMjhDTW16STJodHJ3ZWJtSm0vQnR5SnZtWEMxWHRXb1BscXpTMXZjQ3BTUnJWYThBK3NNUHlqR01EcExURnBGM3lXTjRETGZnM3pDcGFiRjhsWnpUbDVWeDlWTkZJQU03eEU3VktxNGcwNUZ0b3NXVVJSOVNuZmZCNWRwU3Jxb1gyN1NzNkxxZmI3bFFXY0VnTlN1cFRwRXljWEdqME9KUHhKcm01aVpzSmQrbWZ3Nm1vTzdkcTFyTVpnMTVBMVZCb1ZFamxwL05xWDlja24yNWpFTmNVRjUxUDM0QUg3M216ZWhCOVBheEZpNDdJVUsxWWk2SU1LZ25FMWV4WENnb0plempvaHpLMFd2d2o1M0VKVkxDTnlnT2R0ZXhEaW95ekFmWVIyMGcwUktBMTdWVlh6UGI0NGM4MmNldng3ZmRnVGQyNHduazZ4NlNhNmdtWTlQRVU3UDR5RFNlbVJxelU5eEtjVTIybVlYa3lYRW9lZ1F4bDZKTndBS3FMdWNVRTRPNlIzN1pRKzF0KytWNWRBSHdJd1lFNllCVTY2WjlGaVREUUc2bVRkWU1QblYxKzV1MXA1NnFIVjRvM0ZPY2YrVFhibnpQd2EyL08zY09oVnZmMzcwYnRhUkx1cEZqVUVmS1NSMXAzNC9hS3NoR3M0SWVoc0RySEhZT3VZNERVaHV1QzJ1VjY0Vm1BdEE0c3dLSFlKekVJVVh2MmJvUWxrb2h1Z20yVy8rWDR0cEVjWExPZzcvQllXSjNWNmdvdHF0b211STZpbkp5M1hGdUtJY0tnVk1IRFVVMlZucFFDbDBvaFpmcjJMcWdLcXJMOG1vUW1wNXhYNU81cXNJY2gvR1RUeFN0dXNxUEh3NWlYNzNOOEV5SndIczloMTRBMnk0UEtMTVBVdkFJdk5ubEZyTVh2VXZpYkwva1VEUitDdTE0bjdSaG94QWtHdmVxQUQ3Y1lSOGlTVk04bTVEck5xQWhuOU5NVSt2dERnbXhQV1YvUVBpTE9iblA5ZmxwOFc2ZWNwVUpJS1p5MldoOFl2bVcxOXk2TERib2dNdUk1cXJ2TDRGV00rOGZVMTJ3Y2I3WEVPZnliQXJPTmNTcFI4UFkxejUyMlJoOVlYbFV3Zkl0a2lZTWwvUFFySm8wSVcyQXBqc3IzUW4yNTd1a2p3TnR3Q2d0Y0M4UlpWeXZyVU1uQ0RBOGJOcEk5RVd5N1hFWWRsbVhYd1lwSG5Mc0RRSitJV3FDd2dNbHdRVTdYRjk0eWZXbXVNNVZpVkNOSUVHNGFkSVVoLzJ1d0ZETnhpd2U5cklHUkRzZUFjVkdhb252VFhxV292b1V0YkZDd2lpWDAxTUFzQTZveHpEVm1ScXA2dWsyQWp6dlJnWWpoR2s1eDFIR2o2a0ZGYkdDdXR4R0RLN29xcmppT2pKSytTWDREQWd6ZCtXdVZoTUdXRDRNd3NSVzRJQ2lsN1V4SXBZQjBGWnVLbFNIRy82SWFva0dRazdYRlViVXdMMDZNRlV2OWVhSlE2aE56a2FXcXJGd09tRzZadTYvT3pLUjdrZVdlZVNscHcxK05nNGlhdVJxSURVQS9XRVhhaVZXSXRBejFaVFowTkEwYXR1NllnSm5hM3RmbTlsRlB4RGp0eGRHY2w1YUJwcTlVYnBOZWhDUUdIY0ZyT051ek52ZjRLSVdaZVlMMTlqUTFRS0ZEWVlMM0xwdkQ3dnRZZFR0ZC9sd050azJPZk5oZzdPaSswWFh3L2pBcU1Cb2cra0lwZ3dvYnlpemdVQnNwTTJFajFjYWRWNURQUTJzRWg5TU9jTURpOEpXcllSWmxEZ2ExWFFhdWlIVFZRcGdTMk1tU3BCMXNEcFJibzJWSnh0aEhJZU5qOW81aWtyVlRnMFZzV3ZZVHJ0UUtwWk5CNVVhMFhWSlR1dFhtMmlzMnBWbFU5ZGsxRkJWcFBxVzV0Y1JVeFNLYkRPdWwyT0xxdkJITE5kV21CWGtBZnI5OXU2eHBiRkMyQXBmWmh2SnpWRStIMmlHYVFMc2o5cEpZbWhnQnhtV2Z6QW9QSEgvL2U5V0RSM2xCRXNJWFB1NkVmNlhXdTBodHdCdHROMlRVWmoxNVJDNkVRQk9sL2NsQnpYcElGM0llbnFJVmxDM3RPUUVSdHVNNm02NTczcTI2Z1JCUGphaVFpTVgyN1Y2M2h5M1ZiUlVsUDIyV1ZaYXRjOE9LK01FRWRrR2E2dFNyazZsazNHeEh1UkJrR3NhbW1tMmc1YnZmNncyRHNaNWJWeHVpVForSCs5Q1R3QmlXK1ZZYlRqSXpGVE9xc0FtWFBPbThpektvTFZvTlkwVDFoM0dROVpOdWRCTkJ5d0Y1UXhtQ3FaTENKMDZkdE85cnp4OTNZbmhmYjJyanJCNU4zai9sK3NscTF4WnFKY1hUcFFtMFZpOThmSzRQcGE4clY3T3o5NTJaZWtUK2ZwWS9iWWp4WGV1TEhXdU5PMGs2YzdZRGxPTkErZTZydlBmdHI3cnpDOVg2dmxJZCtZcmt4T0ZLYnZiUUVxcnIrb0g3dkZYSnZvVVhYaUR3REZjN3Y0YjBQQmJZYytWaW9CQXArRnRJdExxa3cyUXNFQjkzQnZGaERFeDVNZnBDTGZ3SG9lckE0TFBiejJ6OVF6YWZHaXVmTU5kTjVUVjZWZmUvdmxpTlQvanpycWQ1YzdiTjQ4ZXZ1TGdBbHFZMkxYM1p4K2JpTkIzWGhnODk5emd1Zk9WeVU1bmtyYmN5ZDFCUGlrbmhjSXJ1cnBXcmU5RmxZMngxcFViY1p6cHVtOUMyNTRDaEt4THR1U0RScEM1ZzYrYndvYUE4ZDl5Z0k3WFAzSTQvMkQrOERjbVFGSEgraWZEclc5K1V2ODU5TlJXN2RpeGR6ejY2RnpWWFZ4MHE1cndFZjNnNHZPWUNGL2ZaS1kzbVV5RjNod0dnN2JNVWpEQkFWNE53WjVNQVhDQUZWWEJEdnlpMzlsNnJyeEFsa2lqakJhem5ldHE5K2U5Mkovb3VjdG1lQ3JRYmljTjR0dVlOcFd6Nk1KRWVldnI1WW1KTXVxVko3WStadC9qR3B2VzJyeGJ0YUpIeXVSVlNvMFExeWNGeG9WSXBnTWVSdVB3amhxMEs0QXg2RWg3cFM5TFh3VWR3RkhCTUVsWk4wbTdDYnd6eU9aaDFPdzM0UmNVR3dZUlBYSU9jazhTVUIzamNRUWJoeFhjV2NkOTFoZFlUemhLTU84MTdoM05QRFJSV3NVcE55TzR4QWU1MDcrOG44Sitrd3NrK01MNWVPY1JmOWJPUTNFVDZGbTRhUmhsOWhYc0Q1Tm15bDRSOUFKdmZYMDlTTStzZXpNelh1RDhsajl4NjF0MVAxZksrYnF1RVVzMlM2WnNnbVJ5VkR1SWZGdFZiVDhLYlBheVUvK0UwSzVkb0RjSVFPOGMxTExoQndrMG0xQzh1WW5RUDUxU0tCZGs1Q2pnZGgzMFNwbFNRbWxiTllnQy94Z2piVUxnUkJtS0dZd3FSM2x4UnI4UkJqN0NINXVZZVBUUmMxT3JiN25wcGplLytjMzMzMysvYVhadDNxQWdLZVUwUWhFaDhGd3RaeHNCYnhEZ0U5RXU0eVlLMGhUMEFvTG55cmdBbFV3VU1FZytGV0U0YmV0Z0kraU1QMFlqWUMwUW9qR1FKVGxBelhZQ01KQ1poSmhnRmpNbDRhZHlNaThFeitLbE5KcmRlZjNVMURoUXdjVXRvQWVFN3BCbXdhSzRTM3FmOU12UzczUC9CMGM4VTZqQk1jNEFFRnNWZFlmY1p5ejg5OGxvZDd0TXlpb2lPc0c5SkFNKy9NSU9xQWhRS0h3Q0lSVUNWYmo0MHc2TE1oY2FGMVdkaEt3TFAxbG1MdkxhdHlVYkZVZWg4RmJ5MmxoR2VqMXhMYnRGS0xrTjFCbG1yc0JZK04zQUJrOUhOWVJnWHlLaU1nTXBCT0FXVG1WWk5Sa3VvVHptZml3RkdUWXVZVUpOUlVZVHNxTHFWRUUvcjFEUTdVaW1DQ3RGY3lxU3VRTkJjUXFCcmdEV0tEcUZuQlpYQ3lZVXdhNXBndzdCb2FvWjZIYlhsZVhZajhEWWhHNEdIRTVJdTVyRHVFajB1cWJtSnpIQlNqMTkvTWdtdFJSWlpjZE9UYy9kZEF3cEZDdGpVOWRjYndlZkE4UUN0MUdDYkZWSE10SHBXRUdCWnRnNXROZ29UeE5GSm8vb0NtSjMzd0ZvaE13dGsxZFNzUFFmWTdKTWVERUN6N05zZWFCWFZIZ3JMQU5hd1VTbHNzRnNtWHZSc0ZLYlkzcWd6eEhEVXlsQ2poN0FpKzFoQlM4Q2d0QUFKTXRJeHR5WmpoM0x5SlVzVUx4S3JOZ2UzT3VaK0lOYVM5R2c4eFM1UVRDejV4QkdURzdFVXdpOURHbEE2SXFpSUR0TUF1aFNxTWZHUE82RjhFaTNQb2YrQVhDMkNmSmVDblppWmJrNTdMNXdHZTBHdjM3dHI2T25MMFBYcmM5L0VERFBKZnVEZ1VUbVh2QnhhU2dkQkZrVlRxRitONDdTM2hTS3VwMHV4eTN0b1JmU1poMFFpOWNiZ0ppTkdVZ05CdVRBblJhaTJIRGJNUU83R2JEdGQvdGZxTTNNVmxoNWZLcndGbmpmRGZtVk8rMktwdzRmbnZJOXkxcTc0VXpaajk0L3RqR2UxanBPWGZZMXo3djF5WHdmRlkvSE02NWQrZGtkNXN5YmdvZURJbUd1UGYrTTVVelZwaVkzSitaVTNmZVk4TDFBcCt4Q3I0RzNpYVd5VkllM1dZTzNHZlM0eTlyclpxSGFsSHRYT0N3RHlRdDdMZmhKZXR6SEl2d3dPOXFlY3NkSzhqZno5Vkx2RTUvdTE5UDY1Ni9zNStNajExeHo3U0thZWM5N0Ztdk41ZlpxL2NEcWphVjFVdmNyOWM5OUR0ZTZKZnl0NU5iSTMvcFF2dGh0ek4wekhrZnZQOWVkKzhmbXQxYlNpYkgxOXVyQms2N2ZxRTNuSytXQ0pQTTRCL1EvMTJFejB1YVBXbit5Y0loUGNiREVZVDZYMUFNZTZzczhRZHcveWk5dXg1amhGTHF3ZGQ0S0Fndng3U0dxeHJscHIrcHhNM1lUQVFNVnZla2NrT1FtVlhPelNSUWxzemtnMXd1QmRmbW1yWXRsSjlEaEwyait6VlVBNTJISEtkRWtvSm9UQmFHanN1QVNwdnVCYUhjZ1lpWlJVRUhicWpjRkE3aWJNRzB2TWxXMGoycG9MOGpacDI4dmZRaGQwTmpXT1JYa0tyb0FVbVBydjd4dlpBTi9EZjJyb09FaG9PNURnRmhlRkFia01tK1lNdkZsU2R3RXdaaHdyQlhDRVV1Ry9DdGN3UURCd0J6aUNwK2pTY3EyZDlFTGw2biszV0FKbDR5aUVjTjNDSFlHaUZqZ1JWL1dRbXRnRk0wSXZ1MDRiempqNVNWU2RzclVZV1U3cDVDY2xTTTJ5UnZoTTVjWnFwWjRsajVEcDhnMG03SEtQQWJlUmVnSzBDbTBhcyt3YVRKRFoxU21sbWNpTmdoVnRJb1lzL2I0aU9JQm9wUTdSOG5GLysvaWZ3RWIrVG5nM0JwWUhHdlNEZENUNnp6R0Q5WXZDSERLdzlKQkRQMEp0dHVnTFdSK3NvNVRJWmh0YmovRXFUQXBNZzlvUHdpak9NUFZnSjdoUXVZbEJwTG52bEY2ZVA2TmF4dHpqTGpxeEN2dm5tQWV1VXV6RkgxNHFHeGp5NU9kK3FsdnJWNExZTU96WmJOOHNLZkxKcGpPbW1hcVY0QjRibDBiZWtSR3J0dXVucXUyWFJlOWFicnF1blBNcGVwNHFkaG14TnU2VllaYXZHTjNEelZUMFRmZWNNWUxiM2p0R3RoWGV2K09JNTdzbThldm9HQnlpUTJ5a05MM0t3WExMUGtMcHE0Q2lwM1BCVUZ1L2dEc1o3U1Z5U1FaY0tLVVIzVlA1b1BmWmVpWlI4L2N1TG41OUNZUStTWjZadXNMcDA0OWZmS2tzTjB5UXdQZEQzZEUwSnRUMGdBc2NKQmpnV0NRSWRpNjhaQ2JZNXovUVhsZDN1MWUzbjFwZ1owbGdRWS83Z1R0QTlIZXNtMDh0TmZmMy9JZHcvNmJ2ZEgrMUFjOTlZRzl3UUYreHZuSTlxVWwyTmx2MlA5MWI3QS85V3hrMnVpcTBISlAyVWIrbEd1RlVPRFJVNDRadysvb1p6RDZmY2VwQlhIa21wR3IyOExQQkRMaUw5Q3p3R3NUMG9yZ0R1N3VtK1VVMG05bmlTTWlLQUNmTUJhQjdNNG9CTkJyQ1ZPVGgrTzRRT09ZSUFFOVBvdlhNY2NYeVVKTTBWZGtYWTRkallEQ0hTKzMyR0l2OVdzekdvODVFMk9sWVh6Rm5tdm13VFRmK2hMeHh1bzJzUzNacWMxUVU5V2VjUTZkTURYUWdtYndVS0FUVGY2T1RYaThXREd0emtURndFaG1GcWlIMXVyVk0wNnJ5ekNBNlVMTDNMTjVCWVZTckt6eVNGSkplNDVIakF6VEFrV3JhUG1SUDR5L3F5dWlrM2VCN0JaZ1NJUVVtWGlIQktpMGdyc0NFUzNNb21iQ3pURlc1MXdDZmVIMVJMeStKdEFOaDd0aEZsbHN6R2FlOWUzZW9xUE95b0lyY005SEZUM0pjK3lBU2I0RXFualB1RWRsUURlOWVZMEh6SnlKdjhDbGlDUmJ6K2VJR1ZreTc2QmlRTkNWdE80Z0RtSk9Zb290VTFibGZCQ1RSaTFuUk1Vc09OS0syQU5hT1hMaHZmOS9CVkNQVDNqdmV0ZEQxekhHbytVdXNOWWpVWldmQnVVZW1DU0JseUpCQVU2d3NrS29WbnprbzUvaHdYVkVtRm90K0l3L1c2M0ZkSG0rcE1VMUVRZU0zWVFkeTN5U3o2QVVQU01ab0FFOVNRSkFHSTNFSklqUGZwU3dyNTc1cVpQVnUrK3VucFFmWCtwME9sKzgvVU4vY0xKMjk5MjFrNy83eEI5MGJ2MkRUbWZiTC9rVjlCSDBMREFWa1FwU0d6UVRTNzFoT2d3dlJlRjRZS0VyOUJBYlhuNElhazJoNmFtUEo5RlU2dzNqYzduQzR0ekxWdHZUY2ZMaEkyODZXRHh6cG5nUXZ4bEZVeWUzL25WcWF2YldwWDRTaGtsLytaYjNyUGZqM0hEbGx1dC8vRE5YRnFEVWxaODZQM3FYOC9BdXM5SVMwQUpZNVdMOCtzMkl3WmMyMDBpRU1nVGNCVGFkWHhoWk1xTmdkTnJocGkyUFJEZWpmbmUwaXdaelZLNFh1d3Z0QmJ0ZlVjdWFMV09kNVhUOVpqaXp1OTZtU3VoOUZiT3BPQjFQSmxXam01K2RLM1Mva1ZzZUJ3RjQ1QkE2ZkFTaEhnaEU5ODlNR2FQbHZYdjI3RlhDWEg4Nm43d2FEQnhqTnhnT1Q5NEY5c0VWSmhVNUx0NE9XY1pnVExpMlRNQW1yRXBOS1FVcE5TZDFRZWV0Z0t5QzkvT2c3UXhVL1BBbHYrUi80L3g1OWQ1N3h5OXR0cTc0WHh5akMrZlBQM2l2ZW1uemdmL0Y0V1YvOXpQQzMrMUwrU3hmNXlXSTBFQk5NT21UNTZkT0ltTW56TnQxOXZ6WkcrN05vWWtMZjczVEwvMEpOTG4xcHplQTJsTjUzUmprT3ZCOUZYcmxoUFN3ZEVINmJlbTd3UDg5VUY4N2t3cEUzTGNESjV0cEcxVGdTNXZBd2l3RkNyQkErcVA1QUNKeklXSTdjZzlHa2VjNTFQd1BFaFhTTE05aERXVUI1MzZXNTNBcEM0SzBSM0VaVVVtYlJaazNxenJ5RlMyc28vYndVaHBEeU5NWU9LYUIyOFB0UElZM0lYK0NFVVV0T1M1NmtxcXVnMUJraG1DNXprTVgxa1J2UFIrVy9oQjFNRllWTUNlb0FtWnBiQkI1UlFnUDNHcGpKWkFma2gyNzVZRGxJTnNnWld4bWFHQSsyWVFHdnExcHlMWmMwMlAwWFlxdjRMaWNNeldrR25uVjhCeVFVVkFiUnUrVXlhNHJZaUQ3WW1HcFV5Q3lNdGhiYTBaUk5VNXExYmt4U3ZBc3NuWFBEVUh5eVpGdkVORGhzZzVvQmpIc1VQd3ZxanVIa1NtSFJrMHZZQU5ES2RqbXNJeW83ejYyWThpblpmeDZRbnlOeXowVkJCa0tWUForTUcvdXVrdFJidlBCc2pPUnBpZzNFT3FwWUErQzRRVVdOZmZqWVdTb3NTd1NIb3dUdnlJcnlnWUtLTW01VWM3bmNoTHIzQnI3TzRTTEdsY29Dclh6dGt3d21jK1pWRmlZUkhmeUNsRkJuTUlCTkZ4V2VMS1NZem9KV0k0Z1p4Vy94SDAzZ2NnNzJnVjArRHFnd01lbEo2V25wYTlLMytFU0ZxbW9nbHBvQWUxRFY2QlQ2Qng2T2JvYlpGS2pDZnFrengzb1hDaTFPVTFFOEdVZ2RJQVJ1djBPY0NYMy9YTHZibVloUlJtOXJpSGgrK29uZ20rNTNBSnFISjJCbWxMK2FTeEF4ZHZWTW5HSzlUTXlqeGczczRad3ZZSWl4cDM0VUNLeloraklhQnRDUFNLK0hIZWhUSmlkNDVBQm1LWFhCTjNjN2FkOTRSV0N0Z3EwdzQyZTNncTZkQnVQS3FjTi9uSlJtTFd1TDd4V0lIcEZpS3NCaFpNdXNFN1VUYmRqQ2ZBWTNvd2t5N0xNV3NKbE5uOFEvektRVmFQYnMvcWdkNENmaUFCcWNKNi9CSnpyaUI3azNxa2g2SldzR3J5cDBNU2hjVXcxZW9UcWFqR25POHVPZTgxeDExMUlqQlJwRzVzSlJYNmtXaXpqbkNJTldKK1V5ZHYwM1ViQUQzcjJ4TGd4cGRWeE1UREhxYzd5ajVyMnJEYWVaQ3oyQllBdlRHWWhKY2lsbW9mY3RFaE5Jd3lOMytBSmN6cXhBTS9YYWk1UEN2SFk2U0ZhVE52dFk3VmFRYU53UmF2V0RRdjJtSG9kVm13Z1IxQXJ1VktoN09XcURkcWtRYjNoMm9seHd2TlNCa3lyKzI1cThqd0Vha1NSc1RvY1FsVXpPU2ZIaS9xVlhLa1loOFUzbVFZS2JUVms5VERhdlNlTStxVlgrUk5qWStPNzgvbDVQWXIwWnpHd0IxSW93QWN3S1h6L2pPOG5yRklvQUJ6aDUwOXpwdnU2NHhqd2w4OXJtdVBFOFkxQkVFV2F4dStvVktKb2NBOHZjeFpaMkhzTDFwaHRxaVMvejZlNnhWelgxblVMeW1HRk9sb0JlSkduNmUyemtXMmI0MDVzRVl3SmRReGVSRmJvejhFYjYvcHc5Kzc1K1gyOW51UHNHeStaKzJxeUNnT2hxL2w5TWpHb0xydk1nU3MyVkREZ2Y3Qy9lL2ZjM0w1eXFYU2JwOGhKa3V5TDQwWm8ydlpjc1RTdWVrSW5mQWQwd2tkZ3p3YzBPQ2tka1U1TDkwdHY0ZlloNWU0SmtUd2lza1VZZmFsdmdzUURqdlJvTW44cExwT093amVOVWZhWkNON3dsSXNOSk1oV1JHMlN5ekdhc2doTzhHSkRnQmJEVVd5R1U2azRoMllkTzVlem5YbGROZXdrL081T1liMjFhUWFJZ2lXMFRoVU51VWozbWNrVXBoUGRKU0RmREV0WGJCRFBWTEhrdCtYRGJsUU9DNmZCc0VVQmlMbXcwQTRjM1ZQQzI2STh5c2RqMExjVU1kZWpmMlhaQS90cXFsb2FnT2N2N1JDcTcwQ3h4UlRqT3Bsb2xxL2JJQUJoVUhUTlRVSW5BQXFUQTJNUTV0NDJsMWNjejdPbzZxbElMbHF1cHJxM0hEMTZDN1ZkWlB1ajJFR21nMDNvNzV3MHpqMG5JNC9TT3VZT0piRElCOE9rendPUHdVdjlGRTBCc0VlZXkxR08rei9NSDV1Yk8zYjIyUHo4MGV0cjQrTzFvOVh4OFQrNzNFbWwvM3BENzFTdlVMaStmMFB2VExGVUt0Mkk3aFhGRWQvT2JmMnR1YmgveWZ6bU44MmwvWXRvNVVYUjZKdTYxM2NYWjZZWE9sTXppOTJaU1o3NkM2M2Vicjh1TE9wcHdGYXJZQy9kSWQwblBRRFMvQ2U1VjR0bGhKUEVMUzd6ZXYrZVI2dWZmYWRBc3NHWXB5eHpnd05SUUQ4TSs1UjNRaWZwQS9SZ0RlNlpGUTZsekwwS2VoNElwb0pCQUxlMy9XSHdHQ0x3QWF0elFrMUg1aVVudHVRYWpmRW9OZFBReHdseEZuY1MwT016d0JmbG1aTk5kY3lQNDFzTHJRSjg5Z1lWVzR0ZEo5R2NjdEF3cWE0Vkk5MEc2MXRWdFp5bkpWVGR5SWRKRXB0R0FqYjZ4d3JEcTY2NjVTUjZMOVVLZ2FORnFvdmp2N05VT21ETXllZnYyRUUvejlxeDdkc25UZ3lIa3o1L1RzRjNFOG9DSGJrNVZ3c1lTNlowelNJT3NEamdBb1hKcXFGaXk5QjAxVlJMZm5MY05wYU9OOTNpV0tubGF2VFhtckx3RlJ5djEwZTVVTm1ZR0lCN1UwQzZSM24rWDZ2ZmFTNkkrSFdqbVRTeXJ1SnhoeDloNG1ZeU1sMmplTGdnek5wMDJHWU43bnJtc0s1dm8zWVBvR0VmdURaZDRHNUk3aVVENWtSUFRjaVVNWXJDUEE2aktNUlVWVzk2RVlNK3NBUkszUTJLbFVwN0l1QVcySytPTlNkenBVcCtvbG5QZGVyMVR1N3B5TFBkMEh2d0RYN3U2eldrV1NvS216d3JWUHY4anE1N1M2MWkrcjVUMHBCaEpNNTRRVU9Pdngvc2ZhMWtLVWtuVWF6U0tjdkQyRE10RDUzM29ROTRmdm9tK2ptUWFaNFVBOWFka0hyU1hzQzdOMG9QZ21UN1dlblQwdWVrMzVIK1JIcGUranZwQlNRaEN4WFFwSkI0UEV1Z0U3ZTI0ekxEQnV1Mmt3YmxPUUc5Tm9pNWlNMkJKT3V5K2U0YVY4Z0FJNEtYZG1mSTA2YUhQSXdwbkowSllOTVVJRFRqczFmYUFtbDBnWTY1SnUrbW8xOGc0Q3pWanVPWUhoQjZyNU1NMjFuMlpnZ01FQSs2S1cwQW1BR21hWEoxSGZFVWhwNUFFUEV3cFcwb3ZGMXhsYWV6aVp1aE9uNXBaOTJYaXlVdk9zODVCUzRrdlg3SzZBSmc4VzdHbDgxb0ljTk9ReEJOQWdaUkZ2T2tjUFRmcUU3aHMvVjdoUC9RVjJrZ1ZtL2hzU0Nkc1pmenZGV2VVODlSNGNFWFVZVFUybXhOTnNmeWhXWnpFbmFmYitUekRmamVyYnJBbzRxcXltRGNJNzZaVVltajY2NmlqaFBac2Fpc3hnUzdEdnpteG1SRnRTeFZWYjJnNktsNlRnZmx1YXhvR1BoVHNVQkVhem5USlFxemRxdUtZNWkyb2paa1hWeWNWRUVmbUE1b1RHN2F5d0t5MHF5cEdDbWlZYzFDZmt3MHJFMFlnOWVDZCtPL0NNQjl0bGZnT2JtWXZ4aS8vZlFPSXIwQWR5WGxreWZMdWZiR1R4V09IeThXangrL25ha01qSTZXWnVwSU9QckVUMHNoaG1kUTBOY0E4NWtNMEVLbm1Kc2RGRUFQcGg0ekRPYVpzcGNZcXNOVXNBcTQzMU5wUlNyR0l2R0RhUllJQ1VwSVVRR0lBeFcxQUlqQWRTYmpKTWpPdkJrTUcvUkd4QWVCajhONUJRQ01vcENUN1kxMlVyN3VaRGxwYlVvZ0xiYmxCdGY5RldrVzdPTWJRZmYvdVBSendDRy96aVg1aUI4QUpFZU1EM3U3bnUxbHJyeVhVajRYeUdEK2NSVExrVGlQdVEwNGVGN0kwbWI0RWVWV0hvY0N6V1E0endNYWw4eEZVUG9pMDMxbkpmOStIZEYySFJ5eFFuUDQ0YUNmYnZQczUwMVBBOFY3SndGTnpSTTNrRTk0V015a3l2L3hZdlFRT09PQVFURUt3SUpTa0MzSHVXc0RCUlJPd2JlWlE1RHNLVmpIZUdKVERtUmNNREJZZFRFSzVSQi9aUHZHYU9kOWRDenZPYUJxc3R0bTRTWlg5cEJ5RUdTWloycGZCdEhtV3VvRUxsS2Y0S0txTXhrOXNvTjZuclJ0Y2h2R3NseWdLR2VwZWpHd2ZVWmtSamVSZk80TW1JRnBXMUhXVVluZU15cFkzbGtPakZVb1YxZmtPMlZaWGpBOTFYSUIyT2s3eGpjSFd2cHFrVzk1RGpUMW85STdNbW1YOW1GMGYzUWNzL3p2ZnEvTGRmRElUc215WW9XV0VFUFNaMExDOUdrcXJDeHVlbk8xMEJkSmwzeUhSY05FWkQzQjZXRS92aFM0eXFJL2ZaNUkyNFZCaTdxOU5ucVhDYUFoTWovN29nRmFOcG1ueThUMFBUZUlDeVp6ZFpuYVh1U0hTWEZmc1JuVlZaV1p4WU5VQmU2cGpvSGNJZE5qOFBlR2N1aVl1TnEwek1oeTdpMHVWR3JGQkNvbzRQMDlab3pwenpoZ3JiRGdvenY2L3RzZWNMcU1aWVZwUE1RQytwVWZFYzFzcU5GZFZmVStKMUxLZ05HdGJnVjRYemZlZEMzM0RkYmY5R2xXWmtjckRVUDd1RHF1dVY2MVBOWXFWZXRhV1kwV3VEV3dVeTh6MEVuY0YzVkFPZ2I5SGlmTjRmd0dma212bzZHWUFkSmtNWTlUTjVuUUE0Q1FCenh2UkNnU2JsOVNIczFtZklKaUFrenBDUE1XL1NsUjZpNFdNYi9MdlhkcVl5cjFaWGNUSmNIWTIvUGorVjlyZ0tWakdLNnRVQytvdE5HWW9UdVJDM0xFSzFYVGQ5V3FMbG1kVkh2a3o1SjRpdWp2Mk9sQStzY243enBqZ3FnMGZ2ekpKenNGRHpwY1JRelZXWG5PSnhwaHFremtwb3JLaFNldGR5Zkp5SWYxVmZSdjZJdEFkeVZBdUZLTEp4N3l0RVNaZzdqTGM4RVNIa2taWmc1SGVMOTRnSzZVSi9wMUN0OVRCNVlYbHpUMXFzV1Z6ZFc3cW5XTXg1cXZ2OGVhYWU1ZDZFOTVoZTVQZnJaUUo1Tzg2TmEvS1JQcFEvczNYMTRzS2NxdTNuRFhGV3NydTM5ejBKOXNsNEtKenoxZ3JraVNjdkVpdE9lZjBlZEE0b1dBQmlaNWxvaEl6WXVUdEUyVGJlelpZanh4TWg2dVk4SW5JMElMaDdUOWxrUE4yNFo3bGpmcjM1Zys2Qy9zWDRBUFdubG5DZWZ1UGJqWjN6UzMzdnV5OGVGTkt4dVRoLzc2TmRQejlkWnVBODhlYWZKU0N3Tld2NjcxUzBxcmV1c0R4NTllUDdoMjUzN3RUZXJFaS9KUkM5S1l0Q0N0YzcvdktEQ2F0RVhEV0ZzSXMzUTQ0T2FVa01FaGUxR1Nwcnh6NmhOYTE5S1o1Z29ncC94MGZxeFlzSHd2OGZIVmluWktNVlhWMUlpK2R2dnE2dTJ2NTV1MXFZTlRVd2RQOGcxcXE0Mnh0YWFobGFZTCtSRDVpZWZiMXhQOTFVRDZjQmY1M3VnTzJHeWRIOTBDR3hFNytobzZCUDJwY2cvbEpkU1VkZ1k4MndrT3hlUXVqQTUxOWkwczdPdWNnS2JPN085TjdsdVlQekNQWmtwWjkvd1JiRHI3SnZyN1ptZjN6UWhlK1FHK0d6MHF6UUYydlZjNkw3MUh1Z0RqQk5ZQW44RFNHYzNSdlpRVndacVVkWGhTUmhhWWJXYnhPYkFDRXNvRGVkejRURG14WlpPQkUzNmZtRzBGSk1meExhYzhIc2hvWG9ycVpoa2VMejVzRHZ1WEQvaURXQlR1akFUSFQ5QmpLL2w5ZTNPZFZnTlU5dHlZMDZ5T055dVR1ZGhBQmQ4eDFWQTE1aFJBQUNpMDlyYnJsVlMxWWtZSWlYV2YxSXB1UDFlMDlWS2hYY2lWRHl6S1NqVm44V1JMbFUwdkY2cGI0MVRYNlRqVHREZHhXRkRpbTBlSUVpdEViTzVsU29IUFA0VE5lL2ljUGNmTGwwdFQxYzBGWXlJWEVrV3ppb1ZwelFraTFkQVlQSDhjdUhTcFlqTGE3c1IyTFIvTGpoa3RkMjBWRzFiU0NEMGxiNWphZkxWWk0vSlJHRGJhNVFuVGN0NEZqeGR0b1ByNHFBR3d5VyszZ0Z5Zkoxa0RSRmhRQlI3N0lrQ05yNHJjL2p6d2ZVM2tPVXdCYmZNNVEzeDRxb2dudDNCWE1NOFlpNWlJWnZBOGYvaXl2dmhGLy9JOTAveWVyb3Z0OXo1OTZPejAyVVArY1BobDJJc1BIejY4S0k1UTdZT3Era0ZxZnRDazJ6dTMzOS9kdVAzMmplNUVxL1ZCMkczM2VyMW5zOE5MYzJEL1QvUzBvRmVlSGRtSmhSdXNuNGpjWHNGSVFocEFjN1pqNHFQa3ZTYVBnd0c4UUord0xkTTFDdGZWbGxhdkV1SHBQUWVXQjgzUC8reGF1SGxrNy9qNDNvbXhsWGlsZW1hNGV1c0tXcjMxZ1hQL0RDTnc4MC92SDU4UWdlelcySzVYM2xOdHRNZjNIZHM3WHE4MDVuc3J0ejU0NjhxeXNGWCtFSGZSWjZSOTBoV2dvYStUemdEOXZ4enM2YnVsVjBtdms5NEU5c3JicFhkTDc1VitXdnFROURIcFU5SXZTWitSbm9aM1NNVlVselNiRmQvTXZseFJneDVOUk5acmxkdkpvMjFuMk0yK0hMaGw4MStFTFVoU2dQM3BzQS9qQVFNRGJKYjBVNzdUWjBPU3NIVElRRlh4MFlGUE00QzZRbkV5SFRaNWJUQ0FHeWpoYXA2bFVmYmJURUE5OWJ0Z05EV0U1NUZQNU9neTdpTWRKdG1rRG9iVExsYnBJdGg0NUM1aWs3c1VXME9MR2hyd0pMUWhZcVMzZmVVVmlxV2hIbUZvU0JqZHVtZDZlaHJOZEpWRjFGUGs3aXptaC90UmMvUGNGNDFZditib05RZVA3S1Z2dkVsR3kvamNOWGUvYXVuanIxVk01YXJIdXliQzNjSHE2cEdKc2JISjQ5NHJHS0QrVzI0NEQ5ZHV2ckY5STRDMTAvY1RLdzRWYjlkUWlacXo2QSt2VTJTcTNTUmo0VFdrZk9yaHpZcU9iMFRBU09pc2pJbUdUaWx3RVpoWWdZdjROTklJbHM4aXpWRC82R3BWbmpjSCtDWUE2NmR4VDU5VEZPU3F6bFczb0Uvc3VlMjN6ZVRraWV1dlAzNmdoUFlnOUhKRmVmbjFENzF1YlpXUXdRQXNrRUdveGh2WFR1bnR0amx6MHI4ZExJdlRad2s1ZTlaaytNYTFOVFh5Nzd3WngvL3BDTm5PQ1JGenJ4T3c4NldoZ0dWSk00TVJLOWxNVWppQm1rRE1XUVl3MElQUXRWa01kZ01NMFc3bVRacEJ5Tks5NGxFN0RPM2x5STM0T3hub1YwL1h3cmRiWGxUMTh3U1V1cW5aZXRXdjJBWitPMW52UWRHZmxKV044bXdGbE00YjdURElWOXYxaVFJTVdiMWJ6aHMyVlFMVFM2cnZxRVNteWhRYWU2WEs3V3RaVWU2bkVMbmZEeU9lQXpVdlhTTzlRbnFmOUdFK28wT2sxMUFPK09PSVQxcmc2Y0FpLzBZa2FVeWh6T0VGOG4rS0IrQUJQUFY1bkttOXdabDBPMzhQaWpPeGx4a0gvQUxOQ2cyNDAzNjBEOXdSYnhkczgrRDI1UlRBN0NHWmw3SXhlanlmWE40ZnA3THBjK1BOQURQQ3pOY1lLYldic3RFS0FIQ1lCYTlHa1VvTXpWQjBHaFpnOTZ0SVhtWWFsZzg3bm14alMxc0tIUytZbDdGS0lrVnBLdWplUWhVdXE0R3NJRjAydGRDRGZTQ1Y0aE5nOThwWEVzeklIcmpUVUNKN3p2SDRGRksxTDBPMVBDNkRjWjN0R3hQM0ZwWDg5eElqQ0loY0dNK0gwVjJQR0ludlZNS0VVTnZSYmlKMEh5SUdzeE83cCtxMW1rV29TdmFONStzcWtjYzFaeE4renJVcldJbEFYZHJqbGhzN2hnWk1SM255M01ISCtGVTNlRkhPVUNDMWhGZEp1dXgyRkhQaXhEejdwQ0hFalhEMThzUU92bW9HRjV3WnprOUdVeThFcVBuUmswamFjMSs5MGFyZnY3SDd2bnB6MTNCNS8vTDhURzh3T3ovc25TbFZobWVXNjRxak5qd3YwcXA2STJxTVQxUm5mNzZtKzVmTzFDY21xN1BvNlYyTHkvdXVXQm11NzE1YzNydnJ2a1p6cGxJNmMrZVpVcWt6TTcreWVHYndVVTh6cG9OODVQalIrSlVUWTE1NCtVRGF6b1U1RDNoTTRTc2tlSHgya1lPN2ZHWmdsODhTQXdIWlRKc2YrbER6QUxuL3g2eHp0OUFGdVQ5UVBxNjg5ZzBVWGRoNmRhK0hmdUxvWE9lbnl1V0RiY3RabiszTVFaMUkxUG04bUhNa0laNWEwMlhKQnFvUCtULzAvT1pmUEJzZVYxLzkxbURyc3k0NlpHejlxZ2MxdmVmbzBiTVQwOU0zSCs4ZkYvYy9oNTZDdmk4Si9EeENlM0V5eUpRU0VsNG1uc09QcnJjR1MvT2wwdnpTd0lwM05jLzJNKzNVUDl2Y0ZmOWtybHFhWDV3dlZaUGp6ZmFVMEVSVDdlYnhrYy93QzNnUy9UWlkvYmRMSDVEK0N0MkJYaWxKUVh2SUgwR1Q3Y2wyZkFZalM3TlpRbG0yVkJKR05JbmFLUVZRUlFRYTR3c3o4R2tWMmFvWDdRM2NweXlyb0V1YkluT2F5eWpPMUR3SG5sZkxSSEJYekt2aElpbWJBMEFaWjlZMDI2WGNDbW9QTDAyVW4rVkdUeXptbi9OanVEK01Zc0JyYzJJR1UvWkorVTF4dEJDUDBsSll4RSswQjBNaCt6WVFUYnQ4TWwvYWJnRVlUTnJEVVFnNXpVSVhneUdZcnRrWmNidW9zUzFXZzRuNWtpVU1iT0JvTUlRMlpNRnBrZjRBRGU5d21iTEIwNEs2UXhzQnltU3B3S3J3R2lsM0FmSU9BSnlSbVRtc21lWEI4QmExcjhFMmtyV0dnckJHVFNlS0ZtM21hR2JrWWdWakUrT29hcmpBa3pYRFloRkdmK29sWVFobXZReENpQ21HVGkxQWRsaFJKbDJFN0xoYXN2aXN2WW1HNW5DMDJXdUJ5bFFOcCtqL0QwOTNzVi93M1ZwRFZjdllNblVENmEwaWlCcWtURGlXb2NtSzQya0lJK3BWbWxOWFRLTlBNWTlZVkpOTk41YWhJWXpxVEhZc1hWdlJETUNMV0RhdFFBRkwyVko1R2sxSDUxNHczMVVNckNFMlh3SGpzSmpEOVp5ak1XUHJOSFVUVHlmTVZlMkE2cGk1Y3BaWkN6ZG9nZVpTL2xDL0RHOFBHbEEyb0k5OEJ5TmRZN0pueWFHaXEzQ0Z1YUZMWFpXbkZDc3lnM0kxMDFRQ0JLckZxUnBha2d1S3N1bFlucDdVS2x3OGVwb2o2N0ZEQ1hvSUJLK0t6bFI4UzUzSUdZejcxbVNGV0N1VlZ1QkdEaWJRdTRrYkk4TXZ5Q2dPWkhlc1ZBaWJiL0RBc09YUmRzTEVySFJkSlpqSHo4c3pVTFhsUWRPZC9DeFNUQUFSTTh0OHpqN2h5Zk8vYkd1V1hQR053VmkxQ21ka0kzYmRraHhGaWp3NVpkQzhXOTZJZEZOWEU4dGwxa2w1SG1PZW1WaFVlZTRXd1ZaZHA2Q0dRNlF1OERpOXFwdHcybGRkYWxCTlYyeGpRck9Zci9sRmhxdzZZN1VLSVE1akhnN05sbGY2VFVOSHhJOWNnNmdHbEhkMExIc2hnYTJNODRIbWF3NG9GT1Q2UllXQnpRL2RwRVhVS3pzSUticHNPQzJLWXA3VHBDbGM3Y0E5QVZFVjdNUExhejZmaUltSTZpYVl4aVlEU2tTRUdvcFdkSUMvb1hsZ0hCS1p4YWFGdkV4MlBvTitDVDBqV1Z4U2JSdGl3aVBuQ1VzcDA3RmxsRFRSZ1Q5cjkvdnQvOTd1Yi8wUGVPWEFlcGNWZEo5SDF3L2JmOVdhbjIraFg5eTZLYkIrMGdvRCt3Mzl5M09hbmdVWld1RXpiTkNzUENlM20xbE1iTVRpbzhpWUxFS1ZUV0d0UlYzMEZSNVFWV1NkVU1yOUdCaHJzbVpReXIwWk5ZMDk5UXovb2pkaXFsSlpKZ2p6b0JlbHBxcW9NdUkrRDdiMU0weDc1aW40Y3N3Q2Y0QzNIZ2E3cGdDdDZBTk92eGJhMGdYcklac0IwTXZrNUtVSVZ2b2ZYd0s3STlycDlXbTlkQmJxUTcyZUhZZCttRXRDUDBpY1RiOGNCS1hnNFc3WFRnSS96Q2NSNkNaM0Y1eUNEOXJMazRtM1U0cTN6aGZhN1FMaVc3VDRENUVueTZyV25rODFGY3Z1c2gyRWhUQjg0dDgvL2FYQXVpaUpTbUJiYXhjdVNxSW0ySW9jdFl0YkY3K0N2b04rUzJRajdlUFpuaVBkME8rQmVneXp0QnhobnpmWk1PTHBDc0x1cGlOY09rcVRGUXNuY2VRUWN3T0UyMW9zR2JUcEgxUVRPd2NJdW5oRTE1Snl3N2hRREJ6clYveXJEOVpZM1FWZTFIWGdSMmJlNENWbFA4WlVwdGRZVms3WDNSTlgxSkxITmxsdWJMT05xRmx3REJuWHVya1k0QS82cE1hYzZ2Ty9NQ3c1TGdXYjFiWTlVN2ZpOHZoL05rRGtVYjFNQ2FGRmI2WjZheVd1NEV4UFA0TTJnWDREN29WSllQQWMzT3dQMDJhL3V3RjIyZVk1ZHNOSHJHbnR6QmwyOG9QMmxIWU8zZkpaL2MzNkNlM01yMm5udFJOaUtwSTZ5b3U5U1NLU0p1eGZuaFBma2dCYkJDSWxnK2RxdExJOEM1RkR4ckxkSm45YUt2YWo1dkhqajNXclZUU1IvZjRkL1BEZk40QWgyMFBoci96Z2o4OU0vRXBwNHZ0dlBmTlcyRTZjK2VOdS9sY0VQbnNPVS9TN2wzTGRKTkxuR0N3VnFWQTJXTGlDQW9YWGd5L0VGSFY1RkpEL0lxbHoxSEVEWTZiUzY4eXUzblRtNE9Iamk5ZjQrV0wrNGFObno1NDllUERnK3ZyaVRhdHpDNzNLakJHNHp0SE8wWWZob24vTjR2SERCODk4NWV6QkgxOGI0Y05uZ0QrZkZYRzJwblRuVGwvUXRqZSs1WWtsWjNZNE9tWHVYdWI1QXMzNUJhN1VrNFZac1I0WW40Yk1NZ3pCYmRoczZ1Y3dXN0VtZ3dHQzJKSXM4UlpOT0xFRG45Y2FmT3NnT1YrZER1eXRiMGZWYW9TdWo2cFgra0JTUlV1VGk1Rk9wbStiY1podStpRTJMQ3R3ZFlQcUN1aEh5d3M4MjFRcE1Sb1RNK09PclREVkJMRHVXWVpLdjJGNlhzNkZ2eHovL2VoV1B5Nk4rL1BWR0oyT3E5V3RGN3FEb3VjeFdkRXNTdkk0VUtGbEdwVVJKc3lNOHFWMGpCOHJMRkpVYmthQ3h2U0lUaGxSU2NoNGN0bmwvT3VQU0NhWG16d0RvQ3hXV3hLdXZaUU4yLzFMM3IzdnJ0MisvdDNWMjFaWGIxc3Y1NC9GVG1ObC8wcWpzWUl1ckx4ODliK3YzZjdnN1d0YkY4endxbEs5eVUvRE5XbGJMcjlYNUpaR1hDNzNFK0c3OG9STFgveXVJZlR1ZDg4dkxwMDk2enVlLzZVdmZRdlZmdUxUajNRNjZCZytJVzlKdjhXWGxaSDBpejhBZS9QOGkzSXJMK2RUU2kwUnlJKzZQTGxKSkdQeFNEeGdINDd2YkpTQXFOdE9BdUVpWWdPMVJtV0dvL0xvWmJ2aDcvRHUzUjhVV3hRWlV3RVpzM1Zic2NQUzFpRnFtTVhGZXg3NGhZbWlYM1cwSDM1ZkZNbytmN0x5M3JVVEs0K3VycTZPcTRvOFZ0VHRlRFUyMHVuWit1NDdid0UrOTFvci9PL1IxVzEvNi9Qb0Y2QXZFcWttWGNWajQwbExTTEYyZWdrdGl1bW4yL1NiUk0zQnlETzl2VFpTUnlRaGNPZTFZQ2hPcHc2cVIwTjAzOXpXWjI0ZTVCa05uRXJpT0pRcW9GU3M5dWtOS3dCcXMzNy9oa1BOSEtNNXJ6emNkVVhkVmh2RlhMMFlvWUFGclp4TUlyT3VYWG10akk2K0p3R1N1bU4zdFZxY044SG9jelJPbm5HeTk1WS8xM2t0MW4vYWRmMzYxR3lhOTgyODdmU1N6bVFqRjlabDZzcGdHOXJGUnRqU3J6a2xieDZYUm5tZW96VzN1TlpLeGJ5SFE5SnBrZWM5Rkl2NVpJQWFYcEZ4SkpyeU0yS2JSbUdTYWExMU1WMFZ1bWNnL0tlOGQzNGtrUU9JOVpKUCtqUWJMeGZ5RTlQNWJ4WTI2NldrR3B1ZnJCeXNxMUZhS1Y2bnNLbHVLV2o2bGZxQmdPVXF4SFFyYzVTVUc2R0ZLc3pPMVg1N1o5N0o1bVZYODU5WHUxWnp5bER3d2RobHJTa2owSDh2MGV5Rm9aMVBUbWkyU1FERTlzWXIrU0x0emJyekpRVXIwNmJOMGN4OFN6TWlhK2ZxREYrOTdQVVc4N0dlQTd2MmM4QjdmT1dFS1dsWjJpTmREVnp5b2xVUVlKVDU0QXZIc1hoOTJJdVo2TDNtT21LOVBoZEU0cEROaWxVbitRR2ZkODA3ekViY3N0MmV4WEp6a2tOeHFUK2phUXZ0ME5LQzV2ellWUGZXcjB5T3JlOXJGZlgxUTlYSnczdDBOdXpPRlF2bDQvN2szRnJONnQzLysyWjVjcmJncy9tZEU4cnVLKzFwS1RLaGNSald2TlIyeTk2ZUpUT1BsM1o1VkY0NC9DbFpsbG5vKzg1a2U2NTg1WnRiemZId21rT3hWVHB3bERHWlRoOGM1UmRqVjhTa2pKSE80L00raHA3d3dYSUhYY0tRK3BhWC9xR3JyejF4QWo0bnRoNi85dG9UWDRVZGZyVE5XeCtCK21wU0R6anJQbzdUdUVsRkw0bnkwU3BVbVhPQTg1TThXdld2ZTJsMXBVR2NEa1RDYmp0Ym4ycTBxQ2YzTFFnV25FWGI2YitEN1hUNFJDU1ZpUldib0s4M2pTbkRxWUdab0xsNTAvRkxYbElxbkxydHVud3hkb3NBQUdhVHZDVVRRbFRkY2dCaGdNQllvbmxkWlR5U0w1TUFnQUlnZDZ3WTZxMGdvbldMNmFBVnZGYlV5QWZJRDZ0aGFFWVdoWE9zeW5oa1hrM1FJUll5blE4bHN5M0svRUp0cXRPZm51ek1UVXdQT2pPMW9ydjFWZDNBTW9CbXZ2NG1XQW15dWlBekR5d2FtZkNrV01JdEVBbzNneVZuVVJXQnJaRlEzYk82UWF4VFIxUEFBSWtVV3B1dWp2d0l2SC9MV2U1NnRpWkZObDh0UzM0YTVVWTFOMTh4bkJ5ZkRxTjBhdmtYZi9IUWNyOWNxbFVhWnhiUmhkY09jL0dWeDVydE9MOVpyL2E2UzlOSEs4Mm04Tm4vNE9Mdm9yOFVmSkFEeERJcC9icjBlOUszcFgrQk1jeG1TUEcxR0ZKQjBNS2k1ZGIvdGw1dmJ1OFFLcUozVEdob252L0gxeG9SNjRPeDRTZ0pXOFJyK0pLUElGN2JmY1kzZk1HeElaOXJ3c2tBQ0NaYlg0em5hbWV6YmFCSUQ0NDJSZ25lN1d6SnNWRzlJOE9kVCtEbWliaFFleWJDczdrTFFseG5rMDdXY1pKVk41VXQ2ZFhKcHUzd004MzJKY3BNNG16NXlSUXRvY1FDNjB3eFkxT2h2MmZsTFlYaHZFMVY4MCtvcmx1YTluR204ZHdMdEVnak85RTNlN200NE5hUXl2MW1ya0xCb0pJWkdMcUlhVzVjcVFjTnNLOU1CMXRBekxaaTZiaGNWdmc4ckkyNVZUVnZ4NWF0TjhBYVl6SlBQekVOYnYwcFNzbWJISnRoZks2ckNYalY1bUhvd1dURHpZSFJEd1VNRTB4eUJUbGwxZDc2ZjVDcGhVWXhVazJkT0JwcGU2R3BkUkhHZk5JdVgzbU9ZbDNqV2FQdlVTdzFRZ1V6MEF4Rk1VS3ZUVlZYbGlsNkwxQVpUOFNWZVpvcW5JQnRCSHFMc0ZkcXRuYnA4L091ak0wdVg1eUhwNkxxek1hVThTUWRoL0VsTkpGQytkd2FVd1A3U2xPWlFUVEdOSW8xMVVUWWRXVnpaYzdDY3MzVlkwUFhkSU1CQTJITEpEdzFCVVY4S3BTbUdzekNCTkFXUVh3bE9EQWIxQUF3RkNHbWhmMVE5d0k5ME8wbklsMFY2VVN5UHp1cDhEZTBacWVnb3hVKzNVbUpDTU95ZGgyZnVRT0ZWRDF5NHB3TmhiQXlFZWYwVWF6eXI0SEdaYkRkcE9IOEVpSThzQzV5eWJtcktmUDVBS2tMejR6d2IyMUxwWDRtcDlKNkFYMjlYTGxqYzA5dnZsSlN4N3JyQjd6SVRVRFRQS1hvekZxdTF0RGVYdHFabWs3emxSdW41a3BWaEpiLzNEMEF0bWkxM0p0ZjdkWDQraTZxRWViSENxSG5GbWNXOWd6T2hZNmhPM2ZHSVdXNTRveFlVK0xTL0xQTHMxZCtkSlVpbnJXOW5Ub0pYL1NwcmJzMXk5TFE0N0RkK3NjMHZmQ2crRU1YTE8zeWxhMHZmZTFyNlRqOGpaNGpmUEN2ay81ZWVnRlJsQk41YisyVUwyY3IxcEpzaTJnZFdDbUQ5a2lFaTE0WWJpL1d3UzlHSEF1TTRCRS9NeHo1d2tiaW50OGl1TGMzaTBZd0tSVzVIOXgvQUJoTDFOUUVXc3JxN204dmJEa2FFNUFKbEMySTdNT0UrL0s2Z3cwTVhMb3VmSGhkeGxkZVM3cmJSeUl4WlFNUExuc0tGNUx0NVRVWG9nb1dwVWJSRHlqVzZxMkxaWTlZYStUZmhPY3RpR1VQRzJsL3RNSVlseXB4ZDdUR0gxODFJQll6MlFBRUV4NFlGMU1kK1BLUlRLeEZpZmxpb0xaYmdDUGIxVzFzYUxhdW9ESXpiZTVFQXZheVZiNkduZVVDZTdEWVl3VCt5WVF4eHVkMktBWlRzQVg2UzdDMVNvak1MVjdnWHM3QVlKWWd6OC9KMkRDNWM1NGFrYW1iaklwWi8xeVJHSjdpYW81aDZTN21LN0Rvak0vdEIvNVFDUVcrVmtTV204SU5FMVdEY2RFTWN5eHY4YlVlRERzTytIUVBBOFJFd2xQT0tZOXVxTEw4d3k4WnRrSkJIU0lUeTF3bnlwRmhJRGRSQTQydk5rbW96U2kwOHdpM2NoaG5SS1F4UXA1bGZOVUpwRkl0QWI3allSTFhZMUE0S1ppNkFkSkZKcXJocGlLbEJvVXBOQjVyaHVFWUlMTVUwTmRlSEpXVHFzb1hlWFRDYUg0WmhJUERXQzVuVUJsNkw0d0F6Vm5Rclh5MkNYRjlqTVBJNURQNDlJRUJQY1hkTjVUcGh1TTZxdXBaQWVVZG9HS0NmSk1oc00xVTZJWW81eEk1WDFTNTFORjFKM0FMSmI2Q0djZ0h3bGZDbFpHcUU1bXFDdVBUV3dnMEZxU251a3MzVllNM0hVNGdKMVFWRWxqNGpaVENNQmpPWk9TN3czZEVHSVFybUlzaFg4SVQ3RWFvRURyYWhIc01DelM4bEsxVGNtbmRBSTdDZTlJdTZiQjBBOWpKN3dYZWJqZjdRTWdBS3ZsbjJPNXhiM0hLVjN0b0o5azV1TnB2cERKZldHWFE3WE1OTytCNkVveXFhSjB2bHoxODBmenRuVkE4QlEzSjRwQzduWk5CRDRTY3FLT1hEa1hGUXdCWWNFVlVGVUs1Wk1oTGQ0YW81dnJMTjFkY1hmY24xdjRxMFFHU3FHNng2TEtmV1p2d1RkVXRuMXQyZ3Z2aG11Sms1ZEFtSEpEQVdUNVhkdFZqbHpHcXVYbjMrYnMzeFNaMVZicGQweC9udks2dmJTcktwdVozdlp4bGxVMHI1L2JnbEN6RHFaNlR0K3lDamQ0aEIzaHBYbk1OWjliOFBpdXZsWmpyNkozN09ycDkxcHh6YlV1Ylg4S0JqSTdCNWR5bzZOWVAzYm50QSt0MWwySDNuczFSTXpidi9rWE5kVmxwcmN3OFcxdTQ3enp4cDZOOFl1VE1PQjlOKzJTUExPOFJwMkp6eHlsSjJqbFB1Z2cycitSMXRwZDFqUGlDTGFNWmFkbS9ZWnNLRkRKYTM3Y2o0Z2RpazdZZlAzMTFzd2o4SWg4cjdJOXFFVThUcVlXZXBUbitubGpXdFhKaXhVcTFOREhkb0hZWWxPTklEczB3S2FFTDQ0MzErYzJ4eFlnY1A4QlhBZFdNVXFGYW1peHNYbzEwUldWaExaaWlLNjErNE9pMlBWVWZWOUtnRWhmRUhJTi9CbkgxVHBIdlVBWk4wdWE1bkhIUzlMbzJtT0F4QzZNNkY1eEM4SFdib0JQbEJjWW5aTXlpZUx4OTYzWFZCcjdyUkVmZWVtZHQ3TUIxdTI0cTFJNGRrLys2MlpVL2hXWitmL1B1Q2ZUVDZibTM3VG1ydXFjNml3amRPVC9YUUU5b2MyT3QyVXQraDBYMGpQQVhTQzJXQmw2YUROSGlCOFRmRjg2Y1FXVHI0UnUvL2UxTE1iTHpvUFAyUTBsaFliRitOdnR2ZTZuaWZqY2VndnBvcHUzdDFaRDVVaW1EVFBZbnpkRjB3S2JJQ0JWbm9UcEcwYWQveHltcE9oZFF0T0tRSDk0SmNqaVJkZFdNMzg3a3NVcHNHMkJDS1FVRkYyUktXQkFVSjJkT2xTcUFidlJidGY0UURQZ0NBQXZxN2JueG5yNFBZRVRPcTJadU1HKzFuWnhDZjU0dkc2S3p4RDk2MUNreUxvemVtVHFlMllpbGtWMlo4ZnVVdENJZEFGNi9RM3JOUzFZTVliM0I1WVFpTVM5U3JBdTNmWnk4T01PSXJ6NEJ4M0RJNTJjRFhyaVVnU1JtUTNSaStUOU1DbnRoK2VibDVadGZ6VGRQTGgxZElySVBZc3p2K0FGUmZKbitnOEZlNEluR3NIbUJ6NWJSeUxzMEZhNG9STlhDU3RqY3dVWHJkNjJ2My9WR3ZrRlBqQ3FFeldQalMwdmpSWjROVkN4N2p1T1ZzLzJ2ODByZkRmS2NrY2NVNVRIUzExMVM1VmVxQk9SNEZDRnJ4K29valZHOXNKRzJmYkVhZXBaN3JCSUJja1RjT01wV3p1dXlablRvMEtITi9sUnh2cWlyMTVwWGJ2N2xEVmNzYlNqSFREM2V1T0V2Slh6eEJhQ25Md005OFprMWZHMWZubFNZUk5uQ0ZUd3dMWU9rVFliUFg3VTBtSEc5bGF2Mjc5azlQclY2VzJ2cG50Y3QvUmd3Vy90MXE3dG1qa3dHY2R3YjdGMDh1N2oxdmRYMWgxZTVxM05FcTF3T3RPREF5NlpHRFp1Wloxdmt5UEsxQUx0UmMwZEM1ek9sOE5wVmJSOWcyckdvT2o2M3R2WTcyKzRJZEM5M1RYeG03NVNyYXF2eTNHUm43MmRHZm9yTHozcjJmKzladG5IZnNyWW5lMVk2djd6OHA0WnRHK2pkdW9OK2ZPcyszZm5sUFZNZTA5Ync3RlJuenk4N09ubzNYTjUrMXRmUTgrZzNwZTl3SE5obm96WElSemI4U0g3MUdiMjBtSkh3QnNVc0ZqTkcrTVdGYkFFakRxY1c0c0hJVm0veWhjTGpaanVkanhleU5mdVRkRUg4cng0ZHVDVVpwSU8wTjBoU2J1SUJlT3VMaFJaU0Rpcm5Hd3ZEVHB2anl3WEsrdUt6MEliUEhHNkd6WVYyZndIRVFiKzN4RUhsL0VLL3R5Q3N1SVVNeTlPSWg2NnpvTzdJc1RBeUlEbis3UGZRLzQwSUIzRVUwRUJFVEFBbnFzMHNrQmVhem5SWjFxeUtFZW1PNnRVQWhGVzZGY3UwcmNER2pKV0IwVGx1ZzAvT0lwb0ZKSzVBVFN5YktBd3lCSE40STFZS2w3T0VlNlRvcGtYQWJIRml6WVFUV2l4cklMMnB3cWYwQU80cWxqaSs0ZE56T1N6Q1NPZFJRVi9qdHBraXg1V05mSm5oeGxpdjZRT0VVUUd6TUFCTEpmeWZBWEs0YnVDYmhzb1hDUVVUVWpPcEJRZUVPOEdqUXRKTVFHOTZTUzJJODVWT0JhdzZFOHdwVExrWkN6YXFUbldOb3hYQVRRalFEOVZNazZNeUxKcWdZSjVQeUVPQ2NFZzVoQVFoQ1NEUFVHVWxad09pNGI0U2lubE5pczZYQ2lQSWdyNEE2NUgvendRSUpUbWlNTDNhdE0ySkdkUHV6Kzl1ZTVxTWRGZlRLVk5VMjY5QW4wMzNaT1BTMnMxZkZEcmlDa0JFSjZUVDB1MlpiVFlFYU1LQnllVXZBQ0lPVVM1L084T1V3NW5MM3g2SFR6dS9pY2RYVVVoU0ZpVkRPWWxZMmgvdUZKTFd0d3hkanFPZ011TmIzVFdUYk81RmFPOG0rWitzdlFtOEpWZFpMN3JYV2xWcjFUd1BlNTdxN0wzUFBPMnBUL2M1cCtkTzB1bnV6RWtuWkNTQmhDUkEwaVNnSU5DUUlJSUVvM0t2aUFwQnZLRGlGUUdIQkJDQ29LaGNoWXVYb0lDS2lvbytWRUN2b2w1UDN2ZXQycnY3ZEFqdi9lNTk3NXphVlh2WFhLdlcrdWJ2LzVuYmZjZGZxb2R4b3BpSnFTU3BYMXNLclBVdGt4ODRqRHR3WTJ2ZDlwZHF1SVB4bVM5OTZVdS9LLzgrQW45TEo1ZVdUdDZBc3k4OXZPdFVVWlNDeG0wclNSelZsMEpyZXEyakI3bTVoVHZJVStsbEhhNFY3THFaeHRPRnMyZEo0ZXdiSDN6dy8zcnBTOG5sTC96U2kxNzB4WDFMSjIvRUM4QnM0bmM1Sy9FbllwQkxNclR2eDlMTGhQOGl6bks4dVdHK0lMNWNQU1JuRDV4OTh0MW5ieWlmZmZlVE1EK3djL2Fzdk03WjhsbllBdk8zUFhrREFyN2c2bDA0Qks2MERYMm5ManFKU3ViOTZaY0wwWEQvcnRMcEREdWQxK1dMWitEYy9obXVtMDY3cnNWa0pvcEVvMUZqa0ZiUy9LRlExWDF5NXh1blR6OSsrcnJycm50ZkRrenpTNDhUNy9TdHA3WFRFeHlOTzRGdk9CS1Q1aUtNaXhPeGpESENjYjlOUXJRcVN1MTBFdUNSanRmSFV3Z0xkcjZxU01vbmFKVFM4QTMvdjlVbUpQR0NoSkFtNDIrSUZqcFhkTmg4bEJCMTFONVBaR0djL3R6SUFLM3FwOHRCeW9ncW5LRHlack5YNzVYOWxCcDJlYjVTQkRHdEhqSEhqOTJ3aXJUaCtjM0k5VWpTeWdhamk1ZTNFR09Na05YQmtaVkdxZnAwWVhWeGI2OVNiVWNsOXJidXNEZTd0cmp2c3Zac29GZlNkaU8zM2Y3cEJNZXFNWW5HK24vMEoyTU9YMDZrTVZWZ0tFTkZPVWJ2U0FqYjRXaUxyT2ZtMUw3RUx4cDF5WnM1YUtzN1A0TnpjdVBPejBUMWVrUnVoUGxsVkMrN2d2dW01NVl5eFFvckFRSHFhS0JacGxmeDR0Qk82cUR6a2UvTER3YnQ4a2F1emRTajgyZjRRY1ZpZ2lvMkRYUlExRUxITmY2SEJybzA2TEdMeE5lRnJTaXZaOHFFSDMyTS9EcTh5NUgwSnVaUlFybUFqUThoTXlDRy9rVDRpU01SVHczQ09iM0hiSHJ5RVM3S1FUbHhYZDBQelNCY1A4U2phbVJhN1pWMnFteXZsWXR1V3JIODJJNTl4dlhyZ2RTQlpxNkFXczJVR2ozbGhaRkxYcWFsVHRwdXB6V3ZTYXFnRDRKdXJVT1RuSXRKeU4vQmQwRVN5OXJUVzhVK2lLSmE5OXpOam5iZkxZcUI1TTI3V3ZtUWFDWjJsUGkxTHZRSzA3WHNzQnJaakxhcnJtZUdxdVpXZE03Slk3dWJkZWVyaUw2cSszUUpqZ0IxVlB1UzRUblF2RDdDeEFMVkZ0UUUrZlZOZWQvNVk2QVpqeFRtQ3B2b0FSdURPQ1ZENWtHOEdrS1BCd2tUeFl4YzRnS3hjNHBYRE9ONnVuMkZqUHMxZ2pGVkxCVVNLbXdzMFJYU016ZTVKNG15NzRNMXpyUjZkemljanlwSERkdFhnV3Q0ajFRNW9nZStDTjUwVXJlTStRWERxcXRkYVB5dStwWCsyMVZHZVRzRGRzUi9rdlZyNjh0Mk1LK0Z0aUhpSnFnSi85R0dFYWErUldQNjdHZVJ4U2hrWThsSUVtT3BZM1M3enU0OENsWllMT3dIVHBKVERoUVVxNlNCQWQ1aldiUGdnZ2Niblh1d2RMbzlmN0FxNmFlOUN4OE1xTTVmSHpIM3NNV0hZb1h4cE5ydDFkMm9UelRkWm96KzFwMjRzaVF1WjE2aWkwWlQ2SWxTZFhXdnluSUM5Y25PZzNqVEpjUzhmREhyeEoyV1lUVzRvd3ZWTFJMMjRSSmp5cjJjaXRwYjBTM3cxeTNOOTdWVzBhaFdqU2syVU82andwemVJNFdmbC9VY0ZnalBOWUYrMXBhQUtRbjhaS3VaQU9scFJaa1l6S1hJc3o2UjFkQ1lKYUtoeXpEUlppd1Q3aVNDeEhjdWh6aDJjaHl6TnVhY0lDakdhTkFGQmh4bjMrMFlXT1lCeU1OY3FZRUwvdzhsVVdBNkkrY3RzcHl0WFZrTGJZc3RDMDN6UVlLYTd4ZjdwZjZDb3ZIQUZjdEVjVHlyZXRXUnlJRzlhOU9QUmkxZDlVeHVjRlhUQWxVek1kK1RhclZkK3poUll6Wk95alBsSko3OXpBRDlnSXFTTDNhK3paZzI3RFZxcTUzTER1cUc1b0ZzVm9kUllEUkFyUEZDL2VCbExpR05wV1k0Tnp3VnBoY3JTdmxSK0pUbEIwUW1lQmRyT0tNSzg0VHcyQTNUYmNxajhMbW9HRFo4WFQwUnAybDhRdFg5Q1g3UzM1UGZLTnhTdUFkeHJEdmZwYkhRb2dvTmpNQ0NpS3J6SFUzY3hYSDQ3RTNjUjhsL0hURkk0VnZudkRvWXArZS9pNWo4VFVXZFVTdHFSNmtxSFlPNkpnZnFxVmxBMkF3ajRhYXR1NTVPRGRKUjg5M3c4MnUrdCtqNXY3YnpKVGdFcGgrRlZUQ1J4NVRtQnhTbDJjU1BTcnFJNWtMVlRaQUZVV3VPTkMxUzdpTnF2bGxSUGdDZkw5OWFkbTNiTGQvNlpWRDBWTFR3NVBOSlAvNWpHS052THhneTkyb082L3NOODN3TGgzU2s1d2pkUmFrRWZFWVhLbnBRSnlzNTMzeitWckYwNDV2SW5YSGx2di9TaW91dDk3d201ZnR1YlMzTkRzYWVwVmgzdnExZGJtU3ZmV081dkhubnBqcnp5RzNsc1BXZSsrcmhtWi83Y25lcCtkd3RVWXFjN1kvWEsrMmZ1c3RVcm4wNHIzbjFFZklBK1hVWVZadVNmb3M4bkV5cUNwaC9pc3Z1SktxY0k3bEROVno2bEhBRkJyaXUrYmx1VGc3di9FUEpNUU9obWVJaHhxNU9RYjVmRTlHU1JRejFIdDBrbHY0Y2pIdFVpQzR1TVhWeFBhZ0I0a3RDSTcvdTJmN09xUlIxQmUydFFMNzlmMm8xais5VGRWTzNkY3NVTXlrbzQ5cTlJQlpjeFRHTlVMYmhmOUE5NUpXRm1jTDNGWDY4OEM3UWJTZlE2R2tTbldPUDA2STBDSWVlUjhxc3BnbEdhZVhiMEdLT1pwVUJndUxIRTB5RlFZNGhJM0ZtRTVrWGdxNlJ5V2tudHF0ZVYzcko0cnpzRnNnT1lWNVhCZU54b1RtaVpPcUZsSTVhMXBMUXBLMzF3ZEU2SVRVclFmUTZWZk44THpCdHl3dzgzOVZVUTZWNmFuMlNtSXhZQXBocm9nZ1YxQWdIZXBycmdVYWhhWnBpQ003VHV0dENVRmZNdzFiUjZKNGFscXNLaStpOHB1b3pmNnNZV1BZRGFJRlIwaFVuTGZrUlhNRnQ5WGYrWFdpSUZXeVIxZjdCN2JVbzFSVnVhSTVickxWbUYzcWRSalZ4SGFGeFJTOUduMGY4V2lEVHBwdUNaaGFxaHFGcFZIRk1IdHVJSEdjcWhoMjR0bVpvaXFKWUlLVDFNZzRxbDZpenVoT2FLcVdvRHlXV0c1cUxWdWpWVmtoSlU0WEw1c2FEdTNwV1dkZEtsZDdLNm55dlhTdldkMzdkc1BXbXhCcjh0NmYvZ3Z3V2VSZklxMmxoRlhxaGZHOTVKNVA0ZXJJdzVVaE5FSnV5MXgybEV5aUJpUXJUSTZ1aTJpNjNFa3NQZmErVE9VL0FqOVRTd2hxNUh0cG9jY2x3OU1qUVZ3Yjdic2U2Q2JmdnJaQmJoUi9xVnRJcXQycWVrM1U2b1dZbVdibTlkaUxRakdBdUxsYUJOcGIyM3Y1U1BPQ0J0WW1jOHcvazQrUXN5RG16dVp4VG0xd2ZnUzRaYjAvZ2ptVTFSRmxxUVdJUmtiZnUvTEJmbERtRDZRZU5vdjVja3djMlVLQlRwMHhkc3dKNEkyZUwvdXRsTnVMVzYvM2l6ai9wK2syV0FWc1U0OUpMRFNXd05NT2U0cUQ5OWdTdnRBajkvc0xZRElaeENqMkJHV01OV1NtbUo2TVlVa0xPbTYwZWVOV3JzcUoxOG1SbFdEeFZuSmw4TzNucEt5K0E1MzNEcTE0MVV6UlBuaXdQUzZjdW1YeURuVjZGenk5aitoNlEvTGN3bHFlZlhGTGtHV3Y0NDROMzN2bkJEeTZWdzdObkJ5ZmhlK25rNE96WnNMejB3Uy9lK1h4WVg4TDFKejc0L0R2TEovdXd2clQwd1YxWXdLcU0vRHBhT0ZtNHR2QUExcTZJc3ZaZ0hLMGpwdWgzd0szeHJKdVhMMXBEQk9wNEFodzFQSmVvbmFkMFlSQStqUDErZDNDK2RCT2FqVEpacUdLVTlqZElmcURNdnQ0aS9UZlZLdzIybUNUazVHNzE3SnVKSHk3VWZGdHdWVzhsZnVXZ3F5V09xamxKbVdsOFk1YVFXYUk2a1FQVEN6cnczZGRBODlmTEVSQXZyM05IWitiQllzbXo3ZGZ2VWdiUGFDWnZGSjI2eXNKSUpXYXRaQm1qRUhPdW1TcHNwalFUb1ZHYWFXODBqRGR1R1o0WHU5NkM2b0dBb0lMMnRiOW1oeUxqNmNGcExjSDN5eG9IeTRVeHROc3QwbTRBelJJL1c3UElFaURZTFBpNDBINXAzc1R0aVRTdTVzVzd0c2phTU9zS2xCQjdmVFF6eHIwNGdpWTZGd29tZUpKbW8wRXZUQU5kMTh5bGVyRjdRMlRWSTJFWlJtTkdNZlY2c2JJNWUzcXV1ekRUQ0VvQldRZ3FIZHNBS2xVa2UwaS9uL2pXajRENkVkWFFQVVgyVVBybjBUd25TcVVxaUR1WCtjNkppcU1oMmx4a1VMN1VNRXpHMWkxUFgvamtvUC9hdGg5RmZudHR6U2lIczZlQkNhOXFSZDFLK1NwNVRrdjdPeWRKYWtseXZmbHh4L200S1huRTArVFB5R3VnVjQya2wwbmk4TUR6NWJMRFJKWEtNWTd6THBNekRFd3BBU1lBQXpqUDdFbWs1QTkwSGNrL29qZ2xlZkhBVVM4SGhGbVhNTThmMG8zTTFEUXpNM1RZcTlOWXFRenNZWFcxMlF1aWVRM2tyMnl0Tkw4eTN5MnR0VUdyMG5vSFp0dHV6WXBYWTdQdXRudWc3ODRjV2owMHMzYVZiK282bmtNM1hoWjZVZVIxL1REMG0vc3VDbHdGcEdNM3lHYkhCMWVMSmRmU2ZBOG9XdVQ2bXVXVzB1V1haYXNLQlZsTlhjMzJGWU9nZUNiMHU1UGpKMzYzcWUzaWpzSUxDaThxdkFRa3MxY1dYbHQ0L2JOb2JGd2E0VWZuV05nMHIyT3RLNnVCY1JuTU5RRkFPT2Z2V1NGdDZaM09nOUFSYlU2aUUwblRleXp6aUVkSkZyVUg2NExEdDk0elpoSE1MckNXL0pES3phSUZGRnBsQ0szSDlkRFFvb1VvQ0lHSkVhWUxVdy9OSWtqRnBtY29YT1dLQWVJcGpFN1ZNVnhMNWV2Yjg1ZmVjR0pwNnkyTUNHSUxaTk1VNHlxWWFvRHFvZWpvYU5aVnFqekRDSE9XcU1xZVdHY0tkL3lhclFNZjFsMkhHVmdId0RTWTQrb0NWUFdhNzNCUUkxM2d6TDQwRDRMR3hrekRnY1VjQ0liK2RlT2w0L1B6eDVmRzF5MnFlVmdUZkJoVkVlVmZCZlVhWkVaMEpGTTZpVXY4QS9KTjBHbDR3UVpwOEw3Q2c0V1hGeDR1dkZraWpZQW9BczJEZnY1dUNvditxQnUySnlYYlJvaEswNXQ2MHhETnZ6OFZmeWJSUERJVFRXYnhTRkRJOWZTY2R6K1p5amNDblM2NWpJTmlDa2ZJWjV5aEV4VERtMmlQeXlnQjJQaHU5UDJDbGd2UGF5eW9CQjZIYkIyOTc4RE5KelFkaTZ6NWxxTXFDZ2RsQm9pWjBJVEJuYkxuTTNzbXFEcWVDUkszcmdlMlo5Y1BObXpQQ2pDblJIRlU0YnZWb09QcjJxVTN0VnNQL0NFNm1HeDRUN3hCcUVSSlZHeU1iTUc4SE5aWGlFWWxsRDFDTW5KQ09YbjFnZnVPWFBWUWlXcWcveUd5citacThIcmc1YUtmVzVnbFNqVU1XVExpMGxKWWNuV2dEVXlvdXZ4VEJVc1M2Q2lHRXk2Vkk0TXJUdk5xcnRIU1ExY2QyUmdmMkhrUDNnbW5pc282Uk1GYmdja21LbDVGb1NUSGNxQ1hnTHo4OHNKRGhUZko2RDcwcW1CZGJpeWtGbTlUREQ5RGpOQWNuMElNWlcyTFBNMEpSUVdNdFVMQnBpWnpCT1ZvUW9JdGhRZllCUXUyRVFtMk1NUzFGSW5TOHJuU2xiQnlIT2VTcTBBYkkxSmtNVFU0MGhHMHRFTDlyUmNjTUszaE5hdEhOeFFEdXR0Zys5UzI2WURBWm5KTHFLdTFWcWlGemZvcWgxK0dvaG1PQ2RzSHNKK2hiQnhkdldab21RZGVzT1ZUUmRkcDBPbTgrbExMdXZUVm5jNFhEZVJ2em12ekJUbXVLRXhYbGxZUG56bXVmUjlWN3JLUDNMNXgrRXlUTWsybnRUdWhjNVJ1VklMRVUxcStnVEErYm5oWm8wMXB1M0ZaaU9IQW11RzNGQzhKbEJ0TEx6NjJkV2VONmhxanpUT0hOMjQvWXQrbHNGZG94ODhjWGwxU1lDZ3FhOE1UaHc2Y1lqOUN5SSt3VXdjT25SemNtM1BhMVh3aDQ0UStCeVRpRjBGK01HVTFnVEtNbmhCaE5VSTBjZmJYS2lUdE1XaFlKbi9XLy96YnFrTHZvZzdiOC9ETk43K3poait2WXc3ZGVQamJPMTk4WExFNEVVSzhiK2VMcEh2NnRGeUJCT1I5MDlqKyt5WitYRk5XWHBNR1diOGZ5ay9jUDdTKy9qeVkrdjA3MXRkZlJRNmQyRGxCZmhrLy8xSTQ1d2Qra253OHIwWGFtUlpsbk5EWnZKQzd4THRjbC9VMk1mNFBYMzBPa0RtQkJKd2diRytUYVNST0hvSjlucFBsS2cvaVZwTWYwNEZTMjJVRGxBZk9sUEc5ODUwNHZPUVF4cGlBdHVVVzU1UlNZcVdldmR6cnRPcEpyS3VJM2xjSjBwSmRpcG1TL1lwckU4NDBwV3dianQ4d2l3cjdPeUNaSGhDNGR0MHBSY1BWVm5WMWNlblFSVEFzbG1vbFV6ZmNSaGxEUi9SYXFkUmJTNk9zbWFWRm0xT0hveUpEK1o1ckw5b1BwTHNVMW1hemVaOXJ2SDRCdGk4aUxkNkJ1T201bm5sT2VmdE9MQjZzL0xDcjdTNXN1YnhRcVl5VUhPeHV0WW5USzIreC8xQjhBazhMOHBSdWhKcWpYaGhyblRBZ0NJNkcyWGlxMWo1Y1NSeHJlUTdFRStBL2JwbldoR3RvdFdLN1VnUXF4bnpUZFRYUEpvd3NHTjdWUUpwY0t5Z2xaVVBSTjNmeHNzOG8wUE01akJaaXhqTmhxeDRGOVdwMWRvbVFhdUJaWEk4OHFscUI1NVhxOWZKTWx4RWRRNFJZWG91YVBDcmppQmZRaWhKTFlJWnRlaDZISVU5NW5ZWnZ4cmdCZXdzNVluY0hNMXN6Sk51YUthOEYrNXVYTDI0OWI5Kys1MjJ0TGl5M3FlMnYzdjNTRXFoaXBiUHRtWm50UzdhZ1creHZ0amZ2L040N3Q2SjR2aFpWNzc4K2lVQitLZWQ5OWdseU8vVFpKVVNLSHFPSkpabmlFY3VFQmd4UUhvd25ZQkhKZU5qM28ya01TRjVKTm5jd1RBUGFldDBGMm1QR3NEZS9IcGdTajN6Y1BuVWoxYjNMOXMyM3FqWWhTMmw1dERIYVZ6WWZyUmJMWHNDWUY4eW10VmF4N2NBb3JEV1cyS3ByNnVaYXRUZHZFTFdaVWZhYzZ6dk44WUUwcWpDeXRmUEwrMmVYYmNkMkYwTHlCc2V0TlJmWHVndWhTWW1mTHMwdTc2bTN6K05KZjF6NnhOdG9JU1hKZVNUbGliWGdPL3ZjTUl2YmVZb093bmpHR0VsTE1CTjJldVJnWVZyRG1pd0NkVXU4T0hUTGxrbFpNYXExZXovZVNuZCtLVzIxVW5KNTJucHBqUkF0U0tyZGdjSEo1aUNad1lZZ3dtcFZ5aG1uRlNMODJYYjNNQ0gxY3MyRFRjS3VscHJ6eFhqKzhQbFR0TDU5N3d0blNXQzc4ek54Y2U4bUpjVVkrczE2Mk1RaWRrM2lXelVRSUwxcGJIdmhYSzVLb2NQNm9TcGFZOExTa0Z6MU16LzlycDJucmlDakszYmU5cllyZnZKMXBMTHpsK21iMzB6Y25XL0NiR3B6ZlpKOERXZ2VCUm5TdytqNFRrL3RTUHNRUVJWelBPcVNUbzhjL1RJcDd2d2lhRTNrWi9jZFBManBrSjJIU0hIenFUOSs1eStheFoxalJaTVU2dG5CQTIxamR1ZGYzN21aMDBLWVBRQ3llUXQ2VnFFam1lZDUyQkhSM2QyNUVWbExuWUQ4U2EvZGE5bnkxYVBCOWYzKzlZTkxoNFA2Y25QY2hDa3J4N2JKWGtoZXRHYzgzclBueTc0N3ZtWjFjUHF1MDRQMTlWcHp6NkU5VGRkS2ZPK3cyQ1AvQ2hmNDgyWUxnKy9pejVOM2s0TUM0bjMwVWFVZlozbjFMRVJQdmtCb2Zib3d0Mi9mWEs5YThkWm5PbjNQWWhzMzArSDdhL0x2R2FMbVIvWmR1YTljZGp1RGptZTViVTFiSEYwcGQ1dGlzM3hUeHFEM0VKc2xmSlo0bG5PM2xRT1A1YmQxL3E3aVhRVjQzdGplMDRacHJkMkt0cGVXbXVVNWR1eEJldWdETTFrMmsxMmcrYitwdFhGa285VnNoY3NIbG12RkJjTWNIcmtiZDhwbUpuNkZKMkRNbUlVaWpKcDF1Q3VVL1NXSVVHOGdZRkJBNSsvbmJzTmsrblc4TEEyRVVzUkJOdlpUdzRZVjJyb1RLV1QxSmxWaG00MjdIRDl1cUxQN1duUHFHYjAzcysrSGlLNWVEekpteEkvN3BRWTVlTTNKOWJYMXlteXoxQzl1NmNySkYyMHM5T2ZGNlJ1dmZONU50ei8zaGl1T3FpQkpYSHo4ZFcrODdlN252MmdTdC9FMzBHNVpYc2xsZDMrU3hhdmkzVDJxbjVDdmJiN3dvaHdhNExhamg1dEw4MWVXS3ZQSDVwZmFsY0JXSHZtNjhxRmpMOXFXTFhQd1lJUHptWm5lK3NKRkM1RlhTWkpya3drL243Nm43Qmx2S1JWVFlqSUowODBqNUhhOWxkWDc3NWZSbEc0WStjVnUwWTlDVjhVeTU3dGV5Si8vK0k4THk3RTl4T21ya29yQ0xjT3pIV3RTZDJSUzV6VDNSYStDN24razhDRWNTZEZFVVVYWHgzcmFtMVQzWEJmUzlyRk0yc2dyUnRNRUw0ZU1VVTdkdnJEQXFjalRKVUhWRzQzN1VnRmNrUStSdCtJRU82bzdSaUUyQnpGdWl5SFBkY0ZKeFBORXBzV2d6SzRZeTJTSjRkcWdsNGhJeGp0TEpDcEVOSmdJTXVNNkNCR01HZkJ2eW9VU1VRWFRVb3U0SUFvLzVxbTg0ZG9lczdBSzIxeExNUlZRd0I0NjMxYUhRTFh5cUduWm9jRElYRFFrbXg2bHRkU3ZDdzg0dDIzWWl1WnJ1aTVVUzFHMG1DdUthZ211dTRabGxOS0tBanFEYVNjUkJnUDdFZUxTbXpVc1NhbDRLREJEZnhSV3BWcnU2OFhBMGN5VjJhL0xlMVJNZWNlZ244TFpZSklMMWJTQ0tBTkJnRnJDZGdKcnJLcVdSc3g3ejcvNUZ3bVY2aXdTR2dhY0tGanJFdHJEU1R1TU9rNmxGQm9nUTduMWhrNlp3RHg0M3lKR3BSYkRpVjNMZGZSaUpZUnVZM25DOUZFaEFuV0xCcnBSdGFzdHpGRFh5a0V6MFhRMXRSSzNuRnhhZGtQUGplZXRhYjJ1ZzlCWEZ3dFhGZ3JwWUpwNE5MV1FEd2ZEQ1p4aHpndkZOR296anNhNE1rTmdDaG1KT01pRnpYYWVqVEllck9SODd4Y29POVZ5b3BJNzI3WmlwcHVnS1p1Vmt1RUNxK09PRHUzM0dub1lpd1EwVFF1Qmd4elRkeFNYOFhXaUtFYVkrdEVleEJlcTc2a0d0ZGJjWEhHeEd6VnJxa290TjBqaWFzMXZOcnh5MGZlTnlLcllTVkQ2c20wZFBrYVhOQy95eTVubnBIN2dWaDFveUlzNkJqUnJrSlRRcGh4SXYvbXJRSFpwdzFQdks5eGN1QWQxYTFJa1BiSU9iWEVwK1JqNVBmSUg1RS9JVjhtM1VQTEUwZ2s1RDRlUnNRYlNDckNCcVhVRDJtTk5odG56RE8wYWVXNmtOQnhKRHdsSHpJejlKQmR6c1B6NXNOdGJHMGtFU0xTb1pWTExScUFNUE4xYS84TERreDR3RjlodnJkMURrb3F2UklxcitJWlF2WmVRYlNoNWdES2ZSK0NQZTROSlZwakF5OG9zZ1M2aWhmU0dFbVJjbkpPUTB6dzZGNGxDSHZvSDl4QzVFMlZ5K29ZRkJwcHhjYzZCMGwrYjZoa29zVEhrZ1Z6a3VRaTlVWW9uY2dtbWZYWmt3ZmcweDFYS09FWlFMNU1WOUEzbFpva0JJb3lJOFNTck5JcDdNbWVwdno2RkdPbmxta3JLcHhrVC9VbDIxR0RvVEVCR3VyMDh0d3UxQW9GWGtHY0dDZ1NNQmNQYjhGR1FCV0dDN1RCblBaaVIxWlVQMHNWY3VWSHVyRUs3M3BpUGdTdU1KRkFKOUdxK2hTWUZZbWx1aEVIcVFoRGQ1b2p1WVh1VkNueXBPaVVZblpZaDJKV1VnTzVqcXdhTWNWSGpoNGlRQ1U1MjZHcW1ORXRnZzFZcUhxaEtRaUYyUlMwNWpBbkRGaHF4R1ZVTU9CU0VmNVhYK1MxMjFkWXg1ZWw5TEZhQTRHdWdmM0FtNUkxd3JFeXVXUlQwRGt0bmxvYSt5cEpWU1hYR2tSYnF1c1l6QlJRUkYyWThyVmhXNEdxcVpqSGR3cmc1ZUE2VEE4bkNjRGFnZjl5QlV6TUZnZThvakFrNDk2enVoT1YwZHJaWURoMXRGdWdnMXhZMEhiT1BGQlZrRUc3NTh4UWozWURFS3NIT3R6RGpTTmRpMytLdTVhbXpnbG1JaVdINVZhb1NsK3NLeHIvQjFXUmRDMHpxUUJOWVdPNXlSZFdEV1BXYlZ6ZDlOUTUwVmVGZHVLQmhNb3lkUTJjeTJqR3hYcE5xY0Jkck9GTFZMU3JVTkJYdXEveEJ6bjJ1bUNaVmlpNVM0YnBHVkMwTlMwQlFnbVpYTXpnUGJ0OU9WU3Q4S2RZckNqbG9jUFplclJrSVV5c0ZSWUYzSXdTY09iYUJ2SnFhNlpxV1lXTE5KNnE3dXNQaHBRazkwbFNxcWNtZk1jVUFJcTRiS24vQ3NFQ0JGVmo2VTdOam9TT2dNTHhnSUZ5dXhZQmNhWkd1SnlwYXJUN0pWQVFjTm5SNEIvK3FBVC9SMzFnT0twbUJHclloTEJkdEhkQ0l2Q3AwTjRXWGh0WkxUT3NBSlJ6MlVMUUdNMXliS1Zya1cxVWxZbzVoV2JTaFlWS2tnZGtTd0JoVWVNTnFDbStXVmJrMEd3STdzSVNoVXE0WldVVkxiYzJ3dzNqV0RTeWZoUkgxb1JmTTFsT0xreFRUUTRodVdyd01mVWd0cWRCdFhNZUVVekJlNXZDQVpKWnpwaFk1Y3o1S0VEOUw4d1ZqTmxXNUJtKzZ5dUhxME1rcytGbFhvTE9GT2p5Q3EzTWoxSFd1MURVT25WSW9GSHBsQlRvTllqRGIwTWQ5T0kycUJGYXB6MkY4Vml0aVlabVE1VVd0VXVXQzhIN0pDaDV4a2xERndpK21GYmsxU2h4ZGF4N3dYTmM5V05SZEdtdzVNUHBNb2x1cEVzVjUzRnJobjRGbW00VmZLSHlpOEZuUU9WMGlBNXlBejZ5emREU1JxZUtFb3pvbUhDcFQ2VkhXaVNTUmFIY1JGQUZvYnA0UEMxdlFIaUJUcnh6cVVwbGtpYnZIYTdMU093ZXlpVEZ4RXFPM245ZnZ5VXN6akNSZVdvUkpVN2ovQkZldHY3NmZJZ21MZ0t4SlVTdUNGWktzbzI5QkdsMzdLZXdPRjNjcE9wVUhQUkcxaDJNcGZYM09VVUhlNTI3akJlOEdXbUxac2hjeEdDR203bUhVS3c4VjZKa2ExWEFJRXlFc1hXVWFLZFVPMVlyVXBGanhtcW1JMmcxOWhTdWdHQXFpV1FnSlltUFFyaUpnaEtGbGxxRUxGdDRnNWljaUpZRDF4RFZnb0Nva0VJd0tEL2JCT0QwVmVpSU9ROTkxKzZ1ci9TOXM3dG16ZVdTMWJHK2gyWWR0R1BYT1VVb1NncWo3RzZYTEJZaE9sNWRzWXJ6U2QyR0V3bjFTVEp6U2VLMGlXQWpDbUJscFphQUNlaXhNZXBtS0lQanF6Y1JVcVdGamVxTUFXbEpsU0NrVTExVUl3Z2pCR1J6WENMQ0VMV1l0R21nWjkxVkpqVFFONktIU2d5NnNMQVNHRDA4S1Q2ZnF6UEd3NUtuN0F4cWNpZmt3ZUtFcHVFSFdEdUN3cDF0ekZHVXF6R1NDajB4VzJhM2pCYytXUDZodUVJd3k2ZlZ6SEs0TDFibWQrNy9ZdUx3emIzRmh6MllYNm0rL09YcmVuVDkrcXUwRXJVc3ZyRkhGQ2h5MVpCbDE5Y3h6UDdsenpRVW54SkNvQzArVTF4RjltSHdQeVBSWEYrNHV2S1R3NnNJYkNnVi9rUFpITlNLWmJZMUV1OU1rOG9pWFlVZEMwT2RzVjNaWjJIVTlyOUNMZkR2bjlEbEliTzdoRzBqdmxZejZnbk52a1dTQ3RISE9sQ3gyUmRYMDZpUTNOUGZaSEUwck02VXFxd0JKTXZlWjBIL25HUGxXcWVVRDhkYUhUVlVCdGhKM3F4VWdSZVZxb29HSXU3ZGthR2FvbThSSlNxbkx2aWVLSzE0RTV5bTE2dXUxMm5xOVBETXptSm41ejNBZW1JcUlNZUtEMEhzZmVnQ3VNRUdXL2dHbWkxZG8zTGE1OWdPTWJZVENOcFdpVXdQZWdnQlBTL0N1YlFGaWVNbE13M2tIcy94VXIwM0pqMmxtVk80K2pqM2grckMydm0rOTl0NU92d05UbDdIZllleGFrcU9ZVFBTNGo5RUMwQnkzOEJyc0lTQnArQ0RwdFVCaTgxSGhCZ1VLbmFRU0RRMkVCNG1HeU9OenNmOVJsdTh4NmsrMG1VbGxMeGs4aGpOb2MyemxhT0kxSE1vZHNsM2JKNjhCM1FVTkRLTDU4TTRqYks1YTdhbmtBZHFyVkhxelFUZ1QrNG9TWThJVENOVHFmY2lMQ0lIUkhpdUtIOCtFQVFmOVIzcGZxTTVCb0ZDQ3VPMTd3SlZwQ2JNWlg4U0JucFNBRVREUGI4ZUJBdElCaHpPQStpeXdsTStUMVRtMjg0alNyVlJtR1Rtanp1NThQMFh3TXBWb05SOURiM1FsbmZGcndJbEJRcUxVeEpJOGVqVSs5andYdUI3aXdldFVOUDA1NFBDZ2pqTnp6bThLV0FVYkdOZmM1eDJMcThnM2lKbGpwMkN1N1ZreUorMVJHQi8ydzRXZktyeW44TjdDQnlTQ2EzOG8wcmcvN0V3VDFMazdTYmJvb3FRWFR5THJzSThQRURNdmhqY3dIS3hqeU4xUTV0K0w0Y1FuaWUySmFlejlxU0FyWDRyQVhveDlmejJKeCtldWNiNzlreWtjMzdNZnNUNVJwdnNxNWlQS0lwZ3hhQXZ0WGt6KzE5Njl4L2Z1ZkZxemRmVGY2cmJHU3pXL2tmUUdJazhUZFlzSjZLVXNXSzRsVFNXcDFPUFFpbm05WHJHeDJnSkxZME9UUjFrb1Z2WlZTeFdhZU9MOHllUnE2eG0vSjd2OVY4djNTakJpZHBhN1VaQVllaHk4ZERUYjZkNzZpY3JHaTErc2FUS1hYZFY0NU90dWJIalVVVlZoV0k0ZnhZMWk1Q0tTbmUvc0wxWllQWERYQXV0bUw3R01rZXQ3QmdoY3R1WnBkcHFYUTlOTS9BVy9ONEVES1hNb2p6YW01NTV1c2pSMDI2SGpEZ1NLWis3ZDhvcTJYZlMvaHdqRHEzSGhlY2RKWU5xSTMwcWUvcWVuUDBOK2t6eUpLT1NUK0tvOFl6a1NFNldsSzdXcUJQVVJTY2JRQWRJbDcyaWRHQitiS1JxR01FQlBudGxlS0xkZkhBSmppbXJsUlpWSG1lZGFsYjF6M2FKTEdudm42eUVDK0huRnBGYXFsZVpmc1Bla2w2Mldrb2Fpek5SYmJhMDdjMnMzV09oZGY5czVtK2RBMmp4NXdTallNdFlsSFErRkwrTHhXanEwM2pMNWUvS2FhNis1NXIzWEVKeGQ4OTd6dVpFNWJtWTB3YzBVV2JvYk9MT1BzSmtuSGxmZlp6LzNEcjdLUmtQK0h1dWJVOURNczJ2L3FWSTUwWFdjN1IvSjZSTDVhN2lQUFlXREV2RVNvWXk3bVNPcjdvTE9NNVkwRzkwL1E3bVFkUVN3TENWcVZzTkpWeDJOdzNQWkNHWVlsOWVGOE5PMFhRUzZ1SjR0WnB2Wi9oWGJyZllxcnAxRWU2K28wOFpDb3hFNzluL1VabWMzNXVhK0hxeFZGdHZyaktUdE5QV0Z1bDdPOXMyc1hpSzJlZW9nSzNSU3ZzWE1oWDJwRUhFRERpVmk1Mi94dUkzWjNaZzd0cXpCZzFVbnR3dVhGNkNOTzZzWXRDNWgwTmF4MWpjTzNoZ1k4bmVVWGNEOEY0bU5KSElIeDdUeVNtNjhPQS8zSVNzRHlEb3U0enhnbDl4Q0JRaTVCcjBXeUNMN3RRdE1yOWVjYUxYdVh4QkFNUmRxVm14VnI2UFUwOEtxMjlaaFhGMnJLQlc5VVNkNldXWHZvSnhUdGNkTXJoWUpGZnhxb1gxNmwzandjNTJ6WnpmSmJIajJtbXV1dSs0cXJIM29xUFFzWmFiZTBEMmdyOGI4V1RRNE9UTTVsa0h1YzdBS2NhRmUyQStVN3hrNWtOTzNOSFltZVNRcGF2NDloSS9QcSt4TzY4YXVTL2NmSENRdWpGK1JYSDFLdkNhVnV2Ry9odnJ6VnhyRFJtTzRqYk5HWTNGeGUzSHhBZUltbnBkNEo2alFPNlY0NDdVYmNhbWpnMFp3NGM4MXErRjE0N25tYk5MeDYwaXRDT1ZXdys4a3M3Q3E2elVzdVFvNmQzNXltSDBVejc2OStBa1R6KzUxYTk5NVdoRHZwajkvODd1Zms1Ky9zaHlUSHdhUjRoUFFpd2FGdlpqUGtsdEkwTUxTbFdHeVUxaWRaRHhCMTBLWVViUnd0VVpkRlEwMzBtWXBBV043TWljaWt2aEZYZklYT3VmOTViWDl3enN1dG80T0w5c0lMR2RqN1hoYzg3UGpMeXQrYjlodUhFbFNjb25xN0p5d0I5bEtCbmYvWTJUcnltMlNMbGZTQmdqdlViVkJtbEZhRGp0ZGhkWFk4dWs5bHlYSDdteDJGcHRIT084YWpKNDYwclFzdjFpZWFSOS9XL2RnVktZMDYvN0szR2cwOTVHa1huU2l3R3VWcTlQNFB1Q05qNE9jdWxXNEJET1ljaWNmUEpTRWx0bEg2aVFmOGIwK3NpS0JOdHR1cnlXeFoxbzVPbHFTVG9KTmt4WUd2Y3JFMk1HSTNuVzQ5bjBuRHA4NXJBNE54ekYyLzdoN2RPT0xiaTZUSXE3ZmVZckxYenRmdzE5a251OTg5clA0RFdla2VlUnFPS1lFNDk2UjM0cHc2ODZ0b3h0SEd5dndwVmc4OTIzaWxnZTYvdlRUWDVTNXpJZnlYR1laRER2TlFGeEQyL0JBUmhWakI0MnhrK2VXTHR3T0d3ZGQ2ZWZ1NXdrc2ZpVElxL1RsMlBZZG4vcEdhTmE1aWV5SGFQb1RDSVphdEx0MlhLU09HVmcxWWFMdWcxb01mZVVMbUdaUXhFTWoxSFFYWFZEd1FVU0NMYzRiNGFnMkZkb2ZPUnFwSUlhRTB1ZzZCZ2NKaXhwYjJjK291c0pZQ21yL3pxY0Nudk9FUDUyTVg2eWFkZHN6N2YyeXIwMmZiaDNrYnhpTHozeTI2YVAxQnZLeGNGTzRDeHhVQnBIdXpsYit5c3BsUzh1bmJycHNlZm15bHBxWUxxaDBHdGRWbDRHK3BOMEl2SlpaUE9RSTNTZFhZdGxtOWhLZHpIOXJZWE56QVdjL016dzlHSngrQWM3SWZjdVh5VFBCN0J1UkFxcWhBT0ZjaHRkUTliaEdmZURhOTZEdGl1TjU2NGJLVUluaTE4MEpOU2JHODdZVjBzelBpYk9kT3labmhWa0I4NHFCWC80TitXVGhRT0dhd3IyRmp4WCtzUERWd3Q5TExCVWRtbUNPN0NNSHlmWGtkbkkvT1VQZVNONUhmb1A4SG5tS2ZBMWpJREJrZGo4NWh5dlh5N0ZXSnFncEtETGo5NmxrbHB6RFU1RWFUV3M4SWlNMGJUcFVPbUZSL2tQNE5yVHR3YWhCNklHWVowaGJaUlJVZDV2S3lveVNDa3hDcFFiZG9ZUTV5dkhkY29zalQwYzU1WXlUNmVYeVFLdDhiVGNuR3owSmNOYnZpa0Z1VHBUSHh3a2FJN3M5R0pWanRQajJjL2tWNGZFNFBpbVFKcG14TGkyZk9haHlnNjROeDZ2N3NiQ0tjS2hVNEtZeFd6S0dVNnczU0NaNWV5WlBpdmZXVDJWaFlnU0x3aEsvR0gwbzBMemNvT2pUWVJKTFdYUkZONVgrbDNGZmVtTzZZeUh0bzFQSEQ2SkxZWjRiWWtIVFNiRC9KSnhzT0VyaktRS2dySEl0dlVHWXhZeEJTbU40UTl2d0xtUjV3VHhKVUFEUnJSRm9wblRTWEN0MFdVWlBqa0YrQ2QwRVEraWdLVWdvQXQ5cDlOZG0xYUxwVnMyQU56RmRqcUdGekhSS1JDaUdBb09oNU1LZ1ZUaW9mZVRkdnRqNUs5QWpHSE80aXFna0t2ZFZ2Vm84R2JjeDNSajdMNDlxTnB4bEdaZzlRc3VvZ1dNVGtuckFzMWtNYWhMQ0YzdUh5N05aMWJLRXhkMlltVzJCOWxJYXhhcXBKOFY2V2t2c2xNSFFzb3FlYVZpc1lrZTY1bnlSR1lwdXdNMFpsc0J6Z1JSZlN3anhiRitubWlrcVhOVmlaSHlhUlhUakxoUExOTUw5L2F6UXR1WkFtbkF6UVFUZDFDaW9XcW9HZ3E4Z0NrS3NNQ3VOVlYxVFhHYVpRNGVwaW84b0xvaUlxUXNRR0NKMWhZa3FoV0hETmMyaEhoT1dveUkrOGY5VXE1YlFsU3pVUDZva0NrTTRMSVBUSkl3ZmpGUXFnOVVRZTBaamRrTmpvSmdMcFFwS21tclltb3UyWVJENTRCbW9PWU9JTHdxRngwMDUrNFNpS0NhU1NhcEFXOU5TcUpCRnczQWlRa3lUVzJmVERWSk5TdGN5RGtLanBTRTZCTkcxaXRkSmRjOE9EVTh6NCtIR2RzOE5Bek5WRklmQzdidUdsN2o3R2RlaHRhSlM0c2VLNndxWE05TUdOVjFCUnBsRTQ1UThLbzFiekJDNkQrU2Jremp3cmttWjZlZ3R6VGE0d1lRVEtScE5yZWpYVGFFTDFTRHdtS0dYWUNGbUYyNmhvUnV6dW10M1dyWlFmUTVxaGxCc3k3UWQzZFVqWStIcXVnaFVUK2lhRWR0Tlp0dTZYVUVJVWdGZHlEYXpGektzVUNweDVoaVFkOXN3UFFGc3drd1VRVEZaa0lvNXBrSy81bzdPeXNSSHBabGFXNUcvNHBGUU4zMW13M2hBcFZzcE1lZ0NHdVhBaDBpa3VWU3hnRzhvbEZHZW9VMWNxRUtHRFFwTDVTb0lPbDdNbUs2WVM0NHJtSVZvUTRvbEZJOGN0V0pnTmx5Ym95dlFJTUszalVRWGhqSmFhamlLN3FxWVd5UW9uRmRIdkdubEdMVXdJZ2xJblNZVW9VVldGQ29tSy9iZ25VSmZZSTZxTXpYMG9HOFNnN3VxV3RGQTNmZVUxSzhGdWsxY0JZSExWWXVxRm9QdVVOZmw4NnJ3ZGxRMTRqazJEK0lhL3hiNUZubWlFQmFXUVFLNXNWQkljNVI3K2QvbmVVVk10aTNqR3NVdWhpYmRYS0k3Nmpta1RyZHBIaVFEcEdCdFB4bE9TcEJ6aEttZkVIcnBTUHFxTHlpOGhheTZuVzBXdVZhL2JheGI3MnpjY1dadFBOVC9hcjRkMkFFYW5rRlh1WHF0YVF0SHk5ajJtWWNmUE1hMk56YVA3Yi8vdnpmYVA3K01qdEt5WHdOZG0xSlFodEhQb2hyUURlSlNvQVJXWkJ2dy9oeHJkVVRJMGZVaHE3Y2YzRlpKSmZKc1lTckFOYWs2Yks5MlR3NDI4S3hiTDNuNHdheXovZTdZcENsRGk2a3VYSVJDSkJtVHNhQ2E0a3hpSUQ0dTY0eXNGaTdHR0w1UUpuc2d2NURCR0kyOFZaWUpHaEV3NVFnSWNHK2ltZ21KSFpZaVRML0FYQ0padzNVc0t4YkFkc1QrYnlQZ0VhaTdNc0lYQlZqUWQwbFdURnRLYVQxZWRPdXhjY2ZpSFpFbG92SnJGdTh3NjRtN2xEaGFVczlXMnF3OERMMmoveTZjOFBhbE84eWs3aXhHZThwS095NWw5YnNYN3pCQW4xdE1IQjZWczFJTUordUg1STVTVm91QkZpNDZTZDJFczRhanN0SzZKVDkyS1IzQWp4U09qWVVkZVVmZlUxb1A3emgvd2JpU2xkTFduc20rU1IvMmhldVVZN2o0TSt5dDljTFJaOHNHUnZzajhpRVVlUG9TekJMMTJOSEUxOW5OVzFUSXFsbFQvK1NGZWZTLzFLNHRCVzNnQkxFMWYzczFDb3kyVjdJOVRRMk1rdVcwcTNITmFLbDJZSnF1VWJPZDNqUENidDdWYlBZaWVQK20rME9mc2F3d0tsc2hWeERnMGx0dGVrRnNhSVp2QUVXeDNWSzE4UXk3YmxEWXlPMjYvNGZQOE9SLys5KzhjVFFQLzIvZU1KUFk3QWZKdzRVbXRQNzM1UklXc0c0cVBjVWNaUThKQkNrdGtldVRrZHZMb2d5Ujd2SXNmNVJMY2dCU3RNRGdVT2RZQVVvS0FKZ1RWOCtITVlvUXkyUTQyVS8rWStSeURpbUFFbGFka0tjeFZGLzFyM3orOG14Sld6a0pYS2FXeHZ0bTB1VWJYckhWMnd3YWRtMWg5dkwxSzY4OFVuSENHakJsN1dnWFkvamoyZFY3WnJwRTRkVzZjby9TV3d1TnltSzk0UVNWMlVCVm1UQlZlM0d4d2xwKzVwWm5YTTB5d2w2c1ZUc2UraVIweFZ0WUxmNEJVTUd5dGJZbFN1bWNFdTVaQXlLYUhqNjZET3htN2ZpUk4yWm9veUtiOWNPaFl1aTlsWWd4YlRhcGhMMzVUUzZZdmI1M0kyMEdSbVVwb2JZNzErQWVWMEZXMWtQZjZaYTZnVUhNYU5ZRE9jSXlPak5GZE1TQ1ZKSzQvdUkwSmdkSXh1T0ZwTEFJV3NKekNuY1hYb2I1ci90bGk0K2xCam9TaVl5a0FDRy9nOUV3QXJHRWMxdUl4Rkh1d2RwMEVqWXBzQm5IUFM3eFF6dnJlVjRqeXA1QzR1bGl0c3BJcklQMDV0QmxDcnNLZUZ1aVB6SDlqQTlzbHJibVZucngycjdEZmRJVHRWSlVDZXZrVEoyV2s2SnJha0ZKTjloU28wVklzdk1sa3kxVFcrdFJFbVArZlNrcHU0Wk9naUk1RTFhcm9hbnVYenMxT2RFY3JYNUU2TDNOdXJGODdPUm1YUlZYS0w1ckhqZWI3ZFgyM3Q2K1ZwdVFZdElrZElIMDBsNDE4a3Y2djZ5Tlc5dmxFaldOb3ErYjNrcnBRRFkvKzByVFhhV0dzYmh2c1p1czdXbnRMMVdvcVJjRE1sUHJWZW5tUVNyTG90RDVydERDMmd1b3NuSVVycVd2SE8yTmpyM01yMmlEZ1orVldxM1ZDVGJDSDVQWGtuY1Yya2lOSmVPUjVFWWFnVktzazdkTlZtVG8waktxRlQ4YVI4MnMxNXRwaHZGOVZtZldEWm43bkVzZEpmTG01dDJyeUtuWkpGck9kdjZ5c3hJbDh5ZmU2Qmk2R3czRGw5d1Q5VU5YOStLWFR1MTdPU1lsdkhOMWw2MEtZU2NZdHJ5RUVGalBMeis5T0pxdkx5QmlYMDVuNGpnTWtrMmpuUkp0YlJicnpuV3N4ZVprc3lSWlpEbEp5K0ZQUktVVTdzWWthYzNjdjllc0dqWU5Ea2lmazhUSC9CaDVSOEVEamxUL1RscWJxZjBZTVEzU0hrS0dwT1NoblNkS1dWWWlGeFZodnZQNVc3ZGZmTVZIZnZyUXJVK2VKbS9QaWp1UHc5b2l1YmlZWGZmQUF3Ky82Y3laaHg2U01zRy9QZjFWK2pyeWs0WDV3bDdnZVZkUGRUWVk1c0R0MkRMSkpuNlE4VFIycGk5RkFuenNuaXFUcG5xc08raVBFVFJTWFpVdTB5NXVsT29MQnE5SXhZbStpalY3WE9NM2VPTEFiL3lFSXZUWCtMcjZ2TEtSVnU3WmJ3akJiYUxmOW55aEtwZGRaNHFkeDhqaVJjRGFIeUxrYmtaK1dDRkxWUGt3eUhQN1A4b1lQVEhUMldES3hhQXByTkhmWjdPcmdoR1hHcy9CN0JiRm9KSDlSM3NqenF0bmJBUFRkdG9keHZrOUtSTVhHejZJOGc1VmRQcHZmQy9JK2dkZzg5M3JRTDJXZGYyVWd0a2YyaGE3QVB2T0xWei9MTnl0UFkzWTJSMTVuazdxK2d3bVFCZDVodFI2SHQ0anE5ZFBTMEdkWnhjWGRKYjdGb3Vob1dxcWlHY3NweGphbHE2cEZ0Y3RMK2pOTGN3MlE5L2twcUpaWHJscmlkaElvOWlyN1ZVN3RHSTV1aVdhSUdWZXlBTS9GYnAxcjJ6NG51TTF5dzJRYjlRR1Z4VjE4ZHBWRThUbXRwMllkbWlCWk1qVU5LbzQ1b3FTR0lFQllxTm1WL3Y1bUlPR0lPUXlqSjNPNnhOSWlwYkg4dXgrdXZ6NXNLQjNPcDRHNDAvWllkWStod1NZdGMvbE52eDVhRmhPRkRXNlNiZ3ZjQzEwUWRSN3gxN3UyV1czYllaT01wZlFmZUxtcFVxck9lTmxabEJ2ekpWQUl2Sk52OUxvSHpoeWFMdFdEcHdyK3JyQjlmVzVmaW14cmJJM1gxNHQxcTlvUkI2b1JVenhhajd4QTNFOGlKZnFYWjFwWE1jUXVTQkxobkhiRFU0ZU8zd01WdVY4LzJtNmw3d0d4dFljb3ZxVE5PdE9RcUJDZkZ1alVFS2E1S3NXU0NqRG1pVGJOOGwwUGN1aFRlUmJKdys1NXA2VnBiM05Scm5kV0Z6ZG1wLzd4a3g3UE55ZW05c2Vqck0ybWE4ZmJSK1luei9RUGxvbjdaVVJyaCt0dEJmU2RyWm5aV1ZQQmtUaWluOGx0YXJHSFVMRGhibWQ5M3VsdWJtU1IyN3lnMW90OEhjK1M0cHh0eHZ2Zk0wWGVxMm1pM08rNU5lUVN3cTl3aVVnQzd5OThQN0NyOEg0SFNDRGtLWnp4TUdRUm9ZWUJBTVpYeTJGVWVpbnczWlhUSkxJK2xoMy9WeDZleHhKd1ZYdXFFN0tqTUxMdzhPUlFja2tqS0VzSVRxYU9pWjZzZ1NOekI5dGovOWZUOXJEeXZLNHJ5eUdMQUY2QkRadVRKL0hRcmlDS1dRZ0JOVU1HQ3doc3gzSHZodTBHa1g0SUExVnhxMDV4VlgxMlRnMjIwNmp2Zk1pcGw0NjJVc2ViUWlDUnhOaE9BdG83ZnRMcXRxS0NOd2dMby9iOHl3LzFHcTVqZlp2MVpmSVlsWXZ1NEdmOFZ0b3RrMTlzL0tYUnNzcVJVWGRIZ1Flbzh6M0I3Wk9TbEhKYW9WTzFVa3h0a25sbGwyTktrbmR3N2diYm5zTnc2b2w3U1V1UGdEN3RRT25hb2Z5SklaZERBemZaNVQ2UWQvVy8vTklhZS9ERTREVytHd251R3I1MHNXZ2FyU0pvYlVXRHJsZVE5Ymh5VzJTcFVLbk1DcGNXWGd1eUJ1RmprUkhYQ0c3UUJMUlNRb0xESm1MVWZLRHRXS0twQkZOVm93bjhDbnJFM0NZM2N2dlV1UWdsdEloRUhTcElCS1BtWlMwTUlBWGxrMW1zU3ROOUErYXJONEFSWldTWmZidVpjWmdhalRrNS83VjlzNWZ0RmRXMjZUV1h0bGVQSDc5cFl1bjlsbG9mc3htVjlQMlAxM0V5T0s4b3NnRll4Zmh0TGtCY3l5TnhUWnhoUWtYeWYrdk8zK20xWitjMlp5QmFlMjR4c3hROGR4cXE5eWI4c3VjZDdPQ2hmbnptTG5WTytjY3k0WlQzRWxZSGZjbnNFVHhIVGZkdEp3MG00dk5Kbm5nSm00ZXNJMGJyeWRHVW13ZUxFZE5zakNIV3hhYk83L3dJek5lcFJoa2I0RlZrZTNOdFk3S0dzdGZtZUFpUllVYVltMC9HM3AxZk80VzFGMjNNTngxQzZBSlRFb2F3WHpuaTRjT3Q3MGthYVlwTVE2cFl0a1FodzRRNFFicGN1aVF4ODZYUDdMRG5iTlBQZldQYVNPRjZSL3ZBcjNCdDB0M1AxVnpkTE9XcmhmeVd2Y2ZJNzlLUGw0NFZEaFdPQTdVL01yQ3RZVWJDczhIdWZWTTRhWG9wUU1Dalc1M2dVYlozaURyalVjd21sZVE1MHZqSlM1UTZVVUpnUFp4bzBROUhJNXhzVDRjajhRVUk2Q0hxckg4VU1RbVdNWGtJWlRRUUZIR1BYb1lWekdHN2ZzSitSVnlqTkI5SUVkU2toRTYwNmFjM3NCZXdVaUZ0SlVLQTFLbEJCaGRmWkRTcXdtdFVvd3FqaWdkRTZML252SWM1eWIxN21pemZIazRIeDZ6WjUxdGd4dlhZdjVvTWFFMWNuaUxIRXBEU3VnY09iQzJxZzcraFBRSW1TR2s2UkVTWjdRRU1zRERsQ3oyQ0gwZEt6R2IwanRvekV4Q1Q1R2pCSzZ5WEtSMFNHakxJV1NSaWdQc3BxM2IvdTVWNCsrLzlKVnJyM3ZPYy9iZXZIRms2d2k3YU92WWtNWVVwQnlWcGtkV1Y0K3N6RGtnRTFmcXM1WHV3Wm04L3Z6SDRCRS9EdC9pd2tzS3J5Kzh0ZkMrd3VkSWt4d2lONklFTzE0YlNhdHplN3lhckE5NmExMmVwR0Z1OHU3bFRvYTFMbW9FT2FBazZHN2ppVEVhVzNBYU9peHJCa3pNTm9OcFRsUHVDcHdHclFocFhwYm00aVR0anZLd1d3U1l5YU9LdDhuYUVMVU90S2NEbmNZYUgzVXFTd1ZLZVhxQ0hjZDZVaERNbzNQaGJHTHRYQWp4Tk5zcmhWYzluQWJ0aWY0SXJlUGRYanV2cEpEbEZ2ODhhU0N2V3poSklKRDN2QXRmazJmNU9aZVp5RkR2N01rYWdwSDBEWnpMaHh6MDJHcGZZam1zYlpPc214dnYyeXUwMjA0K3lYSzRScVdFRkJiSTBoOFJXelVxT21OSnhVcEFUYlVpbjF1QkRkeTkxS0RVcWxuY05hUUJpS2syTXpHd1JUSGNCUXNOcUZqWklKck5Rb3hQTllSSFdvNW5LNHBRRk9hUnB6QzAxRUtUSTlFUjNFMER0WGFScUp5WUhQUlpZdmtHQnRneVMwY2pucXNFT3NnNGlsT3lQZDZJakVRSXpBOVhUSVNtRkFyVFZiZnVsTk1TSlNEdU9UL0dLVk05bHJrbThKaU9vbU45VlpDUFRKMnJhbUFZRmhjdUU5eE1NSThUcitjSW16Z0tNeXdsd2Z6MTBQR3d0SUNoVkZyVm53U0ZWdGNvVDMwUWd3MEZvKys0YXE1RXdoUmxSUkRuVzBRNGpobHBqb0xoaEVJSmlwWkdLTFRhRVNwajYyUWJ5Rzg3djJ2Q2VTeUwwaklsbHNVVXpOYUdqNmR3bnpFTVVtUlJyRHBVVXdRb3loZ1pvck5pYmJudmVVNm9PbzJnN3NWSjBBd3pOUXJObU14bTh4MTRTSjlBeTVod01hYTdKTkNsaDBDa2h1ZVpkUXhiVEREZWl6cGhWS3BxSUF6Z1BlcFVMV0dGQjkwMjFaMS9uM0VrenJuS3FHSTd6QkVoT3JyZ09SeW1sRFJiZUg2VlJGclZUSGpWNDVZV3VmNk1EeS9iaXF0RjJtajUxVnBpSUE0NkYxajdJYTc1ZGEvUkNDdEJXR1F6eGRBTExOMHkzZERTQW9XdHFrMk5FbUVxdnFGNlpsV0w3TlNPbFJSelRPQWR3YzByd2pBVW1Ub09id1Q2RTFOem01TEVVWG13WUJlV1VZWUdkaE5Oa0JSQUcrZ2d1dU55WGpVd2tRbmpmVm5HVCticW8yQUdEQjRCR3JJY2dBRUhQRHB6TUJZcHdiMnpVN293cmFRU1dqYjVxMkpaMjlPWjM2ekh0dFhybGN1YkM2YTc4MFhMT3FtYkpjOHpkRUVRSjl2U1p5K1pQMGxlL04rVHdOWU1RajJqNmJlVGs5bnk1c0lIbFFCK2lKT3BaOXZleVlYTmsrNEw3eGVjaS9zZlR0d0llaXRWVmRCSE1hRDBtT1dNWmo4d2pZSDVHUGtvZWJLZ1l3d004Y1d3SjhLZVB3NUZ6eGQrT3ZaN1B2bm9nYmUvZ3h6NGsyYXp1ZitXVy9hVEEwOFhacDYrOGNhbkN4MVNPTHR6WXhnUStGMFlqK1hpbk02aGtGZmdHVHZaR0FzWXN5ek00Tk5ycmRlcElMOTMyNEI1M3RybWJmdXUycnh0YzRrOFVPOW5GbGYvMFF0My9wWWsrTG0xdURDdW5ZdnZPUWozdHdBOGVYL2hMR2d4b3p6Vk9KVTFua2I5aVc5T0VqWUVINUl1TFFudU8wN1hSekwrTCttZi96WWh0Y01KcEhKN0FvNlJWMTJ0azlFNTFLaGU5eHdneGlUTkJvbFVNbnFwckZJQ1F4NXI0MUFnR3phc2pZbWpoUko1VmtYYlBnTHBCblpKZndTekIzNEFaL2ZoN0RUT1hvNTFSelN2cURteW9KT2pGVjBkdlJkWVBoVFBvUG1Kc05yN2p1eHJXeUx4TlZsNGdMckI1Nml3RkUzVEhWWHJnd1o4REpNYVZKbEpBQjBqTmc0Q0pZdDB1SjNmdzZKdkIzRDJac3JyaGxzbXZhalpucjlvSHFaMksrb1ZmYU9oR2FwcGFJSG1HRjRsQzZyVjFrWUxwbW8xeUNxZTRXaSticGpxNUQyU2I1R3ppT01jRGhETlBCMzNNWmJTNXprNklYWmhsckY0OG5QVXUxZ3NQWEx2TGQvZmd4dFR1eC90TVhLdisycWk5Ui90NjVTczYyS2svZjNmYXgxRjdIeERLQjFONnpLbWZubm42eVI2d3RLM05XMWJ0M2JwN0F4eG05Q0NDNDFlUThsRlhtR0xpS3gzL25vb21zaTdJaytlS0RKV2ZHbVJIdFl2STJyemhpYmVRdlc2SS91dXltMnpkNmRNK1RtRnBhcGFwTW9iM3Z2ZWx3QjdWdFV1RjYvalNsdDl5MXVtbUlWMGhqeGVDS1NNL256RTlaQlpST2R5RXgycU9qS2xwVTZrNjZTWE9LUUQzV0lrdlN6YkpDOGRLWU1RSjNqdk1xcGpHamFRN0FvZkdFM0RDTEl6NjllUHF2VWptRzUycEY0ZFhiOU81cnJYWDFYWDdNYk56NzkyUWE4N2ZxZ3M3andOaEh6dHVjMks1VlJMZWxJNmNjMFJMTyt3aXJQWmM3UHpQNS9jdk91SUxtUVdtOUNQM1BWWTFTblg0M0J4UWQrNjVhNkYwT3VkdnZ5UG9QUFl6Zm5zNmw3MTRrdHF6YXI5Zzg5K3B1blBnb1cxTktrL3FaZFlMbVN5bnVoMjRhTEM1U0FkL1ViaDA0aGJpd3dmblU1b3VVWWJNOXVXaUJ2bzQ4NVhkVHZuMWt5L3FOT2R4L2x2RUd5bWF3VEdRV2ZZNW5seExRdzY2VzdMeWtnb0I5VmxSaEc2clliZHZBWVN5Q3R1N3IvSDBkckxzeUJ4M0k3WHBleEJRWmFSNHpuSjg3YlMwZVJuVHAvUDNmZnRSQVdHQlo5SFZTcE1BL2ptYzFTMFdYT3FQU2dDZzdsb1pkRTAxZkE5UlE4ZTUxUTRKdE1jOG5MT3FXSENwMDBFc0RLaEsxZHdwbmtXc0VjcmRCdWxCdThzQmF4K0ZCVDVSb2NWSFpHVnJZM0RsZGIrTGpMZmE0bFFJdURxWEVrd2VhaHVhNFNyMVBBTWpacFlYTG5PelNvVHhVaXpWQXFxc3E1bzFMTUljU0p1WlpSem5mb1JaWTRqSE4rd2dVU1pJZWg1WVZzVkJDZ0hWVTh3eXdBcVlsRHlhU3diUW5XZC80NnF1SUVKbi9jckFUNklwd3dWMjRLSHNlaGI4K2N3eFZoVjhFbXBPS1Y0TnRVOG16M2F1alFPa2dwb2taRmRpOHZxK3Y0azdYZVU1aHlOeldTYzhXenV0SkM0M0pvUldXdEdvRmNSYkZpVkNUTWdCQUN6dHEzd0ZqT3FFazFYOXZSVklLU21PbHRucHNITjBqR3NGV1dxMmF6bTF2QXNUTGxjalZ4OEZ1VkN6TlFKcmdkdzVBeklVaVlteXk5ODRXK21FM25zQzEvNFFnQWZhWHYrTmh4M0Z2TUtTaklvRTB2NzFpV3N5Kzd2U05MS00yVldhUmZSdmwxcGwrQVhPYnZ6cmloTm8zOElJMXFNM29mb21RK0VNVW1qWXB6Qy9ML0orNUt4MHQ4SFBHOVlPRks0Q2pqZk1zMWtPS0RNWkc1SmE0MW9TZjBSM1M4OVRNcnJUOWdMSnQ5SytCa0pldFdWR0ZVWTl5SXUvRWwrVmxrK3ZqQTY3YytQRzRNNmFmZjJ6QTkzL3FRMlA3ODNOaExOU09ydS9rNTdiNXVyZmxHamJ0ajRmRWVrbHFqWE5TdlZPaGRWZU5FU0VRaU9SVkg1NnZ5eDJmMTl2bitoUG1qczZiWDdiNWpiTnhmckl0VVRyVFVIcDhCYTNVcko1aFV2cVE4Tzc5RVRjK25lSlROU3JOR1IxVm40VmIyNFpvQysxVHVQOVpyWGpZaWhmV2VmbVFYUGhTOWpzbFBNUFpiZndtNHYvN0lyeWZwSFYxcHBPLzJlYURiQ1JXc0Y1aGRrdkQvbU5Zbm5wNm4vRkdOUDRYTG5HMDN2Sy9pbE1PMFhqKy91RjUwMDdvVVphTFdkT0hWSmYwenU2THp1bDU5SzM4WjMvbkJadWY2cFYvNSsrb1dyeWNIdXJmcUhucXFGUC9RNzA3emJiOEp6R0lVS3hyZkxpTDMrTUIycjhBRVYvN3k4UUc2OXQzWC93L2UzN3IzcnJwMXZ2K09kbCtaRklld0Q0NE1IeDJkZjhJTExQL3VPZDN5Mk41ZW5xODloSTRtbi8rM3BqNU4vSmo4TGR4b1hXb1d0d29uQ2N6Q3V0SU1FREFnVDlBS2tjc0E1a25TMDNrTVNDbHZhbUVJcHdlSGsvOVNGM3h0aXpVYllIc3E2cENqTzlMQmFSRzgxbmdSR1NVOCtSZ1R3SG9ZUHJTV2daM1hKZkZLdHhZODJldTNHN2JjMzJ0M0d3bDN2Ymx4MVZjTXdGdTlZTk16cmExRlVFd3U5dlJzdjZjMExVbzJqV3JrNGUrYit1ZEpIR3czWDhFQlRNdWVjT0hvRTNxaG51TnZRbDV5NXQ4TXc3M1pSRkVrR0NUa2U2MGIwMjJYam5mdm5lNVZxZDJIN25VYTVYcXZGY1kzek5PVThPUnBzYlFmSFZoWmN0N0d3ZkpUZ3I2TkVMRFdiUzJKbkI1SERYTTJXUWZZVldVTVVsTDFxeWloNUJXZ3FKbWozbW1yTE1QUmQ5Y1pLSUJsdUY2NHIzQVc5VG9iZXhtbWVUWkQyYy83YXk5b2lqWHM1bXhqa1d2RStNZzFaUzZVQmMxdUcvSzFLWWpET2EzTko5Q2Q1VEZ1ZVRuS0pibjZHVzl0cnVveG5YSmtSRzZzNmFEeHJlOFRWRjJHZ0d3YnRsQU05ck0rY01IVVg1RVFiczBHNTYxRldmNFJkeW1zcldGNEpFOElHTTlvVnp6VkI4Mko2NGpkQjYxR2I1QjFpcVdVdDNuQ0h6N05Wb0lJMCsvQ1hRZmo3azQ5ZzhFMHpFVjhYWVVNb2RJTnFkaXhUUndoVnkyNFFuLzdURDgrQTl0WXFBWlUzc3h2NXkwVm5uZE5QTTlma1BrKzVFdmlxcC9yQlJONy9CTkRCanhTT0ZyNjNVRWpiazVpUkJoYW15YkdrdTFPQkt4bWRyMzQrOVFFc1k2dklETDVHVGpDUnQ0NGxkS3FFdmxyUDRmWkd3endhVnJaY25Fd3dYbVVxam9RNEhIM0YwTGNORFhQYVZoaDdnckxIR1U3cllRbEU0SlN4V2hrNGdidW1HNGIraEpab1Q4Z3YrZzlHd1hLdHJHbm1Sa2xCNndCalM0dXppeVFKcjNKMFVxbGx3SUdKQ2tlSHhmSGk2cWJhVVRFbUI4MU85eERsODR6ZVRXRmluMWRJWFhlY1A0Q2oyZWNxRFVxMXFocVluemNDOVI0VnBzRDR2SWxmUDFlMVRVejRGeWIweVZCaHJOVm9iTWhhRllibjZGb0VDbXpOVDFyWUZ4MW8wLzhGdFA5MWhiMkYyMlFlMkdzTGJ5ajgxOEtuQ2w4a0JSS1FMcGtqNkgvRXRoNUozOXF6TnZWQUlpSkZFcmNXZnNFK3NCNVd5QWJHMWtXSFJiU1BvbmVHMTFtTXFVeUlaTk5HYy8xb2ZBN3VjUXFkQ1lJeWJFVnY0bm9rMWxQNW83L2V3Y3N1U05jLzl2YjhUdkwzbWFUU3hEOGFndElxWmFqenR5RUZWbFN5Qmxtdm5RbTBQdmZSYnJpNkpTMkRGendLWm04KzR4R1NjWSt2d1cybTYydmowZG9RVHJLYXFjTm5IZ1ZFTE91bnZaaHN3aXRrV0o3T0lXU3ZuRFlJY2JsR0JmVzU4RGpmbTA5MHdhcUFWQVFEQmNkS3hYYUlWZFlDRTMvVGh1T09CZFp6RkJUTHBXQUtMSWIwcVRKREJzMGhPOThFMFJUWGJZRWVONk13RHpSV3hPN3R3T0M4WElHVitlUml4blNITFpHWVRLZlB3UVltTnpPbFErazJwU0ZPQ3AwRGJReitZZHI1NThuaDI3QWpJOGNKT1VFVWFxSWxCdTZ1UmNnaE9jKy9vTDRJaTBNQnlIUGlrRkJhQ2t6aWtNWmE5SkFPZWliVFZFNW9aQVNDSVJDaUlEUTJObFhPRFk2ZVFGWEQwcTlFdFZRZ3k0UTlDZzlEeUF4VmJvRm5qS215cEZBZExpRy94UERjbjNxL1FqUEdNcXBjQkh0aTZoZ2xOd01OaitqcmlHMlRJc1g3cDBWQ0ZWOXVuNUU3WmhRT1ZnZ3NNTFlQeEROQ0F6aC9nTllNZ2JQMVk5TzlqNm00ZHdaUCtzclhFcWxDU29KTkQ1QW04R2FzMllzZUVGbDV1eE8zSkFwT0t1dDg1RlcxaDVONS9pSE5acE0wZDc1eTlySEh6aDVvTm1GMjRDdFB3aGY0ZXVEQWs4M21rODJ6dDk1NjlySG1XVmpjZW10aEtvYzlSSTRXZEtCd2x5T09hQ2g2SUJ1TzAvNVlacW9oa09vYXNFNFlBK2pQaHN1MVpZQXRraTFZWm1KOWpDSGg0MmxsMVpFRWh4aWRqM2hQOG1xdUdHc2pQdHdlcjYwdE5mb2JxK1N0MURIZGRLWEV0MXBxN1RRUU5tYSt6cmowRWl2eEROVXVudFlaTjE5dDNsYVBiUk9rOFViU3VTeDBtRk1OMHZ2VVR1UzZpaFd0QWQwaEZJUmxTMG1LcEhubXpHUDMzUE1Zc1hTTktsWTl0bVo4WVdta1NXaHh4ck1kQjgzaFJPRnEwbFQxWHJlOEp3VjZlVzFjWml5dVdURXZiWEtobzdIUXN4U1VoWjcrRkhrVTVKb3RpZFo3Qy9ESyt5ZDRpUCtwOFBiQ2V3cS9WSGlpOE52UVV1djlpYUF4d1lHWUJMZjBKamFUU1lITGlYbGtZajJPcHRZU2doSk1ld0pUQWlLdU9pVkV3Ky80a3Y3L3ZTbm5RSmg5ZzhyNCtta2hmRGZ4SWgzVEhBMDdUR3FLcXB0ZVdHU0swRTBud0RLNHR1Y3FYTGU5cUd3NWxtOVl4SFNzd1BaMWsydzBHOWZmZW4yak9Ydm9JNGRtZDc3bUZiMW5UQmYvbjY0cWdrNVl1L1R5UzJzYXA1ZjlOSWlyVERXc01HMll0bTR4eFRKdDA0RW4wQTNkRWpwaGltRkZidURHdG9lMWE1MndXTWMwVW00NlNXbm5hNWNOMDFJcEhWNTI2TkRhMnFHZnQrUUZUc0VpOWYyVCtlSjcvNyt0N0ZPbDVicytUQTNOM2FWM2FSTEQ2QklaVDVsRFdqNFQ3Vm5OQ3l1M2VUcnhPRWp1djlhZGdwWUlYcGRvYk9pY2tCM3I4V0t6Q0JQUkxvaDgrTXpLa1JXWWZsRUpvRFZNdUtmSVZLMEFyZnQrMU5uU1JLeXRybXF4cG05bXNRL0tzdXNWaTYwMFBiTXJGT1BCOXNySzRkV1ZWMnFxcnFxS29rTW53R0lNd3JTVlRUM1M4SGd0MGpjVkdKTGFKSDd3dzNCblQ0SUdnM1lObE0yeDJDckdlMkxpUTNjS0V5VzlIRGxPWVE0VjFUbVhCdElHTVhMNitDUnNiZHhtV3kzNzVBbTdiVG0zN1d0V29PTnh4d3NzMXk4TlNyNXJCYjR0TkYzc2ZDUGJQTGFaeWRtaDdxQUwwNW1ZMzJhM2JEd1d6bkFiandQRERteW1ZRGxXSVREaVhHR3d3dmpRekw0czIzY1J6ckt5ckVna2ZhZC9SRjlEM2lQdE5FTlpoeWFYRFhyVG90ZVROTFR6RHFEOE9jN1ZGRWI1amJ5bjNLMVV1dVdkc0l4ZmlQL1lpV3ZYVitaTnowN2E4OXNYUCsvNnBYbE5lSG96TlVPajJqOFFOOGxWSXQ4Vmo0SWxjWVNJbzBXLzZwYjhHQVlZZEg3UFRwMVcwWTZEMHVJb2JnVnhNTFZCZndQNjFxUFNxbFRvaUdVSzdUbU9aUmFkUC9iSFdQaHptS1JqNGgzWnVBbEc5Mmg4OU9UZUkrOS9xRk9mUGRyUHZLWTZ0Ly9pclhtK29PODV2bGVRcTFzN1p4K3BSWUZZMEJyUjlQeWZJZjhHNzdXRytIVmtVbGRQUnI2TUViOVNYZy9sM0xRYmNsVExCemhEaXg0bmU3ZldGcGVBWGRRNnZZWGhjdXVhRmV2Z3ZmdEJxeVBMMTdTV1Zoc1gxZWZIbzRYR3NlWmdKZ2pKT3pydCt6ZjNyMlpSVksrMzJKSDdIajV6dUZXdjc3d2taTEgzM0ZjOTE0dFp1UGI5QjQvQVBaWGdIZjArUFVoK0dYVE5zRkF2dkxmd3E0WGZLUHh1NGZPRlB5dDh2ZkEvWWFDN3BBbzAvZ3B5Q3psRFhrdmVRdDVKL2d2NVZmSXhBblJhUmJobWlrNDZsZ2Q2amhJaVBmempiZHBWUWQ1MktQb2RFWXgvUEJqbitQdndHYXluSXl6SmlteHNtMkoyaTR6d0dFN3RhaU5wQUVlQVNuZWFWdzBTL3lpUEZzVXlWT2swR1NXTGtSTWc2TGFzYWo3cE93alJQb0tydzB6Z3JBY3phWUFEM1JaeHl0QWxpQlZnNGNySVZUdmRQQ09RdzExMVI5T3FHYkplcGtRVTZvL09qYVEwTDRDTU41VDFjcjhsSW5vUFFCWmR3NndYdVhVNEVJbDBMYUkxVDVhL2tnZU0xM3JvRnBEZXlneDRXWTZyMEl1d05BRmFGL0haVVZHaGt5ZVdIb1I4TE9DVjFJblRVODdqWVRJV0NCZTFqTGs2OGxIZ2lnNEdjK0tWbDRsZ3F4c0VrMk14a1VrYWRCQ2tHVGZUTHBZTDRYVUs2anZ0UlphUmFyWmhkejVBZkhkeFZtOGQydm1tM1lsc1BkVXM4dGVFRkxOcWtYL29iYnhZbVNsaUZvaW1DTVhWTkV2MVRNdnhOTnNqdXFFUkgyUTBSUVNlNjJtR1lqc1l0a2cwUkowcmFvcWwyVkd2NDdiTmQxNWQ5Z0xFdjNZRnBwSXhqQ1FMQlRydWJJRUlzQ1JHSjRibldLYUhvREhvRTJXQ25Vb1Exd1FJWjJ4d0ZtZ0lsdW9vVGZTVUFRWGQrUjRHWWlpSXpWcUZvWmpoZ0pCTXRVM2daWnd4d1pXN2x2WXZMdTVmZWl0ZWpwdGNKVVowQmFhYWEyMGRoUHJhL0Y1S1ZEMHoySFdLRk1yRFFEWFhaN0xacFpYNTFwekJ5bW9RZ2paTUtGZDBWbk5oWWROVkVTUUdMVklXcXJxZXRGS2laN1dVRVRFY1ZrcGhXVU84YVF2QkVWeHl1SlUycTNGTWFlQnY3SG4wNDlCNGlzazFvakNRNmZZU3ZXNkVhcW1SNmJUWU1qOGROOUsycCtsQkl0VG1wMXpMVUxpZGtKL2dDR25ra3BTaUFCVjRLWUV1Zmc4UWF4N0dvYjN6WTZSdVRUYTQ4RTdxRVFFOWtaczJpZW91VjRWQS80MkdKYmtvc0JheldSS0t3YmlxZzRRTk1qTlJWTTJhbjRVTGFkeldDTWh6b01kYTNEQkRoQk5xWDVSMktOTU5WRmFjdGd0OFFsV1ppYVY4VkVWUVE5VjkwL1FOWUZ6b29JUjFLckFDSnY1RnJ4aHVvR0Y1a2ZEL3B1MDk0Q1c3eWp2QmUyNDZOK2RRT2R4YlZiZGVxSmNxdmZ5NiszVldkMHV0MEZLM3NoQnFoTURJQW9FSXRsc0VHMHd3TEdBTUk0d01ZMnhqWUMxbUZ4dVcwSXdBZXhrSG5PZUhzY0ZlajcxZXozZ0dyNzAyTStiMWZ0KzVWYSs3UVRhNys1dnRmblZ6UFBlYzg0WHpmZisvbnJxaUlvcHVXUktGZXBONExkV1MyUjdQMXNxN2JxckRwY3F1SkNoclNLQ29WMDNTSERWNitMV2U5QXFtTE1pKzQwQTNiWG1ZRWVOYkN0RzhpT0NZYmV3dmdhbmdoMkM4T0EyeFU2ellaaTJhRmFuZ1JLSU9uNGw5UndtcmllU1lndVVpSU42L0NteUgyaFhiRG9samlscmRzU0s3aEdQbFVFbUUyQ3QxZk4xV05CbDV2OXdFcGtjSmZEYUp4eHdvdmw5MEdrWkZGUnUrRzVEUWhxdUlSTHUvRW5oRnNPY01SVGNGclpqK24xQUhOYzNpb2VPMU5FMmt1cGYzOWI5SC9vRjhqcHNIVFpjYjV0RUdUSlZuV1hRVGR3ZUxqcDhFUk8wbk00NkRNQmNMTExrT2h3cHF6RTJVQjh6bU1JdXMreU8xeW4wYnU5dnJOK2xhNDlTSUtzSlFNdHF5bEczMFJER093V0liaWZwTXN4WGFNdHBjVWpQWkVQa2VFWmNFMGp0UUxSUkZxY3ZpWU1mTm9VYVBqZFlQRFMrVXlwODlOQjdzS21xeDhMenRqUmZmR29IUjkyWmRjclA2c3BTV2kzT2FvTkMzNktKVGJjeFc2MjVKRVVSN2JiRmY0Y1hIUmFHMjJsaFdIV3U1MGdQMTluR1JMeTRlUDc5K2Y3R2t5bHRMS3d6SFk5OC9pNGpiSGhkeUZTN2xGcmt4dDROKzZuaC9kSXYwdHdpTnd4R2pJNWtRTndVMGRXc2s2dzhaakNyK2tKS0Q3YVJoUE15R1k1YnEzMmVSOGlQTWlZbFd0a251MXQydDEvYisvamZmL2ZkSFowWmhHQ2pPSS9HVGgyOTk0eEhMc2t6clNIbjJ5SkVqdGkyMUxKM3FOcWdITWpRSEwvWEpLdk9sS250dmJQeis3emZ1cnUzOHVLSjBURVhUQitObGNycjZtdFlTaU5UbVgrbkZVdkhsTmFQcXlDWDVYTmt3WXRPam1sb3ZCSFdPWE5tNzhoVnlpWHdTbzM3YjB5Ukh3dmdVUitncVliSDlURDdzODEvbkdhWEw0MnlxNU9VeWJUbW9Ua1RoSkZseWVRcVJGMGZra2wwS0sxSFI4Nno2L1d1b2t5MmRyYzYzaDVYai9TUzBxZTI1QlQrMlhHSFlyZmlxS0dpSU42Y0tnajkyb0tlaGltNzdjYlhPdDBzemNERG8vNWJ2RitMeWozVUNWOENlajI0Zk40eU52cXM3eDJ1eDNXN05JNkM5b3Z0eEVnWlc0bGhEVlRjOEw0NmcvNXV0ZFFLVG1MN3A2QTUwUlJ1Zy9SSmhwcTNxaWk3Sm9wenpMdktyTEI5NnpEaStNQWRWRGxuZTBvZ3U5VEVVbG1GRVltdUpjR0NOZWFPeklGNE9yQWxJRWViclp5amN3VTZlS0UvTkNScmxtSTJwRDNNUEg1c01Nd1NUWmFENTZVU3JaSFB5WkxQVUVvamxaYWI1TEtIUTlUbk5jRzJlZUQ3ZjJtN0g0YUdhb0RzV1F2U1J3QTAvU1FTcXViV1lGeVJWYzBpRHFwZ3RHZFhCT3RMWXJyb1MxamNxUkZDVmN4SlZLMjdnRlp4QXJtbzYxZllhc21TZVdKUkxZV0ZSaU1PQ1h6OGVoeGJWZFdVbTZiU1NOdDNzbWdheDdNcDlCMFpXVUhCdmtpUTQ2NXNLM29GZ042M1pYeU04M0FNdXBsYTlDbmJRSUZ3Vkh5U2Fhcm1JTUtGTmRjdXZ3T04rRXNyV3laRnM5N1BDU2Q5TmVXN2wxZ2R2VzE2KzdjRmJWL2E0Q3hlK3MzTHJDbTVaV2JsdDd5bnkxd3czL0kvSmo1TVBRWnZjNURpR2tZZ3dBR01NVWg3dnM3WFRGRDdZdUpPRThqNk9oSjFUZStXam1BeXI2Q1c4S1JQK0Jra0JYVlpYVHV4NmNUeXJxVzc5eFhGWk5mK1d3Sk83cmRwc2NkYlFTSm5JMGdGWkk3WWdpNGI0eXNqNEtmTnNsMWRrOGxJRkhVS3FtNlhMNTNrd1QzK0U4TGEvVkFxb29INUVVbFQ1VGt2a0h6M0VUWGpqUGs2K3dCV2hKem5DZUJYU1pKOW9aQi84ZmpqcUNNbCtNTVYwdUF0cWhzOHdmMUdSV3A1WThoblVPL0pZOVdSMzdkNjFabEJyTkRxRjBtSXhyb1oxVXYrb2M2Q2VodkhLSFlQbDIxYmlNS2x2M1YvcjE1YWFEYVZTYnBkc28zMHdJNWZxemZVSDFwY1B6R1N6MVdTcFhPdk83Q3pQbnRsN2RIVjJvZGZQaG5jT2gzY091djNld3V3cXFWZFhhclhxdVpaWExudG1KS3ZsalR5bjhzcVZiNU52a1Ivak5yakQzTzJJY044ZXNvcWRncEtjUXB1QlgwaVRNS1pwc2t3eEpJSEt5NWdzaEFuWUs1aTZEWjlzbUkzN0szMEd0VG9aQ3g5bllUNGFIYkFBRS9TUFNnZ05qN2xBSGJLcmd3NVdWYUhHRTkvVWRXaTdxZzF5VWI5dXMwYllkZ3NVdGxYaWxYemlsb0wvOWY3MkF3KzA3M1hkeVh6dnFXb1FiSnk1Y1QwTTEyODg4MmxUdzVOVXkxWkpwT3RFc1MwMUlCcjBRbm9BSHhqa3ZGSXdETVZ4Y0t0djRoVjl1UEw5cEZVc3RlNXpscHo3Snd1dnI5NTRaaU1NOHdzemJwci93RjhpNytkT2NEZHpyK0RleVgyQyt5M3V6N24vaXBCUjQ1WHhCTjVrUDJrL0g3V2FkclA3bWZzc1Yyby96Z2FkTnYxOHo2VDZDQU4wdWtIZjQ4dDU1c0Y0MzB5MStQMEx4L25KNDZYK05LVS9SV09HQlFxa25meUN5VFIyQnp2dktaN0ZLQjhrVys1a29LNm5uWFFLSFFDM1dvNnVrbTRuMmJDL01sVUorcmtja2VTckhEclR6UC8rRW8yV1EzYlhjWTJsUTBXL0g4aEVkSTBJZEd3K3RSR2ZLVFNDc0x6ajhlWE9UTFZvbTRLaEdhcWpTbkZWTGZKaFd2Y2JyYkExbTdheU1xaUE2b0tHS25JeHFCWWVKNkFCR2M3bjZtbXpvRVBYSkpTSzdSU1JJc0c0RmhTdEdPaXVSUVhCODYxeS9EUEVNM3duUnFvNU54Z2NxalVqMUxwTFNmWjJUWkUweS9CTGhnMHF1bTFRaS9ldHFHeXFraXlvSmFHb3VhWnNxNVlYVlcwU3FvYXBlNnJqZGY4R2RMcHFaQWE2YkVjR3p4dFdxMTBoZDRtNmJTb0dhRjR1a21halREUDQzeU5WTHlpRDJWTFZLZVdsRjRDaUs1dEZKSTlSWllNNkpSemxLa2RFRlVUWEtRUlZDVXdIVXhVY1VHTjVITURxekRvVkFkNDZRS2J4dzNaVURWcWx5TkFKbWo2RXF2emVMeERQTFJzcWlFQ1A2cGFNNUphOHJDRjhvQ0NpZlNIRERZVi9RcVladFdUYW1QL3Q4NlpkNFhrK29QUmgwT2NkeFdJQUpLaHRXM3lvbUF4S2d4Y0tjSDBSZ3o5Qlh5VUNvalJxbU1iOUpnUkN0aFZSUTFnTkl2cjJINExLS2dvNnhXUitZaWxRK0NwMDJrUUlJdGhBTWFOSFpqbUZMQWJnWWM3bEV1Z1ZOMEc3dXBkN0VmSWNJeTR1QXhIR0RKc3hwbXprR0VGc3RISFF5VU9FNXdqMEhFd243WS9SUkViY0xOeEcyZFlRS21tS203SUVSR3M2dnVZRWV1M3g1TUF0eHcvZmROUGg0eC9PWjdmY2Z2TEV1WE1uVG40OG4zMVdjcldxYW1tQllxakNLOXVxV1RjQ0sxQXFqV1B2YmF0R1NmZWdZMURhQ2dXdFhIWk52MzFGY3ZYSzVQalh3QkVOT054WDRYQnlSeFFlUFhNMGhIOXM1c2JSNmJ0T1IvRms5cjZpSWg0RDRlRSswaU9DWUhsZ1o4d1R3WGIwMlZZbmNTaTViMmR5d0d1bSt4a0cxYWY0ZFhLWjYzRWpLTDBEMEFzL3kvMHE5OXNjNTI5UDh0ZFpjaWFMdG1mcmZJNXZ6QkN3QTh6blJweEVQMEcvSGV0ZkVqbXQ4K09NZ09XT05Oa1lmWkJqWURDd3BqU2hFV1g4U2F6ellCS3BzNFhqdzR4Q0RBL0lBZERaeDFyWnVkcW5NYU9DalFpSGpINEpTai9HY0RUc0Z2anhQcG9UODBDd1Rpb2NaL0ZnaUxGSmNOemZTcnBtZzRHdW8yMm9nRUNwaFhWTDl4U2VHTkdKZ2VGUlFzRzBNWFVuOE9OWDJTT2RqdnRDOUhaSk5RUmlGOE1HR1pPTlptbG1SWkxCVkNTV3FBdFNFSHV4NVBpOGhDSEVTZ0M2LytJUVZEOHFkQ2tZWEFnYW9ZTmgvaFpSb3RyQjB6d1lGMFdYbXJJN3I4RWJpS3BGaUdZcGpnOVdCdFJtMGFHaVZJQkdqbjVHemRIaTVWQXM2ZjV2RzhJdWNhT0FwMzNvbWxRUjlDWEhFR3hlSkpHcDJVN0JNNXFtNEJRVzEzRG9RMVlSQlJtTU5sN2MrMGRENmFtK3ZQeGxRWlJLVzFhZmVOQ0c5bDQzTHJaNUJ0b2d5Q2FvV0JLVnBNU1JKVXcrQVlWUFY2dlJRQkVOQW5JUWJzZXpqV29OOFVmQk9wVjRPWWtWZU95U2paRERJcncwcmNxTWZjcHF1bXFrVTB0Q0U3M21kWHQrM1pUVXdCUmlJeWlVaFFLTy9ZbUNRU2dibDVyNHRKSGJ0Y1V0SS9hUnowYTZHZGR0akJrNERMenBlNkRPR0lwVFF0TndQSXhpWEdRaDdyZ0d4LytHWjBJM3FKc2VtSGV5YnZyK005ZjV0YjlkbjV1cmUyNXZZSDVzcm9ZMFdsRnRZRGoxT2VMYXNYaFlqRzRSRHd0UlBmcmdOWTdzWnhjUExxcS9xZldsWW5NaHNHTCtLVmhjWkpoTi94NzZtNS9uamtNZk13bkd0OGdrS0QrUFY1M0tNdFE4bUszTGxDK3Nrb05KSk95VWlteHk0SmkvMUN1YUdueEN4ZlMwVURlckM5MDBLNndVcTliTWZOUnV6NjhoRzlwUVVrZWJyVU5IRHhaOTZKYkw2Y3h3dUR3MkxOTTFIYmtpZGVhVHhHK1FuNnZWbkVpV1MxblJwS0JGajNsTjlZMmFvMUVIZW5FZTY1b3MzS2Z3R3VKSkU5QzhGYWlvNmtNTHM0U1hxR0dGeThxTm85bUNhYkxZclMrVEo4bW5NZjdhVCtRSnR4YXFtRk5jL0FsLzU5WDB4cHh6SytlUmlIT3dNZWdJSmwxSXJweGljTWV2RCs2cDFIU3Rac3JJK0NiSXJZUFo4S0NpK2xIREw0dWdub21WamdtMnFTVnJpSEZiaHphcnFOMWdwZDMwbkZMaEZ2THBYalk3YXBiak1yUm1NUEJVeCsxdXQ5WUg5VVlXVjZCa0hMV2pPbVloZ3FaVnJmdEw0OHBTemFyWUFqOWJEZ1lOMTYrVkYrZnV6MW96azVqcFNWMDhqVkhZR0RXYVArbzJ6eWh0NllSS0RsMFRPZlZZRG92RzhKQkgzL1d1ZGV6SHBuV1ZYSzRFLzFjazIzTERhNjgzdTBkbis1MjBVd0c1QlFKUDBjcUZVdEpiN3pXOVNPU3BIdFYxYURvMkQ3THUvTFR5a1VleElyYmlEY01sM2FNM0gyeUh3ZUZ1WlJYNmt6SVl0WFc3c213NXEvUExPeVZQRDF1VzcxSExLVWIyMnBZWHBtUlNmYmtjWCt4WG1RL2krSlR2STV0OEN4WWo5djNmY0pDbm5pSmkvRDVWSWZrdnU0L3RkdEtDN01nTnY3VUJiemZYejlLc3V2OTJ4Vkt5QUcvbnM3ZHpiTDlFSzdKMDdIYm1ZYmdNNStyZDRvYmh6Qnk5NVJDODFwRnVkUTA2NUFxK2xsTlp0cDIxK1pVRFpYaXRkdFZQU3BIOTZ1SkMrWWZQTU04R0cyUDUzL2dqOEwxQ0xrT3NpYlpzOHhnUWpaa3MrMEFMR2RaUE9YUXpOMmVYc3dnby9penRKNFRYeFFqVVVPWTNxR3YveG50TUlXeWFEN2F6K3RGcVhhVi81U3Y2UGFOVEc0dVZ4YjEvRTBhNjMvelIrOWtSQ3plZFVsVjZZalFTRFZDMDBsVlRGQlVVSmplOXVTNEpscm4zczFYeUFhMFlicTYxNTlTWHlVR29XTnJTS0dVSHU4djJsSmNXdVVnVWVQSUdHeHRpbVlQUjlhUWllZElwYkIrUm81Rjk5S2dkZmVKcUtONmxmdXVKbGFPdC9uK3dvNVBoOEdvRVg2M1YvOGVUZlU2NjhwMHJmMEtlSVI5azdHNE5yb1BaOXlSai9uSEpJckdQUmhBL1Fvc3Zza2xHRWNVQ004MHpJUjdUTVJRVWVjOERsa2hkZGU5YmhpazhMUGlobFA2MVlqMGhpTHo3ekRsQkVyOTlmNCtYeVMwLzhqZS9ldUdGSUM1dVVoTlFXUGw1UGpUM1BxU3BvbkwyTDVYUTNpQ2kySFZpVVNiUlg3NEFFZnY5TC8zMXM3K3ZFb25aZVJnNzlyTXNWaEh0R001bnFMTDlrUEZGWWVleWdUVndHcUVOdlNhT2RLTHVGb2Y3QWQxVE0zY0xFd0FuUFVvbkZhWTBmei9mTUxSSDNsbG9VZmhYaWRyZDhpTlJ2UjZOTnhURGNBempDOTNTSTFIRHNRcWxZcWs2ZXVScGtLR3FvbGpkQjFWZGR3MkRQQ1ZiZW5IR3JKWnFpL1ZpZGJuVWJVUVBoWFZSN1JndXlFVFhPTHRVN2phamh3TFE1UlhGNmN4WXRsNHA5aHZqdlQwNEFQNm1mY3JueWFkQW54cGgvY1F4MkNBbkMwRVJOMmxYMkgyQ1JaUGtJNXM3NkI0RjlZVk9IUS9rRXpUUUZOTXNCa2FnSHh5bjZmaWdEb3RGMC9RQ2lxSmExSlJZRmJMWkQ4MWxnaG9yQ09QRFYwakpNdUc5UXBDQ25paDZJQTNEYXFsWUxoRU5UbTFVVnFONzFnN3NyTjBiclpVYmNHRnRuNS9uLzRCNjJVQ09kV2svNUw2R0NEenhOUFF5NXdRQ0hXczY5Z3hLMnR5SjJka1Rjd3VudXBJZzg4R2hSOS93NktGRGorNjJtNklzQnVzM3I4TmZlZTdFYlNmbVZzNHVpRlJjNk8vaWZqZ0lxYzJQek9EKzlmeiszeUNmaHZiY1FqOU1PNVZ6eWcvV3RVNGlDNWpVR2U4N04xaWlDTVlXNXZsNkxFdUFFZk9TVDZHZVVnTmpQZ21DU3ZtdTU5OVpxV2F0bDYyN1FTRnB4eDZWK1o5d3ZUaVpMWnVLWHZBTjIvSlgrMlR3NkhETFVEUlZkY0ZBWEZ4Ym5GdFptVjlZTzloZm1uR3FsaDg0UmQ5Y0x4cDJYQkI5c3lxZCtjQ1pNemZ0NUxFMVYvNE1Hc01IdUNHM3hSM2h6aktPeTF6S1QzTldjank4K3NSdXpsSEgrMWlRL1dpS1FEb2VkYVNBQnFGTUVaR1BXZGFUWkQ0V1NpckowNnlZYURSeGhWOEh0b2NXOVlRQVpUS0VQUFgxeU9ROW8vWGhocUtJSm0xcUlVL3N3QUpodVlQaGp0U3dJeE1KUG5uQmUvRVJUWTA4eGVoWHlpN29SS3Q3bnlPS3BnUnFJSWpxakFDV2JzTmRMQVRDK0JhWDJOVVcrbGE5MktqVWdnTjlVeVNHWXZsaHJkNEJzMFVTaFZaamRvT1hMTnYzUzFIWkU1WFN3ZmJnL0dDRHZLNGk4QlZSb1lWcWR5VnBLd2o4SlpzeDcvaGUwU3ZvZ1JzR1pmL1FiWWczV1drMUJuNXorOFVuUkF5OTBzTVhwa0UxTFZHekFnYm0wbHhvRU9YazRHV2FETXEwN1JXcW9KbXFCYm1nRWxuVkZWTldlS3NhbE1LNllVdEVselNXZjBkVnUyakZwY0g1NGVvOUhHY2oxaWJQa1E5emM5QXl0N21qM0hudWZ1NWg3aVhjcTdrM2NUL0p2Wi83UmU2WHVjc01YNWtOVmRpRWpWSFdtWG9Yc0Z4ZTVrZWFZcFpNQnF4ckpBZmd4aFllWTlYRkh4dGZaUWxUT0FpQ2xTTEowUkF4dmpnZjdvUWxKR21ob3d4SGdQTUluNUdRZjIrTTlZVDlrM3kzSFJhSURDZUIzY3EyNWQ4ZUtYakdjb3EzWTRadU51MER5UWNWUlZDTjdtYlRWSklEWGJBNFZYVjJaVGhuaVlyUjNXbnFabk9qYThMRzNuandUSG1wUkJVK2FRYnh5eFZacFlWSTFsUWFGbkZFVWpNMEsxNkl6VWpYSWl0YWhJV1BZTlJFWEtDeEF2WlRJWlIvMExGcU5ldEJjMUNsY2RCTUJFb05lSXVDdzgrbXJtYmJMeXlDd20wcVZBUzl0R0E3bGxXM3pKZnl0ckZZTm1NL2JRcFU4bVZCc3kzTlR1Y1gveGUvWE1aNEIxQ0Q5TjV1SEZZTnBRNFczNXdMWnVycy9Md3RlclBiY1ZUVnpISVFIWnF6Qkd0K1llYkJPTERISFUwUktzVlAyQVlTT0lRbm93Z2tzbUcxL2NnTGVON0xvaUFMZU9KblZkME9ZekRVN25JMDB4U2s2RTdYSjhRL280UWxXcXdJMUc3MTk2N3d2T25wdnRVdzVHYTkvdnJZVUNoZFNSM0tWMHFPRXhEaUxRVUc5V085Qk1jYmplUVJ2dDZvTlVXaldVbnV3VWZ2bEZuZi8ydms3NkEvZlFBalQ5SFBpbVA0SzdrRGVScjFNY0Y0bTlBUzU0Q1RiSDJNSHpkY1p0ODJId21mTWtQdTQzL0NTZnNzeG1DSmtTTnJxd2Q0Zm5OTXFPRnFwaVFucm1kWnVrcVJVMGVRWmRGUWRhMnE2d3F5REloVTdzMGIwTkk4alZhUkdNZmllVjkzVEVjSHUwOVRaTWxVd1RqbWhjU3IybEE0Mnk5WlRaUEhEMjgrbklMSjRGWEtuV1EyY1RIL2psTHNCMnpIMVBHa2hxUlJWWUdMR0dwL3hTc1lxbTFSc1NHN3FsSk1aMG9PbzJlUlM4MUtvMVR4ZlVza1JiZWF6cTBlZSt6QUpQYm5HeE9zb0RxMytMM1oveFExVWFZVG9BTFFrZU1VZnRkc0kvZnY3V1dycXhuaHUrUHhQMVlEUzN0Zk5WaFZuV2ZnUi9KVjh2UzRPejBvVy8yRjFhRDZQczBLcXNRNVN4eDF1cmFmeS9BdGVCYk1yOExzS2h6RmdtNTRIT2NCRWFpbFpIbktOT2p5TXJUUE1FKzJnRDRZTkZCcEtoeGpLd2M0VzJIWVNyanhLb0xDcjBSTytXaTNja2ZjakdOWDk2WDdRVkdxMzdqbVJPV2FXaFRXN252cGZXdENRYTN0ZmJ6UWlPTkc0USs5bzBjOUFUdTN6UzFMVUdUUndhMkZ2eWUyRjVNZkNtQ3RHUnRhUkNUaHg0V3VRN3BMcG03T0hwbVpPVEpyNmNaUzk0VXVIaENmOWtCdjRCVlpnQTltd2RVR2NBM1l6bDFyaTN0Y0dXVHdnTEh1UnBPa2lLdXZrTzFIL0UxRG1iNEg3eUxCaElybktxbmsycElhWVVtUk1zOGJpNHNHajdsSk16TXFMNTEzSXR1T25Ec1JEOXUyMzNldDRmNmdwV2NqZndOeHNuWEZFQS94SWdsR0hkMzJBdG5oczRPbkQzYUk0TWpCUlVIaURVVXhrTTlGcFZRamcveGFuZnpLbjdyR3JQOFpyVXh1czNUY3JGQU1OTDZiTCt1bHBxS29sY1Z5ZWJHaVVhVlp5c3ZtcXM1K2tMc0YwUjdIMHk5NTNaRFQ5NzU4OGx3dmo5S2lreGR0d3RSZFpsOGwrMlg2RmQyeVFzc2lyYXM2LytzdHJiWGlydUptblJyQ0ZyeTl2OUpTYmNjSHc2ZTFlWHlyUllndCtiZXBuUTdvMkdEU3o4L3JqSFNHWGVrbnJNQUd5Yjk4MVZZb2FVWCtqS0ZiZG1BcnNpWHc1L2lpVnF3cFZDbk5GNHZ6SlVXaDljTExWRXhwZzI4RHZZWU81WG5DUnJScWU2cmI0cGoycDdnWDdtY2JUWUJvcG1XQlpONTV5Z1pvUDZNcHhzR2tJK3V2c0tUQlFXNnA0WUc1L3hTcDBTWVFtQXdGQnpFMHhoT1hIK3FnazRIdGN0bngvYTJMbTVzWFgzVnhzNWZacWw2TytxcFZPVlZMTkNPc0hkeTRsSFljVVRFRGdZZUtzTnBiUGgrWVlUMWRiSlJGUjNaVTJkQkFONXlyd0QwUVBmMEdzK1Ezc3h2dTJYMXNrdkFraHdLNzh1YkZyY0ZkZFoyUVlnUGVYU2pHcFdxYUxHbnEwdXpDb3FVNm9nYTNxQitLQzBJcDJJakx5bXhMTGtJL0I1M3h1SEZ5UVd0NmZTcHBvbmQ3WWJHeDJpOCtlUlllZk1wLzg2dmsyeXoyTEdKWWJBRjJMMmhUai8yRVVWempDOHRqVFBhbzhWaU9mM0R6b1hKOWRNLzZ6TTU0dnQ3UTlXYXROLzZSUXpldjN6T3FsMGw4OHh1YXlkbmUxZ3VPYW50QnJaTE5MaXpNWnBYYUhZMDMzUHgrN2VnTHRucG5rMnZ3YjN4bzNWdmNZUmFKbk92NVd5UVB2MlA1Sk9pY3dvcWJzckFDVkNQcitjaDkxbWNKMi93VWdHbzB6aUthYmlOMC9vVHFZMytCSExpY3JxZndsODgrcUlMdEx4R3gwdUpOa0JCUFNDQmFIWElMVHpRNzBCcHBQWEdxU2lLUlByRks1K1RBTkFORHptZU4vVXV3Mlc4SnV1YTkrWUtpQ1VjRnhFYVdaU2N5NVhZN3lWUjZqMkpicmk2RGthUUhMNVFOWDlmOWlhMzlMUlozTVk4eXBUMjFHbXd3Z3FITzBqR0xNZ1E5TzNkamcyTFhqcU9KUTBUSUFsSnNxbFRTSmROcGY2Ynk0ZlhuSHpYL3BKVDQ1UXFGRzNsMklicjc2OXJTM3AvRzYyOThiUGZRWTRkL3AvTVJWVk9jcmlPSSt1Z0JjbXo1M1BpQUFrS3ZYR2lITGRlMDVISTVNZHMzcFhrMjNldGVmM1FTbTM5bEQ3N0xhN2xaN2dDemhlL0UrQURta05rZm04dE53U0NQaUpnQ2h1U0VGalJod1hHc2NRMzNvMkN6YWNCcHZKK1ZNbDBnbHplZXZ3bEtmbGdzUnlFSWJzdFZUTEhibFVxbXBadE9HSldMb1Z1dWJENS80K3VnQ2xiU3VnTmQ3ZHdFd2J4c2h6YjhuYzlubjhobmwrZU9kaVZYWjRSM2ttUzVUdXhuRDJTbHhEV1FJNTBYRENURU8zcFdLVnErNGpyRmF0SnJyaVhKMnU1YTh6WFE4NGFPbzEwMzQ2WjVnSGsrWS9PN2NobjlGR1AvTjBoRzB6SExtWUdYcGRja01WNjQ4S2hDZlB1R1cyKzc4QzR0MFg1YUZRTHI1SFZwakhlL1Rpdjd6M3ZleDB6elUzclp4d3lKNi92M2hIc003QUJ1dkI5ZGZiMWZabW9HWTlrSDJEUm9Oc0FtRVRPWTA5R0FqVnRrekYzRzJDbWhQZzBZSVN5MmppR2pnQXlSQncxSFVtaUNMWWxSaG1Lank3RmQ0TXYrSnhVVU4wc24rdFhITG04ODlNUkRHMnh5M09LRDdSWnlGNHBCTUY3aU5Wa1ZHbk9xTHdqRUYydWlLVmxpdU5OQ3hHOHhjTmVXRUh1NVBxczZzTnNScTJBUWlVM0JlWmx3bi9OeTRmTVViNk1xVjR0dmQzTnlrNDJIMmdMbDYzT3F4eTViRlczSmxzTHR0a2hFWHZUOXRTVmVCZEZRbjhPQURPS0pZUHFBRUE2MzRMRUlMd2IrNnFJby8yZkJma1I2MnY0Qk1jOFgvTTZWci9CUGttZTRQK2IrZ3ZzSDdnb09BTFFUeXVKZjBlM0JQRDg1TkRLbWFlMFFMRldHYmo5Szh4eGMwSHhaWUN6S1RKdnNCd3BkbFNCeURydktvQ1JZRzlubWM4ZkJOWFNkazVWSmFna09HWTN6NVBOSkdpZkZYbXc4R2FqT1I2bnpzL3VUN1BhcjJ4bkhKcVBaR1V6Q2wxalVLcnN4MUFFRUtrQnF2Q2duMjhnTkFFUUpBc090c3dPOU9rTWRnbS9QWi9XeXdBam9rTzhQUXpsNTBOa1VsaTFGTE0xQzZDQ2RFVWVpcFN1QWxCY3drTEhVMUE3d2VybWgrMFI4OWVKY05xTFFsM2FXU3I1SlJTU3ZVc0U0cnJUYTllWFkyangzcmoxYmJZSktMOVc4cktCS3hhaXRLWEEzcGJicE9qeFJXN0pBREZYeUVTdGI0UVV4TW5nTnlYNEp3OWFKSXNUVjBLMUFDM0RJd0REWmRnVk1KRUh6NVZnckVLbWNsaHhUbG9nQVJyZEVWWk1QWi9iR1p1S3BqYkpqWENSZzRGR2RwNElsVVV0UzVCZkNtd2I2bHFqS0p2K1VTUjBxR280alVueG1wUlFHTnE3YkVyeUdyNTJMb1pRTnhXbnBDaEpEb3NmR1Rua2pMRmhSNGVBMmZFNVEzamFpb296ZUJEQllRSDlSSlJEcHRyRzBQcTdYd3JoU3F4ZmNTdFV0dTFRdzdHSUVZaVBnbFdLNVVDKzdKSFJMVGx1UktIVHdQckZzemZJRnB4WlVDbFRWcUtWV1NxSXFDVVNWN1NKMFlWN0J4ODIyb0JlMHFraFVESWlGQWhWMHNKUlVXNE5QeFN0RzBnemZZUmw2dSs1b3ZYV0Job29qZEFPOUlJT1ZYUEFPd1dlRDdpb1FCYzgwcUZqRWVLVXIveEg2L2lmMmM2WjlMZ2J0dTg2bEV3YWdQamZtTmhpaUlpaVYwcGdCaE5tRVlZRGxjNHJ6Y1lqUVlUc2todzlEQ00wc0JoTXlZMFJNTWNVTjVON3h5VE5YdUlWa2ZLSGh0bE8xYXEwVzFGSk5qT1hWVUl5clFiaFZKY1c1dWxSdXppanBYTGhndmVab2NUdy9XK2xIVzhPYjNOMUQ1NkVMek9hbFNsS3RSSlZvTS9YU1ExN0JXNjdZbFlhWkdJYldVU04xVWJmTkdlc3ArWUIyZk0wYS9ZRjRuL0xSZUNGYThXL1hmN1o2cURUcDEzK1h2SjU4SEhyMUk5RERkakljSitxeklBNTQ5ZzdOblh3c3pBUUZjcWVOUkxVWVhnNmJJaFlTaDNvSVJrZld5RGpQRSs3TUZxQTVubHJjSEZWYjBrcW52THBiR2ppZWJUVmpuL2pXM0J4Wk5KcGVkWllFVVdMWnZMR3prSjJzTjlNdHUvdkFjS2FXam5WTmY3YmFYMjQxVTFLMHFzTHhRdFltbm91eHVDSU52YkZ2SzJnZWdFMVpMYnV4SXNvbWxldEpNYzRxeDYyMFExUjlLVXVQTVh2eGQ4bHZnTzBrTWZ2Z0pPYThEZWs0Rk93OExTQU9XWVlEc2NqVTFFZm1YeG5WRDRiN2lEb2V6UldSSEFSSDNqZXovdmp3YU9RUXU5NVpiSFcyMDlZT3VVZHhsRUxUaDFvdUtyVkE3Y3g3cmQ1d2J1Wnd0MnJUaXF2YTFMQ0tuaUM1RXZLSVNXUzc4dExQRlY1SFZzU2hNVTZ5RFRxU2UwZHVQTnpiTzBvbHdTdGFCclZWcDBydGtyQ3FybmRtdHNXQk1IOXNkbWxXd3p4bldWTDlaa0Z4b0hMajFTYjQzbE04MzlQUGdlaHFJWEJJQjNPM295Vk1Xc0RYeFVpa0FYNHdlVEwwdVlJcGdGRXV1anRCaGlGYU1aSitYTFhnWVhvK1BOdlNpcWJzaUVoa3ZWZ3dBOS9nQTBOVld4RVJKREFVTGJEc3RIQ2hZSVJJS3dBNzJ1SE0yYllrRnl6eTlHcDI5VXA3WDJ5SGdVY2l2YXlJbW1TWU00dUdSZ3NXbFlrY252Mm9yTmdZaGlKLzk0N2pVUUFXWkRDeGkvbFh3VHRqN2dybTc5Mk5ldVNRYVdpNVhSY0djVzcrTkhPQ01Ta25FcHBBekVRSUYvci9hcDJ2aUwzVEMrdDNXb1Y2dWl3MHN1WmFrL3d3VElaN3IxUGxPbEtMMW1YMVBDektLcHRjdUxyMWRsV3U0bGFZL0s0YkxKenVIVjhOVnhKRHR6ZVBNSVNodWQxL2hidGZnb2UvQkpkZXZ6LzUwUDdrVDJWTms2ZXhsVmRBRDdzRWVsZ05zV1dZa0d0dUk4aFRqZVdLWUpML0pJYnNqdDdPOFpWTmErK0o5Z0VvRjc0UWs4WGVNSjAxN3JNV1o3ZEhXK1AvWGE0bEM2dWJ3c0t4OXN5blMwYzdYak5iR0crY09uRmd0TnlBaTJlVHZQalBmazlmMk9abW9PU1h1U0czQnVWL0VIcU9FL0FWem5LM2NlZmhXenpBWGVRZTRWN0N2WlI3QlhlSit6aGpSdndNZDVuN0l2ZHIzSzhqSTI2N2p4bllTSFkyWkNaTlBKbFBmekhiQnpVd3EyT1hDV3ZTWkptdHg5amI1RDgvelROa3Mydm5MczFjcVlrNFhjMncyYjVtVHp6Vkh4RlJCRm5OS1J1MllLamIreW1hY1grY1kvb3k3UjZUUC9IVWxEMVNPTGtZblN4UHQ1RTM2K3hmSzBsYXVuNUxraXcxbTR2TjVpZjBKTDdDMWNWYVdwUHF2NmZyZTgvZ2NsMnNYNUpxNGgxaVhUd3ExaVg4YVVseVQ1Sjh0dGw4VzVMYzIyeit5cC85Q2ZuUTNxdSs4S1c5VjVFZjNmc0YyQW1YU3hJNnVtRTBQRFY2cGFrWUZVcFV2K0pibnFzVkxNemZDelJkSW9wb3lycm1tNjZ0Um82c1hrcVNvM0VDai9WNHMvbTRQdm4zWjgyNTVJbm1hL1ZubXg5ajYzREEzbCtZbWxrR3JXWWxtVFZWQzVlV05RdmtoNm5WWVY3WFFMbDRxVGI5Tjl4NzRRTVBrSjk4Zk85dmI3dU5QTFErenpiK1dXYzRQRFVjQnFyQVc1NGhLeTBaZEU1WlFhWnMyY1Z3TWFva01nTHJmVURYRXpVNXJaOXFEcHZ3UzdncG5oejVKL0lrVndSTmZ3NTV3eElHSVRvaEtyMFdiM1RxNGVudk8rMys5SVc2L1dsYmY2SHVPRHI1dHpEZCswZ2xBNEdVZmFyTVp1U1NyWGU3SURIMHZmOEpwK1NVYnU5OUhmZE0vMWk3bW1DZFBnMGFBRlI5S2J0K2RDM09ydVcxU3NubGR6WjZwKzQ4MWV1ZFd0am92Zk8vcFpocWVJVGxHNUozejQ4WFRpOHNuTDdyOUVMblhlKyttc000eFlCN2tyeUd1M2QvdkQ5SDRKaHczTzR6UWFOZ1haNmFPUDJyb1ZOWHF5dGoyeGd4emxEVVpCTUd3VEVKSldZczlQeWwrcWlScFpXYWU5Q3JWcHFkUWIxTUtvMVJZN2NzRzZyc05XNjUrZWpzek5IWmhTNllsSzJhWFlvcjlUVHdQTCtwK3FhaHlic3J4Y2gwTlNvcjNyamEzV2tSejZzTmFxOW9EbXErM2ZCdThXdU8xNnlkcTRGSWwwQnZVcHhLMGo1MDY1Rk80Q1pCcisyVUxTY0sxdndJcEpWUm9Nc0hOZGxVcUthR2NXc25BNTIyc3J5UFEvODA5Q1ozWHUyOXNmTm1BZFBNTFFkdk8yR0lwQWtMZjVnV3hWV21pdjFtTzBIa3pzc1NJNjRud013Z08zNUJITit6R2tXMURyeEJmTTN5MXhxckRkdFNGVWsxVlRzcjZISVV0T3lpYnFXMTI1dXBheW1vSUZQVGhUWlJkN3BoTFcyOEt3NVg3eG1MTVp6YnFWMnp2T1hXUE5PVkJNMlVWTHNnSS82QXJOcHVaU2J5YktkZ2VTTHlPc2lSQWVxQm9GcGhNbE1JOHpyM25TdC9USjRsSDJMNHRWd2JCeEF6WnFmc0QyN1I2WnpCaHZRajFCdXZMazZHdXE0T2VVblFPWkxQaVdXN1YrdFpwbHEyZW81VXJsaVNjNDhqbHF1bTZQUXNTeEo4WFpTWGFyZ28rcnBBRngycFZNMlBLZFh5WS9hK1U3dTcvZ25MbE93TDdFVEpYclFzcldRdjFuRmV0aFp0cVd6cEp1SHRDemJjRGV3aDNsNndMTGpoVW4zUnRQRkkyTjY4czM0aHh5MytiMWYraUh5Si9DeTBkQWV6YTFBbGp1VUZub1Y3SThEWjkzbnZlR1gvdmRuaTk3ejMzd1did1VNM1BuaHcwVGo5ZmpibEJWZXQrbFZWa1dHdUNhNnZDTnJtWkY1Vm9aY3lGQ0d3L0t1TEd1LzZxcUJ0NU1lb2NPWmZyZ2ZyM3l4TUx3alRqOEhCMnJvcWVKN0NhelVReXA1YUMzRHV3cHJnSWY4VkZXRS90QnBjcW9IVmMrMFJvanZGaGZvcytRNjV6Q25jZXU1WjJrY3BZYU5LRWRQSVFFSnRrU3dNaHBHYzI5UnN1azNxckJVMEVYMEcxYk1NZVJNWnppYmpMWWhpcElESDhNcXAwL3Jiclg0TC9xN1l4V3JIVVpRNEdyYWhYTnZES01ZSWlXclJGbm1kMHJKUEx2cGxHY3pCdmhmdlBWdHdaK1pMSFNXd1RiNUJzOUxDN0E4WDIyMjR6bjhxTU1GMjB2Y0NlelNMQXhIVkttM3ZDQWN5WEFpaTl1eklEanhmTmdWSi9ISllyWVpmRmlYQi9PVmk0SmUrRU1wZ2FUbHFDYk1mNHhjM2wvQkszQ1FHNmpkNW5qekRQWnpuSmRsRVRwZVRDY2NTK2c4bXdlNXNBOE9CWVNPdy9SeXZNaDl6WTVIMTZPbnU1RWk5VSs3UXdDYXN4NHlYSTRiZWd2UnZFY3ViSlZlVVRXUllWMFhWMWhFTE5URDlLQWhObDNpSzRldU9JcXBvMng4bWtqamZkQlZaVm1XZFZnVStWaXdOUlJ0b1dndVZ1amJUVEQzS1VoakJNTmZ0RWkyS21PdlluSmVrc2FmeW1xRWl1b3FCWE5XOEpodkVFQ1V3VTNXZDF5S1IwaXdJaUc2SmdzZ2JqcXFKTW0rMC9icTdISmhoMkhYcmZzdmtFVG5UdEJBcm5vSkNIV1FnOWIrTHcrR3g1OUQ0bjZNVUV4YjluN0VRM3YweVpONlY1ZEUvVTRJUll3TU1venlQSUdBSXlmMjg5T2gxNUE0bE9VUHNHTXJMbW1Jb3NtNnFac1ZTREtMTHNLb3BGSGZPRTBHb2h0QUJTbzRVb0xzRU1Wd1F1Y0dxKzRGY1hqQVlGUjVWb0E2NllGOElSTmFqS242QjY0a2Z2bVRJQkE3Q0w0YzlLaFZVQlErUzRTWUlqa3ZFa21rcE9vSVR3ajZScDBVak5CcVdVaW5CdkVqaE8vRzg2RkZlMGhYTExPS1k2M1YrelpkOHQxL3ovLytDdk1aTGV2Ry9aekVxMnZYRmVLMno5V1AvM1FzeHgzdGljZjQzY0NyWUNHMXVpZHNBbVhhV3V3OUs5VFhjTzdnUGdCM3dXZGJ6Qjhrd0d3OVd4a2xJWXdScEdpS0w2dlZybEsxQlQ1OU5kbHk3aUVkY3U0Z3NESlNON3VFcS9hN1ZmQTNQQnlNd29UaFV3bEx3QWdhRk51aTByenM4bTZ6MTh4UGlmSFg2V0MrUlplZ0pGRVNqQnZ0VWtoQTRGWEdHSkVsOEx3OFRJa2trRW1TdzhDa2xNU3pJbE9JNnBmUnZvQ21Mb2tSaFV1Y3gyVmNFVzE5NEtjeEZuZUNwTDdkdElkdEt5d1U0U3Z4YWMyRmg3NWNGcFBxVFJWSGM0bUVpSXBHZUtCYmdESkhpUkx4ODhJZ29IamtvemtnUEg1RUUvc2pEdkZDUVhuc1lGZysvbGhmdUUxS0VORXFGU0ZoYkZmaTFOVUVYRGg4U2hFT0hCVjQ0ZWxnVUR4OFZYc0pMNGpNSDhVME9QaU9aWU1OLzhCQmIrWkFVQ3NKYmRtVjU5eTJDc0MwbjY0a0tqL0J0VVNJTEJ4YzNKZUZOK1RsdlVrREJmOGN1dk12dU8vQ0poTGZ1UW5YY2Zhc2dYdDlIN1R3M3o4d1c2WWZCTmFyY2hFWW15alYvTm5aMVZZZTc3d3JYWFYzdEVweitZak11ZFF2dHlGSUx0RzRHeFRDcGh3VlEwQUlEdmsxaVI2VUNlWHExZS9XRXZaOHhuV0xaMDAyN2luNTVRM2VyaVd0clJsQ0hidGNzcTdMQ0c0WlhTd0kzbDgrL1NyNUZQZ1g5UVowYlk1ekI5WDFDd3ZoZEozd3hMTEpubkV6R3IvWlpaTmhEeTNuZVY3NDVqOXpOTXlya2F4cDlJc20zdklhbjBHVE50OTRuU1dvb3lmelN6dTRtQ0U3RmNKWWV1S3NORmhxVmg3ZWUzZUdwQ0lZWUhSeGFIWTVuVE91Nkp2MU9jYVZFaUNwYlFuMU5vS1o2U0NBVkZla3BkY1dSekRoQ21QVlRZbDFSWE1KYnZzRTdoaGtydG1aT3NhVC9SOUJITUZjellENkZKb3ZucERrTEN0aHArTC9OMUl3bWZCaVBQTlVwKzdmL1VybERudHA3a1AzdTNQc0xYT3U4TEtwbUZ5NWsxZDV0eGRzZTYxYWlxTkxsY2g0WHFBcy9mQTBPWmN5d0pLK3g1R2xHNjNEMU5JUWZHdGVrOHo4N242eS9yL2plZzY5b3ZHTDlpOG9YczcyLzZwS0wzZXpYZnUxZHQ3VnU2MTZxUGJuemRPSHBlMmV5bVF0UFBQMTB0enUxNFQ1SGZvVjhrWnRGbmljZng2SXlSc0Jya1VXK00wVjBXOG5CMkJZSVhXYVkvUU5VSkhmSU1pTUcyTis2aitjM2dXN0xVeFcvSWlqOFIvaDVnUWhmQmwyZS8yMWVXQkJVL3FjRVJiaEhFRzdsUVdsUWhNTzhjRnhRaFJVS1I2M0JPaHh3THl6ZUJmT2ZnU01XQk9GM0ZQVTNSWDZPSE9TRm54Tm1lWVgvMTRpMy8wV0JDaWt2dkl2blQ4S21teEg0bWo4SVMzOEFTNWtNQzJPMjZTNkI4c2Q1NFFPdzBvS2E4MXNTL1NETVpybHJjV0J0YnNCdG9VMHhScUVFaWlLR05lQzRpTTgrSTZpSjQyRnVQbWM1bmRzaW8yeWNodlZNYmV0c01uWWNmVXJXclpyWGRweE9TNmxhWmZrUFVTWS83a1dyL1JQOVlmdEdrcFVMTGVuOFJCOTRBdFhFTkMzNHhXSzdXTHpMck1nR3RUc2QyM1lOMlRESmtVcndNMHNtZjVhMCt2MFRBN0phN2RiaTlnOU9SZnlmSktnYUpsYXBWWUsvL0oydWdKMzRKTWlWSnRlSHQrTElWRjhPKzJoRDV4N29SVExFdDlxUDFLWWRkTjRpVGhIYVNxTXhOTjBjSFl1OHBkVlAwMzVyVUIvVVh5d3NOK29MOHZyOWNmVllmYkE5cVA5OUM3VGdrdS9ZSGIrdTFMeFM2NnU5SFlTQ0lIWUp6Mm1WNEtRYm0vT2RhdnhJWnZIUHJ3OXE5Y0cvTDdVSmFIZEtCeFJzdy9aSSszY2I4d1JQcTEvRmdjWHg3cFJiQm8xL2QycjVnOW5QOGpWRzJUZ2E1YXhyOE16Wk5vL0d1NVJOa0o3Wk80eS81M3V3R1AvVjV4MjE3cFU2cGVvc3ViVzdPajQ5M2lnRWI1Q092UGdnN052N2FGM051cTZiQlEzTE5Lc2ZLSUVDMzI0WC9Vb2xLNWN4eUgvaGxuNVdhTXpWTnNucW1kRW9JK2VJT2Q1NXdkYnVZODhhbnVOMnU2NWl5dFdhOGNiV29BVi9kcVZUZ1QrbXJ5UGVOV0xQZ3pTWDJCaGdKOGtSSklZanRGQ1EreGtUempxVHdKSWNVelR2eVZtUXRjeDRGMGM1eXhoYS9hREdEenZKRUpGdlFNZ3pPdXRwTE43Vi8raTVYZ2xsNklhWkp4dXZ5cWlYOHRUU0lGZnZrNVZsdlBFazZwYTFlM3VhQTVSUGNvYytTSlRVSXVSK3FhSkF3NU5CRlNJeTBqNGdxRHhNckkxakJaRGhya0E4VDZBNkZRUUdZcStyQ09nUkdnUUR2QVZrbjBWbENUUjdFTWVaNFZacVE3c3dYMUVkaFpkcWJhY1FHcVlvbUJJeUl1RW9HNGhLRlNGWFFIS0tJRGVSSEpjUVMySVkxcG9NdDFkQnlNWXF3aFdLbUhhRGFaNFk1d01XaExETlF4T0Nya1dra1M1WXZxWlIxM0x3eHBZdmd0U1dTRHZUb3g2eGtmSmNNQlZRSjlEc1VCa2l2MTJqVFNRSmxnbFpLNE80YTFna2JDSmVvZ2s2akU4bFVPWUtWY1ZoYk9sRlcwVWNWdDRHcGROR25sM1pjblVNUVliWHB5SWFPc2dpb2xKa3FwQkVmZEhncTZDSFNxb2JCVTBhRmlndjhxcUdaQkVTay8rWHlXTlFUeVRrNlduVExJM0hPaVp4OXNuQ2ZHLzMwWmQ4N1QzbnQ3ZlBQM1hISFYvL09tbnRmZjFsTDV2RTVqL0NlQTA0bjBGN0RpZk8vR2lhanNoOFBHRjBOYzhKLzc5OXVYbTZjZWpVSFEvSFhpdWN6Nnhvbk16UHRHODRlOWR3WFBBN1lhOXRocVJkOTkwZkxaMjdvVmN2Z24xbktaYVhtbWJ3WktNemM4TlNVdllOMjZTWUlLQk9mSFNIT1Jla1ZIZmk0ejdHM2M2OUNtTkFPbm1nRFppZWpOMXJsTEYrQ09wN2xvWTdaUCt4S0VpUXZNV0dkSWd1WXNiUEhtSVFGWHErVTNRYVk0cGtLTFBjU2pwNXdUek5icDk3anNWaVlXd0NGQUovS2RscWQ1dlZNQ2cwK0hQa0RzczNQK0E3ZkFaZGsxTnlmTjlOVFlVb0pkdStkNzdYV3dJVlFLR0tRZWM3NTVMRVZqVzlXNXA3UWhhTlVIV1NhakV1eFM2VmpGQ3htK1ZDRU1iMnAxc0xDMm5XSlhwVExkR1NaZHZXUVV2L0RiVnYrR0czSFlXdlZnOHBjYXZ3YjFwYWUrVzliekdnV3MxZ1V2TEY5M1oyWERBSEVya1F2RTI5QlFITEZXcjBDbHJYMXFHR2lJcHNCQmlBcFU5ajB5NlR2NEZ2MjBjdXV0Q1dNY3R1YkFzN0pBYlZacHlOc3pqL3YwaGdNczUyMFBzVDI0UjhVeXBscXplNW1BYkFCN3QzcjRJcFJZUHphOVlQMlIrNytjTXZmZWc3OWRmOGhMZTg4T3pjaTR4UTdGUU4wS1EwSWxZcTgyY09kd3FHMkdpQWNHcFYrSk9TdWRBL1V2QkcycXU5Ri8xSTUrVHpPdDZ0cjFxOVgzVTdXbEZFRWhYdTJqd2dBMnJnSnFLaVhhUDUwWnk1SU5uWFczRndDQjB4TkVNM2JKenZpc2VUZlgzQ1hSUENRZlg1N2ZsMXpkWmdsc1E2L1htWXh3bXNyMStyeHoyajAwZnFjL1AxaFo2aWFjcUxhck56dFZqVFFxcTl1ajQvVjEvVXRVVUtiWC9wNmpqUVA1QkxuSWNsMmc3emlKaHJIaUJER2M5YzJOUEhUaWVoanZtRGgrUWZhb090UVMwWjJKSHo1clJmNzI4TzZyQjREcmIyNjNac2YvSm9iVkNyOVd0SEhlY1lPczZQcnp0MnE3WlNyYTVVUDRUclJ5YjduMGJQTzNlZFg4TEhMQ3JDeUVmUXJVM0gyenlpbThYSTg0cE9QM0s1dWZ1VEN6ZjBCTDVXdS8yLzltNVk0SVZhamZKelI4NGNTTVg1d3pBbFQ0dHFJSytjV1pnOVhiMjlpUXN6WjZydnlBNGswZ3pzeGluSEdWZXVzTFo2UDdUVkpuZVNNWC85QUxUVDEzSS94WDJTK3h4eUwweTg3Q3U1Rnhta2FvaXdoUDE0NG1hTzRzNTQ0bGNmNVdpWitTZnRNOGY2RkJFdllING5LTmRwS2JMeWpWa21XSjRURmc5UmFzdnBkMi9EVStPY2t5NmQwdGt4eE9Id3U3WWlRMDUvaGQwWTk0OHh6UXkwWVp6SGJDMmxHWC9wMEVzT3RWcUdjZWpSZy8yRjRYZCs2ZUNqaCtLa0RXdkRoZjRtRDJha29waU9LaHFLUWpWcU9hcmhFRndUSklwWnk0OXFqdWI0TlErMEc4TnhqRXh4VEprU2hmWmczYlluNjVUMmxJNWk4ejZ2MnBLd28yU0tKZmhDcGVLREFCc29HNWkxd1pDQ1FWeDh1akZzU01sNk9wYzZ5MVVNQnlRU2JLa3NPd2xHUVFtQ0ZWR0d4eVZoVjZBcVZvQWdWN3lvZ3NtOE0xWlVWUm1QTGMrenh1ZHFUc0d4cWpYRlV1YXVMaWFxYXNvOHY2MVkvRmErR0pxeElKbUthYUFvSXhSTmI1aE1mSWd3ZVphOG5pdkFYTWpCS2FtY1luQVNpMG9hamR1amlIeitzT2hiRjFja0FjcnA4MGhPOVI4ZmN2bUF2QlYwdHJ2My9xMnJLcWVXUUNRKy9ERkJJc0s3RzFLZ3ZGZHkvOFc0dHhncDRTZjNZYmVCaGVnYTQyNDhJM3JiTlpsS0x3WHQ0VzFiT2pIL3M2SmYyOTQvY2puUUZxcnl6Z3RBdnpqdkM0WjR0NkJQMnRIbnlFWG9LMFBRR0xtWStZREhqT01EcTVTRmVJR3luK1F4VUNzTWxtczY5SVBEOTNLT0pZS04veml4YktKV1MyTkZxd1pSc3pMajllUGlwYTJGT2RPc2lJNG1ScnAyY3JtOTB5NFZ6blJWVFZTSHk3MjEzdWtsVlpYVmUyODVzKzYwaXMzNW1teU1qOTFBM3BlMVY5Y0hxcVgwbG5wYmNNcDhtdFEwM25SNFBmQnZYVms0MWVNNERleXZ6L01jNDBLNWszdVFlem0weExkeDcrTStEQzN4RzlkZ28wcnduRHhZZVN5Tk5aT1RqTFZScHNZenNZb1pPQkZMd3hsTW1OK21uSEE1U2VrSzg2TFZFQVU4eWhQTjJ2dWdpSU94UE0yQ1JwY2RpT0lwb3pFNmNmNmZMT2ZZckl6VkZtVjl2STBlUEpiNkRqZG1LNkNoNWtUTlZNWTc0UVBRYmZKVnpWRlZSeU5McXBhY0tSSFhVRXhSYmFpaVNhRk5RcjExU3ZVRTVITWpjRk43WkZGRjljS2FLNFBtSjZJM3JuZ3MweFIzeVNVNkwra2k2UmxVTSszUzNtZThpdTlYdkJXbEtQUzdqWW9ZU3NxZ1dKdko4eG1YSnpOTWpuVDFGUU9oOEl6VGhkbTVsY1YycXl2WDJvbUl6RzZxUXlkUDRsaENvMk1VeWpQUmpETnpzK3hHbWtkVk1TeVFGeWltNlpybWV4cXR1WFpQYVppZUlsdVdyTUNmYndVeGtkU3lJS25qcHJQWm5DbldiUVVVWG1KWVNxTkRQQWNlRjNvRlVEbTdoeFVyZXNpTzQyb1V2YUxZN055K0VWaEt4R3VHOVZ1cVljRDlUUk1tLzlMU3N3dmxXcWx3ZHFGWVhObGVPRmVGVG9QQ3ZXd2I4NXJLWjM1aXR0N3czVGRoUUZvaEdFOWp0ci81TCtXbkNOOG5xb084Y2UrWDRtWXpKamZCOU91T2ZndEtNcGc4ZTNXUlBOMk1yeDYwOXpIc0t2ZHczOXR3NlcxTTlHbFh2Z09OOWpCNUVjT1dYUURONFJoM2pydVBleUgzTXU2SHJ4bmZhVTlIWlZnT0NtVllwRmpOKzl0Z2tVZHhYMGJxbnZhMTBheERGSnhnUmRYNGVJRzMrSGk1QnVKVFd0NFBJTjdIZW00dmZ3L1UvZkREbG0vYnZrVlV6YklDeTdxcGZ1cFlzVjRySExsaHU2YkVxbitoOStDZy84RDhmYjRXcTVXOXI5Y0hPOE42ZmJnenFGZUZ6blpyOTMvWWJXOW5WL1RGcmZWTTEvWEZ6WTFNMi91bDJZMVorQ3VXd1lqTXltU2RyYzRVOHRXZlV5M0x0eXcyOGEwM0YvUnFmWEdoVmxaN3gwN1Y2K1Z5aFpCS3VWU3YzM0QwUW1NQU45ckd1OVgxMW1ZTDlKTUtTYmVVV3FhRlM1dlZXa2VQRmpmVkt0NXB0a1o4dkhiWm42d0crZHIxL3NXdDV4NERTWm1Qa1RteEJ1TjlaM3dWKzlDY2dvcUZ0YUZsZXQxd3hrT0s3UVVyQmEvR2k3UnM2anhSNXdWaEFEYWdNSWdEU1FhVjVyc0dKZDZseUhJamJsNFErVGtxcUxFWGF5Si9YT1Q3Z25pTGF5cGdYM1hwTk84WWNWeVcwRzZlNEQvdlA5L28renpneUNoVW0rTld6VElXUlZtV1ptTXdUdTFqb253TFFqL2YybXFBYmh5SkRWUFZpa0dyMG5pN0pCMEd3OUZxVjl1T0xMNVVGbThXNVRlVUk3Qkg1WVBhMUUvMFNTZzdGZXByeUJVeE5nNHBZOGY5c1d1VGxBNVR0MGtuMEliZDJpT2JhN2MvM3QxOVpPMENPYmpiM2UyU3AwL3ZmWGx0N1hIaTdlMnVyWkhpNmNmaEg4ZDkzMjlDZ3lrWUJlcGpZK2o2STVaTkVjV1kvdytHZkNmdjNzZVlneWxmOTAyT2hIRzN0elplb0dxdkZTYXlZOFUxeXdFTnAzaDBSbkthUWNXUEFpWDBrVDcyMmkvekFVSHF6ZlpLMVdxbEdJQkIzQ29RQllSaGF0ZmFmQVJtaldqRUpvK0tQNDVCL2hlUVcyL25WbUJsSHpJaml5WlBDYlBybjNPQ3JiSC9xUCtPcEsyRHgrNjY0NFJ1blZoUGg1b0dUYUcxRkJYRGtwMzk0QUcrc2xTSk03dFZONUphTFNKZFVUMitlMngyY1pIMFp1cEVVTmJidkVuc2hYRnhlVjB3ak1weXhiT3AxdzVGczNHMVREOEJmVnlCbThVUjBxbHNHbzBuQ1RtNTl1cXpFQWc2d1k5RHU1SGNRSTFTcTdZa0NNcnEwakJRdDJZV1d1V2IrYTEwMWpJN1pseU02MTc4Q0Q5YWZHM2lna1ZQWFQrMjRzRy9YanQ0SS9sQjNheDJlalByN2VhOVNXUmQvYTdZenk0L1YxdGJJRmsvM0NkeG01QzhwZHY4U2c0eFNuNTY3L1ZXQUhyTGEyRDZ1ZmFoV2ZFZVVUZ3NpR3h5ajlEWlBMelpFY1RhQm5rNnNLNGV1ZmRlMk5RS0pvZUpRcENzTmhxcmFldlE3TFJjTHBQUFFIdGl2RWJFQlNzc0RzSGt5Y2FnazhYa00zLzJ0VHZlOE1ibjM1N2NkdjRja2pOZXV2UUh2Y2R2dU9FOTY4TndlUXlpSW1hNWpVL3UrNlRSMnE5eHlUVXh2dHZjTG5lQ3U1RzdCV3ovTzdsN3VlZHhGN2tYWSt6YWNEOTJqYVlZYXpmdWo4YXBUUHVnb2FReUJxUUpLK00wOGlmSERmdTVSNXMyUitNbUtHWjQ1amhnWjhONXpjaS9Kb3hzR2xLR3Y1aGRteFF2c244Ly9aZ2cvN2ovK2g4UXlNUEM0cHRCL0Q1bXZlbml4Y3ZyeTMrdzlLNzhpRTljdkhpQUxHdkszc2RFZW9TdC9ycy85Nnk5UHpKN0Y2LzVKenpNOHo4Zy83a2RHZWZjRjVpR1d0VU1ZNGthc2tPTzgzdUh3RmcrbzVXVnF2UUM0eHVtVGExSFRWRGFoZUFYTE1jbUQwdGQvaGZ0d0gybDFsTitUZGUxaWZ6OUhQOHkwUGNXdVJ1UXQ0bE1rS2ZROGNiaW1uSzlqZUZVRGFGemc5clJ3WFlUSWUwdEpsZ2dmM3VkUjNpVFJjTFFCRUVWWTNwVlRMTDltTnhCZ2pCZkxPU1lZWEd6RUdQeWpwbW1nakgxK3J0a1Q2c05USkhJNzlhZEtsWDArVU5nb2toRTFLc0NFU1JZL0JqOCtJandNenhmd3BCK0loZ1ZVTHJJajcxYjBhaHZ5S0JvQ0pGSGtmeEdmN2MwdVJwNTJ5M3J0a2FibnYxVlJTRmlwNno2eWxkdDFSYXBzWEtJbDNtb2tnSFNneE1jU0RYWmxNenovS3pBbDNnWjZWUm9BSHJjM2x1L3FsTkprMFdxcW9UTU5FMUJzcHpKSmRzVjFXZDl6ei94cndYYjVRSmFxMGdqektRQ3Rwd3Azc1pFR3VSazlibGphQzdQL3hvd3ZYUkthendleGYzY1JHQ0tkYzdoMFJ3eWtocit0ZEo1QWNycmI1UXFOY3l5Sko3SFlVdVlsQ3VSNFpuVU1KNHZkNG9nWmF2RmptdzZzdVpZWHNYUlNycGNkcU5HSTNMTGNzMDBsSXBLeG9wMFhyb3NDVU5DZURrMUQraCtlWElwU1N4WG5KbWE1c2ExMmZYWldneEZVcXgzVS9nRVRsRHYxUVBIMXcrWXFTUUxJNTVoSmw2R1B2Y3l0TDVYY2ovS3ZaTjdpdnRaN3VQYzN4TVJSNG1oS3V3UWtMWTB6cjdubDJLQ0NoMC81MjhMMDN6R1dmeWN2eDJDOE80MGVxNWZuZEF3Z3F0ZnEzMWwxMlVaUVVjTHF0dFF6cVlMKzF0aWxBNXlPdmxNR1Y0c3ZXNEtkZ3lDRkRBNE52aDBiQjBIdldTTXFjOEZ5VElJbVdGK2pXaUZCYUMrWDhZUUZKSE1DM1N1cHhoSjIzQ0tWUWNLTVlpb0hrVThIMFU2alFMZjl0MUswVEZiaWFIMDVoU2gzK2ZIcTd5OHZpR3I0dzNWV0I0WlZuZkJjc29KMlB5QjQ0cWk2d1NHYXlkbDIxN29Xc1pvMlZBM1ZsVjVjMTNtVjFjSjN6KzVlUGErczB0TE1Ga3N6Qnk5NWVnTW0veStpcVFoTTJ6cXMrbHZ5THdwcVFMdjJicklVOVhRMExaWG9Nb1RENVFrTUhpUk85a1dERjNtWmRHUU1BR0dDTnVpVG5UcEVibGdVczBvOEpvaXloK3lWRm1VeEdJUXhIN2cxc3VlbFRac3JkUFNKUVN0N0JDcGswbGEydGF0ZW1LN3Bacm5lM0VRcUpacFdvTGcrNDdtT2JXaVk4MW5wajd1cThyQmJWazhkbFFneDQrTFI0K0pkT2Vnb2cxV2RTT2J0NXhpemZWMHgvY0ZCQ0N3dWt1VGwxdzh1elF6ZWNtWm94aFZyOGlLcURuVEJXR3lvRi9nWmVWUlA2UUhlR2tHYmgwMllLSkhNT0Z0V3hFRlJkRnNRK0o1djJKcGlITm11cG9oaVpJalc3VDVmQytpaHd3RmlidjNZN2ovZ2RrdFE4WVpraXQrKy81RTF0WVJlc2ZLYlJYR0VkYlozeHZsMFUwdWl4UmxjU2pNRnNXdThVOEpOYXJQczEzRE41ckpnNEVpRWN1em9KNCtQMm5DSnRkK1h0V2d2R0tKRDZpZUY2cTd1MnJvZWVvRG9rWDZrUjdvdW9GR1dMdFJVNmdoYUthcENZYXMxaHB0M0dyb2NFQzA5eVdWZnRTcUJTOS9lVkN6UGtxdnhpSmRBamthb1I0SnltT2FwVEdUWHlGeTBBN1RNWE5lOWNtbEEyZnZPWHRnYWVtSWVmUEY4K2N2M213ZFhucDdlVVNldm56NTBhWEcwbGUvQ3BQTEJ5WTJYYTVEN21KMDNIUGtNMHhoVTBGWm5FYjdNMVRCNFdEWVlSd0hJUnZoaWRBVlB4cEhGRWZpY1RmMGhwMHAyQ0ZzRDY3WE1kOGNibTJHQlZrcWxpdnR3S2U4NWFiTFdXM0dONTJxRDJhQWNZUnZMMVBMeEF4S3oxbHdSSFdtZ1BqV2dhTVlpbFA1THB2Z1E3SGp4S1cwdWVNSDFMVGtZYXV4SkRzYmMyczJYVmcycTZVU1NWcTN6WkYrTzNBRVdtMjJubkJLWlVVTTZwSnVLcDVNcVNTcGJyeTl3R0luOTY1OEN2U2NMMEEvT1VaVUpoS3lkMlNqV0JZRHY0UzN6SFhXUEYyWnFkQ2R0Sk1UZXRRbXNLMnluNC9GV1h3WU1Pd1RGbXVJN29zT0NZb0w5Y0FWbW5wckp4UEhJNStFdFlQTE82M3RUaW5tOVdwem96YzdveXJkNXYzM0pWMUZDWUxiemNBb09kVDBkS1BkUU1qbDRnM2xTcWNRRVRKTFRwNE9GbWZtWGxtdVpRZmFKSG40ME5yWUtOeDU1SjZTZW5yUVBwU3BVYWlSWnUzQndkcHN1MWhxemEwUEYwM0NsUzFGZ2FiaVZZM0FWNHJGSmpYblprcnQ5RUVXTi9CWnhsRXl6OTNCUGNEOUFQY2FrQkFjKy83cE5SaTJ6RXNiTWhSTTVpVzZCcTEyZ3ZpSGNZUXM3MzA0WHB0UTFnejNoeFkzcGt5U1daQkFCVXBHZmFoTmJJNjlmaExEVnVidUdUQkh6eklEeldWaDI2aWNkRmprRnh2ZFpQZVpvT1hIT1ZzaUxwTFBlTTNSeWFoY0Ftc3NMaGs2SXZsRnRUR1JaRTJWZEVVTkI0T21MWGVMQzZvT2hyUFNEaHF5V2UzTlYycUl1dDByZUJnMnIrcVJYeS9XbzlqZldheFpGZDE0dDhuWFpTTFBnVG5SaHZuc0lqRVh6VmF6VCtsYU85TTF3N0hjV25QQmR5cFVGblhOdFRTUFFpY2xHY2c0cStpMkY0TVUxa1NiVmp5ZHZNMHhBNHhnTk1QU1RIdTRVaHNrYy9hNnJQTUlnNjFxTVRMVEVpM29uTGpyNE9aWE4ydU9ndFR5UXBKcWtrRFBtVWxsdGpBbno5ZlQwTlBoRHNUUnpNSndWYUJ5Z3pmNWNXTmVNQVdHd2lkdnBBMnozZm1ncTBJRGNyeFdJVnoyVGNzeE5KQmxtcVhZb29vanJLYmg2cmFNaUxTU0lObXVkcjFOdWZJY05xVzhIeFFLTlNLYmpoVXpjaGI4K3JCOFhTTnY4VHVIZWhWZmQ2aHVpS0VkVnFBdXQxV2RxbUZHQk5mMENvZFdybS9KUDdsdzg2MzliTXV2Mkw1WDBtd2lqbzhVcThLMkUwbUNja1lneks3L0ovSkY4am91emZFbXMrZDZtbWxseE1lNUxKeS9jeWVyV0xGbXUxSXRySGJkcWpzd0hFMnZsU3U4RUh2RjV0MUhTT2ZnWTY4Z3gwZm5pdDJ3WEdxWkVaRk8zWi9PaUxPOXVBN0Y5Q0tCdjVxemtQdS8vaitXelR2MzN1ZVhTajU1Q0tZOS9zQ2hoVXFndWF4c25MQnFCbVplTmwyZXg3TFpoYklwK1ZmUGVQZml6ZWNHMlRhVVRRQmw0eEJ4OVdpeEp1dzRzU2dxWi9pOGJQNkV2Slk4aFQ2UGRpaW5rL2FhajlyMmN5eFlISEpoRFF1YUR3TVh5OGRZYTRSY0toZmRjbFNNakhDKzJDbTM3UnVNWm1tdVYyL1BqUmVIeFlBUXk3UU5SMUhzc3B0dWZtRWd0MXExWWdRbWI2MTMrUHdUTHo2ek5lcHQrMmVlZHpDdExtWjFYcFRNOG55aFZPZ00vV2tleGhLNUgyUFJ5U2pIaldkaDExZEp5Z1BXcCtTS2RJY2g5eWVUWWVqY3ZaeUJDYzRlUEZmVVYzTEVvSW1maVcvS2hRMFBWQnpUOXpWRGxhbDZ0NnhhZ294dHZ1VUZscWpyR3dIVnZUaHAzYmRZVmhFdVdmRzdSbDFXOVExREY5VGpxaXdURDZvbk9SbTVRU21xaHpwVjFKY1ptcUs3MUhCdU45WDV0Tk0xTlZjcjFsdUxDNE5WV1RKS0JhckpIU01WcVdsVVRtcFVVMG1wV1V6eitQdDhuSXlBZlhzRTQ2d3hNbTJSN3pEYkF2V0dGZFpad1ZvWU1HemZ0UG45RHNqZ2k5V0ZpRmtsYUtVbHpPYkR0UjBCSmZQRG9VMkZWYkMxMUtZc2l6T0NhbW5DakNqTFlBQ3RpckpxMk9RRi8vd1JZd21QK0pKdEtGUmM1WWtJUjFCeGh0Y3NGWTZnVWxNVENiOHF5WXJoM0djcjlGR21vTjJNanJDYkZWbVZ4RWVwS2l2LzdJNm5FVWpyK2wyS0pMRmRFOTBNNmdSeVlzdWN3ZlNaTEMwVENWVVpnVHovOU9yU0wzM3ptM3RQakI1N2JQVHo1Tkw1ODN1WHlLWEdsNys4OTAwOExjZTZWc25QY3hiWDQ5YTVVOXh0M0QzY1JheGowQmhSWTZsaFFrTU8vcytRUlZna3kzaGxHZjIyT2RzNkZPNFlYYjNvNkFWVkoyTG55TkVFcUVYSTBmTnJKSnNTeDQrbkMrUTljdEhUZFZFcnp2aUs0SnVmSFQydjF1Z2U3eVRqU0JkdDB0MHVtcnhJbDNSdE5OdzhMaXljdUhXM0xjSDBjTXMwWk10SXQ4cTY2SVNpRTNpemMwOGFCN2ZqMHVaMitYbGFaRWhCYk1peGlCUklLcWp3WUJXS3ZPWHpVandmYTRLNTk1MmsxcGhwbmp3ZStxU1Y2cEtiTmtIUmQxcko2V0xsbmVYWlFFbFd4bXhLMmtMb0NyUjVJREhBS0ZoYW1JOEtlNSt2Vm9MaHFPVDBpYWhBUXdIVndvVkhwS0pJRlNiN3Y4SDNvZDlIWnIxWmJwczd6clNmbFJoRGVGbUtFQjJ6U0d0V2t2dm9hdnV4YTlJZ0oxOWdhVVJnK1RFNGpvbkZQRWtmWTB2a1NVMVYxbTVkSEY0WW5QRVA2NjFRMGVUNVV4dWd3Y2VlOTBPNjUwV1dSWDVxNGRUY3dxbjUrVk1MWGxzWTJYWFAveU93bUZITnZ3L25tbVdTQXNtMlcvT25lcWZIRzZsQVNSRE1IcHNabXBFSmYwdjU3S25Pd1U0SElaRlVVbDJPeTdWVnd6YjIvNmF4WXJtc0MrRjl6eURhazg5ZUZZeFRlTmZ4TWh2RVh1QVpZbDJIb1RRTW1GOEZveHBaLzdWUEpKQm5MUHZmRzNVTE5uSU9JY21qK3ZqTjFtWXJFTXdWcWQ1cWJiWEN6dEpBOEdRdDhObzExNElHQmlZZTVtdUFBcUtiV2lBTHFxeEhpSWh3M3pVUzlZc3o2YTF4TkhkaXJySGVLODZkSkVmU3JWYW5JUzJaZ2svU3JiUzAzQTQrUTNYa2FYSG1RSGUxaUVTckl1Z0hnaUNBeHFBSm9xYUpCdUVGbmJqWGFkQ3Y4Nk9iMjdlZG1DdjAxaHR6eCtldWp2ZGNabmc1WFdoYlUzNE5yQXBSUHk4ZGVNZEZLSzE5YWczMm1qaVVtRXlSR1pucGdKZ3pyRlBQd3pvbnhTWjBNdkpEamJQem13OXQxaG92WDE3YnZMaVZmclkvUjQvNlluWGx0cFgyN3JEV1A5ZXZnZFhLUzZhb1ZDemZBcXNYbW9iZzhwSUkzUlh4SW42Mlg3Uk5TeTFTd2xOeWJ6M1pmT2lKL2t2clpiam0vTm05cjVSRTd6RHREZUZxbGVIaEZzemViQXRFcExZa1dycGRFaVJSMFVSNVJvWWE1QS9xL0dha1kyQ1c2enFpd1ByeEs5OWc5V09SVytVZWgvY2ZJcVFBeGV6N1JaSWliQ3dHMHNZMkNURjJoa0VOMUVsL0J4TnBNZFIydk44NDZpUzBDVHVXWmpaSkZ3bTdCcnBPaHpza1B6YmVJZjBZRGdqemZIa1dxamp1ajZFakpKY3JRcUJWS2ZWQkxJSEU5UU5GcWVnQlg2M3lnVmFqU3VBYnNGa1BReFUyaC95RkFrdGVYVjRjaTVrL3N0MHNDODFaTTJxMWJXc2NkS1RSU003Q29XMjNXN0V4YTFTOXFFWmFpNVhsYW50ZENTZ2ZOVWc5VlBXQTNTSVVTeVV4MU11cXd1NnNHQUZvdFdVakZLcFZJVFFxaWdwMzdtRGU3V0xUdGJwbW5IWWNleERQVUx4RnRPTGFhU2V5dTNhUXRTeG5FR1R5WUVHcFIwVHhsZlZPWmJteW1OWWpQeDhMK0JaL2lmd0V3dzluamtld2FKRnNKcy9UcE1OK3lOQ2tJL1FuVGVMUFV0aG9NYVFBaGhvS0ptK0lmbEJvaEQ3YkcvT1hNcmQ0b1d2ZDNKN3o3ZmorV0l0SzNnYzkyNlh6dTViYXFrbUZWS0dlSHJ6TjhlV0NEVmE1U3YweWViWGJVRGZFMmZoVmttY1lsOGhiRGRKZCs1MDd2M0RzNXU3NGE2dFJYQVFGQ0F3RDYvbnZyM21IMS9UUmpZNk9hTWZFTkFhSlA5Y09iUXRXWE92VjJqMERoSVNYTEhKOUh6T054ZWJjY1ppRzhUQ3RrMkU2RFB2RFg0Ri92LzUzZi9kMzVJSC91NjVyalpIYnFPTTdIbnU4dG5mdHRiMXJlKzE5MnV0ZGJ1KzE2MzM0M3JmM1VrbXVPWlFRNlVBSFNVUWJnbkk5VXFybUtBaFFGUFVEUkpXYXRsQUppVmFWV2dVUS9ZQktTOVVtbFE1eFBNU0hJcUVRQ1NtaWZDRWdWUEVCb1FvRWRaaXhkM1BibzczVCtURWVuMFl6NC9rLzV2Ly8vY3hYWGpaLy9JcDk4emV2M2hyZ0l2MGEvRHVNaFZDd3RiK0JyYklQeGtneGJWK2RBTHBkdy9NT1lVWEF3NTNCa25CcUcybXRFRkFpS25GcTBRWktMUXJ1dXhmbUh6SUJSUFlzR282ZkN2Nm9iayt2dlZNcXJxeFNGVGFSUkRSaU1rYk95QkN5WjhOdW5EQVJaRkRha01UQ0E5T2p4NG93cFJHaVBBNVhnM0VEck1yQW1oc092UGhYWXpTNG5Ydm9lZTduTjJBU2ZCd0FQazdTYXpnT25uNzZIeFM1QVJQZFlnNFlLV3lRcDJoSmtGVnNtVmlmbVBuRnFKc1F2T241encvaTJuOFY5Z2NUbTQwdFkzbi82UmgrWUFGaWlETUhhUTE0aFk2UUNZZ2c2bXJJSVRIdmRxMXBFNUJuN2FBTXo1MG9ZYTJtaHZscVpEM1RQeExwYU9Gc2R4bWNSWFNjNGlIS1NEQi9kTVEvbFJkRlBjMlFUamsyV1U0SStBS2xkWXVJUTF4MHY4RkMrb2xlb1ZCeHFGMlFXbXJNT0FkZEl2UjJMdTMwd2dQUWc3K1o1eGJHYlZubVJUckZKZ1JKTnd2dE1ZQU5VWTc2eXhOYkZIRm1nK2oyenhzR24xTGVJRHdNWTN5aThyRWJ1Yy9OK1A1UTZGdXYvMTk3TzRQNTl3NTRGOCsvUEpickJFVWc1bW9SUW4zSXpra0NvLzFxNk15T2RHdXkzNkozc0xqTFJJeHI0TGNXVnl4UEZId0ovL2lGaVI1bjVTRmNhSFV1ZGIwRkNJTW42L1Uvako4ZHFXNC9kTzNhTjBwSHM1WnBBR0NZN2FPbFJzZmJ6RnBXZHRQck9ETlhkVWt1WlczbC9FdzBqcEV2T29GbmRSN0xsckhRWXZuSXJuZnhzaGw2ZDUwUTBLV21SeWd2Vkd4dDk4cnVXbmdvOWJIcThDSDQyYWE3K2N5azVEWEZsb1pXVVc2dHNMcUQxOWk5dFg1ZGZCN0E1czJkMjNNM3E1ODg5ZUNEMjd5WWw3NVdXTTJiZUNFUDQxSkRyRGhpQjFmQ0ZrYTdWRE9Fa3hjY2dudUVNakZpOFBKZWN3NFVBRGVERnlMOHR3Z2M1dUJTeFNld2wxV0NaNVZzVmdIbmxheExVOXlGK2ZrdjhoU0JzenBQMGNGL2podzVjcks3QzVUOS9mMkhlN3RYSGdBWEQ2cG5nOGRKcFhYUFc2ZXA0Rm44MHZ1dWU3UmFmV2JzWXY4Y3ZPZTY0YmovRW44ck4ySWF0bFUzd2d6NFVCdU9tQmNpY1BzUStXMFExSXVpaDJRU0ZFQmZhSWZFbzlXSTBUcVUyUkpJK3hFTlN0dnQ5amtKUS9nTC9DWjRwSnlQbzFsTDd4cXpyVXh5c201MGFmYmtDeFNkUzJwWTllQTBtNkVCb0ZVNVRsT1FZWk01RzV4bEZWRVdlUzJ1dWFoV3JJa0NCQlNUb3BNSUJ0K3ByWEFnWFMzSUt1M045MllWZUhsa1VSSXFITXRRcUN4S0NXMTlQTnNBNE1TM0tkb1FaQVFwVGw4dG1WcWlPbTBLV0pXcXBPM0phYlpTTnRWVUhDVWRwdEZjR0xVVkZrQ1U0NjJpUFBjYVpVUEFxd3dFQlpySnhlbGhmWWVNZWZuRGRsN0pGdEFpYURScjFVZ0p4TFlEcTRkR0dlRmhJc2JiQjV3ZndWOG44SkEyaTVCbUp1Sk15V051bmx2RzR6VVpaNWEvd0xDVE5IM0lpZmtuUkc5MnNiWG1mNHE3OWRxWDhjVmpQK1ZRNkhjSThGeThIT3BoemhBLzJ5THduS2dwdW51b0hTK0M3RmljWDBJTXRRYkFHRVJvU1dBQmQzVUxyOXBMQ2ZZelQ3SDhNbUwrVG8xdEpEam1xL2N6WEhMei9lOHpYT0tIZHhQY3NBOElSbnU5Qk51RGNPZGhwVWZQdE1CZTBIdDNvenpCb3NTNGN5d1BYZ2g2WU8vdVUxdGkwdHE2ZXVvZTV2dVA4UGV0azcwbHJBcEdQRnVhNTJQUlExekJuby8rUyt1S1FkZnF1bHVXSE1VK1p0aHJKY2xOVmI5M202WnZyNjVYRnhzMFBmLzFXdmZoV1pwdUQrS1pKOEk4N3BqZWdTMWRiY0hNNVF2K2lWUHRyL1N1Z2ZvZG9BVXZ2UlR0VThjQ1hFOGswWWsrWGpJaUtvNVpJRHNkdVk4eU1ndSt1OWs3czU1T3I5UlArUG1xYnBsYXJmRDQvdStxNTlxdTR3YXhmU0NhaFl1V1FURGJncnR2NGI2L0VVdmp2dS9HanBCOVE3L0JFcVRwUHZhYUhxWXRJVjlEOXhKUzhhL2F5R2dERmRpUFFDYkl3UGtoaTNjM29nTU5VWE1pWXNndzF4eS85eTI0alhpU1VFQUliSkwwY1l0RGJCTklPcjlOeFlYUHl2Z0RZVWlLZ3lCVkRFRmxxSTZHVk9sVityZ051QlNOMGcwNkxpVHJGS1Fhb3NEQ1FvbEJLVzVxQ3JLUEFRZndySmpKcG5rSmxBV295aGRVbFpWL3dNVVRKbzNOakpQQlA4R2pXSUJUU1Z3aU1ndG1QTGtEVlE1UWdoSzNWaWpFb0lVVUpYeFRtc09LQU5Wc3N5b1BWUVdpeU5keDl5YWVLeS9qdVZrbkdQOXFpM1g2MUFTRXlpRGNSM0ZiOTV6SHhBMU00djhtc2Jicnl3NVdjZVYyelMrQXJUZlpuK1JIMC9wSXd1MTJnTEJ5WDExVUU3eGNhSlNWSk9CejR3dmVuVnM4OVhxVExSYkFvK3BJL3UyOHFxbWR5dHR1ZStyNmwreG1ScEdMVklzeDB3WVFyUHNlZWU1SzhIdVJBY2E0clBEMW9lK2F3bnBVTjh5S1Bjd1h6N2I3MENCaExDc1psWXcreUhieEl3TFh6dlhUcHdFei9NVVNsaGdvSitTbHVia2xmSUx4dy9mdmRidDNobTIzbE93cXVEeGlxc1UxODdPMkt3OFg1T1lHUGhIS0E1ZXc1S21GVnRkUXN6NmtZU1JabDhGS2I1VXhGZlBNMXRZWmZHSllndjdDL2w5SmNQMUpzRHI4MlBKem1qZGx5UWRGc2pYbGVmNzFGNC9qVnZ3UDM0WDZxZ0FBZUp4allHUmdZQURpNWswaVF2SDhObDhadUprWVFPRGFMcVhyTVByL2wvODdtVm9aVHdDNUhBeGdhUUJKL2cwaGVKeGpZR1JnWUR6dy93QURBMVBEL3kvLzN6TzFNZ0JGa0FHak53QzV1d2U1QUFBQWVKeDFWTHROQkRFUXRTOGlwQVJLbVFJSTZJRUVFVUZHNkJLdUF5Z0Jzb3ZRRmtBQmhCdEN4QVluZ1c3Rm1wbngvTHdyQXN1LytidzM4K3lVVXNwREc3dFNmL09FYzZKUks1OWR0emtPdG51VU5ka1dQcHZ6QTg2Z2U0NHh5N3hRWExZSG1tdHRPWEE5MVcrTlErZWNBeVJYQ1RrcExxQWY2UHFmMFdLMk9KZTR2eEV1NzM1UFdObXVpUDFCY1NrbnRCOFJzOXFIR3VVbjRUb0cvdWQraDM2emNrRzdhcnlMOEtLWnpzN1k1c2Zpamx2TzNUcnNPMHgzclNZWTY3UzVpM0dwcjFmQ0xjYmQrMTU5ZDhWOWVQNFFmNmtaajA0M1ZsZXNlejBxVDhjaC9XWmYwVlhyMDlMcENwcWQ0WHZsR2pvdlVHeWNwNXBlQnMvRk00VDloZWd2WURWZUUyTTRhUnptb1RuMllnUEtTMnFBR1BPWCtKYTZtT2JNaGpCN0xIa3ZYbk82VjU3UCtJNlV3MmZzZ2R5dmVXa1BCdGVWdlZkNms2cVJ0eTFYMTZUMWhITFA4YTF6ckhYdmFYOElmMENyd1pMdmNYM3J2WGRzcG9PR3NZUy9CQVFqck43YVM2OXgrVStzQnE1WHJIZlU5dERxdWdzOVVwMUVtKzR1akZoZjZxWDVnT2lienhSN1NuOGRuenBHQUFBQUFBQUFBT0FCVEFHd0Fkb0N2Z0x3QTJ3RXBBVTRCYUlHSEFiMkNCQUlNZ2llQ1JnSitBcWtDdllMV2d1b0M5QU1HZzBpRGxJT2NnN2FEeklQamcrMEVEQVF2QkRXRVVRUnVoSmFFbjRTd0JNaUU0Z1R0aFQ2RnNBWGVCZllHS0laS2hxK0c2NGNiaHpxSFRJZGVoM2FIZ1FlNUI4eUg0QWdtQ0QySWM0aVFpSnNJb3dpdkNUZ0pRNGxVQ1hRSmtBbVlpYWVKdDRuZkNlc0o5QW9NaWlxS1RvcHVDbmdLcEFxdml3d0xJUXN1QzV1TDFBdnFpL29MLzR3WmpFR01TWXhWREdLTWNBeStqT2FNOHcwQWpRaU5KWTFDRFZZTmJRMkhqYU1OMkEzOERnNE9KSTVlam5NT2d3NlREcDRPeFk3cER3cVBQWTkwRDZZUHN3KzdEOTJRQVJBUmtDd1FTWkJSa0Z5UWJSQ0FFSktRcHhDMUVNU1JDcEVwRWQrU0taSTJraitTYmhLYmt0NFM4Qkwza3dFVEdSTTZrMktUZnhPWkU3S1QxaFNQRkxNVTE1VHhsUWVWTnhWbGxYT1ZoUldSbGJPVjFCWHdsZ2tXUlJackZua1dqUmE3bHp3WFdCZGlsMndYbTVlcUY3bVgzWmd1R0RVWVFSaGdtSEVZZVppRkdLOFkxaGtBbVdTWmNobVVtZDBaK1pvU21paWFOSnBIR3ZJYkZKc3ltMVNiZ0J1SUc1OGJ1WnZlSEVHY2FaeTNuTStjN0owSkhTVWRQeDFXSFdLZGRwMlRuYWtkdVIzUUhnYWVVeDU1SG9xZXFSN01udThmRnA4bEgwT2ZXQjk2bjRpZnRTQVhvRFdnVUtCdG9Jd2dxNkM1SVFZaEZxRWpJVVNoWlNHQ0lhT2h4YUhzSWhXaVBxS0FvcGVpdGFMQ0lzOGk3eU1Kb3lHak82T0FvNGNqbDZQQ285Y2o3S1AvSkEwa1RpUlpwR2drZnlUTkpONGxES1VpcFRRbFB5VldKV21sZWlXTXBaU2x2U1hscGdTbVpDWjlwb2VtcWFiSkp3bW5IYWN0SjBFblZDZHlKNWVubnlmSXArY29DeWdyS0Zlb2M2aDdLSjBvdzZqV0tPcXBBcWtwS1R3cFNpbFNLVnlwWWFscnFZK3BwQ202S2N1ZUp4allHUmdZUFJtL015Z3pnQUNURURNQllRTURQL0JmQVlBSzZVQ2ZnQjRuSzJTUzByRFlCU0Z6OStYMklvRFgraEF1RTZLS0tTbGtFbG5MZGpPSEhUUWVkcis2WU84K1BPM3hRMklxM0FQN3NFRnVBQnhMZDYwbDJKRlJjR0VKTjg1OTl5VERBTGdBRzlRV0I5N2ZLMVo0WmpWbW5QWXdZVndIdWU0RkM0dzN3Z1hVY0ZBdUlRemhNSmxYT05ldUlKRFBIR0RLdXl5T3NXenNNSVZYb1Z6MkZjbDRUeWE2a2k0d0h3clhNU0plaEF1b2FFZWhjdm9xeGZoQ3FxNWFpZU9MTFdXT28xRC9aSEpwYmJ4b2xIYTArTjU0Smt2Wi9TYllWK2JkQnBINURyMUxDY3hkNnU5cXlOdFBLdEhOTGlqZERGdVdPdVRiK0tRc2hVZEJERWxKcDdwb1hVbTFpYk5XczBYM3huR0lUcUlFY0dDME1JU0dpbnJrSi9mK1FTWHJ6WU1QSjZQMk8reE84WWNBVHZtRDN2MGI1dDlWb2I5NmFvaHl6dW9iL3EyMjl3ZnZyM0xLbHAxZWJ5bk9VSDgxOTN4UGNXQ2N3MTJMWHpXUG1leVB0cThSWE5Id0V4SVZyTVpPMFAySFV4V1d3bWFxUEhwZjhvN25PS21kL0VkbW9VQUFBQjRuRzFXQlpUanRoYmRxMG5zNE16dWRzdk02SGJiN1piN3k5elB6RisyRlZzVDIvSktjaEx2WjJabVptWm1abVptWm1iK1QwNHluWjd6NTh6NDNhdXhCUSt1M2hhMlpmN1QzdkovZjNBZEdGYlFRaHNlZkhUUVJROTlERERFS3Rhd0ZkdXdIZnRnQi9iRmZ0Z2ZCK0JBSElTRGNRZ094V0U0SEVmZ1NCeUZvM0VNanNWeE9CNG40RVNjaEpOeENnS2NpdE93RTZmakRPekNtZGlOczNBMnpzRzVPQS9uNHdKY2lKdmdJbHlNUzNBcExzUGx1QUpYNGlwY2pXdHdMZTNwZXR3VU44UE5jUXZjRXJmQ3JYRWIzQmEzdysxeEI5d1JkOEtkY1JmY0ZYZkQzWEVQY0lTSUVFTmdoQVFwSk5ZeFJvWWNCUlJLN0lHR2dVV0ZDYWFZb2NaZTNCUDN3cjF4SDl3WDk4UDk4UUE4RUEvQ2cvRVFQQlFQdzhQeENEd1NqOEtqOFJnOEZvL0Q0L0VFUEJGUHdwUHhGRHdWVDhQVDhRdzhFOC9Dcy9FY1BCZlB3L1B4QXJ3UUw4S0w4Uks4RkMvRHkvRUt2Qkt2d3F2eEdyd1dyOFByOFFhOEVXL0NtL0VXdkJWdnc5dnhEcndUNzhLNzhSNjhGKy9EKy9FQmZCQWZ3b2Z4RVh3VUg4UEg4UWw4RXAvQ3AvRVpmQmFmdytmeEJYd1JYOEtYOFJWOEZWL0QxL0VOZkJQZndyZnhIWHdYMzhQMzhRUDhFRC9Dai9FVC9CUS93OC94Qy93U3Y4S3Y4UnY4RnIvRDcvRUgvQkYvd3AveEYvd1ZmOFBmOFEvOEUvL0N2L0VmL0pkdFlXQ01yYkFXYXpPUCthekR1cXpIK216QWhteVZyYkd0YkJ2Ynp2WmhPOWkrYkQrMlB6dUFIY2dPWWdlelE5aWg3REIyT0R1Q0hjbU9Za2V6WTlpeDdEaDJQRHVCbmNoT1lpZXpVMWpBVG1XbnNaM3NkSFlHMjhYT1pMdlpXZXhzZGc0N2w1M0h6bWNYc0F2WlRkaEY3R0oyQ2J1VVhjWXVaMWV3SzlsVjdHcDJEYnVXWGNldTM5TGV2WE5uT1Z2alVTU01rV0VtQWhtcG9rTzhNbXBrVjNoTUpKNEliWGkyeWtjam1VbHVoVTFGTG55ZUpZcG9qK2Q4cnlxQ2t0ZmVISkp4Ny9tOGlMV1NjWmNYaWNneWFleVFrSzRqTGJpVkU1cWdTS3FNNnlFdnk4QllwV2x4WmJvYnJFMUlhTWRwV3pSN3UwRTlidW84RjFiTHNjK3IyTzE1d0N1clNpMUdjaWEwenllU0YyTG1PV3ZWQ3ArYVRrZzdpWGhlcm9ZaTVVVWtBck9uNGxyNEM5b05aYTdDZFJGWlFqYXNvckd3UHFGSXlhSkZ0dTZHR1kvR2daV2kxNkJRYU8wR1ZaSUlIWVQrQXZYRHJCSldLWnNHWVhjRHI0UTIyaHBXV3RFYUloTXpPcE9sZWFyYWtGTjRiSVpSRk56Z1FyOWhZalp3ZG5ueVZTS3hMQ2dLUVpSVlliK2hKbElVRjQvd2VoUzZTWEp1ck5BUjEzR1hHSDFXOHN3aFE3NHFoWnQ0SWczdlJhSndyNmxZZUZGS3V4SzlLRk5WYkNLZUxXRXViVHBvb0l1OEhOR3U2UFZTRkIyeVVwUlNyRktXRk9Td1dFeEVwa3FQcU9YS2kwcHlmYloxR2VFZ1VubXVDdE9Kak5rVjhNeTJIT2hGbGJVWlJjdWtmaHhRYUlLNEUzT1RSbFVvdXJISVpDUlZaUWlWbWFwamxmaXhNT05TcXg0dFJxRzFYTnRXTEpOa1NBOXBlUmFvU1BEQ2J6eENaMjlzcFkzd1loV2xWZWpNV09oaHJQbkluckg0WmkzV01neGR2czlUb2JQa1BxVnNHYXFaRit1Sy9PZkZOYWZnOWdUWFdSMUtIWnVXaUJQUnBVRG01RWVsMnlLbmJQQkVYa290UEZGTXBPYWUwQm5sZHNmVmlSWlYzaExXMUFNWCtWaGFFUnVUOVVZOEVxRlM0MkMwZlFQbVZJS0NTa1d2YlF3dE5yZmsvb2dXR2FsWm42eXhBWjFXNkY2RG04TjVJL0xkV0hmSjBCRW9EMVpHV2IxMVJLRUorRlFZQ3JXTHdiWWJEWXd5bmd3Mmp6VEVpWUFKUnJLN1FXZ2FmYU5wQnBzSE9rUXFjb1Rvalp6cm0xMnZqclJ3R1JEVGcyclBkelEwY1M4Uk5paGRTR3czU1lKSTZpZ1RMRWw2RkpmRmVWY0lPa3JCY3lzTkYzRCtUMi9PdW1UR21vOUY0UVl5SGpwRGVlMG5tYVFWazNaanZVVFJ6a1EvVVNxbW5JeE5rSFEzOElCUVFobEFvWjgwcnpoU1pyd2VidUNLUHRpK21jMzMwTjgwdEh4NXlyTk1XRy9PT29tbUFxQVNiQkdZRUpPbEMxMDcwVlZoVzZSNjVmYVV1NndNQ2pIZG1IWFRVQ3VWcFJtbTlFM0FnMVJrSkJydFZKSGNlcW15Njl5UmF1L2VkbXJ6YkxkUDdqQ2xzaTJaeDJGWEZzWnlXalhmSmwyZEYrUnR5cnlNdktCOXFXYXBNcll2YlZVSUV4VEtDbStPL1hWUmpPblQ5cnFpK0hqclN1VVo3NjR2dDhiV1RXZmRqR1FjWjhJYml6cUtpK0dZY3MyNFlxUXRqL3VibURkV2VsSUpuNlNka3pvTU05S2xVYjRNMzV6NUdaVnNXWVd0akpLK2xaRzI5ZWt4cGdJcEFsbDBsdGdqUUFuVUpsUE5XbGs5c243T0UxZDRYczVudEFzL0Z6SEpwT21RbFZVZTVONGN0TWxvUzBUWXF1em1NdEtxdWM5eU9ldlFYNk50WGk3M1ZvVnM1U3FlZVNSVFFpdS80S1VUMGJYQ09hK0lWV0NtZEEra3Z0dEZzRzVhenE0VVpiNVNtSFA2UlVYS2FxVXE1R3lIaWdzMXByT1pRbzdsNHF6REd3MTJGQWtvcWJQMUhKQnhtNHptUTFWYU9yTlRTVnAzUlJuWkx1bUVaM2JkMC9uRmVDUkRJeEg3SmJkYTBPVzZFSGI2MkFsZEtmcGx5a010STdyczlMWXlWVFQzTEJoUkFvaXAwdU9WTWkxWFNiRGpvS1JMUURmMXRJbVdaZThHMWkrYmxCRWtMZVhXRy9EOE1OMk5nYjZyRVlxMU8vbUFkRG11SWh1a2xOaGVXWmxVeEY1WjIxUVZiTStlN3A2S2NpcmlwV2p2cVpUbWZwTVF1bTVUL1VXV25uUWhkalV0N3lwUUR3aVJRTklXcFNpR0M3TEltam56TmNXRXZpUmEwQytaTXF0am1zR29iQ0tMcEtjYlhZbFNUcThTMUxueERCOXhMVnVHb3VDWktNM2tqQXlKZmR3M0pPcFJTb3BMQ2VmdTRvZ3kwM09BeE5vSVBaSFVFMWtxeVlHaE9yUkdGbUdWamZ0RzVyUm9XTW5NK2thNnUzWFdNZU9ha3dhWk5vRlM5RXpUTGFSMHBiVWJTQU9rUlNaMW9tZ293OXorZ3NSVjR0b0dYU2o5a3ZlTXFxaG5jV25xbTFMd01TOTlWK04wRjY4Mm02S2lwdmZvdGxoUTF3dU1Nalh0RWEzbjVUT2dqT0xMdWx1U09nOVYxbTRJRGNsR2NQS0txcHBPd2llOE0yOFdBdVBOQWIxRFBaWWk1NUlUdHhQSjZZNnNTdXBWNXNMZDN6VFVOeFVsVWFtbTFETjRoS2w1V2JWMFVUb3hjcnBhaU02U0RxbTRYQjhTVElVTVZiZnBKNldoWFZDS1o1bnF1N1dwN1pSRzZXR3pnRjRtd3B4NXRpbkxWV2VjL2l6NnVRVnQyN3BVdTFyVVR1aDJSWlZuKzFUbVdpUXVXclZQaVVxS0VhOVVKdXhVeGxSRndWTnZ3am5KalUvOWhXdjZobVJqb1pacnpsbDdJbW5Dd1VUbUcvL3g1MlRTYm15THZDVFlaTHd5S1dpa0V1dW0zUnpQbytkTUZtdFRpcXRwdXR0NXJKZThQVTN6eVBTbnRGUFhJZkJnNms4bGFjL1ViS1VLanFteE5hVERMdTFFZDJPZ055MURPaEUxWVpyZ2hzSlBTN3J2Y3RPYVVRdlRwMFdUeFdJdGh3ZTFhOGhDaXFWclhHcE9GOHFPbXZvdk1Rdm1kMFZUMHRUMHpBZGJOZDA3N1ZwUldheldxckxreitXNUYzVExsdjhCZ2U4V2Z3QT1cIikgZm9ybWF0KFwid29mZlwiKTsgfVxuXG4uZmFiIHtcbiAgZm9udC1mYW1pbHk6ICdGb250IEF3ZXNvbWUgNSBCcmFuZHMnOyB9XG5cbkBmb250LWZhY2Uge1xuICBmb250LWZhbWlseTogJ0ZvbnQgQXdlc29tZSA1IFBybyc7XG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgZm9udC13ZWlnaHQ6IDMwMDtcbiAgc3JjOiB1cmwoXCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQVZDSUFBc0FBQUFDM3hBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJIVTFWQ0FBQUJDQUFBQURzQUFBQlVJSXNsZWs5VEx6SUFBQUZFQUFBQVF3QUFBRlkvdDFENlkyMWhjQUFBQVlnQUFCU1hBQUF0Q0NqdTcyUm5iSGxtQUFBV0lBQUJHNXNBQW5GZ2ttbjZMR2hsWVdRQUFURzhBQUFBTVFBQUFEWVBDNFpCYUdobFlRQUJNZkFBQUFBaEFBQUFKQVE3QlFWb2JYUjRBQUV5RkFBQUFwOEFBQXMwVGEzK25teHZZMkVBQVRTMEFBQUhkQUFBQ3pnRFlDMU1iV0Y0Y0FBQlBDZ0FBQUFmQUFBQUlBUHJBWjF1WVcxbEFBRThTQUFBQVZvQUFBTHVONTNTUlhCdmMzUUFBVDJrQUFBUzVBQUFKV2g4MXoyNmVKeGpZR1JnWU9CaU1HQ3dZMkJ5Y2ZNSlllRExTU3pKWTVCaVlHR0FBSkE4TXBzeEp6TTlrWUVEeGdQS3NZQnBEaUJtZzRnQ0FDWTdCVWdBZUp4allHUjh3amlCZ1pXQmdYRWFZeG9EQTRNN2xQN0tJTW5Rd3NEQXhNREt6SUFWQktTNXBqQTRmR0Q0TXAzeHdQOERESHFNWnhoY2djS01JRGtBQ3YwTk53QjRuTzNhYWJ4UFpkY0g4Tjl2bllPaXBKRWtJVTJLWkthU2VTaEVoa1NrSXMybFFta21OQ21TVWlITnM2UjVFaHFrb3ZGcHpxM1NjR3U0OTdYM3Zyc2I5YXgxZmw0L2I1L254V04vdnEwNjUvei8vNzJ2YTEzcld0Y1JnR29BS3R3QnJoS29kU3pvLzRhYXcveXJyUHA2QldwV2ZiMnlaak9BamZ5TE5kQW9zNnhhVmp2Yk1kczUyelZya0RYTU9tYzlzZ0haeUd4MGRtWjJTWFpaTmlPN0tyc211eTZiazgzTDVtZUxzanV5SmRteWJGMzJiclkrMjVCdHpIN095bXh6cXBWcXArMVRnOVF3TlVrdFV0dlVLWFZPdmRLQWRFd2FuY2FsODlPMGRHV2FtK2FsbTlNdGFXRmFrcGFteDlQemFVMWFsejVPbjZiMTZkdjBZL29sYmM2WjE4aHI1UTN6NW5tN3ZHUGVOeCtRajhwUHp5Zm5VL0pyOGxuNURmbTgvTlo4VVg1M2ZuLytWUDVzL256K1lyNHFYNWUvbjMrZS81eHZMdW9YRFlzV1JlZGlRREd5R0ZXTUx5WVhseFJUaTVuRjFjWHNZa0d4dUxpbmVMeDRxVmhWdkZxc0tkNHUzaTNXRnh1S2I0cWZpcndvaTc5S2x0WExPbVdUc21uWnJ4eFVEaXVIbHpmLy9UZVFJYXZNYW1SMWZJVHFWbzFRNDZ4TDFqc2I2Q00wSmp2YlIyaGExUWpOeW1abmMzMkVGbVNMczd1eXBkbUs3SjNzUXgraHI3THZzaXo3TlNGdG0rcWtlajVDalZMVDFESzFUNGVtTHFsUEdwaEdwakZwWXBxYXBxYzVXMFpvUVhySVIyaFplaWF0U0d1clJ1anp0Q0Z0OGhINk5VZGVtZGZNNithTjg5WjVoN3hMM2o4ZjVDTTBJYitnYW9SbVY0M1F3bnh4ZmwvKzVKWVJXcG12enQvSlA4dS96TE1DUllPaVVkR3k2RklNOUJFYVUwenlFYnE4bUZGYzVTTjAyNVlSV2w2c3JCcWh0VDVDWDJ3Wm9jeEg2UGZpYngraDJsVWoxS29jVUE3MkVSb1JJL1QvZi82SFAvU1YxcFI3c3cwNytkVzU2anFmbC9FNjN1M1hDbjd1MTFkVjEwWit5MDErL2N6TXFsdE4yOXYydFE1K0hXS0gyMUUyMnM2elNYYStYZWJYRlRiZjdyVDc3VUY3eWxiWkIvYXBiYlJOOXFQbDlzdVc2MWZiYkpzclVGRzlvbDVGL2FxcllVV3ppaForZGFvNHBLSmJSWStLb3lwT3JUaTc0cHlLS3lwbVZDenk2OEdLaDZ1dXBWWFhzb3JuS2w2b1dMN2xXbEd4cnVLRGlnOHJzc3B0S3J0VTlxZ2NVM2xSNWZ6S0pYNjlVTG5jcnhXVnF5cGY4ZXUxTGRmcmxXOVVYZXY4ZW1mTDlZRmZuMWF1OSt1cnVLcnRVcTFCdFNiVm12Z0E5ZVZxYThpeE50QWVaR3M3MXliYWViamRwdHZ1MW9DRnRjTUhQQld2MmZiNG5WT3NoaDNIRzNnck8vSkVlODZlc2VmNUd3YlphWFk2VHNWcC9BVXplU2pHYzZwTnNITzh1bFhEVnFqT2VWekhDKzBwVHVJWGZBQVZOZ04vb3JzTjRxN293Ky81a2ZWblY5YTNvL0FYbnNWelB2N1AydVZZeU45NUNiNURQN1JHR3h5S0Z0YVUyK01MbjVzWDBaTmJzdyt2WkR2V1kxM1c0cmU0MklpUGVTOWV3ak5XeDFyd0VCNk1idWlLV3pHRFYrQy84SWtkYVczdEV1NXNyV3l1M2NHcitEVy90TVhZYUR2eGVKeVArUnpPbzNrTWgyRi9yOVBOMFl5SDJ4dDJCdHZnUEhTeGh6Z2JhOWtKUDJBRDM3ZTYxaDlIOFViT3RlRjJpNTNBZSt4R3ZvenJNQS9YWXpZK3RON1czWHF4MG01alR6c1ZKMXQ3bTgvLzR2WGNDbS9nTGJ2WEJ0dEluSUQzZVFacWNoa2JZZ3dIOENmVXhuYW9nMjJ4QTNiRVR0Z2UvK0pNRzgrVjNNeS83UWlzc2tQWWpZK3pCNmV6ZzUyTjkyeGIzb1J2OGJZdDRwK2V5OXZZS0R1RzFmZ3JuK0hUdGkrdVlGdmJBWTloR1I3SFVteGp0K01DL0UzYWp2ek9MdU1Mbk1WcnNJaWZjaWZiRTU5aURtN0VYRlpuanNKMnNiZHNaMXZEZzdpSEhXWmRyS3Qxc3g3VzB5NjJpM2c3NytSaTNzRUd2TStPNVN2WUdaTndBMzZ6Rlp4amZWaGhDOW1mTTdnYkptTUZQOGIzK0tkVncxVjJwczNHajl5Zkxia1htM01mWDQyTmVTRDM1SFZZeWZjNG5pZndBK3RvVGF3eFRtRjNtNGV4L0NmWDJDcGNoT1B0T255Slh0eUZiMk1jYnNFQzNHWXo3VXFjaUF2eHV1MkZtM0VUa3UxbjkvTlZPNXJqN0hFK3hpZnNXcnZHSHVNanRveEwrU2lYOEhYMnRqM3NQbnNBeDluVk5nSWpNQm9qY1N5TzRXczhoMi95TFJ1QzFUaUNaL01zbnNrSlBKWkRPSXFET1pvak9OU3VzcTNzWmt6RjVaaUdTM2d4SCtSRGZCZ2Y4VU1iYWdkWWM0N2hQMndCVGtKdmZvVnowQU8xOEpPMTVsMDhqdWE3dnRrOVBKY1RiYkpOOGNweGdkZVBBM0UwLzJXdjJtdTIycTdnazliWmx0dXo5ckE5WWt2c1VWdnFWZVV1dTlWdXNEazJ5NmJhTks4NncyeUE5YlUyZHBEdFk3dDVYVEtyc0VyK3dZdy84RWRPOXVyMUdUL2hXajdINTNrYkYzQWhGL0ZtVHVPbFh1VXU0RWs4a2dNNWlFM1lnczE0Z05mQnB0eU90Vm1ITmZFRW5zUlRlQnFmWXgxZXhmTjRBUzlpT2E3R05iZ1dzekFkbCtJeUhJNis2SXpEMEJidDBCNGQwQkdkY0RBT3dZRm9pWVBRQ3J1aEFYWkhRK3lGdmJFUDl2WE9wekdhWUU4MFJYM3NnVWJZRDd1Z0x1cGhWKzdBSFcwNzFyQnRySmJYMXEydEVZWmpGQ1ppRGQ3RU8zZ1hYK0ZyL0l6TkJGdXhGeS9pMWJ5V3QzQSs3K2RUWE81MStpV3U0Z1ordzJTMXZUSjNzSU90azlmbEUyMmNqYlZUN0ZLNzNtNnl1KzExZTlsZXdXZmNGa013R0VNeERLZmpERXpBbzdnRGkzRW43c1pkdUJmMzRIN2Nod2Z4QUI3R1ExaUNSL0FOTnVFUDd1NTd3MkU4Z3YxNE1rL3gzV0U5L3pKWVMrdG54OXRaOXJTdHhOYm9qd0U0RWdOeEZzN0UyVGdYVTNBbFhzWXIrQWZXZTZ1UzQxZVUrQS8ralYrNEgvZGxlM2JoVVJ6SjAzZzZ6K1BsZklQdjhoM2ZhZjdOa3YreCtsYlBkclZtdHI4ZGFtUHNKRHZaTHJRbjdFbDcwVjZ3bCt4TnI4M1YvN2Uzei84RGY3YUpmelIrV1A5aGE2TWpGUGIxU09GcWp5YlcwR09sY0t6SGFtSURQZFlRZTlEalZzTFdIcmNXTzlkalRiR0pIbXVKNzRuSXRoSGM3bkZic2VrZWE0dnQ3ckdPV0FPUDJ3c0xqenVJNzZmSWRoUjg0SEZuOFQwV1dWM0JheDdyaWNWNzdDcjQzV01ENFJTUERjWGltUnFMSGVleGlmQUdqM3NLYi9YWVZOalI0MTdDRXozdUxmYWN4MzNFbnZHNHI5anpIdmNUMysrUk5STU04cmkvMkdrZUR4RHZCcEExRjhSenRSREV6eHdvM2lzZ2F5bVk2ZkVnOGY0QldTdkJlSSt0aFZNOXRoR2I0TEd0ZUorQnJKMGd4cUc5eEhrczZ5Q0llZTRvOEJXVmRSTE84M2l3Y0ozSFE0UVhlanhVN0NtUG5ZV1RQSFlSZnVHeHEzaFhnNnlieEJrdzZ5N2U2U0RySWQ3eklPc3RpTy8zRVlzeDdDdU1lVDVjRU44L1F2aTl4MzdDanp6MkY0czRRQmozTWxCWTMrTWc4YjRLMlJiZVlTRWJMTjVySVJzaWlIa2ZLdHprY1pnd2Z1Wm84WjRNMlhEQlFvL0hDQ01uUjRoM2JNaEdpdmR1eUVZTDR0N0hDR0kranhmRWZKNGdpUEUrVVJENU1sWXNjbmFjTU5iQ1NZSVkvL0hDbnoyZUxONGZJanRGME5QanFjSlkzNmNKWTJ4UEYxN3A4UXhoNU5HWndsaC9ad3RqWFU0UVJqMDRSN3p6UkhhdTRHS1A1NGxGVFpvbytOampKUEVPRmRsazhWNFYyZm1DV0dzWGlFWDltQ0lXNDNDaE1ITHpJbUhrN01XQ3lMdExCSkVEbHdsaXZVOFRSQjVlSVl3NFhid3pSalpEOEluSHE4U085SGlOV0t5eldXTHhPZGNKbzI3TkZvdjFPa2RzcnNjdDdBNlBOd3JqdmVjSnYvWTRYL2lseHdYaUhUbXloWUtOSGhlSjdlUnhzVEJ5NXc1QmpOOWRnbmkvdTRXUnAvY0lJMy92RlViTzNpZU1ITDlmRURYc0FZbmYzMlFQQ3FLR1BTU0ltdmV3TU5ib0kySnZlRndpRm5tMFZCaTUvWmdnOG1LWklPckhDckY0NzVYQ0dNdFZndGpqWGhaR3JYcEYvQVNDN0ZYQkJvK3ZDZC8zdUZvc2N2VjFxYW9QYXdSUkE5NFF4cHk4S1l5NWVrc3N4bTJ0MkMwZTE0bkZHbjFIR09QNnJsaTh6NGZDdU4rUEJKRWpId3Rpemo4UlB5RWgrMVFRei91WklON2pjN0dva1YrSVJaMWNMOWJMNHdaaDdPMWZpZDNtOFd0aHJQZU5Zckh1dnhORWJmaGVMUGFIZjRwRnptd1N4bHI0UVJqMythTXc5bzZmQkRGK1B3dGl6REt4eUs4a0Z2VTFGNHRhV0FoaURFdEJ6TmV2d3NpWjN5UitQNWo5TG94OCtVTVkrL3lmZ3FpamZ3bWo5bThXUDBQQ1A3NktueWFSS0g2dTlFT1MrQWtUcVVMOHJJbFVLWDdxUktvbWZ2NUVxaTUrRWtXcUlYNG1SZHBLOEMrUFd3dDk3MDQxeGJ3V3AxcEN6K20wcmREdkw5VVcvdTJ4anZqSkZtbDdnZWQ5cWlmbXRTN3RLdlQ2bHVvTEgvZTRtOUQzMU5SQTZMVXNOUlQ2ZnA4YWlaK1VrUm9MM3ZQWVJDenVxNm40T1JwcEwvRVROZExlZ3JjOTdpUG1OU2p0Sy9RNVNQc0p2YzZtWmtMdkM5UCtZcU04SGlEbU5TYzFGOFlZdHhENjNLZVdRcS8vNlNEaDB4NWJpY1ZudGhaNDNVNXRoRjZUMHhZV2M5ZGUvTVNQMUVIODdJL1VVUkRqMWtuZ3RTa2RLdEZacDg1aTN0T21MZ0xmaDFKWFFjeFhOMkhrVkhleHlKTWVRbDlqcWFkWWpFa3Y0UXNlK3doOS8waDloYjZ2cE1NRk1iWkhDTDB1cEg3Q3lMMytZdDYvcGdHQytKbUJBdDl2MGlDQjE2SjBsTUJyV2hvc2NZSktRNFMrSnROUWdhL0pORXhzRjQ5SGkvbTZUc1BGZkk5THg0aDVEVTBqaFRGWHh3cjM4RGhLN0RDUG84VmlMTWVJeFZnZUx4WmplWUpZak4rSllqRitZOFY4WDAvanhIeS9UeE9GTVVlVGhIZDZuQ3owZlRHZEwvUjlNVTBWeHZxWUp2UTlMMDBYaTN1ZklmUjlKYzBVeFBOZUtZalBtU1B3YzBUYUFsNm4wbHd4MzhQU1BHSDg3TTFpTWVlM0NLUGVMQkR6ZlQxdHdaamJoNFJ4THc4TFkzMC9Jb2puV3lLSXoxb3E5SDBsTFJONFRVK1BDN3ltcDJmRVlxMDlLL0RlSXowbjVyMWRlbDdNOTZDMFF1QzFQcTBVeGpwZUpZdzErckl3NnNRcndsalRyd3FqVHJ3bWpOcXpXaGkxNTNXaG4zblNHbUhrODFxaDc1VnBuU0ErLzJOaDFLdFBoVkZYUHhkRzdud2g5UE5qV2k4V2EzMkRXTlM1TDhYaUhyNFNlRStjdmhiR090NG9GblA0alNCeThGdGhqT2NtWWR6N0QySXhOajhLSWo5L0VVU08veW9Xei9XYklPN2xkMEhVaGorRXNlNytGRWE5L1VzUXViOVo0RG5reTdZS1BJZHlDbnpmenl2RlBIZnphbUtldTNsMWdhK3J2SWJBZStpOHBzRG5JNjhsNW5PYTF4VjQ3dWIxQkw0djVMdEtiS3A1ZlRHdisvbHVZdDQ3NWcyRW5nZjU3bUplUi9LR1FuK1d2TEdZNTJqZVJPaTFPdDlUK0lUSHBtTFhldHhMek90a3ZyZFkvUHcrUWw4YitiNWl2Z2J5L1lTK052Sm13a2M5N2kvMDlaTWZJSXhuYnk3MFhpdHZMZVoxTEc4ajVyVWlieXZtUFhIZVRuQ2N4dzVpVjN2c0tPWm52N3lMSVA2OXE4RHJZTjVONEhVejd5N3crcFAzRUhodHpYc0tmZjNrdllSK3ZzcDdDNzFQemZzSXZUN25mY1c4cHVmOUJiN2U4Z0VDMzB2eVFVTHZBZktqaEdkNUhDejBPcEFQRWZxNUxoOHFqSHNiSm96dkh5MzArcDRQRjhaN0hDT01aeHdoakRoU0dPOTNySmpYbjN5VW1QZFArZWxpa1c4VEJGNnY4M01FZnRiT3p4VjQ3YzdQRS9qNUs1OG85RDBpbnlUMHMwbytXZWoxTkw5QTZQVTBueUx3dmp5L1J1ajlkajVMTE81enRsamt5Qnl4eUpFYmhMNkg1Zk9FLy9CNHExaXN4NFVDUDVQbml3UXhiNHVGWG5meU93VHhmSGNLWXY3dkVzUmF2RnZnZld4K24xams1djNDK05rbmhaR0hUd205cjgyZmxmaDc5dng1UVh6OVJURS9zK1FyaFRHdXE0UXhscXZGWXZ4ZUY0c3hXeVBtZTJyK2hsaU02NXRpTWZadmlYbHR6OWNLSWwvV0NiMVB6dDhSaS9yd3JsamsrWHRpOGZudmkzbVBsMzhtakdmOVhNejdzL3hMc2VVZXZ4S0w1LzVhTE9aNm8xalVoMi9FWXUxL0t4WTE0VHV4cUJYZmk4V2MvRk1zeG5tVFdNenpEMktSQ3orS1JZNzhKQlo1OUxOWTVIQW1Gbm1ieEdLTjVHS3h0Z3F4V0srbFdLenBmNHRGSGZwRnpIdXQvRDlpVWY5K0ZZc2EvSnRZMVB2ZnhXTGUveER6M2lQL1V5ejJpcitFOGYzTndxeXFGYXhDZjg2Q1FuL093b1NlRzBXRjBPZWpxQlQ2UEJYVmhINitMYW9MUFErS0drTHZPWXF0aEo2WHhkWkMzNytLbWtKZlIwVXRvYStsWWh1aHI2VmlXNkhYaXFLMjBNZTIyRTU0cWNjNlFzL1ZZbnVoNTJxeGc5RFhackdqOEVpUE93bTloeTUyRm5xdExIWVIrdjVVMUJYNldhV29KL1I5cGRoVjZMV2lxQy8wL2Fsb0lQUTlyTmhkR1BmWVVCajMza2dZOTl0WUdHUFFST0Q3WUxHbndQTy9hQ3J3ZFY3c0pmRHpVYkczSU9aaUg0R3Z0MkpmZ2ErMVlqOUJqSGt6Z1o5SGl2MEZYaGVLQXdTK3Bvcm1BdC9YaWhZQ3I1VkZTNEh2eThWQkFzLzVvcFhBKyttaXRTRG1vbzNBejBGRlc0R2ZjNHAyQXMvem9yM0ExM1hSUWVCbmg2S2pJRjdYU1JDdk8xZ1FyenRFRUs4N1ZCQ3Y2eXlJMTNVUnhPdTZDdUoxM1FSZXI0cnVnbmkrSG9KNHZwNkNlTDVlQWw5clJXOUJ6SE1mUWN4elgwSE04K0dDbUtzakJERlgvUVF4Vi8wRk1WY0RKUDUvcVdLZ0lQSmlrQ0R5NGloQjVNVmdRZVRGRUVIazRGQ0I5ekRGTUVIazJ0R0N5SVhoZ3NqeFl3U1I0eU1Fa2VNakJaSGpvNFN4aHNZSVl3MGRMeGE1ZllJdzF2cUpZckYyeDRyRm1oNG5Gbmwra2xqVWdQRmljWitUQkhHUGt3WHgrWmNJZko4cUxoZjRubFJNRmZnK1ZNd1ErQjVUekJUNEhsTmNKZkI5b3JoYTRQdEVNVnZnOWJxNFRlQjFzRmdnMFZvWGk0V1JBL2NJSXhjZUYzclBYeXdYeG51L0pJdzFzbExvZlh1eFNqamY0NnRDMzh1TE5jSlkxMnVGOFg3cmhDczh2aTJNOTM1WEdPLzNoZERQT2NWNm9lOXp4UWFoN3pmRk4ySlJjMzRTaXp6TXhHTHRKTEZZSTdsWXJKMVNMSEw1ZDdHWTJ6L0VZajcvRkl0NS9rdk16MWJGMzJKZUIrTFhmTUd1OTBneFAxT1UxY1c4MXlscmkzblBVVzRuNXVmTXNvNlluelBMSmdMZmE4cW1RdDhQeWxZQ1h3TmxhNEd2amJLTndOZEQyVmJnNjZGc0ovQytzMnd2T01OakI0SDNvR1ZIZ2ZjSlpTZUI5MjNsd1FMUGlmSVFnZmNNNWFHQ2VKYk9BdThmeXNNRTkzcnNJdkFjS3JzS1BBZktiZ0x2ODhydUF1OWp5eDRDUDNlVVBRWGUyNVM5Qk43ZmxyMEYzdHVVZlFUZTg1UjlCVDczNWVFQzcyUEtJd1ErZjJVL29kZXVjb0F3N3YxSVlkejdRR0c4YnBBd1hqZFllTExISVVLZjkzS29NTVpobU5EenNod3U5UHdvUjBqOEdyWWNLZWExdHp4V0xONS9sSmpYbDNLMG1KOVp5dVBFZk84cng0ajVHaXVQRjNnOUtVOFFlRzB0VHhURTg0MFZ4UE9ORThUem5TU0k5eDh2OEROUmViTEF6MDNsS1FMdm1jdFRCZDRibDZjSi9LeGRuaTZJdkQxREVIbDdwc0RQQytWWmdoaVRzeVgrQXIrY0lIRzRMODhSZUc5WG5pdXhnTXJ6Qk43L2xSTUYzaU9Xa3dUZUk1YVRoVjdueS9PRnZyK1VGd2dqMzZjSUl4OHZGUHErVWw0a2pEbTVXQmpQZDRrd251OVNZZHpMWlVLdnhlVVc5TE5CT1ZYb2RhcWNKdlNhWEY0aDlMNjhuQzZNKzU4aGpHZWNLWXhudkZMTTk3WHlLakhmbThxcnhYeHZLcThSODU2bXZGYk1lNXB5bGxpc3krdkVJbCt1RjRzNW55MFc4enhITE1iakJqSHZ3Y3E1WXQ2RGxUZUtlYjlVemhQelBxcThTY3pyYzNtejJKdi9EWmJ5WUVBQWVKek12UW1ZSkVkMUlKeVJkMlpWWlIxWldWbDMxOUZWV1QxOWQxMDkwek05TlpjMGt0QWMwbWcwdWx1TTBBR3lHS1FSQ0hPMWtBUXlJSmdGeVFpTTJRWmpJNHo4V3d2aXMyd3dhZ0cyNWQ5ZWV4YnhHYS9OMGF3eHNKK3hWN3ZtODRJTk5mOTdFVmxWV2RWVmMwank3dDlUa3hrWm1Sa1o4U0xpWGZIZUMwN2l1RFByNURteXprMXp5OXd4N21idVhvNGpDNDBkcEZhZUpQVmF1Wmd2eUZZNEdxdm1NYlBhdmROTE9lR29ERStWNitGYUE1NktXVW9EM29PM29yYXN5QmtTalMyeEFwMnlzeENMeW9WeXJXRkg1VWxTS0VObVl5ZUpMVFR0TExISTA1S2lTTkYwdEwwZVRhZWpwQVZKbXNPT09VMXByeXVhcHBDV290MGRtZDA5RzBrYWVqTHljQ1NwRzhmZ2pVbzZmWXNpUFN3cG9ZQmw1QXdyRUNJNVJhcEl5aHdXMTE3QjR4ek5hTEZqcmYweFd0NGFIcjhlUytkblovUHBtR3BIVENPU1RFWU1NMksvRmt1dHBHbk5qSUFseXZBbldnR09Vem40NHpteXlnVzVNVzZXMjhrZDVPN2c3dWJlQmREelFBeGdVaFlHd1ZOa0RRZW94QUE2c25PTzY1Y0t6dE9zeVdRTmppSUFiNlhUMktuYnNUbWpEbjkyZnFCZEJaQnUwUEp6MFhUN0tWcDJEbytuRlVuRnNsUUs1eUhKM1JjR2FZNFRZWXorQ2ZrWmVZYnpjd21BdG9Nak5FdWlCaW5Na05veWFSWU1FczJTaFdWU215R0tCWGtOTjZ0S3VLWGoyN2JkY2k4ZXR1MjVlOCtldTkrRmgrTVR6ZVlsazVkT3dvODg3dDZHUTg2OURZZTMvdFMzOTlxOXM1T1hIcjEwRXV1QTgrUlptQ2ZQY1NhM216dkFYY1BkeW5FbHhTQ3p4Tk5aQVBjeGduMHlTK1NDbzJEZjdDUXpNSTJhNVRwVXRMb1FzeGVxZUliK2lTb3hLeW9MV1dKai94WUxjcEJFYldqTURJRzA3VzBTMlNJS3V0aVNLUFNhSW45NVh0SU1jWHpiKzdlTmk0WW01Zk9sWkRKYnkrYWJBWjh2ME14RE1wa3N2WDlpWDhJL203ZUt2bi8wSi9aTitJcFdmbmE5ZHF4V08zWTdIbzdMSWk5TUNmSkRDTzlmTGd2NmF3dFkxdmpFeERnV1hoaTdhblp4ZnF3Q1pSVXptU0tjS3JtNXhkbXJ5SW8ybFRmdC9HdzBQR21idVdrdEZKME51MFhDZ2ZYVlB3R2NQdFNkRnh3MHRUczZFVXhTbnFFT3hDdzRuTTJCNjFLeDRCM21aYklpOGovaFJYcG8veFo1R3BQdFYrSFJreVpITzQrSTVIMXhUT0poalozd2NJYnJwVC9WUzNiRzEwQ2R3M1UyV1hIKzRlUzF6MUhuNXNDMXQyN3lpQ3IzVmY5a3Q4NFBEcS96NmpucmpIREd1aUtjc2U3bmhMTjdycnI1SkFlVitUR3RXQlFnL1lOUlZZMzFIbnBGWUcwT3dGcTVRRml2dVhXaGxmL29pRnAvc3ZmSUJRTmJPL056bVB0QUpRSHJoN2trVitTbXVEcFF5MXU1SnptdVdaQ2pzWVZHclZ6dEpKeE9vbnRMMlhUTDg0eENaNzh5UXdxeVVxWkR2K3lVRGNBaldZSXpZQ2VoamJXalFXSVFtRWFBYnhyTmhoMERQSU0zR2hSdW5ibHlqaXZyUlVEUWhxWmR3MDZmWnFmZlo2ZUxoNTMrUzhDWHQ0MkFsQjNQU2dIRHp2c2l0cU1HN3RiU29TL1lSU21xNUlsczhSSGZGOEw2M1pLZzZuNUZLb2srSTJwSVFraVFocHh6V0dqbjUxNnNzRk9yTDlNOVBTVmw3THdTanNYQ1N0NytpRitVVWpQbVo0MWdKblo3b1hpZm5YOHFOM2FiM3pDZVZJRktpb0xjbEVUNSs3cGg2R3VDSkFucm1GckgxRm8zN3hDbWNCd3FpTS81Kzhrbm9EZXY1SzduWHMrOWtYc0g5eXN3aTRwMTVHcXdIN3A0eU9vQTBXVjZKSGdHK3FHUFAxb0NTR0NYMW10T3RaZHluMGNhamJTNldhVGRYUFJ3QTNaMVlZd3Yyb05QMUt1a3NpZ0pjNEswaVBYdUpjbmxjZk5JSkRXVmliYS9FczFrb21FZXlEWC9OWHJjQnZmYkZxUFgzM3JLbnkvbi9XT0tyaXRrV2RGelV3SDlDSG44RUx1N1BVVHZodFlJTjFDK20xeS9NeFU1WXM1SFU2bG8renZSbEtvaXlWYlZ6cG4yNXdvajJTdkJjRGlveVZCdFRaTVBhMGVFRFUvK0N0TE9NNzhBV0Q4QTgyZUpleS8zdDl3UHVQOEp0TFBzekpBZ2Njb0tESHRnWlJwQXVoczRFUXdTNU5udzMwbnNoU1lNZERsTG1uS3N1dEJjSmp2NVpYaXMyY0MzWkp3SU5BbnZBdzhFVDJFQmNOR0kyZk5aN0N4S1Y1VjVnNVRoM2FxOUFKTUpKdzZRV3Z4WkJsSGtHZUlVbkFKY2xYRm13UVB3cXdNWmJtUUpmaU9HbjhnUzJVM0hiT2dqcUxpQzlZRUx1VURKTlNEUmhVWnpmcG5Fb1ByT25DSVhhWC9hemJsbW8wcVpOSWQvcXhWVngwTE5nMnJBQ3N1cTRsZlZNWXVrWTJFalB5bmw1d3hObWNEYlYyWVRxdUdqOXpKVzk5N2ZtUUZCZzBtbzY3SnVXN0trUkNvUkxhZ0ZpeUdaVnhJbFhmU1pvaFQxaCtPSmtEOHFpYVpQMU1kalIzbCtXWkQ1Q1o0WEdqd3BFN0dVVmNQaWIwdFhETTFYM1UvSVBsNVZobjhqb3ZkOVFpdjVpQ2dKc3FTSi82R1QrSWVKTFVHZm1sWUlMK3FhSWttaGNVdXd4bnpweXllWDBtbzJlQ1c5R1RMVWdSdmZDWm1TSmxnaUNVYUlFQkFDdkNocFVzUXZLYndrQkdLV0ZpU2FMNUFvMmdHZlJvSzZhYXRrREdwL3BhRHdZNFRmUi9qeTNvU2lSdTRhbnExQTRib0loYXRCdlZlNjZldVZibm5MdnBTb2tpcXJPWGFpTk90TSs4dzZ2NXQ4aGR2UEhlYU9jRmZqNk1VaEE1TWVobEM0SndvdEE3UG5sSEg2MjFZWGU0UWhEeDZCNGVXK0U3TXBaOWVFVElld2FROVVyMm5ubXpiNXFhQUxleVZablErczdLb2hiMWFMcGZoaUlsVkpXZXh5MTBwZ1hwV2x2ZTV6TmEyUXUrbk9tMXBhRFRMYlh6T1RKdnkrYXBya2wwM3pHUUVlQ2RZdUZza1laUjBMOHZoY2taQnlLbGFVQ2pTbi9UM3g0bG9RQ3NNSFowdmpsUzJYVEFjbDRnOWdLZVkvbS9DSFlzNlpNNEFYQ2JtTXM3Z3RRUEVjNUdvYkMyTXdTUmFRM1EwaXMyczNHelhXUkllMk13cDNGdTQ3S1FvcThLNjMzQ0xxa0JCT2lyb1lPU24wOGdCcjN5dm92LzlHdUZaRThkWmJCY2pSaFRjS3d1cW1MQlMzNEE5bzRDNHVpdlZnZGNEUDI2d084UG1hWXNkd2xrTlZ1dldSby9aSE5wWDJ0czJmL05QK2lva25CVDF3VWhTVmdmcDc2OEhnb2JCUDd5UmR3TVNpU3JNTEJvWEJBbXYxNmZOcDZETkRQaHJaWERkdnYxQjROTHRnNkZhb3NlQjB2OTRGVExtZy9Ncm1QZ2dNNmFvL09SK3dRUlhjZXZnQUhpTkd4N0NCOE9haFpTRnN1Yy9TUGg3ZXc0bE5ydzNwT0U4NTFxZ2VHdEladzBEdmJSL1V5UndHNVNId0pNcVFFY3o0M3cyZUFOK1I0aWFCSGw3RzlBV0lLV3l2MXNCWkpvaFRCblVIelg0V2Y1TXVnUW45MGFBQWNqa2toR0EwUFE2aVA5VndrQlZGeTNuMUFFOTJaWDZ5bG83bVFrbFIwODV3Vktibk5FMU1obEN5UDBHZjV2RFl3Z09WOFovcVNmTnVtNTRuUDNYbDgzbHVFZHJrbFYvdHJxUU9jcS9TeDE5MVowWlpjYXIxcWdVQ2UwOUtmMnpiOFh0djJVWVB4MXFHRHJ4Ynk0aG9xM3BTWDlVaTcxOWRhYTJRWjNvUyswKzN1Yzl1TzU2NkhkbTgyMDE4RUo4MzExWlhWNGZXc3dUVjYxWlY2VllTS3V4NE5GeTFIa1pyT0UycmFoVXQ4dFB6Ly9MNmhUUnBPRHliWFdCQ2JadGU1WWVIMENEWDJabmlzcTNVZ1ltc3EvOSsxUnhXVDZsYlNhaXcwd1VtVkxWWjlYTFJYZFFjYTlwRnExZ3ZYbGkvTDE1SXR5TytQdk5kOG1XeUJyaGdHblZITUZXQUszTVJDc3dkRkVDYnhVMURrdlk4OFduK2V5VlJlRktPeUU4S29uU3ZYenQ2TkRaMlZkajJQeG1jQ2o3cHQ4TlhqWkZWdi9aWlhYeFNscDhVOWM5cS90eFk3TDN4blA5M2dzSGY4ZWZpNzQyTmNRTE9lN0pLUGdseWI0bmJBWkR5VEdPcTlhdTZvT254Q2NoRzRFTkZBSitMdFZBRVJER2ZuR3cvamhPUTRPemRPQ0RyTjBxaStBSFJnUCtpZEtPbVJOUEw0Ump4ZjhDb0dCL3drMWg0R2VaM2I4NnVhTW9wWGZ5QUpIMUExRThCVWtoSFQwQnRUeG5HS2FqdGlXZ2FZRWFSRmNpOHE1MzZJZ3BDTEFNNGltcHptcFk3NU53Ung0Q24xQ2c0bDRtTCtXY0lWcjljSC96Mkk1TDBpUGZiN3plTTk3TnYrMm1USk5xODgyc1lKMUQ4dkU3dTc5U1Z1SFhzMUZtcHU1M3B6bUlHNkNZK1pFV3BDZyt4ZUpiUVlXR1I5Zk92N1V2b0J3cmJNOThoOThONGRPdHJlclFmT0Nic3psaDBoeUtydk1QR2JaYTRBM2Vac0pFN0NtS25oRkZWQU9SL0lXTUIrSXd6LzQwOFJ6N081aytKd1UxMndjWW1rMlhYTjZGS0NtV3lkbzZwOGRoNXpDODJoejExYUxKeDFuQ0hXWm1OTXNmYWhBWXBHSFBucU1JL25GY1ZHTzJHY2JaR2RWZE5idmw4ZFAxbnAzYW4ybXVVM3E2NE92b3VvVzZOSUhoQXFIdXZ1TVNaRXZSVG8ybmVRSjFMNGY1Vm5aS252cmlVY3k3S3QzNUJWUWpSdHJFM3hNNlQyTTRSTFJ3TzV3VHB3UmpyTHJsMTdjRDZIRlRRaFRDdEJUblZxY0dJR3BNVEY5Z3AzUEE2MjU3NklxeE5ENHl4M3VlZ2lITVhDTGpjQlRXU1l6aWUwaVJHRnhFUG5aVXlvbEtHZ25hRzBKRmgxbnM2V095Ykh3NWdQMTArY0dBejhubkl4VlFVWlpMVmMyQ2Y5cXM2ZUVycDBLVG5nQ2E1OVQwN0prTDFFaDI2eUVvRGhLVXE2dytjanRnZlpNMzdjVmsvMjhjL3NnbXRqbWhiRHhmMzZudC9wNzVueDFxbzhLTER3Q0FVVytBNkNOTXNzbnJuemdFcjhuUzN1ajlVdEF2dGl1NTR1TDgzSHFxTSt5aTd6QWNEZGxGeE9aVmw0ZzVaVkZSREd3U3J0NWFBNCtJbHdPejhXOGk1Zk4wRzhIV2ZZRFRoN0xYMVREQmEyeStjQjg0L0YxUG53cXpIQTU5ZDhxRWFnUzQ5OEtoSnNOK2RFUnp3OVNnN1hxbEl1cVJjQWRLb0xJcjNnRng1anlDTWtIMGE4TVJWWDBZd2Zma3FrUXFlOTlCWGhDRjFIUzM5ZEFSYk5sS3JqRDJaN0lqaHpnanA1MklRZzBINEZnZXJJQTRYTFc1d1c3S3BoY1BnT2xvQzZpZ1pXSjI3QXJFcjZ0dkRKYUQ5OE4xN21McWdXMVg0dEM0TXIrcjE4S3g0TjMxQ3ZJSlc5VXFVN2dWaDZCZ1lMUVgxWUlyMTdTNk11cXFFNW9neE1CSlF3K1VndDIxOTNVRGJ4bEg5Q3NoQ1NLZXkwUDkwREhaUjRxWVIrU1hVYVh5T2Z2QnpUQ0h5QXB4ZUVNWG5vZVdmSi9mUmFmdnc1Mm5GeEJjRTRSdDBtTG56Y2hYbVpaYWJBYXJTOUxhNXk1cDMyenhBUnNZZmhZOCt5dlFwOTlCdnMzNFN5QTE5cEVOOVRCQWVFelZVc1p4c1AwK3pGMUY5QTFudDd3L2lDWmR1WktqOFozdkhTMWNNYzhjTEdhUVNsWkhmYWYrbyt4bHl3Nk1BZ2crSkE3VldCU0RCZlRTQjZleVFKbERZTkIzdlBPdUtBZDE1TmtBQ0huOVU3TmFGTE5KU24zZmJUTkxkeXB3bkJGMjVHUEU5aFV2Sm85QWFJMTF4eiswOU1vRGR6N1BGOTQyc01ZbDdPNGwwK2FjTWNFNVVkOXY5bUVlVGkyUHpSNXNISDQ3SkZ3UTl2V204NG9qOGhqQll2a21Wb3QweDUxSFE0bmYrR3N0dlAwekJkRjlmK2VSakl6OGdkTXZIZmwwZWhHYTlvNkpyZHRUREEwWlRTajlQWGljak1jNHRYdlk3NTJWUG54NkZmdi9RdzlCR2U0eGhqd2YwMUx0L1JHN0MvSGErWDFwdytubmM2amN1c0E3N1JxRzIxM2paMlp5WC8vWFVPZVB5cmZiWktJQ1Q3eGNXN0g2UnJmaVBRMGdCMXVmM1BReDR0Q2Zsa08wamV1Ym1rUjB6RE03bm9BUkt1RjlhYVBiTFA5WnJMaHh1LzNrVVdmalM4SVoyOGZoNTRRZDdBSTJQeEE4NUx3NTZaaVI2T04zRERueFhGM1UrT0ZNWlFPQi8vYWdvUGpvY1ovNzV1VkZtc1I5OWQrdHlQNFBKMlRGSmMwQVA5YzFOTkVRWEdIWDUrNTVDaHR5d3FSS1AwY3BGUGFvbXQyL3VkOGZUd0dqYVJHT2RBZVI5ZnMxOWZqU0YvZk9SdUx0SjE1bTZOTXV6Nm9UNFd4eUJRSjhaaVhOeDdpRE41QW5KZzJROUNiSTFSNno4Z0tJcDN5ZjFTejJSMENyWkhWbXIxaUNyWnpnUWcxdWExZ0l4bUhqUzdlOUxmSXVRRmkrUm5ld3NFVzUyRmtSc3VBc1BSUXp2eGZzRkhwNFc0VEZlRURxSlZZRm5kVDN6TElkMmdtNWRtOFh3Z1BBUjd0TUVDVDJCcFdncUhibDdJYloyd1Y5dmVSdlUxOUIwcDNIdDU5ekdjUkxXRTJENkhMZUhPOGhkeDkzRzNRTXp2Rml2RHNxaDlVRkJyemdvV1Z0OXFvR21COTZPcDIySzA1SFJvN0x0c0RiaWFDVzdGKzQwVS9wdUhYNHA4ODZGWUlUb2U3UzB0a2Nua2VEb1d3ZjJFTElIR3ZKZEFNWnVnTUZ1Z01IMzNMeVA0c1dEN01iZTh5Nng3OVp6blRLaG1NTVN6d3IrdGlmejEvQkRrTTl4N3BvbHo4SDRuSVFMaWhBR1dCWUcwRUgwb0pCVG9saHIzMWRqYytxSUNEODYyMnJrNGY0OFlzRzBxVllaa1RvQ00rWUlXNmNjeUhMbjRqcUg5dHhRbHlabDd3ZW1JS3ZCSm1iL0MrZjFoYmtobFZPR05JTFdnNDJ2NDRPVW8xb3ZXbjBFdTRPNkxMaWpER2JpZFJIdU9JT1plQTBsVlR2ODZSV1hRaFV2WmFoamdqdzl3ZXAvaVFnLzJvS0pwOGtFNDZETzk4SEF5M2w1NklNY3AySC84RHpBWlpyYnhWMEIwTG1UdTVkN08vZHU3cjNBOTZMVkVHS0xKclZzcWpNWjBrTHprRHFUSXEyb1FrMlJjTm5DWkZiaDFOSU1qZnN3MVZ3bURwcWdHTlRJQkUyaUJqT1VUVWFKbXhOTlI3SC9CbG1BN0ZSQU1TT3lyN2gwMGZhQ0h0QW1MNzM2MHFtQWFvWmxYM3IrNk5iRFd5SFBhWlRoK0RwWjVuMVRZM0pBNGVWa1dlZDlleUhEMkZxUkFpb3ZGNnNCM3RmdU15eThyZS9xMFZhc2hmWi9VOXZqaG0zNVRidTRWSVFmVm1FS3JiU254dUpCTytxUHhETHpHUktxYk50V3dWc3B4MG5CdWM3NzVmRWRsc2o3QW1La25nWGc4RDVsNW1DS1ppUXVtcERsZzMwV2h2MzJocGZCcDkxNTh5ejVPNWczZFpTTG00anpFTTE1MURWb01oWWJJMHJIT0sycnZiVmphRFJXSm4vN3hTOUtQQzhLbXZSRlNodS9LR21DeVBQUzhPd2pkOTRKV1RMY3V2T3ZrZTc5OVozd3FBejNSdVF6dWZwNThqUHkrOXlsM0RWZFRWT1Y5anJXRm1wV2RKVTRNVHVHUTRWcHd4Z3JCTU9HMnFvcDFGb054aGM3MVdzd1BnUWNZRTFxb0I2RkIxdzF4SjdLWlRtUkNKS2dpZW5kQlRTa1AvN0c0K2xzSWJkZ2FFS2VxRkpBVkFoUE5DZFoyQkdKemsybUVsWWdZUjJjY0FxNXUxK2JHak9NNlhnNm03QnNWMU9Wc0FXZktBdThFSTFoUWRzV3BtZTMxVEtwVU9SVGtpWkpvaytQMnBWaTZmcGFNR0JHWTg1NGEwK2p0dFQrekhpdW1FbGx4NWUyUnRBVWlaUDcvQzdxWElzN3dCMDk5enFNQklnRldTS0FCdlFaMHc2aWtiNENuVnAxeXJPa3lUZzBsM0ZxTHREbDM3UDRVTFQvZG05QTBIUlo0WmNFTmFvS1M3d2krMVJobGljQ0gxNElBMlcrUzVFYTAvWDZkRU5TV3RsQ01aTVo3VEx4N0lTcXkwK282aE95cm41WWx2eEt0YXI0Zlpha1ZLK3RLbEtrMENvODJGbGpPQU50djU4TGNDRm9mUUZHcWcwMEdGckpLREtnOWY0TUczS0lmMTFMUkNJSmJkMmZXMjlQZFM5ODF2cW4vNlBHUndLa0ZZanc2aWYwYlBBVDdmVjM5MmRwY2NqcnlJbnI4TzExcnNMZEFmaUtLOVhRWnBOMzdaWU4zamFvQ1V1V2IyWmhValJqeTd5elRKU29EU01SeDZHRFdLdUlJSWQwR1ExeEhCaHk3Tnhzb0xFUVdrcXlzeDFEZ3g4NmdwMCtldUNpZXA1TDJVcWdYRTBZTTdVWkkxRXRCeFE3UmJOcWlRQmtCWklzNnpxaTgzek1qRWN5UlBGRnh1Wk1rb25FelVLU0NERi9iRkdnZHd0MW9YTlRzRUlacTNOMy9HbWdZa2NGUVFOa3Z1ODNBSWRyd25xeS8yTkR2bzlaV3dpUEJVVUQ3Q3VCNktoUERGYmdQVThMNGxINkpYSGZKMFZSbzd3dlQrbG9CKzZjVkNnNzhnemZwRDR1NVdYZXBuTzlrZVdWTEhvS3hRemVNWWdEVU1lcHZaUFFFeDNlT00vcEdRMXUwVWF2V0dCblJVWmJjcVFvN0l5dkVnNmFHcTk1MnBVTURHdnFqY1NjRzR2b0tvVnJqT2QxSWl4Q3l3U1NLbHFaa0NWMGJndjFRdjlkNkpPV3ArQk9oM25BMnV0RG5yNFVpSjZ0eEdSaDhHNFVZS2NDajdzQm5PK25RRUpxY3Bkemg3aXJ1TmR5djhUZERmaGkyZVBCTmtQUUpOdGRQb1JCSEM3Mk8wWk1FcUZqcFNuTkFVRmduQlJ5eDRoQ29TVEhMdHBWZzVTZCtmNjdWR1BkdVVubXJOUkpST2h2ODA5Tyt0K0dxWk1wNjFOZGtVNzYxQnl6M2lRdExUT3JqV3N6R1gzUGRLWTJkdUxRbXU4OXdVYmpEN3JaWTdWdHZXeFNrSW94U2xpc1lOQ2lpVmhSYW4vSEkxR3VNSHZPenhNbFBIMVpNSGpKYkZnaEU4M0VWR3AxTlFjdjFiMzVxYWxFWXVyWGFINW4zbmQ4cnl5VTcvcldONFFaMG1oQ1c4c2xBR2lXbDczNjYyODVZL1k0bWQveXVqdUkxZjVMT0IwY3M3MXJGdTNYVis1NDNaYjJYNDdiWTFVeUQ4ZURkN3l1NDFlM1NsWUF2eWZnZXc0M3gyM2xkbnZ0NUxyK0tsMUZEOG1IODlRRkxvenJmeElpYjljbW15V1VUVG44WER1SGx1eGtBNDd0ZzJnVkh6MUVjbWVBRDFpRDFDSEV6NnJmSC9MN2IyZW5ZMzFYWkdVMnY0YnZ3Nkc5a1k0Q2VjQlhUMGZUaEV0SGEvaEk1N2ZpdldCK0IrdlF2bldQMytCTjNPdlI3NkJmMWR0UlgzU3VTK2VrY1AzUDU4OVJIb21IME5vZkQzdTZLWEx2THlpQjRuT00zdjFpQThrVEQwU3F2VGlIRCtHQnZLMmJmS0NYdVNJSjdkTjRSV2hlTDczUzhiMUVJdHFlNjNsY3pvMTZ3NXZtcVAvTkdlcXI4UndYNVNhNFplNUs0SnJ2NFI3Z1BzVDlCc2VaZmQ1aTdwd1dlbVlYSGoreXpmNGMrR1NmcHdmTEhGeDVIVndURU00QjIrcWcydjZVQytENzhId2ZnN1dBbWVUYnA3eFpuVWN3czUzcEFmZnlicktYK21xMzEzYjArbTlkRWg3SGkxVjYzYzZ0NHNYajdtMnlRVStkdlBZVG5lZm81VSs5WUcrdmU3dUN0TTZycTN6ZGZ0STRrODdkZVc2SjJ3Y2ovQnJhWTV6WjZaUnE4enhUUXFkVGlrbzNKWFZUOXBDODVnQ1dXSk9FUXpBSVZ5blFXaXUwdmJtVjdoV2UxdGlweGU2MU45Z2JiaTdKc2ZOOXY2QTl4WjlBTUQ5RFlmYjRpR1A3aWJQZVB0SHJiQTc0dUE0L0t3QnU4QUZXTURtYlN3RnVLQUw4SmdGRFZJRjJMYUdmM0h5NCtyTCtSVFF0QXZRakZVbHArSmVNcENMNHAwVlNtQkVocSszVmwvTy9aKzl3ajR2Yk9ESmc0NmljNDVyOHdWbWRKRm1hSE9nNTU2ME5UVEtmalRNZ0s3MUk2VllEY01aRk1QcjZLRmVqNlZESEkyQTRZM2F6RE13cXNKeXlZdU5salBva0tYZ3RnekRjY0pyQWk5b0t5a2kyL05NZWlYc2hFVXI1NHhWVkNRV1NjWDhxbEhCdXF6YTJKREd6cEd0R0lHTUhrcUhFVkxQNm1tREdzaksrNXpNK1g4YnFJNEszSi9PQlJHSnU2L3o4bHJGRUlwQlBqaWQ5Z1RMTm5Hck16MDhYYWFiajk2WGZvaTB2NjZWeU1hNk5BL09tTDNPdUR1OUI4alVZSzdQUXdvUGNNWUE1ZGF1aWdrMFJtdWRLcTgxNTRLc2RaSzUzQXFVbU5OWEU1aW5NdFFuK09RMTJtM2xJZVpRQ3JtY2FmNDhkYnNiKzMzMkxPL1paUkJBMVRlTEZYV0pBQWdsUmpldzdlbURmbjhYVVgzdzFJdVdpeFZ4K3Noekw4V3A1KzFYcHlsZ1NPRThyNmFTTzN1ekxhTFltL1JJUXp0MUFPNWtuR25rd1o2dWhEODIzTGw0SVNRSUl1Z0hwa01URFAxVVBMSlR5Q3g4S05kcS9Zb3QyS0ZPWWlpWU1tMXljbXR4cHBrT0dYZDlpeGJQUjVZczAwWi8zcC84N2xybDdkcFg1bmdITitOOGd6LzhNY0pFZlpsUWNzTkU0MEk0Wk9oWTQ0UGdNUHNzdjgyVmdZQnlBQTRJQ215OHI4SE5BZ2luQk5ZQUNNN0xFUnRqQWZSdUVIWWQ4ZW5aMTlhWjgvaVo2L01INHZzd2pXMnVYN1ZqWTVkODF0MVBkVWp1d3RQaElQTlgrNDRYZHlwUmQzYU5QWFQyK0ovMUlvKzc3M3NHbHhpUHhKRTllUDlkNUc0N3RKMGdxL3NqaTB2aU9TWFhueFZ0OHUrWWY5ZGUyUHBMWlY1alM5MVR0S1dYM3dyMThNdjVJWStuZzkzejF4aVBwUGVNVXo2NERudjFQM0JTM2g3dVl1eFJrWU9hWGRCMTNJL1ZMajBMdlU4ZFJHQUhBNXl0V2RJeUhjVkZuZWlVUW8xQzhnbjlXekFJUkMvNFYreWZpSkpIc3BtTTNpeUJ6T2MyaURVa0YvanNLQ0pSS3M1NjMwSHFSWHcwYWR3bzM2SmtqbDMvMXdKVlovVWIrVGlOTUJIOTBiTXZpUmIremIzRWlhL2tFOHJuTGR1KytMSktnUk9LRUtFcEN2UDAvWnFlMnRMWmMyWnFhbmQvcGpQOWNHQ2RaOGVPVGs1UDNpTmxtZXlPM2NXY3dMazJQTzZMKzFzUFRXN1pNSDM2ckxqcmowM0xjZUZDM3hyTVQ4V3cyUHBFZHQzUmVXSHB4UC94dDlCQnFhMnBxaXptQngxZ08vaDVJMTVPVGt4V2pudjdxdGRkdTIrYnlzOThGZkxzR1hNUzEzQzBBcXp6YXVJRVFKY092WHowN1E1akdwTjhUMU81eUQwaGptdDByMThxTThnK0FUSlJ5UStwWTlPYkpUOXF2c3NOK1N6VDRJSzY2cU1LMTdHU01oN1ZDTkx1RmhiZ0lCeW0vSGdvUkxoU2l5V0FZNzdTZjB1TGF0TUtUc1hMeURKY3NrOVgxeDhPMjRZdk1oR2twVUJvOUJTUWxITjJTZlp4RlhMQkt4aFFXbTVEZ0IrY3BvMlN4TUF3ZlZubGxXb3YvVTdKY1RyWTZQaW00bGxRRVduT1l1NzNqczA4UFRXWkFWV2NzVmRscFZsMHJRWWt1YWplN3NJRlV1VVIxVU9XZDdJQVd5cWpsUjZObHA5aGtpcWdnZlZpUm1XVXp2MnJvYWpyNkh5T1BLRm91cHluWG1YSHhuZEcwcWh1L1dOT1VtOFRqeURuK3F2cHhSU09mZmtpTytxeUVWRmcwRTN5WWo0ZHV0eEt5MlFqRjVLa1ZrRDJrMjBXSmhHWHg1aWtpKzRTSGVJbW9wM1FqUkJkQjUxYUI3elQ0VURvYU1yNnlRUzNMTnZER1IzN3M4K1dqNzAyWlQ0WmkrZWhsMFV6NEhvQ1ArS1NvZkI3T1A1WjB0dDRIc0ZrQkxOTDFIYkNLWGxmN2ZqOTZyKzBzUDhjYTFhYnVNenpYcHM0MVBFZmJoKzBHVVkvVlRWTzZ0Y0k2NnF6bUhOVVhlNzYvQTZUWUcwQ0NmUnYzQ1BmckYxb2JhWUFuYnY0N1g1K3o5ZTN0SWsrOTh1SFFldG5KYzhEeWIwN2ljeS8zNE9vZkIvdmovM0JQdkxLUWZZVUFSL0hJQUd4ZVliaTgxSGEvaEJaMmRCOU1uakc1clVCbnVaS2Q3NmdjN0k2T3FOVERsRFoxTEM4V0hPWklqdXJNdklzcnFSOUFNVzh5WEVvTzJPMC93eW9jdEcrbExUbEVrZUJyNnp3UlpVR1V4ZmFuT3FsZDVCQnRIVzMybnp4elAxUy8xY0ZlMkpqbldSTXVFVFVCZUNieWZYYStEbHNYZ1FhZjRhRGwyQloxSkI3NS94a1crVCtCTmY0ZFVRV0NtU290K0JiSWRCR1E1TWFCNjZ5RDlHSFJzVkFFNXFub21vUFlIYTFpazdIYUJWbEN3d2Jtc2tUWEg2bzVIdWgvcnMweDU2M2M0cUZGK09YS3RUTDh5RVo3dzlDZnFNQjFjbTJEblB5SklwMWNXU0dvWTN4ekJaOWJyQ1R4dWZLMjFzTzZnUmNyZFAzRXRkVklBRDljQmJueU12Um5KOFZOb2I2YXd6MVFiZVF0NjZobmMrakNKSXNzb25qU3RpZE5WZ0c2SFovU2FIcEh5Q3hmcXlsbnVJNVQ2WXF1enVRQzVrYmZrdHdxTzVHVlVNOHNLWmJWc3VZbmsyVjMyWVN1dy93dkxTVGEvMklHUWh0dVR3NDlNRm53V1g0WHpPTWtsNGYyWG9OUlc4cVVFM2JvZ3FyaGFuNFhHdldxQXdKUHZScVZKYWVCWVNub01nV3cvZDBZWElacnh5MUhiWmRYWk91eWRLRURPSjRUUGxWTis4TjhUbFg4U2pabG5ZQWVXQncvRWpCYkpnbnVVUVYvQ1BMVjRvNnliQ1pOT2QrTVBDRG93QldMZkpHZTJ4dkZwVUlva0pWSit4dmhyYm1va3M1V2RxYlZoVUxhOUdlZE5ISnN1WllaQ0pqU2twRVBCUDFtdXJEZzdKMldRVm95ellDdXlzWFVQUUsxNm1wbjZaazhYbGdxWGpwWnlNb3FVVk01enJWUllUSGZ0bkR6Rks4TmF5ZS9DVFF3UmwzZ05QTU1mdDFWYVd5OVREN1gxN2J5anFJSEJpZXMxQVlDNFRmYWF3Q2hyRDljV0xxSXRsUlZyeGpTak9tOWpyZk5hZWM0TnJvVlZiS0Z5VXNCUkc2akZOVHpveHg4Qm5EYi9ZQ2w5d05tTzhMZGlYcHE2S2NlWXJFN0drSEtmSmFMdmJYVEt2ckdHOVQvWW1HWm55RVNXNFMzRlJiZW9WbEVDYkJZUThiWHhwWDBCa1pYUTk1MkZsRjhERmZpZVM2VE9DSnBlNUhMWHBwNFdKR080T0JiektVeXJLWlQrM3cxVlhwTklKWW9iTnUzVk9TTFMrMGJZSVpXb3BFOXNxYS96amUvNi9COE1MeS9FcmVzajd5bDFDQWtIS3J6NkR6TzgvV0lXVmxNelJETy81QWJTQTBRQWt5TzZVQnhHOEN2c1VVNUZZM1VNdkNSUEZ5UGI4QzBWMjlTdytueGxZc0RKU3RURFk5dDhQVnlyR3hjaVN2UlVPZ1JaYkdTbWs2NE5BSDRmbzU4QXFSSXBBYzNjNi9oN3VEZXpEMEEwSE94dmV1NjVuVmk2NWdnZUVNTHVlN25uc2gwOEk5MGJCcXJUV3BKaEZZTnFJWm9vaXhSaFE2cE5wSHExS3NvaWM3amVoOSt4NmFpYUJWd0NGa0hkTys2T3VFUjhMOG1HUkhGbDQ2dVJOUFVjWjJtZkVyRWtMVDJocVlBVmxqTkdaRlZYUTRISloyc3RGcnd5OEdSNkZJd0xPdXJrWGZpSXhyWnJ4c1ZwQ1lWZGpUMFhEb3lWbzVQMUdpb3dBZXhIeCtrNFFKckUvSHlXQ1RkL2hGMmFPampvaDA4TWx1S2plY2lZL2xjYm4yMWxmdmtPL05qa2R4NHJEUjdKR2ovQVR3VG91YWVGTSt1QTU1ZDV3d3VBM0w2YnU2MTNLK2lEb290dE1QVVFkUmZQZXNsZ0loNmdySC9DSDQwZTFQeU5EeU5LOEl2OUFuMDNTc1lzblZYOW9kL0JkWWhtNi9jeUZ2V1NzQVVRWHlXOVZqazdxSEpRaTYzQXY5eTBUUlpUNHZ0VlNrTW9pYU1SNS9pendVVUh3cXRxZ2hYZ1p5ZlhvVVZNU3hycWkvYnZhbnBxaDl2YW1MbnhUR2Y2cUp5c2dKelhwWUNzaFlzbGExUjZiVlQ5QzhkUFgwNm10N1lMeGlDS0FxeUpzcXlDSXhDTHcxOGt3aGlka1VWcE02Vk12Q1VKS2d0WmdHTnN1K1h5ZjNRVHdwZ3d3VnVpZVBzbUVGd3FSU21PcXJPcVBWYmNiNElPSithMkFCbHRCUTVpNEdDNnNTUk1lQklnM1MwWlgvSlMzNi9zQ2RrQ3dyL0JrRlhlZUUrVWM1SjRzV0tyc3cxZWRudjV5OGh5cThJNG51SUtMUy9HN2J0Z20xdmtmMlNKUC9tekdlZ2RwOFVlVmtYbjVURWc2L0JVWGhkNDQ5L1MvWkQ1Zi9tVjlxUGYwdmcveGFZbDUvak93VzdZMVBjQWxxZTR5YTVCbEMxWlppM1hxd1g3aTFzc0h0VkhCcU1XWlVuR1JtUHlqOUxwbEt4N095bmVzRTJmM3RMSXVjNDM3eXJGQTFGcHNiZi9PbEkvdVJiSjJ2cHZ6QVdkamI4WVJZNlpwV2VkR1Bud2UxZkR1ampkbW5tQmZXTHRTM1phWTdIZURsa0Q4QTB4czFScjBKcVNLNEljbGN6NExvVk1qOTNHa3lwMFRTcFkyR3pVZjREVmVjTHQydWErTGdVMXZqNTF5bzZpZXJ5Rzk5b3BvQjV5MWl0c3B5eEF6SGxjVTFKUnBaalNvYXNCWlMzaHRUMmk2cGYvWkt1bnBiVlhDSnlPamIycUYwSytFa29XSWdkaVpYcGVuQ2IyakE4QjF4Wmc5bzlYcy9kenAza0hnSjh4NGc2cFF2WXViaXFXM09vRlY5VGlURmpCTlJzT0RQQUYvRUF4ZGdZYWRwTmh1RVkvdk95UXpheldIQXRrbEdCeXNKQ09qWUxEa21EUTZGNkNORXB0ZTVDVWtKK2M3R3NKL1Z3S3RPOGNTdlBMNjdjYzlPaUd0YjE4dUxGaEVpOE1IdDRycFNmWCtMSi9NSFpjRkNQeU5uanY2UkljZXd3T0d5SElRWS9TUlREb3FiaVliK2c2RUpZVkhUeHFtNnEvUU9BV2hrSXlHSUY1dDFiNElONldHM2MwTnoyNm0yTEs0dVpWQmdxVUY3OEVDOUd0RkFZUG1qRXJtdk1IcGdSZ0hhTUhVZjdYUGhJcy9OSlpVN1U0RU1xSGl4QlYrQVR1aUpXdTZuYkZLMmN4SGxXV1VTa0tMdDh4M04wZldBYnR3eTh4eUc2OHRrWHc4UWVrQWpNYXM4NzN1dDZvTWpSVWo2Y0Z4cHNuRnVrakdzL3dMNlNXNTdBQ3VMQlBlRmhsMER0bWo5R2wzMlBBVGxSaFBiWFNhNjlzV0tsUWlGMDVaZWs5cGZzUk1JbW5sQUp0YTZoYy90bjlBd3ZyK1JuRGIxOVN2RUxnZkpoc3RJK0ZTSzR5SGtpbHdPMng3WFpXQ2U0eHF0ajlCbG1tOVMwY2RIVzZkcjFrME5vQzdRTzJIUnRqZGtCVWNmcXVSTW5DS0MzOXVJTk41REhYU2NOaWRwOXZlajZseFZncnRjR1Z6Tzh2bnRDMTR5UHJYVXZOTHJLZk0vYXhSN1huZ3NPdjhiTUE0NHo4NE1RdStwYnBaaHpuNFFEV1dTUDVkaGpWWFlGZmZ0dlo1NGxmMC90VG5kd2g3bTNjNmU0VDNVNFMycmtnMFRMb2RaQ01wS25tTkpaZUVDanVpcmNGbGhXc2ZQNFFzd3N6aEJYWlYxbENtdGdNcytqcE00M1o4bjVGZm0zb2lycGZrbEY0eTBmTHhCK1l0c0VDT0M4am1sVkRPZ1MwSytRSlQwbVd1SEw0Umw0Y2d1dndvd2tKSjZOaCs0S0JWU01KNmFLYzFDUXo1UVVmL3VmK29weTA2cmt4NkwwTUN0SzczdzJjQjVscW9HSHd4RmYxUGFiRVo5ZnpXcEJJemM1bVRPQ1dsYjEreUttMzQ3NkltSG5ia2ZWeW5lVGlPNVRqRVFvbERBVW4yN0Y0KzFqaFp2R3JGTE1aMFlpcGk5V3NzWnVJcUZSeFppaHloc2NWWFhlVUFtWjlJUGhWdzh2enZMM2l1TTY4NXRmaGZsdHd5aEY2YkxGWGNWV3BGQzB4SWg3VExwY3B0N1pKWmpYWTlRaXNlZ3NVOHR5azdKK01GYnRxbmRBTndlaWlqSG54SDhzU0lsUSs0OURDV2tCb3gyZHFoMnJsZmUwZi9hSXJQSnBiY3VscWZ3Zjhxcjh5RjhZaXZhdnlabkthMm0wMzZONGlBbXlzRytNVjNpVDU1dHd1cEhueWRJdHdVZ2srTGlpdG44YVRVTkowd2NhcjVlbHF3clp4eVI1RFZuTEY2ZHZ1U3JwRmdDSDcvRDhSV004bENBTFRSNUtVSGgzelpIUkY0dkxjaFhnSm9hMEhRMENwQnJUalZ0bWQ0VUFXV0lFQnlDR2RyV3ZZV2cxa1NNTDJKZ1htUVVpV1QrTnJWd2dSSG5jVTIxNFZsVlZnWDlja3A5by94Unh4NDl5VDhqUzR6eXV5eXJ1MnZ3NllKQXNqV0E2RHhoNEQ3WDU3emp1RlBzdFRKU3E1U2dDL0s4WHExYlRybGV0ZklaNHJpYjRPa3Z4SjA1QnhVRFdwa0VIZUpUTmY2K0ZER01PMk85VzZ3ekhFb2ZhTC9LdDlvdUhJTGx4bWthSzltb0Njc3U2VHJKd1dINWRMUGE2OVZ3bnRiR0JSMlovU0dsSEVVYlZJOVRQQktCcVl6UVVkRmRXT3ZFYm5Sa3FuS0d4WU14V3Vqb3RoMXBRTCtHSXloREtBaW5McENzUzJpNkZvYUdhMFVDUnVRN2pnZy8xMkdjV0hsVEt0Ym91Y1JaMFdvZHkvVndsdkpCT0N6eFJpU3dzTEFneTJaVHo3b0laT01NRnpIQXdQWi8rM2ZSY09qMmVxOFpUNWVSWU5HTkhCRkVTc3hQS3RiTkZRZkRCc0VvVzdva2xjMXV5djV1ZDFDU2ZFc2NGcmpqaDZMbHd0U0hJdkdIQVl3WjhJSkdBVDIzS0NlY3VRVmw2NWVacnI4dk1aZUEzcGMxbUt2dEZlM3MrWGt5VjB3SmRNQk9ueDBJaG5BeCtubytSY0hsc2NuSnMzOFdWclFXRnJhZTFYRHNGUC9YQmVRUEkyUDB4Y0pHQ1g4TzltbnNkZW1qTGJLMjRTMjY2bE1qZVpHTCtNbSsxWENMRXpNY1ZSb3MrNUY3MVpmN3pzTXlCSjlscG5kMzdkVmY3ZEloOTRpbDJ1ZllTY2wxMUZwVXgxcW1jWFFUYXVBdW9JNXQxNTRneTIrd1h1ejB6c3dSeTh5QkRSSTRORFJkNzd3bXExVHpSdFdKdWYydDFsZlNGZ1ZzYkhnRjJiVC9LeHZ1OU5zdXRsdGRxbWZJbFRIK0FsbnJ6TUI1MkRzYlBIVkZyS3VCM1dwdUhmS2NiQTVxY1BsdU4xNmdtWU8wTTEycXRzOXFURlNiRGUrdVp5N0Y2bm1LM2NpMGFwT1pFTjA0TFhmOE5nblNTbzdIa0J5enJKSnpRSGdEbjYvQVBJZXcxQm05djE1UzVGbG52WU9UMkdqa0U1Nzd3UEhPSzFtcFRURWRDdVZiUDMvWlpmZzd3MkM1dVA4Z2ZPQkthRGVyTVZuVGRQWXBPbVRxSVdjV0NHNnpDUnB0OUlIc3NJalI2MktGZzRvYTFLSmVnYnNWYXcrekN2WUJSdC9KVU1aVnJGV21zK0FyVnRtMlp3aGp2azFUMGJXVzM0cDNGK0s3eDNQaXUrQ0xlMlpyRlcrMS9yU3l1THpZcHQrdnNka2pMMmYzVW0ybWsrU0pUWjAzaWkxTnZocUVkYjB4dnd4dk5lRG9kYjJMMnR1bEdIRzY4dUZpcExMYjMveGlaNXg5RElVODhBWWVPem1tZHh0TDIyai9ldzkyUEd2TCtPUEhOQWFzOFplQzZlb0gzYlZlNTNoVWhBSk03NFh5NDJuWE9YcWY3UXRERHlVNUNlYWliZXN0Wjg5N2Rib0g0Yk9nRUJpZ0kwYTMyK2lxOVFhN3FQcUwweWwvcEpjK1IrWjlSSkNmUDQwaHVMeW9LRExYV1ZYanJLaGV2b0Y2N0FYajRNSGNkakdVazVqTDFkWERiVHMyNzBmY0hSZXdHQmwzR1k1bWFPZGtJR0J4Q2hHbzhrRWV1b2htRUhYUHFiQklVeWhMeXpuWGtsL21jR2RpeDU5Z3hPcjdEZ2lLaHIwK2dFSWxQNkxLaVc3b284WXFrYUVlUDdkNFJNQUdYdGorajVjWURpbDlVaEVzVlFRc0U5STlxeWxNd01jbkc0cmFMNFcrcFNiaTFnRm5QVFZJOVhyNWtWU3hGRGhnSjIyY3JBWitpV2FxWWtNaVdYTjBNckFGNmJiY2poaEt3eXRGOE5qaW0yMUhqRTFTYjk0NnBkRUY3bDFiSVRMcXlVbSt2aURMd29OdlB1bHZFNkRzZFVrTzRYbVNOSlkvOGxHL21jczNkZU1oUFhEUXhjZEVWZUppdzgvbVpmSjQ4M2d2ZTRkbFVZdFY5QVEvdUMzQll3VGRtOHE2UEJVSCsyZUR5NkR0cVVrK3ZqamFpTE5Tb3NScXFiS2hlQWRnVjNEdGlsbG52bytyUXZiMSt0TmFZdi9yRTFmT04rdWNDOXRhdGRzREp5N3JQSithZGI4ajNTZEo5OHNUdVNxTlIyVTNXTHo5OFpOdnlTcU94c3J6dHlPSDJuNXVaK1ZaclBtT09MeWlFOE1xQ2FKbVgzUzlKNzd6VXRCWXUyM2FzWHF2VmoyMjdyRE9QZVFMOEpQSURsOEVzdnBxN0diaUFlejE4UURmK2ZiT3pScXAwcDNpeG0zSkRCTEpaVDl2QXRKbk14b1FpM3hrZWVzWXN1aVFEY2pwSk5FVmlpSHVOVWVBTlJzUHZNWFExWXRqaHViQzlTbzlHaEswZVZ2SmJaMVptdHVZcmNObHVNZE5Gc1g3VkxWZlZyMjlScWtjNGRzNjFWNWx1MHJXZE4xbjVUOERrUGhWTVNLbXdiWWZqY1R5bXBFVHdGQ1ZMcVZJaTZsTlZYelJSU2hsM3IrWWltWEE0MDM0L1k5M3dlTmtKSkVTY3I2c2ZRQnYzSW96UlBmMDJ6WnNvRXFXTWlMMElvMGpocUN3TVlFdjdITmZLSy93ODAxOHdlcHR1L3pteUJPMTFqVGdvQndEbjg4MmhXTTJUWEg5cEQxQWxTWmNNQTFkd0NNaHVHNGdybVVOU1M2S2JFYWpuOEpwaE54N3VISWJkNVRqWFo1UFNyQ0kzRGZQeVloanJ0M0Z2NHQ3TmZiaWYzeG5GK1F6cnY5S0ExcXQ2anV2QlNML2V2aGoyUERrMVJ5azRDMlk1MTQyOTBYNGZqbW9ZM2VRMkRBcEJWclgyTDdxdHZXNUk2alZEVWwvc3BzZ3FDMHZPamdNUk1PYm02SmVBL1dtL0NMemI2SDRaU2Z4NkI1ZDM4L2JEcTE0NjlJZjZsWjAveUM1NXQ2Z0xlNWwzMk1JYnFjL1dCUURpcSs4UzRHVmRWRVZ4NFY0QlRqcWpXOTYyN2FPYWs1ZmFPblN2NXVYeVRyNkI2NWg5SHRYbjM4Z1BGM2orZ2FLa0V1a0JYcnpjNUVVZU1rd3BLSVdsQzJqczF3dnc0Z01TVWFYaUE3eGc4anhlbXhJVUVuUnRKUWJtMXFHWDNtNkJ4aTZrMjZSUWJZRGRvVVRuMytpdnhLREJNc0dJTlFxYzFhbFFQQVMvQzJndzRWVHBQa2xXeFBza2RkMlBMNGVHak4yTFgwYnZ2dVNaZnJ5ckY3K0E5cXh1aXZYZGFZZkxjM29zb053SWZCMWE3bFlSZXNVYjdzaDd4L3NNTlg1aHNhV3duU3lLRFBEVWUrbTM2ZUo2TjduYXFmSkEwOXNyR0ZLU05iZER3VTl1ZWh1VDMrdzF1UjhVMkhxdC9SSFdlSTBiMG5mWHZZeSsyeFE4Zm5PNC9QUHZ6eE9DSUl1YU9EY0hHRWdXaExrNXVBYTgwcjIrZ0Y1ZThSUXhyTWl1RDdBSERpOFpDdWZmd2d0b0FlZlJSNkN2WW9udVo4aVYrb0s2ZHpWS0xNNUN1ZWhHVUdoaVhJcitNRkZMYUFIbHJsSU90R2tTdFl5RTgwZ0E0N1hhL2xwdHJ4bEEwWnF1cjkwaTg3RzdhT2dscW1pNUs4cXIwZ01QQk9PeS8xaFhpUkE5WmtqUlNrOG9PSTJGN0s4ZEM1aFFBRjA1KzZHMHhGU3JUT25TRU9WYzJNaDdkUjFsdjRGOW8zajBHbWxvZTUyN2hEdUM5dTFtdlo5bmtMd3hINTJ1eW00QUhxVitRTkFTcE9xQ3V6U24yQVBSeW5JOUN6aHl6Q1Brc1BiYzV3RUx5WFg0dDRjTFJoeFh1alplVkZWTk9hMUsvK2hWU3BGM2RZejF4Tzl2Z3ZONEQwQ2RhUXlRbURiVDQ0S3BhUEtsRk93VWFGMTl6eWU0T0xmQTdlVDJvelI0d1gwdERCMUVaTy81OXZIaFRVMGdxK2ZUcysySE53ME9yalBPSjJqc0ovU1BaWHA4WEJGell6ejBuSTkzb0lZYzEvNEpNejZzTmN5T2VZMkpqajRLYWdKTVp1OWd4L2p3NjBQVjdjbXhvTDVVenRheTJkcjJXdlpFc0xhVXJNVGIrL096YTdONVBEeWMzUm1hZTg5Y0tKeit2cnExRlo1OXoyejR3ODhsczhGSWZud0czdHFnYjJZLytwVlVKbWhmUThLeitSTW44clB0MWRuOG9VUDVXWEpyMkV4ZmNlaktkQ3ZVL2tFdUg4NWNlZkRLTkZ1YjV6aWVKNnNnSGNXNW96Qnk3K1pXdVZQY1IxR2VWTnhsOW9WWWlhbmhsNmpXb29uNXFNK1BEcE1yS1JWcUZqc0JsY2F3aTNFWWozV0dNMnFCYkFkdERncXlZaGFLQldlK0kyR1c1dVlwU1dOWHpvQkxJYkRpN0U3dDhhQVdGVkZBTEJJdVVIUXZybFY1TFJNS2g2amd1VTZQY0pYUmVKVlg1SnpHeTFuZGlUOFRkL1NzekdzNVdXbmZxTUswME5TRUhEZWVNZUt5YWtUU0loTkdXMkthdVIvT3RUZVNaVU1uSjNTanZQS29iT2lRT09VVGVCQkppOFZpZ0tXT3hkVkEyVnEwUXhNOTZYUWlaQzlhNVlBYWwzVTF0TnRLSkt6ZElWVUhJbE1QQklPQjlzOEo5Y3hKRUNxa1BsOU9McUtZdkpnc0g0b1lSb1FiM09NaGpmdk1qSTV3R3lSTzNSdmJhdFN1RHZldHJCZ1JiVVZQNml0YXhCaTFpY2ZLU3M3RUovQkJreHRlbDdORnNHMVd2VEhDNnFOMjdPajd6UERvci8zMUhWYVBzMFduVllyZTJHVFdpQjA1THJ3YXcrcHh0c2l6dHVXTlF6WnFwNVgrajR6WWFLTy9hMWhNMDEwa1QrT1NVTzJGTjlKOUh2M3F2Y0hLQ1VkeTNtamszUml0M0RxNW1aWFJEUGRIbmcrdmUxOW9rYjd5em5CdVhOWGUreGd2M2hzRlB1eDluYlFHNnpNWXY3MkFka3ZuaWltemViU1BqT2EvMGovZ1J3ZnhIenJtQitwMXJ2ajltMGYrNklqOWZkOGJHYXAvWmZQNEg2alR1ZUx6YjVvRkk0UFY5OVZvZENqK2xTRnpZYUJPNTRxL3YybEdqSXk0My8reDBZSDJCM3F2TXk5eTdwak85MGY1eitjR2gvRksvNnlnc2pHL202eTdhNjI3cVg5djNpVlpUTDF2eXYyYlR0YW93WUdUWDJBaHFUcjhYVzkvU2JqWEY5Ni9LMzd4bGZZMUtoL1E2T0xDd1l2Q3BVWkorNkFHUnhNeTIzL3RKNjlTQS95a0VHei9ZWitxTmRIK3dqajU4QWRyZ2k3VUpGa3RVcGErcU1wa2RVcnpNVXZCOTBacXBWSXFIQXlHVTZWU3cxVDFsazg5N1l1MFYxa0owNnk4OWZXVE5RSEtDREplUHppcy9iZGVZUHVGemdiWnhVNmlCUGVZNDZLMzdlNkN2a2VFUFY5b0hIZFhtVjJqcVNxRlJ2dC9LZEk0YmZzNHZ0NU5uZ2RNWEQwMis2MnUzN0twREV4U2ZOYys4MlhnbDc0Q1V2Z0Ric1F5R3QrSGJxbzVnL3RidWtlNmw2eGlrRmozS05PdE5ha0ZxM3VNb1pFcmxvQ0JsK1Jab25STkt1RGcybFE0MUxvQ2JXS2JybmtGUGJnMkdHaEc5V0k0YkFneDAxYWtjTkdNeVZMT01VSWh3OGxKY3N3c2hpWEZObU9DY1I3UHpEUkRRdGpmTUlTNDVqaGFYREFhL3JBUWF2cGxkV0pDbGYxbnZmdFVwN1Jvd2Z0RlhFT1Z3c0MyZWI0bzJleVpxTlgvakMzQk05UG44ZEZnZzk3VkZIOGo2TDNyeXNwdVhJY29sK1BLMEVQOVJvd3NkbTZKbVoxYU9LYWxwZzA0Z2Z5RVdpbkdPNkY3amh3NUt2cUUrOGphdFlMZS91SHhhNDR1dDUvcW1DZTZrVnFmYkRldUVzU1ByZnhYU1hqZkE5ZHNmZHoxUDJMZkh1ZHEzRjZRQklkL2Y5RDVxalJ3N1p6amVxQzJxeDRYcTF3dnZUSTBPZGlLaTQ3Z2pTT2RYYnpaNGRIdTRSdWRRejlzRzl5dUVXMmpjUk5kUll2aTNkRUE0d2U3UGxiWUZ0d1BxajRJOW5VenBZK3Y4QkxaZm9LWGVJTW5EOEJwKytWRjNUUnVOTXlNZUtPQVZsL1NZQnVJQTNmMTRrMDh2M1FmSWZDZXlMK1hKOXN2SDllVFVkTVFKYlExRTZpZDNIOGxQd084NWdPNmdMRStGZ0MzY2NUQ01ETXpQTWlYYU5aWVJNdHl0SFVFQ3FZQWVrUFlGOUVyaDI1MDJ3Uk1WOEkxUzhCNll4akRBUjB1dUc5SWlyRHR4a1ZKelcwL3BuOWMvVlZSRnhNWlhwR2FoOTZnL3BNcWJidDVzVHoreHVVOU5WRm8vL2FXUzZlSStKN3BadTJHZEpZOC9RMVZXcnh4bTZDazlHUGJXNzhxaXBtTFM1SjY0dERVcTZCSWNjY3RTL3NXYXcxVm00RUNmM1gyaXJyNlJ4SXZ2amZQQzNOVE0vMHhvaElZalppTXRFMDFoK3JkUFp6b25oNlhlU1dHSk8wUHdUWm9sTnBoV29uNWVWRzhHbFhxZ25EUmI3Z3FkVS9NYmVRSmFwczVPbVdBUzVHY0laYUdmVnlkSjNJNVdjYUsvY1krV2pFQkE3ZDlRZWpuN1BwaWdMOWFGY1ZQWHNSYWMxUVVQOS9abzVKOG1keU8rMHBxM3U4MlhUNkpmQnptUEZCV3Z5QzhDY1BBVGdtUTFNa3Q3UjhkRjBVZmZQSk5JbWJxa0haNXhXY0p4bHc5eUwyZWV4UDNEdUE1WEtmOXNtZFBKL1RibXE5aHhKT3UrWnRCckhtMGJ1dnRvb1JPUHZTaXo5SEhFVmlVU0hpMEc4czJGc1ZZSTFheGpqYTJkaFdMS1Ric1lyMVpyMXIyanhRcHBBbDhES2RITEthSzB5bEY4NnNWMWE4cHFXbFJqYkVidktDRkpNV1VGT2xIOFArTGZ0K1lMbXQrM3pRUE0wamlTejZmYkFqYkJVUDJGYmJ6dkhiVWVOdDYvRlE4bVpTVVZDcWNvRk13NmtzRS9PTkhRc1FYOVB1RFBqNTRaTndmU1BpaTlHWThra29wVXRJUTVRWityaUdMUkxMU2laS3FSNmJvN09aTENVZVhSTEpsQ3hFbC9jWkVPSldhZWg4Vm4xMll0bWc4NTkzY0FlNUdsUFVRVWxVS1IzUjFXdTRaQ05LSU1jMGVhSERKdXdzY2FseklvT2QwbkFaZzhKa0RRWEQwVUNEelRDWVFHc3M2dWo4ZG5ZdW0vYnFUSGZ2UnpRd2ExMWk2WDRscTkrbW00dGRqMFcwUnY1Vzhrb2JUa25WZGZtdWJ4Z3dsdUdwMnFteVo2clp0cW1tVjY3dDJGdVdZSHdlbVB5WVhkKzdhZXpOcitEVlZKeGFUUlFrTkZDVlJqc1VxdFptTG9vbkxtZVZhdTlXbis0OTJZMENlSzFZUlJpVkJtd0NRQy9KaElSL09rMko5aWJlSzZQRGxRQkloZ2lha0pUeXpXdzc2aE9HZWFKMXNOKzI0dm1MNG4rZHk3UmJhV3FGWmFXdlYvYTIyMnV1dDlVNFcvc0UxcHRZN3o4QXJRQy9hT1RpdnRIcC9xNjFSRjYxdUhMcFZ1anFQTm81MzBCM2lQMEMxM3QzSjFMWGRLL2JuZEd5UE9pb2pZV0RmMW55L3FVbUhPZStQaW13M2h6N2xES3pFODhmdW8wNDcrNm4vem8rN3lWdHdBUE56Y05RazRSYzBUQmVQb2IwT2JWSkcra1d4QWxoR0ZrVUhjTXEvYkxvZjljUVNiSG1jSXp4Sk8vd2lmZzRPN1IvaGwxN0V3eWJsNVRzQlZUbWlLTVBIS3FLNGY5UDk5OUg0L0l2dXV2dm1QcmdWOEpyYkI0UHdIdFluWisrRDRsRG9sczRMNXRKQVQvSEhidW5DL2NlZTNyaHZlQitjMmdUaTlwZk9EdlcrSGlLdG9YMlFPNzlPT0gwV3NBZjdPcWlQcGx6SDNjVGR5WjMwMEpSbUQrWTB0a3Zmdm9HRHhxMTBOOHZlWld3RWZWR0tqajFmdFJnVkFRVHJKU1M2d0pNa0pSZzV3ZkRQVTBZeUl3Z3hRY2hRbm5MZWJ3ZzVTbEdTaEJkMEQwbFp5clZ5aGUxRVVJK29Bbmw3aDNxa1MxWmVvNUM3MlJkTmliek5pMmtzS0UyVHFhanZabnBUeTFubDlBRDlxSzJzck9vNWF6eVRHYmR5ZjhWSUJTZFFINWcvb3JhTlRlUkxKYXQveUpsS25rYStydzlkSTNXRlVMUkt6Q093cWdCVTNLbXp0KzFEOW1qN3hhTkszSHBpRzFaekcyV2pXZklKS3o3ZFBpVks1TUQzRHhCcHFqTWlGSkw4NTM4MkM0dWVKMmx5c2NBcjRyZS9MU3JNWjRGZ3JBSVZaT3pyTUZxNzJWRWFtTjVOU1hmU3ZRQ0JDVzA2YUxGVmE1YTc1dlFLMXQycE50R3BnM0hVdEZPQkJ1NUU2YktCb2JKbEZoTFZkdXBGUzdIeVJ4aUIrWUVzUysyL2ttUTVLVXZRQlQ1RFVaV1ljZVhVWlZNK1NYNytWTHk0ZmZ4S1NlUjFSWmJMb2hnU2ljcXJLWjgyby9rMmN1czV3cEVVRUwyQXByWC9RWlFYb1JocFVSYU5wQ1Q3Z2huTEwxbitPdzEvTUIyRzRqN29rNlZrS2Y3UStQYWlLbHFLck40cEMySGdKWGl4cUVtQlJkMlVVcEtwOHpkVHJYa25mdHl6ZEE4ckd5Z2FsYUNhTnJZZzc3YVNCbGFqWTdkSlYzRWJMakJ3cFhNbkRRYUZsQjkvZ0NUcXpVNm9Cekl3SkpLVlVJUzBhc2RxSjhNQkRlZWRFVkcwQUMvSkp5Y3ZuVHpER2I1bG41SFhlWjFJcGlUTktuRVdSNVRzOXc2TEQwWjhSWFBuQmhUaTExTisyUWcvR0loOVdsZTBwS2hESWV0akFWdk9BMWozaENUZnBNekRMTElFOVc0V3lMVDlWSGVvZE5yY0l2ZFRiY3RldEs4cHVYTzlPN05aL0ZTN081SDdackdMYVoydTJrV3BVbVl3eitZdyt0VWxMSjRLV1dacTZZcWxsSW5KT0c4bEpDVXBNN1pGL21pNlVsbXNWTlQ5dkhtMytWdG5PT2pvRk54djdLYlZ6QnhhV2pxVW9jbGRUU2pPRUJVMktSV1JYSW52TFZhZWFDMHVQazdYUDdyNEM4YzN4Z0NtTVdueUhaKzBIcnFpTEJ4ajRDeFAweWp6Wm5hNnptYU5HZWhBRWhkRlhRMm9QcEdpcHJScExSNWF0TXcwUlVPaUQrN282aUlMMk9Fc3lJVjNGcDZGcnVzeWFiSWNOSk9aY1ljMmlEY3FjUXdMRUs4WVBMTytIczhremFDZjVGZ2NqNHV1dnVTU3h6ejlKWFZ4OC9WMC80NjNjQTk2c0xNbmJFc1RONVZHeisreXUzNkxUcW1NWTZYaHVGbkl3UE5CenpFME1XMENrbzdaUTVDMDBNRWNMdHVmb2pSd2daY2lJRW5ybG9TR1B3UW9GZ3htSGhodEdSaFBJdkVSaVYrZ0pETTFnTFUvR29MR0I1TGplOGVUQmlCdjdham1JdSs5WVRzVXNzT0l3N01WdThKVWFtK1JZSllRUHVJUENvSVlqWXFDRVBUTGdzWVRvdlBTVzVpemNpbStaV3dBa3gvMEVWNk5rbVBIeUp0OEpYc2lsNi9ZcGIrbkNKMDg2VnJ2TURqL0c3WFhqRlBMM05zMjc5L2RkVTF4T29QZkxyck85a1VhLzl5dU5oMUlOSUh6aU5INDNNczBNcU1pNUFVYUxvajZJdExBL0pRbTJEU01lcU5LbnZacysvUDd1bUZFRFVPMzgvblpYTzRPVmZYSGxtTitGU1Q3WWtxNTdpZlhLY254YlFhd0N4Sk1VWXZYeFlvbzhIZTBOKzdnQlVpQzVLbjZqYWdNWFNCTnFJS1N5Q1VVOUlQdmNSa2JXSGpVeURHRDVMV1EzN0w4b1gwbDRkdmZGa3F2VWFTY3p5Z0RXS09DS3JYUEVDS3BrQlRFQ0JUcXkwbUtHcldzcU1wMTU5d3V3Q01hdFVNNGpMdmdJUFdZeC9neG00aktFbW5VSGE5RlU1QkU3U3FqS1pEZDlBUkJnTW5Yb1NEUHpCbTZicnhUWnJOSlRpcVNGTXdyaHI2aEcwbytLRW5LWDN6TXFGU0E3bGNxNjVSV1BEeUhTNXVmN2VFTEE3REt2aU41UmI4QmI5eWdLL2tqK3dDamxDNitRYWdjbm9PL3d4WGgrdi9nVWdUV0prWVBacG45RnE1TEs0aE02czN1eGtwUWU3dkpCQmY4cjNUbnlBNk1BODcyNlRBSE1NZ2hrSVBKT0FqSEUxRDk5b3RRLzhSY2JpVTNCM3hpNkhSSUV1WSt0Z2pEOEZOZWpMOHg3ZXk1WlA5ZVozcEMwZS9DMnQrbEsyL0NLaCtmRTJielN6dGIyd3F6L056YkZtRUErOXMvOTZBTWFpZnlMUFZSeEIxSEh1Zld1S2U1TDNGL2pCcGtoampjeHJoczlCaUpkdkNBTlYrYkpmOU9yRjk5dm90alNGVXBEdVVBbTNVdlhHVzQ2WFR2T1VXWGtiTEl2NW1LSk9wWjBkQ2YwZzB4cTR1SVR5VHo1YkNQOU5CdXJlWmFmQjhQZVNpZW04dkZDd1NnVDk2UEdRZkdOVVZVTkQrd0lNcDBNeTVLZTdCdjlraGl2RG5OMEE1bFQxNHE0OGxRRmxsY3lRMndudCtjeDJDWDgybDFhVzV1U1gyQjV0MWFWblJkR2RpYmRGQTMxNzgvYlhmVElvOG1hc1FxOFYvZXd6WVBPMzVjcEp2ZDNDUHFJNWJ4UDNqUzNiYndGbmU3TVdGem5VYXY0anRkcXpqUGprRWpWdkx4U3hnRnMvZWw0Y3ZvMzl0Yzk4RTlYR2ZQdHFKdmI3YmRpMFdWNGN2NkgyUjczZ20zSEhjM3doTkdWR3JqSHJhVDBQRmJXQ053bzc2T3pWMGZyRWF2OERmdFRjYUZqVkg5TndRR3c1ZjZzUUcwKzQ2eitrSDNkZmZBKzJYT29qdGVEZFBwS3RZd1hhcER2dlFDbFBkMUJveXZmbzIxbGFhLzJyZkJMTG54RzJ4ck9NajYydGZZSTNjcHZmUUw5RW14czlmc0w1TTFMa3J0SC9xMmllcHNDY2ppZVBSdmdkVWMvSVFpNm5kdi9rTHFCWmJ1MUJHQVFPSFFxVHVycitDcEI0VkovNDZVSFg5aXBoa2MzQVdzeUQ1RjYvRlZCdVhYZTlKdVJjakhOa01PNUtGZXRUcWc4L1lQaFVuL3RsbWRMUUhwcm1BRFc0UFowa0JyOFJ0RFdydTV4dmVvUS9xR3VQV1lvRkV3Um95SFlaMmYyVlFhQ3kyT01PYitsZmExdTBmc1FLZitVKzlGZ2ZWdTJsdSt1MWxyWHpubXNENkpiQ3FIYmYwNlVOQ21OWWI2dWExR2hNMEd2N2pSNzBqVGtlZUhJSWJSQmlSbnVFM29WdGk4RG5JdUM1TFNVS3c3MG9xRWZyUWY4NDQwSmZuVEljaDNFd3pQWlUwaURjWEFvOHd5Q0xjSmh3bWpEVXVHd1h2WVd0SzVyRXZNWWRoNHBJWEpFTENNTkRNWjBwN2VYTnVHWTNybzVCWTNEK0FyTmcxejE4YjdQOUgxamdwM0taUkpBMkhqSGsvTUtaa0ZrM0s1TlZ5RjdJbzd3NHd3M2RoSHVFbGZMRXArUFZLUGtjVURpeVJXTDVtWDUyM21XMkhuTHpkUG94VkVxZlNWcXcwOXBCczVlcnhhTTVQNmdhTUgwQTdvTldiTWFUYWRXS2tST2ZCSGRqNGN6dHQvZENEU3VCeGZhcFRlY2ZRRlpMUk9uTURqQzBmaEJlM2dRWGpieFJtNE52a0ZTcWxRd00veUZxT1hHQkRDRFhLcDRMcXE2MmVKTWY1a2twT2srWU16bEFoT0g1cVhKRTNhZWtOdHo5M3Zmc09lK3ZWYkpZMDhvVW95MGJkZlc2T2tjcWw2N1E2ZHlKSXFLOFIzMFIxTGU5K3dHOGp1OXRzdThoR2xzMjliaDRhZmhRTWJRYXhIY0ZhdVh3TDZpMkpVb08wb1o1RmlONERqZ0IxenQ1OU03MEs1SitaQXpGS0dZdWhEMXhBUUJzazFYV2UvVHpFaDlMYzc1c3R6MUtWa1R0R1dZSUM5Y1VIVTBMRnBENlRmRGZOc1ZSUkJXTFZGc1c5aGxNbVo3VU9kU2NmQ24ydktTVkc0ZDBIRTVWdjBybnFYd0hnZ3Bkdk9JQjJWODl4bDNCSHVMdlNkUDdzSHVMTXBnSVQ1Y3VCRDRyajVoOUIvK0t3cmtyUFRYNTAzc0U3M2d0YXY5SkszTThpc3NCTlJMd2g2UFI4TjlDMjFhWVFYR0JFMERKUTEyRjVoWkRPN2tOamM5ZUttWnF5eDlwRlZGU3VxRGljUm5Rb2VZalhmek5kT24xVXU4U29IM0lBdkkyYktZNGRCWWpNazVXTGNsRUlZSlpKOGFFbVExN0JLSDZ3Sm11Z1hTUWR1VkM1T0FLWlk2dXcyNVFIYWpzNHVRSnNoMXh5TXhYRzZ2UjVOTTcrV0ZrdmNBcEJicDVCTFIxOWM2VnlRRmd2N0JabjRCazNnRys0MlNYRDNSUnBHZ3FYZGVJV3U3UXZiUi94RzVHQU1Rc001UmpIK0k5SkNta0VYbTJOMnJIbE9NOWF6dnE3OGkwNGszbXBFb3VWNmxKZUpUeERqaDlNNU03eTRHQmEvT1dwN3hQbk9TNlhHcHBjRUlvWjR3Z2REa1IxRkU4NmltT0RqcWRsQzNESzFrSERmcUUwU1gzV1dseVNxdThZOUREN0JwYm10ZERjTWp1Nk1od0VPbGF5cmRVZWMzMmpTU0VDNHRLcXdxSzgwSUJYdVpvaTR2MGkzZmJENnRtanVLalZzeFNHaDZmMmgrTjdaY0hGbXNkSStsYTFsRnllSXM5dVpPVFRIVDlZeFhNYUo0bEtoTkNiQ25ZUWRmMVc2WlVSOGg3UzRkc2dYTVppdWJlWFFJYks2VUVuTzV0T1dYQit2TE1LalczYktxZ1p2NTZZdm53bGVOZ09wd3RKRk84TEJFTnp6RlNzUEhva205ZjJxdWw5UFJvL0F5SDN6L3YxdUhOOWVtNjkrZVMwZXdQdU1hM0RiZmNHTjNzdTh4OUIwNVRoeklHTytkeGZhN3ZkOWVLOG9TaUl0NVRqR1J4YkZ2Ui91cmxXOFl2MXQxZ2UyNkhieG9kTzBMN1RwNGl2UzMrMG5oM1g0SzlqZlpuM29ydEJ1dXkrNDBhOVVmN2VmSE5YaGZGL2JYMGJMTDdSdEY5cUVUdnhIR2h0akdia1U1aGtqeDRBSlpwV2xBWGlwcWhpakR5S2ozR3d3clN2YkpKVTJZZ3o2QVRxSHRjWXV1ODFaYURTcHVSWGRpcDF0ekE2b211MUNpZllLRGZSTHpNMkZmU0ZlRXFaU2M1bEZKeE1PSm5sVmxLSlE3VnMwVlk1S29zb25nK0dNczVpWlMwMEpFaC95aGVkeWs3dnM0UGd1SjcrMWtNeEZSRUVQK01XRWVZdVpFUDErWFpCeVU0V3RlV2ZYZU5EZVJkYksyeklUb2lTTDlsVEthZWhxU2hERVJENFFUbUx3NDJRNGtFK0lncEJTOVlhVG1ySXgxdTVFZGxzNVZ6M29TR1BiUzFDTUVRbW9rajhZTENZU3hhRGhsOVZBRHI1YTJqNG1PUWVyM3JYWDU3aEZiaGYzS21yMTNsbWV3L0NzN3IrK1ZUdUR1RHRob3owV0N6Uk51ZnRTWi9YT1hkWEdOWWltYTlhQjFsbGtkWGIzYkNsTjdHU29sRGJzb0N5bXh5Rm5QRTFQK2FTY01QM0p5V2h1bktTTDdUVzJ1ZFFLbnFMUjlKZjhkQXVyYUlqTVlWRFJ6SlNjeUNqUWR0U1pDQitUcGpJc1YvcWFtMHhOS242L3dBdWlyRTJYNUtucjJRWlk3YWZaK1RzOExUYWNrTncxRkdyN2NqUHdSN2ptTkVQdHpycDJBM0twQ0JKdlo3dWgzdEtUUjAyNUtyd0plWnczQ2VRbmJ4Sm91djBuTTd0M1g3OTc5MHd2RnVJNjdqTlV3UzJIZ25tV09vUlBYTDk3cmhmcjBPMlArMm04ZUl5bnN3KzVOYnA1bWpPaUMrcTRtSlYxdzFNTjlBREdoWEd0YXNqYzJJeXdtQnRUVXNVZXpNZlRxbS95SW5WTEVuZm0vRXNQeEN2cHA5d3R3N2d0WTBJbU5TZFBwUWNnRE1sN2ZWcVpqNDlCUVNmNjRYdTl1ek1ZdzZOc1A0QWdOdzVqakVNdndMcTVUS29ZSEZtZ1d1Y3l0WWYzWXNjUzB6VjVOZ0dQTGZ4OVF1QWZJYUtRNFBGMElBS1QvczF2eGtWSUlwRlRQSDhLVGpFOGk0TDNWa3VCVjhnLzhqeWUyeWJQdnozS2kveXR0eEdSdHdoNUI2VGY0WjRFd2VKRmN0dXRQRnB0WUQvQW1HRHJhbXhuVkc0Qy9TSUJ5VVZsczgrRGdmRjJUcjdqd3RoazIwa3NOSGk1SGZVRlpUNHFCMmNYSzduRnlucGxVWkhJaHlwYjE5cnI1ZVI2c3J4YVR1Wnl5WEl3SEE2U2ZHVnJEbGVrdnlFcGkvRjFETVMvaWcrNGEzelBrZjlKbnVVdTV0N0EvVEx6UVdnNExQZ3FMaWVYY1QySjdqK1hJVEt3OEozNHJNQkVHWVNPanAyRTdxVUZIQ29LNFJqV2pNWmxMU3NPVEhKTGR1b2dpY01nYTVaclRRZnV3blN1TjJ3clMreG16RlpnOU51eVI3N3JqS2kveXd0Q1hwSDU4SVFjVXZLbXJXdGJ0MnE2YmVhVmtEd1I1bVhsSFBjdm1iRVNpYW1wUk1LYXlSb3pralJqWkRmbFBOdTN1OFpqWmp4dWlpRjFjVklXUkRPb2xkVUFCbUlNcUdVdGFJcUNQTG1vaHNUemVPYm1WRGlvTlRUNEdaRlVZVXNxbFU2bHRoUlNFV05UNWwrd2JVRFdtRlVCeCtuVUYrU2QxQmZrVGR6WHVKOXd2eUF5T1VEZVR0NU5UbUcveUE1bDZha2JSeG5EUjlCZ3VFc0FjM1QvYlZCWGpnVU1uRXY3SlFqOWdodWlvUnd3U1REQU9lMjdjdE9HNTNHSHdHckRLZExOcE1zT2RHeVFCa0duK3czS2RwVnVJaDJ6b1RPYnBBNzNaZndxZFIwcE4ybndiT1k5Z3R1K3VJSHFNL0E1ak5XWlpmdm54QlJJMFkwbmNIdDJha0JMbzI3SG1uWDhOcXRENTl1ejhBM0ZvaHRaMHpwMHZqMUd1amltNTYzdEZJcm5Ca1BEZm9YQnNKTjBvakNIT3drK0pjZ3dEb0pxMUZBRVVSQjVUUXZnOGw5QTAzaTRGT1NnQ1VPR1BoTlN6YUJNbndFeXlaNlI2RE9LRVZXRHFxN2pGdlFpWUFuZUFxb2o2NnBQMTMzd1g5ZDhTaTlmOGJIODlra3puRmJDa21sck1CTlNQSitDbWFEWnBoUlcwcUdvVDAzTlpGU2ZHVTZwWVNrYVZ3VlpTUWhDR2g1UjUrU1FtZ3FiUGpVOUE5ZzVWeTREVzZwTjVMVUpYcEw0Q1MwL29RRzc2dVltL1N6WG42UzVUbkZ1YnQvOGZNSEtacmRrczJUbS8xTFRUYTlmMWM5RlF1QVZYdkZMWWVDTVpKOGFOVldmTEVsS1dQWXJncXlLb2lvTGNrQjI3NXBSdkN1cVlkbW44UEpFUkZRaWlnYWw0c2NVVXhZalBQeEZSTm5FWE4ybitUUjRnT2EydnpPbUJyQkIwVW9hR2hheUxEaW82VW9VRytqWHhxRDFzZ3d0YzUrS1RTVFlVeEhSVU1wVjlsQk9aUThGVlhWTzBDSkt2SlNPKzVNcFh6eGRpaXNSVFp4VjFWa1I4ek1sMjVlQy9QRU16ZDgydjNjZWZ1OUN1Ry9KdHI4bGlvckV5MzdhS01tbmRSc2xCYUN0UUFPSXBHQ2pYWkJvcHFuNUpOcG92OHhMVzd6TlUxVzNlVHlDUXRVQTVGNVFiSGVkNFhZWWtVaktOSm51dkJ0ek16TmtqUVI1M25EVlpGdDQ5OFhaL01tNm9wMStVVlBXVHc4c2VxeG9Dam1FK2dHeXdybDd3SHlYeDcwUWtwNGR3d3VVSjdHcEhSZjZYRGFhbEZXbVhpa08yL0t6ekNJRHU4dk5YWC9KYm1DTWJnaWgzSUVIRHhSeWlsK05xSUZJNEpxTFpxdVFjZmxEQnhwemwxOE9mS3cwRm9udWUrTjczcmh2M3h0TGJKU3R1SDZON3E3dWE0czNiUzN0VGNVTU5TRHBzU0JSU3Y3Rm0rNithYkc5R3B6VzdWaDBMSjdKRldjUHo4MGR2dkh3M0ZNTWhJRytFOGY4bkQzdHZQQVdYa0F6THF6R2xLOXFRei92aHJxVnVaM2N0ZEFwZE1zRUlBRm9OSWJXVGNneVV0ZWxoc05pTUdkUm9jY2FRYmZmbFpVRlR4TmNmaGJMS0Jad3Ezbjh4eFQzL0U0aDdOdSt2WEswTWpNNTZhVGlZL21rWHhmamdXQ0lhTWxzSWk0YVFVMXIveitMSzR1aFlFTDBCZExGWWlKYm1ZUnIrTzI2YXhmOEpzcXRYYjZJcEd0aFRSWVNxVjJ2VjMyQmNaOFE1QTBTaUdoK0l4Sk1tZkhVOW5RMkc5OVJ5RzZOKzRLcUZDVnZxK3lwWkZKeE14V01HSDR0NG5mMkh0eFR5YzFkOGVvclpyVnh3NHBLbXFabzlyYnMvQlZ6bmZoV1BkK29EQjJiWjlGMU9yaHZxeXZnTWVQWmNoR2plblJINFhDOTU2UDUyL0tIYjFQNHZCaEorK2c1R2hRRkxlMnFrWWVyUVpmZTgrcjN2UG5Wc3ZhZW9DM285SndnL0llWVBwZktzTitsNjEwWnVpY0tYV2diR29JTzZIUFRZd3pVcnpsQ2Jid0dRdnh2N3FBZUNRcXpldmt0UWY4N2FpKy80emVadFA5YnpONGw3VWtyblFjMk9xK0kzbko2TWhJSC9IQm5YM2l1UDZxZWExUmQybXlUdE5Ddytsd1p1L0VrTjNrUm9KUGpXM1dEVmdLM1ZtdC91cHVVM29yclRXL0YxRW1hdWRISlpWZDk5K0tldFBIZnZDVjJNdW5UUFovLzUrajZ0TnN1Y3Q3dENwOS91NTd1YTljUFI3ZHJyYTlkaEJ2ZHNQWjN6dEl5R3ZlUzdnL2c0Mnd1QjIxYm9MYlZsM092NW03bFhvdDc4ZEw5Ty9LVXBjOVRjVDNQZkRJRytmek5PWnRsQVNmdnNVbnJMTk5pRUdyOHorZmFMWlJzeURvZTJ5MlViUWhLT08yalRGeU1zcURnZFBHamQvbDdmVmZmSk16djM0MWpUK3pWMVRQY3hzWnFIMzkrZ3NtZGJqRHcxbG11b0J5Z2RuTnNTVjNSMXRjMk5yb3dXOThFc3h0WTFQVlhIbVo5cTlxNEI0RFRDZi8vaWdEdDkzcXIzdHFIVzduY0ttN1QxVjUvR1VBalhBZGtoSHRWS1BTcVZTaDBveTl1VzRvcmNEWGNBNTQ0dlJtRDdlc0dYSWRHT3pSUWNsRmdpSzEvZVdjZ2gzeXVaa1NmaktZUElUdXlRYzhyb2xBVCtGYkwzWG53VURwNll0Vk5uekwwL2VUdE5XTmduY2NmbmVQaEhiRjlhdGhpejM2OXUwN1dveCt0czY2VFVlVWh2YUllbW15bGpBWVRaM2JGZEdmMzZBZ1NjaUpnNXNiTHkrUEY1WEl4RS9HTGhIcXFaZy9WR3hPSnVPRVRmQVB1dHg1Q3NtWm9vVkxyd003eGdPcERaMVdKQ1BIRm85djhpaTRRMFNkMlkraDlEL2lXVDNUamZwL1RVb2FjSXdJdEgycm5LRHU0NGE0KzBXVWlBaUNIc2NYOHIvYlRHSE1QWXhJTzVCT2pMRmphMysvYXlQWU9uTDZwemdjOWNYcGZkdjNOVGF2WDllcGdsTmZtUVBRMlorQzY5SEpoY3ZzaHhQVjRpTFJhMytyNmdkbnNoSWYxWHBLczlzcTRRR0FTb0FMVUFCc09yWndudHErL2svQWNwcnNwTjlaWmk4b09uVmpKNTRpUFRHUGZ5NE9RT2V2b2Fmc3BpRGlOL0JBaHhuTmErelBEaDlDZ2czY25CdUhwMDRwMlpOZ2c0dGkrT0gvSVAwQytTdVBTTEhIN3VBTjA5WWE1WFpSbnlReFJnRldtR2hDWXBpV3FkNlJPUkVUdWJHVUVYS0hkVkJ6MEU0QkpMRU9TVGVlZTMwRVhoL052MXZTYzhaZ3ZxV3BLMHRmK2hzOUhwRjFWakg1TnBuVkowUlhSOTFoQWJwdUtTdU5WRTZKK3ozNW9YKzRoTzhjci9HdDRmdTEzemQ4VlpIU21lSDErZG5iMzdHemVWYnQrTWhDUXRUdFV5UmZ3aWNyWDFaaC82L1Z4V2VEbHI2dEp5RW9xZCtpNTlrRkpDSThsc25GVGxYLzlvZmhjekg1WGpDZkNLVUgrTDI5SnZwVVFJY0FyN2IvQlFuZlBybllVc3BxN1h2S2M2eis4ek8wQ0dGMENOSTd1bEJIdU1wWDV6UXdQSFFXRE8yZmdic1pLUFkvNzFOcFcwYkdVdXRtc1dqYVVaTUljSXorcUxHS1VTMTFZYlA5dk9pQTd1MEFTdFh2WnZpdVhhNUU3Y24vNkdmc3p6WnlkKzFPZ1ZMaW5EZEVXQVMzS2dyRFllUWxlYVArMFZ3WmNraFkraW0rdS8ybnV2K1AyTnkxeVNhNzl6VngzL3dmVzF0dTRFOWkrR2I0WFZzUGdlellzV2Q3dU5teVo3L0RZU3ZkWmVLL0wxY0g5N3JQd1hyY01nKytLdE9SZmkwTHpXSjM2LzlXUE5ZVWk2bFEyWi8yWVhrMWRPaVBzd2dkMkNUT1hUbTNPR21lU3hlbXpGT1RKK3BPekZkWE5ldG9WUGVoNnd4OVJXNHdZU0xsWm1EWFV4Z0ZieEpZcG1kRVdqQW5MVmh6THRoeTczclQreDJramJBUk82ekg5ZEFCU3A4TWJHLzhmY1c4Q0o4bFIzUWxuNUgwZmxaV1pkWFYxSFYxVmZkL1YxVDA5UjgwbDljeElNeTFwTkJxZHRNNFpnUkF6MGtnV0VvZ1dDQkJJTm1QQUlIR3BCVEtJeXg2TzVaQUFOUVlidkQveldic0xSckQyTW54Z2YyREw5bmdYMWlCRXpzYUx5THI2bUFQd3Q5SjBaT1JaR1JFWkVlKzllTy8vUC9uY2M2ZWVRMC92RlJQV0Q4MUFQQ3dJaDhYQS9LR1ZFUGVLaGYwMzNGQzg2b2VIRC8vd3F2L0dnQTBWOUdvR1BZN0htRjdDamxURm10cW02RXNrY1hERStBK3YwWG9YY0xKcnZFNmxpRjhDZDh2QVF0NElxbktWYWplU3FyVXFIR3JMb3djTmRjRXdGbFRqWnRYUWxBWGJ2dTAyMjE1UU5FUDk0U3VtVHR4NTdKaGNuWEplOFlyWDNIYmJzVHZ2K0xjb2MrenZYNlc1Zkk4ZzlQQ3U5cW95SDlOdVVSMWhWSmFucG1SNVZIRFVXN1FZZjhQSUs3eTNEd3lNV3pjNDNpdkNqMVJmT2JLNWV1ZEliSHg4NEFkdCtVZ3VJcnptdmJpRUY1SmVCakdOWkdCc3FBbFFSak1xYXJTT1N0YWFHc1FRSWxGRGdqeUpVU0xMcjNrc2pBQWtDYjRXSy9lc2FOYnlSMXdEUUo2TXhlSnNJVE9zVDE0QTY2c0xPTGtnL054MDcrSmlxbnpjTFdqaHNwMDBmTVNIUzluSkxGdlBUb1l4bkVFTE9BbXpQWEIvem5BTHMwWEVGMVB5L0ZRTzN3L3JyMVB6L1RsQ2ZwMXpMRS9pdzJVS1BIbWNianIwcUliVXpCQ1hOdUxtUnYzQWlHUVVBQjl3QTBlcVJsaFVKeXVvTVp4eXplajhSazk2OGM4UlVsUEtwOGNjc2d5UVRZeU5KYkprVGNBWis3U1N3Z05uK0FSZEcwalJ6ZTJDS09CL3kzK09lS1RnKzVwWHQ1N3dhU3cxOHdnSlZQdzl6ZER0TWdmM0NVMmNiT0JzdHJFV01Jb2x3U3VCV1pPZ1g1cVU4UVZDRTd6R0RpV0RQZHMrUnloaDhWVGFKSThGT1JoUE54Qk1Pbm53TUNRL0k5dHNkZnp1OFdwMm5md0hSNFpuOG4xOStabmg2eG9adE9Sa25SeitpelovTkVEekE1NnVxdnFlTSt5aHQ4cEtQT2dKbDN1Q3VDS1RQS3FUZkNPMmpJeWZJSk9CNXNpZ0RwOS9zYkRTS2J3MFNRbi9xaEcvRG0zb2lMaWFyaVVUSnM0NE1UdFZTSkJraTVlVExCT2p4d1NldjVTYUlQQW1mTzNUMUc1Qk4yaXJLanB4eVJqWWZYRDNBRlpKaXJNWHpCWTFPS1FQZG9ORTFEWFdKVWxLWmFxc0dzck1KVE1xMmc4M1gwcWZjU2tmSG51YVBwcHVYdUhIOUhoZ0pib0hZUUYyRUI1UW5DM2lmNEdyZTRHWjJEaUlmNk1MZnpGU3VsSkpFM3JORFJ0NkpTV3FtenIrUnJxYkNNMzVocDRqRlZ0NjRnQ3FSTDVzcURZUjFGb2tkUGtHSVhCRE9scE96TFU4c09ZU29MdUUzN0dIN2U5UjBaSmxzTXhFeEV2aUhZNUZxUVdxbFMxRS9sdTVlcDFvTjZPNTU2ai9HdGZ4amhQbjlZWk55Zm9jMys2YzNpemlzbElqZnJ5dkVqNlRQTEhUSFdUdVl1NW4zc3djai93UEtKVm1ZNlZ4QlNoc2FkUWJBOXJ3Y2cwc2RyNHdUaU9sL1lDdU9YbHhQTGFTYmtlTWV2aUlLSUdLSmhBd3AraXMyR1N4SzhPS1hWQnJQb1NLZUFXeG1VRkxWRjllb0NNTXl2NzZPQUdYQUpmVXNIUmc5K3dGbkRLM1pkL1ZLdEJTUWNrWFlyd3VidG5HSi9pQnNsM1NIVTF5RTEyY21VMkk3SzkvcEpidDhnQSt0WDJ6cVBNeExOTDVCdSs1a25ZWnZmZmRVZFZGdkdZTGRQMHpRY2VvY0xubHZub1M1WDNIRElxR1RTK2RTNHNzVjRyL1BzOHZPSUVpMjJtN1Y3Tk1HLzl4NXJndEs0R3p3UE8vSHkvaFgwd0xCbStvanFIMTJydnB6Ukc1MnlHNmlmeHFubzI0bzdydzZMZkNVemtLVklpR2dsOXJQZHJUaXZJMDNTUy95SXJzRjNtZWJ0Qm5ET1A3V2tiN1B0MTBmWjlsdjgvekpHMzRueXdUZjRkTldOdVl3OUk2RTVuT1BCTHdHZVhCeHdHczZ4UFVIU1ZhYVorcTVhRzVTRDR5ZDljUUlSdXRrSUJHd2tZS2J0RzR1aEFYZnBORHBPWTRyN2pMdEh2U3ovUnVQalRheFVlbjBUUTVqWGVUL1ZkZDFaL2t3MDlvN2ovRnRYZE9sNzlVK2hiT3VocjZBaWZ3bkdaaUZaMFh1T0hSZlRWYzJ2eFlmdnE2NlJwUHpoZzZjQXVPVjYrWW1UNDRPUkh1eW5kMzV6K1pHeHI2WDVCcHhOVXNNeS9oOGw3S01MVkk0UUFtSG1KR2FINnc1WmFZU25pSmdpWnZlOE9uaVFZUndlR21NQXJXL3UrYW5wNGFzZ1BYNzhta0RKblhPSjFEbkd4bDhwSVFDRkpmT2xzMlBTTTlZUHU5dVdLM28zQWFyaEZPZGZKOTBmbXVUMm1xcU1aMEp4WFlqaWxKUE12SE9abFRaSWNmQVVWclRFcDI5WTVrOFVWYVRMZURkTkZWVkI1L3h3cXZhYjVBTGhtUjB0a3JvL1dUTDdGYnNVNVAvQ2RLeEZVQmQxaXVIVlFTeXpXdWllVm9TZ0tONXdTaHFWdk5zZ0wvcjM0YTl5ZTVQN2tIUHZzOVZsSzRQaFpUQ3FORGFlWEhISWZDNTZpKzlCalBvWG1IUlVhaWl6Unh6QXhQR2YwalJUWFdtM1NkaTVESWZhenBra0w0T2FsTUZtY1NUQWJQOGFBakxsRFUwRlZXVEJjck9CNWdLZUUvSWUrMDIzWEpVQ3A2bmFpWWtLT1BhWllrMzhnOGg3VjZHS0VqbitUdkxpd3NMUzB2TGFGSFF6bHljejhvY0xNY2ZrL3VMMGg2TlF3eGwwZVd2bVEwdWlnU2ZzcVJsaDF1SWJkdzh1UUNlalFhR01MRG5DRExGRUN0c2FVRWs3U3ZSMHlKMURlSDFzTVFNd1ZXb3RMNUZhOGhvelV6N0QxbkxNZk4wWmlXaThhY3M3L3hhQWRwWkVPL3ArOXM0ZGJySXRFSjE5S1dXOStXK2p0cXRoRFNkeStNamk0dXpNOHZoT2ZmYk8zRzAwdmk4VXVJOGZUOEc0NXI5cXZlRmg2OWhSckorbjJyVkNPdVFBU0FsQWppVWhPcmxxMEx1TGNWZGd1QjhVK3hsZDB0UDBhN1czanZ5NU5JNUMzYzhaTFg3L2xUNkpveDJ2L2VhdUVPcVAvQTBQaTlFK3Qxd1hjVWQrT0xSQ1R3ZTNJLzJPQ3c5emQ2Sk45aGR5MlE2S0d6TTI2M3BJTzFJUTFuT3cwcTY2RVo5bllhU0lRb1pwOXlyZFd3MUhzanJ0L0dCOTQwNHRmYWNBVm1zY3dCcmkxdCtFSmdEZ2FXRlRKYnJnalVEd1RZSVlGcWJhQlpWZlIxQ2plem40TEZQSlNLaFFkanFWVHN4bWtkK1U0Vno5NU9VSFY4cEUvZkdFdUZMM0lpOXdpV2FTOFh1QVVPcHp5UDdwQ0VOMVMxZ2xaOUEwRXVlRXFRYlBvb25UNTQ5REE4RGlmVFJpN3hYZ2hiZjI4aVoweW5lbGoyOTNuMUdXanZaMVQrUGtHYTFQVkpTU0FvbTNTdEgzeUJsOXF0c1ExRzFaWjlwRVZKc2dxUmdBYXh0Y3hHelZ5bkhVbFl5VXpmdmhBQUZ0NFYrMjZuaWRGajcwbGs0bGlNd1VrOHMwaFNXY1lKWllSYjk5U3ZmMDVrVWtodXBSdElFTlBLTDdTeXp5M0VNNXdMSFhPSjJDVmRMaE9uQVVYcm5qZ2VyVXVjakJhYjJoWmtHdm5HZWFYSitjTUNCbUlKUyt6VGdGVmFxazExUUs2Q1dJNG4vL2FnVXNDSW92REJqUUJOTEtIVmFId1pCTytpRDhZNXFXbE43ZUU1em1VNXdybERYdUtkNFRkdVVrMmtvUm05cUZmMWwyLy9xYndIalU1eUNqZTZmWlI3WTV6bCtDY2JkbGlKaTdOTkVHN3VxK0UzTkdTcU4rRTc4WTNGVGR0L2VwR0N0a3h5NUVZbGt1L0FMdkFFWStDKzNRY3I4aVVxdkVTR0RsaEhpOFJJY1NYZWo3UkM3a2VmT1dIMm15ZE1OZzJ2a21iSHdpVlZrVTRJcG5CQ1Vzb2RkTEJ0TmZ6Y3NtMHZtNVYwdWxKdzVXVkJXSmJkSTBTbGlhS3NHcTNMaUVSQSt3V1NPM2lYR2JScXhLbWR3M29mWXJMOS9SdjcrN080cHhXQzRQR092ZkJ0SGJ0SWhwMk4vVWRncHhBY09jTmVFKzhZelRBL2pONXpEUmJJWWlNVGVjUWNwRjR0djZhYjVRNmVSZm9QNWxhSUUyT2V3dU53Ui9uZGhtWlVhNGFmcmlxdHRPcklRa2NKblRQc29kNk9FaDd2Mkt1dktEMHBPMU5IVnpiTDNuaXBTa05kOHhxWjNCckZQTGxXZlRSbElZZ2pTREdUSk1LRmlPRUY0aDhpdGErQVZNb3U3WWpnbDBnSk5HRXRrMFFqVjN4NmVhRkNWaG9vT1RvMTl4RFVJWFF0SnlYTVJELytVeS9jSGFOK1Y3SGRneERNSlY2d1I0MXIrSFcwdUhyUlRsR3hPY1Rma1RDVHZVa3J1SU5IV0cxUithTnhIVitneDQ4Q01PRWpyT1FxbGlYSGxabU5saCtHNU50bmZXdFQrQWorOGxsSm1Oa29PNUpoU0k2OGNVYVF3bEJTbnVjVi91bzR2a21KWDQyekVsWU5ycWFYWEkyekRSK2FWdXoxQ05iSzlweDk5VzFsUDVVOHFJYmlHS2lJbGFwWEpXaExZNlFTdlBXajcrdEEyTzRhaUtUK1JqR2o2eGx4bzcvVFZoM2JkbFI3NS9xaCtLT3VBZDgwSkxsQ2JGUUlBbUUwVmxpK3EyWUNVS3RadTZzTng5ckNJK3ZzZXV0YWJjMUgxdi9vR3BmZjFvZ3c4M2V5VTE4RW5nbkZZN1R4OUxoeXJLaWdqMENMRmhmVXdNTHRoeHQ3QVI5YjdLRE5WcVMrN0RXTjlya20yMGNvUGFWdlpTNldhZnZJRjJlK2hjY2s2cytIQ0JaU0htSTNTeEdTQmRYR0o1b2FDOWN3eWxXNEtBUStrTVFpK3ArbXVXVDJtcWNaRXdKZEVYSDBPZEhObS95U0lCejdmRTdpRjJCYjVhVS93VmN0bVhCaEw3NlNPcC9jSndoTCtOSzdQaC8rVWxnZ21VbWhnUTJCcXZpZDloQ3Rqc1RSRUJzU3dTY3F3L0lKbFh2bzZuaWsxT0l4cWJYZ0VrVUZSNnN2aUVCMFZkQW9Ld3Urdi9HQTlUNWVZdkZ6UDhSeG4rRWxoSEQyay9ibHN6RlhrQkdQQk55K2U0NjRhWXBuakR3Q0kyUWYzWnRPQ1FMaThaKzRkVnJBQlZBS1diS1oybzRQOFRhd0sxNTFBU21aN3JrNnlleTZRa1NLME9iZjlHcGN6eWxtbkl4N3NOYlZvdEhvYWxpaFNvRVV3T3BZaS9WakU0cWFRYWpVZEhRc25sYnFzbHhYMHZId0VWaU9mYXhlM3g4KzBqcUtpQS9Rb1hvZE1kTm1USnRURXNxY0ZqT255UnNkbkp1YlcvTm94SEdCdjRWN3FKOVlDK3lnT1dXMldXZUZadEJaOUc3RmZKdXRGcjEwRGZSL250OFVYa2pFeFM5dTR2R3V3bC9EaDN6akZQb2lRVnEvc0hrS3lkZFFGSVNONUtVMjRsRUlYM2NOcDM1b25lTU4yZjRYNkl0RXRvZTFnVE14UkJOT3lValFxNVJiODB6RUMzMzNqWjI4MEh0OVVVTE5SVytIUXNnQkh6UzVFQ2R0Zk5EM1VESkcvcU9DOUcyS2hiQmlyT3NsRVZCbnh4UnBCZ0N0KzdMcmpuQVJSV1d3NW11dk83aUZMOUgzL2ZicUVvQjgvbXM4YjIxSFgyTk1NbU1URHU2U2J5SVNwbGR6SWE3WTVmQjR3WWtSL01qWlhwL2RJSXRZK2NqRlVxSjhTc25ubFcrZkVtTENLUjVyc2ljVkpRelBVQWJaemdkQkhoZkYxalE3bkVkTHNod3V5TFo5emZvRklEWnE1cXRFbjArQWxjakZZaDlIYVVVclhIbHF3bTFpQllEdTVCTDg5RWJvMDFUTm5Tby9qUHUxaVNSK0F4NG9UQ1FMQTlSS3UvT0FtOEw3aGhPZm5wK09Pd2JPcC9BTENlRXZlUHdLK0RvNVhLWkdWYlNRaVlXL2lPbG1KUUJYcTZCaTZqRWt4eklSemxEVEw1TmlQazIwKzJNMjFCVXNCZFNhbzVtMElzSVRPdDgzc0liMlI4U2Y4bkRrcmZBdVR2MDNrdC8wUjNSdDRsMjBNai9SbGhjYUY1eHEzTUszUDZmaGkwM2w2KzNNWHVaSzVpYm1WYmo5SmJLMDF2UkNCTkFkQUdacTJrQUFzUVRvTUpvK01aUEVJaUMyWHJqQVRZeERPY0ZFTG9oUVZNTGl3QlVMVUdvUTF2TkZJcmhEYmFDSGVsNzV5aDQxN1JMR0JyWDR5bGRHNUEzQTdMRGVtVXV1b3h3TjRUK3dBdUY0NEtJRHFDdGlmTGo3M0I3VWNRWnhEYjZJbTZNbmhnODBqbEJLaU92NEpyNFJhZHNiRzZ5cWpRYXRBWDdrV3EwYzREUGV5b093TCtFemEvcnI0aWMxdklyUWN0U2NHOUJIUG9JMk5GdFh4ZlBzaHorTVNPYnNWK3ovRGU1WmVVVTAxeUhDNlJINXZIYStlbFRJVWtjdFJBWHM5TzJKQ2llczVUTGI0Ym1LYm10M1ZuMnM0MXo0enZaekw2eC80UmxPcmVQTDYxVFB0Vnp1YjFpdXdUT1U2OXZ0NTVCK3JsZXVMQm5GeTlpS2RaTUVreVp6MUJqRlRHakNxelU2dTFTWmtMeU9DUXQ2NmdwTEFYUmFOZ2NzVzhYd2VRQ0FVWGpVVjFRaDltRmhZYUU1QyswUU9Ga1U1ZkN6alptSWx3VUxBVGRjTWZ3dUJaNUJ2VVVsWmk0WTd1TEMxMTlvVEYxd1dXUFMrN0dBOThSVzJ6VG0ydW0xSlBCVldrVlV5dVo0MmxiS005Ry9RY0hlUXN2MTFrYXh6cVE2NEFLOWxaYm5MYzNpck1DZ09oY1BTZ0tSdGM0b2NFYlVzZkRyUFA4MWRGWGs5VWI3N3RlNE15R1BoZC9EYzhUWEdyMmIzSFFWK2hyQmtHY2oreEdzK2U2RUZhYkoybnB2UmRENkNDNW9lMGxJR0VUbkIxUEdMNGkycjNqRDhNdjRGWDhrdDBxeVAvcGVtcFlpYXhkb3FkdFh2R2I0Wlo1L1F1YUZIN2QvVm8yQ3ZpQ0xUWHdZOER2b3dmMjRTbkN4MnNDUzRKWHh1RHJSRHJzRk5xNWl0UmJVcEFEbVBncUI5ZmVwUGVsdENheTMxQVVoOFdFcFowL3ZWYVVQTnc1c1M0ZnZ1T3hEbHoxMlpiSHZzYjdpbGM1WUFmMXhHbDh2Q0hWOEJiNWUzVHR0NS9EMTBZRnQ2VDNoWGUwM0ZNYWkrZmRaWXE4REZ1UnR6RFhNclhnK0NhSkZPdkNHZ0VnYkVwOWRFU21zUUsweXpGWW5hd0lXV2tnVXBsaXVJSXBLM0kyaVpjQjRoVUlvQkp0Uk1CYTV5NHhoaVFzQ2M0ZFJKWXRvZGdwdDlkT1pLL2ZzSHBDa3lqWjNVNDhnVkI3YTUzeklITmcxS010QmZqb25vSGNtOXd6UGNBaEw4Q29YdmlmS2JCNmZJbmN0RldhTC9mbWlWWFkweS9JdFhZK1hrMTMzKzl0NjAxcWhGQXhjbUJENnU0VEJnVjFhU3R2ZW55cHZrdVh0Ri8rc085OC8xNCs2MlVJdDc5aVhEMnozTHNaUEZEaVdSeitLTXZzZGNrOWZZU2FmR05ZNUJUL2EwcnhSYzlLcGFxV05ibUgvdmxUVzNkUW5VL3NnL21qcldLZHhtUnl6QWRaL1M5VHVJb2t0VDVuSlNydnpOUllCbzNqU210aUVFcXVBUjJkcHNqWVdHY0RBUVlCSWp1ek13TzQ5bnlaMTFNamdZbDh3V3lESi9aV0hQdkJRUlJCd21Rc0R1dzd1R2lqMGJ2T0Y4TXN5ZVdmVEpsaHB6KzhhR0tTMTBNaFl1R2o1bVIyUVhMRDk0cjNiWkJtWHEzOEtWd3orTjlYdnpwYmxuRzJTU3BVQk42MXBmM2c5L3FLSFFBdWlQb1o0WUNQRXdUakYvUThXY01CenhtSWJMRGNRUlZHdE9hWGFtRlBSOFdUQS9hV1NqSDBDLzhXU3lpZnczMTl5a1FpZWZTYTg5bXN3Skh5QVc1TFptSEgzMnlCRmRTUEd5c2QvRDZmS0V2YzRVZWNlRmFSbjBWSzR2SVQvSGwvOVh0UnlqOFUrOEVZRFFqdjhEckJvQkJXOWhXM0V1SVBCcENnNWdqVG1CT2huOEdMZlZKT3hqNnZ3WXVySDIxNHMvQkY2Qm4wSXY5a0RLMTR0WEc2K212d0VmVFZBVzM3MkNWUmZXa0wxeDVtR3J5b1QrUjlSbi9DWE1YY3hEekFQWXoyaExhb2dHbzg3MWdkVytpQ3ZGT2RxWnp0ZkJXVzUwUWlOVWIvVURFdnc4azFvN2Z3Q2daOGFwUVA3S01Yc1VwNWI2V2tOeWNKYUIrdjZxTzQ4NndSNDJHVGlXQmY1cndMM0JWUHRQYzJnWExSYW1FTUxqV2dHQWxuVmpHSlFwRWVhajdxNW1idDZqV1BmM3UzZ253bWNrTkpsTTFaeWtSTjZWWE9CTGdPY1lpaW54aklTY0gzbm1YNkN1ZzEyc0NhSUd6R0YraDBBWmxOY1N6dHJaM1FFdytjczh2RTNUdnltVC9meWhoQk16azBHZ3NIM0NsMkIwZTFuL0c0ajZIb3dBUFR6L0tFaFhja28rcENzb0Y1V0Z2Vk1SaGRsdGhjcHIzalNVYmxrb1dkeXNxZVE1RlRuU2I4MDYzZDMrN01sdEljaXA0Y25ybFowWGJsYWw1OFVvQ0RDazdJZXpTRmZZY0d2Wklpc0VUTkVBeUtMVmtnY2h2bWlYSWh3YTRoZEwwdkM1YWZLRlFvT2d5S01HNWhIQ0ZvWEtFd21zaWhSUVhNOWtMMXRlc2ZsZ2lockFoLytpVm5Rek1USXRrUzZhL0xneXdlU0JWblowamV3bVdYSHltL25ySERmNEs2QlJHRDJaa3kzVkhWZjJIRmR6NFRvcE0zQVQ2TTZYWUpFZStCaEZoZCswdFFLWm1MYlNDSjlRYmw2Y0NKdEZaVEtHTXR1SHVqYm9yNmRFelJaRFA4UWovQzVEWUdaNlRYZGFna2VKMHoyT0JuZFZiUjlkTjB6a2dVb2pzOFlySkdYUmxBeElpSWovZ3hGeVpOd053a21hc1REZ1JnRmFoTmJXRUJ6QVRpSmlzVVdwV0lWLzFXcUUvai9TclZXeGJ2VjJrU0FkNE1KWWhRTmZPTFd4MXFIK3EzOXRwZHhIN0RaK29hTUxHYzIxRm43QVRmajJmdXQva05xbjVVSWdvVFZhNys4TjNINytHZzlxOHI5R3piMHkycTJQanArZTZMMzViMXhSK1E0MFltL3BEbUhXZGxRY3ZmTVpYYWc2OUNPek53OU9jV1EyY09PeGlxQ0ZDL0VKVUU1b05zUFBUcW4xR3hSS2t1aVhWUG1IbjNJMW1WUjRGbVI1YW5NS1RheERCMHNPZmZqMldVM1JNcEdjVWx0M1ZyeWcyTFZEOXhPcERsbk5SWFJhcDJ3Y3gvZHNkK00vMVhEeGx2aTJBV2UyMFVYK0U2WTZtR2xSaTBnNnlYb3V2MG03dWZVdG54UlhPSDRCWllMZDFLWXQ4T3FHVDRuS1Q5cmhqdnNYQ05ING1nb0ppR1VlUmlQNkZPNDNKdVppNWpMd1l0MWRkbWpTS3hPSkViQWZZY3FBRUl3Q1FqQzhOOEVDWmtCUWdEUkI3aWtkaTR0OFBUdktQb2l6KzNIcFY5b0xHL081K3E0L0VzNThsODlsMVA5bkN0MGozY0xEcEpTQmxiaVhUZVd5NjBvL3p5TEg4Skh1SFM0Qm5LNXd4RFFRcCtRVzh6bHJrK1d5OGtyQk9GTnRtL2pmeC9PRVI2cmpqYXY0M0lmWm00SHpKVHphWGVDdFFPekgvZ054Z0VodzhjQ0hPMFhIUWY5dG9PNEs5RHJDSkZhRFl1clRadFFRM1U1MndkeWVWZSsxQzNxSWlja3UxS0J3TXF5RUxoKzBoTjBpUmRNeHpJRVZzS0hWTjNRQlYza0JVWEdVcmZNYjBuRllvTUNOMGlZVURLRG5DcWQwN2UwM2QxY0tOZGpQS2ZwbkRVeFBXcHp1dDVuOUkwT0dCd2NVcnB5R1lVek5OUW5la2xmNUhoTlp3V1g1M1Y5YnJmYmN3SGZReUoyZW5oSmVGUm9ybDAzdjcxK29qV2RSNTJ2U1ZkNWx2cnFlek9GTDRYNHVmRzdLVy9sT1JUOHY3Mkp3M2Vwb1BPTjM5V2dzR3lPRjh2TjhXSWZjOU41bFFGNlJiVVdnUnRKQk55b0FaeE40bzlBa1oyS1ZoVEVoallUQjJxU3N4WDBxUlRMYmtBY1N6Y1RMbUxMWlJhNWVMYmV4TEtia1BBSTNhQzJFK2Z5QWNqNGtkOWsyV2d6R3NlM0ZRbzRpU1BFenJBOC9rT29zVzAvR2ZuSXQvclpGSGo4bjA5ckI3N0Zpa0FNUG9VRmk1WXI2VmxiL0RWWmpqdWE1VVgrS0xmRDRUaTg1L0M2WVBIblV0eWZ3cjA4a3Zqc1VZNXYzTXhiZ3M2MDRmdlM4dXcvdjlKUTBjSWk2RXVSMkFoTlMxeGZ3Q3NWQmxtQ2NuaTI0cjFoSE16VEVoYzRJdExVQkNmQjdzUXNwQ0x2dUZpTThoV2NBeFAyT1JUNEU1ZmlzYVNRTXRtNFZjSzVTNitVZENHVGpxbDlYUVllUGhycnZaMXo1UGJ6S2psSGxoR292UjVzeFUwd2o3TVY5SU8rSUNNUnQ0WEtZNGtNeVlOMFJlQmNTb1Z5c25DUElFcjhQWUljTGFtMDRSYnJXSlBNWUYyOGhtZTllU0xERml3Mlh3V2RzaHU0TUd0QlpaVkRRK25jcGtVbzgrTVYvTVpsM0FOcWdPNmRXN1pISThhb1ZJVEV3cHhwSG9TaUgrbmwrUExSNDlNY1Y4cmR1TjBlZlMxZGhvZ2dURGFmY1FvOERKSEtMUEdaQnQvc25jQWIxaDVuM1p4dHNMdzZFVG4zVStQSkFMVnBOdHFOYWk1WWFHKzJjSldVR0gyYXZ2NDB1RTNkWDJSVmRzYS9Dbjc5QXBLUHMwSlZGVWtEa2hMbDJvdEoyKzRVOFh2YUtmQjNRT3pFQmJ4d3RKYy8xV3c3UlRweUpDcWIvVElFaFd2dmUwV215bXdFRzBCdE5iUE5pcmpEQWVDV1B0ZEdPeWx3bzV4QXlqVGRsbjM3MlpycStaVjNrT3hYT3Bwb0gxcWppVmFOSnh2T2J6eFpZYkU3VzJmYTNoUWp6NlgvTExVeHphNlVsL1l5QjdDdVFGYVJ6dWQ5eXdBZWh3ZTZ5akJvU0JHOGpBaG9jK0F5QWZSYVpRbFBmQ0F6NFU0bmxTY25KRHdvNHFzbXhDTEUzVTRGWjU4Q3U2elpySVduSDQ1ajR4N0xjNndVdUZVUldicVpqbG5EbnQyVE5OaC9GTktjcW9qcXk4RE5sTTBZbHVuRmNvOGdscGQxTzZZcjUxUTlIN2ZrV0lXTGE2NW1LcEppeEozTWRDNlRWQ3pFWnJ2eFJLTm9WbnkvbWVCc1ZaWlA5c3BheitPSjNwVE5HWGpHWkNXV1pZVlZiYi8zTjlBNXZCWExFNTMwbGVlZ1oxQlEyQjNRenMzc3VaVCtzNnZ1Z3V5cWVXSlRHOExET2MwVEhRSDRaR2lTUk1KbGRmWXAvK0Y2OUxVT1pzczlvaGF2OUxyQk9jMFR0aVI4QVc3ZFdObFl1a0hiNzFkVzk4dnpiSnRWUEJPckdVYk9WcHA1aUlkVytORlJpdU03T2twQmZKdjc1MUt5eGJaNzEzcFd1KzRMc1Y5OXpDeXpqZkJxZHNMU2dPV3hMUTRWSy95VUg3cDZQbU9ycWQwT0lURTR5VWhxR2tLejA2cVV5UzBzek52MjZGbUgySTlFOTVxYW1wRk05WWhxU3BsckZ4YjZ6UC92ckJQaHlyYTg1ZnphRW9hb01vRW9oRnRJWEpIWDNPMk9hbWdMQWNzRUNUM2FveURkWjJualRhemg0RUZIVHlBc3F2RWlTb3NDaTdnc2xuYndqNkFCaVhldzBKUERnd1VmeVBpZ3lhc0lYTUx4NlhOcC9YODNxM3RGWGVzOXlBc0NmMzBxcnJKcS9MVllGeFNmZ2dQM2FMcHFYNTZEN0ZNaThXM2lWdFRUK2RUUzJVcDZMdThMY3FiYzlMOERQcjhybUVQTTd6RnZadDdOZkFRc3pzM0JMdDgyN0VYVzNlYXdsMjhiQUdtMDRnb1A4T3BaOXMvbVFYN1crMzhpRTFOcVNCRTFaUGpTNlJIZ2lJNk9oTGV2WmVGdEpjREwraFBJLzJRZFkzRGJwWXVVeTRHbXBocWVVTTNPSTJnZVYvQmZOZStaWGlNWC9vSlkxdHZ5NjE3S0tPdTIwZWYvZjIrbGRjLy9YMisxL3h2dGQwL3o0RDNuMHBCUjdCMk4zWFlKRDA0K1loU0tGcHpBL2kwNWxXb2xqMDZHZFRPbWZGNnJxOG5ZNTVYWS8xTUgxUUtXK1QvM2pLVk1LMnpNK0YrZlUxUHV5ZFBNOURlWEdmNTBHTVhHVHpGMWdoc0Nmb2lCVjV3aUFkOGc5MlVqOE1DcFlNS2o2QTFOanBqcWhDZUNDWVE2Q1RkNFNwc2tLQUtlZU5DZkxGbG9rNnhrKzdLeXVyV0xGWFNkTS94WTJpclloV0ZUUGE2YXc0VlJaQzFKbXZhZkZrdnBWUGxJeElxU1dseEVTd2syenNaS3lWUnZ6SndUZFVFUUM3YkpjeWd2MW9yL0RpMy9pK0tVbU1mWEpKQ0ttMC85TDZmK05WMHVmNDRDYkZ6cnhsMjZmbzRndnF5ZjJjY3c3aVFGVXlhQmxqNkpVNmNjUnFpMThCZ0ZjWExSa2tFam1veEdkb0tVNnpmdU50SHpEcTRBZ1RNVlgrT2xvQkNrOVBJZ2llMjNqS1NWSytwZVltRDNRRGJWdjdGZkVVeFgxcEVuSnN5ZWpPR3B4c0J1OUpSbXN1cm9jS25zOWJpS29VSU16OHROVTA3dkh5RVFBcE9ENVd5WGs4MDVYZUVCL0ppZUMzeHd3czlhcnBiSXhiS1pZazlQemkya3JHU3l1NFJQTTIxNFArQTNDUGdiZTJCZGNyV210UklLWnFVdkJDbzJobFdVZC9JUnRDanVlOTljcFRwQkZ1MXBSd1BhU05mTDBFSzRqT29MRk9SbmFaV21ScktJV1lWS0N1NFRpMmdSRnNUUUlnVFFhT1M3aHpWRGtTQ2dacGtlM0pKamVFUjdPWE1uODNiY292aWJsS3BUUVhrRWthamlpamNWVkljUnpQRlYzR0pZTGFtS1VnbUxBcmdscXdDT1BWWHhmSHlzTmdVZS9oVDNpN1l0QVl2MEdwUEtNSUwxSTErS1Z2Q0JYcmpVQ0VRUTZGMEF6a3h2SW43UnNHQk5zTUxlN3cvb3hhL0ZlK0txbDdVZTZ5LzZQUnZ3VGpybnZLY3dVQ21qeFVxNWE5VG85L3QvcjYrbnRLajdXamFiTHlWU2RsZlNpTWNHZTlLVW9kdUtzZW1ZMzgzMTlEVk9UWVYvRURHWWY3MnIwSmZ6QXJObUJsNTNMaFZQWGxSczIwT0g1amhUdnRCUDg1cTBnNU1VUG5NaEwrMFUyYmZqL1oyS3lsMnVDWE84OFpndHpRbnVIMXdvbTl3Yy93Yzc4REh4Y1JHUG5MOHlKRS9Wc2RRcGM0SWlHZmVTNmViZFFxcVl3aCtEYjlJVGFScUpsak1WZktYREM1cGl2YUJaalN6VHhJbUg4UXJRUTJDVnBsWExVOEFaNWdkTkNMbXBXbHNsUjBBYVdKc29OYm1VMnF0YnhJMU5ybTlXTnpvWWl4dkpManVWNk92aHV2SFF3c1lzeW5lZTdobHNuQ3JsczFuTjErZkREOUpYUjErSXAzTGRVYTBWTDBxMjdlWDZDbDNvTG9HVHNReHUrbm1FY05tRjhGYW9pSHNOaU9DRUU3cnFTUVlTVEZNc2pkQldDWDlnS1pyQU81eG9hUzgwc3JwQzdEdS9QdjBzK2hxdWl5NWdSeTFWVmlOS2VsSmIvQlFFbXRESU9qeTJtZ2g5NWgwcEFQejVMQ1NwZDFoQ01ZbTJKWXZDMXZBcmVveVYzOFhWdVhkTGVKUmNmb2FnQVpIa21lWDRhRDQvT21ZbjFLOEx3dkt5SUh4ZEpmN0YxRDlnTzVZSkFxWkMrQXhwcUYrbGphMEovL293S2sxUXAwazhORmdJandXQ0JEN0lOUUpSNDdQMmFDYStWS2Q5OXdHdnBHMVh4RlJvdnFQK1NkeC8vOGtycVJjcTZPYzdSTjhJWDNNcFR0RmhSVGs1R3MvVWFjU0VGenRpRjRMRk9oNGN2TmhkU0plVUx4elY5TGRvdWgzeGJ4S1p4Y0dqR0paUzJsOE02cXlEUVNvZzFHTFBMVWR2MGtHbDlJNzZ0L0FnVXE4M29qUndFa1hJNVNTbHJrVGNjajlBbjBKUE1BUGdLZUZDS1BzS1hMa0JnTkJZZFl3cmM5UUcvTk9ZekQwV3dKZHhrS3pVREgxdUtOUGNDeDdqRnZZQTBQTWV0Q1NIaDF0R21udnVhZU1OZjFRT2YvbVhnaWdLZjhrSXAxODgvWFgwdjlHWDhMaDlJeDdmampLdmh0bTRSWWE0Vm02MTRycFdEcElzbWMwclJlaEhqUWtkT3BFa2N1VktnTHNtSWpnTFBnSU9nV0F6UWdjekdZN1RXSW50OGpNc3EyRlZOQk4wc2F5T2orQXpJajdGcm5jRnp0QXJVTzJLQjdadlEyYWM4MlQ5a2dPdC9IRGYwQjJzem9XdjdSczZpdTlFSC9qQWtYY3IrQStwWFJuOFFKMWx1NExHai9qTlh5TS93cDcxaW44NElQRXhQbTdzM1hQWGZDdUw0aHA3eDFDZkhyNktiaEh6QWZuZFIvRWZpVVAvMWVubjhIZjNSVEs3WE14Y1JoRUVTa1dDWVRETUZzRzdRQkw5Z0poakp3aDlES3dLZGNPQ0FBbkhnRXFkQ0NvbUN4NFNlRklnUVVkRkN0c1B2a3VCQ3lQWVJMVlltV2c2N2FPVHI3SGZJc2xJdStEUWJMMDJ1VjJTTTkyQ1hEMWcyRUZCbDlVQlZhcjJERm1LN1A1M1RVdWJsbFdPWnhVNXh3TlB0aXB2and0VFNVK1VOZ3lOVHM4ZGM1Tjk4VzdsNWlQaTNlRnpWSUphdkNpR05ISG02c2xzMS9YVDFac3E0b0NVR2ZBU1l6MWpncUNwMmhIRFRXVjBjZTVtTGwxMjl5dHgzRm40dk00Vkxoc1l1VHlaUHJnei9MbkFlVTRoMTlza25oTkpMRFhJVWprOGprM2pXanBBVUZTclpEbXNRNklBc3AwSlFtS0NSeGNxdXVOcWdkTWpxQVVLVlNST2NVVERnSHIxWUhnUFdtZWRsdE5VbysraEpRRVF5WTRUWWpqQ1dmSWdvUzl4d3YraVNNYzFmaS8zVU13OE9FcGp4TDhDNTFLK0ltMjR5czgrSk10ZGc3dm9pWi9kRThHdUFPN0wvSTJHL25uRHpzU1BaT0xMZWNxa2tuZnphRkJTMU05Sm9xdnZDWDhhb2FabWV1eEZTYm5ZTGJBOUVTTktuUWI3aC9OUnlEK3hZWndtdU1vbUhzRnlNSWJWMnJ5dUNOU0tJNnc2OHZObDZtcTFyT254WmZRZHVxZDhGZmErdDlSeXIzcEN6U3FKSjFEOXpXc2NhOGZManBQb2w1MkFTWUlvRmxPbkgxMmxJSTNSMmJVNjFvaXZESWlwbC9qTitPQy94clZIOG5TdzR5QkFtQlUxUjlNVS9JS1pFenJlNGowUnF1VDlYZnN2eXdwS1RBaTJiQW1FbUhMMzdJMGJOdHgwRnlRYldvRSs0QmVWaVRmdmEzc1lmc1ozaG5LNUlkbGlaU0E1a2xrTDdZd2VjRmRIQUJERDZLZC9pY3Y3NzdqUGVrd0cxelQwWFBDTzJJcTEzVDI0N0lBVDJleTVRWllsUVdtMUtRdFZ0dUNoc0ZTREtJcHl6Wk5Hd0NZa1lWM0ZEeVNjS1pZcU5iOGlWYWF3UUNJRkFBUGZ6WmFEQ3A0SUpIRUxLMHJveDg2RkM1T2JwaVoycUpvYlpYY3EydWFYT2ZtdUM4VHcycDFkaGRoMTFyTUh1bU5CMTA5ekIvWjNCZjk0NmFYZE55TjF3dWg1Yk5PbXdYN2YvRmR6a3ZWRmUyZlh4cHQ2bmR0amZibGRYVHV4SW1KTTdPM1BwSytiMlRqYnlOeXBKdzhyVzNQNXVuSW9xWFY5Sjc5WnZjNjMzcUJ1em8vWS9nT3pzd3NYamU2b1Bsd29HQUlyWHI1elpIUlEremQ1aTlkOUlKRTRJRmlibFhHUEVTSXVwTU5ZZG9ibzM4MEU5YXVKRFYrdUZDRStrZ0xmbHZLMHladWRsd1p4clNJQ1hRTTdlNldPVVVUUGx6YVg4TDlNTnJCdmQrMzBITmxEbytGend4Y1BEVjA4M0YwTERnUzFicklqV3A2WDlieDlkQlArUGM5bVdINFlKSm5oVmhiTmxUYnYzbHd5TlNzbW15U2JHN3I0bW91SFBOZjFTT1ltdURucjFlbkdYbmsvelhaZ1NPNWdEbE1rVWR6VzVSYnFXUlpDWjFaUit0VUMwVy9zQVlkeVphd3RPSy9VbW9ZN3ZCNElEWFREOWVIbm5wSldMeFZaMWRPNnRUczBEZTlxWFJzVXZjZTR3ekFxZENQUFppVk9vUmVFMzdxVFU3a0t4OUVOTW8reUFwYnRXUHQrbXhXUXg3THQremlEQkU5bHhVdlZOTDRmMzk2TmY0Q1Rzck95Z1IvY28xZm9SdG5RcFRVdWVQSk9EajlYNWVqbTk0K3lySWNFOGpqOE5BRS9ubXdhKzRDelEyUFR3SC9UeGZKakdtdGplYXlQZ1RVQ1YxWkFRaGVBZUUwS3NOZ1dGR3ZGQ2FrWTREbHhndHVDZ0pwaVNlUnZFa1FVQnd5anVDamN4TWQzWHpiZE8vUGptVnUzVGwrbTdMcDA0Qi91bkx0MEYxb1dQeVJKNFRNOGozWkswb2ZFbnRmQWY3bmw1ZkFYYzh0VVBJU0FueHlhcDV6QTdycnhoeFRPY0NQQk5DVEFoM3NoUWFQUk1aemtvbU00b2I1R05EYTNMOUtmNTVpTGlDVFE0QVlHQzNPeDBCSHI2clV4bkJLYkNJeXJBNkRUU0pNUVN3NjhZMUoxd3BQQTBqRGhUVGdURHNIRXJrNFFMNnVmek5rajJ4TnhKN2NWZCtrNVlzeWk2akNZc2Q0T28rUzhuWEMrbCttek12WjhQRE8vZEVSU0ZuUDFKVVU2c3BoYldrSTVMNTBmQ2R6eS9FZys3UkZ6TzFtT1BVS3lRUDAxNjF0NE90VDl6Wm4zTFN5UTJ4QnptckhoS1F0TXBKdXdIRnJHTlpuQjVhVEJBb0hya1dKU2l3QXhHYmhTQmIyRXA4UXdweXJTQzNkckZ1NlNreXh2YVhkLytWdC9oZjVZZGwwNS9QblRsZ1o5VGJPZVJ1SlBmZ0xOcEVieG9vQUZFOFBmVEJkVHdIUFRNTlk4TmdBaWQ0bmlDdElXcXhTbktoTytCS2hnZUZ6R09RNVF2NEppdVpJRmdxQWlWbzRtUkx3YlRQaDRzZ3J3SUlXVm8xKzBab1QrRzFYMXh2ai9PeEovVS94ZVRYdVhwdTJCN0w5ZDY1UkdMLzd2SmVkYS8rSlhrU3R5MTlua2lIMmRmL0Z5YTFMaTZ2WDYzL1JmZE5GdGVGdEhQczVkdEdORTIzamh5STdCalEvaFF3dk52VWFjQUhvQy9Sa2VSUzVsWHNiY0JySTZsSWJRWVVjZ1huZ0c2VlFjeEFyNUNPSWdobmNvRlNDTEU2eGFnZ0k2VGdrK1FIaU1rMWhzUEIyRFAzejdqdFMrZzVabWJwaXBYVmZyTDJkdzV4STFvZ1BTN0xJbTZsdzhRNDdRYkdrZ1hCeTVaT0dTa1puaHR3L1BuSEpOemVhTlFCTlVmYjR0WDIvTG41cTV2b2JROUhXMThRTmRRL0VNd2s4aUdtbUs1bTBiL3lES3hPa3htaC9xdW54czlKS1JrVXRHSjYvd3ZDdEtwcXVydkJvWXZKMXVaZmUwc2t3ejFnWGt5d0RQVTdDcUlVcGNxYWtsdzdjSUFhSWMwVVJKZDJvYXROcE1XMkNDaEVHY2ZiWEdLOXdid3dkOERoR3cvUUczVy80K3kzMjVwblRId2xPR2U1QUFQZEhVTmRnbm41TWw5TFRBY2tMNEwzTjhLZjJaVkRsdW83L2dsWEQ1VGp2dUdqYUZiaUpwMFhDN0s4Z2tkbzZYc0x6M0lIb2psajZxeE5lbVZBWkFhbUJyZzRpSEJyUmRCWWhiOEx3U0p4RVFWZEFxd09xSVd4QjRybGhCckpUS2s3WFNWQ0Q0Y2ZhbThNVnNObnd4WmhpeE5JL3dtQ0J3T1U3QUF3TGlabzNkMWRkWGR4dEg4Y2wzaWRmZWU2Mm8zNTNOM3YzbThFVThjNzRJc2ZLZWgwUUJEZTJUNVgxQ0xpZklwaWZuNU5mQjh0SHJjTVpSWTFlV1FhQXZYMW5BcDVkanZoK2I3NUhsbnQzN1JIRWZVaEhkcklpWFdnTTNmRlYwMXhvTTlzMmxnMGJNNUxveFUvT1VLNk9sRjlQcytpRlRHNG5SL3FhYm12WjdrbTNZRCtiUjlWZ0NmQldlR3pyaUJaMVZZYUJWY0pSZWNjeFpGVjdsWWEydFVDNFYyMFdDbXJmS0xJQnI1YVFrWEFkdjA5VUZLYzErdWkyLzRqREtXZ0svaWVkaGtUY2xDN053QWloYmhSa0o3UlVoZzVQd0piSWh5WjEzdHZLSWIrWHZ1RU1LdU0wa25waEx5OUwvYkRNd3hJa3ZKNjJYZytnbXJMbmRoMGVxdGxKWHFoSElhNDBDelJENk9LSzNUb3o3RWNncmdPV3R0bG81cTZvQVQzU3JxMlhGZmVpemo4SzdmWnFYa0tIN1JsZko4SHZTTGxZOUFhV0E1Y3l4ekZBMVl3LzBHUDVmbnFudVZoMm1qTUdpb0dVU3JxdkhrMll3bVhNdEhyR0F0T0tuSnk3dWRyc1NwdjlUWEZmQytkUnRWSGRYb2dVOGF5MFM5REFpT1ZNOG1BWlZKeTRkOVhxc3JmUW9Cekk4d3AzeXU2cEE5dUNtd1hRcUVlTVFHRDE0cyt4MjlRM21MWm5qV0g2UEtDdjZiZkRtVC9JeWQyVmZxaXQ4NTNuVjRtTC9CazIxc1ZRbzg0Z3o3TkpzVVpKRThTQ2dBdEJ2U3VMNVcvZ2c5ZWg1VnlQMU9XRzNOYkgrWnBrRExZekdZb1RHVWV0RStpc1hpZHQxb3o0M1UxOU1DM2xnaWdSVSt4cXBadklsUjlVR1FSN2lrYldaVXRCblRjODEvL0QzWU5EZkdjK3lHZSs5eVZGbkZqM3dTWnZ2ZlRMODJGaW05NzJTb3NrN1lTM205ZThSVFlWZGJpRituV3d3cEN6UFc5b3hNaE9rZXJOeFozYnhZYjB2OCtCbFl4blZVQUxIZG9MN2VOV0k0alZnUFNZUDBUZUE2dGNvSmFBS0VOc0dhV2RpR3NHRHBGU2tVT2xrQllJaWlrY2VDZzBJTFh5bHh3NC9xbVFjUU1yc3p6NGZzT0xSL0VnbWZyOGlYOHVmekMycHluVlc3SDdBUmp0cXhJV2tZRnYvd3dud29Ea2FVeDQxM3ZYUFlPZVFzLzJ6QXVEb0NSdFlmdmJlM0wxcE5TYk9ZS2t1bmpHMXJXWWljR1JKc1Y2SUIzVGQ4U1VzNTN3Vi9UbVcyNjdGc3dCaFNnWkxBWWtuSXpFM2tTc3NzVmtUWGhYY1lJQ2c1MGNyZzFQdFF0Q1pkangwTkZGeGxkRVIyUzBuN1pMdHl1WnJKZU1uc3NIbWhLQ1U0YlAvNHo2UmMzMHB3MnVadEFDUUpKa00zbkFDN01HcVJBYnRDcnljSnFmY2VFcldjdkczcTdvNTV2MkpxaXB2RHZ5M3hMdjFiN3J1QXgvSDhnYW5WZ1JlL0J2SE5HT1B3NmZ3OVpoaHhyNEd1YVdZYVRsTGtOc1hNNDBZTHYrTDBmcG9EMmpPZ0k1RDQ2ZUE5eGJLTGdKelp0T2JoTlNBVUtQczB3MG5ZU2pjK05ybHJ0Sjh1OGN0dWszdDl5clRGYTViblpqdzFZMUpyQWxza0RMMmQ3MmNrR0ZUbGZDYldKamJMaHFwbElqbEJwMFR2SXkzb2hZeW5LVjhWekw0R1lIL2Q4K1JEcVY3ZXpPM1haWHk0NU9wOThYZFJQSVcwMDU1OTBuU0hLNnNoM3hlK0tTZFZGWHJDVnpvTDl1dWEzOFppdDhWdzVYVEJUbkl6UEhjZmFvdWk3Y284UWhISEJhVkNlZkU5Y0ErRlJBTmFLcm13ejljUXJMVzB6NW9CUTNtYWFKVkVQeEFyR05VWGZpeVNYQW9NVklSK21rQytPc1QwVm1zbUdDTkJoYzZ0MEdGL0hTbUgzbXVVelFxSTdLZ201enFHaWNOMXhJVG5pMllhYzN0elFaKy80OU9wdXhBZGt6WjZ2WTFxU2dIaVM3cEcxaFo0YVZpVHVxeHJJb1J2SUV1MjlUN016Tkk0eFFORFE4ay9JU1p5QmlLV1Fmd3FYcE1NZUl4bFpQd2VKanNIbER2eFQ5OHNsNFA2NEgxU1ZYaHhVUk1rd1g4bTM0NmJtZDlMZTRrY2hsQjF4UUxhVGRaQVZxaUMwMlI3eWp3SXp6UnFxOHFVUjM5UUlSL1RhZnlOdGN0cWR4WWgyN3Ftd0tlUUFRWUZVanRUamJXd0FBeG1GUXNmRUMxWVFnb3J1RUJVMmlzbnYwSGwrOGZmcmZOMGNDUXBweVhFTzMwTW1LbElmbzNXV3lsLzdlN3ZkRWxlZUtPajdVaFN0ZzJXUmFBcmF6b2l4TDVOeEN0UDhMaVljTWlUMlFiajRRVk55RnYwZFAzcWdQZFNWdlZKRTZOeFEwbFJ1dktWSXdNcmp3L01UQ01OSVhUMEV5bXZ6L2NqUlhGOTl5a0lVdlJkQ0dUU3poeHpjL2E4YlJ2NG9xVHRWaEM1QlgxazFZUWhBOUhTN2REZnBEdGRiVTB2c0JMaUJhcExKVXpkVUVlcVJoRngvVlEvMHovME1rbG8ySlpQVkt1S1BGWTAvNkcxSlVJNUtLaytkMldiRHB5MEIwc1JsOFh4ZHVHOGFsWlY2NFhmVE1OVDRWMmNZSmdhbE4vRFR5VUFmRUdqR1l1bm1zNWI4b1B5RDk4T2Fuakl2V21xeEFvZjdJNlN6RDltd2crZC81dXk0THUvUSt0ZXREWlg0cnFxb0I3NFZIbUFlWVB3VUlNOHhrZDFKc1Qyb3J4UElqN1U1WHFPVTFrblFNNm1RYUNGYnhUSzNtcFZ1NmpXODFSVHl2RmltTkZPZ25lS2FmTXA4bm9uKzRML3lhRHEyZTk2UThHL3FkTitVN1Y3TDZOWEFFd1hzSStjaFZKOXBJclNZSjRUemNzVFR5WUxCYVRueU16NWVPNlFlYUZLL3ljY2tORjVCVGhSVHhGT3Y4Sm50TUR1UjdJZVRBaGVKQ0RRMWVRbVVGLzNFb0xEMThCajE0dmlYeFlDWWRobHRuSVhNVE1ZdzN0RDdBRVNGYUJ5RnlLS3l4cWlIaERKcXJnenhCWFkyTU9oYlczTFFTZ2Q0SUlRKzRLUTYxVXFYVWorZ2d3MHRZaW9EcDhDWGthdnFRS1VUMUZrcVhBdnZTUjFXaU9sdjVXOGpUTHNFV3R5SnZDaGt4dlJudUZ1cFFTYitibFYyQ2hUdGxxK1hIVG5lQlpGWXZEQSs3bnIxZFN5dldLUWplTEN3c0xKL0V0R3dTVEwycWlqZXZYay9wVFMvZ1J4VmNvL00zdUFMNUpaZmtKMTR6NzFsYkZWUGh2WU9sRXI5aWpncmp6WVZCMFArWVliekljZm5HZzhFbGRmUk12Zmd4a3ozZnRjMHozUXNHUXBBMnBIUEtidndlYlYrTGZ0T0hPaDNlS3dxaGQwUlZWM1ZBWVdPVEpnOVEzcWZwQ0xyVkJrZ3poUXRkMDlyMUxVbFR4WTJJRFd3VHNuVTh5UTh4clNFOFEyMFM3QmxFUG9VbHBMTDlYbTUwQzdPYlFLT1IwSk9sdFJzMStVS2x1UnAweXozaDdINGtVSTFHaVdNT1ZNbnFmMHRQdkdIMjl1ajlSOUFhNzRzNHRQR3VxU0ZCTnhBOHEzU1Bodjl5aW0xNDJqcjlxeGV2eTZDZU12SXhQUG5GOHBMRVZoL0R4bjdNY2VtWGNZdzFITXh4TExLVndKUmNUczhHQWZTV3ZtZ2JZV1ZWTFZPVERjZitlWkk4YUxsK3BaWjFaeTBPZU9jQ3pFc2NMOTlveDVEb1orSG9Ic0ZEazlFTXU1OFJjTzBmVyt0eVljNDlsSGRaMXlSTEZtR3hGOVFuei9JZXByQ2hNdE5NdFNSQktSdXhDQkhSNkZzSFVuMFV1WVhHUHd3Y0tmWCtxcGVxVnA5ckVnWEtUWHdoVWM0SkNTampPbUYyaWRKK1hzczFia2drMy9yN1VaTnhQWFhWYkJzdDd0MGlPcDJpNUIyNFJaVjI5aitOMlFhL3RGT3krNUVUQzNoT1dxaWJ0VHdxOEw4VnpiRWJJZWQrMU05SUdVNVdURzFWL1lrTHQ1ckJBNnZXcmJpV0ZGbWQ0US9xdVluRjR1R2tNUEdSc0lYS29MckJieEZUS0VMZXpmRWJtSTc5Rkh1c1BBMlFlaDloYWtjQ2FBMGxIR1hxOUY5VkxteFpCUEZBQ2dtVkRsSW5KMmhncE16NVhLVTgxcnEyMjhsQVpQb1V6b0huMFROSkxESWlwYnJFLzZhZlllTkhtaTZZN1htQmpiNUtVLzQxVmlyeUE4b0pUdFBNczMvM1BiMUJrT1ZCcW5OckRKYnI1YmlRcFBEL0lKN3Y1WVZZMFJYWkE2RTRJRlNUd3FvZ3lmSGNDSFk3bkJER1pmT01UeVpRbzlBUmN2Q2YrbUdFNHFEVHV2RlpTcFZmWmRsbVMzeG92dVR2ZnFtbGxYYnYxTmZqeE1wSW44WWUxKzcxT1hISWVGa1grbVZoY2R2NUtGRTg0WXR6NUFDK0tkem15QjN3R1JQRjZBQzJTU08vRHpPdVpOekZ2WXg1dFlIa1VxVXU3UkNNVU8vRGhwd0FRZmh5a2NDSkd0d0hXZ1dHaEJJWWNuMHJVRVYxS1phdzZCbldPTHdPNHVDelFKZ2UrV01IVlQ1RnN5RW9XVVZIQmdERlZDU0JxdkNHS3QzQVRDQlZpdDFHTUQ2VDhSQ1piU2hlUXFWQjZSTVZFRzZ5eG9aaVR4MTBzNnd4U3hzUmYvMGtkSFZBTm5VTzZaL0laVzQvSHl1cUZBczl4WTdGazFqWkhyRXh2eGV5dUsrdzR4Nm9HUDY0WGRFbWVzb0tCdE5PZnppSG5lTDArU2dIMHcxeURXd1Yvc04yMlk5dkpMc1V3MVZPNG95dFYyMUdSYVVwSlBpQ3V3dmdnME16aXF4RXZPUVl5TEVGRHlGSzM4dXlIRU5mbnlCdmNrUjVEZDBxWHFKay9GQXlaRlRhYnlGU1Q2bmJYRzFqaWsrNzh5Uk1yU1F6WUptYmZIdkF4UlNSNGxFYVE0a29zdG5LRkNIRURZRk05RWsxS1EwcHhwVSswY2cybEh4QmxwR0p0QW4wRm9GTnY5SEFpQ3lMeUZwdTVReEdXNmczQklZcXZldGFMUHZhNjRIVklsUVhsRGtFUitidHBLdkw0d0NKSjF6ajhwc1VJbHhBWGRDdDZnUEdZcmlhL1JHVFJJTE5yYzQ0b1VVTkZYbGlKL3IyS0Y1NnQzU3A2V25oSzg4UmJGZXBBR2w3RXk4aVcrU3ZETXZybmRpcWlhZXFHVXFlYnYzdWJpdjk3bTJFZmg1bnZ1UDBXU1hyMUtDRjFnT1JDNmdDalJxUjRpUGg1UFV2eGJmRjNuRDhuUTF6K0hDeVpZeU9uR1VLUjhnQWtvNlBON0FoYTh6aGEvTk0vYlpsbXc4VlcvbE9mYWpQWnRoMlA4TUhKdkxLRXBhWWRKRUtVTU13Ui8yOHFxVFplU3FwRTVGeGRJTlMyRFF6VVI1eE0zQnhZR01FNXUwaUN0VVRFWEhEWFRqbVJuY3dtb0lNa1NoczBjZU9oZXc5dEZMVU5KWG9JenNrNzcvcWNiZWRIUmhDaW02V2RkMTB3b2ZJbXdtZE45WVJxRGhTNC9rMkhObTQ4dEttZkt3eVFRMEJGWi9McUJQNkYwOHpTeUxhUkpVZ2FhejNmWlh2UlJ4bWZHWU1TTlJaV0c0dnN3RGxXNWtnb09WRkFpSWRvamJoKytyQ0FodDQ1dlhIajlJNzVuT04rVE10cUh3dWN6THoyTVk3N2VNS09iYXBsQzM2V1M4WjdjclZOTVFzOVZhdnQyems4bW94OVZGVS82cWVIQm5idUMzLzVGTWQ5MU84cWROVTIrUmErMWt4dXFuWGxNdzNmVmFxdkozR056eEc4TWltQ2x3a21hbEUwTGtFc2xZcVZKcFpaa1dKWWtSZHQrSHo1eExReGdvcmtwaUw2enZDOVEwUDNEbnQrNGRYWmFTSE9qL3NQRlh4UHZEbkR4L214RFlMSDkxeG1jVnpGSGdqU2JsQktGeTB0aG1XV0NzYzlKeGpDVzRhV3pJcjUva0YwYkhCd2NDZysxVFhSTi9jNlJibHhzRytpYXlyK29acWkzUEI2UlQyUXlJNVg4S2luOWFRU1BPZllsZkhzandUaDRRK2E1Z2VqZXY5cmRneDlpZ21ZUGlMejBiR0pPajVFTXpEaGcyb2F0S21CRWowdCtWakI4OFVqa25oVXBObWpvcGc1SWlnbkZlR0lJRVFaSGoycUdZYTJyS1h3WDVUSkxjdHk0MS8wRHVDbjlFWEtLKzJTdFlqTlRhZVVhTklaRDVvdUtMQW9zV0taQnNiWGtaWWplK0JQeFZWQnl0L3g1anUyYmI5ais4aUJQQStDSXQrMXEyL0REUnRtYnR5dzZaYjBEZENsamtNdnZKRG5FRDlIK3RmbHZJcWVrb1NYemVEYjNueDBleUhMYWZoR0x0VTFjK094R3pac3FVWmdkL2kyOE0rQjluVHluY1MydnBsakc3NjBlVHdtSnFndkxiVmtnYldyQVhRV21jTGNOdXBBZkZocUowQkI5czZOVzB0OXZhWDZwa2MyMVV1OWZhV3RHeisrOWZiWDM3NTErS2JycnJ0eDVOVFcyN2VTM2EyM28wWGRTS1JLeDN1NzB4YitMOTNkZTd5VVNoajZhU1kxbU1ML0R2YVlobUgySlB5ZXdSNmZKRTErblQrTFdEbDNNcGN3bDROZlkyR0VWbUVralZuRW1DbUo3Y0xFRmxqY2FBb1FRTTZKaFlnYUtMWXdnTmJjZ0FPTFpZMWM1QUdjREh2a08xaSt2SnNUeEJsUjV3NGM0SFJ4ZzhoemQyZFo0VHN3TmorZEdkWnpPWDA0OHpUZUM3ZDJYUmw3S2ZkMUpldSsvSTI2SzN5d0srWm1sZjZZSzdqNkc0RXVsdC80Z21od0dZNFhQL0VKL0pRTVo0Z3Z6QXA0aEJmVnJrUzludWhTUlR6WW8wSHJNejAvWGxnbzJ1NkNycUtkVnJqZnRROFV5MWp0V1lqbTVoOFFuNDV4eXF6VC9HUXFMWCtmTm1qZmxzd1VZUkZXcEdJYkswcHRxaHVoY0ROWlRYOUU4WlYvWkpHQkJMYmZOWTRKc0FCMXpIRDdXUUVmWTY5YklEaXRDKy9qK2ZmOTNkaEZIUDV2L0tna2ZZa1ZXSXRGYlA3dkRWY1NIbnhRa0Z6ajcvTXNDeTQ5Zi9zZ2ZGc1BucjZmNCs2UFl1eXc3QXc0b2UxNGFXK0E2SzNTaXJscGhUdEJXZm90ejllS1ovZnhDanF1YWNOdW0rb01ibTVIZFVQZlhpTzQ2by9QOGRpblVxVGVxWnRCTS92MUk1bjRVanh6Sko0aEN6S0tkRnlSbGlUbGVNUzFsS20zbnJENG0yV1ByL2pGS0dzVEJ2djVURHo4QW1oVGFDNGk4VHFDeFpib1NEelRtTDhwL21XUkdXVTJOZVg0YXJzRTB2bng0UlpabHpFSkhjVEZXbXdSQjBiWnEvRWt1L091UnlDNWdFekQ5MEtDUmhzK0RzKzEzQjF3OW5oMEtVN0NYSFF0VGlMY2plVTJqTDVybWJ1WXh4aW10bUpWdkYzc2dCSlVWc2xVbmZzdWpTUmM0K3VBcERUUk91YTBRYytkeTNmNDJlWUhjbGt6ZDE4ejk4Wm03b3RoblVUcEhTUytVUWRKOEY2NFNOdDVjWjRjblAvUGEzNWlhd1lHcm5ud05JTWZpaDVXZEVwcHJTdmhYWktnNzRleis5RWlQWmhiKzNPaTY2UFBFcnlpR1dZcnM0dTVramtFOG1ybit1Z3NuVjNvZWtwRFJHM1JSa1FyTHpEM2xQSjAxa0Y1K3VsVUl2UStxRnJRa1d1QTZUZmVPSUtPOENRVWthek44NWFWNmU3cnoyWXNpeHdGSk1lT28rRXlvcTV6S0JlZUpKbC8rUkl2SXBhVmhXVkJabGs4c1BLUzhCcUJCN3liaHlTSUhtNkt0Q05ESTRVZXkrb3A0TXphUjZldW1acTZKcnliYkZTQmwwVkZFV1ZlbU1BVHVpSWFSZ1BucHIydXJ2amQxaFhYTU4rU2o1SmJVWE8vYlYxdDY2aWJFeXRxN2pldkt4UkVOUlQrYzZ2Vy9zTy9LNjVJRnk2aHBpektlOTFXZDc5dFhZMy9CMzFYYVBlYUh4YTNvcTUraC9YMDI5YkViMTVXY0pjRk94d0Q0em91a3pzTVJrank0cUFxdG8yc1FQeEVqdVBoSVl1Q3FPZ2d1Ylo3Mk5XaTR5WmFzRWJUTE05eDJjRitHTW42QjdNY3g3UHBVV3VkNCtnOU1SZHhIQjd1VU1aZEl1UGVrcHRCT01OeEtPNmM2V1FMMndya29TUmh4cGcvZzE5YVhtb2luVktodkxrRVZtNEdLQWN0aFdJTGVDOER6QnVhYjdINkVDYzE0RUd1WCs1TnowOTd2bVduWWsvRlVyWjFmYnBVbml5WDdpTW9QYTV0ZTZPZWJidUVMN2xKSlJSU2hyampmNXNxQUJGRklTVzdmbG9IMWo0OTdic1BBbzd3Vk9uYjBIYTZuUko0VGVPRmxOM0E4Q0tZMzBtbWh4a21hOFlNV2lWdGRXRFl3c3habk9DYXMyaWxFVVpEaWtqSU5RaEdWbUNTQm05SGhhQlRLVEJEbnlBY2FpZGF3YngvUzRqVTV1MTZKbzVMRmZFbC93TVdjUXJKTks2UFRLcEFKSjRUcmxFMzNCTVFzMHRXSXV4MnJ6MmI0RVdHU3hSVGQ1R0NZK0hiUnRNRFVtYmY5UFMrakRTUUhxVitmVGxDV0EreGVTMThDU3ZpbWR2RjNNamNCdjVYWjJqeEZUTEtTdGlsbGZ0U3ViTGVOM0xHTDZTZExpcUtOMFRMZ3c5QlM2NlgvSVZpcW4wYitsUlRNUkt4MjJLSkJkdjNjNzQvTC9LMzhhS2hTbmFQTGFsR0o2ZFVoSTVpbjJ6MThQcWEyWjI2NU1TNyt2dTc0bzZrTzU0V1N5UmltbmNrd0QrUUM0N3pvc2hycXNPeHNzeHlqc3BRWHJ5b2JvRW5aNHlaSTNiTHMzaDRDcXQ1NDZJd2liWWhFTUlvZ2p3Z3R3ZHJWUlBGRVFtUFU1amdnQnJvdnZleWJpa3VIV3lNZ2dlbCtGWGg4dnpva2ZrMXE0TllCTytoWU1IejFCb1k0QWZnMjFRU2UzbU5pck5mRU9CK2FrdVBmTENTekFBenkreGdMbVp1Z3FnMXl2N1VFVnc2c2FyY2tYdi9TZzcxTldxaWhXamZWaGtWaWRZRWEwTk4ySTNLZ015T1JuM2d2b0tPMU05UU83L0NkZE5aUWNtb2RwWm9UenNaZFRsU1IwY2FkWFFxbmhsZHQ3NGthVVdOWGRtb0wrSlBRUER2aTNqYzJRY2VlaVd5WWdQUkx3QWRYS3h0UmhINlpWdEpwWGI2VkVBZ3hyVlU2Uml4bWl1MFFQZFFuZkFtMkxHWFlaM1h4SHJSeG1PNWgzTEhOaUxFbWxpWGZwbEZSNTljdy9wN1QrNUU3aDVKV2F5VGxRTUF0MWhVVStxaUV2dUR4WVg2d3QxWDRpZFkrRW5UOWZvMHZ0M0NqN25TOUc2RVNyblJ1d2NlQUZ4MHVJWlBIUWJ4KzdBTDk4SWozS1hGeFVXbXJjekx2MzJaU3gxb0MwMTZMcjhXRkwxaXRYaStaUTUvNjBLZldLZlFYSnM5UHcrY0RHZTA1Wk5LYUxmbk53cDhKZ3YrVzNBSjM5SXk0a2RGV3N0eVg2ODNiZmY0blluTjZsL1FWOUU3bWpyb0hzRDFBdTZYaWZ4NGt6czFXT0U1eXEzMEpGMnhENEdtTkNSTExOZThHczhpRWxFZlhzVHlIMFlrY0Q1OEFhY2ZhQjNtUDloMi9NbTR0Q0FJQzFJOE40T09KZUF3SkEvU0RTU25tVlorc1pVMWx6VlpCcmE5QlZsKzhvNFpwb0hUQVRZcFdqN1FYc0NpMHpsWHJiQU9yTnd2T2UzREZDV3Rvb2xRTFRyNXFnUWtUemhCNzJ3cXFLOWUwN29CeTJiaEtGbXFVODMzNndIK0Z5N2d6dkJaWHNiLzJxd24raG9tbWErR3ArQk9kQnpTTCs0VlRXTUdKNjk4UGx6ODFWV3N3RjkyRmNTTnNjM3lKcGtLUkxUam9saW9qUktoeWRrSWJvRmJrSmQzb0J1aHYzdC9vTCtmTGhlcTZEblZETUkzZkZibVB4dlc2ekxxMmp0am1PTGVMOEs1OEFpNXdqYk0xMTkxR1Mrd1YvMEtMVDdQQ3l1NDZpZ2IzTHF4WWh6eDhXK0xXZWkwTjlmT1FsMTNTTmZKVWcrdUp0ak80YVF2QWhCZG03OHVmS3FCQXZCSWF5SS8xZVJ1N2VUWDJReit3MmRsc2p2WEVxd2JoZkhqOVF1eFBuZk5xVE9XZzlpK21GOFEvOWtoV0x1cVZTY3BHbmQ3R0Yyd0FsaW9SVVBRR2F5eG9uamVjNjd0WWprMGllS1p3QUhDQlR5b0JOY1Rqby9TbllwRWFCVVNDVWdQU3dyZTduc2lZWnBsSDZUeFVocExvN0VVdDQxTHhhaG9Ha3VoL1ZRbUQrY2p6b2ZGaVA1aG1YQTVDMlNlV0NSOENpWENyekc3MnBhWGIzN1hFOVc4TndGSUpoTmVrU3RXSjhDaGZRSXVwQU5Tc1pwbjd5Rms4R0N1REplSkZTL0gxblBDcnhiaHY5emk4cElDTUZkS0hlWW1nZjg4S2M3eHowTW9UNmprY3VqZmVhRytlSnFCaSttcGt4RVBHdlB2QkFPSWNTZTQ1cHB6WTFYWm5XakIzc0VhOUtHaFBXTUMxckR4V1BFQVhTa1dodmVNUjBkZVQ1YVYwV0s0U0lnM1NZTGE4bFMrb25ObmhuRDdURE8zTW5jeDkrQVhHU1ZoSlpzcGFJdEhISDhEUDFjalVFcGNnWERwakJPMkFiQWNSaE1sekpORXMyNVdwMWhvRFh6RUhSYWlzcHR6N0RoV3MvMVM1LzFvbEpjRFVVYWMwVlg4dyswYnQxeUlKaS9jc25IN0UvZHVucHZiL0ROSXJscFFGSDVVaU9FUFhaMko5eDZUQXpkTHRNM3ViZDFrbTNVQnhrK1l2SVRzalI3b0ZxVHdyNXMzOFFxK0NhdWhtcWp5U0pPTVloZTNwWGJvMXVrdFc2WnZQVlRiRXQ3WU8venQ0VjZTTE52eXZJei8yVnZ6bDZiak1UMEpjMEpSa29xd1RlcXhlSnFFdzZhSkZWRFhXSEdvZFVORExnSHNJNS9nT0YvVUhya3RZWUVDMEkvTDFXZ2tJNHdlSFpDY2tHeEJmclNJNWpYNlZHc2dtQ2RCc1pWTXFuKzB2dkF4RldkSEx4a1JINmV3amIycTZhcFN0eCtRTUQ3cW9pbFQvQVMwUkF3U2FuKzlQdit4VkFiZmx4dTVaRFR3SDVmVXE0bUpFLytUdWtVU1pIZ2I5YjdNVUx3RXhpUzZSejNTUFJwckdxOWlYc2U4alhtYytWUG1XZWF2bVIrY2d5NnlZamFzbmVmK3l2dExaOWsvMytldjNKZFc3R09Ob0lXWnhiZjdPWVFQU1VJQ2h0RUVNVEdmT1l0Vm9tWWV2QWFheHhmUDR5R2QyZWNoK3p3OGJqM2Q2MzJOcTgrUzdGbmoyQitmNDcydDVCMk5PVVdLOU5ZSDBFSVVmdzVlS0hldi9sWUFzd3oraVAvZEJIVU1wMEUxWklTWXFvMkJrMEdSdXQxV1Y4MldvZ1IwRUdESXhNTk41Q1lGOWp3WWV3anB0eDlNd1dJSWUvalhKK0JqWjBFK0NiOFNua0kyR29YMDE3OVNGYzdZWVhDS0trcnNMQ2ZIWlc2V2xiYnpQTWV4enZndk82QjRiYTFnV3p3WXgxVEJkV0p4OEE3RmU0NWw2aXdMM0Y2c3FnZnEzWkdZUm9VdFd6WERreERGalppVGNsK2ZySXBQeWZKVG92cUE1bXE2TkxFWlA1c2lFcEtmS1pWTmxZVFdjWnp1T0RwK09EeFZNeHdiLzVhQWY4UTBVNmttMytJeTRkaWhISG1YME9nc3FOTUdnNXdiOWIrRzhDbFEyYm94U1RkbDdTWnplRU5sbUlqV0FDZU9FSE1BdFpMeFZPR2x5aThiRDEvRUw2UG1WQk5MM0M4S1VpYk80aTlQU2lyU3J5SDJpdGlZVGk1UVVxVk0vRFJPRVptY2dWRkprZVp4RFJLM1RseHJ3ZzY0QXRjdm5jZkJxTlJZaDZPMmdCbm1KdVlZaktZVXg2K0JBamVDb2dDRElwMmZDQllaZ2Ywck55SWtJNUw0V29OSXZoWFZFclNDVzZacURTQXo4R3pkakFLSVd5dVdLWllpK3JtbHlRSS8ycit6dmlWWFRBWXVMM0lTbmtzVVIxVTB5ZFo1Q1g4TUxCcnAyMmFuN1o1SnYyempCbFlOejFGTlNjbkdobnJkYnZlaTBVbEo4Qlc3MGhXUHFWWjl5ODRMOXc1UE9WNzR4djdiOTBncVVzVEw3aC9oY1J1alJkOUorOWI4bGxvdXEwaXFJdkdhSTJxNjZ1dVNJUU9TcmF5WTV1YlJ3YmpBNFptZkUweUFOc3VwZ2luS1dEMUNMQ3NtcXROekNZOTNOTmRMOXRwcWtNa1hOMTk0OVZobEpQeXZNeE9pYktyaTlGWndrMk9pV09ndnNUeWVyOGJ3bUg0VS9HWkl4QWF1VEVra0lDd0F2QWlpUUpiRnRUTk9mQ0ZveUE5QlZwd3EweXVhRjVQN0NMc1RYTkc4bU53M2xZV0ZCckxXRUdFc1paR0lmaHBrVE5Yd2pkeFFjckE4ZkNEdTRPK2JSYktpRlBydHRRNW5OQlp4UE9MTTJNVzloVXJRMzJPblhUVmppMnNmL3VIWUZSb3I0K2FTa0hIenJLaHhFdm9vaUJyNFlhd1RQekJjSGt3TzVmRFAyUDBGUlZucmNMK0xtN1EvcUJSNkw0NlpIT0k1eEdxaW5WSFhQdHlyWFRHR1J4Qk5uTDNaUUpLaE5XUGttVi9pT2diMERhWUpra1RjWUowT080dUZLczlQbWVyZHNpanFuSERkVkJzSitkeGNIUjFXVFV2UStmREpGcEY1cmw0bjBCb0VydzRST1plcGRRQ2FPTVhtd283blJNQW1MOTNJcS95TlFOQ3BjbHR2RVRoZEZPWDdWWE1yNFdPcDRCTndYdWI1cmVoOXdPeUJoN0dEVy9rR1J3dEwrS0ovaWNjY1VwNkdPejh0VEVOeXJZTGozYVJVQy82NVVZQ3A2K2p2M0syYXVGd241dWJRUFEySzlpZnBqNkREOGJTMVJuazZBd1k2ZmlUeStEaGplZENWYlFVS2I0cCs2NmxtZ2RRbUJoUGdYYVFKMnNVSVlVSFlSbGFUMmxYT0FFRDIvU2Jya2l1VnBjclV1SVFGNE1vVVR2SHB5UUF3aWNvNHJRVmlvUVlJQWlKTzhWMTRGR3dwbjdkc01lTmIzUGRndFdaK2Vuckh0djcrYmVQSHZyb2xibTZ4OHR0TWMxdlhDRGsvdlBvRStrSkxJVDFLanI4SWo1aWZSdWt6MzloeG9yVWVleFMzbzQxMWdNMjR0RmZodW9aSWFkR2pDRlRFSHk3ZUhERzllTlBIYkJOcUJydFZHMHVLUUdNR3dmazFDaERTakdhYWlFWmhySkdseW9xcFRQZEt5Z2xOOW16RjBoQ1Bweng5VHNlekg1NE1MTVgySlcxMEhzdWdpd3ZXTm10aFlZRklyWW9ZY3hSTFA2WmJpaE1URllSMTJYSUs1b25lYWVWUWI4cE94YzBndy9OWHlGSkN3VHFqZkFYUGQvbG1QT1drZWtmbnNTUWNMdVA1NU9MY0tTbzc1ejNEd3pkMGR3ZW02eHNldzU3KzFlbG5XQUg5T2RZUTl3Qnp0NG1HV1NJM3hIM3lZVk9uSWhBbThLQVZnS2doQXVnZTFaUWl6emRpby9ManhNVi9tQlZCRnZIUjBMN2s5dTNqanBPOFRMQllmayttdGpjOW4wN3JOdFowa0NvRXNXUXNkbWNzRUZTOEs5dDZHcC9jVzh2czRWbEx1Q3pwT09QYnR5ZjM0VXVxKzZLZHl3VFJNdmlMNEtKOW1Zc3p1c1RaTWxSYkRQL0t6aGllUlFYWjVpUWRuOW9IUDNVUmIxZ2lmaEo5QlhnVnVxWjRFajJBNTlQdDFDUEpJMUdJMVdoNTBHclBOY1RmYUgxeEMvSmF1VWhreHBMYk1WdVErT3I0cFNNZkIvanpQNllwRm1RRXFRYlpNWnBLd21VM3ZacVhsdkg3REE5K3N5enhzaWloMG1nalE3d3RyalhvbmpiU3lIeGZrSTdjUkJ4cUtjNFBFOWxXWVAyRE1zbTlIQ1NDbG13RHVrWnBoV3dwckFMRFdnTVZpNWJITzhzK2VxNGgrWUFVMUxaVUVyNlAybHlNamcxeWVmYmJvQ2V1a3dCY2JzdVNrMnMzMTBSTU5KMmJkelpObU5ldGtTT3hXdUEzdDhSME1UdVlWekQzTVE4ejd3WDhaQ3d5RTlHbjZSc0tvak11RXk1YVZacHN3RWdVNER5RmRmV2lQdTgxTHd1dzBnNVJRQkNUV1MxdllmRjJFK0dqSitFZUJQc0dpd3lvMmlsT2VtZlpGOVFZaUN6QXRpVDVncVNxTVZYZHBpSmRjbFJPa0EwRDNPSE5aRXczc0pDbGNPS1FvdXhVT1Y3QWcwR0FKSjRYTlUyUHErcEdWZkJNTzlHUHU5VnBMSVkrUXFESGpoRWo4SnA1TktadVliSHdCRHFLNkFsWS84Vy8vTDZZSmVNT0pXaWlJUWlpNUNxYWErdVNLdUtmdzFLWStuWloxaVRSa0ZoUk5IVTR3RXBDa29zYnNhUW1vSnVhYmZDQk5YS2tYVjdDNVh4anBEK0RWWE0zMFlHYWZ2WWdqd2RucVN5MC9uZU1YbXdyNmJybERrY3BXcHZWc1VGN1czYnY5Nnp4K3VnT2lzNjIxTEZoSW14SktOZURIWGFCOHkvWCtYYkNjeXZzZm1JVVhUYzVhN0dubXBlL2Q0MWNBMmZoUzJUZXNFQU9BZ2NrU2hZelZTdGh5YllDa0VKa05aSkFJS0ZmUGFzTmxrNGtVNHFQbHR5U1BZdUhFVTZSbjlNdC9sbkJScThKRjN3bGxUeFJHdFNlVmF5eTlTeHY2YzhwTWhaWGwxUzd3Wm15VExpMXlzd280SERWQ3MwSXk3aFk2MWpvYVVZVTRQbTdsSzlHOC9ISzNubVNHb2llYjR3NzlzRHVLM1lOMlBGTXVJUVl3c3lNNnUwRFZFYVg2L2dXU041SmVIQnhVaC9ZUFRDNGUyQkxKbE12QXAxek1YeHVtVmhmSlJKbUUvbFJVazZ3R3VHemJYOXJsd1JGck5BL0IxcXYzN1F1RHlPdXRZaEVQcTRmMFpmLzMvakh3MU5OMDNoOHREQzdjN1pJbE9pQlhhOXB3b2xJM2ExM1IwL2dkNjZUdHlmSmxzTEdJbjV4TWdWZE5yQjc4RFJEWHgrU0NOOXFrV0RSYjJoRWNmeEdMNHgrZUk2dmlwYlA0LzI0NW5lUkpBanlCQnQ2bUw3bUNrZW5VdU1sOHl0N0tEcHVEK3k2WXZlQTNYeTU4RXVrL1U4emFMVFYvc3JKTGZqbk8xOHVhdlY2eDBzMTQ2dGdMZ3FZVkp2TzR6a3IxNVYvc0pmNDYrKzFZc3FDbWxJWGxOanRDOHVMaUZoRHdoZGNPQUluM01XRkZvN2dNdG9hUGJmYVhEQ0U1WW1Ha29DbGJXOXByVWRjdjlhUHJmRmM1RFhiMklzMzRDVHhEQmxJVlpRTFh5RGVYL0gyQjZQdXRaKzhvaDdjaWFaajljcTE1dnhhRDBETVdqL0dSR3NHaU03MWxGOFBOV3Q0UlhqMVN4TFdnaTRqRDc4TXEwZDQzanpHcWR3eC9sYWMyNDhvbWNWRCsza2VZaStPNFpPOFFwOVA2cU1PejZmRmI5WjByZlhpOEJ0dldmYzVPOWI1NWJibmI0WG5Vd0xPWm8xTDdSaWU1UUtxd1ErRXhDMEgzZFB4QTJqamVyOUE1VnlHMW85THRNUm16UWV0WjF2RU9YSHRaMkJkYjczZmJXRGxiOFg5YmdPekgzeTlTaFFudnhtV0FkWVFVSUFJRjJVTkNJeUNDc3dETllBaEovRUw0SjhBTnBCSkNTQXd4cWloZjJLc0RLcmtCSVVUck9HbjRKTUFwaGo0N016QTdqMVhUbzBEWkpqRUkyNW1lRTlTa2tZdW5lbmprQ0RJeW52OHhHZnMySDkyWTkrUkxRZWwycS82bTNKYzF5M2ZzalNuYkJYei9ialRkcjAzY2VGQVVDcG82ZDV0dnZEOHJvRkJaei9QY29DN2RiRzNmVUJMYWZNREY5ZUEvZFl3L2xyay9zMDJ3MU5ZVGVubVZTbDhzT1BDQTVPQWZXRGh4eXVjUHB6SXp4UzZxNk45bTl4c2F1L2xCWGRqaWJpRlNVVFgvQ3F1cnhqVHc4d3psek1MekN0aHpZbE9BVFFtamdSZUR5T0l2Qm1nc1RjUnNLTFVENmpjTFNGQUpIRmRVV0E2S0tGdGp1eEJjYXJtVnlqVUlCN2RwTWdiTEdLVWg1MEtNU0NmM0hSb0l4N0xGdkhmeGtOdndHUFlJcTRWd2dQeVpjUmpOVGV6UTVCRzhyNHFKTHJMNmZ2VDVlNkVvUHI1RVVuWWtSbkk3alZTcVpjVFFHdjI5YTZ4Q05aS25HQUpmcGpGQXp0YTNuaG9FendZbm85L0pseWlvK1FpcFFoaHUwcVMwRjBjZDJ5dUo1RXVsZEtKSHM1MnhvdmRnbFM2TDVOTTluVDdXcmV2c0l0VWkzaks3MllWdnp2aVZjWTYwREtqTUFWbUZuOTNyMlJleXp6QXZCSFhZamN1YUVXcVZiYmd6NC93bm9LV2hsWFVLc0FwRk9GVHIwVW5SSHFDaEJLUkV4YTc5bkdoRVYvVWRtS0V4ZjBSN0t3UlZLNkVSTHlQQWxTUmdoT2lxWEtHenFvbTBsUDRDM0VGZ1E4Q1hoQmNqdVZUT3BLdmwyTXN5eG9jNGxuYlpnR3FETy9HWk1SL2RiMFQ2SFhyblFudjM2NG82SDRscmVCdCtIb2xqWnp0NGErM285ZHV2M0U3ZW9QQktxWUlRR0NWQk83ZHNSU1c2WFFkQzNVcGw1WDRCR2RZbklBTWgyT1JMQ09XY3d3a2NCYkhyWG4wejJ3Vy83Z2V3d29EL2tHT2plSG5JTlptdys5dHh6K08zMENCTFg0RFZHeStRR1NYL3lhSlIreGxCZ2ttTFVPL1hrQzRLRGUrVlM4b2VoTnhxU1AyckZ3RUZCd2hMcGxzZ1FDNVRBRVJPTVNJay9NVDhVcDFRa0xITEMvcGJ3MlNublhZOHZBOGdIcDdObTI0YjNaalQ4V3p3bDJIRHFIUHU3R3RlL2Z1MjRxMTBFTkZ1Mys0M3k0ZU9uUVlUeGllOVltaGRDS1JIdm9FbHYrdGEzSkQ4Ym5acVZ3Mm01dWFuZnV5NWZWY2M4TndiMmttbTUwcDlRNy9IK3JlQkV5U283NFh6TWc3czdLeUt1dkt1aXVycXV2b3U3cXJxNnFQNmU2YTZUbDZSbk8wcE5Fd09tYW1kS0hSZ1RRSUNZdkRVRUlDQkRZZ0MvSGhENlBuQm93dEd6QmpUbjFlamhab0RkaGFQTS9XR3A2TnJkNkgvUXhybnAvQUFyTVlVaHYvaU13NitwanBFYnp2N2M2UkdaRVpXUmtSR2NmLy9QM0RvNVZkQlNNUU1BcTdLcU5IYnJqQnRRMzRmMGhNdXpMeEJPeFlZMUp6Z0s2aWw4SW9sUHJNQWphSFZNVHRCcXVBcnhsVHkxTkdKR0VhbVVnOWtqSE14Q2xxVVhlUHBnUTFwYTVvUVVXTEdVcWdHRkNNR0pveVV3TlRVd01wVXk1R2J3K2srRk9SVENaeWlrOEZibzhXNzZOMmMvWS9LZG9iRkUxVDNxQXB0eHN4V1k0WmpJdURCZmJJTW1QZ0ZpekFDdFJocHh5cEhrZWtWNUd1WCtzQ3dWRGpLTFlPSnZiWXlUUUxodGVpdEVZRmVHVW4vaXllM1g3VFA3a2t4YVdsU1p6QytXZ1JzMTE2ZEd5Mk9Uc1cxY08rQ21wUmVkMHFOYXRGREM1a1RRekVsbHVxMmxxT0RVeFkrSUpkek5mM1JYS0RDUXMvaFIrMkVvTzV5RDVIOWtycUQ5amdaUFhjYVUxM1ZMZTF5NmdNdGJ1ZndHTWhqTmVqS2lCRmpMRTBLcE1aSnB0c2JZSHQ4NXNzYlJRdW9rcHg5OUdsY201MlFHVmxWaDJZemZYZ1AwY1V5VEFWWFJsS1N3cXFsUFlVVVhHcE5MQlk1cCtKOFh6c0diNjhlTGlMQ24xZVVrd0RDTkQwa05MeENmZ2g3cWM1ekN2dEE0cXVveTNzR1lTT2xMelhUcVZIdStoWW51VWJwV3c0YTJZbE00djhUNEhDNmlsQ3RUK2hTcU9DTUNxcFQyeDFNV25aNzBlM20vYjdMUXZkaml4cUZFZzhVUitYeG5pZEg1UG9KVWZ0NTF5eW1tM0xjdXdiL3c3VEZ4OGxtTjBaRWxkRktoVmhTUWJaRnF6SVFFRVErWlpwbENTallSVHdnUTIrOWYvMGVCNVYxSlRmVGRoUHJLMnR0bEc3M1VaUHpNMXpRcFAzSy9hYUVaVGNER29hd2NHNnZZYWIzWnl4MTZRWmZITDROb2JZQUUwUUZMMnBVcVBIMWEyN0Y0TVR1Q3NnNy92WWhVNC9TeVR1Vmg2V013aEVXeVV4dThEakltTDJ1cWdoSzdQbzJDT1JZQ3lqaStWSkZ3SzhaMWlncTBpaHhReStWMWdvODM0ZjN4ekJ0M2NOOCt4UWRuSFVlZjZGeVhJbjNYbUFBSWNmN0k2YXgzdGZsSnNiUU1MSUhQNnBrU2F2RzN6Q01kZW0vTXgvNEMvd1BMcUd4R2dBVzFPSC91MHhtSVVwcDdOcHRoL0hvOXBEemdwOVBvRi90d0FoUTNuZTJrL2VreFh6eVVPSEdxRlE0OUNoWkY3TWtvdjdMUnBPZElHelA5WHRnbThzMEtDajFnaFVmMlJ5SUVHZW1nNEdrd09UOUpwRnc1SGlWOXpmYlM1cHgwdC9od3JveTdRZGpXSlBZS1BhQnNLWTFyb0xxUkFHc2l2TkxyREZ2dS84azgydjVMZXVIMjdiZzkxRy9NM21ObkxiOThpZjlyYkM1ZGNlUkEvU2RuVDlZYnBSQUhvSFptMnExT2kwcm5jYzkzdHAza2VIdzBTR1ZpTmpscXJ1QU15WUdWeEYzTHpNQkIwVjMrOFprUlQ4WVJMYWdaL01SRjJJK3RKa0dUOUdHcGVaSEhNR283M2EwNVJ1T3dZSXBrSitxMmxWNjU5N1c5YjVUSGV1Wk01c1Y4TXptVzdGem94dVZSL1JrYk9EM1dlS3lUTERUSTI1OXFLZUxKaFlNWTJzd1JrdURuT2hFM3RPMmtrWTVRdm5TRVRCYzExWituZmE3YldYR0NjT0hWcWpaOXlBYVVtd0JJbkVXT3drVVlzNmFQWWF2bGlXQllIczdBdGcrMkt2QWVvTENMTGFteDZHSk5NYmcwVWpVcFFHd1J6WjF1bzBpSHVBZkl2aVZpRlo4bHRjYyt4UDc3K2wzLzdVdTZyS3NncUhlRzg0bHNkN00yQ0plci96Y0s4bDZ0ZjkrTS81dmhnc2ZabU8zaGxaZUg5ZUFxK3JBbDV5RjF5TUc0cGpUbmtxZ0tSMHQrMkx4SHJmdUpramE2UVFpSEtBV2NOTGlCK2VIZVlSMWR0dzBVQmhCUE03VTlERlUyVGswU1JtZzNvVzhoZUc5Z2M4MlpBb2l6d280ekFQSzRheW5zRCtJZGpqZC9jOFJwSzcrL2Q3UjI5TGZiUkIvbHhsRGpEWE0vY3dEekh2Wno3R2ZKbk9wVjQvZG01RDdGbXpPenByMVQ1em9wZDNyVUJBV3ZxSGVlT1h1SWJPdVRIUXdPakd4VE51ODJ3QTczTkRMQjhBVWZXbDAzYjZNZ3BEZWt1SE9DSUVuTVc4ajhqeUZaNFYrWnQya1BhVEkwdXZ0SGFXY2JCY3ZvekFQbFZqcGdDQnpGRkpPaTREUUtQM2pOTXRVbVQyTllEbWtEWkR4ZGZHMkI2Yi9iUWpkU0Q1VlVyTVJ6RlZQZ3Q5TWR0N3hCZlhpM3ZLeEFMc1NUanNMZThwa3BGSlJLVWsxWm91dzIvQUFURVF3SUFZbzFvOVI3ZzRNREM0ZjhRWjRNN1FIdGsvT0FDWkFTb29HQ0JVQisvRXZWbkRuRXFXdVJGNm9vQ0pwcW1lNmt0aXljRllyRkVjZUpOR2x4TjMwUERxWktNa2tnSG5ncmRnY25lY2VFOU5vdmZGT0FvZWp0aS94eTIzcHN2WktUbUZkZ2w0ZjN1d1VObXlGL0lqdVVnc1U1NytJTTlETWZSZitmVldNVzY4TmFaNTVZZ1BDbnRUV3ZocjBBVnZzMzYvUEQxb3BleDdCSjV2cDRWdE95TmhCcWJMQjU4Z0tQbDRLSFBxRjFxRDhXTC9HSWtTRy9WTll5VDFxeGdITCt1cnIxN09WNmE4eXRkSnZCVWZzY2gyZFNTdVcwbSswZG1JOE1vcjlZWmYrVTM0dWUvQjRlSHU1bUIxWTIvOXNTUVF0d0I4Q0hRM25xVnVnQy8zL1YxOG9abkxRUmdTTnRSMHg0aEQ5Z2M2TmI4RStGQ2cyd1IzYlNCcnZrazBqb3hySkVxd3RTSUVTcEM2OGZYYXFuUUE4U0xoVFRXK3d4ZDhUMGgvaDQ3L0JSOE4raDdSOVlEd2lDQytCM3hBSWZHb2lJLzJ4N3ZWL1pTdVA5SjlKdlNlb0g2K3J5d2tydXV0ZEg5Y2p2RkxXeXhJL1R4V0ZUM2FveDFxOVhpQ3JIUnJ0YjBwd1k5NjYrTEkzWm0veG5WaEN2M09WbFgwR1NMRUp3VGxIL2QxdStQSDNTUnlFdzJQMGhGbUZ4Nm5MaWhjTUIrdUJtbWozQzIyMmpENjkxdXBQekpnYlkzYU5GaHRHcUtiVEs0WDZYWVhvbTUxN3Babk9kWVUxUmVRSDFlUHRqY3FTUDRlQTR4UTF6Q2pwNjRjRXlSYXNTVkFXTTdYR2hzcGdoNXFBTDRIdC9IK0JvU2Q5ZmI1enBiOG9sTTVSVW8rNmRhL3R1eTY0S0RXQ3krMCtyWlJxOWR1Rm1BQnV1MndlMEFDT2pwVFVuOW52RlEzK0prRkw5RzF6M1RxOFd0YmRtZ1BiTjJqMi9RaDEvTzlvMHk1OTF2djdMdTJML29wYjk3bXRiRG5kZXpGSFFualJsdHhDV2V6ZU5UV2NEYUxMM2NpYzVvaDF5cWxzZG5jSmR4bit4MUlGT3htSVpFb29MVkN3bDdQam8vdkdSL1hsRDJxYWlBVzNHZ2tRWktwUllyU2I4VzlEaysxNFdCUk1kNXZxYXFrenZiYWs1eFFYWnl4YmpzdTJZb3V3T0syOWJ3QWxkd3p2bDE5bW5UWGN1bis3K00xTXM2TTRsa3UwcURvb0VkeW1VckFBcXVQdWZLYTZxUkQvemN3VmYvMHhIV05rWkltNnJvWkpmQkUrK2ZPRGloODVITVVKekFjR3EzdnVYTXVjLzFWU21tbE9uSTRMTWROamllZ1JKT2pub1QvZm9KSnhNZXVyKzI2Y2N4VEduRjhzRjVpZ2NjRnJNM1R6QzBFdVRnbjlXaHR3Qkc3SzFLQzhHRWtTNGFVS2ZYV0doeStpL1dHNlVaL1p5RkFhemhQTkR4VkFFVEZqK2lva1lkQVl5Ykl6d20rS3RXMlVSeENIYkZNUEJvL0RqMjRTNU9zaEtBY2h1bXdWUHFNSG9ya0txS0tPVTRyNUFtR3FlSjlaSi9uR2tuaDgxbkRUT1RtOXMzbTJmemNOZlhqOWdYWTg3MWFnMWVVTzlTSkQzMTIvMm8wOW9WQ2pVVkJZNFlvMzFoMnhtK1VweE5qaUZHSGRMV2k2dXJRaUV5QkFIeXlvbmpWVUZBaVJnRDFJVlVhUGh4TEJPcVozR3crTzdkdlYvNldzdjJQK0hOeXQ4cis1RUNySGQvek1Gc3JtSVA2YWZ5elBQNzVVK0owT1RFYWMvbThMeURRUlViaGU1c2xFcG5CQUFENFlBUlVhV2FFQXNOU21lRTQ5R09KSzVMaDJQakEwTGduWTVvWno0ODliTmkvZTBqU2ZBTjZxcmpBQ2dNc2krWmZ6WFBjajFsSllzdTNUbm5EQnZvMUk2TFpQOU15a2R2MXRPZ1R0ZlB2RTFuODIrejdaQTZKSENmWTd4UTRydU9Yd0tCbm1CUXpqTmN3UU5BU1FIWUpWQ3BNMTNsVUNMdHA0Z0ZDZ2ttNFNKSEJXaUhNOVYxQmYyT3ZxMXFpUUFZNXNweEV3bjVEWWpBYU51RndFRm5OVGdaOXFjVVplSnI0Q3pWTWkvMUQ2NXMwZ1ZyK29CMkw2SDZQUWc1b29ObHEybC9vWG5EN2N4MWxpYzUrZ0VpMXFUa3I4TWNkNWNaR1hwZ0lWbkt6QStUejlzdXhrWi9hblFKYit6NFlhZS9ieE1veWFzZkhLb1IzMXh5SkRMQ2ZPY0c4a25rdDg3WXRrQTlJbHhsVkExWU5JWXV6NERyVFJ6VUFTeWxkQXJhK2QxUFpLaC9lVUo0dGc5ZHhXZFh4MHYxVFFBVCtWOER4WlJsN25rTnI5bDJkalREV2Jsdk9sbzRQNjl0RGJQUWZVRnRYWmJ5NGZTK1V4SXNiWHYvczg4aFBBb0Fyc293cTY5MmZYRzBmNy9nWWRRLzdPcW0zZGxKelhWOGszc0dpQVZ1WkhLWmZXcDBZa1k1YmEyL245dXF0K3FBbHV1QXIwZzZBenRES3RTZzdsa1hYZHVCcGZvOUNSUHdSUmFrQloxVm9FT2F5bDZjRnJzSUowNEQyMWsyaU5zK2IyYXpKODcwMG5VVkJJYWpUSzFCOFZJdWdTT2MzUE80a0dhVVR6d1RrZWtXOENyK1dlVDN6Sm9KVHpXeUF0ZXNSTllKTVEzQ0NZRlVidlFNczIvZElQeFp2dGs5UllGQXlpajVBNFhocGdRSW15Ykw0UDNMUGp4K1hoSzlEUTV5ei9jK3JxNGhaUFk3WHkvc2Npc1plbzRTTkVBbzVWMURUdldLRjZIMjRCVmREZHR0Q2F4WTlJbWJLR1R2dTJXbzM4U0E5M3RyNGd5OHhtMTdCd0RYeXM4NjVhWUdRY1JXT1ZBNzFQTHNicnhmWE1OY3lwekNuZml2UnkzK0UrUVBtWXgwcTI0V2pyUFpuK3pxK3J4ZXJHN045VU1jUzdqQUR3cVhnLzhFOGpVemFMUmJ1ZURnRCtEZDB0Qk9vYkVQY01yY3NsQ3JoUER2bE5Mbmx0bjE5WTJkc3ZyTktCSzdRRjFZSWlxM1QwdXZTMnkzYzdaRHI5SEdycC9zNnoxc2JYN0c2L1owVy9DUisrQ1Y4V0tVMzNCTjl1ZFZiejFWcHhsb24ralMyajIrOGJLNXhaMXppamxoRGFqZTdFNnlNRFF2NkpxeU1EZmNoNHBLano0eElOYWtYSytQUFhvUVVITDdVZzVUeGxjN1Z2UzhUSitOVG0zQXlYUDU4RGUvNlRlYWtpNi9iY2JnamNZQktSUXE0U3hvd0NUSnBpUEVCTkVDcFdNTDBRR01DVkdoZzg0U2I1SHJzNVNrNVFQL2l4Umw5S1JFdXpZNzZvaDZ2d0tOQ0xCY3djN3lhS3kwM2p5V0dSOUt4TXRKTDlsUFRxWkFZaS9oNVBSNnlGQ3VNNXZCbUhFMkhnMzQ5a0JvV3BMQy90bXRJUzRUUldtaWdWdFpOcjkvbkRZZ0M2d3VQY1JZWW1COGNyeC9hTGNRYVU4TkhVU29TTDlqV1lHSXc0RkVMUGc4ZU9wSWdUczZnTjE0eFhJMUhGWGtrWTNpMGlLOVNMM2tDSUlDWFNGOUFiTlFRcHN5U3VELzJVa3NRRitWa3VCZFFBL1pyb0dTRmpkaDFtd0hyYWlTc1ZMYVdoV2w3anJLVjV5bVQ5ZStycSt0cmEraW5zUFQvNGxHeUFaQnRnRDFIMG5hcjJVUVdlS0hpeENxeDF1ejRZNjZ0cnErM05rR1VraVQ5dy9TMGFjMkpCN2liMmNjY1pJNXM0WFhhSHhQd01odjE2RGFoQUwrOXczWWh4bTBWWXR3QWdKZHNIRWZpS3JQb3E3aGxKb05YRFFXUklCZGd3VTFNb0JwQnpET2hXZ2FCVVJWbVdSQzZZRGM5a3FyOVppaXA3SHF6bnVDYXJDOXEvMVBqRDcvNU5WN21YN29YcmFFdjJMOFFveEZoOXBXK0FPczVWQlA5UHZRaGIwaTAwOWVhK1d0K2dFdjlsM0hNanhCN3ppK2ovNDdIQ21iZ1RLS2FxVGRjdDZKY2IyeHkxeCtwbUpQY3RITkhSKytMVlFJeHc0amhoZTM0WE9yNThQeFErR01jVVdYK2tSYk5hcytIeWpOaCsyZkptWlhVMzFLSjZ0OEdLczFnTUxabktZcWsxTnh4L01qUWZQaVBxUHoyWTFvMnF2MURlS1ljc24rV1dwbEovaTJKZWNyOWJURG9yS2ZQWTFycVE1aVNHaUs2RnNxaHVWWjVScCtoYTQvV3NvcnVlMjc0MFBEUXdXRWlXOXBGamxmaE5mdnZzdE5aL0ErdERoMjg1dUF3TVNkRmo5cm42Sm1Vc3IrWG5kNHpuWFhrTzJ2RU54QThnUTR5MXhPTnZET2R4a0M5MVpIa2RIYzhLWUpIVnNUc0VIWWQ2UTh4clNMeVlUSW9oWDZvUFZpQ1BqV2xBK1cxSk1UU01XSEpnUkJlRHlVTEhOdmt1YTlKSG8vdThkd09RODRwSWlublFrbEFnUU9JRDExZFZ1d3B2WUtwMmtCQXA1cEtBbC95ZzVEQzhVMldlenM4cm52cy8wVGQ5YUVVcGd1VG9Rc3RlbUZaMVM5SUNtbjMxNTI0M0RFbVFiRFJHSUVxSlduM2x6b01DZTdzUnJpMFNlaTlBWkM5eHgveGZWMDk0NU1xUVZDQ3cwMmQxSFJYdnZ6VHJqYnpkOWJXZUpic0tIMEh5di85WC9nYmZhaXp4ekdtZzlYbUxuakJydVNOeUpPRVM5eXZFSkdSNDRQZWN2Q3lrSCtycXhuWHhoNG81bDdwYVdXN0crN2FSbW5rQmJ4S24yRmV4YnlSK1FEemgyUVA2NFN5NjBUM0kxa3d2V3JvZEM4RGxBTE1jazlFYUFZc1hDS05CV29DQnh5c3M0RkphYlpCUkJONGxOWnBNSERpY1VVYzJERUpBQTVaeFBvWG5oaERRbzZFYzhzUjkycW5TSU1BN1VPSlJzN3h2elNKWUFOOUpXSDZTNW1CdUNrSVpuekFLdnJOUk1ydzUrTEpSQ2pzTVFiOWhpZVV0VElCMWZDbEE0bHdLSkdNNS9JUEJVSkdJQXFIUFh4eEl1S1I1SGg5ckI2WEpVOWtvbmdpR2pCQ0FUamNKOHJadEtGTGlwRUtvQ3M4dXB4WC9FbERIVkI4V2xUaEovSUR1d2J5RTVJU1Z5VGRTR2RsTVpCQ2hVQXFuYXRrd01RMVU4bWxVNEZJYUhaYTErVm9aVkNQOEp6bzhZZ2NyK2paY0NVcTYvcjAzT0QxNlZBaW1zamdRL3g2YXdENVFpT2hzSW1aN3BHUW54MTRRenlhQ0dYdy9WRDZRN3FxUndjTVV4V2lBOThrbWtOeVVBUTFzZGVNeGN5OUNieGNQQ2FvcGpFUXhVWHhrZnE2Mnk5OWlXQ3pKSWxsQTRPNmdTQmNheGVUMnJ2aTlSVkpEV1EycEpMak1ZMytleUZZQzA3R3BaRDBGbXJSOGNhdy9UMHY4bXYzb2xiUWZ0TXBGZm12UGpoNTlhU1NVSW9LZXFRUURFNG1KT2t0MUNibWpTSDdlL2RxZnVURlpXdjJhOVZUYm1GY051SEsxN3M2Z2xITS8rL2FRZnh1TU43RjFXV0pibWF4cjdyYkFrWXRhVm50T3pKUzVRUGYwYlIvS1FrZnprOG04Z2xXd3ZUYzlvaFJTVTM3emdGWlJmSjM4Tk0vRVVvZm9RL2haeVMzWDRHMjlqSUIzTGZnZjA3N0VDeUpKSzYvSTcxdW53V2hRLzlIZjc4ZDZYUVN2aHUwRnpaMUZPKzhhdzIvSzBVOG9jaFhsTHFmalh4RnFaYXY1UnNRSGdsLzMwVzhMVlhEYU1PbnRGYzdIKytqbUlMOWJIcTlrbDlQZjBiSXphWEZVTDZDOXZWOVMzdTErL2xlRUlUUHBOZnpsZlgwWjNuOVRXSjZMbFRKMCtLMGtyMTFCQnFwdExHT1BrU3F4MG1Yck5xOVVLa3ZYcXBHcjRmSzJFOXNyb2xqQjhudXdYVXBNR1BnTllaRWNGbVc2bFRxRVRFTmQzK3NkK0V5eGxEQjNTUUo5VzNVcVNkM0F6SnNlYUI2N016ZHQvaVM1V1JBSnlSVWZuQ3l2bmdvVlR3NEtiTDZMMTZpUVpiUTBZTzdUbDB6Tkw1cjhjb0Q5WkdSbVZRWUlWbnhUc3hxZWhtUE1GOU1zRzhGRW16RjlBVTV6aThFQitZbHcvT0VFeC9xdi9rNFlRSnBxaVJuaHd3dk94TDNDb3lBKy9WNTlCYThQb1B0YnB6Smc4VlVZek91NXlaN1hvaFdJdEZnYlppbWFqa211N0Y4ZmpLZi95OTl1WHlhNTFqN2oxZ096dWdFdTA1bC9CK0VlNVA1Ny9UbDBBY2xEdk5SRW9kWktqSUh3QmJsSzNoZlhvRDRNd1dUOGl3QXZRQWNXUVlCRUlCVWtzekp1a0NwdWhKeTllNzFoaE9aUElQb3VpNlZUSUpqSXBraUtwa3plL1l1ZXd6TzVEenFYV3BJR3ZIN3pHUis3aTV6eit1UlFtazFPKzNvM05PNVNGMFcrREVoNUxsVjFiUFdiRDFUVDZkdkdUdG9EWm5sY0VSWGIvV0VoREZla091eWFnYjhCOGR1S1kxU1VoRDlWMGZKL3QyQjBSRXBoTi9rd1c4MDFHdXZPcmJZc0dZUEhyN0t2R3R1bjRzNTA0dHpkOFVPVnFvT05xZllkWkZ4MUJEQStKVWFFSDRISDNWMis1V3JNZXNKOGdsZWtLTHhDZnhSbFVWVjVieWNYNzJpUFZEMDJqL3o3c3FOTnlKRHNRYmFmYy8ySzFuYXk2bnFvaElVUXhQeHFDVGczd3Q2WmxYdm9jWGRWNmgrKzRlTjJGQ2tYc250OHU2NVp6ZFpsMTk2OGFVdm9UL0QzelhEekdJKzV5WkFMMnBBQzRvTk0wSlEyU0FlQ3dWQmNSUU5lQzJ1a01CQzljYmtoRGtabGtMNWtoZ3lHNU5oTXhTRUVIb1JTU1NCdGh0NDNSNERaVldJZ0txUkxZaXFhWExRUStSaVQ4RXY0cW9PUnlMRHVCZXl2T1RaclVhVXBhaHBScGVVaUxyYkkvR1ozV2crRWc1SDV0RnVsRVY3dytHOUtIdUx5Q0VBRVVhWUNkQTRSZUcwYXdXZUt4UTQvS2s5WERvVVNuT2VTVnlHQzRVZ05EMitsa2h3bnR0VURRa0hEd3A0QWw3cE1jVkJrWk9Ycmo5NTh2b2xtY01aMCtNZG5MOTZaZVhxK1VGMEpaTG1icHlWOEJsZEo3SXk3L1B4TWl2eVNQRG4vQUk2QVF6RDZIMmp3SU53L01ESmt3TjhSZVFVTHI0bmpvKzRHSjgvbWVjUjRTZHNvaS80Q3VhN3hzbDY2WXdYOElEcUhUQ05qU09HdUtxajczWEdkZnlxcVo3aDYzbmpIV2QzTGVyMlBqeDRqNTRld09OOWRxWjFNM3F5TTVlbXJvcjNUSmlGK2R2dS9IWFZzT2Z3akJrNGZSVFBzZGZjZk9QMExPUDQxb09NejQ5NWVjdU5wdGJ4WHVyNkxvbkU5UWd2OE1ST3lkd1lFZ1NUZ0FRUGhIcDRuZXRxQ1NiZFVGdnJ4SEhvQlBFZUFndVlUK2RuUDUySEZGckZwZGZKRStSa244K09qMmRYckhOdzhqdVA0SU85bnB2REQzdzZNZm5wQktRNm1DM0VYMjAzOGRIT2wxeSt1K1JnMFVDc1N5Y0Z1RWdnWGxwRUVhcFFtMXpzUU9vMzRCTk00UjBrTCtVQlg2dUVUNlVxckZad3FsSjR3RHo2eTFmbGdIUExKbVJmWGZkelNTdGh5YjZ5MStDOGZyK1hNN3hsbjR3dkpUbS9YdmZKaVN5VXpiMXFPRk1xWllZZnZHVXNWd3hHczRPWllEQXptSTBGaXJteFd4NU1SbE9aV0J3eEZOeDBVZzlycXl3LzZ3MTZsN3dXL2g5QzNsbWVYZFhDM2lvcDBOUUR6WURlV2x0RExNc2ZiTjE0Q1BDWjF0WmtOYVU2OXR5Mmc0RTRSSGJGdk52NFBEU3RTQjJpU0JkVXV6M1FiWGlldHJwS21od0JNNUsvdk9tVTdLOTcvVnppY0ZMMmwzRWlHT1Q4M3JKZlRoNU80RVRkTDUrNmlUYndmdHpBdHcxQTZ3YmVocHQyZjM1c2JBQXhuL2FHdGQrdFlobys1RzIxb0QzVjM4V3QrYlRiam1icnh0MXJhd1NnaysvakF3dXdDMjdQQlJhb3NDMUNBdTFTTkYyaUROeUc5ME9IejJ2UnFIWmVXeE81dCtPbDQrMmN1RFhuZCtST1NkY3Y2THAwcTVTOC9uZnhibmtsSmlHUHNHNk0yaStpcitLNXJJUFA2eWpFcGNXYlF4bzFDbmh4a3dTUjdBc20zZ1hSay9hcW5vdWFlTGxyK1QwZXkxNlYvUVplcU9YdlgxQ0VXTWh1QmVLaWNrR3hyTEVMUEtZb1Z2RWlkMEVJdUh2UUducVFZQ29ONGg2WWNYVmt4UDRQTkhYVjJnTHJDdHVsZk5pTjVwV3ZaVXRPTU51OGMwWm5iYUp4bDR0N3lsWjVUeEdDVGdZc1l0OWxvZVlLSmtmV0lWU2xSVlM0WU5SMTQ0MWd5a1d5VFl2YWNsbVdBNGRNanowMlhVNzhvTUlPYktITmJlMjh3SDc3SmlJRUlSSFJPc2tIdHJUNityTk41U0RwMmM0QXJOLys2OGpsMkgrVmRtTGh2Vk9ic0h1M2J1TWw3TVBFTFJ2TGJMSVZ1L3J5cGY0N3NsL2ZrV2FndFUzVGRxSXcyTE5kQS92dHlwWjJZRmUyRTRYbHRyWm1XelZBdW9qZDJUYzNWN3BqZytiVU8wL3hDaTVacDg5OGhUejZGZmlWYnZLdk51U2RKTm1ydjB6a2czbm1FSE9DdVpXNW0vazE2cUVOdEFNSlk5ekJyT3ZnVjBHK0NKNS94QnVUWUFoU0R6cmlpUTBHUlNHQ1lVYzJlV28rangrZGxLYUtZcmpyd05reGs1SW9WekpaUi9zRmtlUENWaTB6c3NDeUpzZUpBaXV5Vm1ucHlPNFNRbGxXUER0LzI2NTBhb0lEU3Ewd1ZEMXg5cnJhVUFFSU5tNGlsZDUxR3lkSjNrTmVTV3BibGlXSm91QVhSRkd5S09peFJXMnQzaTdMSEo4ZXlFeWxFVHMvVXJKNERsOUFYS2xhV2lvV2R4ZW5Cam1FZHUyNjdYVlRreW1XNStJY203aHF2UHFLS2JaNmJXMzh5Z1NMci9Cc2FuTHFkYmZ0c2o5b2pwWXJsZktvT1RJaWk2SWNIQ3FhdU5MRm9mZFRnT1lFdGQ5eTQ1MEFqeHZFL08wcDVtM01ZN2lIZCtnUDBZRGRDZmQrdFU2Z2hpWW80aERaUjdOVVNMYUlxTTJTa3lENGpTVmdqSHpFOXh0NEsySUJSSWMyK0pJVklmNXhxVTRpTithSlR3UHdGa1UwM2V0TjhYQnZaa0RQUm5CUDhabEFOcFlOK0tOV0xtdmE1eU81aURldFlyckNLNGQwanorSHJGakZTaHNaSmFacnZKeFZWYStacU9YUnlzQlVQS0pGY2NsQ25OWDBwTFd5aHVscW83NVFOemgrZlh1L2pMVmd5dklvR2hLOXhYVGM4RVV6TVdzOG00dGtkQVdQaW93ZWpFaThKRWdSYlFRUDBVRDJPcXRrZWhYT0V3bU9HYjVjSnUwWlN1RHBNaEFiOHVRWGZNbXBBU0VlUy9vRDlxckNSeE9KS09BUzlNYmJ5UkNrb1d0MndKM1ZRUnI1cXdpNlErWFYxNWo4OU5HWEdYbUhyQ1UvU0Y1UjIzbndIYnFlQUVib3ZCdGxzVWZON3NTaEphd2F0WC9yWFdrMnFLSFFsRitRUG5jSHZPS09zVkkyd3l1WUtXYjV3ZkhDWEpZUXRMa2hvcEFBSFAwVlNWajRBREV0dVNNN0d1Sll6Z3ZjVTdxV3ZZdGMvQjFKOERvZVZrdzNmaXJJWVdxNHlyQ28wTTBlNExDQktKTmNpemFRR0ZOcGdHVDAyMWFpdDlZV2xsNzk5bnVYRm1vTzV1eFluV3pqOVRFS1IzdXV4N0x6c2R3OXUySEhmL1ZiNzhrQkxLMmdzT2ticDhuRy81cFdDdEJsQmZaN2lCUzNmOXJ4TjZBMFZSNzM1RzdpSDFqZHdnOW93M3JkcGJzNlE4eFYrV1NOYkNOYnk1N2QycktGYzhpdW9CY3gzaUJRWFpPZ3dTUE9XKzJ0N1ZnUTlabTFWd0Z4QVF3aElXT2hsdFhzMk0wK1NPeDc1b2h0K0VWcTFqTkF0a3FSZW5jSXc3NGFudXdHWlhTT1RwM1IybGFWYXhJUldkOFIxOVpkUDZHdktVTEFsYmkrdFNrS2VveHIzYk1YZGlMZFVJc2NNNXgxMUtSZFdIbzh4anNGWVVLN3V4Q2VUck9TK2plcVhwN1cxV1ZxTWJxczZ0UDJVMzlSZzc2bUdsTnFUOW9zeG1tQmVERkpBY0FSYzdlS245ZlZKNmZManhDN0w0SVQva2g1ZXJYMnNmV1dSUyswNDBXYUtNYjlGSlRKc2Zta3VtK1ExZFh4ZUxwK0sxbGRnZFovd3pqdnN5QWFReVo4TElqVDRrUnhobDhaZG1YM3J2WERvOVNHTit1Z25UOE91dC8xcnBhWHBWMlAyV3g3N1lYc3VGMStFNFJ2bm95OEhwYWJWNUowaUJYZWhVczNxWlZ0bTRLZlc0cDBIa1hoUit3ZXJmT1RtUHRlV3gzUHZ0Q0FVTTZZT1lCem1TZXY2UExhYTh4cDVqTmtWeFFwTW02REh1dU9EQU1VU0M1SUp0d29HWTdpaUdoOHFPMWpEeFlmMFRYVnF6VkN4b0RQWHFSS3Bad1VoaE4rRFhQcmVaRkV0RzVRdTdZUVBKL1A0VisreU8rQ1lKZm9ySndJMk1UYzhqK0NmdFhuRVNRaEZKMFlXREFFamxWVVFScTI4dEc0eEtzeVl1WEFkSDUwZnJRUVNaQm02MW80N2xVRlZsWjRNWjBKamszRVpWN1NCSStZVVgxNnVsaE1LNHFvZWlXdlhsQWxKVm9PV3FySXNTRmVIajA0WkNyVi9ORGk0RFFQQ0J5R0wyeG9PdDZYOGUvTUZoZGtXUzBvS202WVJ6TkNtbWROaG5kell2d09oUlYwdk01NS9ZcmZseTRFUXBrQUhya2F2dUlUT1kvOUJ6NlBubElWSVNMaTdWNldORmxUWkVIUkpNMFhqck1JcnowSmM4d25jMnlZbHliMmpMOUY0Q1Q4dWxJR1ZoaEZsTVdrN1BNbEIvSXphWTJQeUNpcVNmSUlybjVFMHZCV3JzaEt3RzFMVVJia3FleUl3UHA1SVJtSzZocm15RjNhbG1Na3h1T2dubE1QL25HbXlqUVlwbGF0NWMxcU9OL0FMQ3FteUt2SXlRZngveXpKVTZ1dUdzUUtBUFdBWXhpeXRtYTEyK3R3c0Zza2JUV2JxTmxzMm12NDNMSXdmZGhxV2hiK0IyVld3ZWtmbDdQYXFOVnN2c1EwY1hISWdjRmFOOGFLakdjbTlRMTFaZVlRYnEwMjRlSm9UeEZsSjk2WklKSlNUeUIzTW00bVFpSzNyWk1zWWpTL1ArcjM4M2cvMVpXSUlhaTZMeGxPYUt6S2UzbVdDd1JOYTNBYWJvaUs1TjB5T3N0ZDhIalVINVdFZUVEVlBiakQvUjZ2N3NQN0xPekpFWTgyTWhBelBQaUdCMit6S0xSbHdKYU5zdW95eEltNlpFeVdsOWNYMjh1dDEzYmVGUmVKMmZMenkra1BCLy9pRGNTZVpEZmdlZ2R4M1IxaE1oajhSenFvdmdTMGhkRFNsSklHUVdhOTAyWVFXanBhbEVhSEVlN3BrcHkwb1V1NkM4dlhwNC9qU2U0YjhwYzB2K0dWRFR3MW8xb0kxMUR4QjZaWHBnTit4U040bzk2STVvdkhycDZpQUNwUlJkb3JLVUV0RlZOOFFXUFVyd1Y1cnpna3NIdzhOekF4c0RjVWlYcXpBVkZGYTJQai9xTEgwZ1JmMktQcWVQcXFramVBcVdndEpIbHBySmhJMFN1Rk5JR1RkVFVRU1E2TUZBZUdiSXM2OVAycENoMnFad0txRno4V2l2aThIaVVxZ0llbVZ5Z0Z3N2xrSmw5SytJTXF4RXFCZmV4TFpCOHJNTFBNWHVZb3hIM3EwUnQzck50OEtPSml6WU9KUGVZVEVaamVFN0xUUjNDK1FQMGpOaHhObnlqaFBuYzRwTERidyt5YlZGYmtYaHpsTmI1U3lOV3pFVXdsZXhTcHNlZStVdGIwS1VkRWpoOTlrYlBib2Z0V2tLanM1WGxoTEY0cDVRcDdaVzlvZmlhSjJjcTlDSEYzOXUrRWY2Sng3Tk16Z3JCUDB1TEdhTDVhR014eWdwS09WNjE4aHRXRTZhZFp5VDd1RHlSU0RVNUd5bklScjYvWFpKSkQ3ZVV5eHgzblJMU014cGJHeDVmRzNwd3NwVktscElOTnNzNW0wVWN4blRYSkhNYjhOZE0xUG9maFJVUnV6dEJxRUFJWHJFNkE0ZXZhbjlSZXhpTm9oVXlOU2EydUJ3cG1xenFSNUY5eGpheUp3dlhvRmZCSklTYlBDNWNzWXBIWTQwTUJJZVl2bWlraHVuL3BsWStFa2s5ZC8wQVlLWEpSVUpCMVBTbEhyRVYyV05MQmE3R0lmYlhUSjhFT2x3RlRKT1dJRDV3SUN5VFVGN1N6RndBbFhMajhSeTVjc3IzSWYra2lxLzl6K2dUMDRBK2hyekVEeEU2clNTU0xUcUNBb2lTNlNoMDhSVXFFSklGb0FXd0pWRHNOQWc0VE1jV0NqaDlaNE5KRUQ4MmVUYlR1bVJpYVZueFZENjcvT1k4Z3ArUzQ1NXlPWnFZRjczaDJyajQ1eHlkKzhUZXBWNmNNSlJYQXE2MWVScEhoMHl2RFl2V2EwMWNPQ2JINENIcTRtRFR6NldORGUrZEZsdVdPeVhGMUNQL09NYnhLSUVGVWl3TTMzbHl3YnhnNk5wVFJzd01SekxtTDFYUTRQSC9WVmJ2Q29WMVhsWWN6bE1lbWRrSmV2S3VQNFRYaFdtcTlTOFNHRW13YjRJWHRBQXcxVElpVFRyVDdvQ2wwWlBFTnB3RFhZNXdWcEtMRmpVVXhLeXJ3MTRaUDNJaTN1WDl2cXZGZ1hPQ3VpMXhqQk9OcVUwazFXUUVUdDV3Qk40d1hlSUh3cmpmaVJMenZQbXBpVG8rLzBieEJzdisxcVFUMEVmN0c2S2twUGFEZzUveE4zQkZ0anNYRnZnLzNwdXlmODVTSDVQbVJUVVVjN0pWT0xOSkw3cWZieHhUZFBsNk40OFBteWpFWW9jZXlGTjVUNlBsOWtIaHUvMHYrN1dLWHVPMW9PejU2SFc3UmxRVndQZUN0OEI1MjVSZmtEYXdqNy9nRmtYZXcrQzJvMVhWMkpPNHExTitSeXFEL0EvTUNBdm96cHNRY0F5bGswTmt1WVp2QTIzR0Q2dnhoS3JoWE13anZ1aUxxYUQySkMxZGpJeXdQNUFGSXFkQjFiK3VxU1JjUmhDM3B3V29hUTM4K3dsS2Z0SkhBNG1KZ1hNT2N2NHpwNEFnK244Wm5GcDlyNDlyUUVFclVuSUkxcjV5UDNsNmdoZ1Y0czlsTDdRTUt0dy9VTkxzd3ZlVXZUSWUwMnNBdE1BUnZpZVpsOUpiOW1NRGhPWVhmbndxSFU0ZW1uR0tubmNmZ2NlMVEwT2V6N1d1Z0lIN3hOZUd4VEpHK0NMOFBYZ3R2TDQ3djA2L2Q4dWxyTS90b01PM01HQmt6WHlmMlhXTUVTOGVoVjZZV1VaL2JJd1V1cEhoVXhQa3hZb0pCdVE5VldTYm9iZU1CWDU4K01IdlRMUDVYUHBUaUZRanVrajB4VGlqVHBhRWoxcVJLdkpiUktzRm5WR3REc3pmZGQ5TnNNc0hoZ2g0dW5TTVNta1IwRXMra05wRk5VVnA3eWtYM2NkVTZwRExVUktxdk1odWNqdEVQTU4rVnZmZnQ5KzdCcng4L2tlVTV3Q0ZOSFJ6RTladTVlWGIrbFlsN29iOVhRUmovbENUY000UEx2ZjNWUzdrMHJvekVjL0hVek0yNGVvczFBbkJLeXJuNnN5N21UWjJzelgxeEx2cFVVVVZBS2lYZzc3ME9LVFJNVXdsa2JkUlNmMnVWNHF0MUl4S0tuajRBYnpjRXFWcm5wSkFrM1RnMWJNS2ErOVNXMnNVL2lWdURTaW0ySWdrL2djZk8zQ3BxYnowaHFJbXc2ZGpLZlpsODV6eFRaQTR4UnlBMk1BMnFSdVFsWGJqZUZMRkxKdWlKY0EyWkVqSGRvR3d4VEtzKzBPQjVCNWtNTE1ZdWlwbGZqK1RtOHF1aHVMb3N5OHRxUExRNmZHZzR4V2tnd1M4dkx6OUVVdXdXWmV6VjVlVjlXMExlUDVBdDVlZHlUVDNnV1ZHaXlvb25vQU93OXVTZ2dQY2tUSllOcjZ3a2FKTGJ1cUQ5cnlzcnhoYW85b1FQZUJyMzFaZVpRZVpxNEFNS0llb1JTaXlRdWtGaUlFOWIzd21aSlRnOXVnR08xNEU5Ni9ZcnBtMHYybHNzZzJ2NHc3M1VhUEltSHY4akpwRjdmNGdiRWdPakU4N0RXL1pNRFBmWFZxWHd3eGJ2Z2I3OXd5MjdEdEN5OTlMQ04rTVY0MmI2QzN2eHJ3M2xlR0prSWd5OUpRZVF0MXVVd3MvV2h3VEVpNXlTM2FyN0hBeVczckgycXgxcGpWOW1MUDBxUm8wam0rNk9rZjhwSStSWE5nWitWVi9iMVEvL1BkdkVkQnlnUitFVkVDRGk4TGNCT3k3WVAxMGV0K1IrdTBVVWpuU2lqeEZWVXlsY0FHTnN5YVE5ZGZzcTNoc1dVeGxONTMwSnJSd3hyNWs3aDdlSVZjVmFQVEsra0MxRUErbVE0WjhZdk5MK1BpNnBmdjd6S3R6OHhpcmVLZzZ3SHMvVXBHNktjcm80T0g3YlNJWTdpSGNpWE1xN2VoWXAzblIrWWFTUWlPd3Y1blFQT3Z2NVZVWDUvT2NWdU8zNFlueVJ4UC9PQXA3cGRxM29iUWV3VjVQOVRjazc3bU9lODFvMmVxSllTUWFoRGZtSU5WWStPbjhtbXRYT2UzTG5lZldteHRIQlNpeG9SZVBScGNwdEtuK2VmZVlwelRST0lrVnI3b2JxeC9QVnhTdkhCd00rZE5Jd3RhYzBLL0lVeHdzUEtGcStmRVYxTUJ0OXhVakpxendnOE54VG5FaDV5WjlpL3ZvUkVrdHFsbXB3SE1FMjBkR0hOK0xGRXpPbFdoOTZla2RLam9raGxvaXpYNVJGVWVHRS8rZ1o4cWRYVnAvYmNFbkhSWkVtaS9hN1YxYmFYMWQxbnloemE5MXBkblo1dUM4UEpYNjR2RXpteTcreWIwYVA0ZjZHS0RwYlJkdWlsS2xMYklEajY1YmdpZzQ1VzJMZjBEdE9meTV3b0h4Rm1xclRVZnd6VHZqNUZ1T1oxbDQ4M2pOVlVJeVhTYnl1NStrMFN2SW90bmxDMmM5RElER1lBMklucHJqT0pER1hOc1hzSWZMQUJ1Rm13bzdlajZBdWxJcHVPTWJxWkswRXhFQllDblhTUGhRQ0M2a2dJVGNsVG94a0tjb0FrZXNISXpEcHVLd2c4dXdJeTNzem1OaERmSlJIZU9wTEVaN2xBendyQm5ER2p4ZDQrMGZEUEhzL1l2RmkvemhBTHcvanNvK1Q3R3VSZUI5dUMwVDYrQ0RIbmhDRUV5ejNBRi9oOGI5bExzN2hmL1lxang1Z1dkWitKNGpwMFdzaCtRaFAyZ2t4bm1BZEx4UHIrZ080bFlCcjZJck9PekYzTVorWklhS2NNSTNsTkkvSTdCRWFWVkV5YS9qeU9KV09WU2ZON2xvZ2JzWVFSajlocGFSZlQ1dzg4V2JGeDEraEJBTlhxM2g5Mml0SVpzVHl0eVdseFNJN2Y4V3R3L2szTFU4L081RW9qazNNelVaVVBjUWpORFY4ZVA0QkNuOXNVbTl4OUFtSmxSRGJrdVcyM3dwSEpXRXZYc1BVcTRNQjVRcmVwN3o1eE1tRTd2L1A3ZW5sOVp2eXc3ZEdKL2JPSHg2ZVFvZ1ArWlRJN056RVdCR3BGQlI1aGZxTlUzdkdYcm5vQk82UlV6dUk0Ym9wSUswSlF0SXh0dVF3U21uV0dUSWJyMjB2SGlVY2s0NHpWR0IxSGhQejNPeVpHYnpKaTgyNzkzRFNFYmhRWEN3SW9peU1IaDduTGlJa2ZZRmFqMXRVZDlPUytKa3pzeHhoRDdnOWR6ZnhkeElLaTBYbnd2amhVVUVtKy92ejZHbkhwbndZNG8wM05yVlJvSkhPSFBhUUJqVnpJcnhESytsbGFDVzV0a0xiRWFKaU9IU00yelY3MHkzM0F4bDcxNm5yNnczNitrZTVZdzhmaFd2NzdqOUFyN1FjaFJOVlB6MSsvNjAzenU1eXFqcGR2KzdVWFZENDZNUEhuRXNIN3Q5SGRMWVVxd0xpZVZYQWM3QkJkV1A5MWpRWHdYUWtRQWJ3d1g0eWYrVEkvRHNGaVVRWk9YN2NjY0lQQ1JKRlhMaDl0RllmUGJ0NjRMNTlrdkNzSlBnRmFWWVNkTGM0U2M1K2UreXFDdUYzbm5kMThiMEJaMEJZMVdWdGRCZk1uOXBoMWNkZGJCZGFMUUxvRHk3OE5nbHRlekEvb2Z3K0pQNklteHBleHEzL0pDOUVaRkg0WUhUMkNFZXE4QW81Z25zWVBleUhERDZrRXVSVUdKWUVuOEE5emV2aXgzYzN5S1dzMmNHem91UGZZTUs0NzJid3VnZHkzWHovQkNnQkxNR1dBQkFSWWlDMmVkcC82cmdlc2w5MEIrZnFXamVFamw5WEw2ZzZqeXU4TmpBMXRUdzFOVUNuT0ZvNHJuY0d0QlphYWJYc1I5MGhmUllVcTJkWjdqZ3Y3WVZIbHFjZXBSTVoydUFsc2FaM0UvczJzQ3FZWVE3aU5lMTI1blhNUTh5N21DZVlUekNmNzBnMU1sMUZjc09KNzlhSkdGU3FiUWtlc3BFUnJXN0lTNWU0ejdrL1YyMTBVeHNRdHZxUW80eE9zUnFKZUk4WFNTRkJZOGNtQk1XMHFFT3ZoVnIydW9zbnBaaHJhOHNyeEkwRUgzNjlrM3BvaTJ0enhJS2dTUlhCMWs4cmNCME9ON3M2WW1FSjdndW9wVWgvS0FtSlIrR0RQSm9RY0ViNXRQVUV2UEVKNjcxdFJXcENFaCthVm85SGNmZlEzT29pZXFDclBaN0dKZXdYeUFaRmJ2ZW1vUVI4VzJYVHQxM0N2TWNwNWxVZ1E5clpOMFViL1NsQng5anA0bEluVmZqVmZKTVhPbkdmek5YVk5kckpUZHJsYVBwbGRqYUE5L2E2Y3ErajM3Nk1ibFJmK3Jsamc1REduQTJzajh2TVNlWXM4d0R6Q1BQYnBCY3BlRDdWaTRHTmE3WFg2RkFFU2c1RWNsV3lwVFZnOEpJd0ltampRTDlFdm5TSi9NYnk2TnhMRElDUTV3K3FIcVBoaVVla1hVdWhKSmhIMlRhdjhud0RrMUxIN3Q2dFNKVkNvdmtDR1ArL2dLTG5vZGt2NzREYStHMkZPZlZOUmttMVJLL25iREpVSVYvU1BpdXpGdWNWSDZuQVlNZTdrcjFLdnlJeHhXbDMwM2FQcGNWYTkvSnE5MnB2Q1ZmKzlIWDBnaU4veW9FM1puQmJaYkswYVVmKzZkek5XNmlNbDV6b2kxU1hDTkRKVytpRXYrM2dEbEpkb01zSHJoSGEwTWVNZ1U5MVlTUGVIcVh3NXhHUjA3RUxpTVpVcUlJeGZZanJzOU9lSXZnMWNQaXFoMWY0QjduVWdmTDBtV2wyNXNaN1R6ZVNjVVhnSHVUYjQxZTJyaHduaC9XdXdaYjlQenc4TGk4bzhXVGo5TDAzenJENHNmS0JGT0lmNUJXVXFqZ1BqRi9aVzk4ODNyV083Y3kyL0RMYTBDUmJ1dHpkM1dueUN6dHAwSXViSG9Pay9UYzdiUnZyWU43Q25NVmpRZ0NtZzhhMDZBcE53eDErc05DSHdmV0xCM2xCamFlbXo5eDdabnI2ekV6NVlCSy9Vd1h2dUF2ZFYrUWU1Sk1IeXpOUUFoZEx4VlZvQUc2WWVtdTNFUTYyOUxkeFBaNGtkR0dOMmNkYzQ5Z1J0NWwzQUpaMm5ZNUpxV1BTRkpJSUlHOXYwTGRHNStCUXoxM2xBcUV6aEEwYUI3TS9QbCtOYzM4ODd5WTZ2bzM1VHVqSEJ5aEpYNmFNd3A5cStBOVZkOURVRnVDVDU3c2FHRVhwMWNlczBOK28wOU9odnRNYVBlbjBiZTJBcmdkV3lJR2dJV3pJa3VEdXhCSENPZVBEYXVjaXF0QWZvZjllNk0wUWVlWGY0MzJ2STVPQlNBdTRSMFRYVkdxQlFQb1I5bXlTK3JSUTU3dGl5WVdIcVlIdlRxN1VLRGt1dGQ4Q29jeTV1V3ZNU0ZsTCtIaGR5NlFXaVZCbTdjckJDYjhSU2dlaWhlekMrSkhWWCt1Unlmdzd5R1FPY3BtUjI4WUhpMmxaTlBYSktZK0hQVUJsTXA4NGl6eDZycmcva2lpTUxPVFRYZ1dkWFRYN1pETDkvTlVTY3hpUG45TTdzRDJob1ZFb01ETXhYQVZwSXgxckpTa2ltVGhaMmhUK3N6TXF0bWV5bGdHRXJPNExBWlJZeUZjSFRMTHN1REVwaXBQR2VIYWFmdHNQME5QYkhKWnpXeTdySlFaK1JSRGlHdjRWTFM0SWhJNGx3Q09CN0lmb2gxenBPM1hqVjRLL1ZaWFpSV0pvdUcyRkZhbElZMDEzV291djRQYUdKSlBvUkRvbU9jTG1KcTlOcjB4TFovUkNHS3crd2dYOWpFVDhlVW5LdWQ2aUc0TDkzK2paT1Zud1FEQXc1elB3QTRadkxoQWtyc0NRS3BLcjZDVGRJMWI3VG01TXl5YUpnVlFsWFBNbHgyaHU0eGcxSmRmR29jdGJRTHNsRW82NU8wandzc0EyWUFDL2Z2RllLcGdoQTlqSVpaYm9BTDU2c0I0TWg1Skd1SlRkWFRtMitnYU9GenVzeE1jRlNlQjlHc3QybUFsazBrR2RINzFwZWl4andxQ3UxandxNmd4cTFac3JIZ3duQjBZWDgya054dlJ6TENkSzBvdzdDQ1JGUkR5UDNIRTFLVHErWG9ST0piTEg3bXpkcmkvQTkyd2ViZWlQS25WTUM3RTFFRDZlbVQ5YUhyTWllV2hzTUZrcG51Z0lIMityTEVYalVTc1lxd3dlYmR3RXdzZWZVK0dqTHpBNGZ1VmlOUitIUnUxdTRzcjNDeCs5cFpGWFJMT0QxU3ZLZWEwamZLUzhjeHZQMFNUNGp3WHpHNUJ0ZTZCU2lwUnhvVHRyc1ZjUEJyTzRUVmxsU2JoLy9xZ01PcTdhMTNEMitHZ05GRjd5MFhsZy90RUROc0d3UTVpaDNqLzdEQ1NmR1J3dll4YjN2dkZCbXAzZFQyKzc5TkgvaG42SS9uZk1xWHJ3UG8vclZ6QWtzQUFGU2NRaWNrSUJPZGFqSFpOU1RuUmpzdU8rQmc2VmVzY3k3NUdIUytGa0tDd2QvdEZhSUxDbSszUHBXbVVtRUpnY2EyU0wvcjhWeGVwb0paRlIxMFJ4VGMwa0txTUYxSmc3c2J5N21Ca2NxVmpORlZsZUVhSyswMWNmYWxSTldRNk4xcGRQM09hTDJxOW4yZERFMUw0anh6MzhDc3V1OEo3alIvWk5UWkQ1UWV0dU1xTU9YMzBadFEzMnlWTmRZSVMvMmxHOVQzOFdiL2duT0Y3R3UvNitqK0NEd3FHN0xxLzZLUHBwbmo5Qkh1WDJmNWlIbitwZ3JMNkFubUdpbUViY3RrV2xiVDdBWDY4Rk45VmVmM1pUOWJldHEyRGZ2M1ZmVS8wVVlGb0NEdGNLckVZRmlOTkhyZlQ3VGZVbE1BNElVU3cxU21STUVwZzFHTWFOaUFQSEJxUUZOSUFEK05Cc0dOb3BkQ2pMVXNORTY5Zm9vdjhJWmo1STJCYk1HUncyQk8yRUVVd1hTRUNaU3FrWWw2ZXk3ZXlVSEMrV1NMemtrWUZNTUxEZWJqY1I4eHF2OXpXSUtTVGFpVUpyZmYycW8xcGV6TDVlVXFqOXVDSzkzcEx5MnRGUVBCbUlFUEl4Rk14Wmc0TldMaGdpMlhBZ0dVYzNXOVlORTZJNDhYdE53SlZwbm15MWVuSEpBRy9vQmt5cDNjWGN6N3laZVEvNHhQVmpxUXQ1eDhoK3M5dFpqOGNJQlI3S2orR2JVaTN2MkVhV3FtSW5SY3NLUFFnVEdUWnZka3dsOHhTRXFsYmRHR0dlMnBJVFRwVmRpUWFQQnhJanFaQWRTazEzTHYrMkt0bVNpdGZCWUR3Q1BCZjdEQXZIV1h6UERsUFI0czlIdk9weDlOdU9vSEdYWDhzV3M1cC8xVjV6ZmdJZkVOUERrZDJWQ0J3UFRvUVNpWkRSdldxSWlpTGFmK2t6L0N0Z081K1Y4Ujk2SnJjZGNTUnFLc2U1ZFVlZTZqTU1YNnZjNGVDSm5JS01QK2gzalFuanZmMDY1bWJtdGN5dk0yOWpIcVhlOFYwbXJ0czVHL3FFOUdUUFozRmxjSE5JdkhUUHUxM2RRMFNaMjMyTUM5bUdaVFgyd0NGTFJYQjgxT2tRWUZuUnIzYyt5RmRDcVZUSVlMZnUvdStjSngyZWtWUlZRZ3VTYW0zOU9WRExlUmMrWEtEQ3U1VnBWeGdGYjEzdGZoZjdIMElKdC91MytneWs2L0h1bTRPUGR1WEdUOUx4ZlZranNVS2l6R1FYdFRqZm9UWUJoaXJmZzJkYkRWTWM1czRadFlqUGMyczhpNnpzK0hwNWVtMzZlOVNzcXFub3lociszMFNkS045UVIxUnBUWmZMMHphTjNlUW5EbHdWZW5SbHJNOFRXbjRRMDBtQWN2a0s2bWxQTkhvUVJoaFVZWjNwWjJMdUx0dVJ3bUR5RnRPRldRQlF5VXBoaXFvQTM5UHNTZmRlWjZlTy9JYmdWZmtIN0s4L3dLdGU0VGVPRUZGd21rc0UwRjJCQkpjRzBmRFZDQS81eDBYTWM2SS8rMnVxS3poSFQrdjBoSmpmRVJTdjhOYTNDbDVGK0IyeTZIekxpRWFOYjVIa2owUlpGdjlxbXBEQzJ4MDYyTmVBdVRPQ09jY0ZzZ05tUzczeGE0TmkvN2dHTyt0OHRrUmFYeThpMTN1bk80VHhQYlpzWHl1elh1VWFhTmV4L1VhaFhsQWVVL0F4aUMvYTM5YlFZZG5MRG5NKys0dFV3TEZPaFNFeCs3TUQ2UDJvUGFKNHFKamhOd0pUZU4wMGZENERYRHFEc3RyMHlCYzhBZHVKTmp0S24xNWJZL0JJY21PQnVYZzd0RDFVZDNZVGN5ZHpINW5wbndRNWM4R3RkRWRHVTkzRXAxUi91VnNYdWRKSkJQdnNGb2g3M1JqRnpjNGJqbjFWbmRoN1NYaEZDb3NSRTdYcGw2OVFKZFFNUGYxQlgrNWlGMis3U0s3VWQ5b3ZjdHducVFKV0NZU0NBWDBnVkc1WStibDhjaUtRUFJURGRNWm81RUFzeHNjZGZaaENLK2FvdEhvek83dTBWY1k1b1R3b2hEOUo5Y0t5ZjZReTdOZDlNMlg3YWJTSTYyT0cvSHBLNFhKeExvcGkreU9NVE9Tb2lORDRCVHlYeDVnNk00dm5NM2ljNXdrU3ByT2crMWlkbUIzZ1ljdzYwVjk5cUZHcWhxV0dEOU1PRWtDZjRJWGFKQWEraTBocVNJMHFXbC93c0JIL3dhQjNXUEh6cjEwSytYd2hYMm1vNUZ2Nmlhd0dXNTRiek9YaFY1Nk9uQndlZUNoME5wTE1ETC8zZHV2MjZQREphK2MvL3NiNmZzUWM5Sm1zWjhFYlZPV2ZMSVVhalpEUDcvY3R2WmIzSzhQZTRKRVY4NGJUKyt2ZWEwOE9IL3p6Wk9UMjRERENENGVIVDBidXYycnVsVTZNQmdZOWlIZXVVV0xaNHdqTkhLQk5La3FybFJ3WVNHclpNdzVvRm9Sb0VJeStiY3dGS3V4c2E1WWlQYXJ5N3hLRWQvSHFvOFRzL0Z6VTB0NnQ2Ky9XckNoZU1sa21HWG9ZSnZQRHNIYlFWQ2o1ejVKeVd1RDU5L0E2L3M4THAxWHg2TkZRY3NHSUlPMDllbGwvajRZaXhrTHlMOERNbGN4bjZuZExra21tYTV2N0lKTUNEVnovZE9oWXN6b0JuOUFsV3ZEVVJ6bnVvMkFBeWZNUHUrRktIaVp4ME5IaHJlcU9YdlY3dk1wL2hPZGtQS3dlSWdhSEQrRUJMM1AyMm5iMUJmdVBOUklYdk1LOG1ua0Q4d25nSWNjSUdFMU93ajF0MGxqcVlFNGtFbzhKa3lqcEtYZ0RqTEhHQWhLSzlSNVQxMHRsY0ZlQWpTM2g3aWpzQTE0MDhFS0E5NlVGWk9KM1M2WGlnbU5GQzFhMW16TUVIQUNjZG5IWEZ0RWFqL0xEM21sZnhXY01oSGhUOHdsQlJaZHIwYlNvK1hTdmxJbEtYRHJTTW96bFFIUks5ZGlmUWg2NXdlTS81enlLN0hrMXBONkJVOW83SUhXUHBpaWU5d3U4a0ZBNFE3bGJWZVZscjdjbHFYT1NqR1F4TFNuQno5NnRoTlVoU1E1SysxaUo0MW5FSG9mTU5heElNbnNoY3dQdlFjZ0lJRjRaUkUrLzAwd0lvWVBCb095eGdtb2xLSGxHQXA1U1ZEUlRVVEZhTW5POElhU0Rad2FWNkZja0R4NXVuQkFJOUo4OFhGZ01LZUpWa3FlTjl4ZURVMUZNMVpLZWtoTGdiN2hTWXZtR0VoQ1U2L0dyT1ZaaTc0Yk1QVTdtT2x3RWVHMHhEeTE5cHlabFRhWXo1OW92Yjg2VmpGNUN2Y09xZDBqODFVdk11ZmFXVTA1VWR6RGxyZ0ZDeUJuQ1lGcmVHY0xPbkVPNFRSa3k1N291SzY0ZXJldkNndXNyRUhPNWpweDNnL0ZjWlhQOWttaDQwd3hVT1RvM25jQ2V2Yk9LbU1BSCs2ZWd4T1B5S3Y5N25FdVhmWm0xbkxpSmdNMTZERHk5KzdGaE53YjczWlRmb0NIY21CYzd5TEZ2cENjNHRDK1ZiUElzV1BmQVllajNJQUdIb3gyYzhydnREMElTM1lLUDc3WUo3Q2VDNjI2YlFOZDNQWE1HOHlDM2dVMXd3WVc5M3hpejJJSEgzNUx4QzIrKzNNVUc3bUZZYU5DQ2ViWWFCdmg5OXV4eU1yUUtnbFRnaW5WMWVqV1VYTzdrTUd2YmQ4L2hlQ0ZuajdWUnE5M0c3SEc3QW5FZGFCRjh3R08zMHMyQkJxNmJhN3JzTnkwSitOVnI3YmE5MXQ0a2R6NkErK0dlSFNCQTdBQ0ZCVGdvYzRmbHRoZEUzM0FMd1UyaWNmQklFdHdGM21GWmo0ZElqZ2pKN2lOSkVLbk5XTmIyZ3VnVktqY2d3NzRuMld5dGJYZUQ5TTkzMkNaNkFsT3pKUktQNkRWVW8zNlJkbVU3TENxUkhyZ0JNTndKdkdVLzdmRDMyQ243THRKV0d1aVVKQkVFQ2JjUDRJWi81amk1WUpNb2Y0aDJDbWpVWG1kWjk5ay9JRmtTc2UwejlEbm9ML3RyK0xrYnRtdisrY3Urd1d5aHkvai8zSmo2OXFhS1F6TFFhajI1M1kyTGpDa0xldFRhT0JZaE1EdmsycDJSS1lTY0c2Ui9LQTNUTjZhQ1c3UnJJeWc2YlgvSDZPS2k3Vy9zc0o4ZTJhN1J2MzNaTjFDTEtuRHBNSHlXRE1NcHA5bHJpSXhaKzluT3NIVEs0VnMwekQzSnZRakpGOTJ1Nm9tMTdDT1JsdmNDN2tVREtLODAyRldtUVVoWmJPd1VSNmhYdmxUcU5SOTRTTVNVU0dKNU9TRUVGTkU2ZGVxSmJRTXNqM1NoMEdhN2xnUnZWM3lzUEpoTURzcXNUNW5NNS85dWUwU2ZzMTNjdFQ3UGM0YVJPbnNTM1dkbk1IVndIZk9BaTFIVHY1LzI1bnVWd0hTbGNEWDZBUHdSN05OQjRIN3JNOG9hUXhlNXl6N1FOYi9wcEs2Mmw4bEVlQXAybzI4U2JkR2pOSmJDWVkxQ08zaXRBa21NSEE2R0tZeEczRTIwQkk3Z1l2UWRrcUVtUkhBNnArclVXZ29QcEx5c0w4TGRCVjlDanV3cnBTR2RIcjg2cmcyWjg1QmVTbGNEMnFCSnIxc05CZ0UrSTNvR3JUSHZ4UDFWQjE4S2lPQytnSXJqUVBKREhuQ0tNY3RaZzNPTzhLRFFac3czQUxzUUJ0TWRTSlNLSklZRFJLNEhoR3lwUHc4RzhwaFpEY01aWXQxVFNaZ1ptUVJpdndaMFB5VGM5OWJSR3NkNnBOTW5UNTZXUEt3a0xtR1dYdlNLKzAxVzlHcHNmR1d2Z0ZTdk1LSjQxUkVlTTluODNwVTRxMmtpYXg0UXZCSXZIRmlTSk00and1T2loNU9rcFFNQ0wzbUZBL2h4alR6T0kwWG5SMVN2TWlKNFZTU1F4NzM0OGYzNEpaeTRmMGw2VE5Ra0ZCMGJpeUxKNjBIZU11ZlZPRzZ3S1dtOEtKMGF1MkVmU0sybXJvUXZlT1VVeUxIMjNUQjJTaEo1VFdvT2Nwem01Y3BlNVBIK3NyL2cyTXgrQkgwSTg1aFZacHE1Z1NCKzk5ckF1d0owUjNuVGNGekZ4bDBBUHNLK2NSbkVWV3AxaXNIWE13ZWsvcm53N0hGTzVZNWptaGZUcjFWQzBGWUpRWHZqZ28rVE5WRmlkM0dLWCtGMjRlL2hVYmhZZ09PTUVhNVVaU1dCK01VZFBZVlRKSnJFTlA2UjQ1U2JuVUxraXYzSUZPRm12ejBpcStLVHN2eWtxTXBYVE1ueWxQMS9JSDc2SU1lNXRqbHY1ZmllQUoxYnREL1k2SVRud1AzUTBTTTZ2U0w4TXUwUGJkTitsTDNjRGtETFBUMWdrNkJyNkFIYUE1WEw2UUhCa1F1dTR2YVA0alVON0JJdk5RSTJpUHd2bGVjMjVMY2JCT2NsNFN4VUN4K2EzZWh3VFNjb0xqNnNFVFJZY3RqKys2OTBZc1RkdWtYSy9xZHVDTG10MjM2SnIvOUx0bjNiQVhEdU1ocC9rVy8vMU01YlQzMk4xdEZ1WnBYeE1uNjhNbWY3dlhPeXNISG9BYVd0eHRXMkVuaDNHekdyUVVqQ2xlQnFtOHlkdjBkL1F2cHZONTQ1cjd6VXlBbUd0bVRVbklsRUliT0RKRmFHQTVvR2NYcG94Rk53MFhCZ0dLdmJENkZIa3RDK0Zod3dleDhRdUNMUitYSTNtL0ZCUXhkNGxtZGxJWnlWZ2lPWlV0SUtSNGFEVWEvZjU5RzNIMDVvQk4yRTU1d0hydUhEYndrU1Y4QXZWWGplL3BmUmRGWmdGUjVDVmtsRzFDUG5ZOG1pR1V0NG8vNjR6K09zTFJ2NjUrS2pxL0NyNnA5dGg5bnl5K3lnaXd5NWdaZmRRU3o0S3lIQTRTYmpENkpPZGYzQUdtYldRbjNEN3lWbXZXLzRVZXlTenZOcEpydkZHQzVzL05ITmd4cW9vLzczOUEzelZ0OUxaYkptdElrZURDd0pEek5YaytneUQ0RFBOVFVYY0hITWN2ZzdPcEI3YmpDR0tpVnZoMUVSb2hkUnNEQUNiK2lLSmtKaWljb3RqQnFFREN5YXRVbHdWaUovQy9rNnFFenhRMkhBSG5Qa3Y1TVJFYTB0anBVeXdaUVZ0SWI4b2FSbEpVUCtJWnhKQlRPbHNjV3BrMU5USjU5OVN3RFBQczFNK0dMdlhxd0FwbDJsbVNnVXIvTUlmc3Z5QzU1bUtQQ1dSTXlYTUxVUUd2MVJJUENqNGNoQUlqRVE0WUNHODJrYWluclZrQlpQcWtZaDBZdytHc1VQRzJveXJvVlViN1JjS1VmbFU3d3VCMDNWLzdzVjBMOFVhNFYxekhPOHhEUmJBZDhwV2ZLclpsRFdINHd0eERqQjMvUmpjbFBnbXB4UUxsTnNDS0tQR0FHYk9zQjFwVEJFWWNkQWxPS0VFc01HSXJRdEZXc1I2cnJxb0tXSktZcnlTcDNiWElnVk44Z2NBZkVoYVA1Z1RvKytGZndFL3N3ZkM0ZkMyWmxjM0Fyd25PclYrRmp3bG1DTTF6U1ZFNnlSM0V3MmZIdmE4TVZabVJkQ29xemNvc2hpU09CbE51NHpVcVZwdjY3ZGNOMTFOMmk2djFIK2FlQVRpdkx4WUtBU3gwL3BBYThzYUQ1ZlBoYkwrM1JObEwwV3ZLVHkrNnFjNERnK2x2VWFjY252bCtLR054dmpPUzRocS9WU01PLzEzSER0dFRkNHZQbGdxZTdHZFA4WjVxbE1LajNIRkhIWCtZckRIWU9lbGZERFVhNSt1c0ZMc3JCdzF5S1g1SlJEZ013d2NmZHB4MFdLMy8ycU4wL3pIT1Zid0w1NGJZUGVqK2tvSmp2MmVBMFg1YmJnSmpxR2VkbU9oVjRuNGNEVk9rSEEvNDNtN0NZOTUvUkFJQkVNb25GOE54RUkySjl6OHF1MHRIMjFvNWgwYkx6cDZkVlFOQkdrUjdTTEpsMjhlOW9Hd0dGamtKRTFDbGtqaTlidEp2NFBFdWhWbkZxemJNYjFvWExsRzVmR005bFdEckc5VklHczYxOWtSOUJYOGJvVFlhWkliem83SFRINHEzWDZyU0daRVFBRGtVUllyeUVPSENqVEloazJqY1J4MWdlZTVXWUo4Y1NSVWtKQ1NnelJydmp4SFRIV0cvVTg5SkFuNm1WamR5akk1MzFzdDJpYTR1N0h2RDZVK2NqQmd4KytQL25ZWTBtVUE3SHB3NktZcGgxNityYmY4b1pGY2U5ZVVReHJqOTJtUkVOcytHRk5scldIdzJ3b3FrZmYrOTdvYXo1ODVNaUhLYzdxRjVHRit6UUNYcStnd3FzNVNyOE00YVFXRWJKK0szSC9odzhxUG9HOFZYSHFOSHJrdzYrSnZ0ZFNGUEtiQ240am5xSjczZTlFKzRYR3lRRzJyZjhuZ2ZraVBGOVJNa3ZrcFJuRStudWFwbXhxK051VGo1RnFIUHdJQ3ZlMFJibnRNYTIvcGI4RkRYc05OSkhwaklNMitqQ3VTNWJHSzVzSGRROWVPQXk4QW1OV3Mrc2NzNGdtak1QZ2lQZDlKUllJeEpUdlVjUWNhZXhmTXBMd0plN0xDaHZ3b3JZM3dNcFBjMThteE1GSlFYcithYnZOZEgzMm5QZlE3WHU4ZzVLUDJkR3VLTjJIMzRQdWc5bjV6eXE4U1AwZW5helM2QS9RaCtCTmF6SitrOTM3SmpBaGZQNXAxTzd4RXdCMDBldndtNmkvU3djTGY0R0ZkUStnaG1pc0RYeURIYU02TlJkTkprWEI5TjBJRjg0YTZwb2xkR0JHL3pnN1drZ1E2NUdCMlp6QU53UUZBY3hpT1YyZG4wcVhDWENMSWpSNElUYzdRRUpVSkFjcUZqV1g0ZldRMTRzcjFFS1ZiSEpZdkoyWTZHUVZibkNoOERrOHZuWDhLN0lnczhydkE3cDFlaXJ6QjZvRC9hSWppZjljWVdHUVU0YjJEUTd1RzdwZEhFbm14dHNVcGF5aTZucFExMTJNOUtlSm4xOFVJaFVXK3BHRUFGOUpsR3A0dnd5NlNvSE9UQ2Y0eEs1Ym5uNWNmeDNIdDFoT09LdnFMN2d6K3hha3VkSGtjSUVyT0hTRzU1RDVncTZlZFdaKzE5ZkZqZGN3Q0RIYUx4S3ZZWk9YWGEyNlhheUc4cXFEMzZXWTdmWTJBZm9jTUM1OFdHMjc4YUJ3ZjBCOFZ2Q0hZcnJJUXNYU0Zvb1NuWFcrZmEwVHdaRld0YlRCUndhOUkwRE5DWXlaSzJJd0RGZmdZTTZjYWV5NjdmVzM3VXA5bGRBVVorRlE2WEFVcUdwUWc0akFwR0IxWFdHeS9NTE5zL08zN2RwMTIvemdZZnN2bk1md29kMWxjNWh1alBtbmlRZnpma3hSTWFnVHpwdkNwL1VFYktmMkNIMkExcHM5WmpDeERMQ09OS2hNamhweU5panhSRzA5M1FBMHBWcTlFVUVIaktubEtTT1NNSTFNcEI3SkdHYmlGUFhwdkVkVGdwcFNWN1Nnb3NVTUpWQU1LRWJzeVlueW5xbWJwdmFVSjI1VGZjUFIxTmpBWENWZm5wZ1pHR3I1MU52UWxKa2FtSm9hU0pseU1YcEZJTVhQUlRLWnlCeWZDbHdSTGQ1SHZUNS9JWHV2VlRSTnVkWXJYMkhFWkRsbWZETWZEYXF5ckFhaithbTQzNE5rVEdPRS9WNVpsR1N2UDVRSklvOC83c1lCZXc3MzFVZnhIbGNoSHY0OTBGWUVhcy94WlFmcno1NHhRTnRjQitPOGFyRUxIdHVIRWs1eGJOR0xkcFFzUDhCOVBwdlUvZW5VV0RHVko1eEVKSmhOVy9QSDB0KzRvdWlQSk9ORDZVU1dVUDdsQWR6NjB2bnVsL2Y3akhCNkNHK0FSbG9oOWx2SmNGQlZsbVlxbWFiZkY3YUtrYURxRFJPK0laUUpHZWxNdmVxc3B4U1BiWjY1QytKdHU0ck1jWkRhU2E2V24zN2hScy9BeFd1N09VSHhhcHhIcEF6eDdvZjR3OFRIWml2SXpCVHFRbXZsaWRKRnFFcmNQTWR6TEk5UE5MNzR3S0c5QkNsOFZ1THJ2S0JNYzlJTTRjVDNYdkhyYk5DVEx2cGlsWEo4V0FkZ2JsNWxQVWxmTkIzVU1pVmZESW5DRXdTbmlmU0hlSXNnd3ArYlJaSzkvMDU2OVZwSkRaeWtsKzY4ZnpVVTlJVGovdVMrc1ZnSS81YkFzWnp1VDR3RXRVakNTT1U5Z3VqS3JaVE8zSGZwT3JBWmhwamx0MndaUjIzVEZZNWd1aGlobnFoQXJtREwyU01GQ0dCTThHUElCcE90Z1Frc3dZZ2hFU3ZQT2E3eDFNRHBuL3R5eXBvMVYxZ2NhV0N5Tnk1dzg0L05jMEljRTYyTmtjV0JYZmJhK2ZPb25SeUpya1ZIa3FoOS9yeE5Nb2xvS05ha2hwQk5hdGpVbjBQTitFajhKU1pYRjNILzg3dDJZZDUyV3F6bkVJTXZ0MXR0ZnpvUVNQdGJWc3ZDS1krUzFwbXVmQWR3SEZNa1NpU2d0ZmRwWG5wcFE4RHBOVEZ0eVJHeEJmZ0hGR0FZR1ZXQ2UzZU9xR2ZQZGNEdjdPKzAyMnN2TVMxcUpZblduSE9MS2w1NkVleElSSFhVdEMrQXBRRjR3ZUppVGNYQmFQOGkrZ21tbDY1bC9wRDVIUE5sNG5NeEJZdzlIdXM1UUY4aXVFTkZTa2dSV0xraVFaRVQ4eEtocW1pa1lKd0F5RE5DWVlFcEM0akJDZlljb2JhSzlTb1FYQTcrbk9oUUNEbEtGSWhGR3ZXTXZHektMUXhubUNwVWlrTi9sbElWNUQzQVlHUCtjeXQ3WVBUOUlZNGI4ckNHcjhHTHlNdjc0dDV4WGtGaE1SWVR3MGpoeDcxeEgrOUZJdC93R2F6bk1zcGFqVUFJTXR5NEQzODFKT05pT2Q4NEI4K0ZqUWJQY2tOZTd4Q2V0RHNyOW0xaSticWZtTC9TbUlIdnkzTXFsMWNUWWNUTFFrMDNKVG5GY253VmhsNFZMd1lwV1RMMW1pRHpLSnhRZDE0MHpLT1VVZWNFTnFWNmpDckhWUTJQbXNLenVtNmtFQyt4QXg3OGw1VjJWT2pQbmZyaWd4UElzR2V0bkdQdVlKanN6dGRLdG4raE5CdS8rb1ZTZVJucjVFV1hTZU95VjBtZStCRUFUWkZqQ3BnK2d0aUcwaGdCczVJY3FueUJ4VHVnSkhaSnRKeVpid0JZQWlhVzhPN1pxSGNKS0x4Q3BnbG9GdWFUQlV6SGZXUFNPakswKzl3U1QzWkZicTQxdlgrbURqaUJ3TUo1MjIxdDgxVzE4NGc5M2thZm40d21GdTlxaXBMRVQ1K3FEOVZVWUlYYmVtQzF2YjdoaXVLV1hHKzd2QTNGSVN5VFNBTmRKTUxlWm0wQ0g1VGNaaFZMbTJoRHlKUEozT2lBRkQ3YzI3UmVaTUx0cmptUEVPREM2YVZ1eTNyaENuKzY2VXEzTUpGSFUxbFFnL2hYZG9MNVN0MFVMR0lkS3l1VHhuSjM3SzBhWnNjcmJad3RibkdqTDRYc1k0QlV4ckxKMFVPc3hIbzR6dml1VjJPbEpaYkZSM1pQTTVEemZ0ZWdSUTZPSnZFbGpYM0ZkdzF6VnVUODBSSzlYaDdibEJoRjl4eWp2NUFjUGNqaW54Vlo0eCs5dVVCekQva0ZkZ2tmNFhkeFlZazlOSm9raWRQZjliUFNyT21QbHVtajVkSCtoTWlWUngzN3lpK3hITzZmUWFhTzkvdWplTCtBQ0pOajFBWFAyUXBJRjBVY3NWZWtrWGJoNlJZb2loaW1BcVNTS1pVZ1NtbkRGRTN3Y2VyWXBxUHZtb3FWenh4N1JTR2RDUTZZVWNPSWhxNzJJSFZTOCt2eVFTRWFLUTc3UjJJUXJ2QWpBNjB6QThOR01ybHJ5dmUxSXpkTnZtckVsSTF2aWxyYTFOUGZvR2c1YnhnOGMxMCtrL1ZwY1gvQmpPM2VIUXN0cTJuUEpPNEU5YmdZMThKS01JeC9hUWo1UVdBMjhycWFQNTM0MnZOM1Q5NDhZdTVPZkRPYlFicWF2b0VDNkRnKzNGUlg0Mk1pbU41SjR6bGR4RHpnQk1IVDJDVG5vVndBUkc0ay80UE9tYVFKcDFCck9OaytSRnY3Qytja0JTeXcycXR0ZWxLa2N5U3hRUnpVQXVNU1RHM1lxMEJ5dEY1aVZpU0ZwRnliUE9xL3dURkJUSmxWU2Z4bklyWHFyMlZqcCtqMUNMOEJoU2lBRG9sWFkyNkxUMDhGU09RQnhuSkJkK0NaNW5ZQmV1eFZLanphb3Q1TFc5Y2JiVURzNVRhMll5TUlCdFNtMGxObCt6ZDd3bEgzTk90V1Z3Y20wUWEwK3VyYzcvbSsydHM0ZTdYTGQvVDR6MUJialV0N2FtL2tmN2VWQ3Y1bXQ0TGJCanl5ZXlMM09MN1NRS2ZQWWNyOFBxSW5nRDRaZDNFREpBZjlaY1BacVd5RGx1MmNKVE1zaFUwU3pNN0ZobW5VM1A4dUF3ajNTeHVBWUxpOFVVV2ZWeFNUVXFZbVRybi9LWlhxNW5RZDA2dlVCTlVpZjZpRnJHVlZlbkY2VUpKWEQ2czhFWmhvTk9uZmNON3ExcWcwN1llL3dDWklJZjkwNTIvM3d1TjljR0tycU5uckR5VXpVYnpuZGYxVGdrYi9sNVQ2a2FWcmlNSGpPcEFJcnZWT1hxc3Z5aDJlTDBramlHN3VXUVZDN2hqRFJMcllpWDBEUG5HQVl6RUoyRng5K0xxYlE4RVcrbS9qRFZkSHBRVkF6VUxiUm9TMW16MTNKZzZJUHhjUGZGSThjTk1CRVhBeXR3c0g2K205MWF4VW1vOVdtczJLd3g4K3p3SjJWMWZ1UDgvc1oyNEFycnJybExSSjVOL1lKUEwza2ZoV2xJdkVKQ0VFczNRZkNqbHVYYTdyTjRIUmMySmRnb2dGZjROR0hVMVQzSUIxZXJLYjlEemtJQk5NMHZPVlZhK3ZVQzhNSmF0NGZ4Um02SXFFbUt4bzZ2WkozUlN6cGVLZXBROHU3U21XckgzMy8rYjkrOUs4aXA1VStUUnEwZWYvYjNwU0hZQ0xYaHlLNEx1VnBEOVJLRFNLN0xza2dkZSs0VGhITFM5b3VxNHRMQitGWDRXZlA3ci8vbjM3N3QvZmJDaEtveE1ibS9RaDlPQUU0TWtSNXFrb3V2RTFHdld1QUpYTE9ZN3kxUFhOQmVvTXdnRHRCQ1lNaDlDclJJMnRKb2R3WTMzZUtpc2NkM1FncEJiUVhQU2syOXpIZWRVK2lkdElHb3dhckNDOWl5MDJDb1dFUDZtOFc5Uis3SFJTaTlTOXJ6WDI3YmdKVGFjNUhkeGI4Q2VrK2gvZ003dWdiUzdWNU1UTWRLUXBvY0ltcEI3MG8rZjAwTE9ocFA2Y1h0YWYxUXZQOGpyL25LQkl6MHI0WkorbkFhTmtLZ240aCtmMEpDNkxpK0tTNWN5emd2QWNqd3NxK0tTL2g0YWtTbElHMzdIM0JuejRHSjVmTUVxUHVVaWNYWUlOb2tSVmFiM3lmUlVIbldDUFRwMEt3am9hbUk2UWtMMFhWME5uVFJiWG1WWW1hRldoZXZZYm5WbzVsOTBxNjlDQVZsK2JQdkNzcnJNUkpBaTA0UmIwdzArZDV2ZGV3NC9ydEtmZTJOOVNGNk9USWI3TnNEZE5remprRE5vZ3dUTnIvWmFENFEzNVRveWZZRGQ4U1ZmeExXMTFFZjNNZnBZWTJVK3g0SjdDOXVSNjB2WmVYemljRG9kUFloYU5QMW9DVFQ3SE5mQ3B4WEhncVhDc0NONzBQRi9IcHhhUGp2SnNGQjdGaHcrNENmNC9kVkoxK0tsMEdCMlJPVzZseE9FSFZhN09jemZ5NmhOOVYvZ1dPT2FUTlF2OUVQY05VSFZMek5WTWkza1Y4VXA4RDZEMEVERkl2NiszbzlYb1NvYTdJZTd3NGc5ZTcwUmNoYWxpNkQxZlR3ZVRYYU1UQ1hFQ1AwUU5NNnVUalFtODJoVnEvYkFSSlJjanFBTVdoRjRJR1VHeEZBc1F1VkFnVmhMeFp1UTNqWXBocnBHajM3N1FibC9MaC9WLzFNTzgxK094MXoyZW9XSWNXZkdpcnRyNG1SWGlxY3duTFFLcFppVjV3ZjR4Qkl5VnlLSGx6RzVIei9xb1dkS1B4TkpVdXBTT0hkRkw1clRwSHpSTUUxeGE4WEhRYjZLeXRlQTFETzhVeTU2T0Y0dHg0cVZBSEpSanlCTEFBWkFUN3VySTYyTjl5bGZHNFMrNk9GNTFadTlHcjI4UmxFcjVuTFRBU2lBYldHQkJ2NTRHdnk3TVV4TUlxakZVTXVzUWFCWDNvODVLUCszcU9vNnBzY0ZteHUvbkd0ZS9selBVNHFGcVdsTU8zS3BDK29wSmt2WjhWNGtOTGRJeTlWNHcrYXpmbjFrY2lxbjE2eHYvcG1qcDZoVUYxZUE5dHg3QTZja3JpcXJCcWJjZWVBcVhhUTZTTWx4SGpneDRJQ0ZtWUtQdm5Pc3l0MkZTNVo3anVPYzQ4SEhqbm5tR0E4YzM5a1pNWkQ1RjdlMEVDWDBRN2o1SDd2QmYvU3IxaGp1aU91d3ZqWFB4UFBvS0hyK2p6RUVhUmFTYTdmWEV5UnNiSEhOQXpPZ29MZ3BFREF0VzQ4NkVMUkxSWTUzRUZCQ1ErOW5PREVPQ21DZ05uNkdCUGQ1WjVuZ2hHaFY0cnN6S2JHOEdIVjZHZ3VRd1piZDdBa3EyUVY1em9zS0RQSkt2Y0J4T29TYWtYTHV3ZnlCNnRwZlJEa1FzTXNCbHdsbDhuQWlBWkYwaStreFNnMC8ydE9PVHRFNWYzS0k2ZlMxNGllbHBBUU10c1A5eTI3WXp2Zlo5d0RPbThEZ1lacGdZNnZJQjhQSE5NSW00eUxuMk5sVWdyWUU1eEh5QlN3OENiZmpDQlVYeVgxaVRsRTRDbmV2bEVzNUR3S0pIVjg4ckNxUXVuTWUwbzdTSlp5M2czYmU2dVE1Q09Gc0RQaVJiRzBRa21GeC9sYkpRcGQ2Nm9IVjdIZm54KzlhUlpUZUJQY1ZWYW1QV2RSVUJ1ZDVicjlEMWR5by91T09PSDk5NVBWUVBaeFJJOWZQVGJsUzdJdjdlRTNoSFd0eXFodmthK0xpQUJqTzdSUldyNFNydHVlRG1ua1BOTnJJSVIyMnY5OWExYmJuSi9wNjg4ODRmMzNGSGY1WHZoRFFLMytuR1lRRS9VMFQ0Z1NURTR1am9yaHNPUUQ4bHlBbjhWTmpBWk5pNGExSHVCRitFTGVJODNaTXJGcWFqVVc0dVowMnZUSHRFTDF1Y0tySmUwVE5kUXVYcEp0MzNkeGNxbUVEUHorVXJBMzhCUUZQMmVqVHMwYmx2d1NMN0xVNzNoTTN5ekxSYkw0YkVVUjRtM29QMHBTS29YZWVvNHJWRTBDMUlWR1FuWWowRm5xYjZkMWhQbmN0cEJHSmVYTGtjd3UrMldxalVWenNaMXl1Z0svaHZBTFdnVG44eGdPdVl4MjJwRkQ0N1V6Yjc2eGN0VDVQQjRJc0ovd1pzemI4SnNiNStOUERJbkhmNnNhOE9sOXVoVHBVdTJhbFFrNGVnSmc4SnNmMDc2OTMvNWZWZGd2b3UvZitudmwrRituNzFzdXI3QzB5SDgraXJtTXZPZ0hTUnFvcFNKTUE2SWNTcnhGRzdWRVRFbnNsRWVEQ0RMd2VBMWw1YzJncW1xaUgwbmVUaHhBWGxYb05uUFpoSWZuVkRWLzQ2b011eWZVQXlCQ2x0b3RmOGRjT3J6RWQycWZrU2xaYUMvTE1uNGVHNGtpOVFEVWJSeDAweDhaOWx2WEd2RVFsNGRQMWU1Ym5BVkN4cEg1RUVROHFZYU9JNWRWZGtYdlUyOG1VaWcrVktZNXNTdmlEdkM4MjRkQStOZjc2TGFUS3ZaZDRNWGlvMEREa0J3SGVBM1ByQWRER2w2Qmh3NHI4VFZLME9udzFzT1FXOFB3cjVFQW5yU3RUd3hWTFBYMkxvU2MxQlFaTWFrZjdmMnI0RldvNmpQTE9ycTd2Nk9kMHowOVBkODU2ZW1UdXYrMzdQMWRYampuUWxXUkt5TEV0Q2xxMjF1WktNa1l5QjY4Y0dHMnZqYXdMcng3RURPYkFCOGtKa0NSQTJzUTArQ1J2d0hpN0I3RzRDQkMvSkNRa25ZWlhYSnV6WlhjU0czWEQySEkrMi9xcWVucmxYa2lWamNoODkxVDA5TlZWLzErT3Z2NzcvKyttS0drS2lGZWw4R2hrMjBBOGxXY082Z1NaSFc4V0tXL1YwV3pjMGN3V1FtL1FnMGxhUTlIUWlZUnlyakRTSnBJbDdpeVBkdFpVVjFGNlZJZlNxWXBTSlJEVndyQmlhbXpGZFM1TDB1T1pYblVxdVZiSVR4REowUTVYcDZpYmR2Y0NYeWQ5TDFLM2tVS3cxcGNveEJVdXFFN3Nzd05lWmNsejNpeHFKcVlubHlUSEhNWko0ZE9zQkpMeHF4ZFNpWmxsNTB5V21FdmYwcEtIbGdwajdkVmxVVFZtTEoydEtJeTRYaXdSN3Bjd1lYNWYzWmYwVkZ0WDVBZUZSa0RWbzlBTnhkQWQrTjhrODVPbG5iTzA3d0tJaUoyWVNOWkNlUi84WStDNE1vRHNISW1hUkd1R1hoOGlGV0hVdUE5bktmVG5iSThXOW9pYVI1a2dsaHJGRWRDOUpoWXRsTGRFVE5qMTFhKzVRc1RVNmlReTYrSkc3SXl0b0h4VWVGYUZGRW5hcGxRdVNsWXlSTkJPdW1mWmNLandxZVZJMkZQWWtWaE5wcy90aEx1TmZUMjBkeFVuRGNjWW1seE5xakdoRlg0L0xDRms5WVd2MGdjVmtiYW9WRzBwYTljOEJPUGticEZpVTR3Mmxsb3lyc2tGTDl2V1VXU3E0U2QyTEt5Wnh6YnhsYVVVMVptVkszc2Q3VWc2NVYxbk10UmJqbSt0dCtmUXAzS09SeFdYZGRDNXN3akpEekRKL2FDWnNOS2JYWUIwQlVhVXRtcXk3YVUyNW9OSk9xVkk5SisxMi8wajJVNEhkUVVMSERsSysvS09ETEZZMk94eDBLOVdXb2owYUVGSjVSRk5hMWNwZHBVemFlcnpUZWR4S1owcWhqWVVXdHNQaXp6bFVON3JseXRodENnVElub2wwOVpEa1BxTExabnlUZm1RUVpmNkZrY1lLeTJUMEdWNTJDSWR0SmNHc3ZCWlF6UVIyNWtIa05JMHVobWxONlFhS0JnTWpWYU11c2hRYWNPT21LZ3NEQUt6U0ZWT1VXT0drcUhRRWpoSVJqMENIOFFnQUMvRWJLTDhZdkk3aVhyekJBdUlOT0xidFY3Rm9SdWd3UjRrV1Q4cW1GVlNmMG04QTFiYmNSNndON2RtRFdVamJQWHRDRXI2OUc4NEhGM25keVFFMFhPRWFIOEJoaHF6ODN4S24wT2VvN3RvQzdnbkVPWm40b29QdlZjUGMwK0NiNEZFc0sxclk2MVRGWmxQVkZ4VXZkakhta1ZXRjNFOTQ4bjVDOHF1eWRsR1RWMlU1VEVnZmVvM2FRV0hSUjQxWXpGZzNzdlEvVEFUcnF0cjdPMzd0S3JKenBrTnd2aDVmbUlDSVRqMjNzeWplQXZjNWF5aXBxS2IwTktxc2UwTzF2ZGQyUHBDeW5yTG9uL05CeDM2UzloUDVTWmw4QUN3UmtQZ2dvY2ZIcjFmVnoxdldrLzJNVWg5d3JCYzJaQUNKWDd0ZWhZVWV6clB2bzM3ZC9Sc2IzVUFMdmVhZXpxbnJOZEpySXNIZmZyMVcyc1B6dncyOVRhZ0tRajltVUg5RHU3K1h6WFNseG5lZjRsazk5UlRQNnVtbk41NnZoNjlQWGVPK0NCZjZidlF5WGRYTkFpN1U1K29sbnd0aEg5anJ4YnV4VUtNSENXVUI1UnRUb2ZzRk1McFdvbUQxMDZFeGUzMzYyRlRTS0JXc2RJelVhc1JLVzRXU25wdzY5Z2V0UFVmMnRPTDZvcDJ4eFpSSWo0dDYvRDZrSXRra0luYnlEaGFKMlprNk50MnMrNk90OVBDWWE4ZFQ0OE9aMXFoWGE5STh2OUFDMkcrclhFNGR5WTFPYWRyVWFQWm9xcHlYSkN1aFNZb2FTNlZpcWlKcGlkNThBVEdPSEdiTGhyM2Y2YUtZc2tSUW9rV3dQTFhEQUpGYnIyU2NId3hxdmhZc2pxZlQ0NHZCZXBSWVo3aldXZjd5SXc0TWF2YWhRbWlGM3RYaE44TkwwQWV6cm5CSVR0QUg2UWc5Zmh3b0s3VGpjVlpTMUZQM2djQnNjMGx4aENSbTJ3aG9EWGFFOW8rdWh5OGJpamRibkMwV1o3Zk5GdlB4RWJReXN2ODJ1SWNlQmdyVmZZWGRBSnZzUVRMVm01TWVSNmZvaUgrTXhUVGVzT3M1RXZtak9jelE3cytBSnNEOUdwendIY0NUVm52SUlnWXpxcnEwNTRXUnBaelorZmVjQmdQTkpUaWNaa1M2LzYyZzRyMTA4UzRUZVM5Vzg3S1NacGR0aEdSRjNvN1Z0SXEzeVlRZ1pOUHJSRUZwQlcyQlFDOEtPM1Qva2ZNVUtKOUtadXlFOFNtRndLYXZTdVF2bTA0ODRSaFBLY3BUZWlxWmNNd3ZRMGdoMUpRSjU3am9ZeU5uaExhd0MxWXpWOFlDY3E2UGdTeTc1ZllNd3p1VzZSTnpxaHdLQ1IzbjRvWklSd2RmRS9HSTFxaHV6aUNPQUhiOE00NTh6SSt1YlFoeGhJTFhRaml1QTZneFhreDIxd0RudUVKVFlWemRpM1J1ZUlmd25oNE9pS2wydE9zMklpejQxZEUrZm4va1lmWUovN1ZDQzgyQnFiY3hTQnUwUVVOQWYzSUNIdFBZVzVwM053c2xIdWExTk1vb1pFK0U5cnBSZWhrUTVhVkNVRmtjNGd3cDdBMmVIRnFzbExnNVUvbCtyMkVYWjlFNnQzbVdTdmtBNjVoSVVtazBOQUh5THh3dDhmQ3lwVUpqWm1pcEtiWDRkOEY3L01hVzFGd2FtbTYrcFZlVzdvVXdhM29JNVFkN3U4dUFvbTVmVWNrQlArNDZENEY0SFRrMUJxVnlZYUJTY2s5QTA0MWRqYXNKSU42djljNU5aUTVsUUQ5NDFTcnVHNmlSRVBHWHJBdGx4dFFKdXlobkdKYUtxUTJENUNWOE51MnRDOWptV3JYZHB4UXQ0OGg5Tjl3RDJYVGUzblNPRGxlczlPRzBWVG1oVzVLWTViQ0NyQ2haK3FYRHFrejFDdmtWaml0QW5RR1UrT0YrOHNLZ2dacXVOTWNzWFJTbExnc25nMVlsVWRTdGdHU3pwTXNqRDZ4MlgrSm04ZTZQMlNCeDlYVEVwL3BEeG5rSU1ybFNHazY0Wit2MHBGSHJTU1BjNE1abHRCclc3aXpVemkyTE9RZXBUazRzdTFERHkwSll4WmVCbGZUSFJFTmxkTzlnSlo1eE1oa0hQVFJRaVZzVVZWWFEvWkYvRzlnZnhvUzNBVDVrSEdDS0ZSSnk1bkhySVNlZjVrdmZlcVBlaXpwYTM4RE1VMmVHUmU3cXdMRDlEQUlQcTJidWZjck1FVFl6T2FZSSttTXp1NjFpTGV4YXNDcmJzcWFiTGt3WHptUGlZa2xla1NYc0VueWVYa2tmTzYvSWFWazVYeHBMR1I3R2lpaFZNNXBLVEtMYjNrMXVRcWNwVmN0VUpWSEIyRFhjTVRwbUxwWFY0dEJRVWFVSmV5SkhNN0ZidHArU2RGMUsrVFJKTCtRbWZwSHo3b3p0Y0UxZHBHcUNibVNxR0JGY1RhWTlad2dUaEtzWmcyWXVpN3JwN2hqait4SmQxbC9YaFNsaEw2eHBtVWZvRGpGMDd5M0NtRVlmSkErWHZWRmNjeUF0cFMrcE52ejZWZnFMSG1tYlNhek94eEpJTzZQbjlUTWFTc1RtVlp3MDIrQ05SVlZXSnhTSVEzWFlXRkw4VFNhT0owL3Z2bXZwekptbHUzYWZQclk3a2RGM28yUkdXeldNVlMyVFJMdjFUQUwrQzNFbkNiVk9PdkVDdllmWCtPR0hWMWNmZnBqWDUxWDYzSmZSVndWTHlMSVZERkV3WVUxeEIyb29aWmhSNmNOelBJSU9hT1d5OWdPTlpKUG9ZaktyYU1QZFFOT2tTM0pTdmlScDZETnh3NGgzVitKbDN5L0htM0VWWFZEVjdvb2E3NDBIZEIyNkxxU0ZpbkJDT0IxR25XSXlFem1hMG1OSVN1QkVHWERMYTBjTDFyQ1hoRW9qREg4OW56WTJOZlMwU3RadlpOZ0Y4QUdTS1BkbnlqWUxoY0JZaVIrYzhiQ0Z2UmtpeXpVTkdXUnNqQmhJcThueXNwekx5VjdSc29vUGNWelhRN0l5UEZRZlN3WDUwbkhEWnBSeHRuR2NUZ1Nwc2ZyUXNDSy8rajlXbkhJK1UwQUNWZENRVU5uNmw0Vk1Qa2l1b0RsbG5KQnhCY1hrNnJTaTRuUWFxOHAwVlk2TmxHeTc1TXI1dkh5Nk4vcnVLQzM1YVdVazQ1TlR0b0hwajJHZkluNW1SRW43UzZVZHNuSmdPTDEvaTVwS2p2LytqcmN2blRpeDlQWWRmNW9hVDZiVUxmdlRQWHdJbCsyY3NDUWNBSjBLL2JOSWJmME5pbVR0cDFOaEV2R0RUd2p6dE1aSGhKUEFhVkI3blhUZkRXRDBua09SNCtFVm5OK0pDSS9hNEZ6ZmJuVWNpUSsvTnFIMzg0eTN1M3VKcTJPakcxbTllNzRxRG5CNXg4MXk1d2JZdWk5cXgvQktkLzBxbk4zZGI0Vk0zbXNKZTRXK0EyM0JvbVBUZnhKRjlBMnE2Uy9TdG5DSGNDL1Z5WjRXZmtuNHJQQkY0UStGN3dyL1hmaC9WT2VHRVdzK2pGTEdDS0poZEdJckxyQmF0Q2ZRSkRRTmlFazVwYVNxamNwY20rcHlmcXFxVlB6WFNUMnkrWHd6ZGNsbU52dk41NjgzLzgzbnlxYnpUK3Nta3Zmdmw1R3AzMnI0cEVXd3Vuenl4SW1UeXlxbUo3NFJhMjAvZXZqdzBlMHRkQ3RTdHA1YVZPanJFaHRyMldIbGVzbnVDLzAwTUdsRzE5ZGVSeVlia3d4ZVNnOElTNDR4NG5ramhpT1ZKY1hZcVh2YWN0cjMwOHVhcCs4MEZLbTBFMjMzWE5mYmpuYlNpWCszNis1RzVXLzBNcnJPNGVSVnJuM3RCai9iUDd3NHdPeENJbDlLbTY1OWJxTGowdVBDTDlCK3VnblQwbVo2bTF0dGxHa2ZxL2I0Vnh2UTlVcDBiUW9kRUtLRVh3R3FyRlVVQ0lVK1RSY1l0UEdDa2lHeVFZN051TGJJblMwblJOYXltZEZoU2FTSHpWRXAwWUMydDVKUHhlTkc5M2VOZUJ4MHZRdHZrbFZMZml1Nkd3aXNEbnljSXphandGYVhoV010akljL05ZeHg2OWlXUmo1aElKSCswaDk0TVJMNXhnTlh1NGlpYjFPK0dhWE9BUmEyVEgrNHNyb01wUE1uVHdMbC9IS0lBbVdnMXg5SXhVZnArcVgwYUZFS1JQaVJ0SmlYUDVyM1k1b2tSai8wb2s4dmVyMkxIeCtBQVlleDBNQWV2d21SekdKaU04R3llZUVhRmk3eDhLdmNuMHk0MERjL1hZRElqV0RMZXBXVlVnekFEeTJmNnE2bitpNTBLZFJKNWNNWXBDelc1WURlc1M1MHFFWUFuQnZqcUJIdU4xcHNYd0FpamNNajViT1V5N2N0bVM5dUdJNmNlWm0xMlVpMWcvdlVLQUQrb2ZOVm04RmNQWjhPYXVLUzFXcmNEMFhwM045b1dkank5YUdna05jS3FxWGJDVHArMG5mbzhPM1lxaW1xQlMxZkRLcTZiMzAxT1pVdnBWT3AxUHlXVEtKUnYrZWRiNnMxNDhQRGpkL2ZOakU2aXdPb1E0Qm5SOGUzMDg2b2xUVjF4RUl4bDA2SG4rc2hkMkVNLzV3Y1Z4MGNROWFJU3UrUm5FUWhTRnFGb0NRN00zU3AweGlxendTbTBkOG4rUXJySzdzRXdaM2JDQkZESVhjeHFYQ1ZlN05MTmU4SEc5N3BnVnlBSkFCVkZYbGs1NE9sTWtPNy9Bd2Noa2ViejdaR2g4UHoyYjc3OVAra3g3OVoybGtxTC8xdHYrSDgzYUZXb3psODhPOGkwaWJBNWdEbjRsZUVjYW9GQ3c2THFjV1dtK0RYdzIyZVB2ZjVtR1dQeGZmNk1KMXB4WjFwZ3c4U005WXZUeHd2UzFpUk5LbHdvTGw0ZXBIKzNiUXc0TUhFSEpTV0gzamkvdVZLRVJ0QU81ekxMNTUrNlBSaTN6RXBZUDVJS09TQi9EM0FZbkRHNU40YStPcUZJc29tL0ZDS3VRODk4Y0N1RGFYYTM2SkYybkptY2REUmlIa1hiZG0xb1ZqWndwWXp0RmlEWGtWTU4rUGNsTEMvY2JOdy9EVjNPRHhRdFZMUXFqMExqRm93ZGxWRGx4clk2WWE5U2VnbE8xQXZRcEFYSVFLdnNmVkJKekd5SlZDbG1JaEozTWFpaGhXczAzOU54SGFjWURFbXFjRVdxdThiU3J0WXJSYmJpdkdDRjNqMDc1cDdJcU9LUVQrMXI1VUppQkluaWtyY21Kdk4wZ05SRlJKWFNKQnA3YU5mQjZTQU1VQjR4cEF5RkljY3ZYQ1BHL0ErLzVaeEZ1eURmYlp5eUtoY2RhdUQvd1BLYTI4SHJsWjJ5eXhLVXQvd3dkL2l6VjRwejdYblN3aGRpbHQ2TStpdzM2WnV4UlZOeHVnU2xyWHVmakNBb1gvL2Zkdit2a3FYUUx5TDBPVlFwN3Yya2lTOVJHOStJZnhoL01vcVlCWlZjRHBBQy9mSThqMVkxV1RGaEVkcktyS211dGF0b3NoaVowSWNlQmw5VFNnSVc4Rzd6K0hPczBXUjlMRitQREFKN2I4WWJIOTlDN3hGYjV2dm5TcGdoL2REb0d5RFhuaEZrbzVrbHBlbkU0bk1FVzVmUDVKdkg4b2R4WFFKbXp2VXpoL2h4dllqbVVSaWVubVozc05ZdExyL1I1VWs5RjlwMjZXdjNUSmRtYld2dk9sbytQbnVmOG1GT2FwWGZCbTZWNldaMEJ3a2VLVTVoamFNTmViN3RZV3RmcXRnMGQvc3ZsOVJybng2U2hURE11VHk3WVZaWWE0dWh5OTU2YnZUUEVSVHFmeFlwUlR2K1MyelhSSTJzNEFEeUFWdTdseGZXUXpxOVdDUnJXV2R2U09URThNMzBlbWJiWS9Rd3lzOUVndGxJTFp5eE9FVGxmOE5sUDZHQzN6REpRM3g1NkF2Y1h2eGZyQ1lSVkNNS0VSajIrMFhaU3Z0TmhVMk1reXpNWVBxVVhSSXF3MWFCRU9yaERjalF5OGJvS2VJcWplSFh1Ync4R01jWmY1a050azlrY3htaytmbmdLLytXYU5pUEF0ODlYUG5rOW51ZjVieENwYmZMRXZTTTVqZ1p5UkpSdTlRNVBOK1lpWGhuMmMyTDlxbDRqd2prMmM3ZVJZeW80Y3o2U0QyakdrK0V3dlNaN0svK2lYb1hWL1NwV2RGOFZsSmYxNVdHSDQ0SFJJUUNwdjNoczlzR2puOWlKaDNHdHdKUWN1RE9jaG5wS3RzUFJNcC9pSFRCdXdsQU1TTkJ5TURvZmhUYkZFY1liV3BLbmtOWHBTUHg4cFpQWWE4VkR5aEVVQUFxWHJTbFhFU3k1bUVrNDZWVVVhTHBlT3BsQ21KQ2gwZEpXSzRHZloyTnBFY0hFa0hhRlIyNmpGZDBiTkpUU1pTVXRhSUlSYXhKT0dTSEU5bWk0NFJRenJSWXZHRUNUUmJDWm5LeE1Mc2hxS1VkTFpjdVQ5NTdnYllzMzk2VXJybUx1WVRiMFJRMTl6aC9OMDNMQ3VHZ1Z1bmZhc2dEUE9va3ZOejBSNFg5eXlQT2pzc0p3YUluNTErZjFzQ05oZlloVUh2S3BZYXV3N3RhcFNLdzE2aW1rWUgwdFdFOTN0OTYvbjMrRUlpeUU0MFZob1QyZUNQdEFiWTNPbmZkRU16aC9LbHMrbHFOWDIybEIvNlh0OXczajFKbHg3RzJleUlZaFVLbGpLUzNhQS9qQW56ZEJXMXNSY296SmtISHV3RTJsUWhoVG43T0QwYkJoMXVHenRRcndLK2hUWW9ERnZQTEFacTBrb0VaYlpyV0E3aWRsSU5GczlzRFhjZko0N1N6eVRhaGIyRmRzSkh4YU9EYlJwdTJ6NmJpcG1TUGpUTlkzbE5EK21TR1V2TmJxZjVkditCYjBwK3RGWko1bVV3WU1qNVpLWEduOG1YbVQvZFdlRis0V2ZobVVSaG1hRU8xaURQTkZYL0xlVDJISjdtMnNDYTQvSTdXUFNVTnV3ZE1KNDlPcFlydEIvNFBMNEtzL1RNYldhMDdnZVdHdHcrZXJPUlRMR0hXamZHdHpQankxalZ6ZFZuNnpsWHJkU0RJRCtra2hKcy8yREhUZmhWaHpZMlJEQlZnNGJ5OGNvNCs4RDJ2K0YrRXAxK1MvaW02RXpuK2FOdkQ0dnFUUk5Qd01EM1JIV08zRUlxSHFCbXZBcDVNMHJGcCtYUndpTFJrSVFrbWhXUldzazhsb3ZlaUVUb3FZUUkwc2hDWVZTZXh2SjhsZWN4Y2ROdmNMZUpEdzF1dm5BZEM3Z2hxOEpPNFJENDlkeElORy81amZVSWNVMlJkN1BaY0RlTTMxR3krMDhqUTB5b1F5TjFKODU3U3NiOS9CVTlKZTh0RFIwZld2THlMMStSQlNSclpxc2RDckZsR2tFMjM0VCswMnprdmI4ZDZEKy9EUDJuNmRkSTB2ZVRwT1l6djBuZTcrZUZPNFJIaGFlRUR3cS94dU5aanFENVJvZ25nR1dqalhvcE5nNFNuN2xBOEJZV0thQkYwZTFINTV6dUpaYTRISmgwR3JNOWsycElnRExQTGErc204THlEZmRrdjRoSzRreTc0YlVWdncwUEJpWnh0bytGbmtpTENxbUo0dFF1eS9ieXVrWXNWYldJcHVjOTI5bzFKWW8xb3VKc0xzZ21FWjFVUzkxdkVUcVlFbzNvbG1tcG9pVXF0bUVaOUZ5VWlDa1c1anB6aGZGU2p1aWFSaHhWc3czRDFsU0hhSnBPY3FYcHNmZU9UVlBOWktJTVE2ZnFwZU4rbytISEw5QVozVk94cEpqbGlWOVlJbm9pbnFnMDR2VlVEb3NLSFYxRm5FdlY0NDBLdld5UWJmWnNzQnNtK04ybDJYY2pqRVRaVldXTWllSVQ0cW9LRm9ucXlpSkN1THhRTGkrY1ZHM1pjWlAwMnlSWndaaXFuUFJMa3E0ajIycUNsbER2L2dmNnNNc1RtSHhrcFc0WTlSV3FiWCtFNElteUVLMGRIaDFzMXh4dzg5cW9HK1VOdHV2N0NjYVRrNXlJYkhLU2M0c05uci9lOWsxTGVZMmN3dk43ZnJLbUhuSHp3WjdyT0ZnUjZCelhIcWk3ZDJYdDhXRHQwZFhtdWVlbmlxYktJdGlyWm5HS3puWDFMRnJMMWhQZW43TWlIb0lEVWh5Z0MzU0M3TjdSczZON3M4RVRWcW1aelU3ZU9qRng2MlEyMnl4WlpyVlF5c05RbDZjVEhxcUZuNk9ITGtPMzVyTWpLaGpUMVpGc0dPUGdNaDIvSGhkeXdwQ3dJSndTN2hVK0pQd0tJSFQ3bFNFYktNMGJmUWRMcDcrY2oyb2h6MVdqS3lIb0dad2ZlQlMvZ2J5b1BNSmNaQTRDSmdwc1ZYb2hTeHVmUmRoQXFzejB2amZpclBpWXp4Nk03eVZMQmZjdjNFSXArUzVPUVBFSlEva0x4Y2ltM056dW5KdktkbDg1VFZRbkh2T3l0cVZacG0xclZ0MXRMcVE4SzU1ejNvckJSWGkrVmtOL24xcG91blZMczIyVDNtWm52VmpjVWNscC9GWW5GN2RPODV1K1VheXpka1pmbEhodVpMdGJLTGpiUjNMeFgrWjhGZDF2SzRhaGJIZXJSRTRtWlZKMXQxc3FHWXRuNlpwY2pwdUdraStuZlR1NTBBeXlxdVBteHB5Y2hueklkcjcybm16UVhFamFmcnFjVnd3ekxsTkZMUnNmSXlwZGVlV2NzWnpyaVB3K1pnY0NyUDdMUWxFNENQeWpkWVY1Nk5ISk8wUjJnTXc1clEvVjJRbDdweEgxMHpwL3A0aDZ0RkdES2ZUMVNpcFR0UTluUzNIN3haZ3haVmFNVDlSdkxtVVdkSzJJYlR1d0N6ZVZQaThTUENtSy85RlY4K21iSlV1VFRrdXFMWjJUTFJYZlNWUHlHUWlhOE9aVUJTVkt1dEhPbGc0Ti9icFJNU2Rqb3ZtaW5TaG1EdHREbVMydU8ycm5WZmRyV0p3U2lmajVZRy9CbjhlYUpaMlJhWDUzWXRXaStkbXFkQWFyZG1pbis3OTBQbkdCVzlRSDB6TGlNd0hmR1llNmFaRzdxOGZkcnl2N0p5MFR2VHRXaXlVTU01MmRXcmo1NTh3R090UjlDa3RUa2k3OS9ETXpYZ2tiMDVQMEJ2UnUwMG9VeWlNTEUvTzVrdjRyTnZwTGVwZUJweVRwTjcyM2prenRLVWtETXZmQjl1WTNRa215Z0NlK3h5VnNJUWZDb1NzREphRTNNSEFkMlRacFd1dUpaQ1U0TVR5MktFdmxVdVZZODdmTW9TK1hNVTU5bXc1QldNVXZOY3UxY3FZZzR0R2h5djdaeWRpUThkdk5ZNVZTUlpZWHg0WlBCSlZrWWoyRzBHL1JtNW92MGR2cElQYkhMc2JselA1eWJReUwrWkR6Q1BhVUo0VGp3Z3JWNzRRRUc0RVlLd3lRd3JDSERCRXcyQlE2em9vMkxySVk3aXlnaHF3MDJuVTJ1VjZqZWRBVUFBVDlzREcxTVIzQy9Nai9tczYwMDVNbnp6bWlrMC9PSnU2OEl6bE5FOGk1VCttTWUyTzZrckhGbkMybVM5Wk9ienhsckR1VEZYVGVHZk10NHBtMUNqWVZmQ3VtcytwdGtEcElaeWpwVm9tbTBqblRtL3ZpOUlxYTF2S3F0ai91YWVoSlRjMXJ2dnFGdXllRzBmdk9MYmJWT3hPenlUejkxblAzSnVHclp4SjNxNmx4YjZkVlNvdnhyR2huRkgzTUcrL29uMCtJbFQ5MGgxT1pPYy9NcFRGOEE0NFJmSkNtOEhIWkpQVDdhYW82Wkhwa2R1czc0RXZTS3JyTmpDTzErMkhOaDYvL3p2eFV1UGY3WllhOVNna3Q0VTNBNnlHM09SRUNvODNxZ1dJd0UzNmZoNFBSYXpIR0hvaUpXT2tCTEVNQUdnZWUwWWFyaEs3SkVQWjBqaG0xbUxzUTQzWGpERy9nTE9TeG9PUUVuYkRLU1Nmajd3dGdJYitRU1B0dW9oS1hNUXRRN0c5eDNGdHdwbTdGbWpHcm5xR0xNNlZlTnBDWDJKYndrRkd1SzlLZE1RbHZvM3F1V1c0b0tySXMrRk9pQS8xVGxZYjNHOWxTcFQ0MlVwLzI3ZTdOY1QrRDJ0VmlKdjBGV091aEYwV3BWYXFlc3gyRC9qaDJxamllcWkvYTN3Ykg1Ry9iaS9YVWVQR0wzNGNidjY5TVZwM0pVYXA2eU8rUlpZazhDbGJLUjRrazAxT2FHcHR3cXBQUitwcjV5QU92NldvLy92RU53TlJxZy95cnNodlptYStpZ3RmcExPMzFEZVgxSG5rSFhaQUViSTY4QmxEdHN0RFhCdERLRlhlMEFsMHROZm4wMEN5cGVvTkR2bENjcXhhQTRkbzVjRHRMTXNoWFgzTzUveW8zWkUwcnc5N09XR2FJQmV2SkNqQUlYMkd5T2dkKzhqK1pyR3FSaEJTR0M2NVdyaERQdE44ZWdJemV1SkJFVGdlN1ZHS0w4RTNTdWJ1NTFBTzZYYnB4Q2YwMXg5TXRNVHhkYVZBMHBhWCtYZ216MDVUUkJTYWJuN2dWdlk3VzhEcWVjV2diZVFYOUZmTmhLQUUrdkE4TGgyQUYwKzBlS0Z6bXB1c1p3Q3loNzMyV3U4UWx1djhydjNBNGo1SUpkdDc5N2VSOHpWbituZUIzbnI4RFNaL2wvR0Z3eitFRmRnK2NYMDdXNXBMTHdmTjNVRjB2NHJVQjM5OHE4OGE2Q1dKNk96TUp0dGhQWExuWlZYVm4rRmJnamR6amIvTGkyWmVtaWxFYVJxUlg2R0hyeXNwS3ZsSDRoNnRkL0xOWFdld3BjUlhDdUYvb1JTZnZCN3RmQ3o3b1piTWVtcnptV3gvc1grbjFrY3VoTHc1RXlBU2tyRDJJVnVGbDlQdGtTWnZzZDA3SXFqalg1b0JITVc2bXJOT0RISituclJRUUhyMjh3UUN0S1hTNTljZ2pkQnBUTkxSbW5XYU9tZnd6bmRNVy8yRDNoZDd0L0tQeXczc2Zsc0YzZklDTHdSVUNZWml1b3p1ZzZXMWdaSEFJRzhUYXBFM0FYWkhweXcxbWxhV1QranpWbitrZ3ptSWl0UEVPT3VHelU1OStnQzZmWVJxcUQvQXpuT3U4ZDc0OGV1cWRSckplSmNGUXBUamtlRitkR0ZXbXh0QlFwYmt2WXk4Y3oyZ1pwNTdOdlN0NWZIc0NUZXhORlJmTTFNak16ajJGeHZqNEJyNkc3cjlPWkJxTmJEdlJPcUNJMjM5bUtwWUxScVpmblBoWHU3VE0vRDBqdWxjb1pXNWI2TXdQbDMyeisvZWR1M01UTS9tajA4WFphckVVZDlXMGFZY2NYcGZSR3NQNU4wRGJBdVpUV00ybkNBdjNSV2ZaMlhxRFRyTDBzVVNERW1BV0dEVGRCZmdtT2s0Z1VsZk1zbUlRbTR2MktPOWVLNlhjZmc5NGM5MXp1NUt5Z2tPS2Z1cVVyaHhDaGlRWk1heG1paGtWeCtpSjJSeHZudXUrb0Z2Szdjeno2M2JGS2h4UzFwUkQwSjdVcU8rQS9iZEZ4NVk5d2kzQzI0UjNVaDBBaFlGWlVKRlJybU5tZnZDWjdRd3FvTFJkd1BIUTV0Y08zK205QVZETjNsMStXTWY1ZHNQbERxT05hTHp5ZVZRekh2Sk1QUHZxcjBvSXkxakg0aG1lK0pOS3c4Z21KcHRROTArN0FhMXc3Wi9hbldKMmFQOTJ1UFFXVnc2b3JnYko5OGRzTHBmRVpTYUg1czVJTU84bW1MNmhiMGQvUlZmSWhHYmNMZkVFZXErN3Axbkl1YlhtMU5FTXlFeDJhOWtqVkV5MVRtVjExOUs4Mi9ud1kzV01qZGluWTM1V1VmeW1DVGY5bzZGUnFXSnMybi93TkpWaTBCT3AvcjY3bUxRSkg2c3ZJNEU5N3dLd3pyM21reFd1OVJ6UFh1dVp3UjdQTitrWThDTFQxN1lMdHdvbjJSNFBSR2FZNTQySmJlOHllcXZHRlczdHlpdlhhMzFpaHd0Y2JuYzZiU2JuN2Z0WCtHT1JLNDFHaFYxcVRqNTl3MjEwL1FDWExLNnN2bSsxd3VSWmYreEErQml3dStmd0hwY0pNM1AwL090b3pITFlscjlHNVpJVzhuU2syUjNGMmgwY0hEbDUvUndQOFRuajFPcUt6RjBud2pHelhadjNaVytRY1U2TXY4RHA0amd0M25mVzRlZkNoVFBkUzQ3VHZSU0xzK0ZaUjNGQ1VGeG5KL0VWdHZOd1dXRDdoNHEydGhLc1hGeEIrZ09xK2dCSlc5M1B3cGlPanV2U2d4Zy9LQm5kZjhmUHJYUm9vK0wxNEZ6UGUzZ3NvTDZwb2p5QTZ3ZVBVdmh0MzBnMUJMQ3dzUEtoTmZZQ05oZTJuNzMyV25XNTZNUitET1ZiWUZyNGoyUE9laWZvUEgwalZRbDVHR0d2TkVkcjB1QStYSDNlSTJzVEZ6NXRpVE11WFUwNDFUbXFNMnh3UVdnM0JqeDhmRDRrb1k2bHY2SmJ4VXFsMkV0MDEwZlBqcTdEWVdWMFAzY2pHamxBdG5FKzNsbmEvU1dzbzF0dWh6WjVlKzdBc1FPNWZ2Syt4V3kyK3g1NklIMG11bjh4S2hIRzdQTE9PaHMxeEY2ZG1JM01GU3JDRHVHd2NEdk13eUgyYzhQdVdlTXF0akdPVFNOUi9JSUdMTEdVNmZuWkJvOGNpZXBzR1JXNStLRDFuZDd5d1dWdko5aSt3RzVXLys2QUh4Zm1aak1uTm02eEFsdmpNWWRPeTNaUmxFMFRGOU8yMlNNeVIyc2dwM3EydTg0eTZtVHJBeTVlM0lhR09qR25WR2JjZlNQbGtoTmJ5N2VzbTRncHkyUXZTbGpKQ0l2RnNUczh0bXdMdEpDYTd4SE83azJIa0FuNm1Jb2liUDc1MFpyRm4yR0dWSzhCMmppTDh0VnU5QU1qb1pld0tFa2p4TVRibmlVYUNnck5yRmhJeVpMR1FvMC9wajF0U0Z2eXN2YXp4cUVacXBKT05PVHBwWWxiSjJmZjdNMnFrZ2J4dVpXZlY4bGZwd3BpdGxsQVhGdnQ2RS9GUkNrOXRVUS9NTEl2RVRoM3RDZHZuV2lQc1hIaXg1Y3YwZjcxYjlnZStTNjY0bDBGWFNUY0d1OUhFVkVJZDdVTlFUUmcxNjl6N0xOUFlBQUZZcnkyejZHdndPY0ZmRnBNTFVFOFRnNzlyYkNvUnh4Y3h1RHBuSUljaHVadjUrcjErWG85eHpkZmZwaVQ1WXdzR3JSOXBxdnhmS1k0TkRPV0t1VHFwbEZ5cDRvM0g3bTVHRGMrS3B2U0xaSW9mMFRTdTI5eXNwcVZNalFSaVFSL1hFcG5KcGUyakEyM05LMVpuNnkzZ3ZSZUU0blNyS1RMd1htTVJJVGhxK2JycC9qRzB0RTRsbEtZRkdWTmNncUdvK20rWDg5WldXM2JrMVBGVXFsa0oyN0RXTHBYamttUFlIVFNvdStuYkszNzV6U2ZrNlR1TnVqak9UVXozNm9acXE3WTdTR2FTUXZUWm5nM0xVZ1lnMUo4REQzUFpOc0Fuc0hhMVNRTGdpRTlxd3R6NDB5MWVXQUxKYnJNd2NOZVNrRWRiZ1F0Yytqemw4RFdQZlArOTg4d2E3ZTArT0VQTDBwbjZLWERiejkzOXI3RC9PTHhoMVpYSHpvdTRUVnV4VnpqSU9jTHNvVEhnMkFjZzF1WE5ETTBSTE00SzBrSGM5bHM3aUR6OVpLT0ZQTDV3aEVKbkU5SnhDdkVlU2VIZVh5a2FEYzBDakxWVDJ6bThDejM0RVZpRDB0L2tUL3ZCL21UQ0puUk52RFpCdDNPQm5MWWpkR3BRbzZ6N1FONzU1OWsrSTlMYk1KWkhiQTUvSFI5amdlNWhhVkJFT3ZQN2Q3TkVFU1l2akxFejZiemErL0kzM2VOVC9UT045VWx3OWFWVjY4TG5SUnJFZDd4YW1WRjZ6MnhYcTA4bHdMT0p5QWdqaTJqUHdZZEtNcndxQ0hQRkVHWHVteGh3M3dsZzk0d0dNVjZXV2VsRzJNcnNwN1BSRi9qbU9GbGxYc0ZMTXRScVpseGpJUFhlcWlnVndEMU9za0syT0dKN2pZT2VlMWVRQ3UwT2tEWXRRTFJHdktwUy93TndNcE9jcmdzUzhBSEdWRDJNQXNKOUFxdDVDV2FGUWZOL3JPMDY1V3J0ZXYxbjJxN1Z0allBakVTSVRiSW5YU1ZjcC93TDRWSHdCYzVYTHF6SFZrZ1RxZzJlaFFLdlZTcDd5SFhKNVAzZStRS00vMVVsRmVEcW9mS2pGTDFXUzdBaDdNa3pwVG9xTVZQMnRYR2pNaHNJdk1KVVNFSmlhRGtCeHhFSkVkU2tQTk1rcVlTc2lyRzUrR1dUdXhtZURrK1RhOFc2SjJ6KzJZUmtmUDB6cG5qOE1iTjFwOGlTZnYwSTdHVkJZbXVURERHK1pzblRERVRPMFd3aUNTcGVFZy9IVHRQbDlaeVhGYjJFVTJXRGgyU1pIN1V5RDUyZVlFZHZ3T1h2OE9QL1BJT3I3bndTVHVqMm81MXZqa2pMM3pTejZnWiszeHpRWWhzdno5aS9zVjFZUUxhUWNSQVZtT1dNNFViYkRqcks0OU5xTUM4VGhmbUNyUHMxS3FOOWt3dlp0VDAvTU9jSGdZOTZPMGZkVlBQcFhkTitNL0pJd2R1Mis5cFR2SWRxZFE3a3M3M3h2eFBXdm1taGU1OHJObDhMTkZUUWdKTytmS3Ayb2o4bkQreEsvMWN5Z1ZWcEJZSDZ1WkQvdGducldiZSt0K2RUcUhLVkphcU1LRHpmMFc0VFZnUnpnblBnbmRBZTJiQUpsYmxUWmp6YVViUktYdjJzYXVscm94bTMzT0FpbnBJdEZHNG1Za21zUW55TjRJU3VKd29mK2JKczZBVm4rVWtiQ3dhVEtyREx6MEp4L0J0cG03M0w3K0pLMjRmNHk4L2dPdmNuc1FWY1daVndnc0JCQXk4R0xEUE12ZnJGSE05YU9iRFN3TkhacDVLRDF5NEVIcHQ5K0xTOUkxTjNZRTBqSjIwaFVEczg0dG9GL29FWURhWjNTbnNDL1hOSGV3MVRaTHRtWUh1aW1aOUl0MW1XVWpUMWR1dzRpdUtkSVpGMm5pVGN4ZTgzS1hJcnF6Y0NjazdFd2ZoWmZGdTJtc3VrSTlsUzQ0WC94Z3h5WE5NM3d1NFlmWWh1T1dod1N2UEVWTVEvai9qV1ltQ0FIaWNZMkJrWUdBQTRyZDl6cS9qK1cyK01uQXpNWURBdFYxSzkyRDAveS8vZHpPMU1KNEJjamtZbUVDcUFZUy9Eb01BQUFCNG5HTmdaR0JnUFBEL0FBTURVOFAvTC8rL003VXdBRVdRQWROWkFMclVDRU1BQUFCNG5JMVcyMjNrTUF5a3RoS1h3bEpTaWtxNVVveXJaRXZZandESkpXdnBSSkZEVWJJWHlRZGhXNWI0bUJuU0ppSktPOUdOMU9UK2JQVjV5KzE5cnNlTmEwbFVhK0syTGliM3phanRFNU43K0lyVy9XVDNWL1crWGEvaTVmUDk3L3k5c0V0L2tyUGtxdm5TUll5VHNkV1dZZTA1NjFyMy9kRG5kdjNBK3RoN1lXeTVzT0N3K01xR2I4Tzc1Vmk4eGtlemUvM1d2Ulp2dDF5bVhPSGI4TXJqK2hLbi9RTHJyV05WVHZnek9ML2dVSEJpeEY3UGhocTdYclRPaUZWZjIrdTMrRWxTSDV2ZVBQYW81NlV1OGhLRGZxN1h6NjIrd1hPMHZsL3U3Y3BtdXIrNFh0UUtjdk1yYWtWOERqWnhDWjZYZk1OZXJWbjYwR0xHUERuNHlzcEwxNXJoMkRsVW51cUVCZE9KciticklNZHQ3SWZPUEQrYzVTVis1MEcwYTdYL3hxRDdIeXppMWM2VXZzWUR2N1oySUMvcjFhOGJja0Z1ai9yUG4xdXRhWE9mUjMvL1IzbG9PRDU3blcvQkdCakl1L28xc05UZTloa2FlYlg2dFA4RHIyVDlROVovNlBXWS8xSS9HVTUrempVeXRBbmVwMTR4WGFRMWRoNHpxcTA5dFljYUpuWWRNNlgxNlRwN3lNN3NzODRUaFZsQkdqTStUemlROVN4cVJGMm1KNW1CYVpQWU0vL2dMR0VmOU1kRDR6cWpadk42Z1FjSGZ4eGlCRCtZdjhiUGdaa3c5WVhxcjloOWNlcytNZHU3RHQ2eGJyeVZ5UFZsRFlnVDhKbnc4SDZmZGVOelFXZUZ6K2ZrR0xTK09QRVpkZVZudFIrRXQ5cTQyRWVNaExoajcxTytYVDdQYU5RMHpZMklOUXc1NTNrZmREYjBIUHh1UTNkVERQT1gvZ0wzb0IyTyt0RHZ6dHl6Z1ZjTyticWZsZnZsek9RSHVRNDhMcjlOT1g1TG5aOXE4eXA4RjA1enRxNm1HclY1bUJjY09XZ3JHd2Q0anhoM3pPUVFSL1RETmx2Wjh5dWVxOHpSUGRick5aOTdOOVNCLzZIeFh3UXVBbTdDMFQzb2FPdHpvYnJ1SDFabm5HL1dyLzQvcFA0L3p6elBHaDF6b1piLzNxR09MQUI0bkRXV0MxVFBkeGpHbis5WGFKdTdFRUlSU3FFUml6VkNDTGtXR3FFUlFpTmJJN1FKb1puN05iazFjdGxrNjJ4dDJvUkd4cXlaU3lQVzV0YU1hZVMyaGN3KzdadzU1em0vMysvN2ZkL25mZDduZmYxUDB2Ly9qSjlrMDZRS0hwTERJS21pQThpU0tzVklsZDBseDFMcHhVaXBLdS9WeXBFdVZmY0YyVktOUUxBU0ZFZzF1YXRKVGkzT2FoVkx0ZGRLVHY2Z1NLb1RKZFYxQnJsU3ZWakptVmpuUFZKOWIzQkZha0Jzd3lCUUpybkEzeWhjYWx3RlVLTkpBSURQTlZseWc5dXRSR29hQ3VCdFJyMW01TGduZ1p0U2N6aGEwRk9MVEtrbE5UMWNBTDE1K2dCNmFrVitLNzY5Nk5PTHZscnozZnEwMUNaTWFndlh5NDZBK3UweXBQWThmZkdrUTZyVXNWRHljd1gwMm9tNHpuRDRCMHV2SlVoZGVIYWgvNjVvRGVEWmpkcmQwUmlJanozSjZVbCtiK29IRWRjSFBYM1EyUS85L1lnSnBvZitENlVCK0RLUVBnYWpJd1Q5SVhDRkVoTkszOE9pcGVHOEQ2ZG1HUDJOZ0dka09lQUp4OFBSYUJ6RGZDTHdPZ0xPTjlBM0ZveURJNUxleGkrVkpqRGppZmcrQ2Q4bjA5Y1UvSXBHKzV0NE5CVnQwemlQWVJZeGVkTDBFOUpiek9SdCtvZ2xiZ1k5ekNCbkpqT2ZDV2NjbnNWeEhrZmNMUHlhUlgrenVadk45eHptTm1lekZBL2V4ZSs1OURNM1gwcUFheDcxNTVNN0h5OFh4QU5xTFlSN0VYVVhzeHRKNUN6aCt3TjZRN0tXY2JhY0hWaU9saFhVWFlYRzFmaXdobjdYME9jNnp0ZkR1UUVORzlDUWpJYmtIR2tqSG0ya1pncGFVdENkZ3IrYjJLRk5lTDA1VWRwQy9oYTBicTBCNE5pR2Q5dmdUOFhmRC9GcmU1eTBBODRkN0VBYWNUdTUyMFV2dStIYWc5OGZvZUZqOW5Vdis1aU9wblQ0OTNIM0NSNS95aHd6NGNzazd3dnl2NlNYL1JGU0ZyMWt3Zk1WZVY4enp3UG96Y2FIZ3p3UE1ZUEQ3RVVPNzkrUWV3U05SNWxmTHJISDBIRU0vbStKUFU3dEUzQitoMjhudWYrZXV6enEvdUFrbldMWFR1SEpqOHpsTkR0NkJwL1A0c001NnA2anIzejhQNC9XODNCZG9FNEJkd1U4THhKM0VkOHZFZk16TXluRXcwSzAvOExacjNqMksvR1g0YnRDejFlcGM1WDYxM2kvem9DS3FQVWJ2ZDJnN3h2czd1OW91WW4rVy9oN0MvOXZFMytiODJMNitKTWR1ME85dS9SZWd2Wjc0RDZ4RDhCRFp2Q0l1Ny9vNjIvcWxoTC9tTms5UWVOVDlEL2wvMEFaWjgvWTkzL3c4SG1paktKbHpDQVpHd2ZLWkJ4U1pTcHhWaWxYcG5LYWpPTkttUmNpWlY1eWthbmlBVEpscW9hQ0hKbHE1RlhQazZsUklsUExDUkJiTzBIR2lidzZ4TlhsdkI2ODlVN0xPTU5YM3gxUW95RjVMZzZnVUtiUldwbkc2VEpOYnNxNCtjZzBkUVZGTXMyQWU2bE1DMnEyREpQeFFLdG5ob3dYTWQ3VWJsTkRwaTE4UHR5MWN3VEZNdTMzeVBoR3lYVHdCd1V5SGRId2l0OS9QOHZHRDAyZFFPY0lHWDg0L2ZObHVxQ2phN3hNQUhuZCtPNk9qaDR4TW9GdzlneVg2WlVsMDV1Y0lPNzZuSkRwbXkzVGo3dGdPUHZEMFIrdkJoQTNFQjBENlhVUXZReW1yeUhVQ1BHVkdRclhNSG9manU3WDBUc2lGcUJyWkNDZ1pqaWVqYW9pTTVybkdEU09vVjRFbm93bGJseXdUR1E1T0JzUHp3VDZuZ0RYUlBxYlNQOVJ6b0R6S0hSTlFzdWtKSUNIazROa3B1QjVORnFuRWpzdFFJWVZNVEhrVElkdk9qRnZVZnR0Y21McDR4M3Uzb0ZqQnJPYmlmZHhhSW5EeTFuTWRRNjl4K1BKdTl5L1IyOXp1WnNMVHdMNjVwRTNqL3g1ekdrK2NRdmdXNEFmaWRSTTVHd2hNWXZ3YlRIZlNmaVRsQ3p6UHJOZndreVhzai9MZUM1bnBpdndhaVg3dGdxZHE5bXgxY1N0b1ljMTdNdGFlbGhIL25yT041Q2J6TjFHY2plaUlZV2RUTUh6VGNSc1ppWmI4SFFySG0wakpoVmRxZkJ2WnkrMnc3T0QyQjMwa0FiWFRucllTWCs3Nkc4MzlYZWo5U1BxZlh4RlppOTYwL0Z1SC9YMk1ZZFA4UFJUY2pMSS93eWRuelBiejZtWmlZZGZVbXMvTmJPby9SWDZ2K2I5UURud05wdVpaak9iZzNBYzRua1lIWWZSa1VQdUVmS09vaUdYbUZ6cUhjUDNiOGs3em40Y1IvTjN4SjdrL1NTei9wNmFlWHpub2ZVVXZEK2krd3lhenBKL0ZyNXorSjJQN3oveFBJL09DMmd2Z09zaWUzMEova3ZrL0l6MlF2d29oTzhYZHU4eWQxZDRYa1h6TmU2dWU4djh4cTdlSVA0R0h2eU9ubHY4SC80RG4yL1Q3MjFpaXptL3c3enZFbGZDK1QzdTc1UC9BUDVIMVBzTC9BMUttZUhqY25EL0JFMVBtUk0vVzZhTVhYaUczbi9vOXptNzhQeW1ySnhBbkt6eEJ5dGxyUXRJQk1XeUZVcGtIV0psSy9MblZNVTgyVXFsc3BYelpSM0xaRjkwQlRteVZibXJ4bnMxN3FxZmx1VTN5TllrdDFheWJPMUJzazdPSUUyMkRyWHFSc3JXZzk4NVFyYStCemdoMnlCVHRpRjVqWWh0ekYxak5EUUprM1dGMHpWVjFnMWRibkEzNWJ4WkFJRGZuZlBteExjSWttMUp2aWQ1bnJteXJUYkxlaEh2aFQ3dkl0bldCYkp0cU4wV0RXMGZ5dnFROTdLUGJEdSsyNlBiRjc0TzlOOFJMUjNSOGdyY2Z2VFV5VjIyYzRMc3F6R3kva3RsdXhJZmtDN2J6VSsyZXlDQXEwZVNiQ0IxZTNyTDlvS3JGejMzSmlZSVRYM1EzeGRQKzFFN09GeTJQM2tEMEQ4UWZZT2paSWVRRzRMK1VIUU9KVzhZZFlhakl5eGU5blUwajNTUURhZi9jTFNNb2gvK0hyS2pDMlhIZ0FoNDMyQVdZNms3RGkyUlZRQTU0Nms5SVVOMllyUXN2MFYyMGxyWnljR3lVOURPMzBaMlNwWnNOSGR2MHR0VU9LYWhLUVo5MHlQK0JZQXpvVmg0bkdOZ1pHQmdPc3M0a1VHRUFRU1lnSmdMQ0JrWS9vUDVEQUF1TUFLTUFIaWNwWkhMU2dNeEdJVlBlZ1BicmxTa0t3a29SUkNtcFRDYnV1cW0zWFJSRUxvVWVzbjBRbWRTWmtKTDM4T3Q3K0JqK0JRK2dMaDI3Wm5wWC9DQ0lqZ2h5ZmVmblA4UU1nQ084UXlGL1ZmbDNMT2lYaFhPb1loejRUeHF1QkF1a0crRWk2amdWcmlFVTl3SmwzR05XTGlDRXp3d1FSV09XTlh3S0t4d2lTZmhIRHRlaGZObzRrMjRnS2FxQ3hkeHBvYkNKVnlwbFhBWlEzVXZYRUZkdlhSdDVIUm5heElibW8rc2ZUMkliWDh4bTd2dnN2NVZINW80V2RoSSsxNHp0WWpEUDhUMVRHVGlrVE5UUGQ3cFpETnJPUmZvSUxhaFR0MW10Yko2SGR1bG1UaHY3dHk2M1dnRW9uc1RHNklMaXdnT0doMXNZWkN3RHJuL3BHdjRuQU8rc0VVZkM4d3dwK3N2YnYwUC81Qm5NVjJMckM5MWVmeFRoNVRQR2Y2MzIvV29SbG5DaUpYQmxBbGo3TGdtMk5EVG91b1FzQTZ5enBCMHlEWlljYVMzV1dkblN5b1Q2bDZXN0tpMjBlQUl2dmc5dXBqMERuekdpM0lBQUhpY2JWa0Z1T3pVRVg0enN5NVgzbnM0RkN1VUFvdFR0S1c0RkdtaExTN1o1T3dtYjdOSlhtVDM3cU1DeFYxYWFIRnBDN1RRNHU3UTRsQjNkM2YzemprbjJjMWV1TiszeWY5UGppUkhadjQ1ZHdrdTBYL0ZKYS81aHk4REFrRUJpbENDTWxTZ0NqV29Rd09hTUFPek1BZnpzQlNXd1hKWURWYUhOV0JOV0F2V2huVmdYVmdQWGdmcnd3YXdJV3dFRzhQcllSUFlGTjRBbThFYllYUFlBcmFFRm13Rlc4TTJzQzFzQjl2RERyQWp2QWwyZ3AxaEY5Z1Zkb1BkNGMzd0Z0Z0QzZ3A3d2w2d04rd0QrOEorc0Q4Y0FBZkNRZkEyT0JnT2dVUGhNSGc3dkFNT2h5UGduZkF1ZURjY0NVZkIwWEFNSEF2SHdmRndBcHdJSjRFQmJUREJBZ0VkNklJTkRxeUFIcmpRQnc5OENHQWxoQkJCREFrTVlBZ0xNSUpWY0RLOEI5NEw3NFAzd3lsd0tud0FUb1BUNFF3NEU4NkNzK0VjT0JmT2cvUGhBcmdRTG9LTDRSSzRGRDRJSDRMTDRITDRNSHdFcm9BcjRTcTRHcTZCYStFNnVCNXVnQnZoby9BeCtEamNCRGZETGZBSitDVGNDcmZCcCtEVGNEdmNBWGZDWFhBMzNBUDN3bjF3UHp3QUQ4SkQ4REE4QW8vQ1kvQTRQQUZQd2xQd05Id0dQZ3ZQd0xQd0hEd1BMOENMOEJLOERLL0E1K0R6OEFYNElud0p2Z3hmZ2EvQzErRHI4QTM0Sm53THZnM2ZnZS9DOStENzhBUDRJZndJZmd3L2daL0N6K0RuOEF2NEpmd0tmZzIvZ2QvQzcrRDM4QWY0SS93Si9neC9nYi9DMytEdjhBLzRKL3dML2czL2dmL0MvM0FKQWlJU0ZyQ0lKU3hqQmF0WXd6bzJzSWt6T0l0ek9JOUxjUmt1eDlWd2RWd0QxOFMxY0cxY0I5ZkY5ZkIxdUQ1dWdCdmlScmd4dmg0M3dVM3hEYmdadmhFM3h5MXdTMnpoVnJnMWJvUGI0bmE0UGU2QU8rS2JjQ2ZjR1hmQlhYRTMzQjNmakcvQlBmQ3R1Q2Z1aFh2alByZ3Y3b2Y3NHdGNElCNkViOE9EOFJBOEZBL0R0K003OEhBOEF0K0o3OEozNDVGNEZCNk54K0N4ZUJ3ZWp5ZmdpWGdTR3RoR0V5MFUyTUV1MnVqZ0N1eWhpMzMwME1jQVYyS0lFY2FZNEFDSHVJQWpYSVVuNDN2d3ZmZytmRCtlZ3FmaUIvQTBQQjNQd0RQeExEd2J6OEZ6OFR3OEh5L0FDL0VpdkJndndVdnhnL2dodkF3dnh3L2pSL0FLdkJLdndxdnhHcndXcjhQcjhRYThFVCtLSDhPUDQwMTRNOTZDbjhCUDRxMTRHMzRLUDQyMzR4MTRKOTZGZCtNOWVDL2VoL2ZqQS9nZ1BvUVA0eVA0S0Q2R2orTVQrQ1EraFUvalovQ3orQXcraTgvaDgvZ0N2b2d2NGN2NENuNE9QNDlmd0MvaWwvREwrQlg4S240TnY0N2Z3Ry9pdC9EYitCMzhMbjRQdjQ4L3dCL2lqL0RIK0JQOEtmNE1mNDYvd0YvaXIvRFgrQnY4TGY0T2Y0OS93RC9pbi9EUCtCZjhLLzROLzQ3L3dIL2l2L0RmK0IvOEwvNlBsaEFRRWxHQmlsU2lNbFdvU2pXcVU0T2FORU96TkVmenRKU1cwWEphalZhbk5XaE5Xb3ZXcG5Wb1hWcVBYa2ZyMHdhMElXMUVHOVByYVJQYWxONUFtOUViYVhQYWdyYWtGbTFGVzlNMnRDMXRSOXZURHJRanZZbDJvcDFwRjlxVmRxUGQ2YzMwRnRxRDNrcDcwbDYwTisxRCs5Sit0RDhkUUFmU1FmUTJPcGdPb1VQcE1Ibzd2WU1PcHlQb25mUXVlamNkU1VmUjBYUU1IVXZIMGZGMEFwMUlKNUZCYlRMSklrRWQ2cEpORHEyZ0hyblVKNDk4Q21nbGhSUlJUQWtOYUVnTE5LSlZkREs5aDk1TDc2UDMweWwwS24yQVRxUFQ2UXc2azg2aXMra2NPcGZPby9QcEFycVFMcUtMNlJLNmxENUlINkxMNkhMNk1IMkVycUFyNlNxNm1xNmhhK2s2dXA1dW9CdnBvL1F4K2pqZFJEZlRMZlFKK2lUZFNyZlJwK2pUZER2ZFFYZlNYWFEzM1VQMzBuMTBQejFBRDlKRDlEQTlRby9TWS9RNFBVRlAwbFAwTkgyR1BrdlAwTFAwSEQxUEw5Q0w5Qks5VEs4c2FSaVdGWW9vYXJWOXZ6Y21waEZhSmNOYWtVUngzWENOc044eVhkL2s1NjdUOVZxbThHSVJOaldSWlp6T3FLYVpLenF5aG9TaDA3WGpxdUc2SXV3Nklxb2EvWGJpR3A0cE5qYjZJblJNdzJ0RnFvcmhkUk9qSzFxT2JEVUlSZXg0M1JJWHRQMXducCs1b21YNVNWdmRodDYwUlhhM2RNcWllcDJkTWlWQkxlTkRMNFg2UFJWVU5Tb2FKMEhaQ0UzYkdZalZqREQwaHkzRGpWdW1FNXBwN1ZkYlpVT3J2OHFxMmx6MktuTVN6RXhzaTlycmhINmZKeUdPL2Y2eVJWYlp4L0pGTnRYRDBrWEcyTTkzSUt2TlRxaXFrZXN3V3BrWTRhcytLN1V1K3F6VXV2aXpVbk1TNUd5eG4zN0YvSlJOejFUZW9ocWJtekx4K3pjbWhpUkltOGhOd0xRbDEyaCs0R2VuVEhMNkZjL1Z6dzMyYk00aTI1dkxjZFhhVE03QUw1ZzJwaGVRZ3FwVTJuQnVVS2N0dVZmTkQrYnNsQ2tKVWo0ZXhPYVl5d1pteGt4VmJvd3B2MWRGa3lRZHdVZ05vWjBuZzlxRVZGSm9aMkJRMG1BZEk0b2MzdEVEZm1XK0M0ODNZeXNhTWVwSEZZTnZvUlAxME9EdlRTekhiMWtpTWtNbmlCM2ZxN1FOc3pka3gxRnZHeFp2WjlNV1pxK29jTE50cUozZmlrekRGZFEyWkdIUGFobU9MQnlhdmlYa1N6VXlIQXJER2hPdTQ1VlRVdUI3eEsxRmdsdDBXL0pTeWRnc2c1Nkl4dy95M1BiOWdPdkdOcmNhOHplTWVIamR1SmtSMFEvaTBmaFJKM0hkTWJFTnR6T2JFVGxMMHZObFBIS055RjQ5WTdFZENwR1ZpYWd0ckVKYmlMRFdGdndHcW1oQnduTGJNVWU4TUd0dHgvTk5kb255aTV3d3RpMWp4STYzSjRwdDEvRzRydStxUzh5WGZyc2cvWE5GWHZwRzJHdTAvYUVyWjBaKzNaZ0VqaGRWMi82Q0hucGlWT1NmaUxqQWduemVkZjJCS0xkRHcyR25QTjhPSGRFeGVmQmFmV0d4TzNhcll3dVg0YVVnUW1vbjNVbzdjVnlMcXpOd1hmYkpuZ0tSR1BGc0pLSEhaYUlhMTVaZkV2dGhRODZ3WnhtaG5OQ1pNVkZ2MUJ4VDdqQmVQbUVMcG12MERibUlKalg2anBkRWt4cUJtMFNUaDdIVEYxRWxvOXc5UnhSRExhRVVjaFFKL1pJbVhDNklFbGRFeEdGdG5uOWl5cWRQVzlRK25iTG9mVHBsWXBlaXVZb29HaXFIb0tGMkNCcm5IY0tVSmRmUmxFT1lNaVZCUlhQMkRBemkxc1NUVlJXWHcxSTNSY2dobUtjd0ZqWFQxc1dFVWRXd0xjZEhJVjRqSWpVR2ptaW9LVW0vS0NXNjE2SWljM3lWc3NDSmJEL1FRNXN6MUZQaTgzNmYxVmdwQkZtd251TXpHdmZrOHVOSHRRbE4yKzk1OHF0ejdXdERXaTh3aGw2dW5xUnBieXNUSWJ4Y2I0cW50VUxlSmJsYWtoWVZYTWJYUWVoNytlbGZiRlBCZHBFdG5kQnBJMGU5ekpMVEo0dHRVODNsTmNyOElpTTc3b2xsNkkySmJLQ1pFUjJBTTVaYlc0dHRVOTNtMTlmOElxTmN5cWtsQ1hpVWVLODMwZy8wL05pMFM1ck1tcTRUcU5uV1czbG13bVdZcUk1cFVVMjd2SHBpbnErUjRCcUdDaEE4NlV2WmtsanFqVjNmc0xTUG1ETE5hWm9FMmZORzNsQlVwR0M2U2J1dWdnTTdNeGFLR3B0K3YrL3dwRXZNKzc0ckNoS1dUTC9URVlKTXY4dThHNVZOMzAzNkh1OGFMczVDVnZaUlRuRWx2Y3RDL1lBallVUGVsU0xtVXMweEdUcVdxR1JzM3ZTOWdSajVZWXU5ZTV3V3pGbTQxMkJVbFpkMEFrTHAvWlRFYnJVNUxQYW1MQ3d6UEY3VEUwdVo0NnZKY2F4Z2hpdysrQkpGdHVHRVVjRk0ycnhWK2NKdm00UXlBSkNaeEJYTGlBMFpFZ3VXTURwMWpzKzlXTy9mY29xcmxtTjBQWjZZcU15bzczc1dXWjVSdDN5WFE1R1M1QXFuVVhGZTR3NDdkdzVvc3AxbDB4WlZxamxsS3lwV3Mvek1ZVmF5MmExWVNiOHRnMkJCZmw5UnJCQm1QTVBVQ1ZoMHRHeTFhU2QwOG1Rdy9XVFFGRHpBcmgrSUZ2KzgyVEhUaTdxUzhSSjdmdzVqVlpHRXZ2cXlCb2NhbTZXK2todVZqQ3pOQmFEMGphZE11dFhsZVZNY09pcGpxT2VNTmJFUUtGWGp4dk1aSEF1dTVwU2xuaks1a0VvYWN4V1dEWjdoU2ordDNOZWEwNVowdy9LRDVhLzFvRGxsckhONGJsbThZZ0w1K1l5Vi9pQkd6UTZydUZhbTFScUtkZnhRRXVvWUM2V082SE5ZYlhRYzRWcXNtM2pwamVvZHVYQkYyRm9oNGtySGNiVlkwMEJuU3pWTnBDVFVVRG1KcW9hOENUV1NjNjRmODZnSmR5NkQ0d0ZVQnFmUHlhQitsZ3FUU1hlcFFSZFVDa0cvVDJCMWRCY3lIczVxNUE4NW0vUTVxZFNsbFdUUWNNQ2o3dXZ5UXorMENoTEpkdnF5SThuNkpiN3dCODkzbkZDK29jeElFNDU3SWl4SUMxY05lZFJZdmM3d2l1L3FqeFc4WlF1U0Z2a1M5ZW9kbG04OFpISjlsalF1ZEhock56dStuOU9vWTJZTHR5OUgxdzk3cnRPSnkrbVVGTmtmRExtQkpHWWxXTzZ5bmduWUMzWU5YdC9VRmYxYWx3V1FDRm5iUklVdVYydDJ1ZStveFJLUlg5a3BzdUJyaTJyWGR6dXFONDJrODV6cGhvYVZwQXZlQ0NwMnVvalEzaGJ0N2REZWZzNld5OVAybGZMak1MOVFWd2JYV2NVdlZWTTRNSGh0cFZBWXBwalZVSTY0OHVaNXJoS3JIRmVlc0premNQU2JNQkhPS0JJS1V6Z0Rmb0dxcHJ3WWRaM0lkS0xJRHlQZGV4VHdBMVdFUFdOUGxHMWU2YkhSSmR1eXlqWm5FdHhBVGQ0RG0yTlNWR1FZeGxWMWJRc2o1aUlMUnRmM3lqYkhNVDhjMWZXYWJ3V0o3RTFqem9mTVhsU3cvYjVvMkg0VU9MRmVsTE5qRW8zNlBFR1ZqSFBGSk5SendSTTBNMkVxblpqUUtGYnZrdkdLMDJKWHpsOVdjVGcyeU15cDdsZzZMa2dIbnVLaTJpRWxkZVVxbmxUOGpsZlZ3RS9pb2tJbHppRTRsRFg0bGtReHB5ZlM0MldrN25nZFAzVjFHdXY1TDBqTUxRMjRKbzlGU1g2TFk4NnNZRy9SOHVWSmpYUXh4RU5TNForSzk1WHMrS2JrY3BUbkxNdmxzRk4wQmNlVkdWZndNbFZyUWJudkNXMW9tS2k0Vk1sSWxSZStWQ2s4MzY1Y0g1eG10QXZTbVRGbFNTLzlkMFdLRFRVV0N2Q1dVUGZFTGNqN0RFc1B2YWFWbDYxa2dyU3BnTnlKa2xYSHJDRFJNbFlxM2RiMHNjeGltMUpUaTJ3Nm1DOHlza3pQV2RRdXlIRzFDM0pjNzRLY2djV1l5N2VCRThsODJrMDRQRmwrV09TSmRzd1NYejJXQWRJN3ovU05RRzV5ZGpwcVpDZTBMQ0huZ1ZWNWx5TVdFYU02UDR4U29kbFVtQmVCM3hNdGU0b042amxXa0xqRURyZm54TlFYZHBrbEZTL09VYlh2c0FoaHJ4L01LS1IybFh5THVSeFYwYVkyTVRTVXIwNFhYRk9UZE4rbHpEZGp5ZEtDYVNLaVNLM3Z0OU9Zc3pTREhvYzJSOHZIYVZOSlU3WjZ2RzhadW5xQXhyVFE5em5ROUgxZTNpb0xiL2I5SkJLWjN5bjJrNGlIMmhNSms2b25ocEh5Y2syV3dpTEtvay9EYjB2ZDB1cUdmaExNcENUeEZDMm4zMUhtZlNpM1h6MHdwSHRyaHdtUFJ5QVBROVh5TFdsWVY2MXowREk0TTFOWTZtaEdvY0VPT3JDTGdUeHhhUVNHZkVVOWVFVkZpRE9oY3JxZWEvS3VCNHdZU21vNnJ1NUZRVm5RNDYxYmx1MnJkNXJNVVNQRnFucEtCbElnYzBlU0ZBTWVzNmlxM2xBMldWU296dGRSK2tJRmlmbVNkT3N5K0dZSnBjTHBGR3VTam93dWxib2JpY3VCYjVuOG5SVDRmaVh3d3pnMFdDWUVmaUpkTzYvZ3FvcmtMVmJ4YTBpOW5SMDNxUU15dlN5V3ZZYTlHSVF5OUFlOFZJV1Y4UE5Ha0t4YUpYV0J3MUdsdEZJZEo4MXkxaGpsVk4rRXAwSXk0OVdWaVdPeGVqSHQyc3FFMTRMTzlqVlV1N2djR2lZWGprdWNqMWgrZnhtSHJqZzlhWlp4aVdPc1dEcXhaVjg1TXpGSkpWaG1LdGRraGFXRXI3U0lCTFZRZE9WSkhPTkdLRGpVeHExdGxkL01TQzBGY3NZMXJQTE5sUjdmTFNwVUQwVThGSHJwbFZOY0NGbVBsMlJNRlhFdGpMSXBJWWExVUdXa2N2QVpCa0xEUXNTcVkwNmV4bms4SFpuL1g1WVpZcC9kRmM4Q3ArSGwxRlpobXJEY0R4dVJrRUpSSzdaNlN1VGNselRtV3pqZ0RjZnhXeWxjZHk1RDJVbkkrRkhjMENqMUVJclVXWm4xT0lTb0Y0NXNwVngxU1FXVlBDdHBVdUJiMEpTWFFBb2JxWDVueGt4S1JLc2hqemNDZmJiV25jMFJlWmpZSEhONStzSnR5cVhKM1NkeXlaazhsblgxTHcxSGJjeHlpcHRULytab0tNYnVRYzFoUmtvU0dDNVhpVmwvQjNPUnkrc2hsQ2xSOXYyWllmeG9zUGpSb0JqMTJmZVZvNzR2RDFpcWtlY1BXWXYyeEN3ckN0bGRZQnNxSmpWelBPRytGR00vbUFxM21ieUJ3N0tpNmdCTElTOVIvNzdSMFczS3d1NVA4U1FveUh1VG5hYzg4OVdqVTJSbUNiWTVlcm5ZRHVlMkthdW51WTA4ZVMxcFBDZWxVVDQ1cUNxRDFFOEZpWnE4STRKSkdxTllxcG5yVEdKV1lweHk4OUtRMG0wa3p6SWs1a3hZNy9TcXhFT0ROelJiUTdrMUJvNFljcU9odzlOc3N5dnYydFVvYVd1M1VtSTBORWFWS0dFWHdCa2xSWWxYajNobmhQcDVKUnA1cHRxd0VwU2prUlF4b3NHSnVFdzgyUHM2VVZHUm1ycXFxVithd1Z3c216WTFVeG9tM2E2d1NwcVY5UzNpc3FiVW8zRXFBU2FVMk0wVytDZTdqRmkxeHNhQ1U5Y3ZvUS9NdVF4dlJNTmw0MExNUGxyNnI1ckM3SVJpdXhMYnZGakRyaWhMd0o0SFkzcys1dHlubjNhbk12NjV2RVhPMjVSQlR0T3l2Q0U5RlY4N2I1cytMNi9uSGpGTyt1MUluM09tbUJlaVF2eWh2VnFzamtTVXg5T3dvZEs3VEdCb2tna016VEtCb1ZucVBoUXB4REpTeEg1WCttRU9NOVVNY3QrY0pnbXBySXJTWDN1emZQVWluWE9wczhjY2wyVWpkWUpSVktnaWw1VmFFeEpVc2dPRFdpd2wwVWkvdW9KY25GTU5pdU5SSlI3b2cydU1CeFgrMUZDNHJsRk5WSWJuZUtMQ1NJY0ZDZVlTanhQdk1KS1ppR2x5QWxoTERVNDhLaVdlMU0xc3lTUndTY09TUGthckpaR1ZqcFdDYWJSallhRS9Td0g5dkt4dzM2cXF1enB1VmlnUzdPcmptc0o2RkNVc3lrdlVZUFhrUmF4QlpEYmJ6RWpQWTNrL1pweTA4V1NrVFA5TEtpTU56ajZTVEs3V05KRml0S2hnWWVBWWJsRmUyQ0FUK1ZuV0t5NUhveXlucm12OW9oWlBodnZjZGkzRmNvWlRtQVJOZGhqQ1ZoSlFwZ1pqVmxTK29UVFVtMk5vQytHYTh0aXRQSlJwSXF1ZW9kTnhha1BPcDdUeWI2UlFuWGpPcHFUUE82L3ZySnB3enNrbG4wazVxeEtXb2FLa2FXWG82LytJbDRZaDZ6YTd1TkFLMmVlTWhMWXVXZkovL1FNRzhRPT1cIikgZm9ybWF0KFwid29mZlwiKTsgfVxuXG4uZmFsIHtcbiAgZm9udC1mYW1pbHk6ICdGb250IEF3ZXNvbWUgNSBQcm8nO1xuICBmb250LXdlaWdodDogMzAwOyB9XG5cbkBmb250LWZhY2Uge1xuICBmb250LWZhbWlseTogJ0ZvbnQgQXdlc29tZSA1IFBybyc7XG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgc3JjOiB1cmwoXCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQVQyUUFBc0FBQUFDcW1BQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJIVTFWQ0FBQUJDQUFBQURzQUFBQlVJSXNsZWs5VEx6SUFBQUZFQUFBQVF3QUFBRlkvdUZEK1kyMWhjQUFBQVlnQUFCU1hBQUF0Q0NqdTcyUm5iSGxtQUFBV0lBQUJDS0FBQWp5WTdUcFZubWhsWVdRQUFSN0FBQUFBTWdBQUFEWVBEb1kyYUdobFlRQUJIdlFBQUFBaEFBQUFKQVErQlFWb2JYUjRBQUVmR0FBQUFwa0FBQXMwV00zK3BteHZZMkVBQVNHMEFBQUhkd0FBQ3pnREVUOGNiV0Y0Y0FBQktTd0FBQUFmQUFBQUlBUHJBVVJ1WVcxbEFBRXBUQUFBQVY4QUFBTUdZTEZwRG5CdmMzUUFBU3FzQUFBUzVBQUFKV2g4MXoyNmVKeGpZR1JnWU9CaU1HQ3dZMkJ5Y2ZNSlllRExTU3pKWTVCaVlHR0FBSkE4TXBzeEp6TTlrWUVEeGdQS3NZQnBEaUJtZzRnQ0FDWTdCVWdBZUp4allHUjh3VGlCZ1pXQmdYRWFZeG9EQTRNN2xQN0tJTW5Rd3NEQXhNREt6SUFWQktTNXBqQTRmR0Q0TXAzeHdQOERESHFNWnhqY2dNS01JRGtBREZJTlBBQjRuTzNhYWJ4UFpkY0g4Tjl2bllPaXBKRWtJVTJLWkthU2VTaEVoa1NrSXMybFFta21OQ21TVWlITnM2UjVFaHFrb3ZGcHpxM1NjR3U0OTdYM3Zyc2I5YXgxZmw0L2I1L254V04vdnEwNjUvei8vNzJ2YTEzcld0Y1JnR29BS3R3QnJoS29kU3pvLzRhYXcveXJyUHA2QldwV2ZiMnlaak9BamZ5TE5kQW9zNnhhVmp2Yk1kczUyelZya0RYTU9tYzlzZ0haeUd4MGRtWjJTWFpaTmlPN0tyc211eTZiazgzTDVtZUxzanV5SmRteWJGMzJiclkrMjVCdHpIN095bXh6cXBWcXArMVRnOVF3TlVrdFV0dlVLWFZPdmRLQWRFd2FuY2FsODlPMGRHV2FtK2FsbTlNdGFXRmFrcGFteDlQemFVMWFsejVPbjZiMTZkdjBZL29sYmM2WjE4aHI1UTN6NW5tN3ZHUGVOeCtRajhwUHp5Zm5VL0pyOGxuNURmbTgvTlo4VVg1M2ZuLytWUDVzL256K1lyNHFYNWUvbjMrZS81eHZMdW9YRFlzV1JlZGlRREd5R0ZXTUx5WVhseFJUaTVuRjFjWHNZa0d4dUxpbmVMeDRxVmhWdkZxc0tkNHUzaTNXRnh1S2I0cWZpcndvaTc5S2x0WExPbVdUc21uWnJ4eFVEaXVIbHpmLy9UZVFJYXZNYW1SMWZJVHFWbzFRNDZ4TDFqc2I2Q00wSmp2YlIyaGExUWpOeW1abmMzMkVGbVNMczd1eXBkbUs3SjNzUXgraHI3THZzaXo3TlNGdG0rcWtlajVDalZMVDFESzFUNGVtTHFsUEdwaEdwakZwWXBxYXBxYzVXMFpvUVhySVIyaFplaWF0U0d1clJ1anp0Q0Z0OGhINk5VZGVtZGZNNithTjg5WjVoN3hMM2o4ZjVDTTBJYitnYW9SbVY0M1F3bnh4ZmwvKzVKWVJXcG12enQvSlA4dS96TE1DUllPaVVkR3k2RklNOUJFYVUwenlFYnE4bUZGYzVTTjAyNVlSV2w2c3JCcWh0VDVDWDJ3Wm9jeEg2UGZpYngraDJsVWoxS29jVUE3MkVSb1JJL1QvZi82SFAvU1YxcFI3c3cwNytkVzU2anFmbC9FNjN1M1hDbjd1MTFkVjEwWit5MDErL2N6TXFsdE4yOXYydFE1K0hXS0gyMUUyMnM2elNYYStYZWJYRlRiZjdyVDc3VUY3eWxiWkIvYXBiYlJOOXFQbDlzdVc2MWZiYkpzclVGRzlvbDVGL2FxcllVV3ppaForZGFvNHBLSmJSWStLb3lwT3JUaTc0cHlLS3lwbVZDenk2OEdLaDZ1dXBWWFhzb3JuS2w2b1dMN2xXbEd4cnVLRGlnOHJzc3B0S3J0VTlxZ2NVM2xSNWZ6S0pYNjlVTG5jcnhXVnF5cGY4ZXUxTGRmcmxXOVVYZXY4ZW1mTDlZRmZuMWF1OSt1cnVLcnRVcTFCdFNiVm12Z0E5ZVZxYThpeE50QWVaR3M3MXliYWViamRwdHZ1MW9DRnRjTUhQQld2MmZiNG5WT3NoaDNIRzNnck8vSkVlODZlc2VmNUd3YlphWFk2VHNWcC9BVXplU2pHYzZwTnNITzh1bFhEVnFqT2VWekhDKzBwVHVJWGZBQVZOZ04vb3JzTjRxN293Ky81a2ZWblY5YTNvL0FYbnNWelB2N1AydVZZeU45NUNiNURQN1JHR3h5S0Z0YVUyK01MbjVzWDBaTmJzdyt2WkR2V1kxM1c0cmU0MklpUGVTOWV3ak5XeDFyd0VCNk1idWlLV3pHRFYrQy84SWtkYVczdEV1NXNyV3l1M2NHcitEVy90TVhZYUR2eGVKeVArUnpPbzNrTWgyRi9yOVBOMFl5SDJ4dDJCdHZnUEhTeGh6Z2JhOWtKUDJBRDM3ZTYxaDlIOFViT3RlRjJpNTNBZSt4R3ZvenJNQS9YWXpZK3RON1czWHF4MG01alR6c1ZKMXQ3bTgvLzR2WGNDbS9nTGJ2WEJ0dEluSUQzZVFacWNoa2JZZ3dIOENmVXhuYW9nMjJ4QTNiRVR0Z2UvK0pNRzgrVjNNeS83UWlzc2tQWWpZK3pCNmV6ZzUyTjkyeGIzb1J2OGJZdDRwK2V5OXZZS0R1RzFmZ3JuK0hUdGkrdVlGdmJBWTloR1I3SFVteGp0K01DL0UzYWp2ek9MdU1Mbk1WcnNJaWZjaWZiRTU5aURtN0VYRlpuanNKMnNiZHNaMXZEZzdpSEhXWmRyS3Qxc3g3VzB5NjJpM2c3NytSaTNzRUd2TStPNVN2WUdaTndBMzZ6Rlp4amZWaGhDOW1mTTdnYkptTUZQOGIzK0tkVncxVjJwczNHajl5Zkxia1htM01mWDQyTmVTRDM1SFZZeWZjNG5pZndBK3RvVGF3eFRtRjNtNGV4L0NmWDJDcGNoT1B0T255Slh0eUZiMk1jYnNFQzNHWXo3VXFjaUF2eHV1MkZtM0VUa3UxbjkvTlZPNXJqN0hFK3hpZnNXcnZHSHVNanRveEwrU2lYOEhYMnRqM3NQbnNBeDluVk5nSWpNQm9qY1N5TzRXczhoMi95TFJ1QzFUaUNaL01zbnNrSlBKWkRPSXFET1pvak9OU3VzcTNzWmt6RjVaaUdTM2d4SCtSRGZCZ2Y4VU1iYWdkWWM0N2hQMndCVGtKdmZvVnowQU8xOEpPMTVsMDhqdWE3dnRrOVBKY1RiYkpOOGNweGdkZVBBM0UwLzJXdjJtdTIycTdnazliWmx0dXo5ckE5WWt2c1VWdnFWZVV1dTlWdXNEazJ5NmJhTks4NncyeUE5YlUyZHBEdFk3dDVYVEtyc0VyK3dZdy84RWRPOXVyMUdUL2hXajdINTNrYkYzQWhGL0ZtVHVPbFh1VXU0RWs4a2dNNWlFM1lnczE0Z05mQnB0eU90Vm1ITmZFRW5zUlRlQnFmWXgxZXhmTjRBUzlpT2E3R05iZ1dzekFkbCtJeUhJNis2SXpEMEJidDBCNGQwQkdkY0RBT3dZRm9pWVBRQ3J1aEFYWkhRK3lGdmJFUDl2WE9wekdhWUU4MFJYM3NnVWJZRDd1Z0x1cGhWKzdBSFcwNzFyQnRySmJYMXEydEVZWmpGQ1ppRGQ3RU8zZ1hYK0ZyL0l6TkJGdXhGeS9pMWJ5V3QzQSs3K2RUWE81MStpV3U0Z1ordzJTMXZUSjNzSU90azlmbEUyMmNqYlZUN0ZLNzNtNnl1KzExZTlsZXdXZmNGa013R0VNeERLZmpERXpBbzdnRGkzRW43c1pkdUJmMzRIN2Nod2Z4QUI3R1ExaUNSL0FOTnVFUDd1NTd3MkU4Z3YxNE1rL3gzV0U5L3pKWVMrdG54OXRaOXJTdHhOYm9qd0U0RWdOeEZzN0UyVGdYVTNBbFhzWXIrQWZXZTZ1UzQxZVUrQS8ralYrNEgvZGxlM2JoVVJ6SjAzZzZ6K1BsZklQdjhoM2ZhZjdOa3YreCtsYlBkclZtdHI4ZGFtUHNKRHZaTHJRbjdFbDcwVjZ3bCt4TnI4M1YvN2Uzei84RGY3YUpmelIrV1A5aGE2TWpGUGIxU09GcWp5YlcwR09sY0t6SGFtSURQZFlRZTlEalZzTFdIcmNXTzlkalRiR0pIbXVKNzRuSXRoSGM3bkZic2VrZWE0dnQ3ckdPV0FPUDJ3c0xqenVJNzZmSWRoUjg0SEZuOFQwV1dWM0JheDdyaWNWNzdDcjQzV01ENFJTUERjWGltUnFMSGVleGlmQUdqM3NLYi9YWVZOalI0MTdDRXozdUxmYWN4MzNFbnZHNHI5anpIdmNUMysrUk5STU04cmkvMkdrZUR4RHZCcEExRjhSenRSREV6eHdvM2lzZ2F5bVk2ZkVnOGY0QldTdkJlSSt0aFZNOXRoR2I0TEd0ZUorQnJKMGd4cUc5eEhrczZ5Q0llZTRvOEJXVmRSTE84M2l3Y0ozSFE0UVhlanhVN0NtUG5ZV1RQSFlSZnVHeHEzaFhnNnlieEJrdzZ5N2U2U0RySWQ3eklPc3RpTy8zRVlzeDdDdU1lVDVjRU44L1F2aTl4MzdDanp6MkY0czRRQmozTWxCWTMrTWc4YjRLMlJiZVlTRWJMTjVySVJzaWlIa2ZLdHprY1pnd2Z1Wm84WjRNMlhEQlFvL0hDQ01uUjRoM2JNaEdpdmR1eUVZTDR0N0hDR0kranhmRWZKNGdpUEUrVVJENU1sWXNjbmFjTU5iQ1NZSVkvL0hDbnoyZUxONGZJanRGME5QanFjSlkzNmNKWTJ4UEYxN3A4UXhoNU5HWndsaC9ad3RqWFU0UVJqMDRSN3p6UkhhdTRHS1A1NGxGVFpvbytOampKUEVPRmRsazhWNFYyZm1DV0dzWGlFWDltQ0lXNDNDaE1ITHpJbUhrN01XQ3lMdExCSkVEbHdsaXZVOFRSQjVlSVl3NFhid3pSalpEOEluSHE4U085SGlOV0t5eldXTHhPZGNKbzI3TkZvdjFPa2RzcnNjdDdBNlBOd3JqdmVjSnYvWTRYL2lseHdYaUhUbXloWUtOSGhlSjdlUnhzVEJ5NXc1QmpOOWRnbmkvdTRXUnAvY0lJMy92RlViTzNpZU1ITDlmRURYc0FZbmYzMlFQQ3FLR1BTU0ltdmV3TU5ib0kySnZlRndpRm5tMFZCaTUvWmdnOG1LWklPckhDckY0NzVYQ0dNdFZndGpqWGhaR3JYcEYvQVNDN0ZYQkJvK3ZDZC8zdUZvc2N2VjFxYW9QYXdSUkE5NFF4cHk4S1l5NWVrc3N4bTJ0MkMwZTE0bkZHbjFIR09QNnJsaTh6NGZDdU4rUEJKRWpId3Rpemo4UlB5RWgrMVFRei91WklON2pjN0dva1YrSVJaMWNMOWJMNHdaaDdPMWZpZDNtOFd0aHJQZU5Zckh1dnhORWJmaGVMUGFIZjRwRnptd1N4bHI0UVJqMythTXc5bzZmQkRGK1B3dGl6REt4eUs4a0Z2VTFGNHRhV0FoaURFdEJ6TmV2d3NpWjN5UitQNWo5TG94OCtVTVkrL3lmZ3FpamZ3bWo5bThXUDBQQ1A3NktueWFSS0g2dTlFT1MrQWtUcVVMOHJJbFVLWDdxUktvbWZ2NUVxaTUrRWtXcUlYNG1SZHBLOEMrUFd3dDk3MDQxeGJ3V3AxcEN6K20wcmREdkw5VVcvdTJ4anZqSkZtbDdnZWQ5cWlmbXRTN3RLdlQ2bHVvTEgvZTRtOUQzMU5SQTZMVXNOUlQ2ZnA4YWlaK1VrUm9MM3ZQWVJDenVxNm40T1JwcEwvRVROZExlZ3JjOTdpUG1OU2p0Sy9RNVNQc0p2YzZtWmtMdkM5UCtZcU04SGlEbU5TYzFGOFlZdHhENjNLZVdRcS8vNlNEaDB4NWJpY1ZudGhaNDNVNXRoRjZUMHhZV2M5ZGUvTVNQMUVIODdJL1VVUkRqMWtuZ3RTa2RLdEZacDg1aTN0T21MZ0xmaDFKWFFjeFhOMkhrVkhleHlKTWVRbDlqcWFkWWpFa3Y0UXNlK3doOS8waDloYjZ2cE1NRk1iWkhDTDB1cEg3Q3lMMytZdDYvcGdHQytKbUJBdDl2MGlDQjE2SjBsTUJyV2hvc2NZSktRNFMrSnROUWdhL0pORXhzRjQ5SGkvbTZUc1BGZkk5THg0aDVEVTBqaFRGWHh3cjM4RGhLN0RDUG84VmlMTWVJeFZnZUx4WmplWUpZak4rSllqRitZOFY4WDAvanhIeS9UeE9GTVVlVGhIZDZuQ3owZlRHZEwvUjlNVTBWeHZxWUp2UTlMMDBYaTN1ZklmUjlKYzBVeFBOZUtZalBtU1B3YzBUYUFsNm4wbHd4MzhQU1BHSDg3TTFpTWVlM0NLUGVMQkR6ZlQxdHdaamJoNFJ4THc4TFkzMC9Jb2puV3lLSXoxb3E5SDBsTFJONFRVK1BDN3ltcDJmRVlxMDlLL0RlSXowbjVyMWRlbDdNOTZDMFF1QzFQcTBVeGpwZUpZdzErckl3NnNRcndsalRyd3FqVHJ3bWpOcXpXaGkxNTNXaG4zblNHbUhrODFxaDc1VnBuU0ErLzJOaDFLdFBoVkZYUHhkRzdud2g5UE5qV2k4V2EzMkRXTlM1TDhYaUhyNFNlRStjdmhiR090NG9GblA0alNCeThGdGhqT2NtWWR6N0QySXhOajhLSWo5L0VVU08veW9Xei9XYklPN2xkMEhVaGorRXNlNytGRWE5L1VzUXViOVo0RG5reTdZS1BJZHlDbnpmenl2RlBIZnphbUtldTNsMWdhK3J2SWJBZStpOHBzRG5JNjhsNW5PYTF4VjQ3dWIxQkw0djVMdEtiS3A1ZlRHdisvbHVZdDQ3NWcyRW5nZjU3bUplUi9LR1FuK1d2TEdZNTJqZVJPaTFPdDlUK0lUSHBtTFhldHhMek90a3ZyZFkvUHcrUWw4YitiNWl2Z2J5L1lTK052Sm13a2M5N2kvMDlaTWZJSXhuYnk3MFhpdHZMZVoxTEc4ajVyVWlieXZtUFhIZVRuQ2N4dzVpVjN2c0tPWm52N3lMSVA2OXE4RHJZTjVONEhVejd5N3crcFAzRUhodHpYc0tmZjNrdllSK3ZzcDdDNzFQemZzSXZUN25mY1c4cHVmOUJiN2U4Z0VDMzB2eVFVTHZBZktqaEdkNUhDejBPcEFQRWZxNUxoOHFqSHNiSm96dkh5MzArcDRQRjhaN0hDT01aeHdoakRoU0dPOTNySmpYbjN5VW1QZFArZWxpa1c4VEJGNnY4M01FZnRiT3p4VjQ3YzdQRS9qNUs1OG85RDBpbnlUMHMwbytXZWoxTkw5QTZQVTBueUx3dmp5L1J1ajlkajVMTE81enRsamt5Qnl4eUpFYmhMNkg1Zk9FLy9CNHExaXN4NFVDUDVQbml3UXhiNHVGWG5meU93VHhmSGNLWXY3dkVzUmF2RnZnZld4K24xams1djNDK05rbmhaR0hUd205cjgyZmxmaDc5dng1UVh6OVJURS9zK1FyaFRHdXE0UXhscXZGWXZ4ZUY0c3hXeVBtZTJyK2hsaU02NXRpTWZadmlYbHR6OWNLSWwvV0NiMVB6dDhSaS9yd3JsamsrWHRpOGZudmkzbVBsMzhtakdmOVhNejdzL3hMc2VVZXZ4S0w1LzVhTE9aNm8xalVoMi9FWXUxL0t4WTE0VHV4cUJYZmk4V2MvRk1zeG5tVFdNenpEMktSQ3orS1JZNzhKQlo1OUxOWTVIQW1Gbm1ieEdLTjVHS3h0Z3F4V0srbFdLenBmNHRGSGZwRnpIdXQvRDlpVWY5K0ZZc2EvSnRZMVB2ZnhXTGUveER6M2lQL1V5ejJpcitFOGYzTndxeXFGYXhDZjg2Q1FuL093b1NlRzBXRjBPZWpxQlQ2UEJYVmhINitMYW9MUFErS0drTHZPWXF0aEo2WHhkWkMzNytLbWtKZlIwVXRvYStsWWh1aHI2VmlXNkhYaXFLMjBNZTIyRTU0cWNjNlFzL1ZZbnVoNTJxeGc5RFhackdqOEVpUE93bTloeTUyRm5xdExIWVIrdjVVMUJYNldhV29KL1I5cGRoVjZMV2lxQy8wL2Fsb0lQUTlyTmhkR1BmWVVCajMza2dZOTl0WUdHUFFST0Q3WUxHbndQTy9hQ3J3ZFY3c0pmRHpVYkczSU9aaUg0R3Z0MkpmZ2ErMVlqOUJqSGt6Z1o5SGl2MEZYaGVLQXdTK3Bvcm1BdC9YaWhZQ3I1VkZTNEh2eThWQkFzLzVvcFhBKyttaXRTRG1vbzNBejBGRlc0R2ZjNHAyQXMvem9yM0ExM1hSUWVCbmg2S2pJRjdYU1JDdk8xZ1FyenRFRUs4N1ZCQ3Y2eXlJMTNVUnhPdTZDdUoxM1FSZXI0cnVnbmkrSG9KNHZwNkNlTDVlQWw5clJXOUJ6SE1mUWN4elgwSE04K0dDbUtzakJERlgvUVF4Vi8wRk1WY0RKUDUvcVdLZ0lQSmlrQ0R5NGloQjVNVmdRZVRGRUVIazRGQ0I5ekRGTUVIazJ0R0N5SVhoZ3NqeFl3U1I0eU1Fa2VNakJaSGpvNFN4aHNZSVl3MGRMeGE1ZllJdzF2cUpZckYyeDRyRm1oNG5Gbmwra2xqVWdQRmljWitUQkhHUGt3WHgrWmNJZko4cUxoZjRubFJNRmZnK1ZNd1ErQjVUekJUNEhsTmNKZkI5b3JoYTRQdEVNVnZnOWJxNFRlQjFzRmdnMFZvWGk0V1JBL2NJSXhjZUYzclBYeXdYeG51L0pJdzFzbExvZlh1eFNqamY0NnRDMzh1TE5jSlkxMnVGOFg3cmhDczh2aTJNOTM1WEdPLzNoZERQT2NWNm9lOXp4UWFoN3pmRk4ySlJjMzRTaXp6TXhHTHRKTEZZSTdsWXJKMVNMSEw1ZDdHWTJ6L0VZajcvRkl0NS9rdk16MWJGMzJKZUIrTFhmTUd1OTBneFAxT1UxY1c4MXlscmkzblBVVzRuNXVmTXNvNlluelBMSmdMZmE4cW1RdDhQeWxZQ1h3TmxhNEd2amJLTndOZEQyVmJnNjZGc0ovQytzMnd2T01OakI0SDNvR1ZIZ2ZjSlpTZUI5MjNsd1FMUGlmSVFnZmNNNWFHQ2VKYk9BdThmeXNNRTkzcnNJdkFjS3JzS1BBZktiZ0x2ODhydUF1OWp5eDRDUDNlVVBRWGUyNVM5Qk43ZmxyMEYzdHVVZlFUZTg1UjlCVDczNWVFQzcyUEtJd1ErZjJVL29kZXVjb0F3N3YxSVlkejdRR0c4YnBBd1hqZFllTExISVVLZjkzS29NTVpobU5EenNod3U5UHdvUjBqOEdyWWNLZWExdHp4V0xONS9sSmpYbDNLMG1KOVp5dVBFZk84cng0ajVHaXVQRjNnOUtVOFFlRzB0VHhURTg0MFZ4UE9ORThUem5TU0k5eDh2OEROUmViTEF6MDNsS1FMdm1jdFRCZDRibDZjSi9LeGRuaTZJdkQxREVIbDdwc0RQQytWWmdoaVRzeVgrQXIrY0lIRzRMODhSZUc5WG5pdXhnTXJ6Qk43L2xSTUYzaU9Xa3dUZUk1YVRoVjdueS9PRnZyK1VGd2dqMzZjSUl4OHZGUHErVWw0a2pEbTVXQmpQZDRrd251OVNZZHpMWlVLdnhlVVc5TE5CT1ZYb2RhcWNKdlNhWEY0aDlMNjhuQzZNKzU4aGpHZWNLWXhudkZMTTk3WHlLakhmbThxcnhYeHZLcThSODU2bXZGYk1lNXB5bGxpc3krdkVJbCt1RjRzNW55MFc4enhITE1iakJqSHZ3Y3E1WXQ2RGxUZUtlYjlVemhQelBxcThTY3pyYzNtejJKdi9EWmJ5WUVBQWVKeTB2UW1VSkVkMUtKcVJlMlpWWlcxWmxiWHZWVm05VjNkdFBkT2pudExNU0pvWmJTMHhra1pvSkxXa0VRZ2tvQ1ZrQVpLQWxrQWdZOEFOQ05CaCs0MHhOamJ5Wng1R1dQQlpXdjRZWkI3ZmIyd3dsaGRNdy9PenhUUHYvMkg1eitJYjFieDdJN0xXcnBvZWdYOHZrWkdaa1JFM2JrVGN1UGZHalJ1Y3lIRm50OGpUWkl1YjRTN2dMdVp1NERpeTBMaUExRXBUcEY0cjViTTVPZVEzdzlVc1BxeDIzL1JpUWpaWHF2dHJEVWdSaHBTeVVHc3NoRTA1VjdKQ3BqeEZjaVZJMTloUHdsYTRhYVVJK1p5a0tKS1pNTnRiWmlKaGtoWkU2Uk1XTnRyZjRrV1JKelVJZnp4M1lBNytUaHY2YWQwd2ZRVXJsWWtYZkNiSktGSlpVaXI0ZVhzVnd3cDkwR0poK3pSOC9oaG0wcjZMRndtWHhUem1UZ1oxdzlDRHZwaW8rUWtKYW1LTWd4OFpBNTRqNjV5WFMzTnozSDd1TUhjajFMK3Z6bEN6MG5BTjdUeXIxQkpaQ0NlSktTdEQ5emFyZjYxaDJiSmRzaFdEd05Qd2tvTldjcHBCVFRZaGpDR1FEc0NMZHlBS0JvTWZSZlA1aFh6K3ByZ1pDUWZpYnE5TCtZamk4cEoxcVBvMnpTUmpKdHFuSUFPVDF2akh2SGhLa1h6NE5RU0hlOUZITVplRi9Cc1ZMeUVlUlREZGh1SnlLWWJiNUFSby8yK1FYNUNuT0RjWDViTFkraWxpR2lRM1MyckxwSmt6aUpraUM4dWtOa3NVZGxNbFhPTkVvM0hpTGd3YUIrODVlUENldDJGd2NPTGlDZmdqanpxdklLZzRyeUJZbmJqNDZvc25PRTZDOHI1SWZrS2U1dWE1SmU0aTdtcnVaUnhYWElhK05rdnlPVmtwS1hnMVNNZ01XeklHaW15R0YvYVRGR2swcmZCQ296WkhNREhnT0dRcUpYdVpTTkF3QzVCV0tRVVp6QXorT2RMWEp0RHh2TVFnNUZ2K1lLcVd5amFOV014b1ppRWE5SnN4YTFJeFRHVnk0dVRKOHBSaUdzcFVKTFlhS3hrVHkycXlmYm9VOHlYVjVRbGpxM0xWM054VnF4andGMG1LbEpHVUJaRVhBb0wrZ204cUFqa1Zrb0tRTEVBa011V2JucmNQSjFsZVdjdktUdEg4VTRmdCthK1dZdUZBUFd4NFc3R1Mxd2pYQSszUE81bENzRG9ueW0vQjlyb3JKK2hpVE9RNUhKdi9sV3lSajNUN0owZjZCaFhXVGNxeVhvWGpGSHRaY09pK21HZlhidTliVmFUbnNCQUkyaytRVDJHMGZSekR2amk1dkpORUlSc1pqR0x3bjlnRmc3TmNMLzVVTDRyRGFRVE0vam9iT3pnMkFLNlN0UXZNemFIN2Z0amNZMEFlQUgrdEMvUGJSOE84dml2TWlHZUVGZkdNc08rS1orZGFkWjRqbFdvL1R3RlRBZE0vSGdlcXA1Zm9Qd1RYd1NGY0t5OFMxNXNPTEJUNHg4WkEvY2xla2hlTmJPM3N2OE44c3czalgrWDhYSXc3eUQzTS9SYjNHUGRSN3ZlQUR1UndzRGRxSmJzVHNUcVJZQzZQMDFFT3lBTlNDZHF0UzNrWmlHc2FhQU4yNy8yRTFrUXhjYWpER0FFS3NBd3Z3L2kwRWU0YkJPZTZDU21kQXB1ZGlMSURLTUlwbW1abzJpWHNzb2RkM2lOSWt5bGQwN0tsckticHFVbVBKK3lQNnY1N1hIbnp5Y1NNRkZJbVpUbkVCMXhQK3ZWN1ZIZGNLNHF1U0VRU2ZJSTBmRG5ETXZ3Q3U5Z0RsdzBNRE0zSExtdnNRakpxYXBMM0JvTmVmakoxUWlSdS8xTGswLzVnSVhGSHZuZzhOYm1aU2IvY2JSaFB1Q09pdXltSjh0ZThicmQzUTVBazRSVEdUbUZzby91c2hiR25XTVlyQThXMDJJVlRrR2ZnSDRJMnpIT1hjc2U0bDNPdjR1N2ozZ1NqQnRzSVVBOXQwNlU3b1E1MkhaWkJnalRRTkFQY3hSSkJ4TmFyTEhUUzRReUtNMmt6VDVzODN6Y0pXOVdGTk1sYjNSUTRaU2oxS2lrdlNrSkZrQmF4R3Iwb3VjZ1hPaFpLRmJKVys3U1Z6VnJxNHNyaU92eFhBS1B0Q1poR3k0bkVsOTdvbWE1TmUwTDRKWUh2S2dWZE9mS21GbnU1enpNWkxTUTJTR1lvWXlkNit0NFU1Ri9HckxHQTh1SmlHZjgxeGFkb3EvaDlPYkVhanNYQ0xHZEpPSzRjT2NNZTMyNWEwU01jSjV6OTVkbXY4bThGZk5hNHQzSGZoWEZRc21kaHhySnpNTU0xb0hLQUFPam9YcDUxOXYzRVdtakNqQWRUTVV6TnpXV3luMThtUlppZjVURE9oR0U1WjgvVHlSVEkwVUtqT1E4NGdxL3pkczVMNUJLZ0hrY0svTlZoZW0ra2lLekFiN2paNkk5REpxWXNLVEo4RURJZzMxbUM3MHY0dHRSd29pVWJPWndVdklIQkNEZU5CV3MraFkyTW8xUlc1b0VEQXRDcUZzemRqVEFNUTVsL3dEUzFZcUIyZVRLaWVXVlhNaWlrSjcyNUtUazU0OWZWTXI2NU1vNXYzTWxBMzV2MjczbHpYa1dRb3dWTmRBVkVLZWoyVzFHdk95aUpBWmVvNVVQSEJINUpsRW1aNTRVYVQ0cEVMQ1FsajhaTEFiZW95Y21jN09KVnhjTEtCR3kvQm14Tko1SHFFMVVuamE3TGVpK0pkcTd5Q3FHWGRNdjdIK1VKdjBlTEtSNjM0cytGemFRbmNlbFVJNm9YL0ZkMUhnZHlvVkNpODloV2VabjNoRXdvd2VXMjhtRzNDMkxCc0VwU3ZNQ3ZDREtmSXZ4QndoY3ZqRWk4N2hGOUFVa1hUWkdvaGs0RXQrRGhSVWtERUdhN3FSVFZML3NDc29hSnZQNytOT0l1SlhIODJUYU0zd1BBOCtQbzVZcDJDYnNHakVKcy96N1dIaG10VW81eVlhSGVlSWEydGlFTmRDVG5xN0NGN1E2OUNaNlNEdS9MN3pzazZNSWhTVmFuamNwMGN4L09BUHVpYVdERzAxRjIwNXl1R05PcUxIWFNsZlZDN3ZiRzR1Mkg5TElxdDcvdkNRWmp3ZUM5aHdSNDZaMUxKYVYvVTZRSU1BREtaQng0K214OEVxTDQ0TitrWkdyT0s3RjBsVkxlbmpneTZ5VlovRGdXQlBiKzdGbWdTeGVTTlM3RVRYSmNFM290ZEVnZ0gwME13akJad0hDQkp6VldINFlLRTk0c1BQNllLSmlpTHJ6KzljQ09tWUx3bUtpTGdjZUUzck9nS0x4ZjBNMzNpUnErZnQzcjhKVW12azhRTm5jOFFqRURmc2dhdVlVekVRNEdBeFp2TVJpZytCcVd5a0JwZHVDUlRXdG5BWi9ZV2VTZjd3VE1Nd0wrZmpnb1Bvb0tLM28vNlNJbWJDcWRzdE13OXMwT1ZPU3U4Nm5wVStlSHRiNTJvZmdJZHRIUUJhaXgwR2tKSUhnZHhKUnl5aCtjWDFWSGdEc0NieHh4NE1nQVBzYjBqbEVkNGVTSXJEaUN1T1cyYUJ1UGJtRnh4MmNqR3E0dkg0UnBaQXQ5YVdmNW96RFA5ZFhQSElQbEVmZ2tpUkU5bVBHYjJ5QXZiM0lXWjNOTjdoSW1LeU5kQUdIZjRYMlhDWjI5QjluUU9obGtwMFBETWpPVGlnTUdpTFJ3TlFLSjltVURjdnc2WEorZ292SXhYbnl3S3grVHpZVFo4a2FsbjZFdy9ETXA2b1VadTRISmF2VExiUXovQ1lPckthMmdBVWRsM21mSTg0N01Pd2UxNkJkemhYNHhVa0RDNTR3QXhyTWdlME80UHJHM0p3eGZlMUNWNWRzQWk3Y0JPVHRJOVJIa3FaNEkzRzcxSkdPeTcxNnZkSnNJS2IzM0Fsd2pZR3AyQVFMZ3BLNUVEbUFwVkFhRXdHbEJRQ0RNKzJxdklMTFZLK2l3SXZXWHREVVM4QnhBT2dqN1RuaUtEQklHVmJHTElJQ3FXY2QyaE1BWk1kQ3cwTHJrK2RFMVp3Q2RGSVRiNUYwQkFyaDE4VmFaQXNTTndKSFVSUkNBRmV4WFhBUnAvNExBR1RFTVlXUGE3ZWlPNmkrT1JtYjdxVUhnT1RxL25BVnBobzZKRkdDcG53TkdkbzBScnBKaVYrdlZVSlZzSEUyWWQ1bUpvMmFjR0tlTU12ekgvK3pVL1hmZGYyWWRlL0I2d3ZhZU1veFRYanV4ZmVyVUtWcG5tdjlEa0w4WHh0d3NsREFrbVJZZFVzVnF5SFFEVU8rYUJjWFZxellCOGF2OU9CWGdZTUMwMzcwQmhXNFk4VkF0WVI0M0U3VlF2SEx5K01rTnNUTTRsRjlzR01ZR2xMK0M4S3drN09ENitrWUg5MmRCMW55b0EwZlZZY2h4QktOV3JFTmJXUEZzYkVPZldGQkMrVkExMUN5Y3N3UUdIWU9VM0RNYXhoRXdZTC9Ic3JIV0NJdmdrRWcySXBDdVVLVGttdlZxUFY5WHlFZk9DY1Q1b1dwVW13eHJPQ1NIdkRJVU1Cb0hBSmwydnA0UDVhM3pxUzE1OE54Tmd2M3UrOUR2UHU3MHV6NjJyZGJqWVJwMkU1Q2ZEeEhmcVA3bGN6cGpLRDdRRjVGSDZNODdHT29YNXJvVHNXd3BnTlJxL2RTb3JNbmFtTHl4RGJlaERUZGhiaXR5ZGNpOTZtREhtU01aenBwK1orSndSRDdCUDZpTC90WU9BdkdMaE5uZXBEcFJtRUFxL2RNRmFRM1N3RW92WGFMOVhremhwTzcwOHdINGlpT3A3Vzd3b1o2dHY4elZzZEI5WndmeCtlQ0xnbTgwOVMzdUF0L3FJQ0VqNCtGN1lnZW0vL3pGd1RlU0VnZDNnZS9uTzdEeWpiRVF0b2JxY3U3MjdZNWQ3TnV6UXpxTG5SVGJHaUszWk1VWnAwakJuYUg3eVEwWXNaVis0a0Y4Vk1lL0NvUENHYnhiR3hzYi85QWQwdjIweklGallBU2o5RTlIOERKeFJyQXlSRzVKNWR3bFZJYkI5Skl1bkQzcU13S09nZEdPeWdZNjJnM2lqUGJtRU1uZE9EY1lPOUhWQjBjUFh5UGFwVm50MHh3dEUwY2tTWkdtQlNTMG5yZUhTTzc1MVhkdHQyYnB6dWNPN1J1QW9pZVVoUjBvS3FPcDNNYm8yWHlRZjJtZWkrOXNVa0cwMnpQN3hGSXFpbzNtWXk0elliUUEzNW1Bc1FNTVBmRHY5OE9ETndqam1OQy9nQlNYZkJ3ci8vRkxnTS9IdENMODZUdDVyZWE1K0QrclR6RHg5aVplaHg4WXh3ZCttWlVGeFlvWDk4TXdtaUc4ak5WRUdLN2hUampIODgxMm55QzJ2OGVrT05DUDRaOTdZSFpRZGJGNERqQWg2VWd3ZDhJNW5uZFYrb1RQdVI1VDUvQVU0OXArRElMR2NMTGpxb1d5Sjh6OVg0RnhtT3hvaHZ5c0Y0Yjh3NzN3aTFqWWgybGhIMlo1L1JVOCtFdmg2eEQ3TUxtR0RycFBmNWhKbDM4cDRrdXFmNER4dFE3aks4bk5BTFU1WjEybG9WV1Z3bU9RdnlPdTNrVEx2WW5Lck9SWWo1UW9SSDIvZ0VJc1BCZHYrUVUrL3NVdFZETCtDZjJDQmgwOXlOTmtuY0ZCenRrM2hDNEtHREVnNVJGRndFMS9FZVJHRk1EZkorNEF0djFFang0cGpoN2thYUMvak9xZGN5elpRUWVBdWdNUXFpYmVUOFg5d2FvS1ArOEJNZzVwQXJtcUQydHNLUnpiL2lIYTlqUDl1aUdFcDh2SU9pMVdIRm81T3IvNnZuNEV3RU9JbzNxVXN6K0VPZWxqMkFjdHFndnJGdGFuR2NOKytNOGp1eHIwUVQwMnFuUENQOWZKLzJtV2Y1Q3F1TG9kclUvaGhlWDhIZWJmL2pSRjB6VUQrWk1QalMyZ3h3TWxxVlhGTHBqY2xaZThkUXhWdVdFc1MvVGtqdUhOaU91ZmpHV05kc0I4N3A2NEcvLzIxMk1BK0pleElDK1BJV0NrZnY0d0I4ODVpbmZEODcrT29ZbC9PMTZ5T0RDbVphYk9IK1llamtkUndOMzQrSnZHWWUzMnNVRC81ekhWL0lPeE1IZG85bm5SQld0NEpYd2NYVEQ3cU0remo0bmlZeVBvMkRmNnlZSkRzN2VBWnA4UHJWU0dpUGJ6WThvUXZuWWV0Tklhb05uTzNQR1FNNGZ0MXVzR1NQWXpZMmFuYjV6SDFHRU9FbXpXTGwxNmZlNmVaQS9SNjNGVk5mdHErcW4zQ3hSbHc5UGNZTE5RZXJyZDRSbWFWRmZmclhTZjVoNXB0anlHYUg1eExKM2xITDA2VDhnQ0Y2YzhDY0NmQmRiWW1RT2dWbGxnMGlsSDhrdVF0dHYvc3lOM0V4MWp6NXdFK2ZHU1MwQ0VQUWxGOWQ5MFlOL2lma3EyTU85bTNqK3dzdVh2VS83KzE1Rlo0TTBTSzBjY0tMdVQ5MWQ1NkxIY0VzQmRIWlRSUTRNcWoveWdocUUrSURBVEV3VGNWVkZjbGJ6M1hnWUYzd0lGM3dKUVhEYm04WGVjTzNpekk5R3FPUHh0Rjc5SHVDa0FtazZIUTlNc2E4TGh5VkVoTndqaWtmYm5qNGgwa2VCQkVmNXcyVUE4UW80T1BpUHpna3U0K0dJSW9KM2ZDR0MrRVVuV2prY2RuSkVKOGpUQ1VxVHM1MUFYWWhBTU02TTI4ZFA4V0tkNkVNYlBnNHdxZGg1QkVmam85bjdvb01nM09oQVAxNkxiTndBdlQzTzNEVk05YUtEUXdMRHZETDBRdkZHR0grSTlOSGpkSG42STk1QlQxYUdkNUJXMENWbjNuK1RmTlVOSG00RE54RWJoekx2NFNiYTZjNzRKQzcvT3h5TVRjcHhLK3pWUC9wU2I0dzV5VjNPM2NLL2tYc3M5eUswRHQ0WnJ2ekNHNnZQVVRxRFpxRE1aQjdXd3BUcVR3MEttUWcwTlFpam5PZ3ZNOEFYYWN0QlljeGxvcDEweTBHWVVEUXdHYjZVZGRqazlreDFic2I2TWhwNXhtM2hVMHlkcm1lYUJac1l3alpuTFQxdytZNmdocjZ5bGE1ZlZEdGZnbVpXeklIeUxwa2l4aW1xNkJhVWNFb01ybWlJV2x1Q1dWeGZTVXFEOUw1Q2RhUmhIMmVWaGRybTVsV3UxSUdJblltRlAwS2NhM213emsybG1zZWpaeTJkbUxwOU5XQjdUcTNvODZYcjYrVUt0VnNBM2Zzdnl3L1VxTWFnMWk3TGdOZVhVakNiYlVrQzdkRmJtZmFac3R6VGxQc3pmTkZyczhucDI4VU41WFhwQy9nWG9DZW9sN1NacVJWQlQxS2NtUUpPTmNKb29IVXVScnZiQ0NxUE5SNGw4L3pPZmtYamVMV2pTWjZqTzR6T1NKcmg1WGhyOStJYmJiNGRISnJ5Ni9adEltNzk1T3lRMTRkMlk1MnhPUW52U0wzQVhVOXVDbXQyUmNhdTBaUkZpUmM0N1FqazBLZllHUnV4b0pieWthLytKSDBDQzZrS3pJV0huUVhNUzdDSXllVDZYdWZ0UktnQ1hMODJJUlBCQ042MWZTSVhoVjUySUptS1JyQ0dMQ1NqSEZoWENhN2x3WWJrNFB4MmVOZ1MvSjNaNHdtNy8zNkdJeTVVTGhDTXp6eDZzelRNWk9Xb0pMakVBdVpXb2hEeHBUelJtRWxHdjcvMlNKa21HMTJkZlBEMjdHQW1HTldXeW5JbEg0K0dRbGJDS2UzYllFVGVBMmgvaHJ0cmRqcGhhUVRrekRacXZWUzBhc2EzOGZyN1BiQk02ZUw2T3F3ZnlXTlBodjluRGF3VlYyTU1yY2hKcXJOWlVRVXZLeWpFdHBvbFA3TUVHMmpOYnIxY01JeHlObk10NHVQVXBWZjJVckV0aUtxWHBMMCtsZlBzVjZWT1NVcnUrK3A1Ym81Vm9adzM0TE5UMUljN0QrYUMyT1doaks3eE1vR0pNYWRrTTJkTEFBd3VlRVBlV0ZnMEVvdHFXKy9RSDI5L3UzcmorN0lPL3Y2bnlBUTlwZVFLOCtuRTk5ZTVmdmpFeStFVDc0Qy9meUdRcU5wZVd1YnU1dDJIUFF0c28zckVITkhqTHdHVm9PY1UzVXdRN3pqSnZMeE1GYVVaWXRrdTQ0ZzFrdVJNcE5SdjdLVldwZFNJTks1eW1WazRMblVnWTdaL3djeVJYOWdCTmQ4ZzF6MFhEa2xGYWlCcXpqVmtqdWxBeXBIQjB4S083Q084aVF0RXlFZ0t2cWI2NlYxTjVPV0pFaWdLdkMzTEVGVFJkbGl4QWtsTFVDTXU5SkpZUjdVOFMvaU1neWpEamhvRWE3M3NYQkphd0ZUOVh1ZDFIT1Y2RXZBbzg4WkR6TDI1bmtudWVFTVFiYUxuQ0JlOFVFUTQyM3JlNjdjTEJRTFhsV2I0Snc3dlJMQzN6Rmgza2pSU3ZwTkJTUG16d3RrRnNFOUc2Z0tqSFNBTmJCVEZlNjBSS2lIcHNsVnduSW1PcllNdVpuUWlhckJHdXYvNnlkMGY5blVmSGVWWHoxbjJxeGdzSnc0Skt1cUMyTGpQb2lzZ1FGVW9SdzVLN1NlU3dFUzMxSnhGMFhpaEdQWkhXU0JUdktCV0dwZk1ob0pzdlJJZnpMdkk3OHQ1WlBIRXh1bkoybTIrUmp3TjMzK0F1NDY3a1hzYTlBdWpLY3QvK0MwQlJsMVpBLy9mbkI2V3ZLU0owTExLVVBYQ1A1RmRHQTluUVBOT1RBclhKVnVaSHZLakRHN0lZQ0tONWd2U09RQ1h3RG96Y0d3NThwQ3VDU0IrSk9CYXdhclNnNVhKYUlhcW1hdnRxcWJYV091L2IrWXdVbFl4SnB4ZWZqMTdNak5MKzE1NWxCbGxsQnFiYm1qbC9TY0R0RGx3eWIycmhRamhjK01ENmprZmg5ZldPbnJxemZ5R0VHdnNCbmJxRk5vMkFyN0F3UzZDN0dLVFVyejQ5V2tnRzB1M25TcXMzL3h2R1NBUmkvYnJ5Ty9NM3I1WklKQjFJdHY4VW8rM25JQXBsTW1YWk9sa0ZlaDhGQ2pqRjFVQ1M3N09HNmNxK0hWa3cxT3kwZ3QzZEh0T0pORHRtckJaS2JFanBRM3k1WFVHMmdaeUdzTzFHenVHT0ZjWjdHSXdsV0dXWENIdjRYWGgvaDk4aXE3WENCbjRIUWZ1TTVkL3dXOXZIV2NMRExPRzE3SEsxa3dtOHQveWNZOCs3RG1PNFkwZCtrSHNKNVhtNzNXeHdGMEhuUGovMGZ1ZU01OCtTWGZJZ2QxQ2pXQXh1NjhZKzZzTVlCbVRxQlRwWjhSa01YOWptTSszRjNnZmRaQzFKT0lQeE1RR2Q5THB6Wjd0Q050dW5ScVZEKy9Tek1NODg1T0NpQmpQNTlURG0zc1M5ai9zRVNQcjUwWFhvM0F1OXRjUytoOVdCclZQc3BUU1UwQjdLV2NvUEdGRjNzdDloVkkzTXdXQ2k1N3M0T2RqRjA5UXFOVWJXbEhVSTNvNW15WjBiOG04c0JRYlA5SkJlNzAvREFpZUw3M2N6SlNOeDNqN1YrdzdTazByM1MzejJiRGZ0di9jKzJSNUlRbGk4azh0NlgrTzRuTFo1bW82N1BGREZKbmNoZHlsM0RYY3p0TkZyb2I4T2piOWlCOG5WNW9oWWNVUk02Q0F5cjNSajFvaG52UmovK2hlbzJUeS9CbUg3a3hRM3JWV0t4OHdxdTJ0dlNjS0tJSzJTVFhiZllwZE5sc2k1MitvK3hLVFBpbndCdVRJSXRqSDN4eDhmRTdZL2RjN1h3S04xZUZNQnhya0xNQmZrTEM0T2ZUdlAyVUM1NXJncVlIRUo5NDdNKzZ1LzFtOUEwd0phUVlzSDRocit4QUx4QVA1b2dUZytDSkQxOXZxdjgwOXBQZFgvUGVqUUthUzMzWVY1dWhOdmwzdnl1WE51SEdKeGNxaTNZV1Z6WkxUREJ6OUR6dEI1cDhidDR3NEJkUmhZelcwMGJWbWhodk5ocTRrYjFTemNwR1kxZ0QwRjlxVmtBMnNLbkJESXJBMjdDVUtOcGFDRVk4blA5NmFuUHcrNjQ1b3ZFZGIwdEUrTHU0UEZtK2NXN040enIwNmZWZWJGWkNpVWREMlRkTG1Tb1lHbDNudXRpQ2NZekIyZm1Tc0ZnNTVvT0J0MXVmUGhLRDY3ZnJydjJacTJ2S3dYUy9tSVZpamxjL295MWsraVkrMFI4alhvSzFtUU41ZnAvRWEzSmFEd1BrdVloQWtNeERLSW1YQWhkZ1BBcDZ3WnNHekl4WFVNLy9zRWRXZW00Ky94bXdkaVg3cXN1WFM1SFBUeGNrczJ2WUowOUpPSHZ4ajNCRi80bnJJOEh6NUFudnpDNUV5MFlNVFZXS2c0OVNVOXJucFU4ZEx5NHVMSzRtS1o3Y3NnN3dqSE5mUFI1djZEVFlWM20rcUtJcmo5YXYyaSt0dk5DMlB0aDdTNVNqSkwzSThtSXg2ZlhGS1Raajc5cUNxNHducjhHY3hrWlhHRDdjTGdOTXBEL0lTMlpRQkdSd0xtZEp1YjVoYTR4ZUZXTGRsUVNmaFRVTGtoSy9BSHJaZUZXNmdzM29jdHhXN0FTMmpPdnBhODZvTEtBMU16S3pPbGVkZUZwVGt0UFhtb01mVkFxWDNhbmxjenVmS0NLMzFpYWU2QjhzeTNMbTZXSHloaUU3NzluZ01ISURqWXZsQXNQVERWQ002a3RibkRhZGU4L1E3M3pOUURsYlJyb1p6THFQUDJTNlhpQStYbWU5MHo1UWRnT0xpY2ZUbFB3YmcrQVBMM0VlNXliZ1ZtOG11NWwzSTNjcmNEZlRTaGJlZytLZHhnQWswVk10TTh4T3BOUjF0VFhVQ0czQXFGUXlEeHdHOStjUHhNRWNscTJsWXpEeUtRM2N4YkVGWGczMWFzL1VScDFyTm9jUmppMTRPK2x3dFhTNmtyRG4vK3lCVnA2U3J4NWI0Z0VWMW1lcko1OGJXdnVYckpEbXJrank4OWNPRFNRSlJ1dDBIQ0tVVGJaMmFuSnkrY3VMbzFQVnRadG91LzVJc2tKWDVzYW1ycXRXS3EyZDdPYkwvR24xQW02emxldXUvSzZUS1ptTDd5UG9uUDFTZVZoUDloVjZpWW5vcW1xNFdsWklRWEsvOStHSDYySlNHREdVUFFtcDZlREU1Z0dNN0F6MXNTOWRqVVZObW9KNzY5c2xLcE1CN3krMEFqUHc3WXVvNjdCZWNSdEM1WnNHUVlzb01hVDhEYUxCbWNtMFBNK3RreEVzbjJERWJRRXRxWjlvc3cvSlZTUStyWUVtWEp6OXNuZ3A2QTVoRjlndUFHdWU1bWVoRThlWjhyYjJibjJIYm9VSkR5eFNyaFZCb0podkI1KzAvVWtGYVdDVkVTNWxuT1RKRFZyUTFQMEJ1YzgwTUdia0c0V2FRWHR5ckNzK3dHL2JJU21mQ1VwTzVHNjVKbklsS2hMellVSXBlMTBITjBJM1hIZm92SE5ZVXdWK0JhVE85WjJzOE11Slp4bzEyWXJyVVVxODB1QnBwNXgreFZxVkpicGJ6U3ovS1FMNzlUTnQxODhXYk5SV0xFcGJ4S2N3dUpHMTJ1OXF0ZUxkK0x4VDZwZjVWZlZCUG1oL1ZQWmpMdmp2K0JtVkNCVGQzK243cFAvejJ2OWwwVnJtOExYVlJKbU1BSVZrNzdJR2l0dHVEV1orZ2J1dEZaRndLWVYyR0d3eDNNRkloc2ZaQWI2TGVQNUN1WlRCcythM09VdGVSWWlicWFJSmoxTml1cVV3QVV5RGx6VDdlTTR2bVVvbVJEMmJFbEhXb0RPekNtdU5YMS92SUVHTmRGYWxsY2JVS08xSlIxMk1LMWE2RkdXdHZiWjdEQVRLWmJsTWtLWDErdmJMZFcxL3JLb2VWeUk4cHFRbG5GWGN2YVhsOG5LNzlDV1E0UDUrSG11VDJvUGNwMnBDUXJIK3BhVytJNm5relg4ZGlHdFlVMHlUcVFLUGw2MWdKS1EvYm0yOS9HbkZ2NTIvZ1ZXdnFKT1lFWGd6QU0ycHRPNUJBNVFvR3JaTnAvLzN0dnpxdzQzV2o3S1FiV2ZoZ3JCaStSdjJQWEd4RGlYR3U3TlFMLzJYcjJQUEMvMmQ0aXJZMFhoeFdKbHRVQ0hpMEFzMjJCbTZWMnNTRmFYNmhyS08vWS9mVkVSamFmNW1RcGxIWFdYeFhzZEtGcWhSZlJ3RFhEQm5lR3pYTVZOcytScmZhMm9YK3FEUGZteGhhNTkrY2d6cStzRUJUdzN6QXdyOVphaitvRzNyVFlmbjFtMys3aUlqQWpIdUF1UTloTW1WVjRJZHhrM1ovMWU3U1c5SFlRMHRGMVVsU2hnQlBxV3dxMUtMek5aVkovZkVCQy9hNFZiREN5QnJJYWhKSFU1QWQranB3d0JpY05QWktUVlZJK2pYakZ3TGxnVUg1UHFLQkZFOTAxYk5NM3ViZC8zZnU0YnZ3WG4rQUc3azJrdk0yRjBBY1R3QVZmamo0ZlFBaW5NNkRkVzV6bzdrcTFnVytwVjAxWnNodTQ5dzErY1ZIRGJqaWI0NENOVTV6RktLdGpHVVZYT2VoVUdyYUE5ci9GbzJtV2JnaHprcWhKTHN0TzNGaHNGR2VhRGVpV0Jna2MwdVdnUzlKRXFkZ3F5OEZZVUU3WFRWelc5d2tpSDZGWG1QNmFHVVYyYTM2SnRIL3FuNjlZV2lTWW1wL1FTMUhUVUYxV0ltN0hpOFY0NWJDaDZ3YlpGNXdKdUZURGpKWW1McG1UVlIzNFBZK3VTdW5JbllJWWdIN2VucVJYOGlCa09wdU93VFFreWo4T1I1Z05ac2NYU0kyN2d1NUQzVmxiZmdTS2NQbkd3Vkl6NjZDeTBWM3VZWWlReVI4TTFMTGNLdmFqNDhhRXZZMzRlRi83NjRBdHYrYVdsVXl6NVZSYjAzNWpaNDNrdVVzbUJoRmd4eFAzSVFvT1cxckFFNHluWmpPNEx1TlVVck02Zk8xWkdOY1BBZTA1REgzNUpkeWRxRE9DRnV5SjQxWkhqTWNiM0d2ZVhiK280bDQwZ3hyR01vWlFZdXRkbG9KS2ZBTVlxYkJWelFPNm1sVUx3bElEZlo3Z3ZEbEhHdFVVa0RTRDhId3NjcVhzT2tTMThwbEhGR2xWZGJ2VkM2THhaSDRwbDkrYm56cmt6dXJ5cTgxd0pMLzNvbjI1M043MkNWVHArTDM3RkpmN2hENXRoL2k5QVJJS2hGLy9nZHc4SVY1UEJicUlSK0tGT2NQSXovTWtNazA0YlYyamJqOXE4Ty8ydVl1ZS9OSkZTN2xhV2Z0b0psQk41cGJ5dVgwWDdjMzlUZTF3VGI1T0MxdkpFMDByRTVzSnBML0R6K2VDZWMvbGtKc0t1VjRta3ZsY2REcUNlRk9kdlY4ZjV3NkNKSEFwY0pRM2NiZHlkM08vQWRpcjlYWkdKUWUzZ0hlNlN2OGVlMmZMVitlZWphZ2lUS1orbk9IUVdVcmU0VVlCaWZnSVhsbjFhdGdaVHBnL1BpWmJRRmtOZlZVM01qUUVVcXRKUmtCeEpVd1kvWFI3R0kyNWxJQWhhZTNUbGNycWFqa1FYdVYxMmV1Uk5PSElhcVZTcmxUVUk0SW1lYnl5enErRzcxdGRKVUNHeWtoUXlpdzA5RXdpa0M1RkptclU0Y3hic2RYZVNubWwya1NrbEE0a0R2dmFwM3gvcEtTRGgwb1pNNVB3eDFPcnF5M2YrMjVMeGYwSmVGQTZGRXgvM3Vmb2NyZEFkdDJDZVM4QmRIU1ZlNWg3RDFCU1hOV0NvZUxvQk9udWFWUEJQZGVVcldUVXZVNjM4ckQvaGJBVWNyVG56bXJGeUx2OW5lMzFVaDFYUFJ4ZHVyTUdNbkFYQ2c0V3VpVUtQa0hXdzRGNGNOTUloSFVaYnNYZ3E5cXRoQm1wck1CdnhFeTAxNGdxeWw1RlZGMnFKK3VCVUZRTWRwZHowenV2TEtxRVVWK3k2azcza3JnVlQ4Nmp1RHVmSzU2TXU5SXJocXpyc3VTUk5XK3hGQW9HUTZXaVY1TTlrZ3dEL3RTWk0yWmlqZjRrWW51SWpGUmQwVVJaRmpWbE9DNlRQWEQ1MGxYU3FKY1lsNjRpYS8yWk8vTDhWd2pxL2RBdlJRUDFJUmJ1bG04QzRSSzZBaXl5SVNrNm5LR1B6K2U4ZEVNTTlPSm1TSkZUdUt1K2JwY0l5UDBXSm5wYUN3cFY2N0NvdmpJUWl4VmlNWWtJNUJXaXg4V0xyNWZVakNvZTBqeDZaazdRZ2dIaFFsTWc0YmVJNmtPOExQUExvcXE5NmZEbnRDRDVkL3lzRUhzWEllK1NlTlVqYjhyeXNXdGxYVk9PbGsrOVR3dkltdjZmWHhjWDJoLytHMFg0YStCMzVPNytpN3RodnM2Q0JOdnMrdGJwVVRkL1QyRklGMTF3TnpmQXExQ2VxNk9CTm1WU1NLUnlpd3VmeHg2ZnkySDRsY2xZSVJ5WitzYXhwTi9ySmVYa1M5L3VqZDU4TWo5cGZjdW9aZkwxR0dVNTJwdE1aUEdrczljcy9iNm1BaE5rZjFQK3lHUStXbWI3enNsQndMSE1aZER5c2lvMDh5aGF5R3dSbERvd2FEU0REUVMzMlNoOTBYN2o0ODAzbS9mZEY0enpKcDhNdFVweTB2S0VsY2MxSlJaWURpdEpzckhSUG5QNmRDVWFPQjFPUDJZVlBXN2k4K2JDeDhJbFNxOXdYZXBwTGdhamJUOVFyT1BjU1c0TlJoMEhzaXVic0R1VWZZRjZGTUwxSjdaZUdPcWFZbGZaYXFEVlpNWlVqSGpaZmR5UDVXdzRZeVpucU42Z2UvRnlhR3Z1N0FGYnNGRHNRMXJvbUVBQWZzbERpLzdGdW1pSXlYaHl6ODJMaXpmZmMvT2ltaFRGcXduMGJHSHE2TFZIcDZhT1R2a01MYVRITG50cmI0VmtuNklyOENlSm9sL1VWQXdPQzRvdStFVkZGNi9weHRwdFE3ZXl3RTBsS2duZ0J5cFFWazBVa3lvdFp2SG1QVkFvRkYwVUZCT1kwQ2tzQ3NvVGVKbVBYdmFvaFBrcnpkNCtFbEdEWWxRTVFvS3VRQUc2SWxhN3NkZnBSdFpDU2dsRkdaMzVGWG1JcDZtT2JnL01GcGN4cnpTZG5iNklSMnRZR3c2c1U0cDBOd3YzclpFcldlckdJbHVxQmVuYUFyeFlsNFRUS05oRG9IWWlFcGtWQkZuUm9QdWhjd0N5Q3RFNVlDU0FUeUI3ZWJXOUJmS3huN1JJdWFNU2tLN3BxUWMydFZtTmFMSlAwZkRMN0J6a3NpRnJCSGdVVDRtOEt1aHAvMGh4MWprSnJwSG91Q3ViclhRMExWemtRRXREQmpDSVE4RFBiMjBCZjczQjF0VUp4TnVWdFRWeUdxam1zV1BIeUgxSWd6akdWM2YwaDUwMXBDRmQwOEErNUs2TkM3SmhHTzFxMVo0ZnVSL2dBOHgvd20zTUQ0S1AzWTNkalZ4bXlUSXNXZFZ4bmlCVFh6My9MOVI1Q2lqaVVlNCs3aUh1L1k1M0VweEQyS1JqMHhWNG1VMDlpa3puRVFXTlVLb3d0UWxoV1FGK0NHTGhZSjY1RWNGNVBkeGhDYzhuRDlzcGI1ZXMvaFdZeWJDazhBUXBJV0Nlbnprd3c4TWNKSXU4UUhnRjNtbWlIZ2dwSDFQQy9odEpnQ1RnbjZUVHdaT0dTeEdEYm5pYkJsYkFIWlJrVi9zRklOWFMyRXo4WWNna0ZOQlpnZWxSZVFscEVmTVNGZGM3L1FIWHBCN3dhVERYK1RRZ1Q3T3pPWjlYODNrVWwrWUw2Sk91Z0w5OHQrMTIyL2NRMVZQeCtTcHVLeEJvdnlwelRkek1oZDA0QzdyRE9UTitEWEIxTkFldkQzTEllN3M1dUNhNk9keGQ5dFBiVjlGOFBPRVIrU1NPSVMrQ1k1UmZoekdLZTV4eTNDVE1FNWN4N1M2eURPajFoUzNpc2FuRHJxS0lrN2VCRHhQcVZjcVlWQWYyS2cwNXptRG1lUDhqSjBWOTdhLzdvdEtDQUJMWlJ1MTRyWFR3N0NQeDRvWFI3Sk9QL0xIMHorRjg2czMyQWRzK2NBVUdNVUVXTGtyekNoL2srU1pjYnVKNXNuVFNHd2g0SDFmVTl2Tm1BcjZmdWFKeDh3cWZqRDc2YVB1NTV5Wm5KeStOT3g5RDhCYzhmM0dhaDY5bG9jbkQxd3JQNUR3MkI0UmdqQ1dwYm1oSEhWRWF4VWt2UzZ1WERaRjJkUUR3VFROUmZmS1I5dGNmZVZJZ20wUjV2QThrZUt1cU9BVnRiMVArZ2EyaGRrZHpjWWMzcE82NlZEWFVCSllXK0ZwZ1pHbFU2a1Q0bFRXcUZGanJMbnEyNzJwVktxM3Q0OCt2VkNxSFNmbjV3NVhLeXZZcGZIMHFZVkl2aWhDY3VpRWN2dUhVbVMyOGJOR3dvMnVodERqUHRiajNVdHRjdEdsaDN2RFFFc1p4QndSSVFTRUZEVnZDelQ0Si9nSmkweGxyQ1ZzNkNaeVAwcEdMT3VSNkZucElNNTl6REJ2UmdBbFRXejN5SHFJR0d6MWRDYlZzWldKQURjdjhwVXA0SVpFUWVLSVNXVmhZRUdTeTQ4bWZaZE0reTMrVzgxdCtiN3FXK2t5cWxnckhLbGtyN1lzR0RVR1V4T3lzZU1sY1hoQmMwUHF4M0hGMzNzeElQQ25HUHhNdkFUdXBVRFZ6NUV5RVhwUklKSHFkSWNpOFlVQnFBNHFKUnFIQUhVOGVtcnd5NmJ2Q1oxbStsN3pzK1BXcGFncitzc1pNTEp5MjBoYVFCQ0VyU09KQ1RqZXcwN3A1UGd3VERDL3JzV0l4dHJlUlB6WkpGL2NxRlhyUjVZaTF4QUdsUnozUEc4aDdITjluZWVEUTJNcktDbmM5U0ZOMzR1NDFtUzJTZE1tN3NNTVYybi9VcXpXbUZxb3d4WXZPZEQvdmRPNEdIbjVyMU1PaGxPeXl4ZDU5aE9sMHlIRld4RlBzZHZOWGVPcFlRanJqQzMyUDVMa0x1QXZSdm03bitOcnBiYXc1S0k3MjJTYWd4RG5NY0pEakl4MkkvY1lhbFNUWHVyWjM3UitEcE1neDF5VE1CRzl6dEd1d1RTbzFWdm90N2lxVjl1ZnBWOVRxcnMrbkNsSW9HeTNGeVRsaFZqcEt0V3gzTmFGdmp5bzVQUXJXVFFZa3Fwd1owQnRVUHQ0Z3ExUUg2ZXVIeitlakRsUmUrWWNZM2w5QVByQXc0UHNGK2JvSjFOd09XM3RJZzB4ZXZZdmRiSDNJKzh1QUlXUDdNdW9waGJsTGNlQWpJRVcwcVJOS2duWkJtLzJiV2ZaMVdGT3AvVTJLU0w3V2ZkTFJMODhEemJ1UU84eWRvTDBFaFJ5WW5mS09LWExlUmhZcVRVSjVwdUhCeGRlT2sxRkVZOGZQcUxQbnQxUUVpUE8xUnJEYktqRDUwVDBIQnVFanJRbjA3am5oS1M0ZlhTNTZKOURwNTBRTEdlSld1SWx2cXVGbXVwSnVocXY0cGhuR1YrMnpoZHFwMmhJRkdVZ1o4YVZxVDkzRXZpd3VGK0dQWlhrVDJ2ZE1GWnY0b21xR3cyWVZIemVMVXhGNDhXeXRVS2kxMTc2RWxmNFNaUEw0NHhCMDlEUk16OUN4NWJtU3U1bDdMWEJ1dTNMaHlpNldPc3FRemNydzl4MTFoYjlFVzFueDAyV2luZ01NZjNHOTE5THY3RVNVQjdxeFI3cXhTM29KTCtzKy9FSzdwVWdtOGVya0tzMUxUSkExTjlib203dmIzeWZUM1dSSzc5dlZYclFYSEJ1VjhzRkNBWjMxWU1PMUR5dnFRWHg4a0h5TTBINy9KZjVDd09jaXQ0KzduTHVPV1o2aWRnVTQxQjQ2cUlFaU5WZEgrMFdZVmxFWVJMdFNOR0cyMkhLZ0JITzhRclV2elNwSVBNanV5aVdxWTYwaks4dTMwUC9SZ2NiVjE5SytIcE5VMFFBZU5MZy9tWEtMb3F6NjRKK1hWTlYxeGFVTEY2Q1RwQmZPYk83bkJZOG9TelZaVlZVbDZNbVJhL1kybHkrOGNMbTVkOXNJQzc5cEp2WWtwaWhCeUpmQ2s2WXNCblRkRlZWOWtnSmZLWVpYVnJPeU5CbXZKOHpmRk1LNTFkV25KTjAyczBsZjNoc08rdndTZjhWc0xLVytURTNGWmpsSFp1bjVDaTV4VmNESXVmd0ZuOE9UY05lVDVtaFh3aUJOSmlxTEdDU29WK0dycVd0aEs1dWR6V2JIT0JqZWNENkFvT0o4QU1FcWZqR2JaWFNCeVc5dTRNOFdZRFNnTVNrRENHVUxpL2tUZHV5RHFURkdJMGk1RzlxQ2RGMWo2eVgxeGZucjFxNmIzMU8vdWw2cWUva0pxK1p5VnlObDNsc3Y1Wk41bnprN2Evcnl5UURaT3JKeXpmMjNOaHEzUG5ETmxXcTllZG44WkhGMktiZkg0OW1UVzVvdFRzNWYxbXgvU3ByT21NbUphblVpYVdhbUpkN1JFWDZWSjQ0T0N1MmFyb2V4eXpVN3l6NFNXL1F4dzgzT0twblNjL25UalNGeDZ2UEEwOVVMc3JXenJPT29xMTZrYTVjb2Q5MWg1U3o0STZvZkw5YkhEVjMxZXcwOW94dmJOUFQ2MlRLV25WbWNmZG5zWXNhRzJ4WFU4NUREcU84aHErMVBrbXVObXgrOGVZMWxZTEg4dGxkMDQ2MytoRHJYVTZmT3FRbi9XdzBkWHZqTGNjdXRhVzRyWHZZYkQxTWIwNSt2ckZSQzhmZ1FEVU03cjZwamovamFFWE1PbXdxQnlEQmJJS2llYkEvNVNMWjJ1VmQyZVU4MmR1eU1iRytLNUZxbTNCUi9QSkxlOUVXM1JqNmxtb0h1TEZnUitYdnV3UmxhNUgvNlUxNzgyazZ5cFVpUGRvTGJSN3p0cC8xUEQ5RCt0M0R2Nm5oaDZkSC81aEF0SDc0ZnB2WDJMdW43OXdQM096M3FkMzhrK0xOT3l6M1dCZnZsdXlGdkRCNDdEQUh6L2I3ZWNRbGZhVyt5eGI3TlhscjNDR3pkTUFxLzNZQm92UWFudkVXTmhkajRrKzN2VWs4eVFoZlhhSWQ0WUpCckc4ZS9zUjBnV2ZRaFAyby9BZGtZcW83VDUySk9UMnUrVzlTRlMwWFJFblJ4K2pVUWhFV3lQZ0JnSDV2VVhnTk1VR2ovL04yQ2VDa3oyNTk1dFdPMnovaHBDcitIaTBOUE9VS2xROVBMeTZYOWZHT0IrUi9Celk4b3pUZGZWT3YrYkk2UTExYWdoMHV2SmRLeHFPeVhnNkk0SzRwQitkN2RtdTI3YzBRaXI1V0lJbFZlUy9TbzNQM1MveHU3TjBsZm5ieGNCT2FtaTdGT3pwSnprMjB2c2pyeVZmQkZOZGVYWlVYS1NRcWF0ODNLeW1XTXdEMTY3dGI2MXp0RVJSSHZnQW43RktPTFpHNzN0dXJyVjE2Z2V4ZlFsZW4rZ1p0L2NXM3hJSmIxREFZUDdvYjcxL2ZVek0rK3VQNS9DWlhHZXBZYnd6N2d1bkM5T05qSmlpSmRSdUc1REl2dlJ0ZDJxOGxIZG55QzBjL3NXcW1kZFZJR2ZHWHU5QTRLSStiRlVUNnk2SWVSMkdqQTRQVUxlQldHN2gvWnJYSkhSbi9YdlNmQ3J2WGtCMmpYaTZSY3V4R3A4NkZJRGkvNUE1QW5mNGZ1MnlnQ0hKZWcvL2MrdFdMWDNicENkNVJTdDlKc2YyZ1ZBS2sycVFHYWR4alFLVlJtRVk1dXlEeEFkMldtSmlmM1RVNDJEQjB0eXEyc1ptaXZlVU43OVEyUk4wbHY4VVprOS9HdUlHb2VOeVN6N0h3R3dSWit0Mi95c0c3QU4xa0xQbis4dlUweXJZcmZ5UFpMekNXM3dmWlFkT1JqWmxtOXlMUVV3YUdaTnp2UVg1cU1BOGxDamZKS1ZlbjNzV1IzVlVGRDlmL1F2U2oyWWtCT2RuaUlSM05HNURUMkVoRHhUN3YvNFhpdkZoVldpOVcrK3BPMW5uVzUwenhRalpsZzRoalViOVczdFFONXFSNEsrdjNBZnB6YXdzMVNUMWE3dG9rd3NtM0pkZWRvaTZ0MkFFSXE0MXFnL2VpT2huTnNHYk1BWjRvckk4OWZ4SFVHYXIyTUszOUpCOUVYb0VZVTVRQlVLRkZtT1dTaDczSzYwNHozdjhaWFhZcW5EWDFmQ1VSc3RwWEpXMXVxSjlzYjYyYWdGakJmNmxYVkdTdm1uWDcxQjUrT3BieUJiR0VXRW03VHhLa1AvV2tNTGtzSDExSUJueStRbW90Rnd6RlJqbDFLOS9QS1o5c2N4L1BrSVdwYnRjSzlsSHNsZHovcUFCVm50UkhrWjZaQlpmdEFtL2ljS2w1N0xHdTJHNk85RFBEUEhBbzBtYTBtVmIxS1dac3RBTU9BN1BwL29JMHp2TzNrY2E5bWlyZ0lsQ2VjSisvY3ZGVGx0WVRYNzZQQ1FKdkpCRDYvTjZIeEtnL3pvV0xzSy94T1laK2h3TXdJM1cvWnJSVkN2eE1xYU9RR3k5L2U4bHVhUXRZVTdVMlA4YUtocittRytLaEw0SU94WUQ2Zjk3RFlha1IxNVlLSExkODh5Z2laRElielB1dHdNT2RTSTdMdXpaYkxXYThlVHBpUmlIa1g3b1U2akQxNVVlUlI1NmpyZk5mdklQT3ZoYmhFRzhZKy93cUQ3blA3QjlsSHY2N0s4cTFBT20rVFpYSmJUNXFzOUdUTTU3elNiWUp3bStRdGoxeG9HMVYydjd2SXdYN2Y3L1NMbE0rZE04bC9uWGxBUk9EYUh4MEozSWg2OTdtWkdIQXJadlZMNE05NjVWc0Y0Vlo1VE5FMzdvNldVZlV1OW5tdEdIUVIzTytVamR5MmU3MGVQemQ4UGIvdVdib1BtZHZodTVINHR0RVY0SnBSaHYvNEkydEFOaEsyZDgwdzFyeDJZbk9OMlF4elB5QzNzTytidzE1VHQvdFRyMnlING4xWmNSMmJZKzR2TzkvN2h6Mmo5bjlPS2p1Lzcva0JjZ0gvUFRYWVgzZnordlBHL3VhNWRLeW5uek9kL3JVKzNpUG1Eamo2Kys2dW5xbDhuUkpPamZlUjFOK0xMem9QdjBnZGZQVDFZN0lMSEtjNnZZWDR4c0l4MEtYajV3OUhmNS9lRlI4SCsrcjZHMk5CMmVpQXV6MitYVHI5ZTk3cG44UGVKNGU2MU9wQTUzYjRLM2JHd3d5MVpqcklYWS9hRTd2ZkVpZ29NOGNiZHBVeEZtZ0RBL1ZCVDBIVVYwUm51MDYxZTlBS3ZCdHcwOXZsY1BseSt3NlY5Mmdua2V0YnVUaFFiQlMxOTJvUW1rVHd1dHIvckpNOXFvZWZFYnp0ajdLRm92L0pMcDcyWDZYSjJwdHFnTEthSkt0eHlyREhWWm1zejZndVpsRDBrVUM5V0l6N3ZWNS92RmhzQkNWWG9PSlNUN3NDN1R2WTBoRDdlMmJ6WkUyQVBMeU03L1NPeHNITFh5d091cnVuODUxSUVkNHA5V0hKcG1zSjNwVit6aHNqdHcwZ2hHUXBSdjQvUmNwUUUwNjI1NndUUFIrMFBONlBsc2MzaisvSUJLUFF2MTQ0KzJWZUlQOG5WK0h1b2xaaTlLZ1pZSTNZNlVvS3VueEZueXY0ajI1WDhRQTIvQS9UTFY4bGhhNGtoNEZVS04ybFpBaWN0V1NicmlxWFlBQTNuV1ZsR2pocnorUkhwcFNNcTZIWm1ES3hFQXducktJU213MnA4U1R1VHVtOUNDNU1kSjVYVmRsVjlRbytWOVhEVzBxeHFGaThwK3J5Q2Q2cVMxYUx4WE8rM1RMbnUvbVlWaUxHc3A4Mys3THZLM2JlUDV5MzVPN1BXdzJ6dDhZQ3ZDMlZvT1FGZzcwTnE4WHVYZ3JjYjJseUdhNEVtTzA3QmFIcnZ4Y3R4bkdaSGZ1aTByU2FWcGI4bks1b2RiZkNIenAyamVnV2pwUDFsd3I2ai9hdVhEWGQva1hGRWRBZEIxMWZJdDdGYXlSZSt0RHEzMG5DYjc5OHBmNGFwODkzeXk5d05lNFE5Y0l5Q29iZFZJQzczUTlCdk5wVEgrd2FIYTdKdnNONFBkelZWVHd6b083c0hsalg5UUhuMUs4OERydlViWmRpS3hhaU5zeDJJUTNoOTNjZlZXV3BmcnoxbnR4cldtK29TdDRkTUpHS1Y2b2RiNzA3OStybCt4WmtXWDIwdCs5ekMyU0twd0hUZmk2TU93U3BrWHZlRHNGUWNmemFTS2FzMkVLb2F6ZnVIR0RDanNhWUFqYUlwNmRJUkJhT0xUeFZlVGg2cUFpUmhXTmtiekx4am92MjM3bThmT2YrMld1eUpBZEVNWllyS3BKWjJIL3RISzVQYlVDNlI1OTZPSlpZT0hZU1BpMGRUcnlEdUF2TGQ3N3B6dVU4cEJmRmFQNzZDaVNjTzNaaFFSbjBqUkNsdnE3SExzOVk5Z2dqbmpHdVp2OFVIWkM4ZXdrMWlxSjRnNkNMVDRqOWhtVjlYTnpEWVZGNDF3V0NnQXJMRzBUeDA0TGVONy9pVHVUeUtDODUvdXlnVzYydWRyUnZ0alJ4M2FId0JNQndBOU9ITHIyYjZVTTNCelVPWlBYVm54YUhuWlpRZjJma3Y1Rzc4VXdVcmIvV1RZZURJNTlyL3dMOXB5VkU4Ukg0bGt5TEVOWEpxOXJQMzBKand0c0VmS2dMU1J6dmREOEpRVHVqSXpERHZKcTdqL0dUVTdnSTJPZlZHN2RRQU9uc210RGdQb0srZzVYUVZKN2VESmpMenhGcUlaNGlWdGY1R2x1TUN1WHJRRHlzYWtpMjhnMHJYMi9XcXlIck9VVnlLUUl4c0FzYnFabUU1amIwaW02NHRjUk1pajBrdk9xU2xJQk1CNVQ4dit0YVJCTU1OY1B6QmkveFVaZHFxTlB3bjVvbStySisrMlprTFpLTlM0b1pNY0owZUlpQnlmdzFQbUlFRGZnanZtdnlrd0dSdmdnYkVWT1I0cnFvdExDWWxpTCt4R2VGY2p6eHVOS1FzY0h6MFVqQW80aDhxY1NMeW0zQ2REYjdCdFVJQktqTnFFRHgxd0w4UmJsOWFJbUdOa2ZOa2pPL2hrd2xoWHRPb01LNDhRbWw4bEFWZDZ4U3E5MnVjZzV3amRPV0xOVUhaZHhNUGVHMy9CVmZ4SitvWjFwYnJZcmgwVUpBakVLYXh6QXZ4ZTAxb25pTkdmSzdBbzFnaVBoZzZEOUx5VUJaVWg0dlhIK0Y2UTZoeUJseW0xZGNYN2dpWEt1RnI0aEVKRkVrazVORUZLVklKRDkzVklROGRPSGFUTUI3NGRUY1QzcmV4TTJ1YjV6ZDl0NnpQUlZYY2x5VVpQM1VhMGErdnNTSDhyajN3WVlvdGpZYWpCWHh5bDdCNDZybDdBb29PcTh4VHA4Ny96eEhGVUx0VXkzOFdYZisxbHZ0TFVDRTh3aC80QjVqVzUwMFpJdnVXVVEzR1d1dDNzOTZhOXhOaTY1ZGZwOUhINkZZSjV4MWJrRi9RQ1JmMzJGVkVNb1BQcW51MERYNnMwcS9vTndjTWl3WmNKMDk3RkNQUDc1R2ZWTlNNcDc0VGpkNkRKdVJyMEFZUlM4aTZ4MWxUcXBtS0pLS0tTQm9uK2s5OWxXaGMwQkx3MFdRUmRLcTdKeS9JTEQ4N1RPWU0vSDVyZlpwd3AxeHZvYmdjOTFKN2E3ZXc5ZFhvZGRBYjRHTGpCNG94K0p0R0VlajhMZ1RiOUt2Z2JkalhWeDlwdytEYTRONGE2K09SQnlwakVmY1NMeFZmazNFOVdqdTlkeU4zTXVBNnZab2J0ODJYTHJzTTNBMnlyREJHT1VWZXJmaEVUVFlGcFM4amVQTEJGSnI5OUZhTDlEYUdNSVpUSW1HcDBFdHVwS0NFQmFFSkViTmhzY1FVMEZNRUNOdWI0L3NYaHFaalNRTFdrTW50M1pJYkN3WFRQTVVNOGZkWmx6a0xWNU1ZQjRKR28yYjd1UDBKWDl4ZVpETWt1amh3MjhnNUtMSnFVUGY2QkJVNGV5L0EyNytqSzRoSVgzaHBLRkRMSUpLMW1aZVIwZXQwblFzTlZFdmJWV3BLVmJYN1d6cTJ2YVphNVZJYUhNQmdWdWdLbVFXM1F4RkZ0dS9kOG0zRXIyekgvU2YvU3lZcS9TbG9kRkt6bmdHNTh3MnBmbnJYQTVvMzVYY2NUd0JBK1pIYkIrUVBKaEJVYmNoSE1QWk9YcVVPTEpSOUd4SytHUEhQRk5ad3pGU1ZmS2RCaEk2Q25SU25paVVacTRJSmwyU0dBeDRzQldRdk1zL2RlbXp1aXV1OHhvUlhhS1lrMVZKRnlUcEN1akt2bzJudGlPbklwL1ZQVHI4bGI0NGNSUW1ucnpmN1Q3cFQ2cG1aTUVsS0JkaFBTOVNoQXYwb0doSkFkZGVUWENWZ0IrSHFWU1FUK3BRbEtoQ1RvLzZqcnR4bnlwTUxaZ1ZYWHVsZFYrbnRveUwzR0c2U2tCaHo5ZlBVVC9Vclhjd2t5Yk1CKzRzQ1E1TmQ2U2pXZCswRDlqYmhtZXZ4OGg3QkRlUkRFbWFWblRadzB2eXlaTm1XbGNWMHhlMFNLdDIvSW1CWTQrK283cmRQcmVick1IM3AzZ0RaRC9aTW82NlJjK0NKQ2c4SHhUVWRiY3F4a1M5RWkwRnZMNzFRRXBSNDRXRjdkcnhXbnU2MS9hdndFeDhibWVjdHNqRDNCN3VBTlIxaGJVempOUGVxR3hRKzM3S0R2VnhRMzNqMEdsK3UrZkxyR3IyY1QwRXhrVGVHOEN5ZFl1UXZSUEpoV1JZeDl1QU44OUdIVzN2RHpFRElxSG12c3o5RG16ZVVsaFNKcG9VNG1ScFlpOVBFcFZrSVVIdkc1T0tGTzVyWlZKbmxrU2Zha3hPdllVMktKTUZzRzU0SHRWZXJvVnI2TU1qcmNoMktYVEhHVm9VT2J0aVphVTcxaWhUWTVmc1BJZ05uYTNkU0RkN3JFajdPVW55YUlaTTdURmp2Z0FsaVFFZkpUNEYyZEE4K3VWQnVTQUhRNlZhQ2Y1Nmc5QlN0WENzTk1HOHJrMVliRlhDbW1EKzF5WktzYkMvVWw5YXFtL0g4TE1TMDVrZ1hVVWJwTnU1MTNCdm9KYURIUXVrWUhjeW9iMlNVbzJHWGUvemViMmY3S1ZPL2RCcko1dC82SDVFeXNqUnJZbjBUR1p2djg0RWt0TTd3YW8yUzdhY3MyV3JTcWw0SHI2QXpFTktxSHJTWi9uOWx1OEREZ0VOQU8xMU05THJtZUZGazhDNEUyVkZGM2dpQ0taRWxKd0NRaGp3Nkx3UWNzRkxVK1JuUEl3T0N3b1E0by9HR2pGRE4xS0c3bHBVZUZJZ3R3QVozaVMvNi9iNUlqNWYrODA5K3FvRGJaNDZLbEIwM1MzeExrRVZGVlh5Q1lJWUNvbUM0SlBVSU04VEZ5L2RUWk1JMlZBZU9sQ2NlRnN0RWZkcS9UaFpNRE9DY1BpTlNKdlZUcC81ZDJyYkZJSHhBSFRQR2pyS0p0Z3g4M0l4MXdmaElYeFMvNVpkakZZWlNsTkVFWXFBUUJtR2tnR1RJTzZoYWZVZmZiTUZuWDh1azNuOUszaEJMSXVhb0t0dXc1VFIxR0pDRlpSb0pxb0k2Z1FhYmNnZ2xQQTZwQkg0VjdTL2NtRDdRSENtb0FacXRZQWE5TS9VZWlQOE45bUFhSjhpUkZMUnc3SVlnQ3hkR1VsUnpWRElWQlVwNHpKS0lucGhWcVgyMlc5LzRoTzZFSStFdk41UXhQQjB6NVA4S3JrUXhvL0cxYm5MdVd1bzV3bEF4anllOGR6RlIxOVhxOXY5YTZsZVlyS2VZN1ArMHF6VFEzbm92NFZianp1OTU2a0sycWMvTExNUmhiMUhjNlUxUXorakcxcmFwVW5LTjk4S3ZhQ2NLVmZnbi9DZkJ0S3cvU2pheGVzZjdWRUFGeENMeFdOUnhYMEh2cmpEclVTUExRS055SlZuWTFOYTVsQVpmZzVsdEtuWTdMMUlIZHpkK3VGWkoxSHE2d0xvUXpXTDFwOGd2ZlM1WWs4ajF5RUhlNXQ4bFJDYWh1SXVhQnU5TURMUHlNTUhVV1ZJS3d6VC80Umk2TzNUdXFGTUVGSFJ5NVdWU3JsQ2VORzE1Uko1VXZuSUl2VG4zKzJuN3djWHMxUGFoS0svQ1N2eEpsMlowS1l5ZThoTUJYNU9WSkw1NkZTbE1oWE5KeXYzTHNKWWNQKzgvMmdrdXNiTmZMQXEzRHU1RGU1eGJwUDdIUGNsWm9uZmdaRnltdWVtRWVmQmVZd2tFRlk0Vk4rdEsxaGhrSW1iU25XUWZEUXRRSEVWRWQvcklwMTM1TDBGM2FlL3VxZG02cWN1NThIWVVZSVN3SDBta3F5a0pFUGYwZzBwQllLbzRwSGFWd0duZDdTaE9RVG1qanhScmxWSVBwcktwYUtQQng0TWJONVVVSFZkdmZjQVp0VkhjY29Ybnc4dm1BN21Zb3diNUdYQkJmQVdKMDFSZmdtMjdFdGswWndzQW5ndWdTUU9IMzV1OGlKQ0RqMUFhZERmUnZ6enRqM3ZqOWhSK1BtNTAxa0h6eWNhMWhVTkxtSTJSNXlXUEVaWE5ITS9WYmtJSjA1UTlZejRnS0NQMjRSNDEvMU1Td05KcWNMby9xRjFYUWV1OGVkUWpUeHhkOXp4VXp0TEczMmkwLzZkRlhneFo3WDJORm45cC9lT09XdnF6Z2NHWVhwQUVFWUR0ZnpBSUZEMzA2TisrK0F5cVYxRzM2bEdmZWFHMXRqRmNLTHRyT3pQUmlyMlNISUhxS3VqRjJyUjF1Z241Q3ZrdHdHbUNZQm9sTjJqTWxMNStNVy9GUEV3S2VyRS84a25tUlAvL2pnN2E0cThESStKd0NjaXZoRWh4ZnQ2VVpHOVpIcmpzejhrbnlFZlkzQklBNjc0TzBlR05JZk8zcVlkKzIzblVVQ01BVE1XVmxZVmJpY2NnMmVIZExiUktVTkhieU04ZTg4RERQS2g4OEpaQjQ2K2RoblVCamlOeEk3eUdEN0I0N3lxR2p1ZlZtRjYySytRZWRTVWtkR2RZRVNMUnlINjVKUHNWSUsvRXRpeFl1eE1KKzRzeGF0elp0UlFRLzdMemxZYnlod1BieHJJSnppcUlhSWowRDRpbzRFMS9zNVptQ1BQRjkvdExLVm5SNHoySDQxZFhENjVnN0NKeEgwKzYvOXN2V2owdWVXN0dTUzhkVWVocERVV3dqL2ZTV1UrZlI3cjhaM3pXRWVlaDc3cnl2d0ZPMm5yVzhaQytOUUlqSC9oUmVCdzVEbnJ1NEg0bzUxbytmdnhWaFU3Q2ZES1dBQTc0MncvOXVuUmczcG5CNzUrNTNobCs0bi9FM21heXdETnVCVHlwQXZHdUZnczAwSEM5aUUySGIwWk90VG9DT3pXcUowcWpyOE1QUDBrYkpJUCsyWk1kZW1LSmRXYzhZVkNTNU1wTlI0S3hkWFU1RkxvZERTZlg4am5QM3ZFME5HVkd3MlA0RzY0SXllT0tEQ2QzZUJUOWVMQ1FsRlhmYUY5b2FYUHBpWURnY25VWjVkQys0N2lkd3Y1Tnh6NU9uSkZxNnNZZmgyL1VZNWdCb3h1NEJyWms0N3RTOWpDeFFZNlE5SlZDTFptcDZEWEs4ZFJDT29xWkpKUnBKbEx5blNXSzE4eUl5bHVaZkdsMVlQM3ZQM3VnOVdYTGlwdThnbWZyQkY5OGVvNU9oYzI1cTVlMU5ISGhLb1I5OFV2WHpwMDl3R1lKcGRlZHJHYk9HZG05UGlKYzNCZVk1aXNjUnhWZDcyUzduc3l1VW11Q2xJV08xVm5lTDkrTTAvOWV3MnBsTHZ0Rit4ZlkrM2JaQnNPRVkrZ0NzZExFRVFFNFNLNHZJN25wMVpLdGRKS3h6b3o4YnZNUy93SEphRk5mVG1YTldWVDBjcUM5SStDY0ozTjh4SDQ2aUpCdUkvWGhDL0VTcVZZZjYvM01aZnc3VHVvcTlBVlFjcWc4VjlHRWh4NWhOVU45N3VVUWNiQ25kU3ZwRFk3QTJhTnd6Nnk3UjJib29PL2N2VWoxSDNwWVBEcGdUM1IzejFQYkp4bXpyY3hXTzFGN3hodytFN1VGNEdnM3A2M0VIQ3B1Rkk5c3BiQzZKb0J1ZXJxMjhqS1lCMWllRnFJeUUvUzQwRW1JZXBzQmlmcncrQlJvMitnUld3anNlTVI2bFBPcHU0ZC9QM01MbWZpOWlRK3g0bkJtQkdoWGlOUlQ4MEhSU0lFeG9zY2R5eUw4dThpWU85R0oyb3hkTXdpZFAwR1JZRWlMSFY4K3ZlaGpLNHVqTUJiaVBtKzYvZGVRMDYzdDRCd1UxeTBXT1QrOXJjbzVoTG10bmdUaTVNYW1uSnZzWDNpVzg2R2NVemZyckNYMjJZQ2NMenFwT1R4SzA3czJrRmczNytBdTJIMzgyYnNzR0xRSmVsYUUzVktpRDU3RnMzSkdvd2JPY2RiYSt6Uk0zOHRpTUdsUFlGZ05uVXNLdkIrWHVMTm1WUnl5dVJsQXJ5WjZieUs4YnlmeVBUVnRBbHB6blVJemJXaUdQSUVyR2hoTmhZaFVVRklDWVQza2Roc2tnL3dRdnhjTDdzOEY4OTBMZzNxMVNTSHFqQ2szbzVERS9RbWs2ZWVmUEZrRXVyc1NxSEg2OEFJbjZWbnp5UGhWOWdNT2JSbVJIejdiM0hQTktlT1RwRVYrNEJkbnhJdW5IYTVvb2NueWkwakVJa1hOYTI4dUZodW4wclZVczJKM05LZXpuRnhCK2xtaVlPcVREYXZ2Q0J3MVR4a0FKL1BYdXFkM3NlbkNwWHB2QmROdVJaWEZ1SER5ZjB5eVMvbHZuWlNnRSs5ZEZIdW1MZXZYZ21vMXpHME9qa0g5TTN4bFE3Wnc4ZTY5WjAwVFh5aks1SWZYZTM1SmxzL3Z3T3FlUWRiQldmYWRMSTJxa3FWRVhWLzUyODEyWWQzMEd3d3QrWnZPZnFtLzZpMlpNWXQ4cEI3aUJmWmx2L2JyOUdXWC9yL3B5MkYrc2lqOFp4S3ZzaTJKTDkrVzdhZkdOK1kvRUNkZjlVYXY5ZzZuVGZvOU54M3R2ZTZSZmNaTTkxTnVJbyswUkcrK1J3NlRVUXVnbnFiUWdZV1YzYVFtOGdCc1BnZXQrbWtDVDAva3UxM1YyUkxkamhIWkl0bDlCRzRSTGYybE96d1VvK2J0QnYyTEUrNDVJeFA5eEpCTE10eWZxRmFTTVl0SW9tQ0dKQVU3VVpWa1FJUUYza3JuaXhVRi9MUUJ3V1JlSFhmVERLM3R3QnZyRkNrYUJhV2k4UU5IWlAzSmdNM0JaSmVuc2k2VG9vWEZNMlNGUW9MZ2xqWVN6YnlqWGdKUGFZdFhMTGdzWGhCaU1aMVgxajJldVd3MXhVSGtzcUhEWGhGZ0pzb0pocjVTcnFSTVlPOHBoZm40NFVMQ3NUbDhhZUN3YlRQNHlKd0c1OHY2aG9mTkRQMVROY09DdjFLTmVscTJOWFVOeWpkdFdReGoxN3dXNmNOeWg2R0RPS2MvWWVHVWVqTml5MlhMWk5pbC9QcTJCNTNJMlI5N3NCY0prWkNFVzhoWVZpK2FCcnUwMUY2U1ZpU0dYUkZ5VlFvSHdUV0xOVSt6VHlhZWRqbDI0NGJ0QW82aVl0UHFwR1lMTUNQcUd3b2szSDJUSG5HaVVZbk5GVUg5a0dVZFNzMnFVN2V6NXlpdFZmWmxXUWNKMm1NeDZibkFkMENQRXlFYWQ2YXVKVHBzQ3R5TVI4Mk84NDFpaDJPMCs0M3Yxc1hYb2UwNFhVQytmbnJCQnB2ZjJQMndJRVRCdzdNZHZ6elRSM2R3bE9UeW5oNGtqZkxZaXVZNHNTQmlwTUFBcWNOMEwvMkJMY0EvTXNoUmpYUnljUVl4TmZwc1lvZFR5ZERXTzhlVGtRcWlXbTVsb21xNFdRUDNlbW9OSHVwVm80Q3Z0cG5SMktheTRNRUZ5bHFFOUVoOUVMMDFkSzBHbzVETmh1RHFOM3NZSmJhaGZFdGFzZFFRSTh6RnA1VkVNVGxMcUFjUWtjVFBhVG5LUTdjTzhxYmY3VUY0VjFFRnRqbDJqZ3Z2UEtWQWg4WFpPRTNCZmlUU1pwZGhkNmJsaHVHSC9rbkdHWnVXV3duQlBIK3BLRHdOOTNFSzBLUzV4K0N0QTkxTDMxdm5IR3dUVzE2VEM3RmxYRG5XWWMzNjh3K2pMdnRidUt5bkJQK3JHd09xZ2hVRDBZS3o3WFgwQ1hoZG5ZdUExUXJ0L1Rhb0dmYkF4MXZKWk1CREZvdm5QRzdkVjdqVnpSZWQ1Tk5UVG5MSVdKOXVhV0xsM0x0TStqN2NIdHpFOUI3eHUyS1JsM3V6bnJVVHdHZmwzQjNjL2R6YndGSnFlTmZ6MHVvVXhNYlJGMlNKRExhSnpzdStHUUxIdEUrc3AvUWt3NnNNSldLMFU5T3cvRjIwbENBMHRrd3hrT3lYUWVTQnYydFdhbzE4VWdRR05mMWhoVktFUXNQeHdpYjlvN1RRTWlmcFJXRkQ4eEpQalh0OCt0cXE2WHFmbDlhOVVsekFWNVIwb1RzOHI0eDdRNVBSNnhrTHBlMEl0Tmg5N1FzNzNqeWdRRVA1OThPaUQ2bE5TZnpZc0NsRmpRUDcvZnpIcTJndWdJaUw4KzFGSjhZQ0FiUEk4MTBOQk9QbWg3WGdpd3Z1RHhtTko2SnBtUHBVUTlmTlhqa0NLZWlEUWovTUxURjFkekQzRzl4ajNIZjQvNlp6SkltbnFGcW93K1BrcTNJanIveHhuNVNhdHFPejBQcy9qaFBVcjRjclViQ1ZyUFI4WUxvQlRiZVNqRmFpM2I1MUVPSUFxdy9yam51SjFhakNXTUdoa3dKWGFET2tYcEpDZEh6V21URlV0Qm1Pb3dHMDJuU0hmYmQxaXJpcG9rU2JvNmd4L0ZCZDFIWUVTSzQ3WW9hcnNKc2g5TmJHSDFoMDJQOW9MczBtVU1jNnY4YXQ3QTBHM2EzMllQL1FUbDJNL3piUkZMVnZlNjQ0cGNqSHMzRnkwcWNrTGlpQ0M3TkU1SDlTdHp0MWRWc0phdTZERThNRW9VOVBwbklNaWFTSWVMemhDRlJ6R1BvYXFvWlQvaXNnTWYyNjdZSVA3YnV0ejNCc0MrUjhFWUNubEpBdDFIWVprOHRYN3hZcXgxQkY5MlJTRFlTSVI4Z2l1aVRkWlVub3VFWE5WNzErbFJlRmYxZWdSZFVsK1FURlNJSW1FWnlxZkRJNnhmaHRjK3JDcERHRUFtdjZqS200WVU3alVBZ0hnemVQRHEvZ09Ia0o4bVlud3dSWFlGSFJzREpqOWNHOGhOZXc3SkxLZENMMDRybWxRUTVGdlpuTlovbzlmcThvay9OQmtKeDZPMWVUVTZySGw1VmVZK2FsalV2OVBaSUtKNVVEQkVtSHI5b0tJbFlPQ0lMb2s5VE1wQk9xVXJTdEt6NlhPRlF6UEpGSXY1d0xCeDIrVlJwUmhSbkpNM3JDc01EUUkzUGlvWHd1VHhSUFZLckhxMnVNeWNLRDRteTEyMklxdUNXZVVFMEJNRVFCVjUyQXpJTXQxY1dBd0ZKd3ZjYTc0WXFPTytKNG9iS3dYdEpDZ1FXMkd4eGx0c3Q0YmtMQ21aNzg3blF0NWM3akdlYTc1Q3M4eWhaVjRONWY5VS9kQ3pyTHovTGkwLzk4TE5QN2JCRUJ4RjNMNTROMGY0NjIvOSs5cGRudnc5ekc1Nlp2cGQ2eWIyRzZUNlF3Tkl6bEZqM1IvZERuZWtpWitPd1J0Tm9KcVk3am4yb2ovWHVibkZyUjRSa3JuanJGZG1Vck10ZTNpTnBraEQyWEhmeDlCdzh2UHlSSzZxekJjc3VSbkpDT21BbVV0Vzk3OTFiVFNVdzhwdU1VcTBOWE1qbTRzMTdDZ2ZqUHBjTVU0L2lNdHdlb2hSYzFMRndlOE1JNlFFcHNHQ0dZK2xzc1ZDeVlqR3JWRGlLa1UxR2RzMkJDL0RjL1RqNGRXci9xMVh4VjYwTnMxbC9BZnJJUVpCbnN0dys3cVV3aytMdUR4c29kb01DVGEvMUdyRDI5TUJybkQ3cDFuTzZuUnVxdU5Ca0pqME41Z0FmS1RtcW5mRXNaSnNlajR6WlVDZGl6UWEvWDRyNTV1djJTd3I3NnpHck5qVWhtVzVEY2NtUldGNlVEYVA5UjN0bkp5TmhuemNpejllV2l4UDBMaHlabk4xN2VFOXRxZGlhbktrVmM2MDkvcGhxZUYyS1M0c3MxZmFJUGpPbHlUNHB3aXZaY05FYnRDSStYN0ZvTlJNTEU2S2dwc2lKVURDZFNzV2pZZjlFdE9UR20zMnBkREJVU1VTdm5zNWZ1R0I0MVZ3b2sxSWwyZTBwWG5OMU5FRjVpOTVla3duSzg0elY1QVZwQzlNVmUvaEw5ZnNERzZuT0syWjU2V1ZheUNNNDE1dDJjV2U4K0E1RnZGVVYvQzduZWtOdmJLTWMrbjE2bm9sRlYrN3J0V0dISHBRblU2Z1R3STY5ZFkrUDNEWk1KYkhHRm1qV0VvcWgzNndiVDBJRXRiMFFoWGQwRWVmWnZyakFYdi8zVHZKZURqM1pBYzlUeG5YWVplNGxiTWRwVDlIcDJNRVVkNW91THpSQ0ExdXlRcDE5V2lQOCtKR2ZQd2dRb1RpUCt4SGJ2OStOU2cvaWtnaDFFM09TUGp6VGVVcnZ0Z2ZlUmZyaXhnLzdjK3c4cEttN1BpSW9ucnYxSXVkZEwvLzUxK3R6QS9YNmwvSDFPalZRTDhLTnIxajdIODlSTTlYeDgvczA1NEllbEtFOTNkbTdVWFI4bFZQbU5rdjFBVm5rUzdvaVg3WVR5WGVGd0d5ZlpYcG5NUkM5ZktLelpUN1RicUdXZzJ4UlhVZUx6aVZiMUdPbTAvOWZ5NjcvRjd0OGoyeWk2bjhESlFFODJ0TmFXenV6dGJVK3dIaXVzSkhRLzdlcUtWdUtWc0ZQOGJ0VDYxdGJYUCtac0wxNkhzQTF2MSt4bHZXKzFjNm00LzQ0KzJKcitHVkNqd1Z0WXozdGxWWnJwYjE5UHRValhLZHlaOVl5bWJXdDNyb1krc0NKY3pQY2Z1NHd0VUFZOEgzVDFSUUM3R3pHSDlEMTczZ1NSQ0VPaUVTSWZMWm1tRStZaVJYbmdDZTRmdjQ3cU40K21qQlh4VGZSNkNzTi9iZ290blNlci9Ea1RUVmpTUHZ2TnR2ckk1VC94M1hqbTd4SXVCWjh4US90N3p0d3pyVVRXWkh6dlRNTm5OVVR1bVhLZEl4TDJXR05ZeWh3M1dObVMrVldvZEFxNTlNQmowRDRnS0JMaVd4aDBnd1hRaUdQUzlSRmt5ZmpLUEx0aHU0dnRxNXNGYjJxVzlDRXBNaUw0ZGxEVnR5bGFDSVI0NkxtK0pTNUVPYlRqdSs2WGRjemlydjQ3ZU45N1F6dFVkdDB6V0thcmxrZzh0dWZjN2FYSEtaTzVUb2JUVWR3Yk4xRjlFT2RqUzU5QVQwM2NoQm05TGYzR3U3TjNHLy8rdERiT3ozMkRlem1zWWZ1aC9Pci81clllSEFSSXhoWTdJTEJWaTlLMW51ZlVaZU9OSGl4T0xUUDdhZHZwaHQ3TXpYSHhjQTVrOHpCZThjLzVIbDVobnhSUGFZZFFQUzBNeUw1TG1LTGJKOWZ2Nm1JL09RazlSREovK0VmOHVMSk1iNGE4WnlNL3dQay96OEYybXAzTlhYc2ZGVjZHRHZ1MVVTdFNiaFpwT2ZOMEkwaEJJK1dVdkRVemM3aHF0WU9kUXIvb0ZjMjFRMVhUUFVvTVZmN0M0b2lYdFQwZXNrbExsSHhxcEpyUXhYYVduRk8ra0h3cmt0TGR3Vkx2TUt2OE9RU29NQlhMaTdhVUEwN21TU2JZVldRWHFhSXJvQkxVditiNkZXWGJvM0sraitwTVZkWWo2a3ZrNFB0R3dLSHloKzdLMWlMQmUrTTgwUzRSNUF2M2dNWlhMbW5xK0p3ZkRIelFHT3JYSU9lOVpmM2Q1VnoyWjBUUDIyOVlRL2VnbElQTmtQa3VmSXk4M0YyUWZzSGh1N3JuTkprNktUY3ZYM2Y5M1AvMkNMSlpVRVhBb0p3UVNjRnZHMC8yL3NBYmduM2ovOTRsdnZlOTdvd29rMXpsYnVOZWtMSXovSTliNWNHMzdNZFNQRzljejZYK2FZRFg4OVRKcDZVMEpuT1FVenBwb1ZHN09aaDlOeDZrWjhuNWRxeGVjcGR6QityeVVuc0hqc2YvWURlTmE5VUovSDlwSHBsYy9qQkhKdm9uajFISm4yUHZqSTJuODZEajdISmx1a3h2d2E0K1dwMzF5b1hwT3BCM0lEVTI5QU83YW5nZHZ1UUZiS3RlalAwLzV3Mi9JYm50QjdXVDNzZ2R0cnY5NTgrZmZxcHA1NTdpbnpoQ2puaS9hSEhVbDR1UzYrUUxjOFBqYWgwaGFKTVgzSE5zZHJScjU2NDRTdEhuNEEyMGFIY3Y0ZHlQOUczVDNZUDlmcCtFWGVVN1IrQ01uRUNTNUllUEdqVTFBTUo0TENibG1JRFRJcGR0K3o1cGhXQ2dSTlNxbllkZ0swMzYvQzRTZFk5K2dtUDU0VHVlWVh1Y1dtMytYeXZlSVhQZjZ2bTh1amZPM0g2RHZnNWNTSjF5eTIzdlBxdXU5eXJxMyszdW5vL2pmL29ibGRBekV0U1hneTQ3cmJGb090TzNTL05xMnF0cHFyemtsKy8weFVVeFZzenR6NW8yMFZYNXRiTWMvTTMyZ2NteW1RNmJOOVVxZHhZYXN5LzNJNVBUNU55eDk0QStja3BxT1VTMUE3VllveTJkN2hkZWlZYVhST2pMc3Zvb2hnMVkwRWFGOHJXR2hMT0xWa1kra210bWdWcXhFNXRUOVZTbVd4Vm5WNjBEOWhrRllMRjZmYTlaTFc4K01MMklubTB2VmxlNURPTHoyZktQak9oS1JsRncyMXY1WXh4NlZ5R0hzdGhaK1l1TmNxTDVmTGlOZ1pkbmg3dDNMcHJDMFVxd0tJOUVUc2cwRVJld2xJNnZCOGVxMFQzLzlUc3JqY1pZZWZhZ3ZJblBHK1VqUTlOdWFpT05oS2FtZ3BGcU1MV05mVWhlTUh6N2Q4WlVCM2NKVWlTTEVsYmZ3TEV5NER2dXFsN09YeklnTEhMRTRWUm83TWN1MzRLUDVPbHpqNG41UDk4UUlFclhBdjk0N0JkZUd4VjVnTHFGaUhVdVdISHF1MTJMekFSMzI5MkQyV0RxUWdGL08zS1ZYTnpWNjFpc0Uydjhmblp1MmJuNDJQaTc2K2luK1d1dzJXTWtBMS93aS9DdjNONWU0ekZZNlpMMTEyWHhkbGRmTVFkK1MzTlpjWEw3WDhveHkyWFJ1T2tRT09kUFNyQXVER2Z3VmR5SnlrZlhPdTNCOTZ4d0ZMcm5PODQ2NmhzRm5wblBUcXJmUFAweUN1VEttOXNQUGFxMUQwQXE4R09GM3ZNSjRyWHNUVml1TFRmOVVHMmNzd3U1QUpOOW9aVVkrYnlFNWZQR0taQjNmcHBzczlVUGNTT0l5RlAxOUpwM2JCeUZyeXRIYTRaNUJCK2ZSM0w1RHF4L2RZUHNyelo1YlVlaitvMVBWWmk5dktabWN0bk1RUHFXekRyTlZSZjBCT09KV3pJSjExL0ovQ3BsdVhIOTNqb29tNDQ4MFBMOFVVOU8vTFVnOEh6R0xwdUhhbnZ2VUdXd3MxNHJuYUduREwwOWlrczU3YUFvRjJoQ1lIYllGcmE2cmVLb2Njdy9QZG5xR0hWb3FvdURzS1NSanZUM1hoTVpWZUkraG5CNlYxQkdqVFVlYndQTkU2amEzVVBPZnZhc3R3a1NNVzNjUTl3YjBYdjA5TEFHY20xVXJHenliSFoyZXJXZFcwdVVRMVl5UTVWNnppRXFCTW1YQzZuR2pRcFJjK3NnM2RVbkdGY0VTNDNHY1NpaDVlWG1pVzcxeTh0V1VtUlpzK0d6eW1VZi8wTEc2aS81OUZVci8wSXM1ODd3Nnp5MnE5alYzSW1JR2xDOElKR0pSM3o1aEphd090R2JWc29GWkg1Ri81YVMrUzhzWFNsY1VGUVZIRmRYa2JOb2NkeWU5ZFhyMXE2V0F5bk13bTZRVE5SWDlUVno3Q3RsWHRaT2I2K2M4ZFlVUlBPQzNaWmpDdDYxbmYzdE9IVnZKNjRWVGQ4L25qQWF3akdrZ2VlR05OMys3SzZFcGNNUVpWRGhtclVyUnZLNGJoZlZ6SVRiR3ZuUk1abGFaRnZzVzJnN1ZPc0NFZnY5VlhIcjNBUVYxSUh4N2hnTmUydi9MSEw5Y2VlU1E5Y1BtdE1mdmpVcVZPVnYvTGtQSC9sODdFTDRmN2lMLzRMMTEzbnh6WG1SVzRaZU84anpobWdhUEtRWmI1dGNHZWloUXJNS3FNSEpyTjNhR1pUUEhYSGpHMEtKSVRRQTd4c3V0bE5WdklsbTZ5ckNsck9rdllQZUhvbW15cjRrL3VDSVpmbjdibVoyK2VTLzR1NE40R1A1S3J1UnV2V3ZpOWRWVjI5cTF1dDd0YXVscnBicmRubDJUMHp0alhlR0MvWXNqM0dZekFnR3h0c2JJSk1IQmlDQ1dJemEwQTRCc3lIazB3SVNWaE1MTGI4bkh3a2NWN3lKWHlRZ0VMNEVlZDdXU2FFbDVqRjdYZlB2Vlc5U1pvWjg1SzhHWFhWclZ1M3FzNjlkZXZlYzg0OTUzLzQ4RFFhQ0UvemlmTGxsMWVDMWxjVTZ5OHM1VTNsN0Z0eW4xTE52N0JVOUp1aUpwdXFac2lhT0RKK3FHRWFpbGxNekYwL04wZnlJV0NvTkROenhWenppbHJyM2NrZ1NMNDN5T1crbHd3U0NRYVJHSFl3Smg1bm1HYTRCbGNuSFl5dVFvVnhnTnVjWDZUV0RhTUhobDBZMXJSRW10M21CVUhoKzIzVDExT2psdSs0QSttVUtRa2E1N0NJVmN6c29DVGtCR2trTlZBeGZTTTliSGxlTEZrWXNGVk80MzJPVTUzQllWSmdOSjM5WFUwVk5FZXpSZzNMeFB3OXkrYzRoVlVVaDU4Q1htNWFUdVpHcWdPYUpxcU9hcmtweTNBVmxjclpuS2JGUlZKb1NzNE1YRXR3NWtLTXRETG9RMHRFQWdFV2hPdEdTWnNKM1BaQVgybnVwbUZ2aWJDeFIyQjE4VnRtSmVCdkVMT3hhNER4dUVaa1grb244VHlNL2xJVVcwL1JHZnVYTFVua0Rqc2VTam0rSXRtU0lyYWVOY1pTb1BjUmxNT3MvcDVRYWlEeEE4azQ0dUZ4SklQbjVrdnhPOWhNVFFiWUtINm9LaE1LVHJkZWtDaHZSTDhYMlExUzlEYlBJTUlnVlJXcHRZWVRmN1d3c0xKeVpua1pMYmZ5aXJRRXB4WVVxY1poY3JnL0lOc3JjTjRpNXFna1phbXRTVnFvenErdExkSTc0ZXEwY0VLV1lhRHM3TWtKTUwxdjEya0M5R2N2aGxSMjZWdzBWUy9vOFRTdWMzdHNQa2piYzFPRjNNL1ZqdkJzcGJKVXJTNjExczdiaHYyNnVBdHBRUzdzbzEvRzBrQVY5RnkwbDBhYkMraW1UU2hWNlFSamJnYTA0N3FIaFp6MW5ldzVlKzRjZE82WnF6MWMzQlpGMXJ2OElPbkw0amN0U3poeTlUbDc4eXNjNzVIc0RrbGtSVmFUZG1TZVlmb3h1UWJQR1QvbGZGRlNDbE5UZTZlbXRvaUg4amljMnp2VndTd0R2cUhFak5QWXRxVmljNVlLR20waEhKYmROOFNwQTQ5a0tTZzBhc1RTc0NaRlFBQ3NmZjJraGRMK1BBa3VNdzlRcTVQWGQvaWM2NWNXbDFiUHR2SVA3OFhjKzk2SFQ0UXh2U2F0Q28xTXRaU3BXSk5ZVG9FMDNpeXNycTR1THU4MXpiM3oxSTZjNmtmV2NaLzlXTGRPTFl6NDFSRzVPM2psRk1tNE53NVlSd1R2Uk1paVFZdkNEaXowNmRpQzBIMDVRcEp6TnorT0x2SFpleE9GSUMvalgxQllKRnNaLzJpY3VTMU9QUDk4T3dUcHJSMVc0R3dudWRoSnJoOE9Da2dKQ29YZzlHbllLcWdRSENaeHhiWThzZElKampvWE9RUUlYT3RNVi9wc0ZET1Y2L1NOaS9DM2xjRTgyeFRSMGpSbmUwRDFnSnZFTTlrWWNncU5lcE9pUEVaK1Z4VUxOVjBpQUlMUEhYcFhubGZieXJDWXdQTjVsdnNoV3Z4bzY4ZlhlaGxXUlpJejdZdzVkMi8vZ25UUlQ4YzRoUnZZUHNEZGx1ZDU4WjJSK2t6Rmw3Ulc3K0srMGZxeHltYThhL0VsK0lycDZ2WXZYQ1FoZFl3amx5aWhqUlg2TXRFQnVwamZIS0lyRTkyOVZ5bzBDcVZDTDI1cVlTT0tIUHo4dEhrRzk5UXpadnJyWjFxcnl4bVBMRVhnemRMOFBPNnFaMHp6RE82NjYyY0lYaFArWnA5RGNrOE1Qd1p0VU1NMU4rU1VObG8rTVcxOGRlajFuK2c1YWozU2M0amtDTWlkK29PYzQ0aUpjQ2pSTjVteklaMU1LZEk3TlRjczFLQXFIYTd1cFFOZTY4TjB2MFozR1hveW5KOEJyK3BwNW5FOGZ2WFUzOTFRTjJsRER0Y09YeFN4NUlzOU5WVFBjZFJYKzRXZUkxVHRyVDZNc2M4eFMraDBWUGYyQTl2b0trNlVtTitra21mcDdsVFlIRStHNWdvOXZpSFR3QnNpR3Vock1EUlk2QkxGdUM3b0NtcXBBTkhCNGo2QlRhVlIyRUhKUzZOdVJpSGJaK01CK3BlaGsyclN6bFF6VmtxOWNUaldqZzRFTGhmc096ek5UYm1hcDlhUHMza084Y2RURmk1cEo0L3ppTE93b0hzOFBIOGNNQXZUdWNzVVg3VnQxVmVPRnF4NDY4ZWsyNHRCNngrSUFNZWgxemlTWVVpT1BMS1haZmZpSy9iUzBudnhqV0w0aGhmUjB4Zmg1L1RvZmx3OFRtd0hQVndUMUd6UjRFbWFZTEFTUkRIbW9XSGFnKzU1Z1pPL3VEc3VtU3JBV01SM0MzRXYvaEtXTTJVclpjbW1NT2VRRTg2ZFcvcENQam5xQ0RySXJicmdqUEsySFNCT0FRNVg0U3Y2OVpCL3ZmNzR1ZnhMdS94b3hqYksxSkxmOWNZd3orODBndWg5OWNZeDlJb25GVS9IN2E5N3lzbmlhK0RWcE8zazNiMnVMdFdSN0NWeTJPNlhaa1phNjErNDNsZHNXL0d2LzBKa2Q0VHdtQWI2MWp6K1p1bllKVkhGUzYzTkJYT0JWSkZBdllsK2FKcXJlT0I2Z1RIQlF3eVJCZXZWb2RYYlZyY3R2bTYxK1J2NDFLb0paNGZ4YWJyd3ZZaFAvaGhPVXQvSDc2SmQrSGxId0NOK2tsaWZRRGo0V2VyNVVtNjJrM1RaTUJSOVFCZlpubW5Gam5JN1FxTkJPeVdrOEVHOGVzUitrSmVRZ08vN0hwWjlORXorcW4xa0p1WUpNcEtSSUtRU0Y5L3BEUURWQWNzUnNKRzhOenQzTkpzVkJDMG5DRWhvakF1WWJDWHRDM3hTVUNZYVBMNG9LK0pMcjlwSHNhSjlzdHMvTWlZaEl1ZmllZUZmY1J1K2cvSEoyOFN6MVM3VWhrMEpNY1VGQWdvYk5tY1JWaUpnZWtBL1d4U3Mxa01FS2VVQlMxamtXenpPUU1RMG9QVVFaS0RFVFlJb0h5WlBQQ3lMd2syYyt0VU5PWlNHczdoUHJUQlo0a0hXZGdKdTA5RWxmUXR0SDQ0MlBWMzZOdlN6ay9oemRIbSsxcnFWRVBhaEdvOFBWZTRrcGk0NmhUNUVTTHkxZlFvbFR0SWtCZHlyMG5LNCtGZTN5R2RDKzUzbjBPZER2dlNjOWp2dE5ZeEtRRU5tMGs0eXVOWHFzWjRjVE9LLzR5S1MrRkhjRFNDTzBxd29iZW1XNTBEcDVGZE9Rd0NsMHlKWk1PdU1QOVRYRTd3Wnp6T29iRTNsMnBaanladTNvSFJwcXdIazJHYTB2dkE4bmlmMm9hOFNlYXZDMU1EcnVwZUV0bkdlQTREYm5CaHE5U3VDaStjS04wN3E5ZU1PRWJJd0s4aVhVOXFVUWtFNUs0dXBHRnFQcFVUNStaLytBSXNYUDJCNXJsWG4rSDliQWpxV0JGbitIQ1VNdmNUV05MdTFhQmVDb0dCYjZGYzRyblVYSjRxUm5lTWE4Njlodkt3cTZML3hEQlh5dkJYY3FHNWJkMFpRRXVPQjJQYUNycENxL0FZNFBndjd5WGFTNnJrT1g1OHFJaDBaZWFJQnl4czRYVVFya3JnT2hLMkxVbXVkNnFiUVFpbTE3bG1GQ2FxM21paFkzbnFxUlAyRU92WlpZRmZSRjRLSlREaUNGSHJqME5Bb2JTY0F0QWJtVmEvQUhUdmd1RHRDaTZ2VzJWZDBXV2pkd1hFQnI2TFRYUWNjUGYrdE83cE10T2c5aU94TzdjVjJ3RnNNV1dOb0lVeU1GSG9Dd1VjOWdKb1ZNdGhRQW9FaHBxQ0U1SUlwOUxQWHp3cVdKQURzOU94OTl6VW9vclFsekw3KzlRMXhzL3kxVGN1SWpkNXJPL2NNTVRCbzI5MFN4ZU1LQnh4TWl4UTBaN3JSMjZnRUk1RXp2Wm1FOTYrUU03MlpwRitRTzFYQ3lJalJLdmh1OUxhM29kMUNCTmlkRVNRV2NsaVN2SkF5ZC8rYzEvV1gyY3llcnJjS2Z0dGNvdHNma0lxUlFiSFBFSTBJaVkwZTVGQjZvc2Q2REMzMldJbTlwOHNFalpqYWRaMzd4MjdUc3JkM0YvemZXOStENlJuLzJ2VnlHaGRhTC9mbnJGZitIUFg2KzU1elNOK3lZbjBsKzJyR2h2SW42Q1oyMEY3YkozZDJEK21VbjQ0M3lYRFV4dXlPSU40N3cvcVYrRXZCMG5ZWUlCcEc2NFJnM1EzZlQ3VjFsbHBsSW5zYWZ6dC84cDFvV0xlRVJEU21zMnNDTGkvK0gwdVl4dEl5c2ZWRWRyV0RBYy8xekVXTjg2L0RjQlNRUG5MUWpPanRGa1ZUblRtSW55T0VybEE2VjRETWM1blZBRkQ5OUFvbGM2Vk5aUytOdXk2TVJpSTlOOXQwU3AzT2NnNWE0VjF1ZjVTaXNEOGFmcFhucHBkK3hJOVNBUGxIdDRkZmNkUVhRRTgxd0J5Z1kzODQ1SVF3TkUzVVBTUlpBSUxhMDEzQTliS3Z1NVRaZVVVc2lETEx0djRQZlNDS3N4ZUxpaXcrSnNydjZieHlOQmwybWUrM093VDZEQzZpaUJmRGxhUjIrRXBXeGpkVDVPL2hrbXRSRzBEUGlhcjdIVm1NNmdIckIwTUU4Nm9IYndNUVRmRUlXdXNHWVFHZXVkaG9CdWp2MDhmU055UW84SHp3R1NtZm1EdW9TcCtKTW01SXNhMjM3ZnowVHZUeGRQcUdnQUxSSno0anFRZm5Fbm5wTTFIR0RhbWpyVGZqVXVFNkRmR2Y0L0ZzV29jMkxVMnl6V0FRMWw3QW10NExrU1VySlJNYzNrSFFLVmRDME1rQkZLNTNlSURPU2xmenArT2lGR0JhbmVGZEtmV2hZMjhzRlpycCtiSWtqUjA1ZW8zbjVaR1R2SGlpeXJHOHo2dHM2N05oWW01ODhwcWpSOGFrNnVCZCsrM0NaQ0h3aHRNais2N2haNDVVbmo2eWUyNm9NbnFSbHRJdUhodG5KNWZHOXZvSGVBWExzcmliZkN0TVhLYVBqMTJzcFl4dGgwVjdzbEFJeG00ZUtNZTJNMHdZSXdlUEhmZGhtWFFhY0UySUtCNVdpeHJYQzRQRXM1U3dNWTNwTHZZbEI5Rk4yRzJZOHM4QWNWS1VhSzNqYW9XVTJpU29lMlowWDFCNjR6Y3hnWVFPTFVxODk4anVpS1RjSUEzY1BsbUs3U2p2UGhLTkVTK1FlYWlDNWVVSmhnblZqM0VTYnc1dmNaY0YvWFVqM0pKUkdQb3Q4cWVRWDlIeEtQbWtrb3c5Z1greHBQSUUvajBaNG03KzRjckNpaVI4NU5ka05tWTg4RjdZb25ranhzcVB2QUZ2bFYvN2FBVDRpWGI5NUExditNa2JOcU9GVGdVQXVVdTMrTG1nR2ZmRExmbnFZWXhBalFIVUNCQ2dRSDVSVGNZK3JRSXg2cWM3eExTYW1CaXdCT3dtcDdYV0prZCs3S01SOEdUcnF6OTU0QmQrOGdDMGpVTDArVXhmbk9KN21GOWcza1RpSmJhdGI4azQxYWVERGZyc0h2Mis0MzQ3eWY3emJnTVl4YWkxbzlHd1JEWEVmaEVWR29VRk8xMHFwV0dqRWVVKzJhejJXL0Z0R1dCK1dhL3F6bE5PZ0ljUnhzdkVXdDg3WTZxSmRjUzhnQmswdEZoS3Q5Ymg5aWlmTGhGRFpwaG04ZmF4VFlJVDM3cEpIaXFQT3ZnQmdkT2kwUkx6VnZKRVFqVVhXMmZYMnp3OXFwTXhkSmg4OFpWeWFKc0RDK0w0Qzg5MWFjUHh0OEIxZVB6dThFV2dtY0lTUFVRbEkyYkJFMVZSVCs2NGZFZFNGNnVpVWZETHFYeXFIQy9vNzQ3bmN1TzUzTXVxeElTb0ttUFpFaW1DbkVqSWdvS3dnSG4zdzVhV0tZL3MyREZTem1qVzIveEtNZzhRTWZsa0JWWGh3dkZjYTIyQkxCY1o4dHNFRWY4VDNpWWJrZTh2Mko5UGhiNVJVb1hHOEpYQWM2UTVTLzN1eVFjTnVwZ2NjYW9GRDFicWxDK2h3VWtXbkdmQUdaTEVaZ00zVnFMSmtjUzJMcFM5WTlmRWRWaUFIK1Q1MXErYmc3cVptTnFiU0dmckoyNGZTMlI1Y3ljZTRQSWpoYmR3bHRpNktsc2ZpY2M5WE1nS2NLRy9uN2hpWklkZ0pnelBUNkFhMVQraVJYdzMwZUphVDVoNndRcjJUZ1daZytYNk5iV1VtUlVLSS9sbW9iVFRmRE1uREdKMnZiVVNIMjVzci90UndXY25MeGQyakZoSnpaSFZ3MVR6R1dFbVBJam44R21JQTQrbVVER01IK0pEbkFmSmwvekFEMnBOV0FjbGR2Yk4yaDUydHVOVVpMRkZxZGpBdjBxamh2OVhBUDBVLzIvV0Fud1kxSWppTVlqNzA4Um9oNVh2R05VTzRWN3Jmc0JPSGluSmN1bEkwdjZBbXdtY1E5cm9IZWFRblRJc3kwaFpwZmhTSmJsWUhaNGJVR1JZNzVLVmdibmg2bUt5c2xSeWJZSGpCTnRGbXU2Y1FJcWg1T2Z6cGQzb1hyUzdoRlA0R0oxd2RFNFdaY09jTkExWmxHNDI3SHRQSDFhYXRpd05TckxkVkE2ZnZ0ZkdKL0RFeXVHUm54ZkRHRjdFMWdER2ltazhpKzNxbFcxSS9OUSsxclkzempDb1dTcCt6WFhJYWsvUkFiYjJjZmljOEVhUEV0SnRrWnJ1RzU1NXBibDhqRCtsbXF0UFowS1JRN29rRkRmdzVzbldaeU9sSHk2NTgxanJETXFiNnFuV0lueC9haHR6eVNFb25DWE1BVXhndXNIRDRGamJ4NkJyNktrRVJiZmdVT0JmcUFIRTc0QllKd0grUWRTSGdDelRGWDFKaE1DRW5lVUZmQXJkZGFXSnlRMVZpOHZIamkyMDFoZnlWVXpMU3A3OG04L25XU1FLOGJ3ckRNd01DRFhEZGRPdUc4dm4wUTFYbXUzdzg4YzhVb2RWMjhaVlhnaXZ5Lyt5SU9Uek55VXE1V1RKanR2NDd4TjVZcmZjVTc4cy9qcDNiVllyM084NGgxYklxWUQ0MjE1cHd4SzBIMEFIaFFDcnVPZE5vdDVxMUk4OXN3bzFzSVFoMnVCRGdqVWlTYXFTMUR4UFN5cDlwTnZIV2lmUjZpa0lUSG9NYzNCRGtqREh5ME9ZQzc1RzhpUTFKV3YrZGwrVGsxMDRhSlR1bWZOU3ZXbUU5czFJVFc4U2xuMUxJcis4U1RCMmNRTnRld0VYL056MEVhNnhGL2hsdHR5a1JpY3daQlA5VElSOE00QWtHaDZ6T1EzTGRKdlY0Z3VGQW9zNGg1TzRiUnorazNBU1haN2dSZFJFUEJmdXJ3enoyYTZ5VzFmMU5ka3NLNE1sOWl3cnM3TWNUc2x2QXQvY0ovSE53djMxTkp2dEt0blZ4NzRjdHNjWXJFcWU1MjExeGE0UEpBaWJFT2xYTjYzc0czcEMxTGVEekl0SmNldnEvS0E3TnIwYlhZTXZjYnB4OWlLYUQ1eVg0aUx3cWhVYThZSklod1E3a2NRS293Ri93Y045dHJ3cC9jZXlFdWNwaW1EeVVsYVMrTWxKWHNJSnpwVlpWVEE1bXFjVmVXbnIycHdWaCtLdWxoRjE4ZEpMOFdZd0p2cGFDbzZjWGFLK3lUdVlJS2c5NTNrSElkZlc3Tk54YmxxRjN4WWxZVkNRUU1FNktVckhxRGY0MXZUKzlCVG9EMDhKc256R2daTEJKalFDdnVGNWFDemhhYkF0anJWWFFqY2w4QVZtSFZTREp5cTh5bGVxZEExd2EvcXF5d21PT3pITThaVXpiZjhIWWx1RlpmQTFabnZYS05tbGlLRlFuR1R1SGd2eGI0dmhOT0FVOEpqZnFRTG13ajlEYVNTT2VuY1dlSStmY1Y0Q3ExdmJhSG9LYU1aMFJKTUJKWFdkOEs0WEtjb3RnNlpua3YwNm9YZXhVNGRqbmY3N0lJa0ozeUN4eTVubXhtQTVmYjRaWTRESnQ4VjhCa1hYaVUwQ01VU1k2MHErYStPMEJjUi9zNzhjU2Y3K0pqTVZyc0ZtMzl6RWVYdG9uNUp6MC9kT0FnV1NDSVJidiszVG5VQkdUT2dUMmtYSEx2ejFIMlV1WjY0L0x6MWxxVnhwUVBnVGtXQkZFWVFvc2hMY2hDQVBkUWtud2V5L09lTkpaWHpVQk0veG1sZ1VnYWZQYlQ1eGxvMWFVbGNGTnVheG91SFprd0pTZmNPTzZlV1lPUkJvMytBRFhzRWMyT1VDeHdlNm9jZnM5TDJJNVNUVnRHUG5xTytLSVZsNU5Hd2FpcVM0MWNsTUlpNVpyR2JtZUlPVEZkTTlySHVjcVVqaTJxQ2s1Ti9xRlFPRDB4QmlXUkZ4d2lidjZhTHp0b3ZmSDAxMVk2eUFUU3VQT2J0ajVLMGNnN2ZUVG01ZHNTYzJsSVhrSm1QTERGbkpPemZWbllCMVlxWG9tNGlJbytIWDdXOUs3emNsNFVDbVdJaVZKQ1R4U1VHYURqVEQwQkpiMDdzVHM2cWw3SVNwSUREaXZONEt6UHJQMDc1Uy82SktIeXAxc01XOE9RY2VXTE96bU1keE9OaHpmY2RiRTM3TjVoZTBqM3V4YW1rOW11ZXZSNS82ZWxkYnQ3b1o5VHNhdW54SzFzbW1JWG5lMXRUK2ViMFVsdFBsVWwyV3RTVk4zdGpPeDg4LzNoRGJnZW5RU0JHbi9TZ05FVnZDQmNGR1Y3cTgrWmkwSDAvbHFvb1NtSmszY0ZMWFBaeHlCSmt0NEgwUzgxT1lkNHJoTHBRUVJGVEVMM2JybWowajhOUFQ0aWxlRVBqYWxIaWJJQ2ppYVRnNHJNaXhRNUE0TFNvZFBVS25ydWVwNmFaVWIwMEZHVE5EdTRzbWM0aDVDWE1iOHpybUxjejdtRStDZHFyOTVSZTZ4b0JRSzlRZUF3cGRvd0hWVnZXdGJUWE9jeXowYTVaZTVQWG9XWm1vWkZwclpDZkRaRXh6SVBKT21OTjYxV1lxb3M0R0pTU0JSSG5DbTFQbkticnNRY3FqVytxczBadURGbkRqZnFOOXpkd21xZWZJeENhM2sxc1dCRDNkbHUvbzkvN2IzOUtXNS8vL2VXdjVycWpFN2MybTJzRC9pdmUzS0VpaEovTGloYnhJNEVOL24yQmJ1Z1JmdkRCSXdkcnhXQS9hYU5DbFNYNmxVU21BUFpPZk5oOTE1NjFTOGxFei9mVjV6R3lodFV6RmV2U0p3Sm5TK0pUN040K0NJZVRaNnRvWkdzZU9ZaWdBdjBnd01FRE85SXV6a3pTSUgyVm9LS1lqYm4yZittcTJVYmdiTmVLNFNWY2pJOFVHNkQxb0NLZ21PR2crdHFKbzJ3VTlXOHFwVWpFUk0zZzU1bktHWlhwRzNob1lNZFVWMVJ3WkdOYVVGYzF4V245TDNWMnVXUVEvd2NlWGx0Q25FOGpVWXdVL0tNYVVqRGVvdUpLczVFMkRaOU55by9BZjhPcWZLOVRsdEc2aUJHdHFwelN6UWIxd0hsLy9ycGZOWE9kbTJwZ3hsRGNlQlIyT1c2ZlllSkc3aDBoNlZ6blNScExsaGRCcGhBdFJUU09iZEpMWkJGY21lcW1KdnVuNDRvQ0F1YWU0eGt0WXJrbnA1Zkg2aVZNbjZwYVJ0UEpGM1U5VTlsWU1yWDY0cmdwMklPbUs2dWxOM2RQMHlsNzB1R2F5YW5XeVZQYUhYTVVnbm1zdk4wMDVmZVZVL1VRZC80MlhjMWtubDNleXJaZmhtOFNublRsd2FvdjVScXJpRDJFUnltcFlpVVIyRUorTGZPcm5TVXpDR3ZHMVBZb2xnTnBHanIvZmJidC9YUkcxY1RGUXdTa1FpMmtIZ0Y2ZjNzRFpReElkN1hhUDJ6bEtzTEVSRmdoUWZwRTYwcTl1RUI5SUVqR2JyVEFTZTk1UHNEeGFCQ3h2TmJUWC9Bb2pNaGJqTXpsbUNML0JhVHlhdlpKNUdMOUgzQitseG14UW5rTEVYYW5pendhTk1saHFFdmNrekc0M1JLa2tTajUrZnczQU5weXQrSEdjQnpwbEVCOGlOeDh3aUpQRUtNQkJ3eUd2bkx4aUtWeENnMFcyZ0phZlJGRnhZbElIcFFqNnhxbzNyQmQrengxMFZUZGpyVlFLNVRLa1kxbHJKVDljTEtGVHBXSm1YQi8yS3E4dUR4WlAyUU9lcnU3YWwwelptVUNMV2NNRHlUeVI4elFqNXpzcEZuR1ZrZWpjK0pYcFFqbm54WTJhR2ZleTJhUWJIQzUwSGFITERuS0dkTUJQY3Bxd2x4TVZMbldBbC9hcDc0d09MOWY0Zzd6MmJsTThKRGkvZkVBeXVJUGMyL2Fwd2tIeDQ1S1NkTTdxdmpRc2NvckU4YkpvWFVFV014NlI0b2FmUVNqaGFLcEZ6OW1HckJFc2UxVXhudFdNS0JtdWs4TDdhUkFVNUU1cjBvaVFCS3EwRGNReTIreHFUUnFYQVN3VzNlNTJGZkg3Sk1YYTdZb1dySmdXWk94VWNxVENJVGJsK0RtRHJ1cmtrd1BEMGJsOXUxVGRHN0F2dXRKTlpyTmUzS3daY2E5d09PZzZ5cFVMYWJURWM1TENpWmFxT1FtRU1yNFJsMW92aDFwZllZa3lQVGNzK2ZwWko2bEltUmNZUTFGSlhRM3QyU2lwd2RvRzRKNDloYjZHeDJNaXM1WXFtOFQybFNLVE1NRFl3WXdoOFdFZ0t6Ry9jNC9Ybm5TOGUweTVra1l6NllwOHBQVW5waTdkZ3llaGV5Ujk0c2xQZGlUVVR6NFoxQWVMdFhKQys1Sm1mdktUSnQ0bFFydlhmWGh1RDRpUGZlUmJVZWxDdXNlUG5VU2xHZzJzVmdEK2xhQnBOQXVzWGMxNHEvUDA4MXZSNDlLQ0lxWmEzcHZuZndOL2dzOGFjWEVQang1dW5iNEUzYjllOVRMelZMT3VhOHRXTVZpYXg1KzFycDM2QjF4eWZabU1yU0dQNFFDK0FDcDJFMER3SDlwNi9DQ0VqRUxQcklXUDdnS2pmL1A4bndDSy92eDhwTWJIbTlaWjZxNktIL2tYQUxwSGJjcytqejZHNjR2RnBoSkhscE80dnNXRE1kU3NCWDE1eFJMdVN0TXdOS0IzUDh3cHN3cjNjQkphOTE3WURCUS9Xc3kxajFvL2Fvb2N5L0d6RG5xTExMZnVrd1JTRW05T251eWszL2NoMTlaMC9VT004TUpQWHZnNituZjBKSDRQT2Z3bUpwblhrN2dxbFdLWnVsTGpyb3hmTzUxQ3dkaThFcFR4bUFTTDJvSElVWmZEQ2cxVDFERXhxUFNoMzNhYkdteVc2b3JuaHY2V3c3UFN2bjNMVngvWFpSL1MrM0Y2UVpkYlJ5RE01ZTJUU05oOTRoUFcvZmgzOWVRWVpIMUZaOWxza09GRVRtUFpURHhLWkZoV3cwbThsOWplRWxtMnV3U2J4U1hRTDVvZUgrUEZseXpjZmV4U3crVVJUbCs5Y00reDFwOGlibXp5ZG5UcGJ2UGoxenlBZndoZkExbXNobStialVjUENiSXNmb2pFWnZydmZZNFNIQ08rOE5NWC9oVHpSWi9ITTk1MjVvb3dralQrRXNCM3JETEpGbUdGa2M3ek94REJTRzdPZ2hWNGpiNlRHc0NRTnV1a2Z4Q00xcUJpc3ZDSjRsNDFoWXFUb0tBbjhPR0JDOE5UclZHczFObytJR2o5QWZ1dGtvejBBN2Z0bUcvVzkwbXlhUTRJY21OMDJOZlRyczhpbFJ0VHBmcVFHMGlxTFBMSS9iWW0yclpuRHFlR2REWFBhd3BpeFJ1bmZWc1FaMGNtNnJ0ZkZwOGNkUWVVVzVmRTEwSTBTSENFV0Q0V1E1cTQ3YnA2TG52VFhHT21XaEY5WDNiOXJCMkkwMFBUQXNzaFNkQnRkV2liNGFiTU5Nc2R2b2NickNZdWwyMXVhdURpMHZobFFmTGd0dGJmQzJ6Y0djd1B0eDFMeUZvRjhTWE1rWWdyZ0FtMlNEQTVwbERraWhkK1BKZ2ZxSVVnMDdqSjRwQS9oVHJvRDdpQkJpVndMTU9qSFF6ZFFlZU0wekdIYUJzZ3JRcUFIYkpDb21qTUxjek40eDltK0ZZdVE2ODN0VXRDOWV3SHJqWEdhOEhlU3hPNTF5dFNhdndnemYzWllyaUtENTZHdDkxaDZMOW4yT0NDNWowRDY1Znc4MHRvOXZjNGpsTjJ0cjVOdGJlTDhaVHhobDN1SUp0NkxjMllEMzBkRjd2OEt2bTJYWVdKUjY4OGpGL05Mbk9LMlhwRmFnU2xEVG4venhxMW8xalQ5Sys5RDAzU0krWExjUFMvVnpzR0ZCOVRjOHI3ZnZhR3hNYXNhQjJ1NDBjNGdmbTE0K2YySlpTbVp6cFdNQ0UrMjhhOGdLZ2ljOUIxNDJDbHNvWHJJV2ZxaW1tNmhnUXhZTi9YZmZEZXpNSkNSdFpUaWp0VGl5a3BZd3Z2eE5PUzRacW1vcHNrSkhQUHdSK1YwK215bnVEMXBPTWtkVDZCKzl3TC8wSHErbmtzdjJSd0s0K1NhS3A0bENSZktCdmtXR0FJV0R4KzdTRkNSd1duR3MxNEpmQ2xLVFRyNGpHek9jQlc4S2lPQjBYMGZlZlFJbWJFNTErUzlkdXB4ZnA0OGxBRitZS3VIcHFmMnZYRnFmbERhdGxzbEZEbFVKS1BqMTAySG1kM0lLTjI2YWp1My9MZ2ZMaC9rN2p6V0x3ME5hcCt1eEdmT3BMeXZOU1JxWGlqM3ZxMldOOVRpaDlkcnU3YVZVVnUrSzRJUHZ5ZG9iZlVKUjM3M0hQck9MdDh5TUpFc3hDK1ZkQVMxNGlkRTNtL0labzh1RzhVWVVlUjNoQ0RlV1hpU2xnRnpybWRQRXVYVUk3VG5kVmFKL2ppQnpLMngxL0plM2JtQUJ3V0NXUkp0Ymc3TVpuWUhSNDhzK0ZXa054RkYyOFc2RzZaQUpEYmlzdHpua0xSeUtzRTJnU2M3RWtpOGtsK2l0Z0FUVE96QkxzTy9FOHFBQ1llVFY2NEZ3WlNmNWlxUUl5M2d3Tk80OE5tcFVsZFlZSm1nSDRZcUJsamxoZlVoRmt4VDVrbUhLcmI3SXA1aDJtV3pHRzhzN2VwZ3FpbWpKTHhjck4xVmVtTzBpY0Q2MjRydUMzaDNPMEV5RXFvQWo5clpOVEF4SmNQNCt0RkFWK1ByeHZHMStOZEJWK1BUeWNOZkhtbDlTLzQrbEZ5L2FrQVg1K0Fla2t2UEkvcnRTL0VXUUEvbmh6MVRzUU1GSzVKUUF4V3dVNVJDakNyZ3htTlNrMHFCclVBNy9BTHhRTDRxZ1JSUnBESDZSem1kWVNUZkhMUC92bzdyNjEvWmVlMituNnZ2dC81eWswTCsrdG9UWGlQSkxVK2pWbWVxeVRwUFVKMUVmNVZWMWYvN1lwVnlsT2hQRnBnWkN6MU1HMHIvcDRSWVNVRVJDZFlQNWZDQnVVcGxtSTFQTDYwSXhlQ1Q5STRsdkwzWS9rWE9QVWlET3BFaktIdVFOMlIyLzJ1TUVsRXpBOW5RZWpwQk9jVzNJd3hOVndEejRpTm10OGtYdnlOR25wMnAxY2Z5aVhqNlhROG1SdXFlenVKYW9ZS2VLQ1UrVTZRMVJRZHBOeXJYNjhyV2paZ3I4WUh6ZVhWenoyN3V2eit6eUU3a1IrcU8xYTViRG4xb1h6Q1ZKZFZrMEF3THBDa08xZ1FCT2ltZ2xBWTVIQ2l0YnBRWFhobUdmL0lXaDM0YkhCNFhrdmlNWVlCVFN6bWVBT1hCTXNLcFZzaS9qYWxDdnFacEtpdHZLcEkzNzlEdDJtQWRsdS80NTJmK2hUNnVPeTZjcXYxUlZzSFJrKzN2L2hQYTJ0RURvM0c2aGlUd0QyaXlJeGdUcTlPb3NiMyt0a0V4VExZSmhabks3VzRVRzdXd01wVkFwNUR4R2NBV1Rpb2lGSnhOK0pxY1R4V0I3UE5XbThRckR1djFCUER1d2R2NFBrYk1CMDhmd2ZQeTJZK2J6NUNjbjdWeXVldFZ5VDBLMk83RjY3VWtzTzd2NVBVY0xyYkVXZDEyNlF4KzlodytLOTYwZmo0UmNzNGNRSVN0MDF1RzVwdC9UdVUyQWZKRU1kdURhM2kvcjZIdVpTNWpqbkYzRU5pOUxMQU9VWEFGL0ZlL2hxR3Vob2QrYnE1N0JEeWFqY1p6QUMydmtoajhBVWVjVXZEc3hHMFRQZUIxSDJBVnBzM0xDMXVSMmh3b0JCZ1VZdklQb1ZBVkpRMVdSV0RBam5HUWxoUXlBMCtNM1prckpqNzBrQng3TWgxcnFuWnZCRm9ncW92ZEtYbnU5Sm41MjZjWTJkdm1KdFl5RzBQQ2dKSDlYVkJnUlh6ZVpFdEJQU1lFd3JCanN5bC94TWl5K3lMeC9kVmNPSWRwcXVydkJvWXZKM3VKSTkya2t5MFRreXdBRDNpMXdTeEY3aFN1ZTNNM0hSbnk1d0VGazJWY25PNm80bnAwc25NQmtJT3NhOHpSWU43c1BYNjNHUXBqYVppQS9KZmN2d2Z6ZkpxNjg4Z0d2aGhHSzBQMDYwbW81T3loSDRQUytkaTY0Y1hDK1hjYjZmS25vMStYelJhbjExU05FR21BenpacGlVVjdXUE5VR1o4RVAwU3NXYzZCSlJPRXhnMlVPUEJPaVVXMTBPYjhRWXhWSU54MlNPbXVCU1BnU2pKaU5LRUNoOFZFWVNQQWNUZStFSSsvNElWaTFrT1FvVEI0dmtxejlzQUJJRnErdEhtdzgyaitpMzQvQ1BhaWNiWVdNTlFYMlhuN1ZjOUVJdTFXdmlIeGk5VDFjdjRaQzdKaTdMS1d6R0x2eCtXTXU3SFNaTlg3Y3ZINHBZVkgrTXVHNEF5WHpNOFdiSDNEUXJDb0M2S2wxeUNmeHRzK2pmQms5eGdMNzlKUU12MjFCMU80bHRhemRkSloxenB5T2cwZVU2eitTRWk4VjkvZlZ2NEo4bFFQNGszdDZLYk1DLytTc3lEOXREVDZNTTRBT1BCemZMNm5ZTWFZRlFZeDI4TFhuQVlXR3FEcEl6YjVjT1NjQWRRazA3RGxpWWY2VXIzWmFQN3NnSzNuME04TFB6bGlKYjY0MFJmTFYza3d4NXZma0MyWkhQOTlaMTBielpLY2NSUm1lTnlYKytJMVlnTC9Ranc1dVhvVnFiS1BJQkhvNjY2UmREeHhFaXlUQVE4a0ZzSW1udzhRaThUL2pNYjhNL2VEclI5RVUvcHlOUUNJNVBYM0V3OEg3QmdKc1p5c2w2NGJudkdHYzFxc2RiVEw2NGxqNU1haTd3bTU1S2VwM2x4M1IxTzVubkVXdmplaGo3UUdLbmtZMWxYY3dvdnFtSGIvZWwyM0orbW1Qc0pjZ0NNc3RSYkhkUnFZTDFIWk56eUhyYlhSY3pDVE50L1p1dXhwL1pNWmVzdUJQbmpWWDZnbUNpWXNVRkg1aVJPdUVoOU5SRDlhVUZpajVXbld2VVgxM2dQamUrS3h6aUZDM2pFWmJKanBpMWJrbmhNUTJGWHdyenJDV242OWhmWmNGd2JTd1A4S2JlZEMyZUhzTFZkZzhZc3RabXlrRjhndUpwTEc1R3VNVytSVkY3cUJCK0JBZnhxM1dOWjExb2R6VitON29uSDNrY0NBUFZqNjV5UTVTTW1VVHRhV0xaS0hWdzA3MU55VEdSWFBJOTV1aXlNZElDbVV5eEVuN1pFR1I1aU5vdGZGYXp5RXJoTm90dW10SVpPcktFdk00RzhaaWZlcmVaanJXOEZoYW5DMTJKM0RkVUx3VU04ZjNLOXV1eVl0eGpHUTV3UU9IZFpDVEVoeGQzL1piZ0NoOHFHOUM3OVY3OW5PNFZBTGt4VjYwTjRPaTBmZm1Cb0tXRWxoQXF1b2hNNDVueHN3RFZrVHRDK0YvTWp2ZWthK2pybXFDSGVKZmhPU0NDd0VrZUdNbzBjRXc4cEpFc3l1RU1Xd2RJMFhHV2E3V1pFem5YZ28zc1NGYytZbXRMOGNzSXFtSEhaZnAzcWZFZDN1Snd3eWZMcFAzcU5wSGhTV29ySFhFV1NSRFVXVTBWSlV1QklsQlEzaGk3VDRvT1drTEJqZ1dBTityK0F4UWk3R2YrVVlXcS9HQThleW8zOFQ4ZDUzYU5ZUWxMTGlxVC9pYTZvK2dmZzFYMEpVazlDNmtPUStpQ2tqaG1Lb2tQZGZ4S3V0UldKTGZna1FjSEJyd3BpWWtHOTRkYzJJeUM2OGNDRG9adCtxTE1VOTZoTVFJUFAzUUFOVXYrWHEwVnZiT2VZNG1wemN3bHRMbUdaVFdVZzlzZEJTVWl6eVdFSHBaRXEvYkVtTkhuTUh2QWNPeSs2R1hFSHIrbWlta3oydFFWak85eUpnYkd4Z1JzdXl5YmljOWwzdXRYa3pYWXNHN3hPa2cvaVpubzd5K0tVY3JOazhuRk9GVDVoKzZ6MVljeGMvNjV0R1BidlFodGtkTndHR1VoQklyUk4rRExtMWVlWTI1bTdHQ2FnNndQeFdib3NRSmNSZHFGdW5UcEFQVXZURkl5T01QUXpzQ2pYaEU1TWZJYUFLK2xNRFUyQ1MwZit3N0JVTVJIOEFjWjdCSUQwcGNGcFhiVUw1bkJORm5TWjQyVkgvNEh1eUpyaG1wS1YwV0pUUTdvMlBXajZzbVhJaGhsVFpFV3dYRGtXZHhTZFBZTkVYbEY1TVorVkNxWXhwUHR2b09xMStlbkJJVlprWlJVMUp2MGdhU1pzVVpNNXhaaUhXRjd6aHNJSmh1NG9tSjlYN2NUb0RIdjE0SFRWTnorcXlweG82QzR2Y3ZnWm1tZHB0bVBZaXVPck1kdlBwUVJka1Uya1htZjZhQ1hDVm9MMit5NkpieE8yWDRPaU40aHg2cVVlcmRkMnMrd1NUQUhUNVdpRkpwVDRBaGdRU0hzMzZwM2xHUXA1RjdZMU1ZTENNeXordzdjUUlsbjB2NldxZi9kZjhKSkMzUVdORDlSa2JtT1dldVJoQW40S1gxMjNYVkl6YWhreTBtTnBaWmFhaFVuRnVDaVJ2N0ZvOGF2UzZIUkIwcUNVS2ZHSkFDMjBMV3AvL1dwMlpqUmhxNmJNSzQ1dUNOMU5KMnVpblRDVGdUL1pRS3FNVzNsb2NIcDY4RG9WbWJLaUM2bWNiOGRVMzFGc3c3RTF5OU1FQmJjcTcrb0dibFgxbzZidnQzNDFoTldaMWZTaHFaaVdzU1RUTmJTdzhYak1zd2h5YmRnczJLbyt2WC82dGZxUVlSYWtiRjdrVllVWDBSbFdWNXg0VEhZdGZHTWxadUtXdFdRLzR5OUh2WS9wK243RDluUDlzRXZScmpNTjY2dmRuR1lsK2pLSlBnRVBmUVI3RVhjL2Z6WWVrRDljT0d6OFlyblMvdC9wbERXQ085dldoTHo4djZCbTZKWC9EZStFeEkyaWJUZllGV3VBeklOMFFtaFBoTDJUQVlVOHVhQVpzRUhTbmJrRE0zM244YkhyUDBZdk15ZDhMV2RWbWhVNmViNVN6ZGlmSVhOSGVyVDFsK2VZTjJGYStZd2l2aEpQcnkrVFJWR1V5UVk4T3dSRkVYRHlhQ2NYR1RGVjBUVHVTS1pTeVh5TVRyRWZOQ3d5cjF3WkZJMVh3dVQ2cnpCai9DWk1IVVZJRlNIbFE4cVBwcE1yZVZ4ZS9pQ2VqZDlFZUs2dE5oRldHdGpFNVpsNVpvR3VXWU03THhoU2ttaEdtQmtoWHNtNHU0VXNpRUJuWitKYk96aUZ3bGNFQ2sxU0NyZFFyNFlUZEpuc291RmV5NXVDZ1puVHNzekZVL0syMUtyMkN0VnRMY3FwT0NlWHNmaGtDQ1ovTFlBOXZVSmRUWDNtSmpXbDNxUW9aS2UrNmVqUm8yalpOZDV6QjFnTDZueE5TMkh1K1pMQnNXWGVNZDVzT044eTNFK292SjNTYXZpa0lZaDN2QWQ2NmJmSU9YNTViUERwbXhYbFppV3QwTjJKbzBlT2hEempkNGtlY0JUM090TGp5b1BBZUZIbUN6UUF1VzdybmtZUEcwS2grbkJmaWpyYWkyRElLRC95QVdkYk1qNGZEK3BGRkl5bS9Oak5MSEtObnhrdTRzYVVnZXFBTUNiL3RYZFRrRW9Ka3V5bVVyaHpTVXIvRHQyWk5Nd2dNSlJ5V3JCTHdiYmtoSDBWSzJvbTFGNDFlVms4NlNmdVNsV01OVk0vR1FQbkllY3FMN2ZOd2t6SWlNeUxrcXpkYmV1Nms0TCtNR0xyaGowTXFYUTdEd3BHN2NTZ1QyQSs3UWFHRVdyZE1Qbmc3MkVpM0ZRa3JPSU9oQ2RjV0dzWkxNOTJEQURLczkyS3N1Z0ErdGNzOWVvaDNDeDhhUmFMbUlPeTlMb2dHN052VGxiZGQyYm40b25zWlRjQXEzV0NjMnpKR294REIrL2xvQ0t1U3Yyd3hmcjJKd1NWaS9PbWRMT0NiOFRuMmJSUUN2NDROcUEwVFNzeHB5WG01alJYd1d5Z1YxVDk0V1MxL1oyU2p4Y1lQVjNqZDRnWlY1eG5PVDR0Y0h4VDBQNVlVdkZuSE9tMW5tSjV6SytQTUs4QTlKUXUzcHg4TEVWaTVVRkFQR0dsbFVCUVFnTTFwNGtoOHV3dXRrSTRWanFVaGV4ck5LN3RSbkVhMUx0elFDUlF6UERYL1FjVjQ1OVZoOHNMS0E4TU9KL3kwbFhSaVl0VGFkeDBmc0VTQnZ4R2lhMkxsdGlRM1NKcisxd09LWGhjVWRBbzUzamNCQ3VMaGlpem81eHZjMlZXbFZSOGtNYnR4UTF3WE9hdkh4RDMzcWNZNml0c3B5U0t2K1JYQWpjblNObjA3UStsczZJd0dFK1V2ZE1PWDVrYkU0VVozRzBPOEk5b3BxQy9XWkIwK1hjZzlYVVFHditISnBqNisyVmRFdTdVQlZON3M2YVhWR1h4SHRHS2RPNkFmYm1OMmN1OGlua0xzMEo4dHFVaU5SNld5dFNhdU5oais5eUVaZW1aNWt6SXZ0Sm1Ja3VuYlFCQ0VpZVE4cktFNFNWaVhRTzZLUFF6RXVjMWg0Z0hrdGdzNGo0WGptZURaSFdiZWxMVzJzdTA3S21xSmdWNWF6aVlTZ1dwVEQ0K2FsZFNra2JqdE1nNkZ6dm16ZFI4YjhqTWVVVjNtTk5sT1BQODc0ZjQycmhKZEU0UExEN25HSEVuWmhuSEZUMlJOcFJ4TjUyWGxYRUh4ZXpKU1R0MXNZSXVUbmlYY3B6cGliUHFnQ29oY2J2cFR5V2R5VW8xdk5PaVBPUzRwdW5ZRmN3dG5sVk5SZHJ2SlRUYlVsSVM3dkFrNndXR212V0pLa0s4NUJuSWNrUURNNHNYeTQvakI3STFiOVozVGQzTkxXbzVaeUE0SmRrNksrM1dEY21WOXR0dTQybDZNZTNQRkhPUzJqb1NtVDEwZHNKdm81TWlwdDZoTEIybW9vNWE2NlFpUVJwNFFhbllyS0VuZVZ6dUdoZHZ3STdiZTNVNzlWSzhJZWU4RzNnSmJWa3FPZ2VsZm4zSlcwSnNRbEJlTGlnaS95cTZGWG1jc1VTMm0yUy9kcW05VmptUEhtUjhKc2xrTzZqUVJXSUExQTJ3V1NvRUJhSFFLRWdSVjlwT3NNM2JSVjl2L1ZEM3hkc1ZhdHpYdWdhWmw3YXVSbDl2NWRGNkdEczdqUGY4Ris5VE5VMTluMjY5RlRTZmI3Vk9MNTFabnUrSkpzMUVXSFdnbnoyS0Q4aUNVYi9ObExOQlBkbW9iYUt5N0xzT2paZStWNElQa2dDWkRBMjFrNXRubzZWSEh1bW9iVnVyblhSM1BpQUNkUnlFUUY2QU9lRmpCQzk5UDEzeElaT2cxL2xLZ1I0cERLT1FSVDJveHJ0Um8wbm5VczZIQmc0YUZEejA0RDBIZEcrZ2xrdkFKNWZJMWF5NXhhWEZPYXVUTWVEcEIrNzUzVlM1L0JQOFE2c0g3ams0WTBwYWJpWm5xbWRVTTV1TXp5M080Yjk0TWtzeThBbE5NbWZ3YlZ0bmw4djE4akpzd3JuL3I5Z1I5Q2ttRGloaEFtV3RnYk9HZFQwUVVDajJJdzBLUWVRZ3NDV0s1TVE0UW85NVR2NzRvZG50MjJjUFhPSEZjaDgzaGxZZWZUUXduZG1aN0dBc3pmTXBkekE3TSt0WTZZKzVxZXJrZ2N0blpvNGZMSldMbVVlTlAvdm9SNEprTGozVFNKZ3BYTTVJTm1aU3VYUkhodjBZb3pIRHNCWlJBdmFxU0pZVml0eWdGRXBqK1BHMVp1aG1GeHJnQnNXT0IyQ3gzQXdEb2tXbU9uR2tZcTdvbGZ2ZkVhdkhWZzU0YzJOamM2VmlPWjRzMzVPYkV6eCtKdjVRT1JrdkY2Y3V5ZkFlUDcxZDhQbWhuUm1lMnpXZWpNVUhrM2xUYzhaM2NmZ1VmOGV2eEdLL2d2TEZZc3diTEUzTmpSOStvNkxjTWo0K04xVWE5R0xyVGN4YnZVbFJyeDRjRzk2aGFJVkV3SEU3aHNmQ3R2NVRkaHI5RmhNUXI0dTI1NGpYeGRIWEszZ3F3T005K29JVU45YU51TGdraVhlS05IbW5LSDV3ZldscGZRbTlIM3lKMXJRVS9vV0piNjZSMkg1c3VCNzVlV1lTMWg5TG9lRUE5UUlLY2xGNGNqQ243QUU0ZzZiS0lZbEUvRzZiQVdPNUFqMjM3NjU5VTFjWGVNN2hGVDY5djB4c1JtWkhMczVNWXpiOVFVR3l4SW5CNjJxNDBDZE5qdVgzazgvaUJLK3U0WnpCSEtmaHk3aEVtcGlJREdTcWdIVDJSc3pnanc5Vzl0MzVFWTlYMlprVitKUWVuK2NRZmU5bjJRSjZKMEhXZ3hnWTVEMkRoaWNDZlFrMVFHNVhhQmFjTFhVREdDTDcwTTc1MHZCd2FYN1h3N3RvWXVjSGR0NzIrdHQyVGw5NzFWWFhUcS92dW0wbk9keDVHMW94elV4dWRHVmljQ0JtMjdHQndZbVYwVnpHTkZ0blUrTXAvTGMzcitOL2VUWStORDRVSnh0R0RMRXJ2aGI2L3U5aUxtWXVvWmpiaEFzTW9jdTdBTGZKL04wWkMwck5BUGZOUmkwQUVRd0d1cVlidUZSRjBBeG1kaUFJRjgrZStQS2RrbXB0c3dia1E0ZmtBWnhRcFR1L0RLdmpYMHhQTzg1MDVnczQzZG85ZGtYbTgvbjhueXRGLzY1ZlVTeitQV1BOdTVCcEpNMGhoS28zenVmeks5OHk4MUlXMytqMGFYeURySlEzdnhVNHkwNlE4UDBFU1R6cmY3VHhoMHVIWFg5SmtWSEdiOTByYUprRGFHbXBMUk5NRTN3S2dzcmVRZVB1MkhEczZmSWE3YUJ3RS9kMHFsdU9rTHpKUXVERUJGbHhmSitXMFg3RXNSNHJzWllpUGM0Sjh3TDN1S1JZK05oakZ4Y0Zib1VURmo4dENKLyswOUpKVUlmdnZGOVJubVpGTHNraVZ2OERTUkc0NVdWT1VLUS8wSEZHa2hPL3RBeWxsdi9rWVo1L21QcHJRcXlTWHZ5Wlh3U3ZsbExmZkZIcE8rNUhtbml4NTV2RmZ2djVqVjYxdldXNnNIRDZySU82VVhMUWp6WnhPdm40QmViOVZvckh6Y3FuWUtteGsvenJlL1B4ejhiejk4S0NOMEVrZjV6alBzdmhMUVVuTCtRN2QxajkrWklyZlU4TWsvWm9QSSs1eVVMUVdpV3c1WXVjY0MySC8xMHJjRkZPVUdqcmtRak9GdGpBN1RwbnhPRmlMMXo4eGk0Sk1QdDQ1anR3ejhPd09VaG14aVhZNUh0QjJjTWtXZ3RMNGsyckdoYkZHNFI3NnNKQ0cySzluU1MyUWUyWW8xRy9leWx6RC9NQkdvVzRXMzhTOVBFby9XNk8vZWNEbjdwWmJkSkY4S1pVNjJRNVhTQS9GOUlYbHp0djYrRjJmem5VeVR6V3p2eDhhNTc0TUowdzFTWFZ2RWF4WE13ZXJTeVJrM2RlUkRMbnY3QnBSL3RHK3g1ZG5mTEt6VElmQUQ0TTNhL29OSmFmcnJSK1NaTDN3Y2w5NkViSzlGUTM3MU5oL0J2d0xaMG1zY2JiNjEwMEhMY1lNWW9ka09VNkRWRVQ4Wmt3ZnpRS01IZmNEZWhha3NBblVsTlRxUVFQYVFDNDZzbjVmSEhISUdJR2R3QkNKcDdzOWpSMzVuSTdtM3M2WEdGUHpyTXpWODdndjZoUFIzUTJTWit1UmJEQUYwcHh4Wk9LNVlaYjNBMFdDRXVFdnZOUVhEVitZUHpiRDZ3OVIvYWdsUzFJN01rWkxaZEhXMmVtdG0xamV0cDEyOC9Ucmx5QmZxUVgxS3piWG1DSVFlR0ZOV3VyU3RxMXAwMjNFZS9vRjkybXBRTGxKbEJFN1FXMWErc1pGTkxMUklSZlVQc1NzbHZ2b3RSVDJlY3BFbzhJY3hFdTVhc0psYlBVcXJyOTdVcGgvZ3d4Rkl0SHRSUmhNYXpMV0tnWjVtUE9hVGt4NUJmaDZZTnhLdU1NRWZ1U29qK1UyUElNZWlTalVPc3FwSmlEeXlTMTNFVFV2a3JKbk90a3Q0KzNSWENtbXd5VFJCMHJHM2dqUWh1OUtZajA5VUVGSUEra1h2OUI2bXRNL1QzUUFvMUp0cElkR2RrK012TEtnU0NiOGdiTW1LNzhycUxIMEVxcmc5TmViNzJaMk9HOGZnRktiaDk1bCt3Z1pNbDgzTElWWFZkc0s5N0dPU0xZaVZRS3JqS1hndzZtZjJidXdvOHJ0alVqRXJGbUFEZEdBUzdvamtoR1FqazZYVzUxYkg0TlZnamNOZEJDc2d6ZXR2NHVuN2VKSlhSaHo0SVRyQVpvWkNrVlQyU3FjOVZNSXA1YU9rUFUwV2ZRY2g0dXlidEdheGtTQ0cvdCtiTncyV1NoR2ppSmhCUE1KNUtqV3JhVXFXYndYeW1yalNZVGFKR2d6UkVzSjdIdGUwUG5JOUEyWGQwZmY5NFRnNzdaWndPWWY2TVFXa2lXdXQ3WGh0ZUYza00ralZOMFNJL1NpMjBIY1loejBJSTQxKzhCMXlBL214M05aaStOTzJVcnJocUsrQ1pSTWZCSGI4TmxlTE16U2toLzFnSFh6N1QrcjUvOEJDWVV1SFEwZTByUVdmQzZVblZSVVVSZHRVT2IvYTQ2RDE4SWVtc25ia2VoQ3p5bUIvcy9kRUlDMHZuV1o2bFo5VFNhUDhHcDNMM0RlRFBjR3dXZ040N2VjOVJ1K3VtRkV4eVU1b2FqL2tmOU1kUE1HSW0xZWJ3WEhYY0g2aDJzM0w3b0owMUtmUHRGdGRGNHBHWWI2c0V2b0hWTUZ3bkRZNnVrQm5lei9MV3RoNk1rejVNUGpCUzRsNUo1bU5UbkZONGNicTNuYlZJbGhxQ28vd2l1VXVGTEpDbThxV2E4RjVpb3hCSnRsanVoaHFjNDd2QkN5TC9CTitiamIyeStqWlRmeDhRRWdHQlg5QXROdnl1b0J0R0NleGFxWWZtK1ZpbUg0WkRSdzdmd0tuY0xsanIzRVlaaG55eSs4ZDc4bWZ5OUNJQnh3TlZVZnhrbjgwbVczWFY3L3U3ODdidDRQc2twM010MEpOM0M4N2NJMWdlZ1czM0FlbUorZnVsVnJ3TEtYeFV6NytKRlBva0U5c0Q4L0FGY0hoL2RaWGJaK3NUeFYzTUVqOHNVUEtQUHByOHBkQlBkeGVSSmxQRE9wNGF2bGNLSy9zNHR1SFZQQ2wyVkVORERFZmxtdkE2dFc5OUdLakRYSUFkeDgyVjZOYXdvdXZZV0RqZEJWQlhocCsxNjJEdzd4UEx6K0I5SjJIZVpOcTVuR0NzbTFQbGxtZEk1OUgyRVFBSENRV0hpdDlMeTNZOEp1eDhVZllTZ2pkcTkrZmt6eS9Qem9lM3czMkYrK01OdGZ2Z29SYldtQVRWcHd3V0Yzcm1hNnp0dTloMkRnQTE3SWw4S2lPRDd0VTRJMGhNVTlLQUZ6dklmNm1STEgrL0tIMStVUEU5YUZOQlNIdkpnOHhhNmc4MExUQ2U5M0VuZXRpakwycG9teTR1ODJXMHZuMlFxSVc0Q1E1Wm1lMUJlTzJNTm1ReUlrTHdIOU1VYkFOZlBkWXkrL2Jhay9qYkNXNXNxZWtZMWswRnJjUjVuNGIrZGJRYjZselpKb1owbjlwdW1mT0l4dUxKRnI2K2FadXNiYVBGemtFOU9Qbmx1UElQUWppeXE2d1hYOGx4VW93eDk5TmU2NkxJeFhmK0lGci9acGl2eXZlcU9WM0hSdWFTL05zWnBzTFZwSWtoTFc0U3ZtS1doRkM2V0JPZ3dnazVzKytjRkNlKzNDbUdCd21BTnJaQ3ptdytadkpPQXg5QWZ5K0xRK1dOWlhIQU50ZzV0Y2VZY3RkZ3l2QVdhUFVjOXFCMEhRM0N1SndBWm9RbHhJWHFaSFJCT2UvbUFEdURzdWF1eTdtU3pNOXRuc283ak9aYmxsRlBMcWJMejZtU3hPRk1zM2s2ZCtTVGJEbGZuOGY3R0I1T3hnZEhzREw0cW0wL0pBMjRsbGxVRzVad3pESUN6dzA0T2JZTkxaNG90RXA1d1dGTHVWS1FLSkI5WHBERHVKUENsRVdibmpnZ251Y1AwRmRwOXU0WjVuaHBFLzhWOEg5ZWc2SjIxUmpRS0ZmRlpkZ25UVkZXa05VbHBuU1V1ZzFVMlgxVmFQMTVlWHIrM2VtK1ZHbmZpUExTbVNDc3JRQWZkdHV4OEhwM0ZwNVphWjVmeFA0SVJ2THErem9TeEtPQjdnMGpzTmE2OXVoU3RKTG0xVG9RUk9IUE55UDRKUVNSUmR4NmhpMFBDNlA3SjNoeDQ5eVRFRHRtZ3hVNjZ6UU4vbFFud0c2NHlPOEc2SE5XYnUxbXlYdXZ6b056UEUrUCtNamRJUXFUT0VFelBTbnN1SEl4d0dLbGVBd3gwT2xGVEJ6c0tRMkt1TTlzZEtSWFdNZU5vanVkanNoeFQ0c25XYzNzT29mcWhQZHYzUG5iM3RuMzd0ajBMbTU5V1dZV3Jzcnl3S1BDUGRxVS9JQWR1amdqK0Ezc0h5RDduQmpLdWZ2MDRPYXBlUFFCNExCeWVZMk14bVZlR0hPV3ZicC9iczJmdTlsdWJlMXIzREkxK2JYU0liSjVjNFBrRlhwYjVjRCthOW1KNkVqNlBvaVFWWVovVVkxNmFPR3lsaWJwQjExaVJpV0p1SXNJZk5BbHZFM25vVmFTaWovODNtdVZHNktXSm0xSHExa25CcGhrUHRmQlNGS2tNemRPdzdKblVhTDY2K0dZUkorc242dXo5RWdGQlNham1zT2RSM0EvcXNZcFdpQXVYT2xyRnBYMGZGNi9pYzRaeHY2UytpYWhLVE5VYjVnbld5RW9VNFl4aHpKQVhXTzdSalZJN280OHl2OGs4eGZ3cDg5MU5lT2JlNGNzWCttV0dGM25jZjMzcFBNY3Y5djc5eC8wYXRwNGcyYnJBdFlqNkQ2MXpRdXRkSFNUZ3hmTWxXMmM2YVlCSmIrY3Z2NGliZENWdjdvQkY5VXNVaEQ1QzVVZmFvTVhuM2x5eVNkNm5MdkRhenVZRGJVa3NYRHQrRUMzaXZsTW1YcnAzYmV3cHhBdThLRkYwdk1pcUlDN0NRcklRRlBlZzZUalZoblpMQUpUM3dVTWFHS2pDd2drZUxmQlFBb3NwWU90UXB2WUpOT1EwbmtmWVU4K1RPT2JzQWtBNXZTNnVjTXBPQlVsOFhKVFo3YXlTVi9CV1JyZTNua1dKMW9KVzFtVGhxM2dtSkpXWWg4cVlXb28zRFo3akFFN1ZjV0l4UVdWbGx1VXRmRStPRlV4ZTRXVFZCdjhEdElpNWxMT1VTeUZtQmdNRHZLQ0tqOHZ5NDZLYU9IdHJxVlR3Rlh4YjJrYmtDUU1EZ280SjRrMThmODIyZEk3ajRZYUtia0hrZW5pTXJudHVPK1lMblpNR2lBeDR0QjNqTXBvNDIxeHZWOHpMV3JncVVDdjFjY1p1TDJQZFlPOXUvWkRsVFZ3VEU4LzJQeFNrak1maXJpU05QTC8raktVc0tOWXpyVHlOYkVjbDNWQytKYUVJc1p3ZWcyckhXQjR6QTNEMnBDQXR6V3UrcnkwUTdBMnlRVVNtaE5qeWJLVGJYTWN5MDhmd2lIZ2pzU0pyMjdlQzFlWVVDZzFvaTNRdUljdkpsWEt2WFRZSnA5aU1JaTVLYllQdW9HM1dEYmdNczNSU0l2NHF1MkZ5b1VCVTZGbFBVeVlxZTNmc3lCV0NlSXdYT0VrVlZNVlNaVTIwTkY3a09KWWRxK3l5VXRaZzFSOHlaWHhTVDdxYUpZcUJXUjcyOHU0bDFUcm5hK1pVY1NpN3Zibi80S1dUczE2eTlhSHl5ZjJLalF6MStIMFRJbXQ3YUttU1N4N1pQcE5MSXhrQ2pmQ3FKYXFhNG1tU0ptUGhVWkJsM2RnMlB1d0tlSHBBbkdCSUNpZFVOZEVVQkpZbHFKbUorcmFMSGR1eDNDQlhIWW1qZ2VMT0E5Zk5EbGRiZjE0YkY1QUI1blRObmJLbmM5U1ArbWN2UE1ueTZHdDRmcjZCZkc4MGpGOEY0RVBBQnhQd0s2Q05jeXkxaFcwUzFBcFFFNU4yTGRNUzdjTGtPbkV5TE5FdVRLNERMUDA0THNqaXNxUUVuSXVqNy91emNkbFNnN0hrV0dYcUt0L21FTThLaGphNmFlNllpdXZNSWM1d0RwWUhodnhLM2t6WVdzNFdOODgrZzFRbGRWR1ZRNGFqSWlHYldSaVNEZlNZcnhrQ3JqSm4rMWRWeS9qK2dXcko4ZG5SVFhQcmRzTE1WL3loZ2ZKQngrRGdHVWdWN1p5MmViYUhiODlWTDBvcEttdklReU9WYlFKU0kvM3JGTkVGTXFXMmpzSXBob2x3blFXTjNJVGxkb2dIdVAra3dPVkZVY2JTMVg1WkhGcmtTU0RCQlQ0dldIaThXTEZBcHd2K3hnajBCNFgyUFVNVXpwNzdSc0RqTysvRzk3NmI1K09jeG0yN2w5NytjNnE1RFIvRytUbDg0bTVlZ1FoQXU5RnQ0V1B1MnczdzRnclRSMys0Tmt2dFpTTDJzUUZXTVZ2Umo2Nm5GV2lkb1hkR1N4YWwveWwwRWVHWEdkUmp4TnB6M3hCazV0ejBvOE5kRldoOUlIek1XNklLaUYzKzB4N1JVRXlBM2s2Z0RCS1YraXJOK0V3ekVBZWJrWm9ycUFCY1FOeXJnSjFxWlhaR0NrVE1acFhyM1RMZVVDTlJUelNtbGs3VFdOblhOVlMxa2IwcHpQdzdjalRYa2U4dUlSbFAwNmpicDN0S1JkZlFNZnNwZENkdWE4QlYyczI4bEdydHBMWlNDQ3dTNk5RR0VmWW9EZ2RGMzJnU3QyZjZIUmJMQk5HcWkwT2twdkhVUmlBYURFSFVRcmFDT1VBODAwa0tzVkJhS1JOcjFPRTV4VlRtaXpzR1pTRXZXOFlOaGlYbkJabWlPbWl5Ynl1V3h1cnlMOGc2cTFtSzdjdmExSEV2SSt1Y0FxTzZ3dWt5ek8zL2tTcmp1OHlCb2V0YjhLVlpWeXNaOFd3MmJwUzBXSzVJY0IycXd5azc1WmxCUnBKbEtST1lIajRjcmxLTUIvYUZuNzd3UlZaQVg4ZXpGeGJhU3puQVFoVmgvcDVreVlRTjFTS0JtU200QTJEalFUNGViS2poSVhoU2tIcVRVYjhTbWFpQTNvK01hbkhRQTViUjlxUm54SVh5YVBydzRWblhUZThSTFFFSkU4bnBnNGxqaVlScXlJZzFlRW55ZmgyZlQ0K1doYmpoSlcxUGtuaURSYktoSm5DcGc5UEpDWHlOSmU1SnUrNVBrdnYycDBWOE85ZWR4VmZzd1QzVmRVVmhFa29kVFJ4TXFpSXZ4d3c4a3F0dngwWHdIY1gwL24xSlc4VTVCaFltUkRWNU1IRVVubzRsTGRlVlJYelR3NGNKSkFPeEg0UjRIdnVvcFlGUC9HTWExR3NKVkNlZFZNU09oa3IwUGNqdnBFSVdGdk5TZHc4SkVqYzVmalR6UGw1UXhIZlNMVkhPTkNFNVRiZVNjUHpXMS9OWUV1V1BqUXcvVVNCUXd6S2JuMnFuOWdCN2Nva2VIbXBUN2RRZjRVbjlaQnZqbXZxOGRPU0NFOHhOek12UHJ6K3Y5UGxITjg1ejNEWWo5RGNrdGxTNmo0ZVEzVnRzZnVibi9MNi9jL2xhWHg4dHlFblhiWkp5TEhLTFYvZnN5SG9LSGhPcFBveTIwVEhtTmN5SFNmdEVycEx0OVpSdXZzM3ZPMFllYmdWOEFTelZFWjlRa2RyUlNINXgwS2YrOWVSc204MkJoVHlDRVZhYmdhRUdPQ0dLZnRjT2g0TnZrNFhiTnNuTjRBNGVzQWlBaC9NanVvYUp3bldacnFPdWRJdlQ5K202cGV1eTVHT09obE00SGxtNGx3ajdkYjJDREZ2QzUySXBFM003c2d5UXdySXRHNkx0SlF6ZE1oMVIzNjdyaHE2TElvOTRXYkF0U1ZKRkxESHY3K2hRMzlQV3QzNm9uVUlGL0RqOVNsMzBaQURBNGpsMVdQK1VJR3FLanJrMnliQXhLK2ZLa2lUS3ZNeUpncVpZL2ljVVU0L3BMdS9oUEEyWFkwMUpsbGpaNFVSRlZVTHNxbi9CNytlZFlWendNSTYxMjE0WjJRQzNnODd6cXZxUEY2bm9IY0pSZVdIUWdDZTNhdGJ1Tk5HOTRkSVAwVnVzaGtJOHMwbkxkRkswVGovQ2RYcDdqN3orNHZ0Y24venJuK2Y0QXJ2TjlVVER1T1htdkYyZzBTNytvVTFTZEk0Qi9oZm1HTURiWVJCbklycnlNdHNzWVg2VmM0VWErdWxUMm5qcFRES2x4TkdxVzdKL3ROWmFYRWNQdEJialNpcDVwalN1UGFWWTVkWk5hSFV0a3JtSWpZNk9aZGhKaUJQVHBFMUpHN0pyRVlvSXFhRzlibWhtQXc2NVFzRXZyT3UybmJEdHY0aUdtRHhSeFlDY3ZyWTJ0ekNIYkFBcUhiTDFlVndPTms5RUVsTVZkRHo3S2xPWlRCV0F5UmJYTzNaT3NFNEdVblV6c2gvZVlLdlFDSW1NejFCcllja3ZOSUp1NHRFWmZQdXpiVTJ2Tjk5YzJHWjZabVh2b2RicWIxR1MwUm9vaWpvaTNOVHd0cm5oT1dBS21waXVzK3ZyVDNTb2JtUGp0bWw3TVpTZGk1anpVaEhxbnRjSVR3c2FXN0kyUDducDQwdjA0U1MwRzFwcHY0cEkzZjNYK0lXczBUZUNtQ2w4Kzk1SGsvZFFKZEhWZ0kvK1B2TkRQQWY2eEp0bGh1cGEyMmgxK0xuZXlYRHA3aERwd1lkazhkaEpEbWRZcUU0K2pXOVlsQi9IbXpVMFJkQ1pLRVpqWHp6eU8vcXVRaU8zWVBZWUZqWVA0eHZ6OGlHSU0wbnY4eVM5VDRtaU9JcFoxUDZzTWFPQXJxUTNvcWpTcUc1ZEh0M25rSXpaYkloWkhzWU54dlg2TUtHbkl4OTRIZG5nSHpmVUM5WDc3aHplQjFWeCsyUkozRGw4bjNiYjlMbTVvWEVJUTM0cFVTRmR3cE13NUE5eEt2K0wvSDA0ZFJ4ZFE2cjl5ZU1rV2puT3hYOXFwOTBXNFA1YngweUhaN3pmNjcyTmg4bC9pRHlqM25ud3BWejBZSHlPNmJzL3hjNXN0NlhVb1ozRW1SNkdCN1ErU2VwK1RjOEQwTEd0bnREVFBpN3BQKzAyRGpyM2hqcDRXOXdEeVZzK043VEZJbXZTVThTdW0yTHB0bTJOUWJEd0FCbTNNb3M3YjVPYmJibzVSSEVCUUpDdkE2aG9aWnBNaHMxT2VNeHJKaWNhaEFLV201dzRrcFNrOU9VenI3SGpIODlsdjVqTVBOOTk1cmRUdzE0QVlUUDMzelVZM3c4Qk00MEZmTTdFWlE1NCs4YTBsRFo1eVB0NE92NS9jeXpTSGIzMTd1aWt2eGVmZkdONTRPWXhNSHV4eGNQYnlqc2llOG1uMEpkeGZXTE1FTFBBWE1Vc01uY3dyOE50Ui8wbmlEQVVBZ0dEdGZjWXRmZW1ZN0l2allKL1dXZlNFZ2xBZCtoU0NPc05YVWFVVWh3UXR3Z3VGUXdWVWtEaHlvQXRxRFVKY0JsUlI0SlorTmlSc1dYODIzbmJhM0wxM0RMK0VVaTdYMGM4RXNjeSt3VnBxaEJYaGNSQU9mMEw2ZkpBUWxEamhTbk1KbVhHbEpSeHFURkw0Q3ZabThGZ2gxanRyR1c4U1RialZkSGF6dHQyd1gzaDl2Z3ByVlVhRm4yWjR1NngyUkxnek00NE5qZVVnT2lSaVNIT2RtYUtBNEpVT3BqTVpJWUc0dHBBWEdGRGo1cjN4Z2RZSlQ3UXRqa2w2eEFVajY3S1hNemNES2d1QWVqWXdoaFpFaElIM1lvVVFFVHppa1hEVVlHa0VjUm5HeEIxc1FqZHNtbEZjYXJJQ1VCdW9pY3Nkdk44Z1hhN25oTlRiSG53aWtPNmprN3BCUjN2VysvWEM2MmQvN3dUM2JEejBwMC8wbE80UzdpQ3dBY0JMd2d1eC9JcEhjazN5VEdXWlExUUlOazJhSGdNZkJpVEVmL2xyVTZnajI1MXBuNElQeGMvWEljOWZqZ3FSQTkvSk1GTFhDeUZKUUJkeDNKQUtzWkpmSUp6TEU1QWhvTjdySXpGU000eGtNQlpITGRwN3Zkc0ZqOVBqN0VjVWhURXNURjhIOFRhTFBrdW55YStLdU5rclpmRy9LTEdGUko0MXhGTGNZS3lRUHAxdHllRDVFa21PeGdDV3RSOCtINW55SmthYXJHY0ZqdmxhaXlmakY4VUpIazRpbWtjUHp5MGEvdjlPM1lPVmFveFo5ZVJJOGV5ZVNlMlVJNU56VXpGeWd2b3RDQ1lOaThwVDB5a0U0bjB4Qk9pSnBpbW9JbGZPcnhqTnAvTDVXZDNIUDZTK05YeGNyR1J6YWJTeGNyWThmbjVFUmNQU0NQRVpvT3NheUVtakMrNkgzK0w3ZUNpMFhKdnRJNUZaZGxLejNKdlA5NWxEVmNVeTNkLzd1eTRmSWZqSjN5bm5LcW55amgxS293cnFraHhSYXBMU2h6L3VlNndHd3RRS1ptRGVLSzVwRGFTdU1iTlN3ZGhmZmVnbEhldlNZeThOb3dwZWxaU3lDcnZraUpkWXdleUhOZ2hIL1VsZ3VNZlVBUm9sNmhXNGdIeEtpV3E1ZDBFVklhRDlwNk11RHNxVTFVaTVJKzErb2s2NWxQR2R5ajV2TEpqSENkeFJySThyTWMwd2xwb2pqSDhEcXBRUWxBMk96a1VISHlwcFduV1N3OG1pcE5abk5XcUR1K1k5M1BGZ0s3b0JZTTVmLzRKcWxlS2VLb09uUytLeWdzaDdzVlFSWEU2RWJYUkdpVHgxYUxsZlR4RitHVFdhdXhtZTV4cktvQVhKUktablhpSnhkSDgyTVZYSHhrZjJsMDJlSk0zeXJ1SDZPaTJFemI0OVRxQllpcWpPVWxCZVRvQ1ZnNk1peDlMU1ZMcVkrTDRnWXZEZ25oelJsSUNCMTVyYmxScDIwci9HUGZGSFhpK2c0aDcwUnk2TVV3Qk1aY0x1WVBOQXBrMUFyOVFhVllhaFVCQ2o2dlNuSVQvVkdxc1M5YVN6cXhzbHZuKzFtZnkrUmk2Tko5SEREN253USttWm85WXQrVERyTHNoNjI2YXRUQ2Z6eS9qSDFuZndXMzcxM2krZm96WW1GSXVWcW9RUkwwUU1EZ2dHaTRTS3Bxck9BRnltazVKY3BybytUZitwdU9zR0xZL1lMVlRqNjJzdEo2K0Y1MjY5MTcwNFcwN0JHbGVUSml0ZFlDaWo0NVFIaCsxN3FtaWZMWDFUWlJ2dE5hMUJ0NkY4Z1Y4MHhsTUE2d3lBZEJxdkQwNzRqRWNNeEtSY1UwN0JDbm9OYWVRUk1KWUFPSnNKWXhhQmdiVDhhQlpvU3BzbEUvUFdZSWxDWHRrVWJEbVNwTVI0R2dJUUlvTzQ3TnphWnhiMmozTUp3SzJlZG5jYkZsaHk3azVFN09wZXdUcDdHUXBTb1pGQ1R6cE5vcFcrbERYZlFkM0RMRktlWGJ1c2lZYkpQZzRlUzdWUStLVy9WdDBGYlg5eDV4cGoxVUgwYldhYkk2RXpxMzFlQ3NSdGFRUXFnYzg5RGNUb2xVa3IzOVV6bWVPSEdsNlh2UElrVXhlSGlXWlJVdWM0TGpXZjJRSVlYODRqbW4yYVhlWUtLUkpVWHhCdWpCQjgzeFp4TVZWN2xpR1ZDVFVsMzRibGRCVGVKWUc5TEJ5VjJBQVNJWE1ZWHhIRnhLZkQyeE5qdDNObHFXSXpIL3Zmc0k0NXA4M0oyUVhKZk12OC9JWWhjcTBCRXo5aEdCUnBNeXhyaHIrU3B2RUVGdjJRZlFncFJFK3J4N0ErYTZPMHFoWGV0RG1xZlZQMUh2UTNlVEZCU1ptZEIyZXN3WTZQU005WU5JQVlXWUFiL0Fmd282eWJFRnhHakxNSElpNlFXV3lOR0R5WEF5M0pENUx1MG5yRE8wYlBmUm1xSlRZMzUwYm5iN2VUOXVKTHBKTzlGTnlvb3VBRXh1Znk3ZjFwVWtTNWVINCthekh1VjZsYWZHQ1l1QTlzNVR4c0JDNzFOYUp0djV4Y2ZHRGJhMG8rM0lBVmdTQmpRQXR0cE5va2RqdDJ0MFdCTGJkYTVXOHV1RXFTRzZDTzM3MFB3VjNITGNJK2U3S0x4cHgvTTRWUzljdDJMeDRyUEhQSmZDL01FNW5BYzl4QjhHdnYwUkdzTmt3L0NYK3ZBajRJYVJoQ3FaejhibWpZdUkrMVRWT29ud3h4d3Q1RVQ0ckVRbmoyOGNGSklKK0hZbDVKVmM4Z0lWaGFOeHg4dG5SSktvZkNJZkhzNlY1bHhQU0ZWRVdoR0JnSUJBRVdheWtaWGUrMURndXMreHMxMFVrT2N1eTh2R3hkamNNWStBZzRtK1J4enpQWWVaNlpvbDVpSGsvOHdTelJyK0hiajlDcmpjbW11UzRuVzdZcVBXWVkveDhlZERWKy90ejgvOURIcnJ6YjZFSC82MmJ6Ym84UjB3Ti9oZG11MWQ0TmtiakI4VWc2L3pwVnU1RkZJWTBzYlJzTDBhMG1oelBjK2pkNU90NUpib1JzLzRpeTFkNVZ1UnZ2b0MwVGJZc3pWbThzSVBJL3ZKZTNHOXRQSys5Q3M4WWtUUWN5Y2RraVRFZWRQTkFHMUxFK2J2UmhGbGMyZ1NIYzVMdHNqak9oZkkyT1Y3ck1IR0Q1WlJma0thaEc5YnJuVzJOSHdwUzVlZEdMNTdBZ3JFaW5ZRWx5djBURjlQWnNyVDd5TzRTZFFYSE56cE41VjNZUFpjcUoxMWlLNVBvMnNaejVkVFEwT1JsZGFFTXBqUmcvQ2xJWmFGKzJTVDFUaXJ0THVFL1NJZDJNNGpFTGh4Z2JvU1lIbTRsVk5SNlVvVkFGSFI3dFVqQmJFQlc0TVVMYUlEYVRMTWlFajFENURDUEJlZ3Bnbm8rODlVaHM3NnJua05UdURrRy80WDZQSlhzL1dEWXMxU2EzTFFOU3NPRldCSzM0Y004RDhYUVgvSC9kRVU1cGFKYmhsSUQwQjZ5TXZWeTNCNi9TU3ZweGtyRlA3WjUvdFZwY2N0VzhHTVd2dkRnMi9FVWlrdTJSamoxdDYrSXA4cE1iMy9KTUF1Yjl4ZGEvLytFSGxFdjQ3K2Y0OTJYVTZkaGM0SHZHdXIwTkhvT3owY1dydE5JVzFzZm1jZ1htKzJKQ2JBTDJ2WUNtT3FINFY0RVNmbWh6bVJSN1V3aGozVVdKektiMm9WSHV2a09Yc1BFK1JBYmhQNEl4T2RDY0dnOTBhWndDekNIVElkRUpvcXBBUDArZ2NmNmFoU3preW9hNkxJZkJWK3FBRXBTWXpOeWZuamFjdC9obVc4MThaKzc0bHFuVFhQdzlEdmUrdFozbkc0OTJTRm1GR2QzRmZUZTRacG5vTXpwazczMDlOaTVUMjN5YnM1ajlYNUgrNUYzYkduVzN2V1d2ckdWRlh0SHQ4djhEYWFGS2ZVYXh0WFFaNG1pbU5qRlA5WlRoWEE5YUI1ZktlTldIUVo4OXJhSlNiTXZUbzNyOU02ZVhOLzVOYXFkcTRhZ01ualRaU3RYRFEzbDhDWlBVVyttdWp4VDBMYXVoZS9XNVIxRFBMNkh4bWdOa0drV3V3S2JZckxPUjFxbGIzM3YreEdGMGtzMkpYRStqRCtKTnd0UlBGRWdGTTF2UmVjd0tTTkgzMnczdlJ1NWtEN3FLMzErTWNpT1NNcWtJb3I0d3hGQlV0L1VYTzAyWE14VEdtRFRSUWQ5dDUwM2U0RnZjdmxjcncvZGNvNVhGdm9oZ2x5aTQxRnJHM054Znh3SUR6OFAxM2tIUkp3Z2xxN1VWaGFZS0wrNXdlSUNkK1lHVGhkd25nK200Z1NicEE2YnVMNVAweXpFOFRJdnlrcGNsR0VkLzdrdUE5bTdXc3RUaGNJVW90dHFSOXZ5R0t5L0Q2c2NqL0NWc2lmcVYrci9hS3F0M3lMbXJwZXBadXRNWVlwY3REekZ0R01EUEVqZTZmaEdxeENoUTU0UDVEYmIraUk4T3ZkWTdENy8reEUxUU5tWnNCNTRnNWE3SHg4K0dtL21POU5PNkkvK2oyUmRjQnhzeERBbkR4YVJOQTduYmdTd05xU1ozWm1BYXJHYTdYZzVLTmh4YXNpVTh2N0l4Uk9sQVZmMnh4TUhYbnNBLzdudTZNeXVrODNzVlZVQ0N6RS9NK0VNSjNnNXYzZGthSGRNSFM3S0JBWUNQY01scnB5WnUzWlVIUnFadS9HdUcrZWk4ZU1GZGhtM3kxSG1XbWFSZVMxQnJPbGFlN0RDd01yMHk0UHdIK1NROUxPZ0xhZ0NCZ3orVmNxenphQWRaeFJnUGNrU0JTNG9FazZ1V1lSNElBRlJ2RFdEYUhXSFJsOWhtY0F2WEFXdE42RkpsYVNva1dEbkYrWE9pRkptWmc0aVhjL2xYTm56U1N5ZzR0aCsvYmlpSTdZMHFBY3A0cm8rdUtQMVVvZ2ZxcWsxUWRldVY4Yy84dWplZHdlcFB4aXEyOFlzcXhLRDVvYXU0eUtJa2VkTU5hK2E4dGlJU3BpM3VpUjR1cTE3bGtSdVZSL1dsWkhEZ1JkcjVNalRjTlkzNjRmcjNIV3FGMlN2dnplNSt3MzFJWGZRdUk2YVlQUFhjdmhrcUJmOUFycVB6RytUUkkvVFVaUkZkUVd2Q2FrWUVMek5Nc1E0Sjk4d0NaeDQ2Nys2TlN4cXU0bVlOcFVZUzdpcTY2U0gwUHkxVmN4T2o0bzZPM0ZFY2wzcFgyVjU3Wjg4dHBodS9WcTZ5THFKRVZ6UTBhcUo4Vkp0K05XaXhtTDJYN3o5c0N5cjZLV3FMUDJ6RktONlBPQTN2MGEwZUtORVN5b1FTUElpTlNUWmhVcCtsSVp2UVJJYXBRNHFYMXRPL012V002b2VUeEhCRDlsaEloVnZuVVYyYTRWNmhLT1JjUC9VSXUrb2Y2ZE5INXllTHA2NTZnR2FRTWRzOTNWWDc3NjZkVU5xS0lYLzV1a3UwaW12WXhsM2xjUkI3V2h4ZS9UMVhTSXJVVzRjcUJFZXJSWUpvOGltcXVIR2d2SUlkSjVIbElWSTFLU3hvaS9DL2R4bDBvVDdxRFA3bVN1Wms4emRkQ3lRK25RZUFNNEd3NjFRYURvRm9RL1FCQ1E5NlR3Z3MvMk9rWDdmZVhhNGRkaEtDbU9xV1FnUTJPZy8zN0lGVVVEcnJSc1JXbTE5dUQzREZSWVdoanRUOGxySE4zMnpEVnFPZ1dmaTJhQVFobXYrM0hQUGNRS1d5bEhpOFRBY005NHNESjlzbTR0MU51OXRwL2ExVXgwZUErejg0ZDNNWVFrZHo0aGtVYVd2emJyWFVycjh3RHY2aDdndlhRQ29DMXBZd0t6NVF0dHQvakVLWVB4QnF2akJVcTRrUEM1SVdOU2QyenhtN3pMdzU5ME1XWUtDRTdkdWlKZ3l5cWJ6N1AvWVBIZ3ZRMktMaC9odFRXWUg1bGoyTVlld3BIWWY4d2JtemFCUDZ1b05oUjdXcEJma3I5QUYzek9HbkFydU5xQmdjSXVObW9CL0ZIMkozb0RpL3RFTHBGNGdvSzZiRUJ5SEVGdXdobjRVY2hRUUs1eHdGOVJwOGpDTkZVNXpodlA1MW1JZS9xSFZmSDVZcDZXaElKVFJoNjRNclJERGZldGZWbGJPcnVDaGQ2NXppK2ltNEdEYzl4aG1IdCs0dFFxM0QyL0swUDA4RWJEeGE0cjJpYVY1TENnZmkzUSszOFhmNGlwekZZbHBlUk56SzI3WEI1bGZZejdKZkxyTi9VYTRXN1hldzU2RzZXbnNXdjloRDlRaXREMEU4aW9VYVZ3dktsK0hMZWwzN29iYnZsYnE4cXRzOU4ySEhnYmhYZGg2MkJJbm9pWlo3MitqaldlZWh1WnFyZWM3cmJaT2QvZzlvVVI0ZUNJcWZZSyt4SHkrZlgyaS94R3JXNTlaemVQbnJPZWYwMGtwUGR5ZGpoNmM2S1p5SFJla05tdmRjdHI1cGJSelNHVmJpMkloaHNUNS9ldjdodDcvbDdvM2daUGpLdTlGKzlSMmF1dGF1cXE2ZXQrMzJYdW10eG5Ob3BtUlpJMWsyUnBMc2kzSjI5aVdzVERHakIwYnpENFlERTRNUVNFa2NiZ2hHYmprWVJKSUJJL0Y3TU9XK0NYKzVRbGliaHhDbmtXU2UwUGVCYUlRYmpBSmJyK3pWSFgzOU14SU1wRGZlMitXcWxQN09hZE9uZk45My9tKy8zOUxmSDNmOGJKbkxNY0tibTk4L1ZQZjlaVzF6L1pFMTMrdHMvZkxQMHRzL1RXYll1dTc4MVNsd0F4RjMvWUNnQWpaZkluTTY5Z0V3TERab0hFcnhBZVdwVVRkMk1WK0hPL0Q1TkFDdEFRLzJvaElTMDJmQXdoOEt1bVdwNFowVnc2cVlIOHFubWZsdkROVDNIY2tYTFMwVkQ2Y0hMcVFxTmJqbXFDN05xZFlSbFF1dUVEVC82N2tKcTJRcGhyUmdtcHI0OU1Ec3FPQkRTYy9VZEtjb0o2MjVYMHd5M0o4L05CNElybTh5RVVpb2JISmtVazNXV2tmakpXc3VLU3BxV0NRY2RKQ3VCSUVSL2NQVkNOaFVTaEdOY2ZTaHVwRktTaXFBVWphRFo0WHRsSExTUVRtMFFpN1JPS3VleHp0T2dvMDdzcndSOG4zWXgxdEJUbHE0TTdTOWY1WEFZazRQa09aWkNUZ3JxNWUyTmdBNS9ITzU4bWhLb2JlaFF4QlJxKzJWK2ZuMFhHMFhDZkJ6bFdmZyticzJzYkdtc2U4aWhZclBVbjY0K0Vrdm9ub2dSSDBSbWw1THNLYTh5SkxjbVliRXAyTnl5bEdENUhPY2lhemZJbGlrQmlzTHpBc2t2L2NRSXh3UGZJRTVSdjFaQVJNbWVBeFdVZ05BWTAwS0dOOUJBbjlSZkJFZThXVTlkQjltUUZ0YUZXU1ZjWG1wbG1uMFA1eDhleDczczRMQnZ6THU4RTYrTXdGT1orRDFXUGhPR3ZPakxHQzRvSzNXQ21wUGJLZ083di9IT3E4OE9tUkM5VDM3ak5JNy9rcXRsQzRvNEJnWXFjWWdzenFCeGFSdUFrdjJJSk8ySkcwZDBRRHBiMUoyMDUreDVtZUhqYU04T2NqaTlYSSsxZzhPOGV0eTNaYytvSlZidG5mU1U0ZlRYMkZ6Tmx4WDBrZXVzcE9YSFVvOFhlT1lReE5UNGUvNEk0dG9rdklETjM3cExpRkxtbVZyZStrams2bnZrcjNmaFU5d2NOUlhrUGpVNDc0alBvNmp1K2RaZFo2WFEvcHpKeEhhSHIvWDR3Y0dobStjb1QwRHBYT3pOUTNhZGcvV0IrKzhzU2hZV0kyQXE5cnY0V3V5Vm50Q3dSTWdNYTBFNzlSS3FsZlNTSjB5cjdId0Nqb1NxcTlna0daSUcyaDBhd2pnbUZ2ZkU4QUl5NDVGUE1KNmQ3NVRYSVprbkhCeCtvYWxwUm1ZU0tUZ0xPRWtaTFlERzZyTXZNeTh6bW9LSnFpUkE5aTRhbEZ6bWt4M0FxT25pUVdoYnMwK1RqWHJtdFZPNkdGUWhxZHM4TWU1dmIzN0ZTVlllVDVYOEhYYThxdmJORDVPM3dXRXVJUzdhZm85bkZaK3dQR3R4TlJXeW1ldXhzZzg3YzdJeWIyUjJYMGJlK0FsVEdJdmlYeVFVRnB0WnZjRVNZalF0RU5OaTFJUHIrRDN0SDd1dmFzU3hsa3dLVU1ObVNlbEN5cUhFTXNnMmdCcXR2dnZuZEhPSXdiTDJKaUpMNTJsQ05oQ2ttenh3SzNCVjZCcE5sZkorUFVWc0pVdWtKamtSZTMyaVRvQ2JTM3FKZXBrdytXK0hId0ptNVRwVllUcGtCTGNFb0NySmZEelRJSm52V0lpNW93NTdHZDRIMDhSa3Nya2NHeDFQUnZUSWdHS0d3elBnZDgxalNrd1Z3eUVsYlZjQ1NaRzVRTU0xMktEc2NpNVlJWmt1MTBQSWtVWDcxa1I2SngxNG1XM2h6VU5kM1NORFRVN2RFYUNXbmt5SWdVYng2dzBWN05Rb3VXbldYNW9KT1JVZU54Z29seWZpQVpkR3pUQ2NkUzlWVE1kWXlnSW1lY0lNOW1VVzI0NFVMZERpV1RJYnRlQ0x0d09CT3Q1WmxTTnA3bldFR1dCWmJUaklVU0V6SnIwY3p3MVJFajdJUWphTFIxWDU2eWxiQ1RCaWtuck5pUG9oMTZCQjB5SW44ekZCWmhjTmhSalRkQmpzR21ESVlORGtmanBtMmJpZWpJNnd6VkdRNUNNVHlFKytyblgvaTg1K3VTeGQ1Vm9BdnA1YnY0WXA1b2pGUFRyQU9JdGxxdzdFZGhmcTlwVDlyVklyVGhiM0djeWNyY1crMGZCNWwwZUJVY3NOdnZ1RW41bjBlT1ZJOVVCVU5vQ3VDVlRSdWZpczRrRGc1dnMzKzhHazR6UVhUbVpQdTNsWnU4VTlHWlBpNlpaeXNQa25tRVdlSWhiT3VNVU5yTk5DZjZhVUl1WlRuL2NZdGhIcG5pSlNBOHd2Q25VaWpETHNPMEdKNXhDZUxhOXFaMG9PRXpIaEdBeE85Nkc2T2tJTHFJUjFlaGkreUxOZnh1blFZREljS2VpeHNmZGZ6Y3FSTGJuN3BZdmJVL2RkRzZlcUdOeGxzc1B3Y0pOdDk0L3hONThoWWhVaUR5TFJjaU9iVzhHNDB1TlFlQzhmNXNmQ1hLaE5UZkFOTjIrMGtZZ3E5S2ZLZzY4QWVKVndtckNUVTBXQTJCOGVyeEtxcThoa2l6OWJYZlVFTk1GTXphazk4U2hGY2wvbUNnK3FIRXEyRG90eE1IUTlYQkVLamhzMkVUMnB2emlHTldLMXZ5MkNJWnZLeXN2Zm9Qam4rb3VueXBMSjM3MEhHVW9kL1ptaGZxRjc2STNrOGwwRVQ1SUwwRGJCS0ViMndCTXYxaGpqaEFlVUl5c1pwaXVKWW1oY2FFVENvOWR0VU50NTRVMUpUcFprTWF3Y0VkbjBvbG1ObURxY0tCQ1pHem50ZzNmZjJoRTZmZmNLbzBGckdBQkdGd3ZNRmJPVHZyR2dtaGZSODJBQnpLYXBCaERSZ3F6c2tSN2ZVNnl3ODlaMDd1WmZOaGhmU2hQS3EzOCtBaDlCM1FHSzA4ZnJzdGlvQ0NSTUVPREZJM1ZNc3pXVm1VVDdGRlFkWldQSFpyR2xQMTlLYXRnKzNQY253QlFnN3M0NFE4aE9lcENlc01qYmc2dDJrTHZCNnBNVUVCYVRSQjJzNngzdmFWUUJqMThEaUcweVdUNTVSZnIwbEljTXZRYmZKRTBNcVZnVDlCM0d4NTdKbDRScEFBSHBSZEFtNEFYUUZ6UGI5K2p4bmh3cHh1M0NtNzR1Rnd2SFc3Y3gvS0hKa1JiZzk0TThPeVkxUlVVUmdXVXNZdHVwMUtOV2ZqWTdINERZTjdFeU81UXRuV2J6RlN3akRIaTRlRDZ0N0JHNEJLNTMvQlgzbnp3RCtPSmpOeVNydkQwTkdUSXVheHE2NmNtWTAzRnZjZWRHNXZ6ZmJQMWMxZEJ2K3QzVmQycEhEMWxISkg2dHZodVpmdDVpQlFBY2ROY2lJVFRZNXFhWlpoSWd6azZ4eC9VUWJjeU82WHpmRmNuWWZvYklaTmE2UEpLQ09pdTNEb2JwQzBuZi8xd2hmQWw4Qm55QXpFZk9CNDRHN1Vka2o4UTZsRkljY3BDdytCUFBCTXhoREp5dWhUTEF1MjIzSXRyRWxpQkNNTUpvZ3BZdEhGTFJvMWdkMXJTZmRMZUl4SmQ5eHpMaG16UzdtL1R3aHhJeXhKWVNNdUpBUkZtOVN5eWx6WWNjSnpTaFp0S0hmVkM0VjZLekZqV1RPSk8xUVdzREo2c2F6S0theGxzY3IxS3N1R0k1RXd5NnFzd3NaVHFUaXJqQ3ZvaEVRQ0xSUjBWcW5FS3ZuOW1nR1lvU0VHR05wK1BTdmxSVmFkUFhiTk5jZG1WVmJNUzlsQy9lMlBObkw3aFBwMWRXRWZPSUIyY2xwQjQ5QlpIT0NqODFFZW9PZEltRlorZDVTVDBLTzQxRlhIcmtweDZFa3ltejJlUlV1RjQwWmVPVUtucUFndmVnQzErVFMydVZPK0hvRTJkVCt3aERoRlVGVWJxVGVZU2dFdENhd0grRnZTS2dWUnJReGYwOVA4akZlZlBqVTlhN2RQb01aMzhFUU90ZGRtNDhTTjRFUDRHN2hEUzhtWmE0WjcydnJzcmp2dWZJMFJhVitKR252dStKWG82M2paalNjYVRTTExmNHU1QXNsYkJ1b3B5a2hTYlBYRWh2aStEVWdUcE1CVURrL2RQTEd2cEN1UStIcTMzTVFCTWVIVkhzZUZOVHRVRDluZzF2U1JJM09PTTNzVUwzL3dua0s1MkJUNHYvVFdBRHN3bjZkdUMzaDFmaldGeVFGU3U5T09NMGV1UTh2d2UxeUJieGJMeDk3ajhnSmFlenpmT0Q3bkFQWkpBZm51TkpEbllPWlZxNWUwM1E1WlROanQ1WTJoMTJETERHMmlHRGl5UllqdjBMcGNjMGsvanRaazNnZjgyVXRpTXRhRVJtT2NJVFZNaDR0YW9RU3ZTMlhUWnRWd1dHVWRveXpwZkNKa1JUbkhiRWdHRnh2RjU4dXhsOFJicG1XWnJmaER0eWF6VWxHM1N3TzZhZW9ESlZzdlN0bmtyUThsQmdlQlBrNEN6c2RFS1dhK2pXRUcwZHFZMFRQNmpCR1R4RUdHZVp1SjFtUGtuSEhMdEtyby81NlBuZ1VNRUhaZmUrMXVBU1hPZnRTS1dKMjJodXRubERCdzV6dFYwVTF0UzZSRFhRMUpKZEFLNkJiK3llTW5jS2tOaDQzV0k3d2hqYUh5aDBLb25HT1N3VWZxVVZSNFhPSVR4ek90YkxhVmVRQVY5SkY4eERRaitVZFFBUjlJRGcwQjQvZHcwUjR1NElMZGNBTXVWZUZoWEtiZkN4Y0hpK0hWczJjYjExN2JPSHZXanRpZXp3UFZzWlJBaEdKcGR2RW8zVjczazJMdkJDaTQvNndhaWFobjFRZTNWNVMrOFRLb2FlYzBEZDRCRThwT3ppZzBidUFyNE1zQkRYMFBnUkhnejQrMWluT2d4SnVZSlI1MVdMeFFBbyszMTdWY3hFV2QySXFoS08wSEJSWmN6Ykx0ajdIQ1A1MlQrS2pkWGduRkJPbWNsTW44ZC9Bb3k0SS9ZUVRtVHdEcnoxVmdHMVFjYVpEOW1OODRKcURXbUdNNm9PbDV4MmZoeURleVpTOE1OTyt0d2VrMm1mVVZDM09sYW1tdUlLS05YSVo4aHhtUVdkSnM3UUttb2F3U2VBc2NFM0RraURDOHIwdzJsNnYwNjZ0bTVrL2plNXlteTU3Nnp3ZXFXSW91WG9ZZnJidWpqeEFHN1RwT0RBakVPYVNUZkhCYmo2RnpXODdEU1dlbjk3WFpkMmpoVXI1RGwrVVJmREYvb3BYdHk3S0RiNUd4YldFQ1cveU05bDZHQlJ0ZVR0WjN0bkl2NzVEeEhZM2ZrenZudlNQbjVBTTFJc05kUnRZdXBXMkJIV3AyWjFWcis1YnlYM1pXc2tCUHZnUEZ5NW5rKy9nVDVOWlA0RnQzazkvdTIvYVNIbTdOOTBuYyt3UkI5Z2pndUFkc1c1akFFbXU1UHNkUTJaV2FFbWdJa3NhUXdLUW1SWXZDUXkvcWxVblVJRUZ6OFhvNERFZ0JrZkJPcittQ0t3d0pCNE1RcmtINC9tUnRwcEZPc0l6SUFzaTQwY0g5Ui9aVm9pNERBWXMwK2NTOUMzY2psZW53QXNzTDdHZzgyVGg1MThuRzVDZ3I4T3o4NGQxM0w4U0x4V2F4T09CV0t5UHU4TEE3VXZsdXFwWmkwclgwWUliakZJMWpXR2NxTzNERkFET3dieUF6NWJBTXB5RUJKd05DYzNmUEw3MHFnUVRSTE10RVI4YnVQdGxvbkx6N3hpakRacEZJbVhoZ2FmN3UrWFY4NjJZeDRPR0RZcXpUNGNEUndDMkJYd3E4emZON2h3VHZIZFhNK0VSWWdIalFRVTJER0dBeFJoWmVFcVdxV2ZhSXNsQU40bjlxOHN6U1lOUW0rU04xeHVZRUw4YXZsQzlmcHZjOENBUlREc2ZDUkRqbFpqSzhsY3lrd3UwbnczRStIRTZZcGdDalNVc3lRaUR0RGxmZFlGVEtHVHFNeVNLMDNjUm9ERXdPVEljdHdZbUlwWnhpcEN2MzhCeHJOdWVhSnN2eEZWV1JGTVZVQkFKTTBic0J6b1RpU1VWVVV1RkVKRGRoSjBkU2lYS0dFK0JBS0N6S2Fpa3ZRaVA5a21yQ2xFUkd6MlZ5WmlZZTB3YWJvL0hwZ2NpUWxwNDBLd3VxNHlUTmNIdGQ0aUx4ZUlTVDFnUjBiL1FFbFNocG16WTJ6NUZUek56WmkvRUcwSzhVdm1qMkFHb3ZQVU1qOFY1ZmlHZFNic0d3TmZtY3JObWJPQVI2b1djTzBWaS9EMG9XQUtiRXhRd0xqMFNXRWZPK1dZemhQdXN6Qy9WTXQzcW1PS0tWbEltZnorWmd0VTB6RzZDZTR1RjdUdUVQOWxRNWwwcXpFbXV6Z0J1cWwzYm5LUlFqbVhJSEdKc1pkU2xUdjBHOEM2NUtsaXdHY0JHa1BxYlRyZHd5MllrT3hUMDNoVUNYQzJ3alVDQnNXdmdicDRNaHhsL0Zmak93WXlFdWVmb2Q3RGUrUHR5WTIzUHYyKzdiTTlmZ1pRWWpHZzVPa0ZGdVlwQkR1Z3dqbis1aHhudFg3aFVMZUVDODkrRlg1QmlHYzNpSlNaeTRDNCtJZDUxSU1CSnY4OHgzZXh3ZnUrOGUyK3p6cUNZWGNLUmZiNXhXejl6WHBqNnhLNWQwMU5nTzU0aVpiV1ViMlVlMjkyK0lZMFlGQ1JwV0VNd0hMUU5LMW16N1BNRHo4R0JsYlh1UEJqQnZCVmVnMUQ1THFCaVdKYmdTdE5wVk1GK3Rkdnl1Tnp3dWlkMjlFbE4vempCNENNaHVEdnZha3NxQzlTMDViTDhacktEOHpiZlBIOGU1T3Q2N0JCbXdzVFY3MVdyN1RJVVljYW85eTRvM2IveEYwdGZsMFpjMkhGZ2kwVXNOR2xpSmM5NHo1dEFHV3ZPOUoxenFQb0Yxcmc0V01tcm5uUk94aDBvSHpHa2Q3b0x5ZjVPMXlxUW1MMUVJelNWWm0ydy8rZkhoOCtobnBVckJOYXNKbXg2MEU2TEhUQjY0UjBiWGF2TGprNVZIMFBXRURVaVRINmxNbmhsKzkvbGxnKzVZdFJPVUV3aVRHL2prNDN4bnpyRkFZb0JuQXljNjMyWmZzOTdrWG9MMFNQeGFrQks1eFJhRmRBMUtNSWlQREhuMlpLOE5NdUk1MHozZlpZOWlNbVNWYVpYYkY1NU1EYmFYYVYrVHBTNmo3SDFGVm1PYjVpdHh0by9UTk1hRVB1ZWFqNEFJdmtYN0RGNVdLbmg1QnVrclo5Y0dVeEhhQWExU245UXpCd1hoN2h3cUxWbVRpY3F1endIRzZ6c1IrR05VNHVxNEFITm8yTTZqa2IxTDIramh6Tm1vdXpSOUNDa1BpSzQ1NFVGMTByUFFZRDROTUY0YkJhYnpUc1gwaWg2UlBiNmRpL0VrV3gyY0t2OEJTTWJHSFhJajNMbTlwNkQzM2w4Z044V3orRVNQKzZUQzZKQ1RtWWVqRGcvcitYSTZML0dLQU9hS0kreXVvWkliNTFrRFZXc3V4VEZRNG9TeDVDN1hzQXdRMTFpQlV3M0pOTkdyMUVPSm5BTkZYZ3FLbXA0eVRFaytKSE1zQTJWZVRDVU9KdE1pdWlITEtqazNObDJza3Z1RnJaUWFSSGVVT2FHV254RVVyU2dyUWxpUXc0YnhXUWhheVlHWUJaT1NibVlIckhET0RpbTZ5SVpFVGtYZm9hN3BHVVdHWVY2V0ZNT1FVVytHbmhvMGhpVUJpVGpzNFJESE1GRGh4WFN5a0ltbEJQRTM4VU5ZNkNZYWpDeWhMQ3U2YkJvb3k3YURiaXRySW1SRkFQam5aVmtkcG5lMU1SRnpVQkE1WEJpam9rQTRsaXJ5cU1GdzZSekJmVkE3OGlJYmdFZ1hwZWdQY1RSMjVnTmpTUEp0QlFMWXc4YXRPZmtXVXRtd1Z3N3d0OUcvNlhueTRPMEdScXZHTm1yUG9XQmpvN0s2K2d4ZXRFK1RkS2FLZmdENnIyVFdNcG1WK1V3Ry9aMUhSeDdiMkhnTW4xUlpYU2JIbjFqTHJHemdjeko5K1AzN2NUVEt6bk9STGE5aDlMaitlVWl3R0h1QStIOWdndXlXUjFEWjZXQzJuNkpzR0xLcmN0Z2d3a05EY2hnZENVaHBSUXF5RXBmZ0FHTlZjNUZxY29IaTN1ODBjZmxDM0ZLQ2tPT2hnRWNxeVRVa0ZVZzhsRlFEQ2lhTEpFNVc1cEJZVTltZ29QdjltUDlYWVo2ZFMySCtsMy9HVXU5TUFiRHZ4WlI4UjA2QXYzK3haYWR4K20vd2VBSnV3alk2Z1pwTmE4UmhSM0E2b2JoKytjcTRCWGlXL1paejhmSTNQZVpXdi90NGN2TGFqQ2JhUmRNSkdURkNteFFMc2tMSnlzWmp4eHJVZmRhVjRBeVViRFhKMkZET0R1aUt5UVg1SXM5d2tYUjJKRE5uT2VGZ3l1UWxzREU2NWt6b2lXQ3lvRVJEeVFvbFVxb2tkWWNOTzZYbVNMazQzSzVTeHFXeklwNitWdEtPYWdCVmtGWERrVVVIM1REQnFYekJ0Tkt4UktZWTBVSVNGcnJ3R1BRRjRzZFRET3hDK2pOdERjU2NTcWY1ZkZoakhZUjkxR1BzMjR6ZU5EbEdSRWFkZ1BhMHNDN1I4dkgyNGRacEVlYjFOaC9rL3pISEtkeXVRcmFXY1J4RFZ5VFltcisvbUhaMTZaakFzSVYvNUpuMnZkclF4SlZRSEdVNUxoWXVadUtaR1VrMTk1WWpETThNTXd6enJrMHpLT0I5VVZTMGp3M3gvQUVBMWFnNWxLOFZLbGtXOWFQUjBYUyt3cWpjeU1lNFlQcytSWlJCS2w1Z0pNRHZTa21RdlRJWlNhOU5wUEZNcEFER0pnOVBvcjkzSnNvSjlPZmJGWERNOUFlUXpOSENqS0l1aG5QdStnWTJQWGhNREpHNmVSTVB0VVdNRXUwZ1pRejFVdDFrOVd4STAwSm5jVXQyZ21IZHlvZVhYMnFwdXBlK2N4V3BmOE1qMTUvZ2J6NTd3VnRuVkRWaG93dGtpR1Q1QlRmQjZUY2ZGRHNiMWp0ZnZtWW56dDR3TldNc3hJK2RYZk1UZnY2LzdlRzhrUHhqenZZZWQwckJ5eWtlMVRadkV0SFBKck50TGR6cmRwUGczS1VLMFA1cFh3SEErczlZQWpwbitXYndwNFFCbzBvUU5VYUJod3c5WHFMSUZCU0xzbGx1dXRpcEFPbXBjd3cyK21QR3VUUVFpaHFGVThDTmRocms2VmpQbkk3ZHNqb3hOQ25wZzV5Z3lLOUZBMThPeHBUWDZjellxQjdTMU5MaDRzU004UHhYak52MEFWVVRGU1lLZ3NuRjlFUWl4a1FpSTdPTEVOSWtlSE1wR2M2bERnL010aGdBNFBYb0hsVjByK3VVa0E3UWpsZzBmK3Z0N2Q4Tzd3dVBHQkZkWmJoUnBBUEVJbGRYaHRLRElCcTVlbUF3ME1zYjdhQ1JjQS9GWGlaMkg0eFJnSmt5eVJRc2ttUmIzYmdNakdWRzlBcklkbDFnV3hZV2F5bWEyVThPUTF0UDg5eko4bUZWdCtGaDJGWnZYQzZkNVBoWDRIQ2tIM3BITHhBR3ZWZWdCRDJwZWdDSnNCWHUxc0hycTZoRDNRL3RmN2x1NEZhTzJHTUc5NU5EN1orU0xRNXdWVm1EQjZEdDRSbTBQWDZHUzg3U2diOW8zMFo2OGQ4bFd1czlaQ1I0Ri9aa3VRZ2hXUWZYRDd6SjA3Y0RmTi9ZVk95RktrRFBCRzlDdDN1VzNDNkxidmZINkhZT3VkMy9aRGlqQjBRKzFoc0dSY3JDckJHK2dFeFhLL0oxWHRhRFdYU3pUZXF0eWl3L1QzS01VZW9Uc2VlSndzNlFYSU9WcEVXZS9xeVZiUDhMaTZPd0FPRFliN0FjL1M3LzQ0WFBNeno0RTFTUzNSZ2QwL0tHRHR5dGhqRVhXaGkzYkxvSE5WNkJiUkc4S245K0MyUEhkM3NoSkpnVU8xTmZZY0xRVEwxaEtZb2ZubzM0cXhRamN3N0tYQ28wUHg4YXprc21FMllVNGJqQ1NybGhLWlA1MEVST01sbUhVZUJ4R2UwYXQ5UkdZUzl1RzN0RE1RRjhOWS9HWXdkcHpubEppSVZXYkRqUDgvUFFYaWswVlBEcWNYUlhQTFU3amtGc0R6aThxbHdQSWJwN21MY1A2SXJTL3FjakRoK1Vqd3Q0bnlNNDE2VDNqUks5MjgwTjdFS1hCbEhHZGhrNXQ2S0k0anluY2ZPaXFGUkc5MUg3NHA4U3V6bU9ZWVdkTUNrNng0VHJBbmJpcFBCbzY4MitFTnZFUHpSeU4wd1FVWXV5Z05zb2Y3RTl4UWEycHpVcSt4TXRYaERmeVVNZGZLQ1JMKzI1NzIzM1V0WnZHMG5Da1JpeDVxWGlMUXdSODA2UlVCS1N2S0J2OU5PRW5RODdLYmlYekU5NU04OHkrRkdDaDJ6dW52azk5eTF1bTYzcGxjZ2JjWTF2NEEvMENjamZYcHZaTm1lNzY2eEhkckZCN0NYY0p2eUxGdEhtZDVaYlN4aGFieXZwc0V0akxyRXhDT3MyMjR1cGs2b1JEWVVuNm9jeC9VeVpoNWtxQzRjZ3ZEY1hkdzFqSjduMFNEZzFMSmNqQThPUWY0NUVIWndVMUxmUDZ4blRINS8rR25XVUh3eGtVYyszZ25KT3NIdUk5ZHVEbnlmMmJpS0owV2w5dm83MVBBOEpoOEpMNWlrZU9aMDlSL3JldGlHS3FMQ296QTN3bmZUZ0ZZT2YxUG5qSEhlYzF6K1ZxQ1l0VkxjbXA3U1BKS3VKVC9rSFBvbk9Tck1LWjZLRDF2K3U2dWpiUldxUUtDRjFqY0FPNzFGQllxQStzRzlnWGhRRXpLcDRYQkRFZVNTTFplT2NoRzRIVmxCNjB6RjBibjBBOVpzbStwYmlTbDhZSTdxcFB4Znc1NmcrUGg2b0JLN0IrQWxGVWhzdWRkL29BdklUbmtIOGVqczhJM3lKMUVzZktDVHRCRGJWVCt0aXRjTUVCcTRZZUxaRi9UdE9jOXdwNnFwUmV4WVZSbWRRTmZFS0cyM3YxdEhtc3pWNjFpbU9PMDNQYWoyTExvNnlDby9xN1AzYjFkZ0dPdDZpNTJLMnhqdW9BMjR0VVoyS2NDS3VNNzU0ZTJTcW1xaFJySjA3V0pJSC9KQVd1bksweU9QS0U0UGJWQjJ6cVIzOVFsclJ6OVJRZnE0MjRZMXgzZmYvbi9EMisxOXc1OVZ0ODRLM09hdjdndnZlcGYrZXRyekxiYzdwZVpkK20vODIwajNlRjBnRkpraWt1RXNDRkxFWEJCN25XdlMxNFhod1VxTGR3Q0ZlcVVTNUloRDhlYWVJQmt3WHVuakVMTlYvZFYwdkozWk5zS3dzaEN1aGNubDU1djVFV1YvWHF1dFhEZTNPVmtMQnVCMjJtNFBMN1MrczY1WGdsNzhjcktDRGY3U3V4WjM5akczcFdTY3ZCMk5Yak4wNm1PRU9PSEZ0WGF2WTZ3OEtVaXc5V1VyWW9ZVjhXcFVlL1BLNnp1QkxHWFJwaGRxeVBrY3doekdpalY4Q1lvY2lSZkRNVFJjcFE5blJ6cUpzNzg5bEJDNG9PT1hRYUN4MmF2L0RLT05udGVyWmsvVkQ1YkdvbFlsRW5kMzFHNzV3RnVYMWFrN1hFKzZRblZmVTFQQm84Nzd4SEhjTnl1MVpsTnV6YTVLU0xpNk9GbFBPb2VGeVNFT2ltZGUyL3BWNUJYZ0hHaVZxcUcyRnUvT0xYVVkwcHpiaGRsallLVEFkd2FlaXlNTGdMYWpSL2xUV2xrU0I5NWs1bHA3aTJSOHRhZkpQVWJ1T3NQeFRQY2RtTUduR04zV2VrblY4bm5PL0tXczZIK0UrNysveTh2UUF5bFBXbDN5N3pielJaUjFKQXM4UmtTZkFlUDFOSEc5N2h0RXlzOXJiMWxEbUlqVFB0Q0cybjBOWjNLWk4wdnpmMHR2V3VRak8vby9wVjZCeDIzd09QOGJGQ1FoSVIzbUIyZVBGbVk4RjVwRDJmQ05HQTZiVHRXay9XQlNIQUpVOWV5NlNWWHEzZFMrcXlkdkdoNGxZWVJIaVBNZ0s0U3dPdFdicHhWWUsvQmdOcEpoSEQ2Mm1lVEU4d0FtOHdLWFJFZ2hLa3VYUnI0c0Vhb2FETG9zUlJ4MEJ5Wjd0ZjEvZ0lMZ2RkY3NKRHNtOEVQeGdBY2xrN3daOGdtVlBBUmc4elFzQ2Y1b1h4Y2NFL2hESDg5d2hYbmlRNXlvWVJxakM4VXNjWTdPc2dJVGI5anJQZ1ZXRzU5cS9JU2lLQUY3RzhXejcxemllMkxKOXY5c0trdHJtMERzOWhDTjdLU3drVWxZb1B5Q1dYUVdQSUtEbDJMUm5tZ1ZOdmxVVG9OdWtyRUNkejhQRmVtZkROMjB6QVE0eWNqS2R2T25ZR3hXYm54U0VzTFlvU1J4Y2dyTHJoT0xCVlZsZGFUZXExeVlUU25YM2xRZHRLWWg2SzNEaXlsZCtacVV4NUJrTGxwT3BsTVJDYmtXVlY0UHhrT1BLNkhKT2toYTFzQ0JNOHJieXhtUDVsY0hteVZkZWVRS2dQakVvMlFldjNGMHRWdy9GVS8rRGVtRjZjeEs5bkptemdhT1h3VHpSSVlNWlpUd0JzWVk2T284L28yY2Y0KzNiMFd2eDI1VDgrR1oyK09BUWV2SGMyRDZXNStLY2NJVFo4NG85TE5yUlBObGlCUFN1TCtyQmVKeFNJSThOSFJ4bUJYUTV6KzZ0Y3J6QUxxN3VRUzg0d1FwTTYyUVQ3ZkRrekdmQmwxQS9qZjFnaDdCM1NHZkNvZVZiZVhoaWFmZExRUmxpdkE5em04SXQwMG1HSUoxeUFJZlptVjIzblhxQXhEV2Z1TDdlWUltZThBaDc1RzNMYUIrMzk5NTlkTSt5aDFwQ1p4bmUvY0FkdCs2YW9VZllSdjM2RXlRdytwcTNIdkYyN2J0M0w0ZG43V2k4T1I1bnFnUXpoYzZOOUFOeTdvaWdSb0taOGFmOHIzT0hEODk5MEF0ejliQ2xpQzhaZ1d6NStGMlYwYkhLUzk5NjlSdXZndnd6a0UveHNFVHlRYlVwa2l6OS9jZzFZMFNuZU5hZml3WDlnV1M5R0ZtYWp4bE5QVm1hWXo3NEFzMVpxZXlCc2hNaXZwdVRBOUpIU0U3WTBkSk5TRlAvSk1mTlNnSjhYM0RtYXBhY055bmFZTldiLzBTcWZOU2xBRWhEa004TDdIdFpnMy8weWxteUt4TUpiR3JuWnNBSmpIcmNrZVZOeWpkcTRtVW4zN0MyUm9DN3RObHZzUUtDangzVDdQYVAvRlo1ZHUzZmFkc2UxT1N6c25ZMXczMjRVSzh2MWVzRjJrREIzREd0MDRwVmUzNTV1YjFPMnpIeHNqcDFOY08wZjhwd1QrSkxsdXByOU5zSUJOU09mNk83aVR2eTFZRTNCMzQ5OE43QVJ6bzZmcm83ZGRqeW9rbWRiS1BjeUxMNXpYcGNyVys3Zktuai9VQUNmckxXaytwRG0vRjJOK2pkZW8rZzdnRFR6THFVd055VnBITG1oVUFHekQ4eGorZmY4T0xsbmRRdmJiUHZzeVRhRUM5K2k4d1N6OC9UYWFybnF2Z012UGl2ZUM4L2ErQnRnOFRXUy9CVFFjbjlIVnoxditOS3dVOUJhU056OW16bXpBc0Jlc1hteGNwMk82c1N6T0FIbzhVemVGZUVUQjFHTW1qZ3VFQm9JbzN1M3U2ZVFFRHNlMy9ZeC8xbzRIYkMrbnFwOTlaWDc5WmwxdnYyNzJHbmVqOVBTSC94NGxVNzFPZnRuWnJjUTJwMjUvcHNuNU1naVdsRkMvRFl6dFhVWDJVNHZ2NkZuM3B4dUYzT2xYc0M5NkYyL3FiQXJ3VUM0Qkp0Rmw1aXUvLzhZdFpENnZCY3pYMGZZTi9SQy9zRzRxNnloV3U0aFB1RC9od3dEeEo2MEJlemFQK3ZGd0twZW1vNGYwQld6SllTQzhPWlBYWUN4L08xTDdTT0hqd3F3V29oVVQyUGtTRE9nMHJuTXJEV2JZYjA1WkRGZW5mdlJuZHZ6d25ZaWJvNExiL0JMTXNaSWFpY1R0Z2VkZkpxNWd4NjZIeTFWQysxejNidjR2bDVYdkRzTUxsQXdMb0lCcW5YSFQ2M0xiTG9uaGdHcWl2dEFCNzZCTVd4bzNOWUhvNytLT2FHTHZiRlExcFVtcDRGSGJPVUI4cGRJNkkwdThtcmRCTHkxUG1PaDE5emtaajdhaTV4UlducWxra0NHeFNQYUJ6M0d2Yk0wTUhyTUJvMld2eTBBeGZTL3Vzd3g3MmE1YlZJbkp3N2VjdFU2WW9FMmlPRDBKQjM5dEJCSHh1YjVEY2ZXQ1NvcHBmaDUvaGl5N0MzZjZ6ZGUvbmwyWHdWVGw1MjJaaE8yVkk0Z28vSGhucnFXOWkxRVRvZDNiellhNUVEejcrbS93SHNhNUNDNGJMdGM5MW5PSzloKy9QL2FzeEZLSi91bG9IMEF5KzhjQTdsNDZPZFdLWDlnU3RSWFI5Rkdza2QySjdnU1orZDhiZ2p1T1U3ZTJ5SWJkdXdBOGVBSnprN0M0OUxHVlBqWmgzeXkvcmVKM2svQVI2blBqSEhxWXRMazY0TzB0WC9KcUFmYW5xbktRcUlCdGJiSzkzLytVMVhWdWxLbzNjOVExZjBieW1vS01FVnNpQkJzMzJiSzJkV3FpdGdzdmVLYmV3TjNsd0twV3ZGN0t6bEVwNFA4NmRTWUlPRXJib2QydGRhQXh2Z1MrVldHUWNXaFczd1EyeHd1SDltdVZ3T1ZjS0N6TElUdTRqQjRkenlZTk1PMi9GZ3FKTGRQWFRWK3Z0NzdBMC94UGFHQTF4bThOYXhLMkpCT2U5a2RjdG05bE43dzhjZmxOUjBmaUZrSjBxVDZaZ2tQTGllMjJ4djJCd2J0WENaZXNjc0tBdDVENTZyMWZEWUE4b3dqSFN1aWZDT2lzWU1VbmYycVRvK3BxdjdzUHBUMWhZNGJrRXJKeTZtV1pBM0lPUkVkSUdJV2dWV21vS1pJUHBMOVBqUGJYZ3g3ek5lMjBRVlhLWk4xRzJWK25QSWRwUU1QOUdaWEFhWXc0cTdMWEgxNU9UVmlkczRQREdNMXBLRTkzZ3NadTN2MGJXM3ltQVNKVjJialdGQXExbE5wOGhXczhrazJnT1dOakdlclhkVVBnL3ZZOEd6ODZ6UUNFcmFkblpzUGNMbTF0TnF1QkE3TXZxZmx4OGZUcGczTVBsaTkwWGk3NDJaT0lNYTE0RnFJMVVZcVlUS0RoSU5tSUZ4MUx6T2FCdExsWEVUS1VLR1hVclBERnh4NWxXS0xLaitDM2tMRDBVN3hMTFgrZStSQjdrenFNbE5zYnFaclV5UFhCbFZsTHdURHhvVzEwU043b3hXK2NCcElBZFRtVjJHbXl6VWtxNHNnTk5uL2dFcGhSQU8rVzhZOG9Sb212RTlPR0tjUVB1K3ozWHFwS2RHcU9zV3FaQW1VZlIzcUpGYXcyVW1zUEhyNGYybllyRlJWRWdoeUFtWjNINWkvRHAvUTMyM0U0MWtyT2hZK1ZEOTVGbkFZT3ZYTlZ4dS9MN202SEJLVmZMMmtKdlFkZTVxYXYzNjZoclFRdVhoUTA2cU9McFlUQ3ZTMmxsZjk4UDREZ2tjSDJMbCs0THpleHhhU2xRb3BLUFJwbWtTL0YydHpSTlZEL0t2bnpzTStZU3NqVDZGTnVjcm81cWM0T0hodWRmanladlRIczdENDJqUC9PZDVxTWtmSFJoRmcxUDdMYU1ESDVVMXlIOSsvakE5N0xlcHo0Si9BVjlEbWxhU3NHdTBURlEzUmM5M2hQcXVvVzhCMVIyZTZZWmxTRjNpaUJ2R3ZlK2NLVmJBcTB2WjF1aEVLRFNGbWtuTzBEWkNvUTNOcUc1c0pHSWpReFBqZzZPeEpNak10UCtzdUh2eC9qdXZXMnFPMktMbzFsb0hqOTZzUi9obFVWem1JL3J5OGpWTGkrTmpqajA2dm5DZ0owOHU4UWpCYjVXUVFIaXNyMTBnRzVvN0w3aXV0Y2wrNThjT2Y0UG1KNWRxVktkQ29ZblJWclprbko4WUdva2xOamFTc2RIQjJ6K0NocnNiV0R5YXNUUHZRQXVYQlhkNzJicjU2RUVrUzRxaVBkSmN1dTVPUGRMK1pXZHNmSEhwbXVYbG93Y1d4a2ZiZjhoeE41QXIyTm0zay9IUWE0OUlEdnNxeVh1Z0o3TW9hOTFDV0RUTGtCYmdCMzdHdEM5YWZtYXZKTGtiSnptZDZXYUI3ODBhK0FUTmlFMno1ZnNHZjVGWlE5OERSaEM3T25BRFprS2JBK2pwamEwK3daREFzaERNSDJvYm1TQm9RTVFhUkp3WXFWa2dWeTZ4R0lDdTV1RDM0UHFOdGR4eUlmanZCelhlTkNjMXVhckpaMlE4V2s2YUpxOGRET1dMRGR3TXg0dVZORCtTUEpNYzRkTURCWUtJM1NqbS8zbDFkZjdDYWNNNGZkNEtuZ2xhcDgrZE83MXZUczJsQlB1TlhmZlZOOXBDS3FmT1ZjTFVSS0FiK1VTcGxNZ2JPcDNBZGNEckl0WHJDNEpRK0Nmc3hUdC9mR25wZUlCZ0FtMFFYV1FmS3YyeHdFMUk4bmdnOERDTkVkbUJDYVhIQTUwaXJPYVI1QVFiZVJKTmdQbmo4ZEx6Uis2RVYyTVJNTzkyZkxLSWdiRlJLL1pOYnJZMnE0RTFadFZ3amptcFF0YTk0R2FKdnpSUnB4NGg2OWNIaDJ0dUZZMEVhK2lmcUJZRDNxaFJrT0dCTjh6VGpabmdZTFNRUVBxYWR5MWFSRG8zV3I0L2hlNWZjYk5adDlMVkpvaDdiUHZKY0N3NHNvWkhIdnhQSVh1OHFPNTVlT0FDVGQ1aHU5RURrWTdXT04yOUNlVzhwWFVyb3I0QzErK3RnVHNEcTRFSGlRZWJOeWoyZ3hFU0grR2V1dmNOTjlQZ0lyWGJ5bnZBTTEweHd0Mit3czhOemM1ZU56dnJhL3NHcVF6UXFlWDJPVndWNGpaMStqbFUyL1hob0VPMFdXd2syS2FPd1dsODcrdG0xMGpWZXQ3dGozZXJHTjk5dS9wY0NjZGlZWHBibmoyK3FXNVBiUEovTndNUnpLanBvMC9tT3pJVXhqbko5K0FhRXRjYUR6bU9Zdkd0RUpqUWxiRXN5R1RIem1mSDFzZStiZ1hiNTROV0ZjbVo2K2kvQ3VZcGRHbjdYSFlNblZaZHBoQ3l4T1U5UUQ4eXV2VHRiQmdqNzMyQmdjQUlHcVgyVVlZT3pBU0R4TXdzaGo4UTlPNG40OUpZblU3MExjeVdzOUNoWWg0eE1QZWtlL2N6OVFOdkVteWRnUzlwZi9jbGtORnQ0VTBIY0o5Z3hkbDRDTndkUWlzTGJkL2VmbmNjdlAvVFZHaGVwYXZ6dnEvN1k1QUoydUtERDRwMmtJR1BrYzdnVDgxSXhQeFRrcnlBaERGY3FwMFd2dnhIOEI5R0FrMkN0WWdrMkhJdk41NUZvVW5yNVpvWFVrUlkzMUFaU1FCaXFZTlZXdXMwUjNTTXFiUlBpMHhRSWxFcHkxZUVpczJpOUM0SkxXM0E2a3I3ZjhoZ1Nnd3lJNnplZmkvVktmNk5yb0x0YjZUQktsZ2JFUlZTZ3ZidmhCckZZdHpVZFJPSGNsbThFcW9xNGprbDFEN2RxMHM4dVk3Zm0rbnhxcndQalRiVWYvK0tEaFAxTHdWZWgzcStYdzM4Vm1BOThLSEF4NmdmaStmSzRwZzFrNGppQXJhamJKcTRoU1hpOU5YNW9qc08vbHZvZ0YyNnlnbmJITnA2MWM3M3FXM1owdzJLdTFPS0xLYXM4VVJocmxDZHlHY2lLU1l0MHJtd1B5YXJSMExGdWxWSEg3WW1TVk4wdFordVBraFhBM2loU2N1YmRtNCs4ODd0dHJ4VHlwdFc0TFFZVVZYTEtjd1cyMzhDcGdvMU8zc2lJOUVadVQ4bXEwZXNlakUwUjUrWjJXNWwwRHRKRnpsbGZydWQyKzNETmtyTTl3c0kvMXcrVUVadG9CcG9FZXc0bjEvSEc1RjBCdk1pTlhjekhnMmRBMXNRRGVCV3pZR3Vqc1p5MUM1YXJsQnFsWGNEZktRR25xbTQ1cEpyNWxXTHYzZkIxdlZLcTJVdi9Lc2NkRjk2US9MN3poSG5hSGl1RnRzZks5NWpBUDBhYy9TZHNmMUhKOTUvWFdFQ0JKWk10Mks2UWZsZkYreFdxNkxyOXNLOXZLWG1UWGQrTG5uRFg2Tkx3V3NuQ3JHaisyTlhmOThZTmE4eG1CUG9QdGRkV1pueitzWVhVSHQrRTVLZlVoaDN3K3FkRmlHdWxyaVJhaFRPcHRhd3VsRG8va2k3Q1FuM0ROWEZpY3FpWVdWbTQ4eVpNK2VQRVY4Z2ZJU21VQWNPbHVzSis3aWRxTnR4Z0JVU2RES0kvLzZaVThkUHRjK1N6ekpoYjJBZEJLVW1LeHVWRHBjU3l1c2FSUWpKWGlJcjFFR2lVNXIrcnc2c2I1T3I5ck1XeDkzN0U3ejVrM3M1MWtiTi92ZFo5Q2R6MitVSnZCeWZjQTl4MExxSDBxUitBSzArd0hJMFhwTndoNDRGN2tFajlrT0JQOEMyaDFFR2t0Q1Vrc2E0R3VZNHhmTStPQll6akRzR0lnclM2VkVrUS9hQUVwYzJGWExyQmlvUXNVN2dZdXNVaUtacHVSaVpvWXdPUUZldzNUeE91V1hmQldiT2M2VEZmdDMwMm1halhNSVJkN1lPa0liTmdkeUlPV29tSWtZdzdxb2dMT3Vtb0daaldWYlJnZ3FiallDc2U2TnA3bk5pVlVWdC8ybVRGUVQyYmxrVXBaZmoxRnR3Nm1HeVR4SXhZeDNIeDBYV2dIZUpJdHdYVkcrVVJXbHFRUkVkdVNKZ2RuUW9za21VK09NVFBNdXh6RFVDTklVakRFUnB3Q3ppalJPY0NvQ2hBMDRzZ1M4OUhFa0RjelpzY3B3WjA0TVR0allVS3NkZ05Ca1ZvMlhnWmppVHp6bkhpMUw4UXp5SGZnMWo4MHJsYk1HVWhNT0M4bHFvQXBNMURMRHZPbEZndVlab2NOZEpTa3dwNHNRQ1lIRXc4RjBvTGI2TXhSdVF2UjV2M0Mvd1FrNUdaWHBZZ1NsbnUrOEhYUHo3S1hmNVREcHpmNzJJMHNENCtUK2c2a1cvSCtCL1A5WWxzc0pmL1B0WjJTNVBldS9uZzhtVC9jOEhBeGxzelpTMTgvZERaSWJKVFhNY2dWWWZHVXhyRTNSdlR0aXkzVGU3MDc5dGQremFyKzVHaUs1ZEtqbmZSZU11RUtwNXZMaXlBelQ3c2phQm53VTRwdjdSTnJrSWZKZEVrdEs0Uml6UGQzR1IvVmo2UnQ4RWxqODl2VlZwNm9OQjNuNGY3K1FiV1NjL3k5UWNERWJObks2NjVoUFl0SXFWUnFROFBtRzZQVnRudDAyM1V5dGdmbVhsL01yS1doV05NTjRKYUlFR3FtclBWbVg3ZEJXRGs2S0wyeHNyZ2Y3NG96MUlqN20wRmZNeVpneDZLTDUyQm5iWUVRb0s4dS9XWkJ6WWlWK1NUWkx2N2t0MlRyaVk5Zk5ISWc5cHFDY2g5dkNTRDIrNzE4ZUFZT2FSRElrdDlpL2JNamZpK1ozWHNyMmxLR2N2Z3JuUThWaS85RGtNYXI3SFNLSGFGS2VVbGhCOXdtcjdFRWxTSndlUzlJaHB2a2MybnNicHArbCtYR05mM2JaOEg5eTZDeWZiRzl2dkQvem50UTMzY2tBL2Rtb2JIOTRtcnlpNXR2M3VpeldPNTdZMEpkekFmbVdiWnZkdXJWZFg5ZG9HeFVIdFdEQzNMMmszZEhoSG41YldaV0IyN0ZDNlI3YmJxZjNtdG52QkVtNVpoRGdLSFBOYkZtNXhQd1FrMGY1dzcwNmNYS2VlTkNSTkFPOS9SSktlanJ5WjYvR2FYd2pYWTVNNDc1Y3dmUWNTdVpvdm12SHh3NUlhazZKNzkwYWxtQ3JsYnIzMXhmTStmbEtOY0dvMkVzbXFYRVJGZHd3RWhNN1lrQXpzQ2h3TW5FVDY1RDBrL3FsM1ZIQlRtekFrV3FXTEhIUzNEQk9idHp2c1UxbmZEYUJSQTg5WkRna1F6OFpOaXlSU3JrVFd1cFl1a01Sb3lZOGw1NDkyVXJlM1Q1UEcveGhHVURwM0Rrd0VpK0U1ZkhBeE0ybXBCU2VGMDZuczFBRkJJYnZuekpSa0w1Ym83dkhyZjhDekpLNTgweUpoejlzSlFscThpcFdyRjlyb3UvZ3lxcDlmeG5JMFlkTEJhaFNlY2lpUjBFUzhUYzBtVEFPdmN6b2d6T0JKUEVlQmpTb09qdHJBQ2Z6aWthQ0xpV3N4ZFF2Y3ZJMWRlSkhhNXVBMTlUU2xuazBUV0ZSdVlLa1pKOGh6d1NjWHB5V0oxYVJyanh5NVZ0SllXWnhlaEp4b2lJc09JeG9hYXl6dEUwRFFGRXBxU0MwSlpoQUkrNVlNVmpORXhsbEVaM0Z3Y1ZxVUwvTnlhS3I5bDk5WWxobmRrSmowNEdDYWtVeU5rY3VjcWZGY2FWSTBlQ2llSER3MkxSZ0tITDBLSTlKZU5Rb1ZRNWcrTm5oU2hMd2hUcFk0WGpNNWRBZk4zTzRPa241NWQ2QjRxTSsvOEN4NGlNUzBEUWZHa1hRVDhPWUdVQmZWb2RIQ09FYkV0ODBMUktBdXlPaXNmS3MyQmlEYnBKaE52ZkdLRk5HcDIyTGZ1NWVUdWIyOElIcGNwYUp3QnlOd1NRRXlVNHhVRU5rcEJncEppUlhyd1pqRWNZQmpyMkFnLzFvY3Y3TEFjVGk5aHZ1WDRTV09XK0oxdnovU24rQjRXWGhjRkI4WFpDazFuREtNOWhjNDRYWVdhUkxvdU10RFRyaU41VUxlUm5lOCtsQnZlYTJXNzFQZDIxUHpQMmQ1ODF2S0N3d0FPd1dXbVA0Q2MvdFlrWHN0enVwOFQ0SEJNVnBpdjF2V1gvTGlTb3o5Zko4bFhNSk9vQmhvQlBidC9JYXRQdmFHZmhLZGZwS2MyVDRTbmExditHQVBHQXYwdUV6SW9rTzMxcUhPNlgreEFIYUY5bU1kVWYrem5kUWRQU3c0dUl6bnZiak1UaG0zZjZ2dXoxbEdka3NaZjNENVpkenlMdDNMTHlPT1d6Z0hGZ0lZNDlrZ3FDTWtoSkRpOGNOeURkUGFJVjF5RmVtU3Excjg0ZFh6NjBnTFhkVzBWYVNGcnEvUzcvemI0TldvanJLQm1jQVZoQ2Rva3hkU296c2oySkZOMkp5SDJvTmh1Z2dOR3ZYNHhwaGVlQWFNOU5Gd2t3RFRDVUI0QVBJdnc5bVBDNnpNR2l3M3dHSG9JS1FzSHJjTWptY2dJL0pHVkhSS0VkTktaOE9SYUd4UVVYWGRnSTkwYXBiMzZocXdydGVjRC9Jc1p5QWxzOHhDL21IWS9pYlBTRnlFNHdFdkJnVXRGNDVaVGlSNlhUcnpGa21EbWlWWE9vMkpwL1h1OTNmL09mVlEzTVE4NFBPdC84ejEwTDd3QzZ1SVp6b05ybHNScUQyaGtpK0FzN1E5dFdwa2lQU1lIVnB1dnRyWG5NNXZiazZFdCt4YzUvb1VxczJ0YmJMY2Y5TXRqZlQ4eFJydGF0OGppVjN1UEpLejFnTk5KRThlQ2x5SGtlYUFoeGxEY1dNNkFFT1lLNUN1ZllCOCtrdGpRRWRCa1FZdTVFdjVCbEt5SjNBOEEvb3RacHYxY25iQ2RZU3lwOGROaEFYd1pLMlNTWm1wdUJhTnBrdlpyTzc5WkxPbGREU3F4ZEdoYkxrMmZpd2FxMTNiZm0wcTc2QUNuNGxFTENzU09hTm5DazRlMU5yZmdSQ2s5eFlLdzFoQXNnMERSQlFwcEVRY1dSZWxYR295cUNETjNTREx5VlJPRW5YWmlTZ2hTUWxiVHEzaUhnOHA4WWhvTExYWGx3d3hFbGRDYStHYWE4d2JDcy91WXZsaTBjZm9vYnpGNHhnbEEzaFJHVUorSEFQeGtickFlMmlBUzVNNjRPWndHT3c0QmYvZkRTaDRCTFo3NFFCMXdRdGN4azRoWmR5czU1aEdzMHh3WWtzZ01ESnlnMkxVQ3NtNEMzaU9ERGZpelVpd01GR3o1SUViVHhacWhuTGpDVXM3ZVVzd1dwZ3JBaFdOZm95ZUROMGNTdXFBRVJTSmlZMlhIQkFGd1Z1T0NSbzRNelI4VWc4bjhoTkJsMkhaYUZ3MndvS3VDMkZkaVVkWmxnbHJFL2xFMkRqeHR1RDFOMW41b2NKc0FTaXFtYmFzdEtrcXdDNk94NGZ5MWsxSE1NeTJ4OVg2NzBqdmNJbk5Gb3VWalA4eVV5d3FNWGdLeDBlSDJZbnJhaHdVK2JtN2Q3TUpWanFJY1kxSDdqanVoVEp3Q3k5LzR5VEhVbDRHR3R2cysra05veEVHMndwOUQ3Mk9zMU9MVHRsTU5JdCtvak43MDVrZ3luYjJWS2puZTRWNnpmOGozV3F2MExXRDlpSVZBNFFOcEdlNGJ2di84TGJQMExQYnI2S25QVTQzVGJwNkNwK1NkZHZmd3BlUUpGcDI0dkZKckEvRzh3bEVRZGJFS0daTW9JcGQrTUJHRzUyQkhmdjhjN3Y2L0tVeEFuYlN3UyttVmZ0eTJPZVpZZkFWd3QvVHhITXdGbzBnd3lCZnVKV1dPejVqTGVpR2NjQWdadUlrUWZaa1ppYWNabEpBR0dOMHBBVzAzUEx6cUNXMldCN3k3Q0RMZ1NTdGtuKzVLOG9FSThxYjM2eEVna3owTGdub3dYY3RDSzRyTEx3cnFJUEZSK2ZtSGozbHZ1NTFMaExNZUo0N2pnT29YRnExVjl6NWEwRkhFUGJ1RlFSSGZkZWRVc1Jtbkxlb29xaSt4V0hzQ0d1LzRRMzJiWTh1TGo3cXg1eC9IZ09sQmNJNE1nNVBDelhvSkZLWUFnRHNCaUR6T3ZmVW8zTklNaWRQbHJ4ODdWNTg5RGI3RFhzbGlkeFZRczlFUThwZS96M1Era2tHeXVnUldQL1pmRXVzeFJEbHFRVGRNbmxvR2pCR1QvR2tMWVYvREpmMUZDNDFjSHBLSTkzNUxuVnpXUi9GUmJzTkY5TFB5N05nRFkyWmNjei9TRm0vOE9OUlM4Q2FXNlByancvTThpSDArWHhiaW9aQ1VlbmJWSG9CMG1jemtQL1U1MFFtRkFScndSQWpmcDU0TUdPV0wvQ0c5bGQvdC9PTU4vblBvSGFPSHBKT3AydjlCYVlMN2tmMy9Sc1pQMFQrRzgrNytjZWZCZXYrVTlvOVQ4SGVXKzAzZytuMzl2aitrbWkzbHVNamZWTUhZSUV5V25xWXczVHFEd2NjVTh4eWIySytOUWQ4Y0FlQzd1SEhWVDA0Y3RXTlY0MUVNcU9MMVhRMDAxcHNaV3I3ZU80S1hnUUNFTGpCeWNOVGd4eEtJV0h4Q283ZkIxNUc0Nm51bzg3SlE2ZmdZQ3c3eG96bDRvUHdGQVVuRGtuTGpkL25zTklnY0JGMEcrbHQ1VjJUbFVja2RJY0kzYzEvb0xIOENScGc1ZnVaZm9uRS9tRE9pRUJ4TStvR0dwTmhvK1pORU9iTkhxQW4xZGFPYVd1SGNIak8rVk5BSlhBYjZBamFPWE1JRGRpYWZCcXM5R0pUVS82ZlFIRkhQT3ArNzNidzNBNEVQcFV1Y2MvR3RqQUdiKzN5K2xBY3FJK2liMnd3MEFyc1J5Mms1Y2VWbHNyYkdPQXh1cXdIREFWN25iaTMwRUgvaWt1RDI1M3hoWVEzTXdENVJPM1lPUEhmN25Ic1RuZWtjU0M2Tk83ZEdSTEh1eUw4dUxEcmhqcHgvSjVhL0x1dXMvZHFWd0hvK0ZNRXlCeDBKYkNYWUxrVFRDcnNoRW5iVkMrcktwbCs3bUNSYm1jVHJZVW5XdGpsaC9qSTVhZ0hZZ3ZkUXdPUXVLWE5nUmFxb0dZckRJNmEwMGVtVFNmaW1LVllQVlpDcWRQaEZGSWhVeStSWUZpQ2RTaUYwWjlsVmF5UWU3WmEzbE83bzc1WUhyOUpNbEpGRmg1YW1CbTllWjRUNWczcEpsQ01wZ2FtcHdkU1VXVWdNbVZsWUFtSGNwUmd4cHFLREx3UzMzRTRkUUVTTHdLNExNRXB3eFZGMS9oMElXTEpFTXBXcERBUkMya0tOQ1ZIVjdXd2FtbUtGb3A1dHZWblVOMDhqc2FFa2NCQjFNWTYxblQ2c21DNGg3YklmOXMrZ09BWXRncjZGRVcrSGw3Mm9RbkJqM3FtYzc0WlZiVHhTaTZha21BTVNtT0R1eFlIUjR4SGlvWXpuRSs2RVZtSVEybXczSndyRDJGZVZ2LzFHcXB1dXBtQ3FpY0loOXRJUEpJdHpPVmp5NXBtVFdWa05ZVDNobk9PbGN6TURDWnBmMFowMGpFeVM1QW5Ec1UrV3FMUVlZbkFvWW9kNU1JdVZFeXhPMXVHeStWUEROT1cyK3BweE9ndWJyT2pxK0FMSVBqUi9Zd21od3Q2dERHUUdOY1lob0M0aGlJaFc1ZWlKVDBPMEdpSHA3bmF6NmR3MFdZRXJzbWhud1luekpKQXc0V1pJbDd2RWJncUdoQzVjUll1NE8zaXJCa015aHFJR0lsOHNScDNPWmt4R2NCRm5ZUW1oV0toVEZsUU9RSHlVUjcrSHFrdjRYcEJGT0YxQXRrNGRTUGRkNVVnaWZBcXV1OEdQTFpBOGwxL2lmakptVWl5d2hpdFZ3ZU80UDZGK3BSM2ZXRklOSW5yRzJLSUEzWnBOeld5RWtSSmpPUEdaNmxyRXF3MThud1crNDhTejBKVXAzbW5CaUowYkgvTWkxUzhabkpvR3BXd3lyT3pyNXRsK1NvYS9hY0hweHhyUHZmaDNMemx0SDhKbklTMTVJZVRFOHBqajJHRTFIUWkvV0ZyS0tnLzl0aUQ5QTZlckFDWWZ5anNVcVpaeU0zTWNKQ2RWbllWL2lFZGl5U1RrWmlKdXROM0w2OHR4aXpUQ09xaEx5OTM0alNKVFNaS1J2Y2hpbFhUYStQdmxia3dHV09YMVI1MTNqVXJqKzAxUlA0NnQwb1l5RmE3YlBIZlcxbFpIU1FCbXFqM1BuOXlFS2ZCaW9GUE1IcHhtd3pEUjI3Q0FMWDQzMGR3SXJJWitER1NQVTRFSGcwOEZuZ2ZHdk1KYWhHUnZ6QzJOSUdvcGxBNktOSDFZV2g2cUVoazdqeUZyMENhU2dwMFVPbFJncGdJQ1B5RFFIZ0RXMjVyanRoMTBiVmxySFlUVlp1Z25oQ2tKVUxIVFJjcFlpVU90emIxNTc2UStHMGJzTXlJbmpJNUZUQk0wN0FaZFFDQUFaV3hqU2JEQUpVelUvb0l3NkpQSkpVU05wM2JNUEc1RElQUE5Sdjk1eXFXSlpiTklaV1AyTFd5WVpScmRvUlhoOHl5dUdrLzBEc0g0ajR0ZVc0NlQ4T2xLK05JNkVoSVVzeW9NMGcyaldia1BPQkFYczVFQWNjeWRTTW1TUWtBbUhGZFZmWExQM1Y1Yk14U2xkaTRuUVZjQm1uUUdRNWs3ZkdZRWd6dGRNRHhzb1VXNTJoRWR1RG43YWY0L3kvMlV4Kzl6SDdxZlMraW4ySTZlaURGcmZGY0E2RW5sczR4ZmNCV2VBWUhDU0dvQXJBN3BDK1k3Q1o4TnhqYXgwTytXbGpkd3hFWENyWjV2TllEZDhWdTNjVjN6aWRZV0x2dm5oY2c1R3JYam5jQnNQNnBiNXYzei9QeVQzQ3hCZ2o2UVE4eWxwZHJyd3g5WUZoc3R4enUxcm1vUnRrclQ5Tkh6WHI1L015ZFZ5am9ua2tPeXExclJudXhzc3h0OXZHYnJ2TFF0Qm8zVHZFU3p3L3RyMnlDMEdwL2QrdSs3dm0rRFFSalQwOWlwTFl0K0Rxd1E0UUhLVFNiejltSEpBaTg5RTV2WWEyeTFMdGoyeFQ0TmdNWmwyRU9zd0liWnRsd2JpL2RWcC9STkZhY1FRbTBQVjBxQ0lYWU13bzl0RGZYL2cvTnFndU1waWI0SUsvd2ZDSzNOWEVZWE1XaXN5R3p6SkNWaSs1TUVzb3pXc20rWWhxbFZJYVo1cmpZTXlvOWdPNzdGeG9qMUMxOFgzU1RJTGxkZitKd3dMUGJmUkYxYlY5QzB1Y2t4YzdGQkMvbFVjcUhqTHZrc0ZjL2xJRFdEYmRTSGlJVE8wRXdHVXVZZ3d6YmtGaTBLaE5YU0FMYzNQRTNCMy92aXVsOGV2bDRJWjBPRmNKUjA0d0dEd2FaNEhpd29NNnpqbE1aTVlhaVNNWDVtOXp1U0VXUGxrcHg2ek5xMXEzTTNsUytleUxNV2h1cUZMUFU5RmRwY08xckJtODVtVTluZFRWbUZNUFJQWHVqd1htMWdPN0ZCQSt5WWRVUlF6YTYxU0JveGlLVmU4WU5WYlErbytTMVdQdi92THQ4ODNoNGQzUWptdzJLbVpOZUtHN1AyS3NqYlQyR3Z1YmlObFlPMG04UkVuSHNnZU5nSjNzTXA5bUQ0di9UanpIY0UwODg4WGNmZTRKRDY2M1dqb2VxajdRM0hua0luZlJJVHd3ZDlZZWFwSkp0cngzRnVoU2ViOGR1ZElyTU5QQmsxdUg2SGRGNnoxTDljdGs3a1V4UGdQbWUvTGVQOUtBcEh2SzF5TUNXdk83K0dmTGFGOWR4bVZsZTdicG1YV2EySytRY2tjeVBzSDM1dnJRWFNyOGl1Sk1sNjBFL1Y1QW96WjI4dEtzZWlRUEpUSVptaExqRlVQekxMNkc4VEdQV2RESlZPT1pOT2puUXcwTG9XM3NaYmRGek8ydDJjMVU3NEZNRTJnQkxjUzVLK2Y5VW92TzNxaDc5TnVHaUJna09ZNVVUdlY2bFNhTnZ2ZDJoOWdWeUF3S2EwSW1uSlBVckJpS1lrYklUb1h5cDVnQUNxR21GNHRiTzBOSVoxRmdUcGdWdTMrbEZvK2RUdnUrM2dqOEpxQUU3a1BENW82eE5UaVExVHdYMldHdkJqcHh0NjEyMS9yRnZTWm5Vb1ZSRzhsWmc3MFhKMndKZHhmNkp3VWc0SERsSmxvTWdlbEg2TmhJUGhQM0cxbEd2UStOb2NVelE5VVQvejNYRUtseGZQaGkrcFFGY3JUUklGWlVINTd1akZMbStUWUQzWDBQTFQzVDI2TUE3aDlCNUE1QzVlczlpcVd3bzQybHdWM3BjTWNxbHhUM3Y1cU42K3pmMUtHK0wwdUpFL1RXTjhVVkpiUC9mdEQ4NFR6dVI5a2ZvNWlSZEFZT3VUeFNjWXJOWWlPVzVrQ1dDOVhKNVljL1ZFNlBKZkQ0NU9uSDFub1Z5dVgwR3MwbFA3WnE4T1o1SXhHK2UzUFZYOUg2L1RxL1AwSzNYZXNoQ2RGVzgxV29WaTQwaVdKRkZHT3J4dDhQMWhrZXNTOVpXdzBjZUtNT3djL25sMStaZjhkQXI1bjk3Skl6S2xJOE5jNllsN1Z5bThzRENQUXZvYitEVGExWXlUdks3aHI0VE0rRHpXMkg3am9seW5QYjR3WDFNSUJwV1cyN1UzTTduQTM3NHRHWS9aU2UwcDVHby9wVDIwNmVmZXJydHhVRDlYMDlyQ1hRSUhVRUhLdWZSa2Z0cHlOV20yTVVnZWdyR1JpZVliT1h4RnFqNWRPMFVqOEVYdjIya05EdHVaN2FDdVEvZFUvdEIrei9HOFFOK0ZXOTBIbGZ0UHVvOVQybmFEd0RuNVU3cjV0Vkc1NERWVHNDMTRPRnYrN3piZTVIdWVCdGgvdGprck9SY1lodHNGNWU2R1ZQUjI5bUplbUVDUHFBU1liRFpJZDErLzQwWStaWmpnMmlWM0k4V0tzZHQzZlVTRDNkc1BzTlR6Q1g0WDdaSmdiZmN5TElUU0ZrSnNpeTZFTi9nQTF2Mi9OZE8zVUJpbS8wWFZEZmpTTk9ueUVhbkEvZGlHMGRwalBDMjlhcitubW01YXdYc01vazBHNERFbG1Lc3VpenFGdUJtODFpKzNNKzczc0V3NjRobUYwS0dDYXNwa2JqNWlxa3FOSTJRb2NrWnBEQmx5TXBvUDdPNldqMm5PWnpjL2d1WmN4YWg1SnBnM25RbGVMcHJ5ZnljZ3pHRW5aL3FlT2s4WnVlVXZha2lqWkFycHZZcU9YdkpOY2J4WmlhRGwrT0dDeXFScWhrY0hBeWFGeVM0WkxxdXVRU2xHUVBmRHk4QXZWT04zcGZLcVUraU9uc2lrRUw5NVNMcUt3UEY2aFFZWmNyakpROG5jenpGdU9OaER5eTBpTG9FcktaQVZDdElXWjFqR3ZVVzVrZEg1ektPamJRMUYzVVVXTU5wYVFEOE16OTNhaVlJOTl5M0IzUlQ3ZTh4a2VLdWhLVElONStHd2VLaFdrcFpYSkU2cVcreHJuZjA2WmxUY3p4QWw4QmdOL1V4UlVyc0tycnN3czEvcGFScWg0cEJLSzBzZGxJdjdSenR6S2VnYi9kMzBVaFc4TGk2TzAyOFROdDUvNGN6K0hXTyt6cHFYemJIZmVJVEhHZXpNbk1TdFc4Nnc3R0VwS1QzZklPVjJXK3dCS2tZbllIT1pOdUhFNTZHQmIxbnNxZ05qZ1FPQkFKbW85dHNQSE95V2V0M2V6SHpYbnNxRWhXeDE3MWpDUGhPRHY2bkZ1ZmhFUkt5VE56cXg0OUNQb1p5OVVIaUs5UGp3OURaQUkxYjhJbGtNZDFlNzJGNVdwbEdxYnVYZVAyRmdPK3dBRWpLbitmK1d6TFBzVk01bkMzbGFQamw0QW1mWm5ZVDVuYldnNWFsRTBXa0hPL3FLY2V2MDNKOGJwdnNiQ3JCUnJjQUd6ai9QOTZ4NFAwNlNKS3dDVzFoSkhNZHduNkVlUWlRYk9VU0xTVGZJckRQamljakVXSDB1MDl3alBBRTBrWTZpVTNzRy9aajcySzRKeDlEaC95RTF4OTV6N2VRRHBSQ090QXdSaHJkd29xV2JXUXAra1VEazdlMEdxU21pelJuTE0xWmIxN0FNKzN2QXdzMXk1Kzg5NEVIM2dzZzZuYS85Z0RrMVFkZWlxcXdOMWMvV25ua0dBOVhIa0cva0QrMmdzTlIyaGRRTWhDUU4rWE5aNTBaSkQzbjFEWTVSQldDblY4eFZ4VE5ZczBwYjhvZmovYVk2SXpOK1VUWmUrVXJYNGx6K2NyZjdlUncrb0VISHVqTDVncktJY25tU2plVDZzb0tNRmE4c1g0REFDSVRKd2lhYkVjWTgyQ05jOFJYaUJJZ3NVaE9HZlBkV2owVUV0eXRQMEZKUUNxWjNIUWU1S1p6bWNubFNWRVdnaXpheVFZRnVWWUFoZm84NVI2WksxYnowN244ZEw1YStITWNTTjArSDdZVWpmc1dEckQrRnFjcEliZFFyM3Y1d2pLSWhWcldMT3BoNkVOOTV3N1NZWktBY2VMNDRUR3FlZzRqTFlydTBteDV1MU1BYzV5anpPVUFlblJtQlJScVBabXIyeWdSSWxHMklZQ0oweXQvWGtCWnpLT3lWSXNmcVJmY1VHLzJySENoZmh4dm1ISDRmVHd1ZkIvR045V2ppVnJpckZlUG0vTHdZaXZVeTlLbEt4Vm41UUdjbFFkZ2ZPOWwxZTcvKy9sdDRQdzIvditUMzAvZy9IN2k4dk5MN1hnYytFb2dSQkJOOEV3QjBwTUpLazJ0TlVjUVR2S043YTF5blJSMjFyUEIzeWF1aXYva0JOUnNlT0pVTzZTSjRzU0Z4V3lDMDdEMGw4ajVpYXh2ZTh0cVpkU09QK3dLaVgrLzR3UzBOWGppK1ZBOW1qanh6M3V5OFIwTmExbU5VL1FoWC9ZSDU1Rk1qaVBsZndsSkxFMU16VmtpR2dBMW5nK0JUYWFSRm9hVTdTVkJ3OURDOVE2MEE1KzNpZHFIMFhYenBYTFBMeElaUGFjMmRCczNERk1BL3hFSjd4dlFZQ1FaeEpPVDRjR0NuVFpGVlZFa2RaN2dma2dhRCtXcXd2R1NaQ1JHb2pHcFVKaG9yOURRZWpCL21tYzBsaGVVTk04eExNY0tpdWlFRlN1b21MWWFTUm54V0RHcEdid3FpenBRb0I1K05wc3lDOXB3SkM3eFFjaHdvaFc4Z0hrRnBkMEtGeTBZaVdpODRicjFYR3lNUnVDYmFoQW14R0F3cGxxQ0l1aTJiQ2hpSXFYWW4rRlpTZVl3WUFuTTYzcFpqU1FpWG52RjlUaUI5T05YNEhva0FqSlI5ZkswSmpYUUMzM1k4bUNJc2VjYXB2WXBOMkZZZ0dFeVIraTVCalo2dlFCYjVBcFVyZGo2N1JDNDJIeFk2R2pPNEJ2YVJLRWd4YUlqQ1VPU2VFNnB5cmVUK2xOTVZnMktvWlNkSHd4UEp1TkFsaGhqcnlpcnZLRWxpN0c0a1lxb3Rxa0VMU1hzaUlxQUkySTVQcTBJUEtzeC9Ha2pyRU1GdEQ5T0srUjlrVml1N3JxTmVEUmhGS0tjc2xzaUZhakpIQXRWWG9wSGhyV0NtWEowVkM4R1pxK1RXUDR6dHBKS2lJb2gyenFxUTB1TkJZTmlBZ1p4bmFubHV6bzBoWlN2ai9DdkRHQ3VOdUFEbTNZeGE2RkdIV3FTMU1oTmdvaFFGZk56WURlbUdYWHl1Tm1CQ1Q2T3Yxek1vNmpKY2I0NGdKUUdnMUVaQTZrT0ErMXZDNlc0c2V2OExpTmVFZ0EvcE1tNEhlSEZVUFRBa0t5ZFpxczhYMlZQYS9MUWdSc1RvOXFEMWVxRDJxalB4NG95T1EvV2tIWnYrVXpLNklQdUMyckJqRHBlbmoxQTN3NkFLTUZHSzVQUWF5ZmJJUFNpalN3NGMvNDVtbGRNK0tpOVZVU0RmY1pPaUZqWFFHbHducVpkRERqU3p1QWxPSDloWmFVbkhIS1NSTUtjZG5OdUoxRlNCaWNHbGNWRnV2TGpjT2RKSE80WXl2ZUx6Q016ZVRtNSt1Nmw4N0haSDJmMllrd2lGdXdvR0xCUHkraENQMjNQSTFLZG0yTlo3T3d5TjBleG0vcTJkNklTQWNJT0YvamJMNWEvL0JMWjEwbG5mekgrOHRkY3BCUjRld2NpODhNN0Y0RnMvd3g4NXBkVmxKMzV6Tys2VkVGMkpEYi9yVXVXWlF1LytXVzBuRXZ5bTE5eGlUYjBxaDN0d3UxTE5LSjdkcVk4OS95QTd3SDNZTTd6N2pSZ2R3YXdPL2xISklieWR4K2l6M2pvSWZxTWgvcTJOM2JZNzIvN3VLbmdOZUJyU0d0cFlPM1VwZUlVSFhEbXFFODJGYk0xVU83d0ZucERlczVuN25QOXBPTUI2NkNER3hQWGpadEtPaEYwVlRnMEJJTnVFQTJlNXZoMW55M3VQcmk3cUV2eHBCYlZnQUMwaUo2TVMvb3RRQWE4SmpLY20zRTVSdFRtSjY2ZEdDaTZ3eFczTWhnSldlN1FnRnNaQ2hjSDBPNVBGM2NYMFY4NlpaVUdvc05WbGgwYmpnNlVyVFRIODRZdDg2Smt1SzRoaWJ4czQvS2h2bStCOENkZ0MzekFKMWFhOXJvZHZ0Y05rTS9qZWNXYWg1MjZ0bEUvWGtkL2ROVitYWG54NnNVeVdZRGxoYUZVYW1paGpMZkJXdjM0YVh3R1dteVV2VFBLaXk4dDNYVlhpYVFESFN3RW5BK0RlRHI2a2l0aFZrSFBLL2QyaGN4ODU2bGsxWE5YdXBjODdzWnVmdno3dnduY2lucldZeGlEc0Q4T3lJOG9Jc0JtWWJmVzhqMGJISXNlSVliWFBQVGNJY1p3bEdQZXNYV0tEMTlxV2ZYbVMyOGk0Yko0Y1JQa2N6ejg1eUdSbllFUzRBVnVoaFdIZUJoQnV6a0lWQUI0eUZjNU1TZHlWVjRRQU5vRHVad0FRUVNDVVdLZElJdDJtNWlDNnVKdldnbkRVbjlURkxEMUV5MGZEOXBteUZFZWdQQUJ4UW1aZHZCeFhoQ3gwVWJ3ZlpGOC82dGhncmUvcjJkdXAzVlpMbGVOYk10enV3S05IcDhySUZMM3FDY3U0V2ExaW4ycldOL1hDbHpiZGJSYXBXNVdYOS9SdmVyWGxxdjQyLy8zUmMvQnl1ZWVRNzFZNEliQUtlcm5nRDUyOUVXVk8vNmlteDB5dW9oT0xuVUF2Z2l6UUlOOHI1amdqYmhHZEl5cVQrOUc5YXdmTDk1WWpGa2NaM0lTWnlWMFZNdTdlYWdMV3NLbUhxWjJMTDZ2Tmt5aUdHbGtEMG5XOXNXUDY3d08vNG15WklJTnRIRThIby9aMU1YVVR1Q0RQSGxBd2tKM05qbk9qcFZHRzh0U2p0eUZjTGNYU0RJbkxUZEdpOGMxZ1R5NWZSYmZiM215bDQ5dnltT1dKSFdTOTZEQmY1WVMzKytWZUJSOVRaZGRLSFR1aThrMnhSRWhiWk5pQzF4SjR2cjZiTnl0dmxEcFZzOUhTc2VsenVmck5kazB5TmVvU3VabS9RbmlIdlBkcVk2Zjd4c3hBcWhOWjF0dERBNTZNSWNrakZQQk1NeDk5ZTBoaHIyWlpiN2FQazk5NkFCSHBocWVvVkdBZm5wRlE3b0JLaElacHBZaFVwNjBLVVZWbGFra3kxN1YvaVFlc0RwenF4Y0liZ0QyQmlSOHJsUVk2aFRPOHFhN0xGK1dMOWJjdkpWbHMrQU5uVXlkeFBrMU1remNBcUlWWnpJR3puUDczMDdaYi8rejluTnBjQVZZcFErbm1mcXdGWTFhNEJqSlZDYlRYZ1BMM1ZnUkxNK01CRjZLNTY0SkNocnFia29FOG9oYWtDaGJMcWx5UERqTmV2NGhPQXk5TzVGUklzWWxEeElWZStXbUNidFNKMUdqcE9BNlVZQlJrL3B2TURtZFY1dnpUVFUvbllSMk9EbVJ2SjhWSEpialYzbU9kUVQyZnJRbmZOMzloSnZnL21qZWxNTThKd0EyNjRvaXJ3Y0JLK243REpFRFFaMFhSVGZMQW9Ianc3S1pCMHh1THNlbjh2a1VqeExHU0JUZFJoL1FYWnVUWmM1MmpiS0Jka1JISG9yZ3FlNUlmc0tVWkZZS0NsQnlzd3dqQ0h6U1NDWDFsQ0FJRElPNWY0V2d4TXFTT1pISGVoYU9hMytJMU5VaW51bkRzUUdkaURmaUR1YlNNS3JOOWRYQTFRVzdWZFhDdjI0ZS9ZSlg1blZlelJ1TWRrSWJSUCtNa1ZkNVBhOXljV3VWRnl5dkxpeUJYN1hpM1B0SlRhd2VuNzEyNnNTSnFXdG5qOTh6SEN3Wm84RkJmVVZIZjRQQlVhTVVIRFlLc2FSaGhYQmhRNWFSakJVMFd0RFYxWldWMVZWVWh1ZlIrOTREdmhMUU1ENGU0V3hsQmRMWWtCck54d0U0S0dXejBqOWpPa2x3UGhTRDB2UC9kdUVDZU54UUZLTzlZdUFZSXlPQ3NjQzkrTHd2SXQxb0E4bkNod0pIQTdjR1RwUElGVlFkREhXNHd2MHRac2RFUFhDcm96alJOdTRaUW5CbjVNZDZrQTZJaUU0TWFmSjhvMmE3bzhETjBUWkhXMkVMalZETlJnM2NPV1N4S21NUENSeVhFWUhNbDh1OERNUU14eDJWWVBzOHFpY29EUjRZc1pMeDVMenBFZ1JRMTV4SFc5YklnVUYwUm1CWnJkUXZ4T3VHZVQ2a3g2UGZyRmZVWmRBUUtqeGZFWURDcFlkUXRUZ09pNGJBTktjY3d1Q1lzQ3JCMmRUMGlEZ1FjOFdqcm9raiswejNxT2pHQnNTUjZkUXNsSzVLN2gzWDZoK3BqOVVXbDViMjFNWmkwYStFNjlyNDNxNGZGcTZyV21CWFlBa2pKSUZmY0kxcy9Pd0ZYL3U1Q3loMDhFL0xTS3JZZzZUaEk0R1RtNUZsZjhIb3Bzd3ZDTWgwK2VmQ0xFVlNmMEJIL2NJWEdRWThoZEpaVlByNXdISmdKYkFhV0F1Y0Nhd0h6Z1kyQXVjQzV3TVgwQnQzTzJTeVNFSWhUczZFN1pFb0RDNTJ0c1BkQldiV2FwVlJ4d2xkdms4VXJiM0k3ZjdyczMzYnhaL3ovdjNic04vSkt2Q1RvcHcxRHVvbXc4VEhZd3hqNmdlTnJGeVVPSFh4eFBYWG5WeFV1WW1wUTFkZWVXaXFlRkNZdW5GS09Oait5ODRjNWcwWFRiWC9zSk1FciszdWZlMWxYdDVOM2RrWnlNSEc3ODFvaXBBUzRrWU13cGdSUjBsRm05R3k2cUliRHJ1TGFsYVp0TkhQNUhScXdiWVhVdC8zM0ZJdnVUaXkzYzRQWE83VjNjWHYwcmx6dlBCbGVlci9pdVdsWTRIWEJ0Nkl2cmcrUkFPM0wxYXFuT3RSUDNXR0tKNGtWRGpORUYyVldFMTNNNlJKVWwyMVJkUWZKMS9Pb3ZHK0U1ZFFwa2lvTGZ4Tll0TExNTXlhV1hDbTZ4YW5kcnoxMGtpbFVmVjQ3clpjM0ZCNDlLRmdCbTZ5WUJoT05lSzUyN1BrQU5uTmtNWGJFclpSVmRyL3BsUkpJTU03bXRpa2YvMzEyRVRmZkllZElJR3NUM1Vlc0wvNzFGOEczYnNEaGhNVk83SVVzUlVrSi9RK0Z2UWNHTURpWGdiOVVLZTZGcGtHSUZNSUxTd0tCbndPa1RVU3c5WGphVWhoMzZoQTZjUENiZWQ1NkZOUlAwZk1qb0NnN1o1NXJvK1dtdmdhYnFDU1VXdHhGV1VHZFZQdE0wamFyQk03eDFNZTE3WTNmbjhKU1NEWG9iZU5QWG5MM3B3TjRWN0hwSlkxM0ptRW14NjRQNW43SVFGblB2Y2xOcmlSTHFkR1NBRFFWYVJQeFgwUGxkaVkzVnFsZU04Y3lzamN5MHNWalEyNk1zaG5rd2twS2FwU1VFTktHanBVWDZvYktsUVlNU2tsVXBrOGtOM2dVajZUaWxyamlWWWxtc3VrTTdOVGI1MmErN1BwMGVFNlorSlNtMXg5YUhSR1FXcE5WcFNHTkJDMFpJMy9JMndaeFVjTDlYcmhqMkJRTk5rZzBJWkVLWXZVcWtrNUdFeTU4WW1NcW9pTlZES1o4bVhXTHhKL1N4MWJFcDBlbndEQ0wrNVEzWWJFYjI2TkZMUkpHOTkweFBjRklBR3FZY2dQVEw2a1ZlRjlKSStCa2NGM0RZOE1lTnYxYmxqZzk5SHlMMXRUcmNtbnU5ckUwNGNIQndhR3JuN2F4L0VBSGk3V3A3SEhsdVZpQW1waUlNRU85dGl5TmtmZ29xbnBBc2RmdU9HT3RwUDRSVkpsZC9QUm9HaVNEcnhrWGxxYkhTdlUveVNhN0Q2ZTdLdHd1NzZJZFR1TXV5elNpTU1hTnJUZ0xpcnZ1YktUZUNYVXN2RlhNUWQ4UG9SdzJYZWozR1QyOWpsN0ptKzVIb2hpSzQwVUNKWGpSQ1E3TXhLTEozTUVWbUt3c3lPSDlnc2czUkpGVmtQbjVYSW9xWDA4bkFtanYwMFdjZjkrYUFIU29zWUV1YjE1TnluTElTaEswRkh0YU5SV0hTaUpNQ1RMU1RlL2x3c3ltaUdDSUE1ekNRSXhiK0E3aGtsOVBJUDB3ejhrZU9OTDJLZllSNTdNTy9uZS94NkVPSDhXSlo5dFpDMDhZOXJWOGVraDJ0NzVsZ3VlRVRYWnFOSWZROVpFOUJHeTRCekxhNHZ0RFRDLzlOZTYvdGNpVW9UUlY0SGFPMUtFMjhzYkcrS2tyRDNtL1dqeUpMb0JnWlJIcWlUSTM4RHpON0FpZXFNcWZxa3FlcmxpWkdrSno0Lyt4d3VmWlhqd3RVQ1Nla1lYdzhRbU5zbzB1M1RKZEpvWGRUcGxieWp4elROejZEekIzN1R3WU9RRmRyaG9HMVE1YmlHK3ROUzByUGdDTmN3dVJHdDdJemlkblkvdXIwWVhxSmwySVc1WnphVWxkQktITm44WTVyajJHTnFOMXVEcnJEeTk1UXpPdi9qYm5mdTUvWTlxL3pZbXhBQmZKN1FXYkh1TUMvUmlBUmJSVzJ0aUwzcHZzcDMydWpSNmVzdmJndWh0UVI4QTNuTkx2OUJhbmtMZEt6Rk9acnFPUGUxMXNISldOWXlJWVp5N3BUSTFXU0ZvZm01NVQ3bThXRjVKMk1Ub2dCYm56NTR4MUVsMElsNTR0aUEvWHk4aVZ4ZlB5Q1Z5NE1jOXp4TWVvUXFaSDhkdHVBY2dodGdWK3A1YlJGb3hhdGdnaTcyZmZOTlV4Nm1STWM3TU8zR0FlWmEwZFIzRW5ma3pKRk40Y0czZnVMNit1Z0l5N2N3WkVoOTVwa0xIMGZVTTRYdlNNQThVR3VEWDhBVm9zYnlPZmw0SXJKRlNaVHhTcTc0NXRsTVg2NFhLM1pCdHdoNU5RNUh4c0RzZUpqRDRsRkthRGpzZXNjbDRONXE1UEU1Z0JvaSt0OE5VM0pVOG0yUzVSREdxWmYrZjJxNDhScExxdlBlclYvWHE2cTZ1bzZ1cXU3cTcrajVtcHFlblozcG11bmZuMk41ZFdNOHM3T3pzQWQ2RlpUUGNCb016Sm9Td0JIc1hDNUVFQjJ0dEVRY0JrVGNvd1lCa1FJcXdnaFRrRFpZajV4OVlZVnN4dHB5c3BWaEdsaE90Rkd3aEdacThvL3FZMlJOSFdZYXFWOWZyZXErKzk5NTMvajVIVXMyd1pzZ2lGSUVKWmNWeWVYeE5TT1VUV3Q2V0ZGMDFZcklFRVljSlZWUnQ3MkpHdWdhWlp0TEN5RlpMRFpOd0Mwc0dzb0M1THBnVFpLUkNuNkJoWkZEWnk4VENFY0pPcWFxS0VKNjJmUUV2TkJxL09iZlYzVmNRYzBFNVRicXdUTEtjS2RTNk1jbDBSSzArcCtyUTNxSGhvUlRVSjBabmQ2SWxFZ1B0Mzh4Rnd6WCsyYk5WRVE5ZERrRkpqaG1xcm9oT1hrdmtVN1QvWEZOQmtETUJibzBSRFp1cTVJQmNKRkZLMFE2OEZHYkpESzlKSWk5a01GTXFJa1ZWSkNSSW1ockxlR1dVSVIyVjVsVUI4VUlPQWdFcGlvVjVUeEJXcmEwakF1M0dubThJNFZIU29UTHhhaWxWWm9Pc2M1Z1lDSjgyUlBpVlFjeS8xVS90aHNrSU15cDRSYmJCcldxY0RzSzRXa2preG54UTk4ZXkzdk5NMS9yanFOSjlSNGxtdldMcGhsTFJ5LzRNRm12VTVGR3BGYUdTS2t3ZDlzZkcvTU5UaGRRYlROSGFQYVpFbzhyaDVKaW9KQktLT0piY3NQNVdRNU0wM25GRG5BV2hlWnFPcDllRW1Fc1Q5T0RoNFBaR3B6Z3plR05DOHBzV1cwellLYVFabmtYRFVTM1AwRkJxOXNoakxDejFqQmxOWkZZeWlhaVozTDYwZlpoK0c3Tkg3cTA3dWlWbFNqVE1kaWtqV2JwVHYvZkk3QXNzMXZhbnFXaUNGMjFiNUJQUmxCT1A5MkpYdmtOdEFzU2I1RUhtVDlMcmVtMFllQk96eHhSWEZEUExNOFJlM3lKK09UYTdoUVhFNFFXMVFtaVZwQVVUU1F3bHNTRUVPQTB6bTFBOCt6TlZxNjgzdnoxWjNyNjZvNUpzNzZUNmhQRkNESTlkVjArT09xYVVMK2N5cWFLSXNoQUJDSG5MMGQyQ3hVTWV3U3dTaXltOU1FNmYyZm1iSUtNZSs5NC9LNCtYZDFUeDV4MHZ5L3VtanhPOXpmSENERnBEUlVlUDh5aWZ0TkxDSFNDbVR3bTFkQnZKQUFFZTZoRHhJMllLQ21sM0RGZXZReDZmbGxFN1hST21vREJiWUxWTTcvc25OaEcrSEdqa2ljNksrQzJmb3RhL0JZSytWUm9pZ1FzUThSRGM2NFVJdVhVbEtML3JVcHlHMjhTbEVjZGd4RzQ0cjFPUWxIbXllWXNSZk1KTzErNnJwZTNFT1ZHNGxuTGIxeEx1bzE5OEVaYnJOT3JuY0JtcXhWVEdJY1BBd1IzK1RsQVAzblJmSjBQQnNmT0NYQ3pLUXQ1KzRyeHFTREUwWkp0NE16UWZPa0x6M1A0SnlSNUZMRXV6RlVvOExKVTZCZFdxVUJ5WndHOEoweHh5cVFtRzBWVi9zWFBzUWNxdXFWNEJVMXdnc3VGajBTMjBHR0locnFCY1lvbGJTVlRZRXhFOEsxVlVmcktVUXhGVkZSMUZOWkFrSVVOVkhEeHZSMUN1Tk1tcitCVTRMWjRlOVVIREgwMTJmNG80SkNORlU2TVNwM0ZpVk5WVWZNd2gvS20zbHN1TzN0RlBsWkttZytWVHNLWXBxNDZaTEwyY1Iwb3VIOUVWQTdseFI4UExCYVlvQ0RIdENJS3NPWEVYR1lvZXllZFVsSTFPK1V2KzZLaS9sSjQ2QmpuQmxnUUlzVGlEa0MySmtFT1NMWEJRSW9xMUx5dEthWDM5MEZLeWRFcFRGQTMvWms4LytoL2N3OVFYb1lObGdKdFpmTXZsSENmK2IvVElQVWpzZExPenpQU0c5M0RUY2ZjM241QVlqMTI0bnY1eDdmZWh5bEEvemdoUXpPRlJna2QyNmZVRVhxN3A0SnQydm5IZ2xnT052RjJQVy9Vc3VDMWJ0K0kvS3M0WGkvTkxaUE8rRWVrK0d6SDhlTDN4WUtNZTkvOEdUV3lkUE5Cb0hKamNPb0VpbFV3aGthM1hzNG1DWHdXaDRCRzg2WDR4WWhpUlJLSXFSb3JGaUZoTkJHTUhDKzBud0NOWW1ya1JqNXNUb1NkRG9SWWIvVVJZWS9ZaXBvUkFGTDZQcFg4VGUzTzFIU3N4ZkFJczl5MHl4eXZNUmJGVWUyd09wdE9LMkF4YUx3NXNocXorSUVTTWlJMlZYbDRlbHdUamtCeVdneFZoNXJFbHI2anBhYlZkOVJNUkRqazBWQkxMYTBnUllvYXVtUkxhQWI1M3FhdUlWdkJRT2ZsV3NxeGJ1VEQ5b09HY3BiOVhtaTNodjM5MHpJaS8yNCtZamlLK0pTcFp2R0I3cnFmRzR0VzJrVWdwNFZRMWhkbVlxTWtwQXU5R3MwaUtHbiszNmFKdURGM1VXUVhYTENUTDVlUkMya3VINHg3RGsvTGk0YlQzeHlSSlVxbjBMVE10OEk3REMybHpRVlFVc2VjelNIMXUwelJtdFE1SXZoTXlYN245WUhDbVFhcURZQ0tyOUlkaW1VNVVEUEJqQVAwUmxNQy84cjRwNUViTmF4SytFWDdhNEl5R01hRS9YbDVKZTVNUk1hTkZ0TFNXMkpsNWprTmNnK08rYmZPZU5sTEczQmE4QVdJdTgyWlNPc2hMVWY0R1hwUEJkYWJQeHpKaXVKbnc5NVFmMXlkd1haenhkTVJLZTd2TjBkd095eHJSUE43K05vZXJRdHh6L2xVSkxaMkVzb1lmamtyOFFWTGhtaEJVM1dzejBaYzYxT3FLV3daUXNNNDcxR09Ic0tjMHRTTnRhaDIwd0N3TmdVZmdiYjF1ZEw5cWNtYlRtTlQvZEdha2tmY3phbVNYWHk4MC81S1RZQk1DRHZ3aEZLR05SWHZ3aXM3cDNlZnd1elpNWUQ2QlpEV1hYcTFWQ3BWZnBwR2cvQzBISjZISWdhT1l0WXp0SDUwWWZJdnZoZUtZK3dwUnRITnV3MmVncUl3YlB3RjlYOHE2SVBBVGY2SjI0NDVZNUNYOGZqVnpVbjlxZENXZnpRc29zOVhmWG40RnYxVU53dTlhRVByeHF6TDVFY2dsd1RNK0V2STdWa2FmMGlmeEU1ejVVc1RLWjQrTVRXUitrSlppMzRYNEFZbDdwWlRKWitJZUIwY0ttWjA5UGMxM3VCMTREYXlIOXVHUmZFOG9aQkRCWm9BZVFFa0FENnVBY0NxTXFvaDJoZ0ozQ3dTZWNRTzVPQnNvU0VSbDBRMmEySUlrMTJ3L0doQUxUYVhxM3F2aW5KdDBPdmF1cSsxdGp1Y0FkNjZhc2NmRGZNTENBd0pseWpyWUhpdkNKOTI1VVhERTQ1TnFJUWZEaUZ1QktNenZSd2EvVEFwN3lDblhDM3ZiLzc2eFczSWtUNUtYbzdZRTdwRWtUM1NrRjQrT1ZjQURoOXNMeHJ6ZGNUeVhpKy9kNStEN25XMTJHMlhzN1hvNUkwYmlncG5ndytOMm9mNFhOamY2dXJjRFYrZENNUXozOEdFRWwza0Q3U2VGRlE2RllhNFE5dmo1TFFkbC9FdU9DTGFwVWJIN01tNm1KMG5mbnhvZjJBWnptQzR6b1d0RGZ4QzZuMlM5cXpDVmJGNWtzQ3hCVG5lV1FJaWtDWXIxblhObXFPcU91dlVQOEhpb2RFVm9HMCtGdlFkcEVBMnJyRVg4ZVFKTUlTcGZ0UWpPWjFhSCtiZ1YxY3BhMUlybm9WN09LbHpPblhkem5KSXRQeGpoNFR6bUhNTzVpaWdCVFNOL1luK0QveVN4OG9iRzVSSnRZa29yN2sya0dyYTF4YVdaQWFHZzV3MGJGREtyTWR4czNOR3gxV3g1d1hqTnplZmQxNHlGOFhlSjJQVXVHczhadFJFQkMxRDNDVHd2M0VmazFWNEpDaU0xTXp0KzdWZmloYXdEbm5TeXpXcHRZbms1bjB1WGc2Qng3aVhYU1FYeHd5R2FxMitLWnFmb0xaS1hkWHpwYXdrRisxTFpTa2k0T1JGbDZYcUVENW9zN3puSVVoSHRnczR4NXhoRERRNmRkNjJZMXBWa2tiQkZ4YVNpVjZhSWV3M1FtZncyc3lwdkhicVZGcmZLcXpOTURyamovR3ZJdFp3NHZoWjNyQXg5dnFlWDRqcVl0a2gvM05ESDhmc2svVUVBL2pBalJ0MFk4YnE3dWZsdXE4S1FQSytnQ3pnOWlyUTI4UXlhcW14c2ViM1VEanlDemwxSjgzOU5IWkxhMUNFcE0yaDJzazNja1BxNHBqbk1UNDRNWjVIOEJLMitrZzk2UlYrS2ZvTXo0T2ZVOTVsRXQ0VUdicWxVL2RucU9hVUtSSDRrTVMrRmxndisvUVZPaEE3SGhidGRmLzQ2Zkt0S2o3c3Y2L1dzUHZWczQ5bHZyQUQwUW9BVTAvM1l2MzdlQnh3RGlIbGZ6OWIxcWNZM1Zsak9WNWFyZ3NUVzVYRmY3QTZ0VUw4cUFsOGRnRmR2c3BBVWJCSjhXSjRSTmpub2c4cy9zaFRIUWpsTnVYb0diNjdwZERyWkxIanZJNW9uZ2x2SDIrNS9YZWlPazkyek5BOW5scVdvSUp2MXhvbVlyc2RPRE02QVV4ZTlxNWZiaS9ucEZ3SmYxZWl3MXdGcmhOdWZDQWtpcmtVOXREazlITk51R1laS3UwV0xFZDd1aHdRazdYVDQwVWZENElSMlM0ZnFQdWs5blZzMGRtUDNWWUtrOW1qOFVkclAzd2ZucUE0bDNzK2RmdFVteEFvTDBka0RpM1pOMUVJa1dJaHdwQVJqaHloWE1IdUtaMU84c291TEFOK0VXV0RNM3pvdHpPdCtNTkNrckc1Wm4vQ3JXN2ZsTWx3a25rN3hybGRPalQxWExQRDFFYmlsZXNnTTE2OUo0SW0ySFZ1WmpuTFhqeVk3YXZUNnV5WmEyelpvQlUvSWlXd3hrUlY1V0Q0a2NNM2JhazVwN3ZIYTU3Wkk3bTM3UmRkTk9MdHFpOVAxZDJldlM5UW1wbS9NN3ZEaWM0RE5yUitEUnpBZmIyR3VFWE1xMWlBbXgzVll0K1poaFpsQ3R4SFZFRUh3cFpBTmRZNHlLLzkyK0E2aU1yNkR4RnBwTWEwbEtvY09LV0xyMVpncHhWUmVNaFNUVnl3NTVvQmpoMm1BeG1HUkdVeTc3N1RFTmJIMU9hY2NScnh1b2JDdG1rck00SVV3U2RBcTlXazhHdkp3ejI4TmJRc3RoZGJJN0MrQUFNZ2QrQlREdFRKTlJYWENrTFNvUk9BeTJWMER6dVpqNGhYVmNoSE5ORExiS3Rtc1haVU5MVjZBMDJRa2MwYy8raWJQd1NpVzk3akRyUENtRTVNdEFZSkZ2eUJVSTQycWJDbjhYSFBlS1dlWEYwaDVIQ2hScVFwNWlROWJwdHo5TGVtS1R5OU1EZldPbUYwRVA2S0oxampZSFdPRmovRHdyb1lGWHViUm5MbFl0TXhNcmpCNUlDSHdSbXhQNXE3RjZRbC80YXJkeDh2a3VQc1Brb2FIQ0FlRm1NNkhwYmR2eHozWTZIZnFRMTlaVWpReHkrYkpqMEVvK0thWCthSVgrWHdYK1ZwVVovSkRianQ0amRiZERDMFRwUEpMLzRMUW94bnFYOGlzZUQ2NHdDazgyMVN1bUw3QWVtZUxaSVY1YVdKbXZpa1RFbHRZZmdWVEhKUlNtWUpQVDFRYm83TlhTb1ZYUDFUQlZCZ1RjcmR2V2J3ckl4QTZMQi8vT1NWTWF6NVhYRFRwcWNTQnlmSFZMMXlJWW51NTVmNGxGTU56UlNxVURlM3FXL2lHSnl1VzU0ZWdVcmtFbVNwSTlEN0lpOWRMUEQ5MHFzenByOHJpV1lybFEzQjBmMGtNSGFkUG5yempROC83MEhLcFFsRkV2NU9rRHdXUkhyaHI2K1JtaGg5MFFwVFg4WVI4dWdQeWQ2bnFYVkxlN3I1QnE5cUpGUGdabnY4TVZGRHZqSjBQNUFIU0RvSnJtU01vdmFYY3NIZnVBTW1DMlpUSWY2MHJhZ2I0b0h2U1lLOEwxdGlMSm9qZGlmeC84YmFjYzQwUHFDTWJkV2Y3d0hEUGRMS2RyMTFKVXdMOUhzRlhTZUtXVkVMVGVBWUpnU0VUemthY1hreUlUUnN6NTFaaEJxL2ZsV0hUMEFDRWhRUlpzMmtIZERUbGpLTDUrYnpmSy96MjFaR2pJNitTelNITVFaUjNycEFOV0JBbzRzZ29Idk1tVk1EZXc0U2NEeWQzSDl5ZEhCUnZHN2Z0N2hmd0pqbUlZbGdhNGRIbkNmZHhRNHJZNUttZjhRQjcyTVlyLzJKb0Qxa1ZBL2U2RFhhYkN5bkttSmNQNnFNcVY2alBRSkR1bVJyYjhRQTV2ZDNaZWUxT1p6dkJBd1luOFBZbkE5WFlmOHRpbDhKSlZTV3FRcE9xb253bVlra3VESnN3cm1vV09FSDZvK3gxVDlQSE8xNVpIMUtDVWJJRUhWSDJISWFaN1Naa2NkMktLN3ZrQ0pSM1FTTnViZlJmcmxJYlk5K3Bya0NpTXFabmZRNkpicCtkZHltVUN2RUlLQkJXbHNoT3M2MEtjM01tbVNMQSt5cWVNTGZKRnIvamxLeUJiTHJxY1hGVHBobmZua0RQWUFGdllZUlhYbGZsVDlVTGMzbmZFMnN6RS9zYTA5YzdEVnVRdVJ3dnlsOEx5LzhUUzNONFVZWkxsQTlzU0FqTGlMQXdQcGVmSzJUYlp0TTUyR3pzbTJqWFdXNlNjM2o4L0ZWSUNzMkZkaEx2MlFHaVFFQTVFNENzUUlVOGhiTnEwUmZHSERmMXIyWitQTGkxV01vam9uU0pRRC9ua1NPUXdJZEFnYkd0NTFHSUZ6VHEzTkdpSUgrenJkL0ZTYXhHL0wyL0ZqaCtMeDhXbmdwcm1UMGpXeHIxTm9TZUdpNG4wN0h4WnRIM2tub2hBU0ZRT0V4VFFsSlF1cnZWbUNaN0Z1QjhBTy9NOFFwL05ROUJaTUZKbFF0aitZempaTnk1N0h3dDdxRlRFSEZ2c29DTzNERStJdHpOUS9ocE0rcG5Vc2tqMCsybTdFVzlzdXNxc3FXbUxWNFdmSUdQOGREZ3dLZWlNVld5RXIvQWJPMStpK05iVUJFS2pZZ29TM0xCUDNnZzQ4Wkw5cWg4SThkeGxMNkpmZUlWaWlWY0liNUFmWHoyZmlvR1RLMlZPdTFFNGtmQW9yTHdRdFByRlhxU2VWOEdpV3c2QVVBVnN5OTlpd2Y4bGllZjNJSjNKSy8yNU1NUFQrTHg5Y1ZEOTY5Ly9vOE9RWEpTNXZmZWVmdnRkKzdGQlowSHF3enNxc0VNVzFtb3d1bGljUnJ2VEFqSE1wa3hDTCsrUDRYLzdTZTZZUjR1ZTRtRXR3eHhjUk5PQ09NaHA4KzNzWW85K2FSeVhnSDA5THk1RGRDRnQ3RlhXdHV3QXpvVG04R3BqVmJRMVEzd1hNR3Urd01pWC8rcVoxdnJ2V09HWllmZlpBUGVoR0JIMWZTWGkwWWRmdDFZVDU0bmdIQ2ZYVnlFdklQN2FtRUI5NzdEdzhVRm52cDEwR01YYmpMaFB0QTNDM1AzWHVTSmZrUnFJQ01HYlVsY3RDV2J1ek4yNFk1anYvMnJYbjZJc3h6QTY3cUtQMnFPa0NQcGloZ0NaN3MwTGgrY3h0dHNINFFSOXVmcEJMVVcwemZaQUF2TkFyYXAxREtUY3dOZklQSmF4R09RdmtHSEZlNG5IanhyalZUc0xPZ1FsOElHOHlxa0JlcFEyRGl6amtXWXh2OFhyZjNuQldudDVPOUhhNGlPNyszNEhVa08zbHZ4L0hoZjZBR1NWVEtRUG9PNExoSm8yNCtmQ1VwRHVaQUh1UlhkWHBoeGMxRHExNVZyaWdXWDFvRFhqZVkycnBrQi9hTldvZExrYUtyVnVrR3ljUWdJbUYreUFPS3p2QWlzNHdiTDh3YU1Cb1VHVW5lUjNiNEdQa3R5UUV3dFRPRlNEZDg1dVVvdVhLMTJIN2s3ZktBQklRYzRDTzNGUlNUbzZwMDhSdzU1ZDFHOVR2MHNpTk8xWTFsUUVMK3l3aU8ybGRFeVcxTG85bTJTd3VSdHRtV25HMStObXBwbVJtOXVlTTZnM0dCOEduaWY0dFlRKzM1bmFKMHAwY1ZGWklvSFppbHhTUGFWTVVDV1RTcVpVaVNPVm9uRVpmZFRRTXorT1ROS2cxdWQzV082L3BLM05PMjlDTWs2NzhpaVo5NGtDRGVabnZpTG92MTAyTTJyWU0reGJQWll0TGxBRnZlRlpvT1ptYjllR29NdmV0UExpWmQwblN6eEpaMkU5cmo1WmJ2NGpKcDN3Nzl1dDcyQW1lakZtckI4ek1UKyttZWhMNU1zVmtQS25BS2I4Vmxjd2NZMHpSY3NuWjloTlNpNTA3T1l4TXU0aTNBUE9kWm1MQVZqazlQU0dLRFpkVjQ0c1VaMEVtdHRHbHpRSVJFQ3NUWTdkWUpzZzh0VWF6RTRQYWZqZjZmSjVzZmtIRk9VdE50OWRRbHNVMWZuczFrQjZsREkwbHJwRHdRbmhyWlZjbnQxNk1SSlJaSmlrcVN3SFpnZGFFMjZheHUwS3ZnSDJKd0Y3c2FsWFlIdUJIT0oxSTY5ZVRoZFVuL1dhZzROVG5Da0p2TExSRE9zU3N1OFdCTkYvaWdkUlh1aVI4anVpQ2hVQkpFR3h0NFVYU0c3NmFONG1KeENqNlVMZHNKOERJWFI4NVN5UFlmdWFBN2tlMmpSOGVqdWVSUU9oZjRYMTM0MVFIaWNZMkJrWUdBQTRndmlqNmJHODl0OFplQm1ZZ0NCYTd1VWJzTG8vMS8vNzJKcVl6d0Q1SEl3TUlGVUF3QjJ0ZzR3QUFCNG5HTmdaR0JnUFBEL0FBTURVOFAvci8rL003VXhBRVdRQWROWkFMc1JDRVlBQUFCNG5JVlcyNUhrTUFoRWpzU2hLRFJkSmhlS1E1a1E1dWZxcW5iRzR3TUVxSkcxZXgrVUpCczN6MFltSWlvSDBVWkQ1SnprY2IyMnh1L2E5ZDdxOVNuMXVncWZWV1RQUXF3bkludkVHcGp5RFl0ajZoN09LQXU5TzU3WlB4eDdnWFBNZW1PdkdJaFg3ejdmeEhXYUMvdlZ1bStLL2V6UCtqcnJMcVNhTDlWaVJLeVIzOC9JWDdkUm5sSVAwWlZ2REtQZGZlM1lGbC83cHJZTFNUaTdyTjJIbEgrcCtZTTNqd1dHOUVCMTI5ZDV4OE1hOVA3QlhPbXo0M3BKN0Z6LzNtOTExRXYzYzd6MFEzeFc2Ly9GR3ptZnNWZTFvOTdQNnErc2RkU1AxNTZ2cW53Uk9WUE1COFRxOWl1STRCUzNuK3Q4MDNldXlFcmdoNHZuMW5Gcjd5V1BUWGtMdlpINVlMYjlIY2N4OHRqdGpuZmdYM1Vmd2I3RlV0eVBsdlA5clJ3d2EzNlFaT09RdmdFLzFFZXBBL1RJOC9waTNSZnlocC85OWRwcXJIdGc5dnI5OXJ6bUdqcVhMYmR2bHErUlM1OWxiSC95YzdQNFBIZmQ3alJyOWxFMy96N05CeGV5UEVETTdoUDRsdWFvYzJPTDNnRWZNQzdpbUtyeSt2UjF6QlRtcWZkOTRycmtBVzFQSENUanNaOUJML3lqZk05RVQ4azd2cFBLTHJaei9mblpsZVpkZzF3UTNDczF5K0MxOGJLWi9tNStMWENNNjhaN3JpOVIzRjJaVDV5M3cvTWpzNEZGTVhWL1duLzgwZmMxZUhOaXJWY3hSSDgxaXZzcnZUUCtveitLNVhlSDlxRGRMeCtXWHpIYlhubXVSbjNIbks2OWYyMFBjWGk5WW1iNFRIcnJ2VGpqdG1sdVZKcjQ3TFVCM2xYczg1NTN2eU5UNzROK3pvdnF5dDJDZFRuN2Z3MnZ6Zll4MCsrOENSOG03SHZ0MStlY1c3ajNKd251MTVHdjBILzZlY0Z0NnB4RzJVQkt3cDE2cThFc2dUeVdoODlrc0NQOUk3MGFkYWJ4djlCNzQxekh6dHpGdWtmOHptK0t1dzMvZFRBRy9XNGY5MXZaeDNkNmZuWnU5UGsyWWhuOERwNmN0LzhubEJwNml2Y1AyVFZ3ZlFBQUFIaWNQWlo3WE05bkZNYy96eU9UeVFwbG9TVzNDWmtRaFVhMlhNZVc2eG9oWSs2NVRLd1IydGJJM0VLamtkMFlJYlRXYURRYWJSbVpVSVJNTE5OY1E1dFFzL2RmODNxZDEvZnluSE0rbDNOK1gwbi8vNnVVTEJjN1U2cVdKRG1FU05VZGlFenBHZDQ1K2trMVk2VmE1WkpUc1ZSN0VsRW1QUmNsT1ZQblBJQklJRGh6OFNISXF4TW4xWFVuVXFSNlFjU1hrcXMzd2JNYi9kd3lwUHF1QlAyZmR5RlNKWGR3M2VuYmdMNE42ZHVRSG8wNGF6Uk44cUNYUjViMEF0aWV2UE9renJOQ2Fod2plVGtSNEh1QjIyU28xTlNSZ0hzemNwbzNKOEJzQVdZTDNyMFlUR3lSV3RLL1paamtqVTd2ZUttVmg5U2FuRGJrK3NDakxYa3YrUkxKa2kvODIrTkxCL0E3a3VOSFRTYzRkQ2JYSDgwQlhMc0VTRjNoMkkyemJyblN5MXk3azlNOVcrcUI3aDZKVWhEdmd1RFVrN3llK1BtS0Z3SG5ZUGdIbzdzM2VYM1Exdy8rL2ZLay91anVYeWdOZ005QXpnYml5K3Z3ZklPYWtDSnBVRitDNnhEeWhzSnpHRjRNSjI4NHRXOFNiOUYvQlBNWVVTcU5YQzZGNGRFb3VJMkI2eGk4QytkK0xOcmY1bmtjSE1iUmR6d1k3OUIzQWpvbjBIdGl0RFRwcURRWlB5YWpmMG9nd2V5bVVEK1Z1cW5rQTY5cHpDb0N2UkhvaklEemRHcG5rRE1MN3JQZzhpN3puWTJmczNrZmlRZVJZTTJoNTF4OGVJODVSSUg1UHZ6bjBYdCt2aFJOM3dXUjBzSndhUkdZTWZUK2dMb1A0Zk1SK2JIb1dveFBpOW1ySlhCZGdwWTRjdVBRdXBTOHBXQi9RdTRuY0Y5RzdUSnFzRURMeVY4Qjdvb1NhU1U5VnZGdUZSeFdNY2Q0OW1NMS9OYkFZeTAxYStHU0FQZFA4WFlkODE4UG4wVG04eG00RzlqNWpmVFp5SGtTWjV2WXUwMjNwQy9ndlptOTNzeDFDL2pmNE5GV3RHMWx2dHZvbXh3cWJjZUhIZXpBRGpqdUJETUY3M2FoY1hlNnRJZTZWTGgrQzY4MFpwM0d6TDZqTGgydTZlVHY1ZjArNXJxUG5jdWc3dy9vM1kvK0EyRFNTcG5NODhmeEJQb09zdWVIOE9JUTkxbk01VERuaDlGMEJQd2p6Q2liYXpaZS8wenZYOWliSE01ek1DbUg3OEZSZFAyS3BtTm9QWWIrNDl3ZjUzMHUvVStBZndLL2Z5UG5KR2Q1OERzRmgxUDBQRTM5R1hMUDRHTStoQXJRV3dEK1didzdSMzRoUE03ajF3WG1jSkhkS0lKREVSb3VNWVBmMFhvWlRjVjRVMHp0Rlh5NEN2NVY3di9BNnhKMFhlUHNHcitwUDhHNUR1OVNua3Z4N0FaZTNRVG5GajdlNWpkL2g3bzdjQ2hqQnZmQXZvZDM5K0Y1bnhrOTRGcU9sbi9BZmtqK1F6eXB3S3RIOUg5TXJ5Zndlb0l2bGVpc29rOFY3Ly9sRy9BMFZrWStNc2FSeUpheCtUSU9yakxWQnhEbE1zK2t5TlJJbG5GTWw2bkpjeTAvR2FkSW1kcXBNczdVdVhqTDFBbVJxUnNtVXk5QnhvMTM5VjBJYXA0ZkwrUGVuTWlRYVJCUFVOK1F1a1pEWlR3Q0NaNDlNMlVhVDVQeEtwVnBRazdUSUtKRXB0a1dtZVl6WlZxNEU1VXlMNWJKdEV5VThZNldhUlVnMDlxQjRMNE4yRDcwOGdHakxieGU0cjRkV3RyQjI5ZERwbjJvVEFmNCtLR25VNUpNWjdEOHMyUzZ3S3RMRkFGV1YvcDFCYThidlFMUjhUSTUzZEhWZzVxZ1d6STl5WCtGZUpVK3I1SVhETWRnOEhxaHRSZVl2ZERRR3o2OXllOE5iaDhuZ2g1OWNtWDZndG12V09ZMXZCamdTOUJ2SUQ2OTdrVlE5d1lhUXFnTmdjZWc1VEtEeVJsTS9oQjREK1YrR0dmRGVINlQzRkJtOHhiMUkrQXlFZzRqNlI4RzN6QzhHMFcvVWN4dk5IeEc0OWNZdElYM0pmSmt4b2JMdkEydmNjRUV1ZU41L3c1em4wRE9SSHBPcG1aeWtjd1VjcVlTMCtBVVFXN0VVWm5wbkUzSCt4bmd6b1QzTERTK3kvUHNPSmxJY2lMWml6bHduUVAvdWN6dlBUeUp3djhvdU0yRDB6eDR6OGVMYUxRdHdOOEZ2RitJcm9Yd1dnUk9EUHNVUTc4UDJKY1BxZnNJMzJPNS94aGRpMFhnOXhLOGkyTW40OGhiQ3Y5bGhUTEw0YjVpa3N4S3psYkJNWjcrcStHMkJ1L1hrTGVXUFV0Z2R4TEFTSURiT25xdmcvOTZzTmVqSlJHUE5vQzlnZXRHOHBQUXNRa2RmTy9NNTlSK0FlOHY0ZkVWTy9jMTc3OEdkelA2dG9DeEZZeHQxQ2F6QTl2aHV4MCtPNmpmeWU2bDRQVXVkbXNYbUx1Wi9SNTZwYkx2cVdCOGkrZHB6QzJOK1gxSGZNOSs3b1gvM2dxWmZlUm5rTHVmT0JBams0bVBtZlE5U040aC9NdENTeGJjZm9MSFlYNDMyZXpGeit6akwvVElRZHRSZVB6Sy9JL0I0emllNVRLZkU5U2RZSjYvOGU0a2VrNmlOWS9mMUNtOE9vMFhwOEU4ZzhZejdFQSszQXZvVTREdkJXQ2NSZWRadUp3ajl4eTRoZlE2aitZTHpQQWltRVhNL2hLL20wdHd2QXh1TVRsWHdMcUtSMytBVjBKY2c5TTFldk5kTTlmaGY1MmNVdnI4aGJZYjZMN0pURzh5bjF2NGVadmNPMkRmcGVkZCtwUXgwM3ZjMzhQaisvajNnRjE0d0N6SzJkMXkvUG9iM3Y4d2w0ZDRVTUgxRVdlUHlYK01OMC9vV1ltZUtqeXFZcy8rWlE1UHlYdGF4cCtFVVVTaExOODZheE5rcXlYTE9vVExWdTlMNU12VzRFL0dHcHc1dXNqV0RKUjkxa08ybHJ0czdYalo1eXBrbldObFhlSms2L2dSbWJKMVEyWHJUWkoxOVpWMUk5Y3RYYmErRDFFc3kyZmNOdUMrQVhnTndXa0V2a2VsckdlWWJPTm9XYThBMlNhNXNrMnpaSnZSaDArOGJjR1Z2K1ZzUy9wNHA4anlyYk90dUcrZEpOdUcvdnozWUgwU1pkdkNsYi9sYkR0NCs4TFZ0MGkyZmFwc0J6UjFESkgxZzI4bmRIVjJJUEprL2IwSmV2dURGekJUdGt1R2JGYzRkS011TVBFLyt1ZWs1d0I0bkdOZ1pHQmdPc3Rvd1NEQ0FBSk1RTXdGaEF3TS84RjhCZ0FsZndJekFIaWNyWkk3VHNOQUdJUm5uUWNpaVNoQWloQUYyZ0pvUUU0VVlZbzBLRTNTUmlraVVUckpPZy9aWG11OVNSUXFMa1BIQVRnR0orQVVISUEvenM4YkJBVzJkdjNON1B5akxReGdGNDhRMkR3Vldoc1c1RmVZSFd6aGtEbUhBeHd6NTRrdm1Rc280NHE1aUNwR3pDV2M0cHE1akQzY1VvUEliNVBheHoyendCRWVtQjNzNElrNWgzUGhNT2VKTDVnTHFJb1pjeEZuNG9hNWhMNjRZeTdqeEhIYU9yYXl0VlNwanRSN2xwN3NHdDFUNDNub202OEg4dGVUdmpMcFZNZlNjK3ZyRUdlOHQ5S09pcFh4clJySndVcW1pM0hEMmtBR1JrZHluVmRocUdWaTlFd05yVHV4Tm1uV2FnSDc3bEJIYUVNamhvVkVDMHNvcEtRait2N2tTM2kwdWpDa2U2VEhtQ09FVC9vdkUvSWZadnFrRENXbjJldzY2YUwrMnZTeHgvdjJwaDFTY2RiaTA0U2lQMGhpZ0JYdEtSYVVhNUJyRVpBT3N1bUk2S1ZmVVVlWTNTckp6bWJrRE1sM01jbW1FalJSb3pmNGxIY3BSVTNQaGdxUkNnQjRuRzFaQmJqczFCRitNN011Vjk1N09CUXJsQUtMVTdTbHVCUnBvUzB1MmVUc0ptK3pTVjVrOSs2akFzVmRXbWh4YVF1MDBPTHUwT0pRZDNkMzk4NDVKOW5OWHJqZnQ4bi9UNDRrUjJiK09YY0pMdEYveFNXditZY3ZBd0pCQVlwUWdqSlVvQW8xcUVNRG1qQURzekFIODdBVWxzRnlXQTFXaHpWZ1RWZ0wxb1oxWUYxWUQxNEg2OE1Hc0NGc0JCdkQ2MkVUMkJUZUFKdkJHMkZ6MkFLMmhCWnNCVnZETnJBdGJBZmJ3dzZ3STd3SmRvS2RZUmZZRlhhRDNlSE44QmJZQTk0S2U4SmVzRGZzQS92Q2ZyQS9IQUFId2tId05qZ1lEb0ZENFRCNE83d0REb2NqNEozd0xuZzNIQWxId2RGd0RCd0x4OEh4Y0FLY0NDZUJBVzB3d1FJQkhlaUNEUTZzZ0I2NDBBY1BmQWhnSllRUVFRd0pER0FJQ3pDQ1ZYQXl2QWZlQysrRDk4TXBjQ3A4QUU2RDArRU1PQlBPZ3JQaEhEZ1h6b1B6NFFLNEVDNkNpK0VTdUJRK0NCK0N5K0J5K0RCOEJLNkFLK0VxdUJxdWdXdmhPcmdlYm9BYjRhUHdNZmc0M0FRM3d5M3dDZmdrM0FxM3dhZmcwM0E3M0FGM3dsMXdOOXdEOThKOWNEODhBQS9DUS9Bd1BBS1B3bVB3T0R3QlQ4SlQ4RFI4Qmo0THo4Q3o4Qnc4RHkvQWkvQVN2QXl2d09mZzgvQUYrQ0o4Q2I0TVg0R3Z3dGZnNi9BTitDWjhDNzROMzRIdnd2ZmcrL0FEK0NIOENINE1QNEdmd3MvZzUvQUwrQ1g4Q240TnY0SGZ3dS9nOS9BSCtDUDhDZjRNZjRHL3d0L2c3L0FQK0NmOEMvNE4vNEgvd3Y5d0NRSWlFaGF3aUNVc1l3V3JXTU02TnJDSk16aUxjemlQUzNFWkxzZlZjSFZjQTlmRXRYQnRYQWZYeGZYd2RiZytib0FiNGthNE1iNGVOOEZOOFEyNEdiNFJOOGN0Y0V0czRWYTROVzZEMitKMnVEM3VnRHZpbTNBbjNCbDN3VjF4Tjl3ZDM0eHZ3VDN3cmJnbjdvVjc0ejY0TCs2SCsrTUJlQ0FlaEcvRGcvRVFQQlFQdzdmak8vQndQQUxmaWUvQ2QrT1JlQlFlamNmZ3NYZ2NIbzhuNElsNEVocllSaE10Rk5qQkx0cm80QXJzb1l0OTlOREhBRmRpaUJIR21PQUFoN2lBSTF5RkorTjc4TDM0UG53L25vS240Z2Z3TkR3ZHo4QXo4U3c4RzgvQmMvRThQQjh2d0F2eElyd1lMOEZMOFlQNElid01MOGNQNDBmd0Nyd1NyOEtyOFJxOEZxL0Q2L0VHdkJFL2loL0RqK05OZURQZWdwL0FUK0t0ZUJ0K0NqK050K01kZUNmZWhYZmpQWGd2M29mMzR3UDRJRDZFRCtNaitDZytoby9qRS9na1BvVlA0MmZ3cy9nTVBvdlA0ZlA0QXI2SUwrSEwrQXArRGorUFg4QXY0cGZ3eS9nVi9DcCtEYitPMzhCdjRyZncyL2dkL0M1K0Q3K1BQOEFmNG8vd3gvZ1QvQ24rREgrT3Y4QmY0cS93MS9nYi9DMytEbitQZjhBLzRwL3d6L2dYL0N2K0RmK08vOEIvNHIvdzMvZ2YvQy8rajVZUUVCSlJnWXBVb2pKVnFFbzFxbE9EbWpSRHN6Ukg4N1NVbHRGeVdvMVdwelZvVFZxTDFxWjFhRjFhajE1SDY5TUd0Q0Z0UkJ2VDYya1QycFRlUUp2UkcybHoyb0sycEJadFJWdlROclF0YlVmYjB3NjBJNzJKZHFLZGFSZmFsWGFqM2VuTjlCYmFnOTVLZTlKZXREZnRRL3ZTZnJRL0hVQUgwa0gwTmpxWURxRkQ2VEI2TzcyRERxY2o2SjMwTG5vM0hVbEgwZEYwREIxTHg5SHhkQUtkU0NlUlFXMHl5U0pCSGVxU1RRNnRvQjY1MUNlUGZBcG9KWVVVVVV3SkRXaElDelNpVlhReXZZZmVTKytqOTlNcGRDcDlnRTZqMCtrTU9wUE9vclBwSERxWHpxUHo2UUs2a0M2aWkra1N1cFErU0IraXkraHkrakI5aEs2Z0sra3F1cHF1b1d2cE9ycWVicUFiNmFQME1mbzQzVVEzMHkzMENmb2szVXEzMGFmbzAzUTczVUYzMGwxME45MUQ5OUo5ZEQ4OVFBL1NRL1F3UFVLUDBtUDBPRDFCVDlKVDlEUjloajVMejlDejlCdzlUeS9RaS9RU3ZVeXZMR2tZbGhXS0tHcTFmYjgzSnFZUldpWERXcEZFY2Qxd2piRGZNbDNmNU9ldTAvVmFwdkJpRVRZMWtXV2N6cWltbVNzNnNvYUVvZE8xNDZyaHVpTHNPaUtxR3YxMjRocWVLVFkyK2lKMFRNTnJSYXFLNFhVVG95dGFqbXcxQ0VYc2VOMFNGN1Q5Y0o2ZnVhSmwrVWxiM1liZXRFVjJ0M1RLb25xZG5USWxRUzNqUXkrRitqMFZWRFVxR2lkQjJRaE4yeG1JMVl3dzlJY3R3NDFicGhPYWFlMVhXMlZEcTcvS3F0cGM5aXB6RXN4TWJJdmE2NFIrbnljaGp2Mytza1ZXMmNmeVJUYlZ3OUpGeHRqUGR5Q3J6VTZvcXBIck1GcVpHT0dyUGl1MUx2cXMxTHI0czFKekV1UnNzWjkreGZ5VVRjOVUzcUlhbTVzeThmczNKb1lrU0p2SVRjQzBKZGRvZnVCbnAweHkraFhQMWM4Tjltek9JdHVieTNIVjJrek93QytZTnFZWGtJS3FWTnB3YmxDbkxibFh6US9tN0pRcENWSStIc1RtbU1zR1pzWk1WVzZNS2I5WFJaTWtIY0ZJRGFHZEo0UGFoRlJTYUdkZ1VOSmdIU09LSE43UkEzNWx2Z3VQTjJNckdqSHFSeFdEYjZFVDlkRGc3MDBzeDI5WklqSkRKNGdkMzZ1MERiTTNaTWRSYnhzV2IyZlRGbWF2cUhDemJhaWQzNHBNd3hYVU5tUmh6Mm9aaml3Y21yNGw1RXMxTWh3S3d4b1RydU9WVTFMZ2U4U3RSWUpiZEZ2eVVzbllMSU9laU1jUDh0ejIvWURyeGphM0d2TTNqSGg0M2JpWkVkRVA0dEg0VVNkeDNUR3hEYmN6bXhFNVM5THpaVHh5amNoZVBXT3hIUXFSbFltb0xheENXNGl3MWhiOEJxcG9RY0p5MnpGSHZEQnJiY2Z6VFhhSjhvdWNNTFl0WThTT3R5ZUtiZGZ4dUs3dnFrdk1sMzY3SVAxelJWNzZSdGhydFAyaEsyZEdmdDJZQkk0WFZkditnaDU2WWxUa240aTR3SUo4M25YOWdTaTNROE5ocHp6ZkRoM1JNWG53V24xaHNUdDJxMk1MbCtHbElFSnFKOTFLTzNGY2k2c3pjRjMyeVo0Q2tSanhiQ1NoeDJXaUd0ZVdYeEw3WVVQT3NHY1pvWnpRbVRGUmI5UWNVKzR3WGo1aEM2WnI5QTI1aUNZMStvNlhSSk1hZ1p0RWs0ZXgweGRSSmFQY1BVY1VReTJoRkhJVUNmMlNKbHd1aUJKWFJNUmhiWjUvWXNxblQxdlVQcDJ5NkgwNlpXS1hvcm1LS0JvcWg2Q2hkZ2dhNXgzQ2xDWFgwWlJEbURJbFFVVno5Z3dNNHRiRWsxVVZsOE5TTjBYSUlaaW5NQlkxMDliRmhGSFZzQzNIUnlGZUl5STFCbzVvcUNsSnZ5Z2x1dGVpSW5OOGxiTEFpV3cvMEVPYk05UlQ0dk4rbjlWWUtRUlpzSjdqTXhyMzVQTGpSN1VKVGR2dmVmS3JjKzFyUTFvdk1JWmVycDZrYVc4ckV5RzhYRytLcDdWQzNpVzVXcElXRlZ6RzEwSG9lL25wWDJ4VHdYYVJMWjNRYVNOSHZjeVMweWVMYlZQTjVUWEsvQ0lqTys2SlplaU5pV3lnbVJFZGdET1dXMXVMYlZQZDV0ZlgvQ0tqWE1xcEpRbDRsSGl2TjlJUDlQell0RXVhekpxdUU2aloxbHQ1WnNKbG1LaU9hVkZOdTd4NllwNnZrZUFhaGdvUVBPbEwyWkpZNm8xZDM3QzBqNWd5eldtYUJObnpSdDVRVktSZ3VrbTdyb0lET3pNV2locWJmci92OEtSTHpQdStLd29TbGt5LzB4R0NUTC9MdkJ1VlRkOU4raDd2R2k3T1FsYjJVVTV4SmIzTFF2MkFJMkZEM3BVaTVsTE5NUms2bHFoa2JONzB2WUVZK1dHTHZYdWNGc3hadU5kZ1ZKV1hkQUpDNmYyVXhHNjFPU3oycGl3c016eGUweE5MbWVPcnlYR3NZSVlzUHZnU1JiYmhoRkhCVE5xOFZmbkNiNXVFTWdDUW1jUVZ5NGdOR1JJTGxqQTZkWTdQdlZqdjMzS0txNVpqZEQyZW1Lak1xTzk3RmxtZVViZDhsME9Sa3VRS3AxRnhYdU1PTzNjT2FMS2RaZE1XVmFvNVpTc3FWclA4ekdGV3N0bXRXRW0vTFlOZ1FYNWZVYXdRWmp6RDFBbFlkTFJzdFdrbmRQSmtNUDFrMEJROHdLNGZpQmIvdk5reDA0dTZrdkVTZTM4T1kxV1JoTDc2c2dhSEdwdWx2cElibFl3c3pRV2c5STJuVExyVjVYbFRIRG9xWTZqbmpEV3hFQ2hWNDhiekdSd0xydWFVcFo0eXVaQktHbk1WbGcyZTRVby9yZHpYbXRPV2RNUHlnK1d2OWFBNVpheHplRzVadkdJQytmbU1sZjRnUnMwT3E3aFdwdFVhaW5YOFVCTHFHQXVsanVoeldHMTBIT0Zhckp0NDZZM3FIYmx3UmRoYUllSkt4M0cxV05OQVowczFUYVFrMUZBNWlhcUd2QWsxa25PdUgvT29DWGN1ZytNQlZBYW56OG1nZnBZS2swbDNxVUVYVkFwQnYwOWdkWFFYTWg3T2F1UVBPWnYwT2FuVXBaVmswSERBbys3cjhrTS90QW9TeVhiNnNpUEoraVcrOEFmUGQ1eFF2cUhNU0JPT2V5SXNTQXRYRFhuVVdMM084SXJ2Nm84VnZHVUxraGI1RXZYcUhaWnZQR1J5ZlpZMExuUjRhemM3dnAvVHFHTm1DN2N2UjljUGU2N1RpY3ZwbEJUWkh3eTVnU1JtSlZqdXNwNEoyQXQyRFY3ZjFCWDlXcGNGa0FoWjIwU0ZMbGRyZHJudnFNVVNrVi9aS2JMZ2E0dHExM2M3cWplTnBQT2M2WWFHbGFRTDNnZ3FkcnFJME40VzdlM1EzbjdPbHN2VDlwWHk0ekMvVUZjRzExbkZMMVZUT0RCNGJhVlFHS2FZMVZDT3VQTG1lYTRTcXh4WG5yQ1pNM0QwbXpBUnppZ1NDbE00QTM2QnFxYThHSFdkeUhTaXlBOGozWHNVOEFOVmhEMWpUNVJ0WHVteDBTWGJzc28yWnhMY1FFM2VBNXRqVWxSa0dNWlZkVzBMSStZaUMwYlg5OG8yeHpFL0hOWDFtbThGaWV4Tlk4Nkh6RjVVc1AyK2FOaCtGRGl4WHBTell4S04ranhCbFl4enhTVFVjOEVUTkROaEtwMlkwQ2hXNzVMeGl0TmlWODVmVm5FNE5zak1xZTVZT2k1SUI1N2lvdG9oSlhYbEtwNVUvSTVYMWNCUDRxSkNKYzRoT0pRMStKWkVNYWNuMHVObHBPNTRIVDkxZFJycitTOUl6QzBOdUNhUFJVbCtpMlBPckdCdjBmTGxTWTEwTWNSRFV1R2ZpdmVWN1BpbTVIS1U1eXpMNWJCVGRBWEhsUmxYOERKVmEwRzU3d2x0YUppb3VGVEpTSlVYdmxRcFBOK3VYQitjWnJRTDBwa3haVWt2L1hkRmlnMDFGZ3J3bGxEM3hDM0krd3hMRDcybWxaZXRaSUswcVlEY2laSlZ4NndnMFRKV0t0M1c5TEhNWXB0U1U0dHNPcGd2TXJKTXoxblVMc2h4dFF0eVhPK0NuSUhGbU11M2dSUEpmTnBOT0R4WmZsamtpWGJNRWw4OWxnSFNPOC8walVCdWNuWTZhbVFudEN3aDU0RlZlWmNqRmhHak9qK01VcUhaVkpnWGdkOFRMWHVLRGVvNVZwQzR4QTYzNThUVUYzYVpKUlV2emxHMTc3QUlZYThmekNpa2RwVjhpN2tjVmRHbU5qRTBsSzlPRjF4VGszVGZwY3czWThuU2dta2lva2l0NzdmVG1MTTBneDZITmtmTHgybFRTVk8yZXJ4dkdicDZnTWEwMFBjNTBQUjlYdDRxQzIvMi9TUVNtZDhwOXBPSWg5b1RDWk9xSjRhUjhuSk5sc0lpeXFKUHcyOUwzZExxaG40U3pLUWs4UlF0cDk5UjVuMG90MTg5TUtSN2E0Y0pqMGNnRDBQVjhpMXBXRmV0YzlBeU9ETlRXT3BvUnFIQkRqcXdpNEU4Y1drRWhueEZQWGhGUllnem9YSzZubXZ5cmdlTUdFcHFPcTd1UlVGWjBPT3RXNWJ0cTNlYXpGRWp4YXA2U2daU0lITkhraFFESHJPb3F0NVFObGxVcU03WFVmcENCWW41a25Uck12aG1DYVhDNlJScmtvNk1McFc2RzRuTGdXK1ovSjBVK0g0bDhNTTRORmdtQkg0aVhUdXY0S3FLNUMxVzhXdEl2WjBkTjZrRE1yMHNscjJHdlJpRU12UUh2RlNGbGZEelJwQ3NXaVYxZ2NOUnBiUlNIU2ZOY3RZWTVWVGZoS2RDTXVQVmxZbGpzWG94N2RyS2hOZUN6dlkxVkx1NEhCb21GNDVMbkk5WWZuOFpoNjQ0UFdtV2NZbGpyRmc2c1dWZk9UTXhTU1ZZWmlyWFpJV2xoSyswaUFTMVVIVGxTUnpqUmlnNDFNYXRiWlhmekVndEJYTEdOYXp5elpVZTN5MHFWQTlGUEJSNjZaVlRYQWhaajVka1RCVnhMWXl5S1NHR3RWQmxwSEx3R1FaQ3cwTEVxbU5PbnNaNVBCMlovMStXR1dLZjNSWFBBcWZoNWRSV1lacXczQThia1pCQ1VTdTJla3JrM0pjMDVsczQ0QTNIOFZzcFhIY3VROWxKeVBoUjNOQW85UkNLMUZtWjlUaUVxQmVPYktWY2RVa0ZsVHdyYVZMZ1c5Q1VsMEFLRzZsK1o4Wk1Ta1NySVk4M0FuMjIxcDNORVhtWTJCeHplZnJDYmNxbHlkMG5jc21aUEpaMTlTOE5SMjNNY29xYlUvL21hQ2pHN2tITllVWktFaGd1VjRsWmZ3ZHprY3ZySVpRcFVmYjltV0g4YUxENDBhQVk5ZG4zbGFPK0x3OVlxcEhuRDFtTDlzUXNLd3JaWFdBYktpWTFjenpodmhSalA1Z0t0NW04Z2NPeW91b0FTeUV2VWYrKzBkRnR5c0x1VC9Fa0tNaDdrNTJuUFBQVm8xTmtaZ20yT1hxNTJBN250aW1ycDdtTlBIa3RhVHducFZFK09hZ3FnOVJQQlltYXZDT0NTUnFqV0txWjYweGlWbUtjY3ZQU2tOSnRKTTh5Sk9aTVdPLzBxc1JEZ3pjMFcwTzVOUWFPR0hLam9jUFRiTE1yNzlyVktHbHJ0MUppTkRSR2xTaGhGOEFaSlVXSlY0OTRaNFQ2ZVNVYWVhYmFzQktVbzVFVU1hTEJpYmhNUE5qN09sRlJrWnE2cXFsZm1zRmNMSnMyTlZNYUp0MnVzRXFhbGZVdDRyS20xS054S2dFbWxOak5GdmdudTR4WXRjYkdnbFBYTDZFUHpMa01iMFREWmVOQ3pENWErcSthd3V5RVlyc1MyN3hZdzY0b1M4Q2VCMk43UHViY3A1OTJwekwrdWJ4Rnp0dVVRVTdUc3J3aFBSVmZPMitiUGkrdjV4NHhUdnJ0U0o5enBwZ1hva0w4b2IxYXJJNUVsTWZUc0tIU3UweGdhSklKRE0weWdhRlo2ajRVS2NReVVzUitWL3BoRGpQVkRITGZuQ1lKcWF5SzBsOTdzM3oxSXAxenFiUEhISmRsSTNXQ1VWU29JcGVWV2hNU1ZMSURnMW9zSmRGSXY3cUNYSnhURFlyalVTVWU2SU5yakFjVi90UlF1SzVSVFZTRzUzaWl3a2lIQlFubUVvOFQ3ekNTbVlocGNnSllTdzFPUENvbG50VE5iTWtrY0VuRGtqNUdxeVdSbFk2VmdtbTBZMkdoUDBzQi9ieXNjTitxcXJzNmJsWW9FdXpxNDVyQ2VoUWxMTXBMMUdEMTVFV3NRV1EyMjh4SXoyTjVQMmFjdFBGa3BFei9TeW9qRGM0K2treXUxalNSWXJTb1lHSGdHRzVSWHRnZ0UvbFoxaXN1UjZNc3A2NXIvYUlXVDRiNzNIWXR4WEtHVTVnRVRYWVl3bFlTVUtZR1kxWlV2cUUwMUp0amFBdmhtdkxZclR5VWFTS3JucUhUY1dwRHpxZTA4bStrVUoxNHpxYWt6enV2NzZ5YWNNN0pKWjlKT2FzU2xxR2lwR2xsNk92L2lKZUdJZXMydTdqUUN0bm5qSVMyTGxueWYvMERCdkU9XCIpIGZvcm1hdChcIndvZmZcIik7IH1cblxuLmZhciB7XG4gIGZvbnQtZmFtaWx5OiAnRm9udCBBd2Vzb21lIDUgUHJvJztcbiAgZm9udC13ZWlnaHQ6IDQwMDsgfVxuXG5AZm9udC1mYWNlIHtcbiAgZm9udC1mYW1pbHk6ICdGb250IEF3ZXNvbWUgNSBQcm8nO1xuICBmb250LXN0eWxlOiBub3JtYWw7XG4gIGZvbnQtd2VpZ2h0OiA5MDA7XG4gIHNyYzogdXJsKFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFRcThBQXNBQUFBQ1R4d0FBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCSFUxVkNBQUFCQ0FBQUFEc0FBQUJVSUlzbGVrOVRMeklBQUFGRUFBQUFRd0FBQUZZL3VGRCtZMjFoY0FBQUFZZ0FBQlNYQUFBdENDanU3MlJuYkhsbUFBQVdJQUFBMTgwQUFlY0k4N3c3bUdobFlXUUFBTzN3QUFBQU1BQUFBRFlQQzRZNWFHaGxZUUFBN2lBQUFBQWhBQUFBSkFRN0JRVm9iWFI0QUFEdVJBQUFBbm9BQUFzMFdFSCt0bXh2WTJFQUFQREFBQUFGbkFBQUJaeGJJczhBYldGNGNBQUE5bHdBQUFBZkFBQUFJQVAzQVFKdVlXMWxBQUQyZkFBQUFWa0FBQUx1SXNYaU9uQnZjM1FBQVBmWUFBQVM1QUFBSldoODF6MjZlSnhqWUdSZ1lPQmlNR0N3WTJCeWNmTUpZZURMU1N6Slk1QmlZR0dBQUpBOE1wc3hKek05a1lFRHhnUEtzWUJwRGlCbWc0Z0NBQ1k3QlVnQWVKeGpZR1I4d1RpQmdaV0JnWEVhWXhvREE0TTdsUDdLSU1uUXdzREF4TURLeklBVkJLUzVwakE0ZkdENE1wM3h3UDhEREhxTVp4amNnTUtNSURrQURGSU5QQUI0bk8zYWFieFBaZGNIOE45dm5ZT2lwSkVrSVUyS1pLYVNlU2hFaGtTa0lzMmxRbWttTkNtU1VpSE5zNlI1RWhxa292RnB6cTNTY0d1NDk3WDN2cnNiOWF4MWZsNC9iNS9ueFdOL3ZxMDY1L3ovLzcydmExM3JXdGNSZ0dvQUt0d0JyaEtvZFN6by80YWF3L3lyclBwNkJXcFdmYjJ5WmpPQWpmeUxOZEFvczZ4YVZqdmJNZHM1MnpWcmtEWE1PbWM5c2dIWnlHeDBkbVoyU1haWk5pTzdLcnNtdXk2Yms4M0w1bWVMc2p1eUpkbXliRjMyYnJZKzI1QnR6SDdPeW14enFwVnFwKzFUZzlRd05Va3RVdHZVS1hWT3ZkS0FkRXdhbmNhbDg5TzBkR1dhbSthbG05TXRhV0Zha3BhbXg5UHphVTFhbHo1T242YjE2ZHYwWS9vbGJjNloxOGhyNVEzejVubTd2R1BlTngrUWo4cFB6eWZuVS9KcjhsbjVEZm04L05aOFVYNTNmbi8rVlA1cy9ueitZcjRxWDVlL24zK2UvNXh2THVvWERZc1dSZWRpUURHeUdGV01MeVlYbHhSVGk1bkYxY1hzWWtHeHVMaW5lTHg0cVZoVnZGcXNLZDR1M2kzV0Z4dUtiNHFmaXJ3b2k3OUtsdFhMT21XVHNtblpyeHhVRGl1SGx6Zi8vVGVRSWF2TWFtUjFmSVRxVm8xUTQ2eEwxanNiNkNNMEpqdmJSMmhhMVFqTnltWm5jMzJFRm1TTHM3dXlwZG1LN0ozc1F4K2hyN0x2c2l6N05TRnRtK3FrZWo1Q2pWTFQxREsxVDRlbUxxbFBHcGhHcGpGcFlwcWFwcWM1VzBab1FYcklSMmhaZWlhdFNHdXJSdWp6dENGdDhoSDZOVWRlbWRmTTYrYU44OVo1aDd4TDNqOGY1Q00wSWIrZ2FvUm1WNDNRd254eGZsLys1SllSV3Btdnp0L0pQOHUvekxNQ1JZT2lVZEd5NkZJTTlCRWFVMHp5RWJxOG1GRmM1U04wMjVZUldsNnNyQnFodFQ1Q1gyd1pvY3hINlBmaWJ4K2gybFVqMUtvY1VBNzJFUm9SSS9UL2YvNkhQL1NWMXBSN3N3MDcrZFc1NmpxZmwvRTYzdTNYQ243dTExZFYxMForeTAxKy9jek1xbHROMjl2MnRRNStIV0tIMjFFMjJzNnpTWGErWGViWEZUYmY3clQ3N1VGN3lsYlpCL2FwYmJSTjlxUGw5c3VXNjFmYmJKc3JVRkc5b2w1Ri9hcXJZVVd6aWhaK2RhbzRwS0piUlkrS295cE9yVGk3NHB5S0t5cG1WQ3p5NjhHS2g2dXVwVlhYc29ybktsNm9XTDdsV2xHeHJ1S0RpZzhyc3NwdEtydFU5cWdjVTNsUjVmektKWDY5VUxuY3J4V1ZxeXBmOGV1MUxkZnJsVzlVWGV2OGVtZkw5WUZmbjFhdTkrdXJ1S3J0VXExQnRTYlZtdmdBOWVWcWE4aXhOdEFlWkdzNzF5YmFlYmpkcHR2dTFvQ0Z0Y01IUEJXdjJmYjRuVk9zaGgzSEczZ3JPL0pFZTg2ZXNlZjVHd2JaYVhZNlRzVnAvQVV6ZVNqR2M2cE5zSE84dWxYRFZxak9lVnpIQyswcFR1SVhmQUFWTmdOL29yc040cTdvdysvNWtmVm5WOWEzby9BWG5zVnpQdjdQMnVWWXlOOTVDYjVEUDdSR0d4eUtGdGFVMitNTG41c1gwWk5ic3crdlpEdldZMTNXNHJlNDJJaVBlUzlld2pOV3gxcndFQjZNYnVpS1d6R0RWK0MvOElrZGFXM3RFdTVzcld5dTNjR3IrRFcvdE1YWWFEdnhlSnlQK1J6T28za01oMkYvcjlQTjBZeUgyeHQyQnR2Z1BIU3hoemdiYTlrSlAyQUQzN2U2MWg5SDhVYk90ZUYyaTUzQWUreEd2b3pyTUEvWFl6WSt0TjdXM1hxeDBtNWpUenNWSjF0N204Ly80dlhjQ20vZ0xidlhCdHRJbklEM2VRWnFjaGtiWWd3SDhDZlV4bmFvZzIyeEEzYkVUdGdlLytKTUc4K1YzTXkvN1Fpc3NrUFlqWSt6QjZlemc1Mk45MnhiM29SdjhiWXQ0cCtleTl2WUtEdUcxZmdybitIVHRpK3VZRnZiQVk5aEdSN0hVbXhqdCtNQy9FM2FqdnpPTHVNTG5NVnJzSWlmY2lmYkU1OWlEbTdFWEZabmpzSjJzYmRzWjF2RGc3aUhIV1pkckt0MXN4N1cweTYyaTNnNzcrUmkzc0VHdk0rTzVTdllHWk53QTM2ekZaeGpmVmhoQzltZk03Z2JKbU1GUDhiMytLZFZ3MVYycHMzR2o5eWZMYmtYbTNNZlg0Mk5lU0QzNUhWWXlmYzRuaWZ3QSt0b1Rhd3hUbUYzbTRleC9DZlgyQ3BjaE9QdE9ueUpYdHlGYjJNY2JzRUMzR1l6N1VxY2lBdnh1dTJGbTNFVGt1MW45L05WTzVyajdIRSt4aWZzV3J2R0h1TWp0b3hMK1NpWDhIWDJ0ajNzUG5zQXg5blZOZ0lqTUJvamNTeU80V3M4aDIveUxSdUMxVGlDWi9Nc25za0pQSlpET0lxRE9ab2pPTlN1c3Ezc1prekY1WmlHUzNneEgrUkRmQmdmOFVNYmFnZFljNDdoUDJ3QlRrSnZmb1Z6MEFPMThKTzE1bDA4anVhN3Z0azlQSmNUYmJKTjhjcHhnZGVQQTNFMC8yV3YybXUyMnE3Z2s5YlpsdHV6OXJBOVlrdnNVVnZxVmVVdXU5VnVzRGsyeTZiYU5LODZ3MnlBOWJVMmRwRHRZN3Q1WFRLcnNFcit3WXcvOEVkTzl1cjFHVC9oV2o3SDUza2JGM0FoRi9GbVR1T2xYdVV1NEVrOGtnTTVpRTNZZ3MxNGdOZkJwdHlPdFZtSE5mRUVuc1JUZUJxZll4MWV4Zk40QVM5aU9hN0dOYmdXc3pBZGwrSXlISTYrNkl6RDBCYnQwQjRkMEJHZGNEQU93WUZvaVlQUUNydWhBWFpIUSt5RnZiRVA5dlhPcHpHYVlFODBSWDNzZ1ViWUQ3dWdMdXBoVis3QUhXMDcxckJ0ckpiWDFxMnRFWVpqRkNaaURkN0VPM2dYWCtGci9Jek5CRnV4RnkvaTFieVd0M0ErNytkVFhPNTEraVd1NGdaK3cyUzF2VEozc0lPdGs5ZmxFMjJjamJWVDdGSzczbTZ5dSsxMWU5bGV3V2ZjRmtNd0dFTXhES2ZqREV6QW83Z0RpM0VuN3NaZHVCZjM0SDdjaHdmeEFCN0dRMWlDUi9BTk51RVA3dTU3dzJFOGd2MTRNay94M1dFOS96SllTK3RueDl0WjlyU3R4TmJvandFNEVnTnhGczdFMlRnWFUzQWxYc1lyK0FmV2U2dVM0MWVVK0EvK2pWKzRIL2RsZTNiaFVSekowM2c2eitQbGZJUHY4aDNmYWY3Tmt2K3grbGJQZHJWbXRyOGRhbVBzSkR2WkxyUW43RWw3MFY2d2wreE5yODNWLzdlM3ovOERmN2FKZnpSK1dQOWhhNk1qRlBiMVNPRnFqeWJXMEdPbGNLekhhbUlEUGRZUWU5RGpWc0xXSHJjV085ZGpUYkdKSG11Sjc0bkl0aEhjN25GYnNla2VhNHZ0N3JHT1dBT1Ayd3NManp1STc2ZklkaFI4NEhGbjhUMFdXVjNCYXg3cmljVjc3Q3I0M1dNRDRSU1BEY1hpbVJxTEhlZXhpZkFHajNzS2IvWFlWTmpSNDE3Q0V6M3VMZmFjeDMzRW52RzRyOWp6SHZjVDMrK1JOUk1NOHJpLzJHa2VEeER2QnBBMUY4Unp0UkRFenh3bzNpc2dheW1ZNmZFZzhmNEJXU3ZCZUkrdGhWTTl0aEdiNExHdGVKK0JySjBneHFHOXhIa3M2eUNJZWU0bzhCV1ZkUkxPODNpd2NKM0hRNFFYZWp4VTdDbVBuWVdUUEhZUmZ1R3hxM2hYZzZ5YnhCa3c2eTdlNlNEcklkN3pJT3N0aU8vM0VZc3g3Q3VNZVQ1Y0VOOC9Rdmk5eDM3Q2p6ejJGNHM0UUJqM01sQlkzK01nOGI0SzJSYmVZU0ViTE41cklSc2lpSGtmS3R6a2NaZ3dmdVpvOFo0TTJYREJRby9IQ0NNblI0aDNiTWhHaXZkdXlFWUw0dDdIQ0dJK2p4ZkVmSjRnaVBFK1VSRDVNbFlzY25hY01OYkNTWUlZLy9IQ256MmVMTjRmSWp0RjBOUGpxY0pZMzZjSlkyeFBGMTdwOFF4aDVOR1p3bGgvWnd0alhVNFFSajA0Ujd6elJIYXU0R0tQNTRsRlRab28rTmpqSlBFT0ZkbGs4VjRWMmZtQ1dHc1hpRVg5bUNJVzQzQ2hNSEx6SW1IazdNV0N5THRMQkpFRGx3bGl2VThUUkI1ZUlZdzRYYnd6UmpaRDhJbkhxOFNPOUhpTldLeXpXV0x4T2RjSm8yN05Gb3YxT2tkc3JzY3Q3QTZQTndyanZlY0p2L1k0WC9pbHh3WGlIVG15aFlLTkhoZUo3ZVJ4c1RCeTV3NUJqTjlkZ25pL3U0V1JwL2NJSTMvdkZVYk8zaWVNSEw5ZkVEWHNBWW5mMzJRUENxS0dQU1NJbXZld01OYm9JMkp2ZUZ3aUZubTBWQmk1L1pnZzhtS1pJT3JIQ3JGNDc1WENHTXRWZ3RqalhoWkdyWHBGL0FTQzdGWEJCbyt2Q2QvM3VGb3NjdlYxcWFvUGF3UlJBOTRReHB5OEtZeTVla3NzeG0ydDJDMGUxNG5GR24xSEdPUDZybGk4ejRmQ3VOK1BCSkVqSHd0aXpqOFJQeUVoKzFRUXovdVpJTjdqYzdHb2tWK0lSWjFjTDliTDR3Wmg3TzFmaWQzbThXdGhyUGVOWXJIdXZ4TkViZmhlTFBhSGY0cEZ6bXdTeGxyNFFSajMrYU13OW82ZkJERitQd3RpekRLeHlLOGtGdlUxRjR0YVdBaGlERXRCek5ldndzaVozeVIrUDVqOUxveDgrVU1ZKy95ZmdxaWpmd21qOW04V1AwUENQNzZLbnlhUktINnU5RU9TK0FrVHFVTDhySWxVS1g3cVJLb21mdjVFcWk1K0VrV3FJWDRtUmRwSzhDK1BXd3Q5NzA0MXhid1dwMXBDeittMHJkRHZMOVVXL3UyeGp2akpGbWw3Z2VkOXFpZm10Uzd0S3ZUNmx1b0xIL2U0bTlEMzFOUkE2TFVzTlJUNmZwOGFpWitVa1JvTDN2UFlSQ3p1cTZuNE9ScHBML0VUTmRMZWdyYzk3aVBtTlNqdEsvUTVTUHNKdmM2bVprTHZDOVArWXFNOEhpRG1OU2MxRjhZWXR4RDYzS2VXUXEvLzZTRGgweDViaWNWbnRoWjQzVTV0aEY2VDB4WVdjOWRlL01TUDFFSDg3SS9VVVJEajFrbmd0U2tkS3RGWnA4NWkzdE9tTGdMZmgxSlhRY3hYTjJIa1ZIZXh5Sk1lUWw5anFhZFlqRWt2NFFzZSt3aDkvMGg5aGI2dnBNTUZNYlpIQ0wwdXBIN0N5TDMrWXQ2L3BnR0MrSm1CQXQ5djBpQ0IxNkowbE1Ccldob3NjWUpLUTRTK0p0TlFnYS9KTkV4c0Y0OUhpL202VHNQRmZJOUx4NGg1RFUwamhURlh4d3IzOERoSzdEQ1BvOFZpTE1lSXhWZ2VMeFpqZVlKWWpOK0pZakYrWThWOFgwL2p4SHkvVHhPRk1VZVRoSGQ2bkN6MGZUR2RML1I5TVUwVnh2cVlKdlE5TDAwWGkzdWZJZlI5SmMwVXhQTmVLWWpQbVNQd2MwVGFBbDZuMGx3eDM4UFNQR0g4N00xaU1lZTNDS1BlTEJEemZUMXR3WmpiaDRSeEx3OExZMzAvSW9qbld5S0l6MW9xOUgwbExSTjRUVStQQzd5bXAyZkVZcTA5Sy9EZUl6MG41cjFkZWw3TTk2QzBRdUMxUHEwVXhqcGVKWXcxK3JJdzZzUXJ3bGpUcndxalRyd21qTnF6V2hpMTUzV2huM25TR21IazgxcWg3NVZwblNBKy8yTmgxS3RQaFZGWFB4ZEc3bndoOVBOaldpOFdhMzJEV05TNUw4WGlIcjRTZUUrY3ZoYkdPdDRvRm5QNGpTQnk4RnRoak9jbVlkejdEMkl4Tmo4S0lqOS9FVVNPL3lvV3ovV2JJTzdsZDBIVWhqK0VzZTcrRkVhOS9Vc1F1YjlaNERua3k3WUtQSWR5Q256Znp5dkZQSGZ6YW1LZXUzbDFnYStydkliQWUraThwc0RuSTY4bDVuT2ExeFY0N3ViMUJMNHY1THRLYktwNWZUR3YrL2x1WXQ0NzVnMkVuZ2Y1N21KZVIvS0dRbitXdkxHWTUyamVST2kxT3Q5VCtJVEhwbUxYZXR4THpPdGt2cmRZL1B3K1FsOGIrYjVpdmdieS9ZUytOdkptd2tjOTdpLzA5Wk1mSUl4bmJ5NzBYaXR2TGVaMUxHOGo1clVpYnl2bVBYSGVUbkNjeHc1aVYzdnNLT1pudjd5TElQNjlxOERyWU41TjRIVXo3eTd3K3BQM0VIaHR6WHNLZmYza3ZZUit2c3A3QzcxUHpmc0l2VDduZmNXOHB1ZjlCYjdlOGdFQzMwdnlRVUx2QWZLamhHZDVIQ3owT3BBUEVmcTVMaDhxakhzYkpvenZIeTMwK3A0UEY4WjdIQ09NWnh3aGpEaFNHTzkzckpqWG4zeVVtUGRQK2VsaWtXOFRCRjZ2ODNNRWZ0Yk96eFY0N2M3UEUvajVLNThvOUQwaW55VDBzMG8rV2VqMU5MOUE2UFUwbnlMd3ZqeS9SdWo5ZGo1TExPNXp0bGpreUJ5eHlKRWJoTDZINWZPRS8vQjRxMWlzeDRVQ1A1UG5pd1F4YjR1RlhuZnlPd1R4ZkhjS1l2N3ZFc1JhdkZ2Z2ZXeCtuMWprNXYzQytOa25oWkdIVHdtOXI4MmZsZmg3OXZ4NVFYejlSVEUvcytRcmhUR3VxNFF4bHF2Rll2eGVGNHN4V3lQbWUycitobGlNNjV0aU1mWnZpWGx0ejljS0lsL1dDYjFQenQ4UmkvcndybGprK1h0aThmbnZpM21QbDM4bWpHZjlYTXo3cy94THNlVWV2eEtMNS81YUxPWjZvMWpVaDIvRVl1MS9LeFkxNFR1eHFCWGZpOFdjL0ZNc3hubVRXTXp6RDJLUkN6K0tSWTc4SkJaNTlMTlk1SEFtRm5tYnhHS041R0t4dGdxeFdLK2xXS3pwZjR0RkhmcEZ6SHV0L0Q5aVVmOStGWXNhL0p0WTFQdmZ4V0xlL3hEejNpUC9VeXoyaXIrRThmM053cXlxRmF4Q2Y4NkNRbi9Pd29TZUcwV0YwT2VqcUJUNlBCWFZoSDYrTGFvTFBRK0tHa0x2T1lxdGhKNlh4ZFpDMzcrS21rSmZSMFV0b2ErbFlodWhyNlZpVzZIWGlxSzIwTWUyMkU1NHFjYzZRcy9WWW51aDUycXhnOURYWnJHajhFaVBPd205aHk1MkZucXRMSFlSK3Y1VTFCWDZXYVdvSi9SOXBkaFY2TFdpcUMvMC9hbG9JUFE5ck5oZEdQZllVQmozM2tnWTk5dFlHR1BRUk9EN1lMR253UE8vYUNyd2RWN3NKZkR6VWJHM0lPWmlINEd2dDJKZmdhKzFZajlCakhremdaOUhpdjBGWGhlS0F3Uytwb3JtQXQvWGloWUNyNVZGUzRIdnk4VkJBcy81b3BYQSsrbWl0U0Rtb28zQXowRkZXNEdmYzRwMkFzL3pvcjNBMTNYUlFlQm5oNktqSUY3WFNSQ3ZPMWdRcnp0RUVLODdWQkN2Nnl5STEzVVJ4T3U2Q3VKMTNRUmVyNHJ1Z25pK0hvSjR2cDZDZUw1ZUFsOXJSVzlCekhNZlFjeHpYMEhNOCtHQ21Lc2pCREZYL1FReFYvMEZNVmNESlA1L3FXS2dJUEppa0NEeTRpaEI1TVZnUWVURkVFSGs0RkNCOXpERk1FSGsydEdDeUlYaGdzanhZd1NSNHlNRWtlTWpCWkhqbzRTeGhzWUlZdzBkTHhhNWZZSXcxdnFKWXJGMng0ckZtaDRuRm5sK2tsalVnUEZpY1orVEJIR1Brd1h4K1pjSWZKOHFMaGY0bmxSTUZmZytWTXdRK0I1VHpCVDRIbE5jSmZCOW9yaGE0UHRFTVZ2ZzlicTRUZUIxc0ZnZzBWb1hpNFdSQS9jSUl4Y2VGM3JQWHl3WHhudS9KSXcxc2xMb2ZYdXhTampmNDZ0QzM4dUxOY0pZMTJ1RjhYN3JoQ3M4dmkyTTkzNVhHTy8zaGREUE9jVjZvZTl6eFFhaDd6ZkZOMkpSYzM0U2l6ek14R0x0SkxGWUk3bFlySjFTTEhMNWQ3R1kyei9FWWo3L0ZJdDUva3ZNejFiRjMySmVCK0xYZk1HdTkwZ3hQMU9VMWNXODF5bHJpM25QVVc0bjV1Zk1zbzZZbnpQTEpnTGZhOHFtUXQ4UHlsWUNYd05sYTRHdmpiS053TmREMlZiZzY2RnNKL0MrczJ3dk9NTmpCNEgzb0dWSGdmY0paU2VCOTIzbHdRTFBpZklRZ2ZjTTVhR0NlSmJPQXU4ZnlzTUU5M3JzSXZBY0tyc0tQQWZLYmdMdjg4cnVBdTlqeXg0Q1AzZVVQUVhlMjVTOUJON2ZscjBGM3R1VWZRVGU4NVI5QlQ3MzVlRUM3MlBLSXdRK2YyVS9vZGV1Y29Bdzd2MUlZZHo3UUdHOGJwQXdYamRZZUxMSElVS2Y5M0tvTU1aaG1ORHpzaHd1OVB3b1IwajhHclljS2VhMXR6eFdMTjUvbEpqWGwzSzBtSjlaeXVQRWZPOHJ4NGo1R2l1UEYzZzlLVThRZUcwdFR4VEU4NDBWeFBPTkU4VHpuU1NJOXg4djhETlJlYkxBejAzbEtRTHZtY3RUQmQ0Ymw2Y0ovS3hkbmk2SXZEMURFSGw3cHNEUEMrVlpnaGlUc3lYK0FyK2NJSEc0TDg4UmVHOVhuaXV4Z01yekJONy9sUk1GM2lPV2t3VGVJNWFUaFY3bnkvT0Z2citVRndnajM2Y0lJeDh2RlBxK1VsNGtqRG01V0JqUGQ0a3dudTlTWWR6TFpVS3Z4ZVVXOUxOQk9WWG9kYXFjSnZTYVhGNGg5TDY4bkM2TSs1OGhqR2VjS1l4bnZGTE05N1h5S2pIZm04cXJ4WHh2S3E4Ujg1Nm12RmJNZTVweWxsaXN5K3ZFSWwrdUY0czVueTBXOHp4SExNYmpCakh2d2NxNVl0NkRsVGVLZWI5VXpoUHpQcXE4U2N6cmMzbXoySnYvRFpieVlFQUFlSnkwdlF1WUhFZDFLTnpWcitydW1lbnBtWjZabnRmdXptTm5abC9hbmQzWjNWbTlWaXZKbHVXWExOdXlMV1BBNndlMkFOdklrZ01HRzdQbUVZUUpvQVFuTVM5bklUeEV3azJjQkJJVFNEekdDZmgrbHo4UmVmM2t3ZzBpbDREdm4rUWlBa25NRHg3ZGM2cTZlM29ldTVJTlY1cXRycTZxcmpyMU9uWE9xVk9uQkVrUXpyWEkwNlFsYkJFV2hjc0ZnY3d0N2lUejFVbXlNRjh0RjB0cU1wWklOWW9ZMlBCak9yN2FYQ3FobHFyemkwNUNuU1NsS2dRdjdpSXBKOVYwaGttU2ZGYWhWRW5rRSsxV0lwOVBrQlh3c2hEdW5pN096T3labWZtb2FadzJ6SVExNmd3WGNxTldnaFNvTXFiUU9uN1NYa1czemdKV3VGdkFiL2JNUEdlWXBtRmJXVm1QRVdMcmN0WVNWQUgraVFKWkU2SkNHdXF6VTdoU2VBWFVLRkNMaGRoOFZka1U1bVluY0R1WlN5VVh6dk5PVG5NWXlUcTQ3YThPalk5dkd4OS9UMWovUXowY04wY1MyU0ZueEl5dlUrVUlWbmtEaDZ4QlRjK3dYQXFKL0VITVlkdjRmOVBEWWQyS3BtUXRTa2hNazFOUkI1TnI2Q3dOOEdIVmhYTmZJVDhtbnhmQ1FrSVFtb2xoTXJkTTVxZEp5U1JPYkc2WUpFeWk3VDMyaThmMk11ZjV1ZXRtWjY5cjdYVmY5eDc3Q1RrNmU5M3QxODFpTThxUTExTWlJVThMSWNHQmtYRVp0R05DcGRPa3Rnd0RJVldaSm1WbzFVVEtXU1pFTGMwUUU5cWtSckZaZDVIcXd2d3lnZUtTQ2Vxa0VqTTRrcURKMUNHU0dDRXBhT3JGcWloWVVlZUttY2hrWm15cC9YdnNnUUhrV0tnVW1oaSsvSnJMaHlkQ0pTZGN6Kys0ODAxMzdzalh3NTlvVXFXdVVPV2dyRXREa2toV0U1WEk1QzRya1Y0S3c5OFllMnZ2RDRjbnN2bDhkaUxzbEVMMXVXMDc3OXl4NDg2ZDIrYnFvZElueHQ2SWJmU1lLbTJUaUZ5VERhK08zeUF0OGdrWUx5UENqTEFMNnBqczdsNmx5SWM2emdTQVAyWDN2RmZLL0xuZG5UWmtWYWRucU02YzloTmtIYjN0VlhRRGZuS0psMFFuajQ2aEY1Mm4rQU9kYzBMSC8yekgyNEg1NlNETXNZWDVSUmpiS1lCREJiaXF6bmxnYnZhOEIyR3pOZ0M1Qy95N2ZKamZOUmptdFVFdzk3VXp3b3J0akxBclNRL0xjTGo2MnRsOWVtbElRYWZuQkFZWXVPMHpHOVdCQkZJRkcvdWR2cS85OUl0cGE3dW5yZW1MYk90MUZ4UUcxc2tOR3ZoVG5TUXZ1ckcxY3krY2V3cGdmbHJZQTlqOEVPQy9PNFRYQ2ZjTEQwT2JNeEM4NFYwOTMxdHRHaWIxQ0JrbU9MWmgwbUs0aEdnVDBXZk44emdiaC9pZXB1Y2g2eEZia1N4SnNiTjl6N1JlekNuR20ya3k5R1VySitVVSt3V29sQW4xNG8rdGc5NHlYUTl5MEk3c2x4UkZlaXhpMjVISDBQY2srcDcwdzM1UWpDaDIwZnlNWVNTdGV4T3BKeUoyK3pSK2FlcXIvTEhXOVZiZ2o1V3VPR2hqQmRkTThXRllNMnRDbmJYeHJZSlFLUy9NejVEdWRYTTc5RGlzT1EzdThwR2crSzJDemUyam03S0hjeFk0NGhsQ0xKdTAvY1RsaFlZakhyWE0yODNFbExlZVdrc0hsOWJncjQ3RGVCeEN4dkw1QnhWcFNaSHFrcktFdGZhOVQvRFlIU2VuYmwrOUt3RzU4TlVWc2hsYldockRQNTBXcUg0VUU0M2xuKy85bkhuYlgrZXhwNC9lRG5QalhQdmNsOFcza2o4VzVvV0xoVGNKNzRieE5VM29IQ3lqYW5rdVJVMVNodVdnQ2kyeXVFdGNKczNGWWFKU2xTNzZuaFFzdGlhaGJCMFpSdHFpQ1F0THFWcEpxVkVSd3RWcEFtbWJxdStwd25oY0p2QVJqS1phZFJHUzRnZE9FektpSlJYTG04TXNJYU5wUXNwV0tUb3lHYUtXYVZvME5KbDk1VjVxU2xPU3JHNGJWOFpMV3NvVXRVU2tOQmFLUzJiSVNTWm1rZ1kxa2hVNWJrU1RKR2thY1ZrT2ExcVlITy83UWs4RXY5QzdpOG0vSEl2NXZQZTU3T1pISkNvcXVYUWtrNGs0ZWIwb0srcU5OQ0lYTDV1OElrL0ZXSXJHYkVjUnpWUk1GQ09LYWdBbXBMdU5VSEk0RWRLcHBrLzFKNDA0Z2FTS1Jycnp2b1I5Um5YTUFja2g2S2VXdUFmd0FXSURvZG5BUnByREZvV1dndDRwUllrSzR4UzdKRURXTGNNd25DWnNmVS82SzF3UzJyMFcrSXA0ZEZTa0VLcU9Icm5yeUdnMVZOQlU1U0xKa0M1U1ZLMXNUdGJxODdqc3p1ZEhtd2UzanViNVM3MDJhWlk3NlVnT3BtYld0bGRucStVcS9HYWpFQU1SMFZyV1VmK1UwWHlLTVRkU1d4SzNqbzNNR1FvTCtWUFZ5ZGE4aEtTQTMyZHRSdjZkTzNmdWViS2JuQUFLYUJ6cVcwT0NaSEZ1QkVZZ09La0VBRjZDUVRQUEsxRmpOVUd5Wk81OUp5aDFhSUt1cm9MalVIcUNKbkk4U0wybEU5U0NQNXFpbUFvZUNRajZmRjhJMG1Fd0cwNlJXemdNdkh3czJ1SGxROW56UUJuTlFRVEE0UU9qSnM1Y1FPNWY2d2NxMXc5Nkx3eE55b3ZkUmZ3R1NTV2FmdlVwYndNRTZFSmcrTjBMYXF1K3Z2Q3I3d096T0ZmemkvWWJwRnI2dlF1cTR3WDFCVGwzRHRwaGhZd3hpbmpRYUJqUThhc0Q4c0gyRko1ajdUbTRSd3NYMGxYZCtRenNsZjRPR05EY2JyMTI4M3JaZzFwMlFDT1NmaGdSR3VRQnp3Q3QvMUdYemtHT3lhZk1rQ3lRWXQyOFlLM2NvWkF4bmp6WHJpTTdSb0NQTStPbTBUN0szazRhNW1kOFBvZXNtQVpMQkU3N1NXS2h0MzBXM0w5eStSZHdCTTdEUEV1ZUowOENEMU9DVlJWWWx0STA0ZnhFQlhHUk8wNzVRb3RzQlhtK3c5SzB2M21KcHFySEFiRWNWMVh0RXFxc0tEVEE0TXplRjFXT1M5SnhKWG9mbE5oYmx1SVhCSVhhc0p4WFhkelE0WDJKc0ZGbVN4MGd5Q2dDY1V3T0F0RmJsbHNLTDFGcUFLSjF4ejdnV2hmaDlwU2xIcE9rWXlvcml6eTVlWTJGL25acytoV0RJcFdGTHR5ZjVPeUx0bmtOV2h0QkkrQ1lQdmN0OG1teURweWlZRGRjNHNXZkdKeW9lV0xWTUk4WUpuMENodDBUMURTT21HVGROSjQxOFEwRHpXY04wNFg3REZtRHZLSkNCZnFrWnlUV0JvSk9qclNmWUNQdUlMakhEa2NNL1RIVlVoL1RqY2hoMDRDd2dtbWtNUjZjKzA5a0lCTGlNaWNnUkhEeFpJdkpES0M4aFpqTDFzYzRZZFljMkRVYlpaZG1BQmdNbUFGZ3VQMEM1VDN0bFVmY2NyeHk2ZUJoMTlxb3hQUFZ2TGM5N1FEdmd1M3FESnhTNTZrSGR0eEc3UWw0NmR4L1FudWV3TEZRU2JvMHJvK1UrTkRBK25UMy9ObSswU0h3Y2ZVOHROVzdNQytmT3ZZUk42ZWFlM002Mlo4VGI0T1cxd2JZNWxoL2JIUE9ldzVFS3kyZ2o5ZVpUR1kxa1cvL3FIK2FrYU9kK1B6QmJ0VFNXNllTS0EvSGxqUzRuMDl1bUdQQkRXVXdrZkFBRE5OWHB1Mlc1ZFhWSGppVzY1MXNzY2dnbWxrL1h3djBseG1zSTVaYkdUaGZ6MWNYYTBPWXpvY2ZwTUY5R1p3bC83WXBmaUNudWdmMGVmQkRaV0EvYnBoZGNHSU5nT1A4K0VFWnZGUUU4RVA3OE1ZSVluQ1I1OE1SOXNBK1BFOVZnamlpQnlRMnI4L0FldkZSbk5kSzJaM0lQZ0hFVVFheCtpWnlZWVAxd2x2bkpucm9oV2hIOGhnZzlEMGlNMGczbk54dkdrQ1I3S2RKR3FMMEhWRGlPeWo0a29GRnIzckZIMkYxL3VnS2pFalF0MVA0SmNEYkQwTVhIVEhURVpzSENIMFBqdUFhdjFFQlMrY0hzeCtHTHZwaWhQZzhITzF1QTRUbFFtQUlVaHdiQTlFRFF4Zk5zY3NiTnp1RGhMN1hGdHJQcXl0Y1d1UUxNSmFIWURRRXlITW9NalZDL09uYlhDYmtJMEFKZndtKy9CSW5obytiUnNFd2o5UEVQem84OEV1TWNDYjBmakxDaHZxMzc2Y2tPRjgrRGZObFN6OE9JczNOcXRvMUlkdlA3V0V6WkErVUZHTWtPbjJuUnVQVURtSWtiZmZYMFB1MTNab1dvellrd25ScVRPdkNGVnY2Y1pQdGJOYnRuUUxPN1g0V2ZjOTI4bituWmdNNHdSbE8waDFBTFkwQkN1bGltc2R6KzNCTTkrTXNxYmJaRktoMUlhODlISlE5VkxNMHQ2b0lDdDJvMWRTNDIyb0FES1RrZmZQL3VyaHN1aCtYRWJvWlNqaGZsZDFTdW5EYmovZnczZ21DakoycGNWcm9uMkR0K0JBYml3SFdETXBVbzhRSHpSa21STnhrekVrYmpGTnZ2UDhUdEQwcnd3Nnd0VXp5MW1Ia2F0UGtxVlNuaUpRR1JiUy96WnAwQklvZ2I5NmtqT0FhdjZXZmZqb1BtdTJpbys3ZllIWjMwVktmMm1SKzk4RFNTMWVkQjkyZXZJQlN1aWl0amVEdGhhT1gxdG9jNVFacHJvM0E2S2ErTGhTT1h2cHJjN1I3SVRXMUxnRFdIaHBpQUU2VU5wMTNYYlA3aWcybVhSQWxaamFZZE4zODNQUUFlbTF6WEhTK0lnRGRhRUVjY2NXR2lLZ0hOL2ZSY1p2aTVpNlUrTndHNlA4OGplYWk1NTUrNmFQdE5sMnJCbGUxZTZYcVFvWWJ3U3E0Tk44WGdPWWJDc3JoR0s2cXpuU2FCd1g1RzZDaTM5Z0VmM0Y1bUVqSWpEQ0N1NHRJbHZ2VlFNSWNxdWxYVHlWditoSFFrZGRUK0NYTWdKZWtwcWVCNGdRdi9KbEc4TVhEdFU4SjN5ZFBZeG00SXpQWGFTNGtqS0ZML2E2cy90MkdXZTBiWERoZkw1NFNZZFFJZXp2ckJUSzk1UUFMUFV5QWhWNG9NNUtxUXk4M0FvenhOQUY2T3RrQTBvdXNYZ1ZGWGdYbE4xNWwydHBWbEY2bDJlYXJHcUVJMFRhTVNma3ZBREpMcFpGSXFEdFpiNHpBNVpyUS9ydUZTV2liSXNXdHc2NEJCY1JYRVlpdW5pbFhyYjJHVEUxVG9obVEzVzI2ZmhzOERPamI2ZmJmREFoZG4yTG9odDVxWkkxYk9RNmE2Zy9pN1VnSWFURllZckM4OWd4c1dCaGpzQ0Qyb0NIMUF2T2ZlQkVROHpIRDlDaHU2cVVCRnNyZDVLbmJmNDBGMmh1RTc4bEdyVGNJMzh0SmQ4MG50MXdHSUY3R2NEWjFIc3B5V0MvVDljdDRCYklQT1J5MVgxZ3kreVYvT1NpWklLalFKeTFvaDJlRXVMc3pmVVM0QzNWVVZKajF1TWVaWkh0Sk1EbWJKUk1YcmJuRmpoWUo3Z2NtWndGcndRUkxOZVp3ZDZxSlcxaUx1RXRGTVJCbVl0WDNWT1lYcHNWYUZhWXpkTDNEOGxKcTFQbTZsYlptOXN5QWF5Yk1kUDFxOUJXYWU1cUZFQjJsb2VGVTJMTENRM05EVkE0N2Vtem02alcrTGZVZS9pQi9UV2F1V1F3bHFSRmF1WnJBbCswUEhDd2QvQ0orVTV5WktjSXpaWnFmbkxtNnprS2FoVUt6bUxGRDVWQThreHFHMUpDdlppaGhKelkwQmdYL0M5K3ZXdU9QTDRyUzBwMVh4R1VqbFpSVHI3dEloaHcrQlhsemZOTWkvd3BqWndIR1RvM05IaHkxelVXMmxJN0FVcXJ5bVVYNVR2MHVhQ2VHeldjQW16TkZHL0lQNzMydnJpaTJrdERlTFJFelZBMlpSSHEzbG9BUVJkODQ2dGlCQTRxdGwzUkZQZlN4a0dtR1BuWklWZURWVmpZSTkzU1BuaWVmRnk0UnJrTmRBNU1rY0RmV0JacXFaWmNyVGpuUTFWU2wxVnFWeTJoSzBMWFZNdTkwM0FhR0JJM1pPZXhibUtJU2pvN21Jb3FUb1k0dXE3cjNzcDI2VEEwMXJtMVpuRHMwTjNmb1ZZZlNtV2dzRzVaRUtTMmE0UzJLRnArb3JGVG1weElURVRVVkhybGlyRlFxM0h1VGxiQmpUaXl1NnptWG54MVRrM3FZU3NyUTNLSGJEODFWeTVXNWtYUldJcG9hZldNNFJwVlU3ZUtwMmEycG1FUGxMYlZkZStkbmw5cW5rM1loWmFmRzR0RTQwd053OWMxazRIanpRZ05HdHRCMHlydEVSTDh3RUp1OWtzWWExcGVMVVZDbm91RXdUOVBYajJLdnY2bG5kZm0zVE5OSlp6N3FhY0NoZGxuNzM3ZUsrcWdtYlJXcE9pUURycG5YSkgxSXBYKzBNTDBWTjFDMlRpOThiWGpZc203TjFETTNkOVRKOGo4NnBXbW5WRU9SaDRkMTQvb3REYXFjVXVpOFM3T2RBL2dmRmt5QUh2Zm5ZR2JGNWpsaWRJcGRyK0dXbm9uSE0zb3JIQUxFNnZrL3RhNko4UWhaaWNSRmJkMFlOcnBmUFhxOXhmQmZUZGdCb3pobGlqV21LNlpPaTAwWUVZdk42ckxvc0hHeE9DelNZYUJObEVIYnMrUXJJWDFzTWFOdldkcWlaeGJIOUZDbVVNajBCN1YvOHFTaXBKU0k4bXY3d0VrcHloSFp2R2VUOUoyZ2hTZjVCL0FoeStDSTR1SnVvQ2FGTVlCOHZscGJuQmJwTlBRVXJacWlBd004NWFqRFlwUHRwNmVXeGRveUVZWE5DL0dDV3ZsTmErRUZvYTRKdzV0cjBINHp3ajdoVW1GVnVFMFFpbzF1S200N2lVMlR6cVljYTAwM3lTUXFXU2gxSUlkd0dnSzZNSUYrNElxQkN6V25URGVNSWF1bkdPM0h0dkpPeGRQeW05QnpJbFNxbGtJb3hUUGVKS2ZqcEdBTVRldWxrcjVsMkNodDM3ZTl0TGIvNUpQOVFZeXpZQTZwMFJHYithS3hXSlI1N0JINlIwUlBiWDFGTEJ5T3ZXeUhvNUhVYUFwKzZ5ZXR3Y0ZzdjlLVE15V0ZZUi9iY0dWSEJ4Vk1vQTFTRW1xT1FLMjZkdTEyRmJLUmRQdGMrZnBydjRNK1FzQVhsRzY5dm5EdDlXVkMwcEZzKzV2b2JaOERML1FEWno0ZkpxdUNMdGlDSXhTRWNXRk8yQzRJTVVaQXgyQnBxcFJqbmh5L0dDczZ2cGFwNTZuMWhWU3pxNnZacXJpQ2JyVjlCeEhPQ1VocUo2Q3QrT1A2cmpkU2FHV3JaQVdTdHFwWjhMWmJaT1V3UmlUTTFVRVBCRmxsODI4TnhyQ253M2FWY0hPL1RpenBaaytTOXMvNExoNThnU0VnRVJGUWV3ZlRJMkxPQ3RQM1lrN0F1OVpKRVBBeTBVRUgvUjNCWU1JaTI2ZGZuRjhRZEVaYlA4emFZVlNZaDVsMG8vQnE0U0hoL2NKdkFsZlVvOFhKZG1lQ0tCa0RleFBSUnBkUzlHQjkwTjVNT3ZISllIR2xqaXpmejc0SGhDZTlWbEVtRHpKZExaMnVnWE9MMTRUS1AwUFlRUytZdk05UGZwdWZnaXhnRlBVK0Q2Wi9RNkRWb1YvT29oK2Nkc3RQZ2NtRFVZVk9SaEJkNkVSMG5MV3VNdHJyWFYray9hUkN5TzJicDluY0dvS1ZZaFptMXNVd1VtOEViSGNjUnF2WEZJMmE3NU84cGlwM1lwc0QwdGwrT3NYM09iNlArcjUrRFZNK1htRThIcFNVMVZYK0lPczhkSlUvV3F4aEMzek1yclRQK0tINDRPTzdRTkl2bk1TcWlrZXhDN2d5SWxOT2ZLeDlpajNJNFVCWVY4eGpmVzVnZGdpQzVkTWZFdUNuRUl4c3hFdzVtT2RsYU1OSm1PME5vUWt0dVVzUVptT05uK2svRUUxeGZWVFB4WE02L3N2R2MzSDhwOGR6R0JBbmErMjFuK1dQNjZEOGxMVEkyejBkbEY1TjJsNnQ1dDczQzlKYzN0SFJsVjBmNkJVa0dJdlBrck93dG93QmZ0OEo2MzRUZGR4aDhWZHBiYkhKVnYrVUE5UXJXLzRYbTQ1SzJmcGZuUkVYYTlWYWt4MGpVS2tLU1lCQklmZm1ZN25zVUQ2YnQ0YnNRdW5HVzI4c0Zld2hLNDlhNnZuWVVJSUhGZTN2REFOVlpZeUE4OVZoZzVEUWNBU2NRMllwVjd6cStxdUt1YUpaSFNsV0tzWGhhclRJZy9KRnM4YUNSbW9GbzFRdWpSaWoxZkhqUnFFNFd0SnI0OVV5MDgvOFUvRnR3Ry9Gb0NiVE1BNEV3bGxlb0wwQmJxQStsd21wd2JKZmhZQlp6ajhnUzFVREIrSnJxdUt4VStMcjA1RXQ4Yi9aTXBiT0w5ZUdacWYvSms3YjBhbDhWZ3lacXFxSmFsMU5hSW9rRzFKR25VN21sNEFUNWVjNnlJbWlUU01mS2RiU2hSdGlWcTc0WVhOTCt3TTcwcllZSlVTR2IzWlFTVlZvT0N6R1YxZkM1cFhKS0QvWUlRZ2FXOSt4RDJRWTFSYU02UkhBMlpOQ0hVWUZBdTgwc2ZscERkVkpvVy9nTFNvQ293YytCelZHYXloQ2NuZ2wvdWJpaFFNVDFjZDNYVXVHOHI4eVpWelovRkxwK3JvOC8zanA4WkhMeDhod0xoaTI3K0tGS3lmSkh4cFRWeTYrOC9GNXVYNTk2Y0RDeGVMa1czTEQ1TnBkOEVVMkw3cGhFdy9saHlIb1A0eXBBOUN1QUNQWEIzNFNSdkdZTU1YbTNhS3dGVWJQaXJCWHVBRjFZcEtBZmFDdG0yVmF3LzlsQi9waWdmT3d5TjA0TUd5Y1pDcXBPTTJhMHl5UGtDWndjRTBLZnVCYmdhdHJsaDJHMnhhS25qb21XN2hQbnpsRG5yQ3RJL3BJL1BJOWV5NlBqK2hITEp2SW9jVElSSFBmOWErN1pudk4xa243cXVtcGlkM2oxNnhNVGRkYllvVU15NDlQVGs0ZWw0ZXJ0Y3B0aXJTL2ZZWXBUWk1uQVBVWDZnL0g4blR5NUpuOThPL015VW1hajcwMWxLeU1UR1pHR3FQYmg5S2lYTDlwYW1yQ0hsOEJOMVVvdkMyL2tKMmNIRE1YOG04cndQSjg4S0M3cEx2eVBxWlRkZ0RtVUJIVjV1Y2NGUWptN2cyWGFWY0RPTEQ4TWFWVER5MFhmZDh5NmFoSlBOYytZa2ZpZWtTMkpDa3NHZkxON0NGRnlsYW9uQ2pPYUVoc2FpNTVTUVNYM01UUTFzbUlIYlZuWXBBNExFazN5K3dSMW1RSUszSXF0WkNzbUFYMlBjdWxZRmFTQlJiaDY4azlUTmFGQ0l6SHZhaE5TMzJpbTVhVnNzdVljd1lQV0hFbTRXcHlZZ0xJQmFlUmhJR1FMSGRSRGl0L1lINE9TWno3dEplVHUxK1JsOEw2M1RSRXNpU3MzVndSd3duMWw5VFFFMW8rOFNHamxMYjNGd3EvTVBycFJCNUJXMTNKSjRERVdpbjhJa0NuL1owZS9TUTgveU9VTEZpSmZOMWFnWC81aEdVYUp3MVhoNEhScmxRb29uUVVvU2d1ZEs5NEhlVmZtUEVGNEtRSzVHeGJZRFNjd0VzMHREd3BRTDR0WHJLWFBaVEgyeVpRUnVWQ1NxSEZaSEhEa2k1cXcxcTdRWEdyYXkrcFBBVzQ4ZzNMYS84VTV0TEd4ZjM4eS92dzJ0cDV5bk5wb2doZ2srMjRsKzB6ZTA0NTZXdFdUUklIOXhMVmNxbkdOdnhnbW8zd25jVUcweVlyT28yRkJobWRhZjhQTEdOeDVqcHhCWXRQWERPcVNscVl3cS85dTU1dmhleGk4SzBVemdudnU3ZmdqYkRXS1E1WFhVdW91bUtRTC9QbjlRanlITUQvYysvN2p5TmpjOTYrMzAwZUZ1SkE3VUI1RmF4dkdaRmp6Rk5LYlhxcmwrSlJna1Z4ekRCWDIydXJUQVYxMVYyamJsNGFBejZYRk5hQnQxMVpJVWZZOW5PTHIwUnJZMHVtY1lTZkF6cERuZ1pjbGhGS2dOMTNRQTNMZmNjam00aWhvR2FKS0I2UVRDVXA3eTZYVXcrK2tLTjFWL2ZWUUQzWXE1UFptWmplckZQOUNYNlE1VTczUE12cVdJY0RueGcxYXVtSGl6TmZNK1RNa3pvOTNUbG0xbkdZTGkranBYZkR1SWtCSmIwUGNKVGFPWWRTd2NWZmRWRE9sbUl3TFNnVVdIS0Nld21vSm9KcnFTdU1wY05pTXNHV3BSUUZqdnFBbVVzZXJTeFdpdTF6UktOaCt0dW1nWGcrNXBBOUtBVis0U2RVWk9MZ1kvRzVJZFhPMm1wMVp4blRXWEZsS3hXdmlkYnl1VW9sOXorM2pHVGp4aTJHcWFpS0U1c0t3MGZrejRBU1FNL3RxU0ZGTS9DVWpxR3BXeTZxelpYeWRqZ2FUOCtwQ1Urdm41OVRuWUMxVmFqZ1dZUXFpbjlyaTdqVm93S3dwc2dFaXlicFZCZ0dBUFdxMmtpa3lPOWJBSk5XM2xrTndqak1xM1kwbVR2RDYyU1oxMFREZHI0MFY3dG9pOW9IMHpDdlM3NTJFNnNGNEZlVTBaeUQ4Zjh3Vy9PdkVLNFI3a0NaQkswRkdEakhZeW5abGgrVGR5YjRzWmNHNnI2ajlCTUZHT0kwVVZKT21hSjBBQllNSnM0MWdXd0F5ckxoVEl0TnRwZUJJbFVtRWxWRmtra2RvSkVWSEFDTjZER2QzaENDc1RJN25IQksyOHZ3bTdvNE5CK2gxMGZ0VkhuYlJkdkxZbmw3KzdHb1BGbEdrYld1YmRGTTgycDk3TjJqNm1oNjdYMGpVMkppaXhSUkk2b2tiVEdNNHN3Y0ViUTNoM1JxQWJNR2YyYkNyR3VsN1Jkdkx5OU9oTjZkanMvbW9JRGl0bjA3eXBkWnFWV1lMdUtsNFV3cXUxb3ZqSDFkbkZwT1h3TDU2SkRmZm5GbWJ4M2xKeTQ5d0htOEdkWldWeUh2N1o1NFNqWjhuczFuZzhzMjlpeGx3NWJ0Y1RVV092eWNCQ0YyWTc3bURnWDRPQW01dFBqOFBzTm5lUnZlN2pmTVU0Y05VMWZNT0EyZE1vM0hlTkRhd2ZxcEVJMmJpZzZUSEZEQVlhYWR6alRVMit0TVhFVmcraGZ5OFpGcWVud2VVcXkzbjNTRDE5ZmJaK2JIMDlXUmVCNW9CVUFkcnB3TytKY1djRnQzQ3c4Szd4WStDS08weElFcjhScHM5c1piWVFFb0JPOFBjVVZ4WVk2VGlKeENURzMyMWlCTVZvNW5yUlp3YkRRMmZTVXRUWk8xRUkyTVJHaElVNmlseWJxaGhRdGhHdEpsR3FNS3hJVUxHQ2Ryc0Z3d2dtSUY4Rzk3eFFxekQ0SkoyT2VZV2NHTFk1bFo3ZldJTFFORnFCcXArTEdCM2hWWlVuVlpWV1ZkbFdSWnBOeFBSVGtZZmpDUlA4bis1Uk9uVjkya1huUlBVcDRGV1lFWnF5b1JWWTlXcXNtTi9BeXYvd2xCbVpBTzJES0wzSjZDbTlIQVZhVFVHcUs5WlZLVGNCSEJhZXZVcXVYWmNpbktONmNBM3llcE9reGd5VjJvVlJlUmV3Sis2a0ZKRmQrc0tRK0o0dG5pcUpKSmg1Ujc0dG5zYURiN1grNm4yTFk3WVJKWmkwbzRrNWIzakVpcWRBZTFMWEdYS0VwL0lkSFRrdnJNeXc2SFEwWW1UQjdFYjBhem4zNU0xNis2R2FmMHdjUXYvV29rcllmRG43dXJCaFYrV0FQU2tORUkzeUp2aERrMUN2TnBHNHczM0Jsam82cURlR0lkdVZLVFJ3TmVHWFpKQjNXU3IxVXdIbVl6K2RGQ1BCSEwvREVpazJJUjNUOGJ5OVhtcW45MmtXT0dJL25NbGZlR0UxZGZOMVN5djJvMlJrYVh3bFFTSVNGbEoyZ0xWTmRDZTZkcVN4K2thamFXSFdrcEQ1ZUdrbmpRQWZqUXA4aEZzQjQ1dUdyMlVzaU51YWE5V0NWangwdVNHVDZodzBKTXpOQWJwdUVGRlQvaDlhMGhPNnlmRFZsZkNzZkRwQjVPQzF3V0Mvd1c3cE5uaFNwUVI3dUV5NEhMdWhQeXAyeEhGZXJqcVQ1Q1hkbis2QzVTNXFnWGU3UEdXNFNUSTNnWXpOM0NuNnVsM0IxOTVGS3E3bTcrNG54TlFXUU15ZmlSOTdsRjh2bjVMS1d4K05MTngyNWVXcnA1NjVieEdLeDkyZmtyMDdnUGc4NXUrRE1vSFlwSjFKQmlzcWF2eUFhVmdlK2cwblcrci8yT2FwYkpIWlpndVNkSDVuT29XekcrWldsMWlXVWNqMUhJTTRUNUdIUUh6eGVkWmt6V05aazVrTEdNdWNzTjMvZkpiQlZ5VzBLQmhuZUd1Y1hPQXp0Q1RXZ0t1MkdVeEhwSkY4Q2g4ODNGU3VkQUQ1UGxKbnZla1FERmZTeXVuOUorRWsrTmt2MkFXQUhQdDF1eStEY3dGYnVkRjlyL0V4ZFBNa1FPb3liSjBsaTdoU1NWRmRKQ1VLLy9qYWtTNkV6NXZ1L0N1aHlwQ3Q3ZUo4cXRBYmttZmEybUd0L1RhcTJRMDB3cnFYN1VyU09YRi9EOWdCcXNLc0VkQWVxZm91V1BVdFUvbXZ4OFoyZmdHYjdSMitDYnNuVjMyemV3TmZBa2oxbmxNVy9ybkRtVXovMEVZUDF6Z0RVRzlHOERPVVBDWm1HVDczY3lETzlnU0puaCtwVFRXQ1lWaHJ0clRLQ2tJdjRlSVlGWS9KcHNKN29pU29TTTFFY0lrVVJGSjAwMWFTdlhLSFpTMVN6N3JZbG8rK20rSkFmOGFOdlNJRGtweFBLV1prYVFab21ZZWpRZlc4OU0xRktwMmtTbWVsKzFldCtYZzlHYWxZOFZNS3AydkZvOVhvT0Vnbi9lR2Z1Q0FzVTlCQlRZTGk0emo0cU5KdFFBRmw2Y2FYUytXV2JIK0tkSnMydERwa3Vmd1ZWWE9Qc2VLNlBNaWQvL1owdkpXTzhwM2RTSXZKRDREblF1MlRKL2R2N3cvUHpoSStnc3Z3MUlpQ3NrS1F1UHlWdkF5VXFrRlk4K1J1K1pqY1kvTWpwK2RtNzZiQ0pmdXYzL2Q5T0Q4K2hiSmVsS2xoSy9rTEt5enZBa3h4ZFVpQUlOenlSaHFEUlQ0WFdndnZFQjBtNGdPTjl2LzhBRjd5emZleUQwc1dpOHhVb3VuTVdCZDdaRGE2OUF1K0Q1eG1VOEE1NnMwWVVlUVg3RjUzc0NrYzZnbEdMOVlLRncwS1BvMjI5a2RMMGJkRWt3YW4wMW1WelZhUXZmd1ZsaHJoKzIwaDNyN3NFeTJ2bHE0UmNRQzdQbHpHVk1wbEdaQXJoSDNqKzRJWjJFY1FsY0k2Zkdrb0FEL2ExRXY1MThxUWVNWUVnb1VWUjA5NDU3WSt0eWZxS0pLdGZJbnFLRzY5cElZc2lKUzdJaUQ0K0w3NWdwUzJKWVZLVnM2ZjJ4VEhUSVdCb0QxR0JaWTBpQmp3SEtFQ0kyOTIrdmt1cXZHcEN5WG9mRjFSQ0pORFltRWJFdmhCUnkxYnpFNUUveWxoRk5HeEVwRkNDbVlQakpwSUM0YXZYbVcvaStFK0lrTHB6Zlh0MGhaYXZ0NzRZaHg5RlJ5Q2tzVVhGNFdLUlNYd2owZDVqcG1LRXVuY2JvaGJJd0pTeEF2MThpSEJSdUZHNFZYdXZxc3lCcThaVlJKTS9qOU9tcC9JeFJhOEMwd0crRjR5T2N3ZkQrRHZldEsvRFBCd1gycE9TUEZvLzdFRWR1WkpVWDBlS3Y2eThoZE1WRms5NGNYSWY1TjRTckVPbnNzWlc3OXlJcmpXVFp1UURqQ09UMHdYd0NKdWZCanZtZGI2NnRyUTgyZ0VCV21NV0RldERRVHFIdzlZR0dEanBuWWhGZW0rMmxDQUNWdCtIZWNJV1NDODFrY2FFWHJGbzUyU0FyN3M1bGk1MTliYldGZk1LSHRRVXdua1FRVGpJclNHOC9DR0V1YkRzS2dYSTdaM0c3clJmMTJCL3FmZSsyUi9SaGRscWVPV1NGS3Mrakg1eHU1ZUw3M0JSQngrTzVVWGV0SmF3SWwrTFpHdFluU0dNaFFsYzdIVmp5TGYvd2t6ellKTFVxMDBoc05CZlpVVkRrWnlSVThtbkFpaUFLaVVqVDNLbmJXV054ck1HSW1zYllvcEcxOVoxbU01S3dJMHN6TE82N0xHeG1LV0tmRzU0ZlBqTTgveHVSdUZVWTJvR2h6Y0tQRU00ZkZacVlkTWRRd1lybjdPM1RMSW9GVFcrM2lRMmZ3VS9nZXdxY0RySmgzdUlhamJhaDdoYmVqQ2VRZklLSUlXVG8weW81SHkzVWN3TGE4Ym5ZRjIwLzZyTUpybUVMbzRHMGFQc3JmVjBCenJ6L2RzbEt3QmJXaGs2QnNITVU3U1Z1YTRzODZrY3UrYjY3T3NuWEQ2SG44SUJFUzhFQmdldkluN0wxYnB0d0VkZUlRU2tZWjJBN0hJZUt0QXlxM2pVNUhRTnJSSldwZFdFNEYrV2o5bGR0QVNrZ2NTVnVWbkw2WkhaaXNyR05qY2pKa0NwSEZZbGEyKzJ3WWtTaGJFa094OUx6TTdVeFoxelBWY3o0NnR5VzViMTdsN2ZNbllsbWxPTzVpbGFKRDF0MlBnRkRHVWlYR1ZPWERVbFRNbm8wWXNWVU5UNnRTYlkxRkN0cmxkeHhKZlBtQ2FlZzdkTUt6Z1NqRzlGZUZ0S05YTExYZlc2cWk0cWhudEpHVnlnUm1CR3QyOUdaNjlDU2U3UFY2bnkxbWkxdkx6RWRtTkoyY3IrYkNweVZBRTJKeWVhcksyNHFjRHlkS1lJNlAwd3Z5MGJoaDZ1WUE1UzZxeExYWklwMGF1djYrY1haRzQ3ZU1MdTRjTjNFb3VsczMrNllpNlIxNWRXSHRpMnZMaTZ1TG04N2RIWDdQUXNUaWZ6c3lzcHNQakd4NFBJRWJGNDMyY3krMGJON2xlekd1dDM0TjRDRW1WNG13M2IrSm1IUjh6UVhPbnV5aUxORXdUUTA5cXNiWm91NUd2dEJHTFB1QmQ3MjBaampsQnlIUlBrekNrUDNOQk9QUW1veUJxekRLY05rd3RBeDdwckdLWGJLc001MWd1cm03K05uM20vcEpDWTZ5YzRqTTE2UnlXV0MraSt2Qy9JVUhLMlRIcmlWSHYyTDN2ZEt6M3V6NXozWjg5NTE1bldOS3UydjQ2d2lNTGZPQ1FFa0hmQUh3OWNHelhLTDRYaXVJa1BxdnFXRkIveEVENXhDMzZtdUQ5L1JpZlY5WGZpUlk4ZHJtZWJGMjRUM2Q2eEJCTmU1NElxSCtFL3BPZi9pOUt1K0JOOFhmdFo0OHRrMm9DdlBNdUNhWnpDUXRxOGxwekFjVzVtK2NWQ2pEV3pKZ1lGb2gzQTA0UnF0Y2UzWUpFWUJ1VUxuL1pTdG5iSkN2K3AvMFdubXd4Y1k1dEVaZkh4aXUrOS9hYTJ0MUhxMEpkbGhwd3RwSW5KTlhqTGsxMHlEazVmbGF3Qnh2aysrb0hxdjVtWHBOVE9TbElkUERrblNlOUdpbnR3MWhuYkJDdnZTeGc1S2gzYUplT1RZdFZBRFZicmdHdjN0elFvcVBONHN5OVB5YXpKcVRBVkdjRWFXc3VvRlZldWVtK3ZROFFyN09wZFI0V01aS3BsVlk5MnlGS3pmRHVFS2JudHZzN3BoblpRZUxXQ2ZrcTg1SGgzSnBXTDlOVk93d3Q0Sk9zQVdVTTB6SEVVdXVZT0lhTXFpb3BHcFFUV2pqVTdGNk5NY043NzdxS0txeWxGRjA3eXgxNW56TDIzc2RjL094b1VOdXdXRThrbUdBUytrVzFxZFdTbjB3bjNEUzRSN3ZtTWZvRnY3Z0NPY3hvVmlHYktiS2p0WTFBNEUwZmRlVU1WK3FmY3I1djI1MWJGZms3clgzRkx0d3VxbzFtVVpNVVc5RHZNZE1FVzk1LzJDS3J1K3djZmV1Njh2RHZqd2FWaXZHLzNuS3ZtcTIrbTIzZzdFbFRzY0JQenpBeVlWeHVOQzI0RnM4UFR4NXZ3WmwyK3R1cllyQS9Cc1J5SVgrNEJKU1NpM3RjcHB0Wm92Q3VpUkhvdUNwOVo2T0t5bW93OUYwMnI0Y0NKL2dwMUY0Yzc4L25uNDNXOUhVSWJEQkxxazN1RmJpMllzWmhiekh5OTZ5WnZGVVV3L1B4cXhJU2tUS251NnZ4MWVzc0ZvdlplaGJMU0xvU3dyalE1amd5Tk1LWGFrT3g1L0l3VnRHdFE2TW9rcVUreGhPNnhRT2JYdWM1NVF3OWVnUVBjK1VkYko3N1d2UVA4anc2TDBBdFhsYi9ZQmZvaHlxQ2xVb0pzM0xiaUNZWVBxcTdJNEtzcGJKSjFlSnNydDV6dk5kWm8zMXhHM3FiRFZBbncwNzdjWDNXc1gzRXNYMURNdVBIc0JucEl3d2Mvek1NVW5wdjdVMGJ6ZlNWSzRsY1RPelREaklyZ1o3eUQvaE0wOFFzVEp0MWx6K2RGdEVYRmxDK050ZDh3UHE1U0ZEV1V6U3Z1MjFmeFkvcGs5WVJvUFc1RVUzZjNvRjlLWjhkS1daYzQrSXkvOHExRUR3cEx4NW81OVJ4SHNqN3d5Tmg3V1E4WXJtVTFIbUlBaTI4ZmVDM1R5eTFGS3cwU2x1R1BERGF0c0o3TU0ya0VxV213aHFNMDJtTnFUNHJWdzBSVy80ejR1ZEFDS0doZGNjNkEvYW1ybW5yRTNqZTB4dGFaS1JVM1VoNkp4aS9FSXFMWUZEeXNlSGRJaGdyYmZRNHVKTnlXS05ObytXMEJaVlRtcUo4Z1ZSRXJvMFRJSzZ0UEp5dlIwSldtb2FVMGZpdGZUOGVVT3Y3QWNUOWZqUTdxV1ZnM1JkaHk3ZXIrZHRjdVJrQ1NLVWloU1J2bFUwSFpGdXNlT2lPSjQ5bVI2ckkyOTR3SEFXZzhvcXZZZm1ocXdUMUY3UUliUWFMVFhEbGU2eHphSVJEMjdNZDJXeGJ6dmd6YkZIbnhBTnVRM3FheW8zbnd6UFh5cjNmVHN3eVJTeldER1l3OUkwZ05xTktwMFdSQUwxbUpRM2wxMlBDcTFxbitBcWFiMUFBaVpzMXlVMW9BeTNUT2laQ3RoR3BNMnN4ekE3UlRBdUk0WStzT3FwVDZzRzBUSWdCZDhHZmZNTGZ4N210ekl2bUVuL0xrdGo1YVhpdXh1dHp0ZmQ3NzVOUCtHbjhibjU0eTlUM1lGeSt1MktaQWJZQjhxMlAzZFZxRStFbWk2TGhNRzY5NFE2TW03enc1VWNBZ0VyUk9zUHloSkQwSUczWGFmYm45UU1pRFlIUVU5ZWZmWmV3b01nNkRGQVMvckh2dE9IOTRzN3o2N1RvRmhzQ0dFMW9CQy9mNkJjYUJqLzFTWWxRSnVFNE1VZzEyNUdod0hYUGFFZGt6cnFOVlVLVHBzL0xDTmJCaVd6VEthSUo0bWlDbWxnR3lPNmNMaDBhWmFGNm5nblQ0bVAyNS9ReVdSa0NtcTBWaHh1aURHL3lwV1RpZEhDTEVpKy9ZaDZyaFRpNGc2ZVZmWWxHYkV5RDJUVEZZNTJURmV1bGFJaHpJMFp6bkZ3a3pNcWhjSkdVbGFlWTNjd0hSR1E5cVdlT2kwYnF4eHdzNnpWOXBibjBNL2MzMzZhVmMyb0Y1YzdWNWRaN28rYUUyWWRyd1hWc1BIdUFJOSt5cmd4ZjMvRjg3OWlTaVJaNWdPSXpBNmFQQzBHdVc2Nk96OEtqanVBVmJLanJJQzcwZVltaE03d2dyT0RCTWtrdjgyYldpUlhYRTVZUzViVXM3WXNrWFBTOWF5bVpEanV5SWFIckRmSkxhMXhjZ0ZYbWRtREdvR0UzZGlUWXBaQldOZG14THNuRVVDOVdjckhkYXVZMTZpUWxsbGttaG9oUkltbW02blBVSEN3blhYeVJIcEJyTDJNakVrZTZKYndnUTI3YTkrZStzeGhTaS9mT1NMaWlRSHo1UW0yRG1saTlqb0dGUmlyOENwOTcxMm52Z2VJQU1pa0FDM3RUb3d0TGNLVS92eHlad1R2dk9zN3p6bk9VSjNXeTV1VURQQ0RTblFMb0dHNHpwOFpQYzA4SW1qaGttTCs1Y0FHNzlCa29iZ2NVMFRscU43aWpSaG1yM1Frb0tab01WTGx5VHA5WkJ3U0phdkFlL2RSV29hUjdrOU5JbWR1VndnTGNCUEtUejdpYnNYaTNpbUhCWUFBTkFrYkwvVFNUR3owNjZzR0N0Q0N0OVJxTFI4eHc3Z3lIV0ZpaU41V0xRL2VvVk1wT0sxVzNiZnMzdm5rV1dJK2V4M05HWEhIY3NTYlg5UFU4YXVHSkdKL05GZkJtaUhDN3Z2V2J0cnQweVY3M1R1Y3NBMXVOaExqd3c4SUJza1RQNjUveFJzWUVuKzhwT3lLVHY4cUtzRDNpTktONzRmN1YrbmFnT0xEQzVZMys0dnNtdnR1blhnK1ZvMkZ0NHkwRFl2TUoybDMva1VwUldhMUk2ZTFaTGdvZTIvcHluOWt6UkZSelVNMDBiQjIvN3ZtcWN2VGFyUVp6bmcwWUJmYnJyQ2JDZmxsSUY2RHNpdjUxSTFQR0xRWUZhdWE3NXlRclcyVERpdEM3RW1zZjNwUW9OaXlOcS95MkplbE1PUGhObFRGaDhYNWQrS3hlNnc0dmFpcU1CL2Nhc1Zwd1l4alp3ZU5XaDY3Q2xaZkZhVTA1SWt0ZUh2bVp3azBhSFlTRFk3RXM5VFNjcEJGbGVsSE5teVpDYzFYSjBSUlVvVXNaRUxpNUdZYWNZaVl1eEErNitIc1p6aHFDZ3hQWmtwU1hUWGo2ZklDcXdmWThJU3JQM1RubGdBcW8wSGxMeHB3dy9iSjhzTFZkVHhXV2JWQ29xNUh3aEhuVmpkU2tmRG80WDdSZEdFR3R3N1pFV0duaHlLV0RGcjRVeFFVRTJPeWNsSXpIRmlrYVNjMlhvL0pEVkY4ZDVkaldyUzFyWnQwK3prRlROVEI5cDMrMHBRMkwwRmQ5KzNkZDR6YW51RlM0VExnZXU0Rm5ydkp1Rm00VGJoVHVHMXd1dUU0OEliaEFlRXQ2QTEwZktDWFU2aWVtUzVDYzhZUE9HWFZNQ0p3YnNDZnNkN2gwVFUvWFBndlpaczdCVExTWGhsdGxFd0NXWkY0YmtBU1ZDVnRPS3FYdUlHTHY2eHp5QTdMQUw5UkdBNmtDdHIzR20zOEVud3JiM2kvbXY1Q1REeEd2ZXVyWndUdk04d3hScFAxbUtKV3ZEZi9aeTAzQzlhTEZmUHo1TzIzR3pSQng1ZU9NdVYvMmYvWEYwZHBvdVBkb2YyQ2dmWkhtZXZ2WjFTSlJrOE85NjlrNGxOMmgweXlUWnZsU0NYWE9saW1Yc1dsbE9xTERjQXN5cnNRZjdXaWIxd0drZk43ZjRpOFM4SjM1dTRQK2EwMXhrZnl4eFM2UGhYTzVhaGYwVUZlcXNoUTU3NGVPUXM1Z2RPSjBFaDRIWGU1YkhHdys2UGViUCtLdVczMHhxMEU4cEYrRjR3Y0xzOXdzenlRcU4zOHlGNEFJc3RSVUdPcmhoOHFmUzBZNlduRjhUREc3YUlFeFByNExZdjZVQlB4STYvL1dXdnJwUkV1MXQ3WllNbWlYbE4xajdiYWVDdXB2WmFSK3hxYW0rUDRpbmhlY0ExT1JoVE44RjQ2aWdFOWFMWFJzMXBNSEgyUXZDNFJ5K2hDcjZOOE91emlPT3lvaHg2S01TZXNtaVdqcFFrVFcyazhHVklrbEt3d3FNMzFWQzFKMlh4OTBVNUpjbmlkMFJaK3E0a0pTUkpIOHRNbDhwYnNqV2R2ZDU1ODgycU1TeUxqaWd6aEoxbjNtR2ovUVIvTlVWcEFqMFRISytlK3duZzFUOW44c2NtREpPZWUycWs4dm5xaFdhT2dMRllCOFQ1bUVkMWFPdHpXTUljRTJCeDczb3lUYThuMXZVMG5mZnhKZGxWRDZSZzNuckovdUVQN1pLM3ZpM0NlQjBUWmxFYm8rbmduZ2o3SlJPdTlRWm9landTNFE3V3BNTmF0dWx0WE50SkoyZzFZcGUzWWxnenNwU1dpUzdTdUtGUHhoSWpmend5ZHRINGZaSVNCc0lKYVBtSXJ2L1FGbUg5K2tkSkVtMVovSkVrL2Rja0lRYVJDNXFranh1V2t0U0xkaXlmLzQyeGk4Y1VXUkxGREZYb2NlWFYrR1ZFYi85L1NWaTY2bGludWlSR2s3QUtlcnB6WkkzcExzK3pjN1pNbDJZWE8rZEhVVUVZZmpPRUExcGpLaVV3cSt6ZVE5cWVKSktzdGx2cHhOYUltVEtrTUZHSEZHVUhwYm9wVXVYUitjUHppVTVYMFBZWHRIRFlDb2ZQbkpsSjFZd2gxVEhuUWtwb1JrVmxzWnlrUFc1UVBTL3JkUDV3KzVzZGxWdHlFRCt4d3A1OGVwRThES3ZYTHJRQzVzMXhXSUNyeTRRdHY0Mis2VkZ6ZWthN3AzZjcyancwaHpUdERKSEcvdmtoWnhyZllGaUdmaWtrUytTM0pla012RUlRR1FibnY4aGlRWktNaWV6b3ZEZy9tcDB5SktrZ3lrbytOZ3pVUkN6N2dSSitYSW9SYi96NHRrcWZJbldBZHhJNXNHTFpOWndVaE5zMXY5U0JPOEYxTlhvYld6dXRoL1dJcGhjWTJaM0t6dTZiemFZWWFWMndRakdkNXR0TXY0Z2cxdEhEc2ZSd2RacTFuakdlS2MvT2xqUGpCbnZkUGwxd1FvclZhZDNPM2xvRjVwMEdOTU0yWVJWb0drOWJkd05VTWNNWlhxUnZHbmdDSklDcVlWb3dnMTdNdUJTR3NPTVdYSjhSZk93YzlBZzV3YzFrUEN5TFh4YmxESXp3bjhJQS96ckRMcEZmaWpCY0kwbnJrdlFvMEYyV3FCQTlya2lTSll0cVhoWHg2S2tTMTRGWWc0QXBjb3BiNkdqZlZjQzJMMWdpTU5UZ21aSEVINmRGZVNJL1d4bWR6VS9LSXRLQjRic1VVUk5GTVdwRUpFbU94V1JKaWhoUmtSQk5WTzd5OFMzNUNkTlpTT09lY0o4MVJWODdFT3VJRWxWdTc0QXl5enE4bmw0RTF0VWtqbDIwRjZ1NDJkT1pDWjlQRndvenhlTG5aRU5NT2drVnQwM0hOWWxtQ2hrcWFlTzREYW9tekxCbVNMbzhCclA2MWFUd2FsRkM5dFhyTjFFb1RoZmg5eUdvUnRVTXdiRFFFc2xrUW9QeEVJSVA0ekxpWDAxcG55TkUwU1N2WG5mQVdIUmc3bHpTaFYwWk51TDFjMUt3VW5ZV3pzYUEvUzVZUHhNd3NaaVdLdFNWdkFxdzA1ZWc4MkJwSUNhc0VHTDdKelZZRXlZbGFWU1NybUh1Skt3UE5mdTc5djQ2ZEpUVXhONXBpbUlzalo1MFRQeCtWcFR1UnYvc2JNZTlXeEt6dDF4OWpWclhUYno0aWNPUE9LdkdkNEthS2kxV2E4MEFoVkFlc0RVRmxEZy8rVmQyZWxhVHEwbUJGQXBraTh6M3B0anl5M2VyNUFmdHJMMXlKcmlJL0s4SDdybm5nUWxadVI4RHBxWTY3djJLZkMxVGFmMXdnUEpXM1RIa3Jka1BDKzhTUHZwL2QrVnVPZ21ZaUF0K2MvaHQwTlVZanRjV3RjSFovQ3pyLzBXWjhLUGhEQkZKWG5aRWNSNmRQQkV2QmF3MWZEK3dLcjhEL0EwUnhhK0s0czlLS0R3ZVc1NmZYNDRSY1o4b3lpTWpyaVBDNjRLcTYrcndEYUVvdmtaRFJDeWpweXoyeXRWN2VYcDZQcDcrZTl5Z0o3M2pEbVpSVTNzblRRUlkrczl4KzZjWTY1b3I3Uyt2YSsraE51aitvZUJlZ1p1ajlpby94OEIyeFBlNDdVOE9ETGQ4Mmw5ZTE1NkVNK2l1b2Q3eXNGNnZlcFZuT3pTNFNSR3N2V3ZodEsrOHJuMks1cUI3aGJTdUdyQmlXSWJjb0dsck0yQzgvdnNHK1FMNWhKQkErK2JPb051RU9wWW1BLzNZL0V2WGx1bUhQc1R2My9rU1RlVDZnK2dRdC82c2ZlQ0RLdVhHVHIvQ1ErZ0gvUkJYTnY5UDVKL0loemE1WDZwalpTSFF2K1hCK1VQcG5aQ3ZYUkNvQVJpU1REdDYwRTFHdEdOeU05RHBOZklQenpBTHJ0b0hQOGp6ZlVhbFQvRWcrcUZPME84T2FLRFNnTEJndnpCWUJ0Nkc1UFJJRWwzN0V6KzR3RUxJNDgvd0Y0QlpkYnBnRGxiRDI5djRBcm00STlQcW5JUmdZQTBZQzN0NUx4QU1JN3dmTk1HejdWMWgvZXoyTWw1cXdBLzhzNXFWQjN3NG9BTjc4K0s5aGFjMGFzeG1BRGNnT2pRZ3N3R2QwQ2NyN04wdmt3YWlzcTZOczcrRTJXZng2V3lEQjVGWjEvWlorNjlPOEFpY2dGMzRiQk1aWldVZ1NqdTVlYlpkTXNvQllBbjk1ZmJ1c3ltRFVGdHd3NDFNOXhYYnZmZDJZZVgyN3NIWmcxRGNlYXBqYlE1V3ovamxNNmx6dG9mTnBBRlRodXdjT0lBOVBlWVcwUFNUQVhxK2llMVZydkVEbGpGLzA4bzdWUkdEN3J0L1lzY0UvTTRaV2VQNk82NUhwZjZiN1lnVnNTM20zcXlUKzRjeGZtSkkxMis0QWJYOVg5bitkNlNCamg1bEJ3NURyelN5Zk15akRQMnppQ1daWFJuY1htUExBMUNTbnIwR05CdmdLbGZqZnB0S0NvYTI3UXFtcUgzRk5zMndRd3ZYMWZjZWUrZTllK3ZYTFlUajVBTXhMU0phdCs1aWV0OXp1MjYxeElnV0M1dVN1ZS8yclJmZHV3ZldrSzIzNzR0STN2MUYzdnJVYmFNd3VQQUZsemxQN3d2YkRFOHlObEFteFVqY25qTXlIVnVDTkhpOWhXY0wrT0RCNm56MW9HOEI5T09jTzNuYiszQmpSSlpSWjNQNk5VejNpcXhscTlWc2NDeW1PVlAwM0hzbCtWcW1GVXFrNlZlelBSVlhSOWlERGU4KzNlcmEwZHNBU3RKM09henY2VWdsWHV4NWlaNjZ0WC9hWlNPeDIzRGlJNHJFYks5dDRQVFh2djNZSUVPS0xmNW9uL1FzNmFFdHVENWZUOTlOOStvY01UWWJUd2o1M0Z2dmpweC9EYmhieFpaYkdWbjhMQktlNEpDREhWZ1o3UE1jdEdNSjd3aHREeDFXNkJsNVVwQzFjb1laY3hnY2pjWmhoZDIwdlFMOW5wZU1Ma1dSajYzSUt0TmVmZ1QxaGF1eXR3L0I1ZnRSVHZOMW9jWkdqSjhjQ0p3MWRnL3VzbW9XWitwZVA3TDF3ZGVqYXEvT0ZFOTdBWFdYSi9idmR0L0M3cW52UFJmRmhqNXd3TXdZQkY0THkvZkpwL0ZrOTJKejA5anVNMVAvSWFva0ljbjI5cTF4dXpoOEtDT0pNVkdSN0MzRFE1Ti9MU3FpRGN5Q0c1VUZCcEtvWWdLaXBycnZjRDhqU2psWlRrYmlUbVowT3BzbUdVa2Fsb2hva2V6MGtCamZMTkp0MDIrSnlHZm1oVG5PSjVTTEx0SmE0RGFVRnh2Y1NNc0dlZzNpV21sN3VYMnl0cWUyT0RGNTJRMlhKZE5EWTB2cTFMYi8zSzBEZzZudkRtbjBOYklwdjRacXErWHRKVWcyZlhsVW03eHNjbXJVV2hxTHgvUjk4YU80aVg4MEFja2dWWUtmQlR2RHpqN21tYVVCdExwU1J2dGRUSG1ObXkrQnJtQVdCcnB0bXZ0TXU0dWN4S3k2TkRhVVRnSllreE9MVURZNUNqQnNlL0lWc0dxOGdwc041eGEzQ3N5YytQK0l4Y2VXck5FcGdFNkxYajRONmFGcTAvc092WnpTbDNQRDQrV0hVSlhob2JKcmFmekZ0Vi9mdlZaTWUyS2o5dnRudDlWQ2ZqdHUwSDViZUx1NXJTaThsUGJ6VDkvMG1JUGZxUDE2RzQ3eUJ0MmcvUlo3RzQ3eUJtWExmd0RXelNIZEFKWU55aFM4Yy8wTVg4ekN5eUxMMWFtNnVjNHROcG14ZDVQZk9yNU1xa3dGWmdHaitQcE03b3M2dTYvZjdWaVYzYlhpMWxLdUhoTWxKMk9FbEhob1BSUlhRa1ltSll1eGVxNjB0VmpiRFV6blZZM0dWVFZsWkVjRkFsSjJTbzhrd25MQ01jMVVVZzdicGc1QmtFdGx4NGdndS9Mb3A5MHpVZGN3cTZOTVk5ZEI4L1BzUDlzeGRnT1R2cFY2M0RqRys1UzVOYjlsVXZHWE5tK3hzNzBRc2phelo2YVFKY2wwZERSdk9sWm1CTjVITXV5UmQ1U0VIY3FReVdUWlRwTDBjUHQwMTVYbmYrOGFoYXFqN1o3Y2hKYk9xaWllbE9sSk9wSGpZZlJaMTVzWjF6VURFTGlzR2s1MlFwdDREYis2dk8xZVlVNVcvS3ZNQmRuZEI3dUY2U2NXY2RWcUpqcW5HOVZLR2ZnNFZ5QlU4UTh1QkRuN05la051Q2E4UVNJL2VvUEUvTzJ2eERLWlVpWVRnLzZmdk94NmRGcVd4WThzV2RFaTl4bVlvcFI1dlpzQUhMY1AwT1ladDYxOEVidXpucDBWM0tEaEZ4ejN6bThBcnEvVk85Zk8xL05UNm53aG82V0dPczA5a2xHbUw5ZkhNdEJlN1hNRFcxb281N1RoZEVVZnovUTBMM2p2VWFhMFZBNXRoSFUzN2JyWHNwSnYweFpwOTYzQXJjQlFidHJMek00bWxXRHA0YnBRM1RkaVZKckIrekxjU3pTSXMxTlJ4Qk9pcHJqUE4weEMzOTUwazBUa1NWaUhUOHJ3TThobDdLbkx3YmhkTWZpSS9KMmlrRGg0MmhPS2Ntd2F5TDZEQitHemFWbDZwMnpJNzVUY2h4eUlZZnN6YllZRFBpcllRbzdkM3R4Z0JyVVlFZUVwRUxBYndDZkpnbDFFbVRwalRtQ2F0RnBqU3dWMjhySGN2dDh3bDhnUnBGUUtCOXVDRlFrWmlpN3UxeFVqRkZsWkdtTUhIazNqdWJFbFVnQ0taNjI5WnVpWlJDS2pHd3lIUDAyK1Q1NWlwK3VGQ25RenMrMDFRMVNLZXhXb0hMY1Q4QU13Sm5qR0ZMallLcHFpWUJOd2hDQ2VSeXNHZUVveHhlNklUekd1T1ZYbXRueUExdnFUQ1ZraXNhcWt5Uk81a2lJM203SlN5azNJbWxTTndjU1pVTlh6eEIvbk51SStraEUxZVdFY043MmM4S3hNU1RoTXFEd2JkaktpS0kwdnlKcVlLWmN2SUEwM1I0ZjNaT0I5N1crRmNYT0pjSlh3NjhJbmhIOFYvaDB0MjVpRUNmTlJUd1d0bVZXWkJ2dGlrNm1HTStuQ29nTkJiRDVBUGRIOGV4TDRNT2dkbGFLaWtzbzRPTFdXd2pPNWdOQitUdTFKRnhtR3BpcmV0SkZTZnM1UWlvSW02bkxjbEltb0dhcWxVT2dTcWxpcW9ZbEVOdU95TG1xVzFadEU3azJSalZkQ0p2emRVZEpVV1MrcU1UcVVHUTVyMWFvZUdra1BhVEdsWU1pcVZsVFZJc1FiQlNXbVFYeElyMWExOEhCbWlNYlVnaUVwV2tsOUlDbUsxZnh3TGltU1dnN2cvM25DUm9pSjM0Y2xYVGJEVVZXSjI3SWFqWml5TG9Xb0tNbFJTWXJLa3FpeStFaFVsZTI0b2tiREdCK21NQnhOYWRrTVZXd3pYUGxNVEk1cDJURlZrbVBKVUVtRG5xYkUxRXFoWkV5VzFGcE9nK2pDU0V5eHRGeU5Tb3FWTkVwNkJFYUNHTkZMb1lTbFNMU2ExeXdsTnJLUUc4N1ZSREdGRHlKK2JDUG93aXBBWjRybmh5NDhpdEFKWGZZTmJHWVRxdGNTZlRuV3NPR3ZteWIvNmZyNm1mWDFIbzNsTlRTWVR3UzJibnhMM0ExNWVqWTVPTTFYcXFtVTM1UFVSTXZON3JsbC84aHlvODhqcmx6NWpnT1g3TnA1dFV4RnFzVzFpSm9mT2ZEMkQ3LzlBQU5sTEorL3ErdHhldXZOUyttNkptdVVXaEZuTkxkUzNvcm1vSFNNNi81eG1zcURjVFBvTmdSaGc4SThPdzNmRXZjeCs1UlE5eWJtakh0L1BPdnFnaThYVjlqY3JpRmR4VzdWcWJHVEppa0hsWGpPTkdmcnU0Q1pJYW9TVlExbG1wM04zbkVuR1JhbGlLckxSWE44cWxaOTJ4VkRWMDgzcHFlMm82cmJqWGFGcXJLaVJFS3hvY21scWN1bnBpNi84ZktwMXhJcGJGalprUU9YWnVTZGMvV202T1JpSlZWU1pkNzNuazVqbnRudERPNkExTml1UDd1cmFSY1NodjR4eWVBdXlKL2ZvWWhGS1pMVTNlY08xMnhKaDRHOTZGYVpQaEtLU1pyN2ZGM0hUcE1uVDhON1oyZFFvdXJxRmJBdHNZNjRtRmtSODRVT0hmRytjcHVySTJvbTZNaHRTa1RKS09RTC9XSEoyMFpRNjlSZ0txbTNLUkFTSVRmMWgvbTBGOTYvd3UwSFhZc1doSUk2USs2R2ZLVi9INjczZkhuU081VGVwNitFaXI0UFFyRkljNkdaaC9hbmZLL3lJTkwvRDZMdmtIdjYzQXRtcjJlNkl0TUJ2L21Qd1N5OVFKWmE2TmhMWGUvVWkxeHd2V0tENnRVY1dLL1BkdFhyZXh2WHE5VlZMVHhhdEZHOTJ2K3dTY1c4dXpTZVp1ZnBKcG5leWo1T0dRVmhLL2E4Tzh3MkF1SzMrYXJpMGFTTlBzOUIzNVlydVlTWnJFZm4xOXNyek13YWtGUkw3U1UrMlArZzY5RUtHb0gxdmx0Wk9yZ0VQL2VDcWVEUDFSRjA3WGtsT3ZlWU5Jc0R6RlFwRndiNlNjSXM3UjlkV1VHR2wxd28wR3VGd2hyemJBSXUzM04vbXRsV1E5d3VGSk5CbVJvdUhQWkNsOWdSUmxvVGRTRFFYaWhaOFF6dDdpODZwMDU1Rm5lUEdPWWI5MUJENVFaMkNjeks5dGVkSWpsOEJGSXoyeEZFTThmMzBGWFY2TkxEWHV5UnBkbHE1MW9ySklpWXJCd3hMT3F2TzJqYmNOSGQ5d2xLMk9ZTXV6STF2cWRTM1gxdEthNmp6a0pJcHFGVXFqUm1KOHBwSjR5MnB6SmlsK0R0RStGUXFycm42ajJWdUdGSXVsU1dSVmxWdzVPN25ZeXBVWm5JSlVuMzlFYStMcTZReHpheUhVUjZaS2xPejd0b3RRdHNkVVU1VnZ2QmprNWdxNlBZVHg3cldvTTdsbVU2anVEYWt6Z0RzS3ozMk4xNHl3REpYWTl0SGRvRFZhOUZuVjZvenhmZkswSHVydVdIMlkzenpDbDBLbXk1Rmh2QWVhSlQ5MEluN1ZvbkFiTkU0bDU2SG15YmYvRWJaTlhUMWd5WWdUZ3hJS3pqM003czBLTGpuMEhHdHRSaGhSL0hYWUVGVDV4YWRIcGFyOWJ6VHBoZUhiSm12TVl2dEFLZHVSWlEreFJlYVBFVUZsYmdpYnNHUUVVdXFxUEExanNqOFJUd0tWK0NlWUU3QVVKRlllSlVLTDVab2U1VkUreG1xYWpvY0M2WEtmZjVxa3Zrayszbm9abWJGOHRBb2RJUjhvdFJOYUdkREdXMXBCeFJreU8vbTFSRk9hMHBvWk9hOU11Y09Yckw1eFVJdW5XSFppcWZmNElvQ1UxU1hrWGwwQWdralA3dVNCUStLeHM1ZW9kcXQ3L2kzU1RoMlZISCs4ZjRuUXl3d2k3NFRQYUFNMVJzWFBZZXBBS0U2RFNUNUxteHJWeFV0dldIckhNOFd6UkU4MStmZXYrVzk2LytjQ3NYVEc3MUVrQmsrL2xPZWpTRTgvNzN3OCtIRCtWaE16QS9qaUI4MHdHTmFxRGZmZEQ0WFliZWJRamVxdE81SndpKzgxZWU1Y0FsNVBDZG40ZlpPZUJNZmpRY2V0VSsxclA3WGhVYXh2N3REZmg3OWpLMXl4akgySEZqMTFSZkFFZlRaemJLb1JQd3VZM3pjQVBlemRjR1ByYituTmxyVEFHZFdCQUVtN0l6eHlrdTN1YjdkdENEU1NkSmF3djJRalA1L2RObXpJeWNObExHNlFqNFRzZGFyZGFaZGZMSEI5UjA5TnVtb3g1UmxDT3FZMzQ3bWxZUHFCZnRKd2NPa1BaM2ZuWDNMM0w3UU4rQXNuNlRuVWZZSXN5eTB3aG9KYlhHYmthcmNzM2FEZ0M0MityQkFPT2lXV3NpRkRiNEZtaHR0amxDUEo5RC90Y3RFZVAyU09SMkkzS0xFUW5wdDF2V2tTT1dkYnNlaXJ6bnV1dStlZ2Y4TzNUZGRmZzR5eDlmSHIwN0ZKZXJpbEtWNDZHN1IyVTdkSThSbCtjMGJYNWUwK2JrdUhGUHlLNFZMcTVVcWxVeVB0NytoOG1yYXBXSmlWcnRxT2R4eHhPblVmSkNGZWNsS1NJTGpqeEFCeTFVV1hWUXFkOUhJOXhVUDVvK0V5ZmFVOGJzU0gxNGZwamQrelE3YncvbG5oaVpmZUVNWDlKZldCTUx1TUNMYTB0RXlJOWFrSTVmRGtXa1pOb2EvU2t1L1lXVFMyT1dOYllVdEozdnkvUXFxUVNqdEtsNzV5Y2FPbS9XMUxKL1ROeGhOcTFoTmEzMTJUejB6ZnFUTDhweWVsLzZ2Z3hGMm1HTXFzV2lTc2VRaXFDWit5QkNsai81aDEyV0RXOVRtRVhlTE41VGt6bWVRUWsxSkNiRkltRVp4R01RbUpFTStaT3U1Y0p6QW4vZXhlM3ZlcmdrYUV0SzhIYVRkeExQSkpiM3pxMXpPOG51ZDlKeXVTclBLUzl2ZTJUYmNqbmdKMitZVGhRVDhPT1BCKzdrYjNlbUkrRnc1RVRYVzhDT0Y5NnBlbzF3NjgvbFB0Vm1yeDJobmp1eVgrUTFxdDlFeXg0M2NFTkJOOGp0VDh1Ni9DZzM5d0dQbDNoLzZueGVoaXdOeUFXeU5OclB5WkFYc3lUeUtPVHU2and6TzNWNHlzaW5ON1l6WE9xUnM1TU1XeUw5SVJVWGloNU4wTEwyZTBRaTBJeFdDOEpHMnl2WTU3Q3l3MXVkYjdmV1lhVmNBZXJuekJsZngvckZsQmQ3cWVXdEU4Q0dBdlh2c2tNN3BJdEFXKzBYcmhadXdkT1VycTN5bXVlaDdGSW5JSVZUN29Xd05idzZxZHJFSFIzVUFrUVJvS1AwM1ZCSXZlK1ZYaDN3czF3NC9tbHUxdUlNellSbWw4NDA1MElaR3FkeXhNbWJNd1hsNGgyWFhaK3RSdU9oTUpDTCs3bzI1SCtOZnk3U0Z4aXJJaUxmME9JeTg0UGNuTVlYUTRvNmJOOTBrejJzS3FHY2tkUE1TRW9zWlZLRlJFNk1HS3FXTTJqWDNyekd2MjUxTHJWanNoWnVPeWNLYTBmUDhQMDNtcUxQcXVxei9FR2UxTFRuQVBUbitFTnc5eUR3Mngyd0NsekNiRmd0ZWhyVnhXa1JmY3plUGw3NVJScDhYNGlmZzRlR0xxWmNrMDVNemdJaEZKVnM2V0t6a1hKaUtpMVhhOUMxQmkyb2hpaTJuNVdJb1Jhb1FaUmtZV2UycUdqeVc4cFRyMXNxYVN5RlRrU1JMSW1pcmhZaGlacWZPSFJvSXYvZlIvTnIrWnYxOERmRHVoNytSa1FudjBORG1xb1o0YkFXb2xOVEY4M2JNWW5LUTZtbGwyL2JpVEc2YmtCMGlNNDNEamFiQnh2L2tFaW5ZUVd5TExLQ3JyY2Y5eFNaaExGMEtkUFF3YnVvK0VEcEprT1l2akRLZUJPdVhqbS9ldGpwSmtyUVBpRVRDTjg3bkttTXlTRXhMWXBTYkRiRFYvaUZ1RFVVdnlSaWg2T1pWRHFabEVLNDdTM1pqU0d1L3J3dEhzM0hMbzBraVJOTDVpVlJtWlExS1pxUVpwQk1tRE8yMTBxWnBLWG50VWdoSERFTVN5THl1S3hMOFF4cUsxQmxSdHM5VlVqYlVVaGdlakt4TDdMejlTV21uOGdJVW9CTThvL0hBTkEyRFA1aGNabFpLL2JaVzNHWElZYlZ2NHRVVTdkTE1ZUHQ0Tjc0OGtSQ1ZpYTN6NCtRdjFYVjlsTmMvUGVtWVZVVkw0blpoRXdZWVRieTJ2OXN6ZVNHcDBMT1RQNFNLZlEyVC9ZbnMvUEVPRiszQ0R2WldUT2hVb3dGaFJrTVc2Z3VscTQxT3I2T0Nla0Y5d1BFTEwwU0I2Zm5YVHphdG5TNjZoN2t2MVlDS0tRdk0vZGFOQ3g5b3k5ZStCNUxzeG9VSGVncjVLZzdrZG9ucWE1cGlLWTZUeGF4b3FQOUpQQ2ZFOWp0ZVY0dUFhKzNqK3pWKzBYV2VQTWFYQUNJM2hqZzVTZll6Y3hGcnhWZENRYzJwZktpd0RwTkdFbDBzbDQvaVlLT1QyMEc1QnB2SkM3a3dJYTZJS2dsZjl6R21XMXBvSlljLytKdmg5WVl2cjd3d1V5cU9lZWpNRXgzd0pEZVdkeFpYQVkvT1hDQkEveTNhR3hCRE5QUHdUZUoyeE8zSmVDcjB4YzY1b055azJUdkRiMCtDeElRaTBRNHp4YVVlenp2Ym9ySlBvK1VkS1Z1Z3QxdzVZaWVDUmxtRm8xMG5XdGxXcEhNdnBPNzU5ZjBQRjhIWHYxd3hOQWZVeTMxTWQySUhEYkpuR20wR2IvOS90bm9SSFQyL1liNUlEL3l0Y0lmZU9YQnFReDhBUjlrVGdFL2Q0SmR5d1RPYkRRNmE5N0tENVZwL09IeXgzaFhITXJrbWYwMnUrK1dPNjdzaVBlRUxYU21kamZmV1E2ZUpFa09VSldjcng0QnFOT29mcGJtQWdOUmRUMkdHL0VIOEZ6ckJMbGVzbW9hUjVqVjZ5TWVBYkxHZkZ4Y3hxT3d6c0Zib0xrQURhK1VjL21NM2RBbkVXRUlOVnFZOHJtb1ZuZUppM085SktTVUxNYTRWYWllZXlkUTFZVzgvMldTOUkyWEd4RmlmRVBTUGpFYkxvUkdKZWxsa2lhTmhscnQxbmNWYVV4VnRmWS9lbUtWcURJbWs3c3gvaHNHaVJndi80YVVtQTNCSnhwOEE1OFUydi83RHJJaWpTdFJUeGJ6dUthcVk1S25nOFBrMGxHQVdhajBuTWFwb0ZLTHUvcytERlMxSFdtdk1XMVNjTnRIb2VpY2FENWhUc0NmbUZ2aFJ1VEJhZVJxWnN1eVdtWXRoemlIR1ZBaXp4T3R5MGE4VU9sWUQvYVUvL3BDbEw0UUlxZ3dvalJONWNxdXY5TDExbjVyMSt0Zm9EK3NiZU9LczlzMmVlTzZkQUVZMGJJM241Qit5YjQ1WDdLZmYzVEVLNVEvVy93eHdTUGRmRkUrL3F4d0N1WjhWOTJiZmZXcTlZVklmU0dyWGJVYjN1U3R1K2F2NzNwcjM5RmRkWDUzZUFCR3dkZk5xZkZ5UzJyTTg2d09xQ1RSQnJhSHJ3ZjVOTXgzMVBid2hkUjQweXEvcEFtTllxZVMxTDJFRldnb1BLTElOVDA0ZTRpWXUrYlpuWXVQUDZnbndzQ0FoaFA2ZytQeFBhSXFIWGZmajB1cXFJdEV2TStKcHNmU1VlYys4RE9oSGFGcHMvQXlhcW5oc0dyUmx4WE05QjVSRksvajc5ZUphTjZCaW9maW1tbHE4VVBnZFhsYVQ4ZThqSkQzU21jcGdPa2Z6V05iZEtWYTA1ODVBZGdYdTFUdC8rMUFUdWRvUmM4ZFVQUHAvTE1jdGFRdXBaWVJHNDRaRnIyMFcxejYzYVVVelNDQ3lkRFVrcEpNenI0WFg5NGJXMURDZUtZcXJDd0lYZlpqY21qM2dpd0dqelF2T2tGNEtIL3NJc0Y3Z2tkY2tNbC9TSlEzTkpXS2J6VFNKbXRKNC9WL0ZiRkRDZU9oU1VYbnNUcWRlc0JJaEdEQmsyVDVxd2pyVjJWSnpCelc0MW9FV2xHNzdsWFkxRGVWWkJxMk1kWU9VNlhFdXNEVCtSUFlmaVBUcE9OblRqaGliUGo3TFRXSGxtdmszMHh6M1J3enp3a21jamFFbVFZNCtkRkhManAyOEhjZ2VOM0VtREdJWXJUeS8vUEkzb1B1SGF0a04rUi9HZVErVFpBeXgrdWRGcm0xc21yVDk3S0xrRHdHRUswTyt1dVEycEVOcHRpV0JSRHhwRWwweFVsTjdJNGVrd0ZheVBjWFJmSDlydmNSYTNrc2xwUTFNVXhVSlpmWi83cFVFVUZOaVNUSjVIMTJjK3VWSThPeVVsSlVvczdVRkRtdjZvNnR5a09xWGdiRXJTaFRpazZVZ3l1UVZLSEFUU2g1aGU2Ym1OS0lwbmk4OUgrS2hMeUw3OUhHMk5CYm1POGNzSUorUnB1NktLbnkxeGdVWVBIV2hDRjN4RXpRZ3hSK0NiUDltR0dTNTFDbjJ3dGhGenlTTkF4TFdBUXhCUDVnUVRUZjIvM0tMM3hGV0w0UHNKeUUxV0s3QjB1UEVRZXVtY2tnQ3B3NjZaeSs2c0QxMExER2hNZlg2dnExVEQ2c0RiZmZ5dUI3YTM4TWVjaURNODlseWRjWVdlTWFMbjNPbSs4ZEZNaGg1bnZzejVQUE03cXJkNDk5Z09uaCtUNnpocy9idVZ3MWw5dWxNVVZ3alcxM0JEYllmd0VqcTdsUG5KQXBsVStvbEhiaGtCRm1MNmtYaDdEN01Ec2JGTDZLWGhmSytNNEtLNDJWV2VFd2RHT0lWYXA2aGJiL2pVTUJkTllMZ0hmM2ttY0VrOTF3QmZTeXErMkx5bllwUjlxb3h1STJUYzNHMjRWNFZ0WE82c1dpUGpHZzJwcFZkSnlpUmRhdFVNaHEvMkZmelYzOWQrRUpkbTQ5SGJqL1JYTHZLVnl3ZVhGUGNQTDIxd0dsN1lHdU5ZMVhHcWJsM2tINmVrQ01rUWdpeTQ3TnlHK3g5bVJ6b0xtQlBzSkcrZ3QvKzRxQVRzSXJaRlBPeXZIK29IZThJcUNTOEFvWlFzeGovVUVNeDN5THlXLzNjb29KNGNCamZuMUFzVHRBdkUwMlBJelk3QVVQNWJvcEpLU3hnTkhYdm5iVWgybjBycnRHL2FLN1kvQWxZUjdwZXRzNFhUREd4WThJKzAwZDJCSENFUUMvdWRobDlCYmhqRUlsbkZSWEVDWmhWM0dyUFNaeDBHZ2hSY09zR0lTMDRnbkRqQnA3SG5oZ2p4RTFqUk1SMnpTaVJwU0lEendnRXZBWTV2bFRuSGhKWDNXbkdLUlQwbVBMaDBOZlNYWlpET1NEMUNuM0tHTmdoTkp0Y3BsSGRLdU5ySFpwU2p3YVVNTmc2aWFCdUg4SnFsZThKNWp3N3pmT3c3TVB3WEdNWDYvWXdvWFd5MzZKOVNwc1VxL3ZkY1dSOElZVjYwblpVelBSNTZNY3BsK1FUSFFkWFBXbWtJUm41SXV4SWx0VmVybW9hU0t1NEJUNElUOHIvQ09jRld1RytXbUx0bHRFTTZnRjcrMnZlMWdVaUl0VGF6aEpma1Fwbm1UOUlaczM3WE1XTlU2U0ZVaWNNRDJrKzBRb1Fuck9JZGI2ejN0UzExeGY0RFFpbHhWM0hmazhqQk96OEl3c2owaUcvRXdCeSt3Njhqa0tOWUJvUXhxUk1kb3p4aGNzZTh1QXNnUEdtanBIdnFsM1MwUVhCQ3Z4eU51UnBGejZTMVZOQU9mL0Z5TE1KYjBiaXIyUnVLbkRyQkwvQWhJa1ZQVXZsOXc5ZUsrZm5oYUc4ZjduU3BjV0NrUEhNUHhpUUpVZ2NaQnFYaUJZei9QT2VkNXQ5N1ZVOURmQ1ZpeTg5OGVVcHFGci9sTzB3dkd3OWVuUGUvQ3hWTzNXQjlobnowVlRMRnI4VDBpYXB2VEhlOE14TkZIandpb0JyQ0drQUpvNGRnRDVBZ2N1T2tHcXhWMUwyQVdGdi9jSUxSU1dsZzM2eUsweFNzY2h4NC94Uit6YTdPVzV2Q2ltZi9BSU5aYVhDZ1dXSWdGeGtJSTlZdGZrY3NWS01jUGtuSGcvMEplRU9LeGIrL0YraElyalNvdHhnOGxoMTloVVVQdVlIV0d1dWxlV28xcHdnMnZRMUZDN3ZFU2R4WlF6eTFmdWhkbVVDdSswcHFiSVNDRnEzWGo1WlpPVWp1N1lxbzB1azEzT3Zva0pSZElpV2tKdC80bnJhWXhQc2tTUFZaWXIyVXpDbnJEam1jeG94cFRqZHZGakI2U3BwUmt5TlhscEtCdGFIcjhtNVVDaW8rTXJ5ZTFhUWpFZ0EvSVYxM05waUNXS1FMeVJVeVVEY3NqRXN6c3l1ZXJjNjJyTEtOOWhkNUMvVWJDRkF1UHd2YnQ4RS83VnZQTmRGaGZjcmJubUxLZEh5ck40QmtuY09ublo1Yi9QcXVSNTJtZWd5TXJ5WmVqczNYbjl6akFyMmNsTzd2ejZwWk5USEhMUDg2dHVPbkJPVE83Y09abDFXRlhETzluYWQ0NnRBelYrY3RnN2c0VzdsT2dDL2tEdDc2VHJNdVRKc05SbjlFd2MvK0laL1RQNHh3TEQzSGptWXgvUlJKaEZ6RzIzSW5GUisvRGJtUHZycUNEWFZTYk9WTy84MGpUaExzQ0IydVFMcnN0Z0V2a3RONzl0Wk9MNEY4OFl2KzJYU3U3ajVrK0N4WktWM21MZCsyQUoyKytwQ05Pd09od1FYaW5jdysxRk01clRyYjhTNjUyMVF3UUdwR3Z4cm16L2pKZlNyT1VUYkZNUGp6UGlhY0N6aWJ3VCs4dFl1QjQyNCszVzJiUmh0bGI3ZEdyR05ycDlwbzc3ZjN6ZkwzL29uTUQ4cDJJTzVCYTdUTW1nL0M3ZC9yai94U25mTi9pbUdVNm4vb1R0R1ZZRFVnK2IyWGNIbnI3czNjb2JWSDVaNDljQi9rcGRqR2loZURVZTBpSmlYVExEZURHMllTNkZUZExpdC82MUgyOXBoZ2EvVmpqT3hJaEg0a0ZkaEpCcmc3L2hHdStwTlJjbEpCanhnQUh3Y2RTOS9oejU5ZW95OGU4OEZHZjNLbFRhY3UrbDhtemozdStacFpDWm50bVR6ZzNOSHo0eTVXUWtmZkw2Sk52Rlh5SXRxcnhaWVNuYi80cEp3OFdvczJmR3llK3J6dC9ZeUpoWmFmYTZxU2JYTW5UNVpuYStEVzBTejVCeXJjRjNhSk9OWkxsV3BtaGlNa21UVHJLY1JOT1BUUWhOdWltYURhNVV2Y2l1SFJjTGEvWDBMNHhwa1loMjNLcnZMWVcwK3NwS1hRdVY5dGF0NHhnNjlndnArdG9XeDFaa1diR2RNNWIxcUtSSzRZOGZERjFzU2RxRUpsa1hodzUrUEF4aGoxcVdRUlZaMUVTWjI4TlNYRnREL0U3WldXRTM4dmo5bW83bjAzVmJTSFlITkpOb3dBNEcvaGwyUVJ6ZXlndms0NG83Vmpad1Z0ZFVnOTVLeWRJSlQwaE85cHYvNk91dkxmbStGZDhzNGQzcUduelJWWStra0lHVjgyS1ltMWdQZ0tPM0xqVm9aeHZwNmdXMHlzbi9XTk43ZjNQc05sR2Z4ZXJVWmFWd0pGQ2J0VUtoa0JsUjdFTG5ueU9ySkM2UGFIYk9odCszL1BvVUNvRWFIU3UwMTJ2cFd3S2ZGVlQ1aGt4MUlXUlpLY3Y2cmxlbHJyNHBROSt3MnhINyswWkMxaUZ3VTJvcTZlQ3dXZWFicUREMGgxRU95S1lBaG03UU5WRmxOSSt0bWg5Vm9rVktEVDBUU2lSQ0dYMFZxMkprOVZBdUY5S3p4d2QxVWJ1dHFlb282NkNLb21xSHFVMURHUzJVMko0MHRNeGEvdEpMY3lFdEU4b2Z5RVBvYTkzYWVUYXVrSi9OY2gwWEZ5emE2TUtlU1hZaitvQnJwOVk0S0NkTzhHc05UZU5aOC9JQmwwenRZd1hXMjA4eVlFK3p5dDR6SkVtdm51YTZJdGZLN0ZJcHBxdE11SzVEbHVtUkhnckMxSE84ZkNHbWRCK1daVFp4Z0UrRHRhYzV6MjVwUnpsRWM1QzFHaDl3dy9RN29QMFRvcERkSXF6ekNra1FjV3hNSkFXZ2haYlI5aSs0andmQ0V5eWxWeTFnMVRvZDhRTkNkb3F5dUpPUXBLaVEwVkdpaUpkb1JCYi9HbWcwOTNrMEdKbGs2VG5QODVSclB3TnZPcC9mdERlaTRnYTNaZzNva0xrTkw4a2EyQzJiWElvbEJlWUNucHdkaEtNb1o2cG5tRTFIempwenhwa3BVdkJMWnVqZzRiOWp4dzZaMGpLVktrckVsc0JEWlM4a3JGTzl3b051SHpUNlYxLzVDaHBXTHpheVJUV3N2dklWYWtSTld1SEV4V3FZdnRFZDY5M3RPOEdzYlhoUUpIdWJ0MEY3YnV0eS9LT0ViZ04zbXRlNG1RWnU1NkpYOGF1M0JyYnRUdjgrcmlmNXhWNitMVVJ2ekplWkZ0OG1JOTQzQlZKY2FQcmlvWUdqK1FmMjBGQXRuLy9PT1dFTWpmcmRDZE5zYk9DSXRmZzI3dG42bUNTTkhZRS9maGNzdTVkcGx1MzJMZlN3MUc2eERYNGlsRnZWTGljSDZ1UVhBQ0IyMWU1N0ZER3hWVFRFOGo3Y2czNVppdnY5dnYvQXJkUlExMWluUHNmdmRSNDdKaXNYNjZZK2RhOGk3enZsOXZQNHJSU3FLblNOUld5M1piem4yeTJUOWcvS25yc3VCOTB3VE43SUlGanZ3c2NiWEM5OEE0TWlIUnlBdjlhWENyMTljRTVzam1ON3IxY2JNSnVuY1gzZ2w2a05HbUpkbDZkUnYyeEZDQXNKd0NwWEN0ZWp0YzFtZGI0eGg3WTA4Y2dZVFNDUlE5Vm1QenhvNzVEZFc4K3ZyVmZwck1wT2YvSzlCbGpUNW5DUHdlOXRpbThVNW5uekQyVlJ4Vk9ESS9Ia1hZYXFHM0wySTRFNmlFTW1JRkJKa3BJcFVaWkU2c1NIckZSWWppaVJJVHM2bGJES1daT28xbFdzUTY0V1ZUMGNqNFUwdVJVYXJUVnJhVFVzUjI4alZBdEZwZlM1cnJwL0pqNUtrcUZFeURTb0VVbkVjb3NGRTlaeVJSa3FLbEZKTi80UGMyOENKOGRSM2cxMzlWVjlUVS9QVE0vMFhEczd4ODZ4OSt6T3pzNnV6dEc5bG14cFpjdTJNTEs5dmtEWXhpd0dHeE9Nc3lhT0VaakVJaVF2aGdCZUFpVGlEUVRoSkdBTXdXdUhKQ1l2WDZLUUJKeEFRTW1QRUVOSVl0NlFEM09OM25xcXVudU9uWlZraC9mN2ZkSnNkWFYxZFhkMWRYWFZjLzRmS3lvSHYwYmYzQXRJUmp6Q0FrTDl4dEY1M3MvRmhKSHI4ODQyYlJBMHJ0OEwzQ2hJWEh2K3dwekY1UUd2dU9GNlpEZk9NL0xKU3k0WGV1akNwd05tTUpENjYvWGp2VjV4S2dxV0J1R21oM09WVDRaU29hMi92WDZzLzJZOXBQSHpVT2taQ1kvMS9SWTM3c00rMklmcnc5VDE2VU4wb2FCMC9UcnpJb0xRQ1YzejcyeG4yL3ZPSTUxZ0hSMWdKekd2elYwZHVtVGF1TUdrMXBBMFFDbkYydG5Wb1ErQ3VLeFJjbXVaV3FtQlRhNW52ZDBQVXRBKzYyMk5oWWlCQnBGdUpmT3czYkhMK0lLWVE3WE5rQ2NmTVRYL25abnR2d1RQeDJXTVNnaUxKUkVqWFNkOHRoQWplMFd5VitTeG5CQ3h6YU9JaW1ScGdGRFpoQzZTZ3ZpMmZndnlIYXA4U3BRa2NXTFUwRlQ5NVpBOUphdVNkSDFLdmJRRWU2OExDbm9vczBlVUhtUUxOTi94ck1sK1Q5cS93YXY5Ymg1MzEzenM2NDhiM0Q3dWF1NlYzQnU0dDNMdkJnOUYveDNtT3BZRjErckdYeFp5SFF0RVg1K3FDK0ZYOWNacnZ5RGUxWE1LL2V4YmJCcG5nWk9aaEtEcGw3VHU2Q2RDNkJBbTlCVXhkQjZuK1BNMlMvMTQ1QjBsbEg1b0I3dnRGeUg4dWZNZUpkMnVidEQzdjhOOSt2OC8vWDlCanZyL3l2dXhPdVBsZU1ueS93Y3ZqU0oyTDdrK1lHN3VoUXU4U0VSdEZCRzFVYVM2WGpKWFIya1lNNHJkVjBMUHdXZUhQNk10R3NuUFlCT3RrU252TTM5aEtITktnTXp1bnlFekh0aEd0RndiN1Rud3RxRVl3QVVYRG9pYVZHZVluQVc0Z3loenZ2RmtidVY2TFNwN1FkUGFsbzZQbmRJMlNjWkFNYVBoUWp3Y0VKVndSQWdFVFR1UURRNE8wM0RndzRNVnBKK1NGYVgxckF2eDh0dHBQb2pDdWFoVENLdHBPNjlHc0tKbXpZRElwNVI2N29md0tsL0l6U2dwRk9UVGhKUi92YVJNZXZndWlQTml0SStCM1hTSnRwbnlNOHp6Z3FwbGNIZmtkdmIvV1NzbWx5UXBwQTNFRkxOVUw1TE9jWUtobWFQSGo4NEVBNGxndG1CRTBTa2p3R3V6SS9sMEtCMHpJdEZVc1pTNlVnOGdKWjR0RGM4Y25TRy9zVkptSUpUSmh0TTkvb0VCUXA5djVyZ0VzMllGdE9aY2lQa0k5Z2FMN2FaKzY4VkN5UDJpMGpaNCthMGdpREt5QWJXN1NQMEFtZVlFcmFWYng5RGFNLzJJWGVHRlZwTnBMamoyL2J0eVd1QWhkbEdVcGFQY0RXUWVlTFZueWVNWmw0T1ZDbzU2MGxzSzNVV3R6N0dyS0FCVEZTazYyNmhEdnp0a1hZdENZVGs2NjlSTFlBUUU0VzdLbUI0dnlwaFVoREFKZGNpVm96RlNpdjQ2bURFM2I0OG5nK200WVllMnpiQm9ab0Y4bkp5TXBGekJPMUp0ZlhreVpacHE3Qy9zUWtTejA5YTdLcmxTeWNzWHl2a0tXaTRYd2hFakptUkhpbmVVQ2tQb3pUZ2MvcytRT2l3TG1pSkl6blYwQlhxTEVqZmpPWVF5MFlCdXlLSktqZ3p0RFluN2tDZ29RVkhIdXdXWmtDRjdCYnhiZjVkb3lMdDVySXBIREhGQkNENFNraGNFTEtyb29iMjJ2Q0QrNm01ZDJpZjdPRnBQVVJ5dGRwOHhQQllLbE9TYmkzYjBHUVBueGpLNkxtUWI4WFF3R1Mva0pJUUdZL0Y4UUtkOU1MUE5PN0o5czVrSjdrSFhTb0tpaXJLaEI2SVpoSExrTVpRV0JRNjd6aUZITkVFZVZrUC9HUTdqTFBtbWYwclc2eStRTmcxUVM0eHluK2dwOEdGVDlMQmlneG15a3U3K3c3dm9ySG1HVHAxM21VbzVoYVpUWmFYMVoxVzVLVmZIUC9kdTJqQ2F2UHR6emt5K1VMdjFvS0t0cm1yS1FVb2puT04zVTF6QVFVQzJwZFlmSlNCdW1FMG5wYzNMZENGcGJFUDgxa3VVVEtpMWJKb1lNdWdrbVp1UG9JVzB2ZG9rUTNsUFlPeDk5d1pEY1FPU09UTEV5ZUJ0ZmZmdVdKTHpZMVd0RUZvRW9xSVd1dTFZMFptMTVxb1BWNEthVFE4TWtDUytQY2NIdVhHUTRUUUtqWnBUNk5VanVMYmNXT2c1RXBsdGtDRlplQ1NlZW52U0FUNzVCQ1NwdHlDVnpOZ3Fla3ZLSzV1WEJGNGV2aWw3K0hEYkZRYmRCZEtGMWtNZEpWYUkvTHVYemhuUG9PZlJaNmdkNUFERjhJU1JVeVlNSG5pTWtvK0ovQnlLYkZZR2Y3SGlPcEJwM0MrM1RyRFc2Sk5EL3lUYVptMzIvY2hzVFFnc0Y5Q2UzZlg2VWtXbkthcnhzcUR6ZkpwUWs3b2c4d014bGhIU3pnRFBHendtUjRUT0drSjZmUTMwUU1BV1RmVCsra3pySGkvMzBiL1Q5czF0MlUvVEtZRmNBUE1EYVpJWVBEL2dlSmVNZFYvN2ZEVTRUanIzazNObnlMaDRrbHFtZytmb0h2RGhMVVBJUW9xTVpBcnc1WUUxT3JETjRETkVKckpCNUg2Si92TFZvSmhMZy9Ra0NEeFZRMmZ2dGQ2R0ZXUmN2bW5yenZvMW00T21PU2dwOWFzaXc4R1lnRFJoVk1QMW9mR2dxa1JhZjh4OHE0N3FzbVhaNXZ1SDdVSDFsbVg1N3BWTHcwaVh0OS9neERXOCtacGJwNnRsZVZ5VmcrQlBKMDBPMVNSSjEvVGxRS1RDL0tncVNUUEZDd3NuSlNFYXltZGRqQWptT3dHeDduY0M1aVpaSTNwTjBjbHlQRE9KUEQ4RWQrd0NVcGdIMGRieGhQV2FNK0JEd3ZMTGkrNm9CSmVLcjByZ3FudlNUcE9QYm01eERnQWhRa0dxQUt1azArOVl1bnMveTdrdUZLMGxkelMvSzJCOE9tQ2w3ZVcwZlFiOFR1RXZXZ3k4Z1ltdnppd3RmVHh5eHZOSTROeTVBdlNUSnJYL0JvZ3A4aVFVY21hbVhPamVSZisxUnRXUjZsTzZjWTVsdFRYZCtMdlZ0dTV6VmN0b1BidlVCcnJ0OTVEaHBybTkzRlc5OGZzOEEyTkhkak9OUEo1aVlyejZGUE01b1ppTDY4b2NLbmJKQUd3Y0dWVGJVRmZRdjlkWG9BTXFIMFJzdTl2UVZWMFA2VEowd0I5MDdueDg0TWdWR1VrTlM4NzI3WTRVVmp1TSs0UTBuQW85Qmh0YkpxZVFFdzNhKzEwN2Z6dWV6WTRyUVY0cEpCSUZoUTk2dktuMzdPTWU4bWJiOW5BS2x4dGtkbkhJUnNZTnNwbXlIZkNYamswM3lvVFJuNFhEdVBPSnFzbnRvWHg1bTNuZ2dMbXRYTEMySjB2S2xjVk1wcG5KRks5VVNpOWtEaDdNZERSOVYyelRFV0UyTWpneU1oaVpGWTVzaXUyY3lldVhoVFV0ZkptZW54R1B6YzBkNDZndmxvdDNHT1htMmFnbUZDeDFUZ0g0eVJxRG1pUzBtM1JoK1dEVVdRODFlTGExUmxFUFIzT2JZOGRpbTNOMHAvVmZXSnFoNURNTEwrOWxIMmVqZWd2Ym9DVUtnNWh3bkFUTi9FRnZkWnE5blkzblJYZFlJOWMzQm5Bck9SYVZ0N3pPRU5YQjVWNjcxSWJUR1lmaFIyQUlKTDFXWXNqZWIyYUdRVkxsc0t5bTFOZXA2Z1RieUljck1oeUtLUGZpSDhVd1BZRmFITjJyUkdBand3bWtZb3FjUURma0JMZkdtd0ZabE9Ibk5QMVlnQ0hPZ2U4UU9XUTVkWEtOUWcxRDJMMllQSWx5Z3B3blk2S0c1Ukw2OWpXMzdLbnVhWDEzNzhxaFBiZmM4aVlrb1gwby9qWWtvbDF2dXVWclpHOXRGZjVsZjhvTGhLZDRtdWQzL3ZRY0x6QTdjWlJGaTJSOWkzYm91eHVkamtnbm1RRm1ycnl6WE41NUVCSmtNVHZOcHJ0UEVvKytSbVQ5SHVYcTNIYlE5aEZlaGNHaXNnRHU1UHQwT21WL2pDend2SGhZOEhaYkxwU0JEcU4rN2s3TkkyN1JjenNTYzVWTW5CQnNZd09WdWNRT1NnVXhvaG5Jb3IrM0hDc0V6aVpySVpKYklMbXRTMjZFOUZTeE1oYzBVdW5rWEtXWW9nQWtOS0w3TXMxbWk1WU9NV1IwcTBnMks0Kzdka3lJMnNzSzFFK0JjeDF5Qm1sWUYwOVlUd1dhNkNlS29yZXl1cUw4OVRIRFl1RWZMZU1ZK2dpMmJmdzMzN0VNR0kyRzlSMUswek9zYVptektGNURucXVRYjM4ZTR1T2dXc3pHQlhDQ2pUazFTb1BYeVBJV3d3V1o3T0lDSVROS1pDcllCcFFCK1YrUXFYdUI3ZFFvY2hraE90RHREeWpLQThwblZTdVM1Sk1SUzgzZUY3OXgyNGoraUtJOG9ueVc1ajl2ald5N01mNEJ2OFpINFFSRm9xV0lHOXc1MkZ3YUs0Nm0wNlBGc2JYNVJYM0xQYzFtY3dreVI0OXUwUmZuMTd5RFdhamF6TkpDSHlNSmZaRDBrOE1ORVJwN0c4d1VqUnA5YVhLSDRXaUpHaDNhTWk3NDh4eGI5MklVWHMzeGN6WHFmOWJlV1RwTG9lenB0MDF6cUZrZis0ZngrdHoxZDE0Lzl3ZG14TkFrM1FtSTFoWXZvNXVSWmtjK0MyT0NNZm9rOXcrTmE5UHBhNWNCRWU2V2lLbUhoSUNqaVpveDZlZnN5OXBaMysrWDRyZUF2YmJBcUdaL3lIWUhBWnAxSkJlNGxML3ZLOHBndVBWWHlkSTl3T0RkdzlLSkRIcndmaUVnbTdLSWZxdTEwN0pMU1VVU3NvSlVwV2txVTVJdVFlUWdJWm9DekMvelp5VDVKZlRMaEV1QUdNQ1NEQ2lVR2RLcDJKVysxQnVrTjRIN0IxalJScEUwSUlOa3FUQkZLbUtYbnk3enIybDlMNVg2b3NZcmlvb3RVYXlLb2tWOXl2VXhNbXgxWktkU3lDYTUxcitpb2FGM0IyYVAzWDVzTnZDakt4VmxtNWtRelhCUWZCUElITjhrQmtsMklCSVFiRnNnQjY4azJ6ZG8ydVNSVUNaRWZrYzZjZVBBQnJIVzMvNnhLOFJSajVmZWVsdklaVUs2ckxScGNqZmJaWWk0VzhXTGl6NnVsNTkxL1YrT2svWHJBSTNzMlNWNDdoZTVzMzgwejI3VDV6bzFyaUR6V0h1TmlLNWpVTWp6bmRMa08yVk5rNk5SU0ZuMkZ6cnlQY1hvamlJV2QwdGlUQXhJa1drby9wL3dHTlBxL2lSc1NmSWxtdEprWWFHZDd5amV0MDlGUVhHbkZCQWRTUXgvQUJ6bW9kTms3WG5YeDVjbWQ2QlhjRlh1WGpLV09wNk5JYjAzZ0lWaGM3VkozV2diMnhBRC82WWlHK25uMllIL2VDODA3Z253M1E4YU1iT2hCbU5XSWtLK2pMUWtDS0haM01UV0FXc2twcHFFWW45UkhibEVIMXVSQThwZ01tWWJKVFZvaHNJcGlSZkRwR2RUZy9YeGNqYVNDaXBHN2tYMXE5dDN0NU94Tk1tOWlmVGREQTBkUjBpSDdkMXdmYllibHg1c2RDYW9mekdJRW1aL25sM0hENFdEY1VzVFZSRnZmYms3VXNUdCtaRm1MVjIzSlNRUS9rMUtEMFNUclFkZVhNODlZT3VxR2xHVmZlN0FpY3ZpZm5XcU1MNDlFaEVOYVVEbUpTYzY4dUo2cmRNVzJLYitqWDM5eWluQjFTRXBubVZtQXhBaW5tSVlMWGRqNW4xSlNhalhocHdQd0lSNmxXSHpmQ1M0T3BLOUN0MFZDNy9iUUt1OXZ1UVZSZGx2VXFWNDBEQ2Q1TjRsODQxcXhwdlh6L0xnRTFZaWkxaXRQZ05PNGg1ZU0zTnlNRHVjeHFtcEExcFpDMzVJamhtdHh6UXo1M3hiMDRTWWFLbjNwb3FtOWk3VFdOYXpyMDg3U05BTVU3T2NuS1hXVkwyWUlxUUozZ2MrRmtCUFVMdUFLa1hyWmhOaHZ5MFpPaVpkUktBelhLYzg5SjVRWElubkhPOHZxK1pTa3ZabUhOWC8xRW9KS2NsQnpYam82dE9oZU56NjVGY2hmZllUa0g1dmpFd29PZk5qbWhhMVhodDEvb2NWSiszNHFZc1RDRmdERUlxa3R4bnUvZkg2Ump3U2NoUW43eWlFbmpiM0tFTkZDeDhZSkFST1V3N3J6NXN4SVl1YzU1eFFGdUxuWm1ud2lqT1BoYTNnVU9UekNYVWdzS3pxSWZPRUtDMkdIQlkzbnVLWGp6S2tJNmRPRGJ4Y2RCMWYzVWIvdzFkUUpzUUErVVhkSUpkZDdpVytzL3F4Z0dFTjJnT1JoQjJRNCtiSDFBQVNKQUhyQWg0cUtLVlFjTVJNRnBLMnFVR3NFRWoraHZtclIzNURsYkNhQ0tVTnBad1pEQVFOTUVjMGJjT09XNVd5YkJwYUdBVnVEcE1sOHYyZVk3aVo5NXpYNFRuT0VYcjNmdTg1SWhCZmsva1FVaFFRYUtNTGljL2FTbVpWOHFPVXJkVHpoVHNlbE16NFMyNFJHbnBKWGVER0RJSG5HS09XaCtEblBJcGlNcWEvVVU5cVNwR3ZaMXh0UTIyYUFtTURObGFQVHRlSEVlQzVWUGptQUFxVEQwSXVWNnc0ZVFRVG5zVUlCZ1l6WmNWSWh4SXFsdFRmQ0tkYVMyMi8relJyMUF1aHBEa1NESldVd2hBV2RFeWVBd1hVajVseE9XQW5JZ1Ayb0dVRWttSHZRY3pIdXZBRTJOaHlueVVDM1R3YmMraVBTczdwZjZiblpROEdkdFpVdXpzYjZYMHBub1h0aVpmU0hMVDIzK2dBeW9QL2pPcCsxaWplV3AyaThrVTlIZlVrV0FESEJsR0l4WW1zMVh1MnNKSEltdEZ3LzhqY2t4Vmk1aG5iV05Ha1ZFN053cGZjOFhlT1U1U2o5SGRtU1JKUG1DSHJ0Sm1MU0lFeFpNTVgvVXdGMGtvY1VraHVXSUovYmR2bE5TN0xOUUdCM28xVTZjWk5tNTJneG15MFhlNDBJckg1eFF2TzVrNDdOalV5aDNtNEZ4U0JYd3BFcmlITFdrQkVRa2tSWWtsbFBybXEzNlpGV2t0S01pWW9KUUdSMWQwVXJ5SHNHeWxlVFQ1Mmc1YlVidEEwdGtFcmtjQ3YzeTZUMHcyeHBpY3RVYnNzUDdvaWhnSVBCa0ovSDRqOHRpWmFTYjBtZ2dtTmZQdXZBN1B3OS9TWXVES2FmK1pHVmIyUjhPZHM0OGI3QVA1MjNvdDZzZUVrN2oxV2pENlhUeCtTQjZyelhMbzhvUFQ4aFlMTGxxazlyNWxLVlVIYjdZRzBQUWhKZGhMU0tzMmZ3RlhZN0l5V0FqY0ZveGlHaXhBSnZ6N3M4eW5mSkczN01NenJEVUp3MStrc3crZ051aVdmTDQyd3h6Z1VHT1h1d3Z2c3hVemF5Z1huZnFidmZKTHd6SDhNMUQrOVQ3M01CbW5OMjVKU1FMVDN0aklsbXR6eFBJRjBQV2RzTFl2aGJGb3NhRlc2blFsV3hZRnNTQnpUQjhWME5pd09DV0pTU2xoL0Z6Ri8yVUMvWkNCOWZ2RjNyYlFTdHQ3emwzVHpqMDliSVdYQStyMzdyYkNTdHQ2ajZ5Tm00R1hCU09BK1BjY3dKL2o3cVE0a1R1T0RIK0JlNnlHT3RFbDQ3QW1waWhzZEtEdlJ3dXdrU0Q5TDFEMkhSUzlrcXhZRDV5L0RGdFlzSUFiSklLZkdteUJLeW9Dai9VTHZ6TTFYZTB2dUhJbWc0R0dlbCtRdDRkbVFZZXpTQmtJVDRaeXE4NGFpcXhhUHpJQnBTWVZJTUJFdG1kZHRqV2FLeVVqVHlveU1CS3RvMGRVUmtlUmJiREw1MXJxU0gxWi8zd25keEdOZUZKbzJpcHBENW1XR0dmd2JvNkFwQW85NEpZWVZGSXJJd1pDNTlIZ3RHdGtmcmc0WmVtamF4d2I1SU9tN1ErU1ZVMnJOdGZTTTRvS2JDMUpaRDhYN3dyN0RoQXYvVlcvVTNOeDJhcHZBcmtCeTVPd2ErZ3dtOVE0RVNUSXNZdXRHMEtoVUpCa0ZGMFVNcnU4SG5FTWlxWEhoT28vZDVOeUV0SXFrWGk2cHNuZ1ZTMldSRkt6UXRFL3hneXVjaHpYZXBHTmtnSGxqOU9LZmxLZkJUaHBveFNDYXJma3crWVUyT2o3aFlYM2szS29WdkFGb3hoOFlNZm1Hb0lWT001akZWN1BOU1lyZEQ4a1crWjJhcm12dmxKZTZjSjJaWC9IemhLY0dDV3czNW5kaHZkNHd0SjRkcmExblVVR0RqWjUzc2F4S1h5cjV1RmJGb3AvdExVYkxQaHZld1pLM092RGtPc3RSVS9Xdy9DR0d3UnhETm1MeklTTXF2WGJqdW9jSjJRblNOTzFHdUtjeEFQZmV0VWRUVEg3SGVCekdjTndadHFnVmdEWHNzSUx4SGJ5cGFIdnVRcXQ3N3RwYlZTMFJqMjgzdGRPYUdiWjRaZ1hBVzJGYXNIMGNFNHE5U2k3b3pabGY1YWZRUjhGcUNtS2ZZNGI2QUJodTd1cERXV0wwYUtHY1NpWlQ1Y0x1eS9MaDBHZHhHSDgyYW1VdlE2ZmlWaUpoeFEvc25KaEtCdjlRbHYvUWprK083enpBWkRjL0pXdUZpRDdDQlNpbHpaQThDOVJNcndEaUdqSjRXR3BDZkkrMlFYSnRHeXFoNXBSa2kvT1o2ejRsQmVWUHZmb0JJYkY3VHlLZFR1elpuUkRpWVRQNmlpRXhLbTJhRW0wcDlZYW9HZjdTVGFyNml3dFB5UElUWHhFU2tVaGlZQUJTSWI1alYvSXFUWDBMV2IwYXlWMDcyUFArSlhuZVQ5SjRFcXk3MlVycjAva3paZlFFamdYT0JtTHlNcFpmSzdQc2EyVVpQYUlIQXZxYW5pUi9ic2JIcnZvTWVjTHRYclNHVHRhWEJjSEp5N2pEVzN5UWdtelFRTTRVTWNVZHZFNXNGbFFhdTBZWGMrUWIxdVVJbm02eTBKRkRPeEkxck9qdnhLcU5wL05IcDBpbFA5UmtYaG1taXU0ZENvMUhQSkRFVVhJV2tpbzBJR1V5WHNPMml0K3BLM2c2TjdUcnRiOW1LTGJNbkY5TzFHUVg0OGlsZVEwdXhYR2h6cGpJQTY3a2V5c29rY3FsUFhlOTQ2NDk3YVR4eWh0dmZDWEtKc2VTeWJFWlNPYnVvUG5rSFpXZ2FZS0NSM0p4SjUvbVZES3locmdKb0JmcVZNb0ZiQy9ZSFdDQk1mbXpqY2hzQ1RlODZQT0lPbEF4eUZ5bURpVW5xTGhhSlYvVVAyK1NEZUYzSkczbHZ2Q2c4cmVDK0pQNlpzR1FOOG1pZ0w0T0ZkUnZ6NHFFT1VqZHQ2SXRyZ0RHSERxUUZrUzU5Wmk2R3JIUVIrWEFGMis3bTFST0N3RzU5VGVyVkoybzNhWWs5ZkNxaHdGM2xzYmR5SFVpR0hUTUx0Nis2d2ZTYUtNZVVvS054V0J5RDFJTUsvU2NxYjNldDVoNnZXYUtueE1WOG5ma0NEV1RlcG1aRDdRRUpBQ1k3TCtTQS84S2lMTUNldXZENENDK0RLY3NneXY0dzdMNFhrRjRyOWpZOHhDVVhiSmYxLytLbkRFb0NrOEo1RWN5MUtaZGNiRkZuNkxJM3l6ZTVwdTVYK0hlRHpxSVRydmo4K0c4djFnYnQ4WkY2TDR1RkxlVHp4SUNkUzBRV1FsRVZNeVRxVFBTZWwwL0s3YlZmb1dXeUNkcE9Fc2FBTjdQbnV4ckJyZkVzTGdpQVlEVlV6RmFEa1JhSHp1dk8yUzc3QzI5dDZEWjF0TjlxbnB5SDdCZk1waTBvek1XZ045YjYweUJhM1hQVkJCbWZQZURHNkZtVWtzMDdjaWl0ZllIMlRvQmg0NGVoZlQ1ZHRiMWQ2VXlsd0dLS01sc0tSOGlIMmlVbVVlRzFyMHRzakxHZWkxTGNDK0tKRDFPV2x0cTlOYnNjWFF0MXpydDIzM3hjSmNOQUZwck5ha1I0bEZxd1h5VTJpYSt3Mzl6SC9kenJ5WkpFMi8yOTkvWWZyVmF2MEVnam9GOUl3RDVVT2pjQlZOclBZSlJ1WDFXczh1ejlzZ1JDWGQ0M1JyKysveEJueGR2ODE3ODFEVS9EaDNuZG9JblJLdlJpSURSYmx6Y0FvMENDUEY4NmpVeTJTSUdwVWZ0MUhmWDY3czk2MlMyZHlwZFRaOUpWOUZLMjY1cDEyM2g4RzI3ZXZZdksrOHFsWGFWZlh0MGFNOGtTQnpSaFp0U1p6dENBY0pkTmdvbDBpeDBmS01Ha2UyVlR3U210MHdIbnREUEFFRExSaTFpKzYyVm9iR3hyMmZ5K1o2K21ucHhMV05MMDNsYnRaOTAwMXcxZlJGTmFwS09LdS95N0RKWmUxN0VtenYvQzd2Z20zSjVSQVJ6dzJXTW5pMjA2UzU2dTFrUStYWG9pTDF5UUFxZ3BubXNOWEs1U3dzM0F4UXRoNlZDdEpCSTVLTkRNSEFIbzFtNkhhSXdJaHNkUWZDdFNVb2lvVWhzbWxTTUFXWlF2RnlsbTQyT2VmNW5LeTdPZVFYd050Y2hPdlZFbWZEUkREdVdsdTFnbzlLQW1OdG9zUjBaTi8wdExCMkhScEtreWZUdkg2UU1uRzBOT1psc2FzaXlxYkxNRC80MTVyc1gzODUwODg5QnowZXNwS2lHRUlxb1l0THljZStiZEU1a3VQY2RMc1pka3lIRDRQWkRjM3JUVm8zblZ0Wm9QT2lsNmNKVmhla2xrdjB4YTk4Z1JYcGNRU3RMUzZWa2F5MVowZ3ZUMHdXOWxFVE5aS20xNWdLWExzRXF0QVJyZHR2SEFHSS9lcGkvcjE3ZmkwSy96aXA3WWRKZnJLZEFvNXVkaTNaRlVQdVdqdCtIOWFDUkNzZmlkc29JdnE4d1hTQS9kS3dkREtSZmtzVlNpeTZCNkJRWW5IZkZhUDRuck92WU5Hd0JCeEFLWXNFMmJrN0FOUXVIL0RjMjF5ZDMxTSs1TmtOK1g4VUJyV1FZdFRXcjRJU0pmSWpJWEwzdGI5d2RIZTRkVGk0M2tjdnRReXRIQlUwNE1VZVNCWGUwMFFhakJUZzhrV3U5c0h4VWdPUENnbzhwUkdsRDhMRWZvUlkwMFY2M3oyS29HMi9IeDhyRWJkNG1ta05ueVoxVzRIN1daQTZkOW5ZUVNWdHJ6RlJuQ1pwVk9VR1NvNjNWTE1OcjVPejBtZHprSXFMb0RoVGo0VnZNRnVqRHBJMmtybkIwMmNjeEJydVpHTmgyOThlK3JTR1gyQjVFQlZ3b0Y1Z1JFQk5TK3JOZCtTZTdzYllub0tuM3lDSHBUbFVMYk5NdzJuSzlvSXRwUXJHT0hjc3VaNCtOZ3YrMUxseW5NejVmUjJzYWZqaEJ6cER2MGVJUFk2MzE4YnRGSkE0SXF0aG9OaHVDS21USTd0MkIwUFh3RE5lSEFwMzZzWUlyMi9VRzVuWXFxZ05qMFJyZ0tsQ2JSMHBZVTFQaGRiR1lQWW1EZmgxdG9UQktHemhHbWdvdHZGNzd6amJ5S0hkS0lma2U4aWg3Tkx4YjBRNTV6WUJHWmtqcm9KR2lLZ3lJMHQyQnFZZmpHanlIbWlEUG9ibTgwZzR5OXFMTUh0Q1RmblIyV2JIbTBQN2s1MjcxeEIyM0txeHJXamYrOU1vM2tSYTk2VXVQZ29qalVTTjRQOXo4L3VES1NyUHA4a3RmUTA4Ulh0bUxnWFRBUXhHYzltRXJuVnozSWlYMDdEZDY5dUdsd2hhWVdrTHNybnIya0tmYmlOenFlOXJGNnU5MGxFOHNnZm5Pa29SdXIwQVpKRzlqRzBqT2NlMzhTanY3bWlWRklYeXhvaXlKWnFjdGxNZVBjQWpUbU5VZEtNWCtLckZPLzN2K2ZmUzFoeExHUTY3SEcvanJKYTd3eWNKZjdwTkQ2YU83VFZNNStvVTJSakd5VFBOYjUvZWJjWFdrN0JuTzAvcjFyZG5nZm0zYlJ3OTNjYWFITzhCOWxzZGVsWG1OY2dnZDlvd3NpUElsN294cFVNcTFTU25ZVHBEc08xZ2M1UlljalZQaU53N1ptOG4wMm9uTEdJZlpiZDBxZnJITjZvUnAvTUo1MnRVRjEzalZ4aTN6OEdoQUI1UUJYNEZHYmQxZE93ZEl4RnNFYk50V0RFTlpWZ3k2ZllRa1J4Z0NiL3lrb1ZTaDdHL2NMVW5RS1EvMmwzNkxUSi9qY0NtcTF6eEFveEs2UVcvWXU2L1ZjOUdhR3hHazNNTWRDWDBpRUhidTh5QkhiSEVNSDUvbm1tcWpSUjd5akErdy95TS85enQrRHEycCtDUmxXbHRXTmd1eE5WcExhMHR0RUgzNEl0c0kvVDYwUHBPZGpwRHhXd0J2Z29nUDgrcEpwQVZmTnMyTy9ELzViY09TaWpCU2xWVlpvZHY4dG9wYjhpalp5cnlXUlUwc1o3RkJrOVphTys5OTh4QWpLVXJXeVhHSVg0QkFuVDNoeGtVSHVXSVdKSXBzU1dReXNYSkhYcUxCMDcyK2t2T2RJaGF5QmppeGRnd0pzSk9Jb1JJdkJqUTliamltSVp5ZGF5S3JPZmN2VlY0VnFyeElHR1h4QXgxNU5CK1l3WW9nRU5adGNPY2czUVpuREI1TE00Y0pQeWNJMWFzelpHQmV6eU01bnRCa05Sd0s2Mzl3VFhWMnRuck5Keit5S0lxTG9xS0k3bmJUV0ZJVUVzQUtGakF1d0RhQmsyT1NqR3doUlJsRVErZGxybE1PUUNNU0loYk5GWHN5azJpSFNNa0x2bHJ3VEw1NWJ2SndOV1RGc1Y2a3NjREF6ZmUzMU1uRFM0Y25Uek02QVZuVnc1TkNTcW00QWNNT2F2aTNVbWxTTm5tWTBRWmNvRU9XM3gxYjcySHVVZTRUM0pQY1gvYWhvM3JzMHhyL3pYM3A1M3grOFFMMXU2UDJIV3RQNTBzdkl0czYvUklyQXhRazlXOTlycXRLRjVGcG5HL1I2WnU4L09kU2o1TmMvZDhTcDNKWmFuMTdKOFRiOE40L3B2MUg2QVpxZnVTcnFNcmdWa1NZVHdsZ0pla1FLZmVKaHdjOHJDdkVCYkFIWmp6RFdGWXZudENzRjQ0RVZWdVVOMFB4TndvcXFjelBDMnBXRmVaNUxEc2ltV3EyWkVSUkwrbUNoSjV0UFlkQXh6RkJGZ1dMTEEzd0tIZXFVUTFEQkdtSkYxVERNRVdlVjNoTkNvZENZVWtqV1Y0MGpheXVrNnBaQml6K1ExV1RQNm9vSDVVMVNjemVIckpLSlNQNnQxN0V6MjlaY0UyTFhqNGEwM1NSRnhSQkV3TUJWZVUxMFJRRlFUZE5YUkJJbGx4Y0t4Um9UWStQdkovYXFFY28vbEVvRnlyMnJKdVJRajdxR2xyTStNZ2NMcDNHYzYwVnNsNjJ1WlBGZjVmNXNORTB3cno4N3pCaWVESmlDQ3NGa2F1YlhmelVrbVFFZzJRVmxZYWdhRWpDdnUwcDllMmM0d2pUVXFUK2taTlVxU016WjBrdmRGZlpNM2gwLzN1dzh3NjFkU3lDNWdJQ1A1ZVlieTE2YU0rK1lqbWRzaVZaVkhYQ3lZVU5MWUFqQVZFaFhTUE1UTzRQWnlLVlRZblJrRVlPRGhxYUxJNU90SDY3K3VZclpZMVg4YkZmcVl1OEhramxOY1hRRkNrUXdRRlRUNXBLVUFQT1R0V0RvWVc1V2x3V0VPSUZPYVFhb3B5d3M0bndWYnYyRGU3ZUpDTTFvQ0c4ODRBVVVIaFBwL1E1WGtSZklIejdicXJCSWMrV2g2anlORklaK05WR29kVThlU3p5UUs1TkozaFQxY0dxVGpKNWF2WUNwcDA4UUJ2SzZEdWhFU3NRQzJUSEUyT2xpYXZzRUJrOFBGSlVOZCsvdVBYamdXWVY4Nm9reW1TWU52Ym53YllJZlRTa3Fnb2lWZmlRZmRWRWFTd3huaVVuV3lQNS9zVnp1Tm9ja0RDdjQveitCbGxhQXpybjJ0cy9pWUFYU25uYU1tcTJFQ3JrZlRBR0VNN2FhTk54eFZhT3k2YldQQ0lKYzdLc0VDcXpxWmx6eTRxeWpDTW1zc1E1S1VnRzkrTm14TFBqUnplUTYrYmExMlhNVk5lbFhheG85TElUMk1ZbndMOGppdWZhTjVnanV6RzgrRGFNMzBhT3g3Q3lCUlhkKzN4b2l3TGVJTDNQNEdGME1LV3NONS9VUWZVNnM5RXpvQVgzSVZyUHM0dWpCWGdJZHQwYnlMZVdhMStYYVZtNkx1MWlnSnovR1ZDMTR5RmFYM1B2YzYzM0VKMStXV0h5SERrYTdiRW5MZzJaNnhveDN4cENJRk5ZZVZZZ1V4MHVTV1dBTCswa3oyOXJodExiays5bCtJT250cWREVGR1bVJTaEpkenBwOUh0b3lZOFovaUF5YWJYV3R6dk84WEE5bHFtL1FSMmlTZ1BYakgxU2dwbW93U3N0ZTlaZDVWSTdvSjluKzFVb1F3UXZxclIzZy80aFMyVUJhckZLQlRvUEt3YXZCMVVycXVpVTZOQ1ZxS1VHd2ZyaTRja2NFSmdRenRGVTdiUmlDQ3BNNXFwZ0tBQkFWMVp3MmpIdHBKV3NVRnFrV2lGWjIzVFNXRG1UQTdkNGNpSTVuMzNQUHo3M0JDK2pQeVZyMGVXa2p6Tk1IVHpCVTdCWG1KR29kcGdCdTB5Z2VvbnBWUnUrMnRoZFhNb3pKZGRsbEJwVlVkTkRxRnBDK3dac2UyRDN3TUdEbThtMmhDTUlxUUlPUk5ISWx1aXVhRlF5a0JFVGRVbC9kK2JnUVZLTjFOSEluaGdqNVZLVTFOZ3lncUlCc3RZZ0ZNRWxjaGhocitKbXNpMWhSVXNsU2JkRk40OUM1YWlrS0dFaktpSkJlY0M3YjBaVkJDUkdqYkNpU0ZHNDZlam1LT25pWkVwVHlCVVBIbVEyVmVoK01tL3ZwbEhkWmZhV0N2VUdDeDFLT001MnpsdDEzU2lqMjFHMG5YT3BJYks2dnI0cTRiaFRMbzYvVlpSVStYNldVc2xhQTdKVExNWFM0aTF2RXZFYUZxdEQyWkQxYUFaaGNaaE1hd01aUDFlRHBYR1A0ZTdxR1QvM2xJU1hiMmJyRG5acGZzWTdnblJzRTdlZnU0WXdVcmtONUhONFhhYVhwSXRlWUw5YnFQYytob2NXNnRxZ1lEK2dqSGFTZFpsVXlvYWk0d3g0YmFscmN5SUxkU0Y1ZVo4Y1BMdE01aVVXdHlQTjdlTHU0TzdqZnBYN0FLQThFTjRZa09DcGhUeDhqTUNua3NhVFo2aGo1bXBRbndHNVAyRHdVYWQ3OTlQMGFwWHFUbU1XWlAwem5wMDlJWE54SVUrR0FiMmFhMmpQMXZWSWorQ25WMUMwVG5Ca0JKRW9xSUtzcUZGTUdPQ2dZZXd5VUVDeEZBRFpVUlJGbGMxa21CUmpLNERLaHJGYndxSWtheGdITFVrUmtTakxoSmtQR01ZbVF3NlpRU01RdHkzRkRlemVvdUtrRGZKb3hxaG9BbHhBVVd6Wk9HS1FlNzgvR2xSMVNSWVVVWkV4VmlLcWJsc0JyQUZvbnk1THY2YXBzaEJTZUt4Z1JVSThLZE5KUFZ1TUdHSERKTmUrdEMxOFd1MmI1ZGg4L2gva0hiM1RqZVBEeGljWDhhV3o2MFpqcnlEdFF2MjV4Tml4S21PNmJMYTU5R0k2WkluVmZZQmRZSlZ0dm5maGg0Sm5lcDQ4MDhrdXZvNkxYRUJpdUc0Z1hDQTZZTy8rU21mcnJRMGU2bzFOeUc2VW9FdDlnZUpIK3o0Y21tblhYdTJicFhRRzBJRVMraE9JMjRra3NoSlFTVERZa2t3ZzlMbldVa3hOSms0WHgvUW5WYXVJUHZ1a1BsWThuVWlxTWJRYUtRVjkzQzZJejV2Z2l0UTZxUUFCYmFtQlZxR2JTc2N1UmdzRXltMFVXTUJjZERJK3ZQZnl2Y054WDlUMVBqWmpaRStPYkJrNXV6QzhkNWo4RnRJMnhXVW15U213THExQ2NzOUNabVFrdy9teUFkQkRWVHdwNExxYlU1KzY2VTd6MlFra2REUUluUnJaTTN6V2I0VmRIZGs4U2dHWGgvZCswWVdTWEJ2Wk83eXYzWko5bWRHUkRGVlhMcEltdHU3eEcrYmloTEQyWEh4cnp0T0M4OS9hMVFlemQ1QTczeHR3Yjl1bjErL2RvTHY5UHFieUwrNC9hSHdVcnVGREVyQXdCREUzUk1JcHVqSk9FTUxuS2tJVVhrV0lvRmNnQ3BUWStySUorMUJzVXIwdFNkYlFKTDJXL3lWMVJSZXFQN2orekVmV1hkN0ZDRUZQc1dzVi9jaTVRSWN4cDJ1d3JFYWJXbCttQ3JXSjlzV2VXMzh4S3FNbXp3aXhvd0RIdklQSzlueTdZN1dqNjg1RHlmVlhkK09nTk1tMVFNdUIvUTViNXhSZXlpTjVwNmtSem53bmpwQ0ZRM2tydWV4YkZaS0xmSEFIb3RLbzFyTTdNQTdoQ05EaEo4Z21oTDArZkFvdHdmVWJaYjhUK3dSRWVtckR5MXl6d1kwNXIxL1gyUFVqanQreHVMdnRjSjl6TzFyUFVoRkVwZmY2cUxUaERicjZaenZ5Tzl2cHZqYmNhOU1HRi9ubWh2ZDE5WGVmNTNlZ3A3a3BHcW1MSWZYNDZqcWdFS1prRy9DTmdNdUlOUVF5NHpGS2R4SUJwenVEeTl0UWVjb05sajVGMk9NeTlWT0oyalI4d010R0tuWFpWZ0tLSUkwT0Y0YmlHQSs4clBIbWdMVmFybncrYlAvVU96U3lONDZmaUlRbGs4WVRDSS9Za1hpeXVLMElRUVcwQlZKQmsyeGxVM1F3TjZJbjllbExJbzlGUXY4c2lTZ1lVRnUvNlIvZE1hd25YNWxLYkVuUk1BT2FJS2RWY29rYXBabTh1TWthWnhHNnFjek5jN2VBZEpwNUZaUHB4YW1WeW9TTXo4dXNlOGtBS1VmWlVrUStYQm9wZmJRemxycHJjNFJIVUtIVGdGYW1XUEhzQlFGN1FJTnFmMzZDQW9ka3k0RmtNcEFBUFR3TjNKamxXVGtnTXF5UVB4cG12WW1sM2VsUkdZbElIazBUR21neUY5T2srR0FwZFYrcU5CaVh0Rmh1Y20wd3BnL0cxSjNwUkNLZFpmYkt0Nms4RktJVkJ1NndzaFVDdUtzU0xnNE1GTEUwV0pnT1djSlFQRlVzcHVKRGdoV2FMbkJ1bjNoeENTTGNHTGVIdTQ1N0E4YzVJTE54UWFjeGt2TVJwekdKb0dNR0lVSUlRRjdPMXN1TjJWSUJCbDdEUFNDekE1UElPeERrKzVkTGJGQjFIWmprUy9sYnJzTVkzVWtHTE5tMmZoWGJYNWk2WnVxY2tSUjVJU0pKb3VPSWtoUVJlREZwSU9VR0pjenpmSUF3T0x4bDhZVHZDWkRkc0lMRXB6WTZnQjdkNk1qOGRlU1c1TDRZdHVTKzZBWnkzMHhjeEVJNEtZcThZZkNpbUF3TFdJd0xvYUFnb1VCSTRKR2lJRjRJQlpBa0JBV2hiK2svV1R5NWxSSG1CVVNvRDRFUGsrc2czdUtaSG83cTlvQ0cya2U5SUxwMGpMMU1DYVpaR28reFRSVEZjRHVLUjMyR3ptWWZma1RDMGVEeFlCU2pxOWxXSWlVZmxuQWl0c05KMEIyRUtrTmJONzFwODVhaE1wbUJzNFFUQzBhandVVUpHMTRHa3dNejQ2bDRQRFZPOFR6Q1NYVmg4MncyazhuT2JsN1FzbnBiNXJmR3JhMkwxZUFVV0p5RzlSQ3owTUlsRnF2aEFJM1RZRU04T0ZOcmFxYWxtV2t2U3NOSlJVbmJKeWhJSm9WN1BtSDd1RGdNWnpNR0dGb084NG56cFFzTWxpSGY4Qno1UHBZY25yWWMxMWJkc2FaMzRXU0FHY3JNbGpZdEpJYW1zc3c0UFRzMWxGaFkwcDVuOWpFZTVvQjduNDN1MHVmaWZhL0srZlRlRk8wbkd1dXVFYVdDc0hvczVOczhrOHRqWHliQ1lIVFdZcUloeHJKdDBJL2hrUXdZVmc3TlNMTDByby9uSkNuM2NSblYyZ2dnSnpJajVNak1FS25reW1tK1IyVmhSYkRHZ0tpTHVUNFdzbFRxNXI4alFtTVdvcjUvdlk4YTl0d1UxbHEvQm05amxaSlg5Mmw0U21qOUc4MnZyaTdTWFlIVVFYZVFPdWpvRkJQbHVCaVRVNExXK3E5N0lIL1B5V29WZGdXM2d1c3YrSFd5NW56WTVTVW9hZ0U0OVFEdkRtSVlEQ2h4SWVySFJXWGFFRmthOW1IWmdYMitpZVVWdzZISlg1dzBZb29NeWIrdXlOZ3hJRUVuV3FleExqUmxNNEFXV2FiUmxNd0FLVFVFeUpCU1kyZFQwSEhyZE1DVUlZTVdBNzZ1SE9iRk5XcXJkWWpwWWNtVVJhVldQbHhpdzRzakpYVDZMVUcxTXZYUFpBU3pqRE44cmVjRWRPU1FJa3VoYW1IRWU4ZXhxWkJBT04wdnVnSDNkckhqQXpreWs5Q2lURTZzYkN1V29hSWxrb3BvTFNpRnBtTHVFQ2lQRktxV2lLVkRFbTZkWmFONUJZNkhoVnlHNHNlUXl3eHR6bmRWWkhLd241Qm5PNHV1WkpqcHhYS3BDeWVpQU9QZjVETThpT3M3TEdxanpMaWpMTG1zckkyK1BpY0Y0MHpocEE2azkrOXYySFpqLy83MGdKcW1oZkdnTkNlS3JYK0wwNlo5c1NITFNwd2hnMVF5S1ZxVm5KREtWRmhaWEpGbE1FWGE0ZEJIWWUwODl6VlVSRTl5VmJEWGFaUTZnUHQ2N0hMYXN3OHN4QmwrRzEvQ1hqUC8zODQ3TkVSTjdOK1FCZGJNcnd5b1NkcjZoRW1hSTh6SlpvTHVKanVlOEpmOEpycDRQdmVqKzFrYjNSSFR4b3RlUDNZOG5LTlk5eUJDcjZjdlAyUlMyR2NoR080WUpXRlRWQ0ZFaFJrT1NVSDhIWGUwd0xzbVI4Z0JsUnpwR0JTMFVOQ2dPbmxTR0Ixci9selhibThhWnFhTlJuamZ0aTEyTk9sd2Iwc09kelJnMFZwM1g4bVgyd1c0RUoyakxpRnpiUzdVTWV3Z25vMUVJeU9GR09xSGErMG1YUVFrL2hKcVp0UDJLcUcxbGxaV1VETnRXNWFkYmpXcE5adUZzaXF1VWdNSWNOdG9aN05vcVVxNXlHeTJDa1p1YUNuZCtoeXpmanU1cmpKa09hNHZqdHJpenc5SGpid08rcm1WWGhxQzJqdFdJZGdSSkM4Rk8rMk1SZjc1dHRNNXNwYnNvckhTWmhpMlBxTjdXWWpvTXFOOXdXK0wwcjFPZE1QMW4zeXJoRXZ3akVkUk5oWEhKY2wxSVJSRHpsNG5KQ0lzVm1TTXBCS09wN1pQTVZOaCt0R3g3TlIyZDNaN1BqZHZ5OWxKU1pIRlNOQzJneEZSVnFUSnJHelA1Mm9IOVptT1V4ZzBtWDZ3eGtab0o4WXJ4Sk51Y0FlNDY3blhjVy9sZnBQN1JEc21tQmVQcXlNSVE3M1daZmJ6MHNxSzRCUFlNM1FiLzQweXNHZnlVRHlYUkQ0czhpTWp2QmdHVzVBTDUxdVpGMUVaOGwxYTQ0T0VvSlY1c1NyeXNuampSZVF0bXZLc1pPbmlkdHEwMzNIeXZtcHVsRlFUNFQ0b0xSTjhCeEh0ZXBHNXVBZ2RwbHZ0bk9jbVRyZ3p0d3dkTCsyczdJWlJRME5WN0s3c0xGR0xzR3hqUnlOSGMyL1p0QWw2d2szbkQ4M05IWnFIL1BmR1J2Wk55aE5rR2FGcmlZUW41TWw5STlRdWZEUTdsOHMyY3BBUFphbi9Ca3NyYy9PVkQxVG01eXFlVDRmZzQrVHBoQmU3bktMVCtzOVRwc1FoSGtRK3B4K2xsdm1PekJoU2oyRWdISG9mWEtSWmI3VkJIeG1uejdFd1Y0a1BtNTk0VDJzekM5UDhudmxLTkJKTzdXaGs2ZUh1YmlobDc2QzFQalJPd3p5TkJUOVJtWXRGUHZFRDlDY3NzUE43cGl2emFzakt6V1ZINmZIZXJwQmlkOUNLL3J0OEZhR3JkUEJiYkhoeVBUSWR1QjQ5SnJxWUI5ckdVMzZDcVN0LzJ2V0sxci9DdFZVQTNZUmtxZXQxckcrcCs5SllPeGxtbkFGeDBidDBzRUxiZ0ozS3V6dFZybjlHSlZ2VWRMeFR1OW82NjVxWGs0UmUyL01GcGRHZ08yTWZ0TjNaaFI3UEVINUVscGZYTzRqU2tPWXRpb2YrYktlTEtNMmM0enJ2UzMwakVkWGZRdlJEQnBza016MFA4eTRFVC9sSXozMGg3UHVKWU9SaDIzeWJTWDZSa3hFejFiNG5HdWsrUkRLdGIzZmN0QWViYkhDOWhTZnE3YzVPUzg3VzR4MGQybVc2MlhxaDh5NnUvSTA3QjNMNVl1OFRuR29idzc3RjFDNkY3YVZhbTg1SFRlcEhFcWZ5NTBJYk9yYkxDNlBSdlM1RWtlVk51K2tIbUVQNVRXMGRYN2Q3U011VjBOeE9uMkt1dzYvQXZ6ZmpmM3J2M2MvbnNYOFRqcml1bmd2VWlIV0RabXp4M1JvV09sdkNkN1hqZ3Ezb2Y5Y05iOVY5L2ZoNWVuaDlqL2J2eHJiL0N0aVRCVG1iUzNCNU1xTEhxS1YzRC9JZGpJTm9wQkNkbnBVOGNCeUgzTDhXS3BDQklaMVBYY3F2bU5yUHFMY1ZUL2pWbjUwdHBwck5WQkZWR2YxeEpsVnNOb3VwMXFmMElCSkVoVkFmYWt4MlZabzZXZ0Q3TG1ZQ1pyYituVlJGWExONEN6UEVpQmRUZ0l0NSszcVZKS01wK3p6WGkzdXFpMnI0eFRUUmw0YzhSM1VsbkVRUndyQk1aU0tRTFh2TUFrcHRQajRrS2NyV3VjYXV4aVFXRkNlKzUrNDllKzV1VG8vTFFWNlBPemR2bmIwdUtWbThTTjFHUGZ3bTREMHVKV3Y2YXlrR1FJYzVjNUNHeGZKbWZZZXdvWFNYRGhvSGw3REpVNUQyYVdyWFZ5NlI1YzBOejhsd2Nha1FHakEvU0gwVDVXUXdPbk04Y1RVQW5STEdrRWN4TzNjNWRNRzRqa3VraE9JWDdyVGZHNHdteWcwZGdqQm5MY09PNXVaeUNPVzNGTWIyNkVlMElFSUQ2VUEwbnQrOFowdStzS2wxTGFFcGM3SThqRTN6c0ZwQnQrZW5ZOU5DUURKbFFaaFNsSHlWNTBjUkI3RjBzcHFwakpRTUZWdUUxNGhvdW1tYkNUTGlVWDQrVjloYW1CMEpha003bldpNE5wRGZWTWh2MmJPcGNBYjh0UTRZOFZpU3IrYXp6dVhraWlxNThtRitPajg0eXQ3TDU5RnU5QVZBamkwVzNHREZBRzVPeDRpRFlqS2F1SFZPQUxHOUtkU3ZWbUl4QlEwbzZodE9ZRk9Ja2VMN1g2WnFCdm85UTFWYVgxTWNINnYvQ3hUdFZnSTVpNGVxc1JVVm8xNmV6dGRmYVozUmpGaVNEaFZrdVpra2VuSkpER210SDZxbG1WSXArYTBybjJZWnRHUkYvRFVnUjlZQTRKUTR4RFJ1bEZ2dzFuWHdUZlZtZ2l4bElMZFBVZHA5YXJzTGdvc3N5bk9XQ1lIUFl1N3FCd2RjcmhLNzlzWVFVMzZnMTU5dHZmTTVsZmdUd3J6UkkzbXQ5ZXlYTDNRODE3MTQ4UlVJSzFJQmpEcjBySjAyVzdJZ1dkSjNXR3RKOHIvODNOLzJLWk5ZS0dFYXh4ajhPUld3RTNWeVpQYWIwOHpXYVVsNDRRVUI3RVVWZjNMMWtxVU5DbjEva3JhL0pQVC9UbXJ6VkdBd1N0MWRVL2FqN2w2RWcvMjZRRE9MaStTbEwvcCtsQjltcU8rMzlnL1JJUW1uM1FSUnA4Yk8xVDNPRU45YlovcUc3RGdKVzR0NW1yTjE5SnZVRmdic1Q2OEIzOVl1ODRGY2x6aTlHNllsRiswa0s0czlBSGUrZTJPTk1iSGtDYy9hbnVtMUY2L0k5a3I4Q0VZMkhEc0Z1Vk1zeEE3WkxHZ21lTHcyczcxbnRkWjZTOTdodXplK0hESXpwcmJnKzZOOGsrSW1Oc0I2K255NHFybXVCK25tbFJyZHZWUG9QbHFJbnFkL21pSS9RNzBNcURNNnlhSnNiOG1hbHpsT1JjQk56VHl4dnZLS1gzdmQ2VjVCMDYrOFFLOUN2b2FGM3NxY2gzdkZhRnJPTXg5bmtHYWsyUXoyckl4dTdhSlJneWRNRXozV1JkVGFEMGRNS3BlNnNDOWNyODlOcnk5Y3ovR3lLMEFEbnEzVEYrN01XUTg1OXpNZG5uQi81cGQrNGFYNHdiMnN5dytPOS9uSkNIaWFGMk1VSDdWY3FydGFvMFlHUmZLdVZXYlVkZk9lcGNHUlRQNlNiYnVIY2xvNUtvWUdFeFZqN08rajRjcVdUYUY0c0Y0Y2pDZnlnM09Cd1N0VWJjdnVxZkc5ZUVBZkRRZFJjZ2k5d2hxcTE2eDRPbG9razBlOStxcGtLZVhqc1R4RiszUVh0NDloVkhmM1VhN1grcWU3UzlzeTNRN0RES2xRcnpua2I5SHZNYlJ2MVVOTitoZkkvSXp1VW5nV3pGTXJvV3JyN09vcSthMjVrTVZuZlpTbDFTNnc0MlpIRnY1eEZKT2ZQZ2ZFbXBqanRrQVUyWWJmR0JkVEZWb292WWltbit5R1Y3Mm9Sak40MWJNWGFxNlBCL2NuOEYyb1NJNE5vdUpzREF2TTBNT2hCa3NsOVBYV2xNbWJ0NkpCVVJHK0g0emk3Vy9Xb3Z3Q24wQi8xUG9CenNoalB4T3cyUHI3UlNPZ1hqWWpHVG82SFF6UmEvLzQzQlBvQzRSV21PTTRad0pSdktnTUR4U0l1OFA4WnozN1dkY1V4QU9vb1VkS28yazdPdkJYc2MyYnhvTEIyS2RqelZFVWUxZ0tTSTRrblJRUVZvVlBCd2Nxd1M4bmF3dUpqN0hpancwY09oZ2VXRHcwOE5XWVpZMXQzaHo3cklQR3Q4ZmVKU0lwUm1xOFM5U3grSVExa2dsK0pYV2duand0MGRMVEdUdnEyazU4a3N5YmVjcDlzRWdLVWQ5ZXBkTnloZXBtSHZuMjJQNngwZjNNbkNoTFU3QUlRYXVqbDF5OWY1VEY4VDdhWXNGZGo5TEQ3dnI2RkoySHN0dzA5WUZteTJVSnJQN3pNdmE1bnJhdTFBZlk5enk1L1dDQkt6bm5oS2tkVmpMNWpISVk3bk04eTViU3A0OVRwRUpRamQ2NUpHdDRKMGFLa3lPTFN6QVVDakowQ0hRUFd6dGZZQUVIQ1QxQ1dseVNsMGhkdGxhMjVScGp2WktOQzREd2RFbzZyaUJEazQ1UHJDNjNzMTFDajhjN3Z5ODNjZGV4ZjZTeGhpaS82UlE2V0ZyQzV4UjdBcmkwY2RxUXU0VmtzTk9LdHRyT3BqdjFDeVkzUXI3VmcrQU4yTWdUcm1VR3ZFMHlvRXFYbUFVcmhML0pVdytPUXA2eU5IQzRuQzh6UU53YTdJR3RLd1NlZEkxbFhZOFd4MmJDYjNaTzdFcEN1enVHT1VsVHROczJCMHhMSzZyQnBLV1Z0WEJ3Ym41NGRHRjBlUDRuVGlSc20xWTZIZ21SelRZN0ZJbW5MZE1PUnh5eWVkNEpSeWROZzZWM1djSEpjU3NTZ2pSOGEwSlRSQ0VBcTE1QUVFZnpoMU9aVE9yeVo4akJXQ3Jxa0UwMGJjY1hvcFBCa0JOTnhjZ21idThqR3l0c2paT2RDSlhqbjJ1ZCt6elBVUjY4VERYQ1hUSEl1NE52T0tCSjI0NUFYUGkvSjBSTmVJMG9UcGdWYzR0NTh3ZXhqUjlpUXIvWEJMNGJRSlp4SndxS2FIcENGRjhqYUtRV3FWUzU0b09ZVktKaXhkZVkzNzNUc0ZDQVZOSzZmSDJCUmw5bnB5M1ErL0xNbktrWGk3UkxMUFNwRXpKU3BVMXY1ZmtHTDcwcUF3RThhSlozZXN5ckowN01nKy9vQ1hLb3dlc1pUT3BCanRTek8vb2t3R0o4Z0swTFlhRGd5YWZYM1g2YzlFTHIrLzdUUEVNZTFQUWZHeDJEYmV2N1hvL0V0cGhtdStmbyt0SHUvd0V5S3FmV3Y0TXlNNGh4cmJtdzYxVkFnMWJoV2hTWEc3V2V0L0d0MW85amZOajRCU1RUWm54WUZOOHJHZ29rbFdvemF3ejF2SlowNjhlL1lJVDVHS2tPRi9tQmFKQ3FDaVNMUTBhMkNUeDVaeHVITHRSQzRXSWE5Y3hGdEtUMU9Mcy9vMWQya2prMFNiRWZmZnhtOGs1Z0NtS2cxT0E5VmN4M1JvK3JoMEJWV2VJM1QrMHJwcmJ1emx1cFFjSTV5WmNlT25iWlZFRTErWi85ME1tRlRScm53UXpudmo2WERVbUd4QXVTenF2S2oyUU5DZVZ4WGNHOEh2cEd6ckhTY3V0T1lDelFyOHBweThseDFDLzdwMlJ1L3dMRjFJcVNOV1NVYXFEWmpNbG16NFkvcFhkNTFQc0FMaUJ4WUlDdkRUUzduSm5KWkdhMlFKSmhWdGcvV0ZjeWxEVk5wZlZPYk9STlUwWEwrS3g3bUNTdXJmYjZFclNXTkFqM21UVFFHWTJPYmFDTG4rWkNOSjZiUS9FQndlY0tEQ3NHV2VCSzBta3Uva1lNVFB4Y3pZTGp1YjE4WisvY1cvWW9Kb3J6NEJrVmxLZUN2eitieVdqcWNjVWl6SmdvYjdFSFc5OWwzem42RTdhOWZHK3gzRkVCUjdkZnVuaFY1eVhHaWlqRzVvL1dacmJ0bGc5WCs4cUgyKzJHUUN3TTVIQVFlVzVGM1FMakp5U0ZEeUpKMml1cDR1RFFmS2dvQ255RzE2UWRFcTZVZHU3cUVTSVRSbTJIcEpFS2dsZ016UThOaWlvNVVVSkJYcEVPN2RwWnFsQU1sbk0vT1Bja2VwQzgveXhYSXh6bU1XWVpSSjBwQmltV0xuZzFrWTRqdzhBRlZ5NUZ5RnppeG5LWVpSQWlNVUp1eSs0SDFRRDRXdnBaNFk1Nk0yN0ZHNXF4V016WlRnWnBVeGFGTEsvSmM4SGduS3p4V2RLblRjbDRwNm9LdWlUelBPbFVrc2lTZm4zR3RqT0NMa3FpVUN3S1pLT1BwbEprWHhZUXhBeEJnaXpxbTV0WEh6bHlOZUhneElwZ3lJY2xXUjY3ZGxTV3BjT3lJVlJFSHExYWVVdENvc3dyWWpBb0tyd3NvcXVHamg0ZGdwQW9takQrK25HU3lzSlU0V2dCaEphQ0tpUjNKc0dWUTJTaWQ0aVZTdWFPcDBrZmdaK2NPNmpJeXVyYmtJSzh6aDExNk4vOElaSjYrZVlwT1lpWHlhUEVrYW5jZC91cnRtM1gwTy80QTJiVHNkUVcwZ3RWd1ZLT3E5cjJiYSs2L1Q3RnhmajRPcitiMEJBV0YrZEtFS01sd2xCT1BjWGZCSEpjbzNtSEx2SFVobVdtM0tEaHllaTAzZ0JmMDQ2dk1RenVGTzhRc0JBem5NWWxCOEJSUHcwYi9xOEZ6RHVHazBhcnBQSlplZ0xkbktXeGpDN25oY0VEbHpSSUJSNEwzMDQ1Um94YzRzc0NGS1lwSGM1d1puYlFtSHMrcDhNRW12RForVG1iQ1N5bkFXZkp5L24xRzlRK0REMTdiemtJUW9HcFFSSFB5d3FmcTQ1VUJEeENQbDRyRXJISS9EeUNoY3BJTmNjcjhqd1dCNmVnYnJCODcraldyUzhzVU9IQ0psbVZQOFBMTzJWVnVrS1A2MWRJS3Nuem55R2xtK2h4Z0NGeStRZlc3Z3B0dDl0R1ArTzNyNk9oMEx6bDQ2SzhpYlFtZjBkQmxFZEpKaG9sZFVkbHNYQkhubVEyeWVMeFpXak0wOUFNMGhicDFsdEpDemJCL1orR08zZnEzZUs5K0lYdU9rRE4xam9vMGFuVFJqeHVuRGE2YU0vbmI4R21lY1kwOFcwNDdjcXgvd2o5TVJtZlpQQ01JeStNWHFNSXJucW5XcXRtUHU2UTJXL0owdlh2bkZHbGhOMWFDaWRsOVl5YXpYYkVXc2RjZ1J1bDJHbFVhK25rT2d3ZG5HaXREZ1BQQXhGMVVjZ1JGMGxHcXN4WHhicWswV3hjQWhHQWZrZ0tVWFVaTElDWExjcTVaVGNkMVcrNlNUKzZLVXQzTFhhc3F6LzY0amxlUUVMWDJVK1hZZWtZVlpjZGcxSGhaN3U2N1h1OVIybVc2OUpaYnQ1WVo0bjd3U3gyMjRIVU45QmpxdjFidDE2bitia05tdGlsMzl5OG9YNXpzQzhVWkU4YisrZzh5eHYwM25yOTUxZk8wNGVkTVpwNmtXNHU1blYyTG5Vekc3U29hNFg3YWYvR0lMOHRCZkkyNnhmdUVzQTNmRHRWbTc0ZDJFby8rOTUxSlpDbDgvT1RGUC9USUhQenRkd3JDQmtsczNoSDA3QnFsMm1RSTZEbFlNK21mck0wSGlsUFExemFNUnFMbEV6WUVhb21vTzYyNVZJWmZIRmR1R0JLRjhiWWdnSzBsdXRDaDNSNWZ3RGpGWXp2TWkzRTE0dXBpZFFBTDVpRS91S2RPRUtsN2FYSzdrbzh4c3NJbThLT3JhL2NVc2pQQzJCckx3eU5WQmV2UDF3bEpJcUlaR0V1UDdUbGxWdVp3Zkt3VTYyTU8yTmp6bmpsRTJZcFdxenpLREdlcWd3UVhrSUxDb2lQem1XTHpSSzUrSzVLcG1IelNBaHF2SVFLNVB5ZGpUcmdzaVFpQWg4L2VBeWNrcTg3R0xkVGhKTkwxUnM3eWQxWG1ka3pyS0dLSHk4NXpCVzVPZTUyN2k3dWZ1N3QzUHRvVkpBOEtMRUFnN0UrVTZZcXJQVkYwZlZGRXBOYWdqMHRWZHF4VFFNaTNkVTl2MndXYW1xS2JjQkV5YmRaQTYrSERJc0w1TWQ2S1hkZG45cHhBV3c2a2pReXI0bFNJTExTdGRlMWc3S2xaR3NsVVU3SDg4R1lIUnNLaEV0OE1kMndpa2xKMEFySjBrQWdXVXJweVZMckJBUERlM2FOVURTaDJXMnpJVUdNdUVWZGwxNkZXVklTeWR5cVNTZ1NPTS9leDVPbDhuUk93dktRRlI5UURDVmgxaXpWTHUyTTVVS1JnR2FXa29VQit2Y2d3K2w3Z3lyR1U2bTRxQzZ4ZmNlL1VESVM4WFgzSzY1T2UvemljS3MyUUp2ODhNVkFUSzVzREN6WjlnM2F4dnk0d1lLM016YmVkQnNJaFNwc096L3hIdkVrbWhtWDhKc29hdWVSZkNNRHFIUUNFc1BSd1d5bE9VU3RmOUxVcWc2Q0xZS0NxZmFMRE04Mm5pTWpYQmdpL0Z4QURXUTNEZTMwc0cycGF1TzQ1TWw5QUg5c2pTdFRwQzhZZnRUYWgwcGVLT21NZlRVdWVNNHdRaC8zdW1DZnJNN3RldTFiNzl3MVYxV2praVdLT0RzMGZ0bkxENDRQWmJFb1dsTDBlaXFTb3dsNmUvNjJyYkFDdm5iMzFsc0xzcVNtbGJBVTN6czhmbkI4L09CRWVWOWNDaXRwVlhxV2l0UWdhZHRsTUpsMXdrTVc3ZW9rN3pWZlZOUjZEejJXWXJXMmZpOFNRRndnc25IYytyVjJPSm9XRGFDSWxrNzFWWUoxNE5yUy9td0gwSW4yeS9sdEx2WThUYll6VGlKTHZUYWloWTZtSTQ3cTNKcWRLV3ZmU3J2SkhtYmxHcFVqRkNrNjhXYUdBMDRXNFVLdWQzM3Bpa0lLbUdiRk9wUE10Z1BYb2pNVzNvUzExbmMxMDdMVFZCOEc3Wm1SY1BwbVFLZzV4NUV1cTFTWmZCUnhkMmlrdHFtZFN0c1BTSmpLYW85ajZRRTdmWTViV2xtdGFPYlNBaE9QTWhzRXBwc1ljbU5IcytiVnUrV1BYVXF3Q1ZTc1VWTTZoeEs4bzhqRisvUUdhTVR6UU9FdGdEUHNDTkhBTTl5MXpFenJtdnZTb2kxT3gzNEJqcnlDNW0xZStoWFM4NmxrQ1pUbVoxVjg4dm0yaXpQVEJnRHZzZEpRMVp2R1ZGT0ZiVVdrNytBY0I2Zk1sRnliQU9wSGV3dkVGMnZEN3dEUURxWjQrbVRxZDJNTjVoa21Hc1BlSVJQRFZJZ0pWOGk4N2dKM3pOTDFBR1NqVUxFeFd5dFRwcGNLUlNrWU1Lbko0MkJRTlRYeWpkc3lZVHNWWlhCb2NEU1JrWVNJSUJkbUl6WVdOSmtYajQ2TnBYUHBzcE9XQk1VUWxhSFpna3dxU0dQSjdRVXlRU09FMWFpdTR6ZzJ6T1NBYVQwcWk2b3NDS2xZT1pWTDZ3RlprWEhhME9XNFlnVGdjTktDTzRxS1BDYndXdXYzSlJraFJZdkxpcWlacW1tbEJnWVNwa0d1cGV1RG9xQ0lrVmdrR1l5NDdRbmIxUGFYMFQwc3ZpOTR2VG1FQmlvRFhWK3YxUXRPTFZwb0VGSWVreWtVdWZ0Z3N3dStNV1Jvd24vQ3hVVUxhMnZOWnBNbXJSVzZRVXZacFd4enFabk5rdDlaVWtLS1YrQWd5YTFrbDlheUsxbVhsL0F3R04xNFh4M1c0bVg2MHFpL0N3djBSZEVaZ3NDeGR0Zy91bUJLWFZSUGg0bjQ5eXNEcWFqQWl3WENzRnVxR1E0TnFIS0lUMmhoU2dFcWtwblVJL25aUWlTVktxVlNIYmJoTjRXQ1dUTGZKOGw4SDhGYXhOUVZTVU9tSGttS3pBUlBGaFhMaUdiVGs2a1g0TXhTeXBzcjIvaU5DMzN3ZzMzN3ViYTYyZ1YrOGhDb1BmbEh3L1VZWlFPM0c5Q1J0VFpLSHlHc0pmaVFyQTZFd3FacWtZY3NpTHdRVFExVTByUDVpSjQwSmFWSHhuTW5hKzR2SVhnT01SblJUYVJKaW01R05Cd2haRjlTVU1Wc01KU2FUR2VqaHFXSXN1L2ZobjZCMmh4dkFkbEN6NHR4enZObTZFY0VacUx1eS9uelRhUGxyQ3dvbzBwRWpnVWpxVVRVQ2FncHZtUWxUVzFCSTZNMW1neEVEVE9WT0Z3ZnFGUTJWU3BvTFI0Yko1Vno1S1NrRmpETldOQlFneWhxcFNzYVRHaXlyc2xHVUF0RkU3bVJZbjY0OWREdy9ERDVlZStEeldtRFpPNGxhMWZSY1RXOHNBRlBTeUFFZ3NpRDRCcjBzVkVLRVNxcG9hSWJwd0dHVWlSQjZDcEJVclJBYUhpaU9GTWN6Z21DZEwwZ2kxc1NBOUZNZkNBYURmMUhmbUppMThSRS9tR0lmdmxjWGpTRXhOVVFGeVAvbk1UL3k2dER0cDJPcGJJYTVubkVCMjE3V2NRb3R0OEphWXBJK0xTM3VxalVPeElTTHo0MlNvanUyVmNEL00zb1kyS2dqU3NHbUk0SjRKZmMvcVhyR1ptVE9xd1dKSi9ZbVhFQmE3RDdYcXJUUzNwRXhjY1hZRENzMkdtMFNER1BGNDVqTmFJdlRWZlQxc3FyOXV4TENxYVJ4d0crZEN1dGxHWjFieTN4QVp3M1RDRzViOCtyeUQ1dHp6OVF2Ukp0anp0U0tXWFhtTzIwdjJnSHI3SmRrQnhvT0VOZTYyMVI2M1JQaTlEeWkyaVNxNWYrSmZSblpHWURIUFE1a1BVeWc4YlpScEdDUGtKbmxDa2VHUVQrTXBFRWhGVlp4ck91OGwrbTBXSUlpWC9mL0J2bGdGQVVlWm5YaGhaTGtsbE1qRStNMXl5dE1UTDltdXRueGMydEozbGVsdVZBSU5hYUdpOE5KRlJyc2o1OGVLdGhUYjVpOFFweTJvd1VFRzlKcEpESWk2SG1sa3RHRG1VS1R2clNtMjRZNFhtTWpYZ0lJenNSSGNvTVRHOHY3eWhPYjIvYjdvQXZiSlRNd3J0Y3lZTE1hQ2R3amFKQjlSeXk2RGJhaTJ3M1hNRUFEUXJjdGxyWmp0Q1BNRjdFdHJsWkV2Zlc2MW5UeHEyYmp0VHJlMFhwTldCWjlVWlNzT2pYK0RvbGRsOURNaS9EVUU1b0NmSEFwbmxDS2VCWHptODZJTklwQi9ZVy9jUGZvMlhpOXp5L2Z4Y2JmRDJlWlNkWVVDY09veGNEZ1BFUFhMVGpIT0RXT3F0YTlHVEdDUGozVzZIMm9SUS9zY3Y2YlBGbmxLc0ErTDUwdHUwWFFuMHRmM0x1andoUCtxZGtsR3pqcmlPakJHTFlneEZsaDcwVDBOdXVETnFCVVVUbk96WmZzSGhKZmdrTncrVUduZ0V4VUowWnVNQlJvT2Eyb2Mvd1liVlN3MkxZb0U3RU0wTjF3NjROcTRKK2gyeWdlNGNyTktmekNZRlVHd2x2M3g0T2t4VXJMNmxrZitpYktVRVQ4MlJTVDhINVM2VFhKWWwwL2hLNXhoTmFRRTRjMWh5TE1oYVRld1lQSjZXb2tDREQ2NUtkWHU0T3FMT1RURTREQTZMR3gzaGVIQWorMjVqSTgxRnkyVEZ5YmxWWGxFWFJGQmNWUmE5TzdxSHZncTNKWUlNOVRaNTl0ajIzekFESDdOa01UTHQ4Q256V0JiWnFJMjdxYUg2SURDVlRlNUFNa2hGbmM1WndGdU9YVFF6T093Q21Mb2k1cXlicElvc2VIOG9OWVZxTkRNQ1JhSHo4NE1zdkc0OUdCVVJxNlVJbVQ5ZGhWMWI1RFBVOXJidlcwazUzRTVpQzBHOENtUW1kY3JlSEJQckJKQm1naFJ2bjZKMTNUVjZWSTFPeXFJck9saHhEUmh1L0xINkw3SUpTb1RVc1h6NDhzZXZPdDc1MlZ6NURtcElYaGFoRG9kZEdDTE1uVGJyVzVONzN5bnplTUdmRExGaTBtWE9UMDBuSDRCS2dRdFJueWwyTUd4a1pEdVBnQnRJWkoycCtyVTJ6L0FyV2syUTVTODN1VXdsQjZXaG1jZ3liY2RQOC9zQ2MwV3lUS0w4YnNLdDZ4Umx4NHFaR09lR0ZLd0p4U3NkL2xmVFhSN2s4b2FodUJNa2ZnMm9BZVlpbnYzVGpLbmc2RnNtMXVPaWVScWlvaWRrSmwwdk8rWXpEMGIrSHgvYVBmYUE5a3p4YW1WY0ZYdGJWZU92b2ZPWFI5b0VQa0hwaE9hN3FNaStvSCtvTGdLVVBWY1lXUmlmMTloeFRiVlRJSUF0S2hpb2VxVFNxN2RsSG54eGRHS3NNYWFKcVNFRnNPLzJNeU9FZC9TOHlKLzBoV1E4T2MzY3dHbk1VMU5zdUd2OU0yeEtuczArY21GU2l2R3dmMEpMQjd0NXBuTmR3bmh2ZFAvcXBBbFB2SGFPOVFMSks3Rk9WT1VYZ3BZQVNsME90QldXdThxbVlRdXVRbmpyRzlJZUZUNUZUUTRUV0QwajhJLzM2Q25BeXNqZ0tkYTlsWjhJRjdMbEtOTXk2Uzg5ZkZvNVc1bXgyUGJqMXRWQW5pclBrekZKZXB4M0g5N1c5NTd2RzBjOXBGTDNFZ2ZMZkdCT1VUbW0vLy84TGI3LzNCZnN2YjkwTDdsT24vWUo3M3FYM250YTl5ejUxT3Q0bGUyL2Y0RUgrQlQ2NFhBU2t5Z01vNWtIYk1SVnNHVjRtUEQwR2pObXRpT3BmZ1llQzV6dHhXb2tFYnFzM0UwNEJCMVVoblVrZENVU1UwOG85VVA1cUdqR1M3Q0grRWN3SHRDdVUwdml4c2JIaGhDUVl5aldqWmUySUZ1RHhJemcyUUE5YjExa3o1TTh0ODJ6eHZrSHRrd2Y3dDY3VTBUd0Zidm0yWFVmY3BzU1MxZEhMTysrK3lCZkdYdVhkZmQvaGtJV09lcmRpUUxXdklyVElBUFhsajdtb0Q0VjgrNTI3TWlIQ3o0T1lBK1F4SUhsbmNzQTJNaFU2b2FxQjFzODBzMk9VYWRVL2x6VmVQRk0xdGRiUEFtcEk1RFg1enp1T04xWEgxSjVwRCtkVkxPbU5aelRUQ2VzU1htMlhNN3IrcC95YjBRUHNPK3RHaHEwWFdIaGxScGE0MExBU3lESDdRQjE1MkpQa1ErUHZ2b1cwNHhZMlBpcWZVeFVMbzREMkE4MnMwTkhUZWw1UlA4ZXl1TE9pU2FvRUVENStNOFkzc3hFNitpbHMwZVg4RzZOMDhNYndwMWdHZDlUNUJsM0RPUzgyRE9DY001OERyaWlBTzdRcjlLMkRUeU1XWk5yS1BKa3BHWDhBa3M0Qy9mYUtEYy9TanFIUVUxdTRSdHY2am0rOFRURHdFbytsdEFUMm9JYndOdFhVdmdKQW1GaGNKTnlVUmo3WHIyaG02MGtCUzJTdEZrQURMT1BkdXdtalQ2Z3VTSnRvV2xZaWtxSklFVVZ1L1VVa3FwbUtkRnlTWlpJb3BoWjlJUXY1TEttd29rZ0xrRitRRkJmdkdIUVJFMVJXNjhxT3NkeU9LY3NZWW9xMEhXV1lIRnNaVjE5dVIrdEZQK0sxV0N5UVhHaU1sNCtiamp3bG00SHJOWVhuaGFhZ2kyYmNNVzRNbUZzR2l3amR3UXhmME1kQmM0S0ttYTJtY1pQaHhDeFJKMVVKLzZCZkh6Q2xhZGt4ajVjblpoY1NadXdOek9yRmxUZTJaUkFUZE81ZWIwUENHZ1FPSFBVSnZ1d1N6aG5lV1ZjR0h3UXA3YllxK1JKcjN0c0xJaGFHZDVZbEdVdXp4K1lFZkJNVTdMNXpGeFJjdm0vUEZRTHVOVEJoelpTbDhzNWhnWkJrcFByY3NWa0p5OUt1TzNlN0JTTWpEMTFPeUN1Z1k3NUo0L3NxWkNZRFRzNURpblNnZFV4b0N5Mm1SRlNESWV5NnhWU1E1eDVaS2RaTHBYcnh0SGhvNVZLc3FYTGoybm1SR21lZUZEZHZXcnJwZFZCMi9lTEJhcFdWWnBOUXU3ai8wcFZEckVDY3Y3WWhxeHArM1kwM3pHOXhpNnJWZzR2WGs4SzJQK2NLYVdlVnRwSUpRcnNsdStlQkFLQ09GUEI5L0VmejhPSG1oeVRNT0FTV1ltbXpoRDhJMlE4ZUxGUXFRNWV0SEY0NWhLVy94Tkk0amZSVThhclRiUFpybFQzRGJxd0p3QjhIU1hPdkFmYTA0N2ZGOUVDNm1IZkFMSVV1ODl0VktpTjY2ZGF6a0Y0NWJQOGFiQitWeW9PRVF4US9Ja2hYS0xMODd2bExwVHFVYjVaVTVEbllrS2FsYURaRldsaVhoUGNJUWZraGZ1OGNMUXNGdStWa2dBUTZSbTFrQ3QyRHRCM3ZxenM4STJrc2V1eUlhYmQrNEEycXMwd3J1Y2ZGKy85blVTVEV6TFlqcGovd0RMdjFQTk1yb3FsYlhBVU1xVVBhb2Z0MkhRN1ZHckM0aksvbDNzUTl4UDBHOXhGZjF6SFlGczR6eVVXdmFmQkxpTmZaRmZtcjdBYzFhL2d4SFdzOW5xRzRxMDduRWZKeHJtQlZTakdFanBTa2ZsVVNGa0YxMFpXczlDdk1Ta0tMaHFwRWxoZlJzdmtJSk5MN3ZUaVgwaytvWkQzN2lPWDVHYUVsRmI4TlM2blQwTDJuVXhMWlVWdW52T29keWNrK1pZdCticFdxYmtEelE1VTQ3WFlvM29GMkVjZmhybmMxUlViM0h1NUtrTzFmNEIzNXh0UWRmWHdSdmQycDgramJ4MWVyZUEwMEVTUnBzbjVqV3FEczBaN3V1K244L1hhYTRyYlNrRSswQzFsbjlPdVc3djVRNkpvRXNzMFl0VjNmd2wzS0hlTnU1KzVsUFdMSDJpSUxUNkVFRzV6cmdROG85K3ozQmgxOXNjZlJjdXY1eWx5amZGVFRRNDF3U1h2d1plVFIzaENJWElGKzEzTndld2tKV3BrN05JY2VDWlcxTExudWM5Ujh2clVTQ1N5ZjdBckk2blUxeXJhTG0rM2kxdGwyZnFWZHc3VXJldDdGcnFHMmM1MzRCbXdpZXFFajBoUFRUSFhaQ2ozaktwN2F1QlZCOGxibXFXUzA2K09QTUFwdks1SUx2b2lBbWhvQWJTZjRWclRrN3FqYWRwejdZcHJTWEhNTDg5ZlB6VjEvNS9Welk1Wkc5azhWdCszZlZxUUo0bnhNN05ZMzBrQ2RhZFlZclRwMy9mekNIRkJyU0M2NmxZdmIydkp4anNiRmFkSTRtQmVCS1BUaTJqOUhXOFNnQ2J6c1JUNUw5MG1RdmRqbmF2dDZwYW12RjBoZVp1dCswMnJUaEVienlQdWkveEFRQnZaSGZhNk8wN2gxcHJBNW45KzhGeEpwZmN0SkRmdE85ekJKT0pYR3NHNWpzUU9hMkM3dUN2Sjlzdm1xUzA1WjluVU9Yc2I1T2RSQVoxdE1INzFHMHExTUhieWZiVjd4RW82Z0xBMnBTWk9qVEdYcyt0Vzh5SEw2YnI1Qi9UWXBmMW9FcG8vR04zZGlKdkpEb2dES0lJeW5CaGhBRFRCK0hXd2hxUFBCNDhBVkhrbGwwb0lheEFVbjBhemYxb2RCL1FibEVJOW81ZEZyRkVPUUVzTmpZOGZHUzhvVkYrQlBPKzNTcHRaakRlQThMcytXRzY1TlVOUjJNTE1FYWpnZVZCVzFWUEZKM3BNeGE3Y283cmJHd1hDR3A5dHhhemNQVmpSa3BtelQxTjhMRHB2bWNKQmExMkJNTThGaGpLbTlqWXM3QVBpU1ExU1hUVnRRNjJnQ2ZlMjF6a1lzNVpPdkVNVlhKUFBVSDUxbm1Rb3A1QUhTWUNYYWpKSWZaQ3U2UmpQUnBxYlR1cDYrajY2MUdiQ2lBYzhIaXR3SE1ZWGtqbmZrdXN0RWN5Rm16T3l2bWo1cU42a3Q4M01uY2NTOHRES1dzRVZiSFl6R0x0dDZueG5CSjVXMTFscE5FcU1aUlZMZjZIV0VKb2RDc29LQ0p3aVB2WURNNFA1ZFJnREhTOFBETncxbjBRSmhzRTlnKzYvMm9LWVlDMHBocjZOZkptTmVGcERTbGk4Z0psOUFiUGpJbm5vZlpGQ3psRVZ6aDlJTEwxM0E0UGtnMDdHU2hwaytVdWlCeStxQVpDb3hvcTNRRmNuZXB5Nys1elV1Zk11cDVtRXNqUkUrL1YvSTdqVUZ3cEdQU2Zod0UxWUJ0TlI2QjlVOWs1MUR6Y2NoSlAwbjg1VW1JZEhmVWNsL0VtTFZQOTQ4eEE1N2Jmc3MrajcxZVFTTUFWZVI3TnN6a01jSGZsV1lndjRvbytkTHVjYkVkRGc4WDYxbjhwYTVGZzZ2bWRiekJ5Wm4rTk9vK2NxckZtYkhiVVZ4YW8zOVYxd1hqRXVMaXJJb3hWdS9YN3pzeXR2M2Q5OXJiT043SVI5ZnVzT2RxUCtkV3o5NW5Qa3Mvbys5SklsSjBuSFIzTGdkLy9rNHEwUXEwNU9PUzB4djhEbXlwbitCV2s2WFMwSGttVTdTZ0VSTTQxNUdmNzBXZ2Z2bE0vWHFmRGc4UGRISWxTd1QzYzR1SEx6dWl2Mk5tcU1vOXZqc3dsV3ZKRGYwMWhhZ3U3YlNTQ0dBMW92Nm1JeGlGeW02SFRhYWFwZG1HMzdrNkh5NWhISlJhQm42L2w1RENZMlEyZExVVG1vbW1UTkhRb3F4TjVESmpvRmMvMmhEcjJaV01sVzljUlIyeDdJRHJhY1FkN2VtM1gxZ2I2QWdtZThJUkNoR2R5VVNlSWNwRlFKNzgzYVVocnJlbk16bGtwdHBObW9qNTJoSkZFdWM2Ny9MWW1aZHlWMUhPSjdiR2U0N2pUaFduK2syVFBLV21JNGh1OEUrblhycU5aYXlaNVE4NGlubkd6NkF1eSsvYkprM20vWVlDNkU3MXlad0tYMTdwanYzQ0ptVFZzZ2YyUDIwaGwzQnlCamJiams1ZHZQUzdUYTVHTU1yYkpOMy9aSVZtQUxoajlvZUxUTlpCUHVkV2I3WnhUQmNjLzJhd1I3bGN1N2wzQko4MXoxR2QvVFJlanFNTVF2bjZZSkdKNkhoZFBYSEMzRzNrVUNSb3J1OHptbFJJSDJyei9PbjIzNGEvN3ZkRXlnNzUzTlk1SEpyN1k2QksvVjcrTk50djZuVEhSMGh1akVCd0ZjK1JTTmljNmdkRnNCbjBvdk04TC9nUDB6QmwzUXRVVUpvYVRLSHNybkoxbGxDR0src01rcml6ejJDSWt0SnFrSzI5VHpBeGlBTEpDL0piRGV4NE1xekFPZmh0d2dsVitkMlVLa2lKVkJCNVpjRGkzdWZTcVVxL1NDcWxVdmJFR0Y5d09DMzNvYTFhM1RreXgxNW5ueDBTbEpJaFZ1L0hrNEpTUXJVc09zMkpSa1RsY1h2TFNwaUxLbmN0a3N6V3krd05pMnp6Vm0yZVk1OFdwOE9PMDc0MC9RcmU1Y3VXa245MWEvV2s1YW92OHQ4Z29Kc2JaUzRlbTkrSnhsdmsyd21LZVRLbmRqcEVUY20xRXk1eGdCbktPQWsxTXBCZk1WSndUUmFiMUQ1Z1BKS3VPYmV2UUVnRzBKZkRrRWFsSGxUYi8ybmpJcEs0RjFuOVBDNG90TW10ajZxSklPRXJKaTByRWxDYTFncG5ORERXY0NBNTl3WU9rVXE1V3h5bDlEeGZ6UDNhdTV1N2hlNUU5dzd1ZmR5SCtJKzF2YUViRXhOb0VhSnJXc2hWL1U2RzNPbVhMTEFsOWQ1RUplK0JNOC8xT2l3Qys0NTFPZXNqYSt6L25RL2d4NzhBQ0hoRFl3VGZEd1N5MDQwU3p2S3FTazdOUitqeFFIVlZNa3Z5elpMYkxQS052REZrY3pWWFlYZE5WZTY5dHhOczZ1bXUwRnpIOERrZmpiT0hCbzBKckt0djBEVDVSMGxPNlRvWVZwK2lOME1kMjNLYktPeVMxaGRoWDFybm0vUDNYQmNoenk3UmkxNkM5RVlsb05DbVltdDJWd1g1TXZiZWM5bkgzWWQ3NmhFM2NlMm96TDZGdUc4dE16TGt3ZVQrMzVGTXl6ak90MFN4L1lsaStNRDV0ei9xZTVMb09RNHp2T20rcWpxZTQ2ZW1aNXI1NzczbXQzWm1WbGdnZDNaeFUyUUM0QVhBSjRnYUlxZ1NJVWc1VWpVUVhJcDZvQWtTNGI1YUlrbUZRZXlYMTRnV1JacG1aWk1XN1JXRkNOVEZzTWdNU1BiTVMzQml2MHMyUTROT2JGQzgxbkQxTkhkMHpNN09FakxMd2t3VzExZGZWVlZWMWY5NS9lRGdOYVJEUDVucTUrcXZvN2tRRzg2N1BkWE81MHcveW5nQTZZL0tZOU5saEs3Sm9TQWVoTytVdm5FTG55WDZ5ZkRXa0JHcitOcmZwWTNwSTRXK0hpNDA2bjYvZmdxaDZiNTM5UytKRVBrOExtK2xaR0RtREdBUitUcUlQdlNWK2E5ZklxWmRCUCtoT1h3dkhqd05BbzdPT3RoZEpxQno1ZzZab1ZvYnI2NlhwMy8xbWxNZEIzQlA4WEFQM3hTMk1ZTnhuVjZ5RGRHK3RMc09PcEVSNC9qVnJKU25odUtvVHE4a0xZL1NnYmxZd2ovYUZpODFYVlNuL1ZWQ1R3d1g5MVlaM0JsRktGUDQxTS9qVkJVQ3FOZDFNcDdGNHI4RGE3cmNQMHB2Mi9IZkhnT3p6Y0x2bHQ5UHNzQnl4bmVFcFVUbm9vb0UwWXE2YmNkZHB2RVZZV2dZQU5Mck15VkNZMUQ5ekxVdGRHN3BkMUFkRmJYQi9YRkI3UmdVSDN3Y1p4cWo5K3ZoZkRZK0Z4R0VZeVkvSDdEciswUEJPN1VBbnVLcXNIcHVoUUw4UWgweFpBVkJPQjJ5VEo1NlFyeFprUzJOd21yWkl2bUZFdCtYMmlyVWRTQ01CZ0x3S0FWSkg5UkZETjVlSjBTK29SbWNxWVFlRlZTQ21wUTRmMldNdkdZRmdCQnJmd2htVGRpeWxIaHZYVDdIdjVXZkRRbWI0UG9PaTBhYkNoMGZMMEJYc1B2MGlManE0VGdzQlNFS2VCYUEyTnRRNVJwOEtPaHNkUjdZWGkwa2JmNTVJYlI5UG1OUTg2aDVYRUM2TGpIWTJ3WWQydDRSSmw5SWY4STlmWFR6dk05ZGJySEhXbG9ZQVN5S2d5T0pERHRqalBrR1g4b3dyQW0xcmxqTnI0Tmk0ZEY4RzBHc0drN0F5QktlYmhoZjBnS083eGZkSEF1MFh2Nm1KZHJGOHQycWRpZkprVVhZbXl2RXlFWTNkbWpnalpBSXFSL3ZFZkRuZ05TYm1QK1VYci9Ha1lsbDhlSEVMWDZLcDZOeUt6TkVXaXRHOHE0WXcwcitOdlVhZUFrOVJ6NDdhRGwyWHRxWkg2dEViU3FkakZPcWxhdzRkbXJqczRQMlNnM2ZRZEgyQ2hmS3RUWm0vSE9LMUpQQlV4K1BFMjY5bW1hblJ2S3VpY01LUTIvS2lJU2VsaGhnUHBPOXI2UnBheDlmOHAxd1dkOEJkOHUzNTFNcGxuSVhhQ3lSS3JUcC9DOVVhQUdkSFVvZHdHZlFDZVdNR0hINzZMdFlCOFl6WUpIUmFTeGJJK2huajdhUDZYM3R6VC9Nc20vekU0bjBHZmdPRzZWSFRkQzdHZC9hV01SeVo0YVhUeHNrejd5ZmFQQ2hWOGsrWGF0Ti91K1h4bDhMWGIyaThPdmkyVUgzL2Y2OEJCaDQrTFk4Q2loNS9SanlIM2RlZDlNWWVoS1lrWlcxaXA0ZzVDTjFzMTJSZ1RYSGo1bmJVU240K3lKVVlYR3AwYVdndDFrV0h5QkRvdXJ2U1BuN3dFYkgxOFlIazVybnJIaXlRNWg4S2NvSGIvaXUzYklxd0sxcHdqclZDYVNNU3NOMnBXM2pNbnZkYk40SDVSRFluTDM3cVFZa21IMnhodC9kS25BL0I2WGkwOUtmazZxcFZJMWlmTkxzOFhpczVjS3owL2I3ZUNxVFZBOHNwdW9wZCt3Nm1wQTltYWxnZmNnR25JRUl5NHY1Z0QyOXZBVjF2QTBmcCtyODd0U3BsdS9rU25Tek5TdjlLaGhPMWpETkhqbHFhY09tUkZhbmtzR1RacEpSOTFyajloNlU1d0FHYXFMSkw4WVRNdmhsVEtOZXBPZU9maHFLdHdOcDJTOHZzbkh1NERUUzFGNjFrcDIzdFNLRVhaV2J0TjYvMFlPSmdWNER2ZlJ4M0RQdEtsM1E0ZEdHS2UrRFdTLzB5WjJ6VnlMYllITkk5djBYSVM0cFZCNkR3OGN6RjBURUFtd0JDdzB1RTlqbFM5eEViWmw3T3RXWUVWbmlROUZpMGdCU2NaNWJoczhLd2dCNWVEMjdRZVZnS2dxMHkxSmxFMjVGZUpsTThSSHR5d2p6Z2pETkdhMDB6QnNjR2g1UzVRUG1USWZhdUd6UktrMXJhaml5TXVWME5EbHlCeDF1ZnFJWktwY3ZGQ0ljNm9aNUZCR05FT2ltSm1VUTFDV0R4ZDJkbEZZQjZpOFNEN1p4VElDZWhoMWR4WU95eklNeVpNWlVReVpZZ1p4d1pIM1VJS2o3aUdOdmdXUnlmM2tqZStCWDZPMi94T1lkdHFQS1NmR1orTnB5d1VFdzNOWGh5RU5PUDc3VWViU1g4Q2t1ZGtab2tyUUVPbnh1NjZoTnd2ZW9VcDNBeWdVSWVJMjhWSlY0amR4Q0JabFRoNzNHd2h1NDVENGZrbzk3ZUNSK0FHUzI5cGl4dWVBeGdEdHJZZC9YUkFWZUZxU1RrTkZUczFhdlQ4NHdnc1VnbjFNUkVkNUlXcG5tY3h4US90c1htbG90aGJmZXZ2RURlMERyVGZYUUxDWHRiQkhkZnVnRzc3K1Vsc29rdlpSK1FtSmJOV2kxZ25uZVlQRGdZTFJFTkJxcExWQmZUQ3d2L0UxVGpJREF1SmtLY3Q5d3dSdjFOYzFPeGwraGFEWTk4bzg3bVRrZjNSekgzRno1Mm5qNkxjNEhMejN6Ylp4NDZ2OG41ZmV4ZzF2TVhYcGJTVDAvbXVnNGZ1c1QyZThpOHZLdDJ1dllqYnQzWmpmZVRjeWlBM251eEhaTTlqWWZnVjhIdmRMMXJjSjk4cjFWT05nUTJ4NFhhRmRXZ1NXRVlYZmkwWWM2RDA3cERvazJBSkVuVWVjU2p1VkFUckY1dVRLb0JYbWhYRkJ6SWdvUWNiZk8wZ1NGNVY4eUZ5S0ptS0plalFvQ0VBQnNoZ3p4aVp1RE1vUThjaXZnZWZjdm5ROFBzQnFSRkQ0R2g3K0Q5SmhUSlBOSXZpYlJEZ1NUVXpVMDNuRVNVSmFGSUNzQzFVdEVGRU1TR3pGbmNGak82TTQzL2UvU0IrVUJpQXBuZEJXYjdVUGVyLzhVK3FFdjNBSFY3OFRHUGhUQTV3Z1k2YzBZR2tNTE0vZ09lc1pQQndiYi9TYTVQQ0lLOW1LTXRyK09lLzRBN0tkVVhDaFp6RGVZVzhOSjc3SVdZN1lKbTZpdXFvcFVNaVZLMDNxOGxZbUxyemsyOHpqMTlLTXNCU1RQNWc5bmFWdTBaMUNtM3pFT0U5aWNqTnpnOWtvNUE3RWwzSzk3eVA1cGVsS2JIZWtVQStFVTFuOEx4VU8xQXVSM2JISzlFdTRWOUs1cFhnMEhuK1EwQjkrVFR1bjZncFVMR09MR2xwYkt5VzdzV29zZ1ArNnlkTGFXa2pkWWxqNHFLNnE4Vmo4Q3BIdjhtSzFhc3ZHaWQ4UFFmb3BVKys4aU8zelF4MnhDYjFCcloxWmMxb0VNb1d6SGJaQkVIZk9sOGF5dVUzNVpDUEk4ZEc0cW9vaDlaUWF3bFJDUE1yem9kbFVycFBOR3Z1N3MrQVpoRDZmTFV6bE4rZWpabFRXdzVvUWlScithRmpRVEVPT2hxTUE1T2R6alVMZ2lzVnA5eDIvam1sc0VqT1lpTVBhVTF5RkVvcHRLODNqYW9FWGtsRGd3OExrRlpPWXdrZUxkeXdLU2Q2NFBNQnJzSGI5Nmd5UHFib3NVb0N3Zk9mNzU2Rmd4Mit3TVFKWWJQUUNYaUZiVlBQdVNMRmQ5OW1Pay9HR09tQWxPZGYydzgwMEJrS2lmNVZ0ZXU5bnBicXRTd3ZaeGQrMDkwOE9ublptNEI3N3ZGb3pVSGJOamwzTS9IWENrWW01WUk3ejlmQUE3SEkrbndkZnh6L0NHdG5MTnc2eWdnNy8raXczQWI1QlVUTGIrSHFLcFp1aGxPWVNwU1FwQVZ1ZTVnaVlHZUZFa2IwT1ZRZ0VvYU9SNHBjZjBmMUFmbnVjMDJQcXd3K3JNWjJMdjEwR2Z2MlJaV2haY2xjUUpFcC9TMkloU0NKMlcrQ0xINHh3NFpoOCt5OWdrZzF1M3c1aFJIdmtkamtXNWlJZjFDVHBjVkU0emdzQ2Yxd1FmOEJpZkR1NFdsbmNCd1NJaEFqTlBUVUZXZGt2RGxRQ3JNdnl3RE9jZm5UYWUrRzJYcVJKYnYwZjBTSndZLzJkWjMyUDJpN2ptY2R5alJZb0VGR1F1bURZUEg4WGlRMFJQUy9IUTZHNC9EemRDUU1xTVh2cXR5UXVwUGZXOUJBblBmMGtsWmdOM2RjaEM3WUNZdXJUQ2xMTEhudjFKeUR4K0Y3ZlVNaU5sVy9RSGZCbzcxRC96c0I3WjhldTZ6bUdVRUdBaEduTUJBcm5XR0hhaVQ2R1k0UUZuS1RlMjh3L2t6RnhISVhFbzZBcWZkUDhyeVdLSU9oUHo2VW5sN25PSGxWYVVnS2N3S2xLWm43ZnBveXNjandYVUpZa2RVOEhFRmlrYVgrd25HRHFGTEMvbEFpbHBYdFNqZFRtbW5abzB4T3l6dWxBbFFQNEJ2QzlsYzN6MWZkQmZHMEEzMFBqZFBtSlRZZlZpYjBUazFkTTNTT2xnOG5TZnFiYThkb2RrUm5BaDFlOU9ZOU5OTzR2QzBFcVBBeUQrUk5PL0I0Z0dSOC9paFM0dGdZa0o2clBDY1hvSEVWclVMbHczQ2J6QW1qR1kzMk00dk5BR0R1eHEzNEQ4NU4xNmwvamdOZmdwYU8xUVQ0ZG9XNmtUQzhTM1FCaDh4UTFwWnM2TUVNaGRlNmp1RHJ6RTBtOEtJL3htSkY5cWgrNTRTUzF1OXZVUEx3WkZmcWxlYm1ZWklFZDA4Mmpqd21TSkR6R0JpTHZtVmRwM0ZMVFVTRmVPREt2QlZHVTROL2FpQ0VrL0RQeE1IRE5pR3preGtyWkR0TjdmRVFJM3hWY2xtdE1GUmNhaGVyTXBtSzlrY09uTkRMak05V1Z1YU56SzlXWjhReFlZNmJyTFJMbDl4Z1ZjUm5LTWZ3THA1NE55VkFQMWdLNkJKR2tCNnBCRGNraE5SRExGbUltaVdSb3hnclpXTUNaSDcrRDIvanY4ZHc2UmJYalE3YUJpSHBYMFlaNHVDZEtXcldwQ1FNejUyTDBtY05NTWZjVzNGcHdya2VKWTBEZzRiOXJxWHF0TUJaSnltZ1NrMUFUaXpzbkdzcmpTVDFnaGxMcHZBS25rRHhaM2JTdE5xNmY2aFBjQVZVenpQaVlva1U1VW1JMlVvbDhzVHNXUGFLcC9taE1VOE02TFUrWG8rRk1ibXN1NXNFNitDeHUwYzhRYVlYVDN3VXY4Z1NobEppaEVmWEZjOWpBUXNXbE5FbVViczhvNzNnQ21HUzRqbWQ4SWd0OFhNZ1cvWWxNcXBLSnh3eUJGOU5RRTR5UXJxdklMQWRTQUMvYXAxMlUvRVZabklNVG9reko0TVNtVnBwc2Q4aENGVTRMOG5heWsyb3RaTFd3RlJncjF1TVJ2eDZGT2gvaE9URmttQW8wRW1adVhGYWdSTHVIOVJTNlN0bk45cSs2Z202a1pXVXZLN2o4YWhZM2dOci9KWDNqdmdWTXkxMUI1MVU4NzFuTXIyMkpmbnhrYmwyZ1FyNmhUNnl6TVliMk1NMndYdHlTWHhKNDJEc0RlV0VwdjZWWVdzaXVaN2NVWDhQamtZNUx4WGlobjdXcGdkN2YyalREa1RkODhjbkVMSytxL0d4aU1nNThpWWxFWXVKWFJsZzlUSGtKQ01kZmFTRCs2U1ZHUDcxZ1pOTUxSREIxN0o0cDl0WSszdzIrT3dqYU5iVUhqTEtGSXcxczR6Um9PL1ZEZTFISnM0V0VnR0lUcTY4cFlPdlYyaXlXVXJudEFBS1lYalBvaWxmOENzeTQ0RWViVlVzSWNJcTBYWmZWSmtKTlZkYTNTd29YRUN4MU0vSUxjVEVsWHRwcDcrM2JUR2RUamZsR2lpYmdOeGNsVVNpaWdMNGk2VUFFQ1hrY0J1QzRuTUI1WFZyUkE2Z29pTktpcmwvYWFXLzQrdWJWcFpUOWpGVERpY0h5VnI5VDlQL0dkN3IrMC90TzJYcEw1Ty9NWjVvQUZSQ3JXYW82WCtTYXcyZ0tIWkZ4ZTR5cllXNmV5T0FJTWNOVXozTnQ4TTdZUW5iejlRYUE0aWJpNkxqejlpMERFQXU5UDZKQUMrYzlDU3hFclYzemdpaUxtMjVvZVNFWENPNUhmZFF4MTM2ZThGN1VaeHJZaUFzTTNaWlVkQVRJQXZsYWVWeHhhNk0rZkpvMmtLS3FrR0xDSWoxRDRCaTIzTDVUeFRlZEVSQXdibDcwZ2pBUWxJVm5jTUhiUkxjQXQydkROZUEzcjZ4TnRXN1loRnNnTEZ3K0FNK0FlZ2NIOTZIM1ZOdS9uY1c5clJCYTBuUmR3bEUvUiswWjNEZ0E1Tk91OUpIdzBSQW1QZzFkVFhOLzBPRjVsVVBjL0tTVFNlZ2FoN1p4bUFKRTNFbzNsTmUvZk9KLzdlTWhQc2lsSmkvRGhYbU8renpiN0psTTRZekdnZUE4M3FvOFB6L1ZZV2ZPSi9WOHFMdENqM0xiY0twLytTTmorOWhOVTVON09IdzF3bmVobThzbVUvVFJEcTZiREY3QU5HQU8wMnI0S3kwei9CSnJFZE5pRlJnZGFLTkZpQUYzVVRnWGkwM1g3cjY3TnY5eWRQdGx2L3RLUkI0cjNJNWdDd2JoNGVKWVRUM0pBdVE5dHZEZ2RHMXNESitWU1l1M3ZaSS9NRlk0akU5cFFYUjdNU1VteGtLckxES3BKeFlGUXhwTGpveUFXU0RJWTYybWFXOEhjR042LzNUcUZBMEFjK3JVc0d2cGtTNWVoSERpNitzRSszRXN6NHZETldqZFA2akVmSjdGWGZ4VkpOcUJOemRHZHJ4UUxNdDFUeXpMVVRyMmpmNkFvNnZ4d2I3cHd2RUxWT1dDOFN5ZHVseTBKdWQ3OGdVaVdqclArRHAreGdMbHk4Z01NRzBMZnlQSTlzNGIydHBWNkxCejNlMncxeDc0aWl4YkRQekh3am5uajRFQ09YdmRmZ2dqa0JLVXl4V0JLQWJER3NzR2hyYWpEbEdwTW1JaGlBYjdMSGFCMFROcXRKd3ZTaWV6dWY0Z2VONW5ZRjZNUmswZ2ZtYUkzYll5eFJIODdBaGxUanY0STVpaTdoWjBBY1g4ZnFrTWJkQjJURTZjcW02ZmdpSVBHandFY0dyN2NSSVdEbS8zazFJUVRSS1Fkc0RiS08yOUh0dDI5dXpOY29BSHZzSmltWWVRTHk4V25xSXAzUWZMS1FiWS9vZjR5c3plUFJMYjJDanVURDcxUGE1cnh5dXMrQnE0OWl1K3F6Q2xsbmVjUVlnYzEySVFpUVYzL3FnNCtJOW9nL2pLSlR4Um1WSlp6THlWV0xkZWJsZ3dWeW12YlB2TXRwVnlKUWN0UTJNOSt6L1k1Zy9acG1XRVFrbmMzZE40TnhrSzNTYUgrS2w0SHJOVDFoUXZadzF0Y2ZjcXVaN2NhSFgzb21hc3N4ZHhhbUR6eStRV3lSQkxNN3lzL0R4WG1pdVZrbW56cEJ4eTZCdlc3c3I1V3N0N0cxQWUzWUlQNGRxMWFlMTBwVDJ5ZXVCbS9QUW4yZFA5Q2ZsSjhuamJENGZ3cjFRbTBIZUJkaVRFYm5lbXdpK0dqWmNONDBXamlqZkhHVlgrL0l1WUpYMFpsN3hvNE0yWnZxeU8rZjJ0MmZjZHR6M2tIR2R3MnkzT0h1TWlpZXd6UXowM21Jc2YrUHVYalhEL3pqMzdZZUJWOHV3dkpoTC9ZWWJVNUxzdkc1NDY3V2ZQL2pDdXlCZVRseVdmSjljU2V3WDhUWnlqOUNPYkorY3hQZjQyL0YwTTZZNnNpK3k3M20vbUlLaUxMWEpBMXVqaU00Q3lxRDA2ZFp3bi85SHcyQml1K3A0OWZrRVJwZ1UrSUNpODFlVVZJY2dMWUdUaGxuNEF1bE1qczFmYnN0UHgzUUdlYitDci9JSVE3Zko4VUpDRlU3dnhEcVpOQlh3b3VpVGdHeXFDaStud0d1NG5ZcSs3azBneVN0UlEzR3VoNGdxNCtrWkpubWlpcEw5S1RZSzJrY056aUdzZExicG0waTlGMFhoU3BWWmlhbkljUlUxTFZ5bUlMZkRSamFwYnZhZS9JOG9nMlB2cklKQzFTRHFDZjZETHRpOGVUT2FaRDBvK2VSRGx3ZzA4aHR0MG41YTI1WVMvRWM1ZGowUUN4dkdVbjF3UzhiT056NG5EZFE0OGczbkFTUm90ck55aEdJMXRLNHByYTgxMjJsVEdUNTBFT2JvbHFLc0V5V2FSczhyVWVSQlJuUVg4VTJCdXZUT2I1OGZxNVdLKzlsTE1IeE5DQnpmbmRSbUE3UHplQXQyL2RzSFp6eGQyUnFNQWhMZmVtY09YZ0h2cVkvemlYR2M1ekFFcnN2TjlrcDdmZkRBa3hQeFdjZTk4RnJNV2VuN2hXcklmSyt5ZHo4MkNlcjVReGxkc25ldXNtSlNlUE1zOUJKN3doYW1Ybm92alV1bHJnY1NXSnc0M0hzU0FlNDRFYTBMbzhjY1Izb1RSY3dpODIxQjZaNXhZWlU4K2g2aEI1aE5QVUhOTWZEejhldzZhcytITVQ5dnd1SmdrMFo3Tm5GZkhWZ2h1VUxrRkN4NWZaSkdpckJEOEcvdnpzRTEvU1dVRDdCTW9JTG1USjVtVEpNbDNhSWtNdmsvMXNnUEFjZllPd09QY2p0UG5BZnNGWFlyWml3OFFQZGxaUjJGR013eEhFdE1PcDBhMkliSlJiZWh0QXdIb1pCakZIc0E5aXIvU25ndXdTSks0eHUvMnRPSGRkaHUrdEtFbS9icDdvZ211T1RYdi9kcDVHKzNJTUlBN2p5MWhtbUdvNHNQdVEveVExYXM0WkZJS3Fzd2lGeWM3M2R6MzJZWWtudVBnbEtFUTU1ckJwUGVhdS90Y3Y1VFppQTNXZFovdjV1SDRxWmdOSGFxZk9XVHNORHhIODVHKzZSUXBHejcraTRaeUc2a0RUanpaKzUyTXNSTWtxUUQ3TDNGS0JyKzdGL01jK0FGQjNsWkk4bmszQjFiWmxpUzliajhQVHJ1bjlGN3RGelBNNHczdHY5djNvTy9uSGR2QmZpOVl3M0swb1Y0WmxyT2hvVjRhN3NYU2NHelA0ZmlvUStkN3V1ckxodkkya24wYkRjTG9sR2I3cFMrNWZmbVIvbkh3c0Z2YVQ1N3ZYd1JPdUwzMCtvamNkVzV1cXQrRnZ6MnE4RlEvZTh3OTd2Z2NyQU5BWmZBcEduM0xkZjZ4SWVXbzJxRERJTGI1dVFwenA2UXVsRlJrUkR2RUZyUm5zL21GQXNndjVMT1luUXdvb2k3Z2xWVFFSV1U2QzNMVFhTWk8zMXhxRkJieWhZVkNvL2h0WXVyZU94c0pLb2I0WjRRbS96UFJVSUtSYkdQYXJoZWhyVXhNQVJIUERmWlFxbVJlWUtEN0ZWU2dJU1RhUzI2UUd5Wk03N0RZRXN3SEdoZW53VmxjSVZ5NVBNQ1B6aDRCMldsdjVUSzRXa0UvcGpmOVFYQ0VWT25iUlZ6RkFtNUxvL1R2R3RuaDZ1V205K09XSklOcDZZZkVRUCtIVW5xZ0g0TytFcW52eGpxODJRNjFxM1R4VGlWVnVZTlU1UTRwdmYyU2V2Zi9mbjFycEw2MS8zL3EremxTMzg5ZGVuMVpUQ29CZklQWlJ4QjV6Z2dKVmorSCtXN3EvdFRzVUNER1AwdGRrWnhxTXVIUjdPUXN4Nms4NUQyWnc4Z0lvOE0vMHdzWmtnUytZTUhVMUN3VFBEVkhaRzQ3ak1JR092eVQwRnpjNVMrWWJJM3d6NnMrWDNCb1huT2QrMFNpWG1zeDhLNXl4VFl5YVZPUkx5YnhFUHMxMDB3UGJlUHpJOWlmYTZyTURSTUVkRVdFb2dDVlFHd3NMQ0F4dUNPY3ovSVRrVUlDYWdyVUJRbElhaUYrRzZjcUFreUd3QWszeE1WL1llNm9QNDVxRm9ncVFjVmZxRWQ0OFRzaXlrQlZnT1dFVVRlREU2YWNNS3lDRWdrcG9WQWpyRzlzWDJkNDNuY2xCRXp5emNMUm9FSVVJdllqcTB4bHlyYWtkNERTT3kwYlRiMC9nODdhM3JKdEtDZ3FkMXU4b09LV0NEcFVOSmdvUkNiNGJENjhJeWdpSVR3V0N5aFF3SDJnNk1sUThxd2RGeGNudHRzcStFZ0kxejZpRkN3aklac1RRYk51Sk1wUVVHRUc0ZGJ5a1hyQmoxc2ZCWllXMWNPT0R2OXJOSjdHSk9FMm1vUEwrVUovckx0UUtsc2RCRTFRMStwMHphWjFxR3RsSzI0b0owQ01VN2dZT0tFWWNldXYzOVVQa3ZHdTBGaW1pRmNOam1zSVFvUGpqaGxLS1pPeXNRU1h3UnJPWmNrWU4zT1JYQWtUR1JFSE80dmFwYnNCeWZPd01raGN0OVpBdDdjT1RxYkNxWEF2aTVNVXlZR3pKTmRnd1lGWjdBeVFYVDhTVHJGUXV2akx0RE5YazhPVUVIZHdwa2xka2l3K0ZIc09kWGwyNlI3eXlybnV4bWVsemczZm1qTGhGNHhsNW42MUc1Z0lWNDN1MWRkM2VMNkttY2JsWllGZ0xQTXJLMFA3QTByODN6L1BTYzYrNzVMam0vRlU2TDBCMDhFalRaN3RuQ2UrV1libmw1Y3ZVT3VOZ2M1NjMvR2NPM3d0MmZkZGFzd3p5N3lFZW8rSWVSYThTSjFIQkQvcmZmV2lsYjVJSERUK1VvYUNWd3g1MmNYR3dxRFkvSHNYR3cxa25Ya0R6d01QMGRob25ZdDNIZGpXUnVpV1d4QnFZNTRWYjhObzQvNTVENUN0STM5OUoxN2I0bVQyc2RpQ1N4bjhSYm9LRU82ZnJNV1ZjdDdSTERMNUlWNUQxaHRYTmtMcVVpQmhpUEdFNEk4SGx0UlE0OHJyZ1FSRURYSzhtVEo1RG1wZGZGYWxiRjJYbkp3MVZOV1luVW9ldGtwVlhQZ0ZRVENDc29Ba1BSeldKU1RJUVo4N0Z6MkUzeEZGbEhJQXlCZnNEMVowZ1Ixd1ZjVUNzVWxzMm9oU2ErdHpoK2J3ajIxNlA5ZUhpUUxkbWF4bFpXY29EZ0pZbXp0MGpKeUJrL1UrMk5TTnhSdHVLREpRS2RjUGxOUWpRS3pEU2c0MTRxajlLOTVKaE91NlQ2VWJ6MTFaS1gzYzVSN1lLdnYrRDRGYmNMOGZJTGdYRyt4NGJPbThTVVdCR1V4TXRHMEQzNGpwR04wUm5GZjdvK01LRmg2ZXpqVno3VnV1SVJxRGZ5VEp0VWhzaStpSHl6SS9qaGN0QUtFd3djdkxJb3JSY2hrVFlxRU1MODNLZkRxRTh6SVNPeUtLSXpDR3hIRnlPVTUrUkxVY2M5S0Rlc1EwSS9xREVpUmdsVGo5a0Q4U2FsOGpTZGUwUXhIL2gwUW9rZmhjc08vLzdOaFJ6RjNjaHNLN25xQ0xta28wdktLYnAxaW90SXRhUnJSWkpEZDd6T09aZ0dJdVVLUjcvRjNoOFYzcGYyNjJBcFhVaUhqZXVCOGRqZjk4SVpUUkZ1Vm1PbGFVeVI1YzZ1VGxmYmkvZ3ZzTFZ4Y0NZWjRmNHhYQk5BTVFTdnRFNUljQjAyUldWZUZBZEdtR0Jqb3JVbnNybHAxWmloNElRRC82SVF2WUJ0YjlZdkJBTkJvSU03dXRzQmtVL1Vpa0Q4QTNZbVdCUXIyNXFxYm9YVmo4TkpaVlY1djF3bjc3eWIxMUZnckZtUWNJSGd2Uk43aDl3dUMzMzFxTGY5WnVjYjJ5VWpsUG8waTlCeHVGejMwejFXWiswT0RyZUIySzkxRkxnaTBibzJTQmdoN2I4aUV5OE1RaGpER3hEMDdTNnB3bmp3ZVB6R3ZvWHFUeDhuRUMva1NNSnVuY2ZwYUVCUVBIY0lYT2pRS25BSGVsRk1PRUNFSFRVRWhqbXIydjB0VmdPODd2Y1UwblJpVzJ6Wi9Ucmd1MWlHZmtRb1ZuTFJwZDIzOGJCaW56eDJZS0U4a2llQnN1R0s3YVhPOTN6RVRDQkR0RnljWDJZcmgrRGVyRHhxRXBJb1FwRzV4bEFKc1lSYTZkQWhVWjIwUnB1UUsrcWFQOFRGem9YTllSNGpONVpDU3o4OVhqZ01PVHZhU2VWQ1U1YUhEZ2VIVSttM3d0MWl4cGFtbDJ0cVJxcFdaTWJZeFY1N1c0NG84WktCSkJSc3l2eExYNTZsaERaZldoTlBLY1RTTlRMVW5mMTU1NTRMc3BDZFhEcWtZVVNlUkU4SjZyOHJnL3Jzd3BCandtaGFWam1MZkpYWWtNSlg4VlR1NExoSnpLSWVVK3hkaHowRERSSWZ4M25NU0RObzFEK08rZ1pCcXhNVCt0bWg2SUd5YnRwNTlnL21RYlhqOE5hb1ZDVUxmVEFMOEl6UHFCeStSY1R2NDdHU1pDNEd3b2dhZmEwd0ZWRGZTT0JIS1dsUXZZOGVvSTlsdkh0K1RiUmZDUFFLRTFDQXFWcG5LUXpJWjRpZU5FajBzV2FZN2loTFNhVVJJYXZFUjRvSGFuU1RoVUdtYWx6QUtyY0poKzRkS0FxeDVqck1JeHhaamVOMldFTkYxdEpFc3NxbUlwMlZCMUxXUk03WnMyZWthWFUvUFJDRmlQUlBNcTEzMndxZ0FOemN4QW5aTXJVRVNkT08vbjQyMUpBR3RNRldFbzg3bkZ1aGd6ZFVYYW5VNW81TXZWRXVuZGtxS2JNWEY4YTI1ZU1mWUhKbXRxTkJJSVJLSnFiVEpTN2lDWlQ4UUZHWFhLb2g5SU13ak5TTUR2OHJRa250d20yL3A0dUZjWTZ2UUZ1cVZ0eDJNU2liY0E2WnNTamR1S3U4YmJCOWwwWTNGMEp5dzIwbG1qTnhNTTRYNnd3TWNpaG1tcEJHM2RiVzF5THBwSG81dUw4dEc1Skc3dlEzcEN3VTJXRnRXa3FrdTFTZnQ5UDBUalVCSzk3dUpHTExDTFFsdWREOTNyL0FCVzV3SHdPaDlPbFFlYlNyZHAvQmNwVjlqMTdjY2o5TGh2elhmU2Q4cjNsRy9kZDhaM0ZsTXV1TE1wbVVqNEZtYW9oMWRTaTBXako2cU9EWUxkZithKytGTyt2blN4ODdmZmVOMTFOMjRYT0dGYzBPQkJQSGZDNlZ1bklFRGlRYWpoTXU3bXZubjBrVGVSN1QzMUZrOEdXUnQvK3djRHA0QkQyMlA0MzNaQmh6dEVnU3R3Q3R3U0RHNkJDczRLNGc2b3YrQ2NlY25KOVQrVjg5eTRuRi8zbFgwMyt0N2h1NTk4MFIxaXIwRDVHaGJtd3g3NmtXYW5hVFhKc0tjc0dTekF2bW40TkZkMkxNVEpsT1lFeE1QekFFZW5BeVlBNmx3RUVCeWN1YjhvbXdsbHp4NGxZU3FGKytsMzA0ajhPTklnOXF3M0FFN1VROW5LNXJsaUtxaUpIQ0QvOFQrYUViVmdxamkzdVpJTjZTTHZPYkxMTnRBWlNNQ1JHbjZBZk0wMTVHRTFSaTB3N3kxaVQ5TjdZZURPZ3F4YnFTdFRsaTRMM1BrT0hIWHZQdDgzQ1dKMkM4UytJRU80UnVET0lSRUdWSnBqSVBsdWh4SnZJVHRhMXovUUlNWmdqYVNuL29ZZ2h4QXZJbXBVZytjRzI1cUdWTGVMcTNzS1pERk4zOFB6d1FxTnJ6cVBLUzFmaWNhN3kxUERkbWFIU3Q4VFhuYm9CRHhMM3dvc1VlOFFCcUJLWGRUTDBBR0lhM09UMWNwNGlkZDVvUGxUaFV3TTA4WTZYNnBYYXNqZ0FoUDEreDUrVDMzU3p4bTlGMWx0aUZRM1AwdXE5WFFSd2phRUlLd25URDFGODBWUlFsc202MU5UOWNrdFNOYWZZTVlyT3BuZ25wREFpeUhTemhEdjg5b2N6UkphdDBQTjlVY3dZTFN5SThvUkZITjlBb3djUGJ1ck5qRUdGUVYrakNSajFkM1ZGS0hpUGtyM3h1dTlIeklGYVk4b1BiZVVxM3QrdmEvMi9QVkt0VnI5Z21kL2Q2MjhwYi9yeUFjSjFnU0xFNGFwc0VxNVB6M05rV0FDTmdkTXJGbXA5VFF4L20weTN2UmZLazRZcnMvWFNaeXd6a0FIRFZhRlNrLzZWU0VXdWpibCtqSzFORzJJcUhCTGUvczl5OXZ1MmI0eFZOajRaWEV5NU0vYVpxbXJsWEU3VXBpZ0NIbmVpUlJXeWRINytHeGV3TUhraU9PNVpwckc1SEtGQmNSZnhzdTFvNEVkRng0UG9qQ2hMS0lHZ1UwZ0V3Nlpnc2ppUm0zUU8rMVdtYUoxT2VDbWFRQ0J6OEdvbnI5NWt3ZTZ2TS82enpIN2l3KzF4cENnOGh3MGRKNUhnb2o3WHhRUXorc0c1SGhWUUdNdFRENnFhQmJQRTZsWnBQSUluTFJ2aTVOcVg3QTQzeGRnVERDamtLT2FzRlNNcGlBeVJBaVJxUkdjUk0xRUVJb0dncWxvY1VuUU9GVkhuRWI4NkRRTzZacUxWM01PZk5hWDhOWHgrdDdISkhmajl6QkpIdTROZmdpem84UW9Md2JVUTJQVWtqOXdUdVJqbU9VZ2lFRzhLUDZBNTM4Z3hucjdGUU5QbDJkNDBlZzlVQ1NzRStiK3VpUnliVGZBaTR4MkV2bUF5QjNpOEsvM2JVTmhLS0tLY1c0ZGllR3dpTmJKUHlKVGVQMk4zK0VnK0tadmpGay8ydExTS2E3ZER5M0ZWQzhrVUNEYnNqTEd2Uy9pVTlublFRUnJGWnR6c0FnMGJrTVFKc2RXVnhmQzRiRkpKcGViak5TM1JDWkpMRnY4TnhuWlVzYzd1RnpCNTRYREM2dXIrRHdCaEN5RWVydVlaUWw0Qm9Ycmc4ZXJua3RmOGR5eU92aTAzajNFSW9WNHg1SXR2bDkvamlJMjAwMUdKN1lIM0lZY2lOQWhLSld3YmN4TzdVdGZxeStNVXdPVzJzNnJkdFJpcnVEeU04eUxjdjMyOUhnOUhTQWtiYUMyczFiZldidWRlbm5RNUxHZ1pRVWJKTEZqUnJLNlhISk56di8wQ3o3V3dTSDlHclhGaTFCTHRXWG00VTBIcFAyaTJURHRSUHBUOElCa0lvb2NsOTJPa3dGVlBBd1A2WXI4R0F6QXgyUkZQMlM4aEJrQnFobzVrYlAyVzdrVGl2RitMYURoWDlmZUdNcnBPRDRmbng0L3JSaVNJMGlTckZ6T2tveWpFamxKazlqRzU4U1paL1BQTmNOWVFJeDBZZGFNTkxZbDBjWTVsQ2IwQnNXMnFSMDJOa21aMnpBU2d0RUxCZlNsUUhWTThWdlZzQUlGaVF2eGltSmFsT1pLQksyeFlDMUZnbUJaTVEzeEVnbEhpVFRMamhZVHREeFlRTHQwdnlvcGlhQXFRcDRUTXFLS3FkbzgrU2dMVXRES0ZpMGpvQ0pGTTBJNmtqaCtqSWVjSlBraFBTR1B6UGlPSVJ6M1F5TnczSDlxVFIrQWUzLzhMVGQrQUEzK2hYOTI4NWwvQTdYSkpuYi9QdE83NHBnVmdzMXRSK04xdm8yejVXNjUzTDJjSk0rMnB1Zm5hcTFzalZXbkJ0YnRBempwZmRmSWMxemFrT1p5QjBoOUQrVG1QSEV3TlNZZjczamw0WGl0eFVOK0N2TmhtQkxERCsyNDZ4ditSS1grd05tZHZ2SHRONmI1WkRoYmUzc3RHMDV1N1lNVGUwYkdRcjNScUljem9sd295R0xtOFQ0UXNtdDNUK1JUSkk3SExTUWFrL01jL0V6a0lGMTFLaEdLNUVTNVFlSWwzaVNrSCswT2k3aVBNNWFSWWhXMnlNdVBwSmt2TVRVR0dPNjF2bFQ5R3FacGZUMmZLaUtZNWFIQUMyYkJDa1JOZ2VjQjVETlFLcVl5dVhvNUZNMU41YXhncU5aaWhHNXJ2UytEUDgzMHZaOFVPK0xFMkR5VThUb3U0TGtlQ3VQUk1ZRlBoV29DeExzQ0VJQU1ONDlOaUEwamVvYzRacEp2M3h3VDM4YWpwZG90aEtTOHBiWmt5N3NKL3NNcE9nWjJYTW9vdUJUVU04OUkrZVlpR1NtTHFXSThDTzRLeG90L3ZBT0paUkh0SUVPeG53V25QT1BubFFBWlB3RTBOWllOeHVQQjdOalUyNGRPdDdNT0RqWEJLOTNzVzhSVThWME1KWGtjVUpQV09XWTBRRDN5aUlPZUhkcWJXc0JhVkZRODJEUlV5UkJNMjhZTThVbHc4T256VG1hYXVpd3NnTFlWYlhiYVZuTTJBajRVNFJCYzBOTDVVZzdxcW9xaVNzb3dVa29VcWFvT2M2VjhXdHNNRVdlbDh1d3p5ZjFWb3hHYmo4VWFTT1NnREZWRDlTUE80Q1JETXhTOHo0bEFBZFV5SjZKeUZTaS8xSUZLUEtYQ29CbUVWaXhxeUNJbWlqQ2hKTXBHTkdiUllqVVZWMkZMblVudko5L1ovblRqeSt1eDZ0cGFOWFljcy8xUmhHY0dLRVVodENRb2NCQkZjYUhNQ3pJQXNzQy90WGZmUndrZHFkZ2poeXNYZVBkUFlYSWxnUW1IbVJsTWJ5UUVvVEcwZjVGUnNQYzhsem43cnMrV3o1blR3RVZiQkVoc3p2SExyaVhKOTNlMWxoZW1kOUZKN1JTZDFPd0RPT2w5S1ZUbXVId0lUMm9sMHRtbEhKbE9mTkRXaDYzWnZsTk5Hc1ZsOExuV3FPZGFqdU5EenNsWXJia09kTTliQUNYaVRWNWhFVlJwVGJ0anhLZHlNMGsrV1MzVUsrbHFQQjN4QThrZlNlOGNxOVUyMTJxOSs5bTJwVWVuUXNsQUdDLzc0T1ZrT0JZTjYzajlENE0xKzNLYy9JbVM0TGlvQWl2eHJaakk5MitOVjNSeXBmTTd2alVXVVVRZENZbEFUVEh1Um40QWxHaHMyVkJxZ1VSZnppNkE1MmswQnlxd2JidU9yMVBBL3RENkNxaW9iY0NDR2J2djNNdXI0QzZveHVYN09BM2NpN1NZSEUzT0JqTkc0RnV5MUpRdDZlbkNaZWxRS1J5QVdnenN1UmRvM0gwS1hnL3Y1RFR1WGptbXdVQzRGTXhjbHY4dHlaS2Jrdnl0Z0pFSnppYWorRWpmSm9Yd2VHR2ZUN1l0ZnZIajJkUEoxd3crMTd0TGxtZmtoUFRvanRaVU9pbkxnWWdjQTEvcDNTWEY1WWJDeVUvS3NmQjRaWGJxNm9qc2JXZUNSWFdrMDRLblhWUmlVQ21EczRueDJyWFpJa1NSUDJLdFdLL1VKNHFaTEJuVVNVSElab29UOWNvNnEvTWY0ZG1sbUwyMk51NzRVUkk1Zkp0d01xYlZJZEZIY0I5U0QrUG9ZTWJ1MVVyZlppdFB2RTN3eUtiZlhnWFhxdjEzallBVWkxd0JwQ0NFQjREQUhaR0NDTzRESXJnSmhoQVJFZW54VGNuYUU0cWNWWkx5Zjc2MzNRZ2x4ckpLU243WHBvK3A0Q3ZmSFUvTng4TWRJS0lndWdsZnRBK2lvSFFFdC84QWhFRXBHQi9YNDFKZzZ1ZVZwSkpSbEI4dmR1N1VRMXl2bXBYVkQyNTdyK3pZckh3Tm5NTHo4VGlSRTV1TkdXcldaSWZySkxIQjhTaWZJU3I2Q09Oc0NNczYyMm5oakdsclBvaThoN0RjMElxZUNaU3lPdkFyWGNVUDlHd3B3RVV0Z0tkc1RCbEZPUWxuOEp6ekhzeEpxZlBVNEgyWEdWRTE4QnMzNThzZDdWWEY3MWRlMVRybC9NMnlKQ21mNExsUEVsQ0VUM0w4Si9DMjl5ZlBFQndHY0VZeHRrek9OT1p0bnBMNm1kUjhzelFHRXlNS0xrR0pXSEV0MWZxbTZDT0FVTXVWdGgwVENCT1c3U1lOaVFWQnRyS3llaDQxNDFtbUxBVDdOeHpMSkNLcXRXMTZlcHVsUmlxelJFMEpBamhsT3NnNXo0a3MvcU82Mm1TNnlqczNIa1BoUkNhR2o4V3k4UXk5M3RWakxPTTV0T3c3NEx2T3ExVkZVWXMxRnM5TjBlYXNvMEYxaFAyWHFIUWxNZ3hiSGNETlVXMXJvMUNmclF3MUtqb1Q1QlhpcFhzK1BTd3U5K2hnWjZLWmdhYlVDNDJBZ01SOUl1cGVvR1B3b2JOZVhmSlprTVBySVJrRGIyVUVYTXJydktRM2hkZXhuN3h4QnZ3NStBMDg3NlFwVHBxejNGSk0xbVovdlVXRmpnVytlNXFIUEY0dTFiOVB3NlMvRmgxUC8xaWxKYi95Yng3ZEIrQnB2SEpoRmtEN1VmcXFUQ2hFanVGRGFQdWoreGh1Qk1WRnRhakZ3emJmTHZ6Vk5tMGg0Z2dRYXpBa1VBRVhPSGMzZlIxT21KYTkzUzQ0K3hNcVVPU0lRTEgzb3cySDEyaWdqM09lZ0gyOXN4NG5rWTJINlh6L0J0RndVYy9WUXQ3djFVaXhPbHJ1ck1JRnRMQnhsSW0wbVRqN3FCRW16cDVnelRqYXBkb2xlcVI3MUdDSGlmL1pQMkMrNVJ4NDFpZFQ3SWt5amRUbTY1UXJCc0Fmd3lLZ09ieTF5T0tDaU5vVHo5RTB5QzlFUk14TVl2bDA4UHB2NHVrN1NwaUk3NEhJanB1RGVBMjdQQkF0N05qbGo5LzhPbXpPTlJ2akRXNW0xM1J1OFpHZGFhMWV1ZXFMVVdYTGpza3JjMWRjdHVuaGVnVk9UdDd3SCtkbnN2ZnVuQzVzdWZWMEpWcyt1WC94MW8vcy9mZ3NOQ2JmdVpRTWpJMlB4OE8xR1FXQWhmSjBNWk5TbzBId3NkYkRPNEFmN24vUW5wZVpqWmFKMjBCNTNidzNMZ29OcDBFUmY2bENnaUNuNFhVTitJaUpML01FSUFhOGE3R29takNnNWpkVXdaOVF6U2c0Um93azBXSHFGSFlZR1YrS1QraDQ0azRndVNDVCtDaklxSkU0bEwwM2ZvLzdBRjRUb0UrbkdGMWI4U2hiOWQzRWtDR0p6VHpSdzBQVW9XRUNMYXFNSnpWQlEvdWkreG15S2NkcUZHaE4yNTBLcEdnMTVDWFk0RTRXSVRsZVNaSktjN0d3RXBQZU1iUFozMHJzWFNJTktLZHlvS1BNMWttKzk5L3pidnQrRmZDSzZFOUVsUHM1b2xDSGY0alo1cDg4ZzhKUXdSbHVGODZBbTVMSVVKYU9XbFVOQ3NxL1R0KzJwVmFwYmxxNi9PRUthZmJoNE9hOEpJK1BaWm9IRTJRLzdQU0xjdndCanZTSElkMnNxUWEvUjhKMytnYStwNDR6dmEwNDQ5QXVid0FmZlVjajM5RHc2eGp1ZlZzRzlXMDhkeitMNzFIekxmdXVIbjJuRG4zUmRBbHkzbldMeG8rdERCeWduVXJtdDR1T2pDL1RjVEd6dVRsRk9sRGR2TEkzd3JwWFMrWEdFcXFJdTFPUktoTkhMamFBdHRQUmc3dTFjelJEQjFEdC9sMlhQL3lmN1A1RXVIOHo4eUVwb1Jvd2VmWDBpTUVtMkRqUHovc0tMaTFlS2lQUkFKNVFyY3lEM2hNMG9ES015OSs4U0FoVDd0YmUzNFZDdlhOR2dNNUREUHlJWmdORzd5VUhHVXQreG9FYmxYL2ZMUU43NzVHa2UyRE02SDJPUnJXaVRwKzlQNmI1ZzBZTTl2NnJGNi9VU2RiNldVOGJtWC9TVlJUUmFWQ2VPclJmR2RydkRQYUpCd3pLMHlldjlTZzRORGhPQTh0Njg3OGc0SC9nYnB3LzF1K0gvYnhvR3VBQnc2VFpnSEZrSU82cWsxM3ZaejgrMEJHdkVhSEVhMjQzT1BKVWNBK1YxU1F4YjdVNHhLRjJ2TjVYbUFqT2wvdk9VUVpnQUR4OXBUaGhCTmFwaHVZSVZkTVVWcExVZWp1NVV1aG5ReWJQQ1RVYVVGUmNFQlJ3M0Q0Yko3RllkSlVNOTlWb3JIZThuLzhBWVR6VE41SkYvSjFRR09kQkgxUHM2MVNiMHlMclV0U3V0Qk9YMmJYZDlVcWZDRGxNcUgxYm93UFdFd21xSzBra1NOd3JzSWJULzlablZzZHp2S2FKWEY2TjVTd0xyRTNlVGpRcnQwK1dFNzExZW5vM1VYN0QxK2RmSDF1Rm9xakJmU3F4NFluWitsY096OGsxNG90WWNnMGZDc1NDbStCVWNwaHFkK2xaaS9vRmQ5clJTb0hveUthSTRLdGlBQWR0RTV3emVBRXVhd200K0hOYWlNdFdrL0VDbDQySkh5QkQ5ajNpQitXQXNLa0V0Uy9INEZJOVBaZk94T1hacmZnVnRBNUdGbE5RNTNOUTFqNGNVUDh5V1FhZ09GdmljM1M1enlyUysweE9TTlU2NmJtdFRmK0tlYmlEWDkvbWFaL3d4bXR2L0JVZS80LzRKTHdhVTd1L3ZzZVlhOUdCR1FnaStla1Fqb1BvMjlzT2JCTWVDSGhzbEFqUGJiVTdsaU5vL3dHVHpmM1RwMFJPV0JVMDhkUEZ4YzBQVE15WWFWVXJKOUxtek4zVEJ3VU9LSndRRjRXVTNIdWZFamVsY1B3YjlTMTEvRnRuUXJucWZZSXUzaUZ5L0xXZFdEUStNZlBoQlRsaEpNcFdYRXd2Q2JLWUZ2a0l6d2ZnM1pJWmx4UG02VFM1dEc3ekhnK0FKNTA0OWlXM05ReUloY0U4ekRMTDVsbGJFbDFHckp6U0dtMHFvKzZBTmVZRTkxRVJpUE1uVDg3alRWN1V4TnF4WXpXOGVRVHZYdnZPdSs5KzU3VzBYQmQyMzNUOTlUZnR4bFhPTXJlNFcwUkRuQzBVWnZFbUx3aUZlTHdnQ0krS2huQWdoZjhkRUVncEVGY3MvRzlGQklJSGw0dkZzSzJQaUJ5eElmeVdteGtBYmZrTHBpYy9NckFadEVQdjJucnhnWTJMQS9mUHNZMzNWdVNZSUZUeEI3MXRSVkJ3UnRpMnpkN2Z4clA5SWR2NDc1N25OR2Qvb0g3eEVmMlRhemw0THQ1YUZIdHJ6RUJ6OEhFc0tCWERTc1UzUGtLd1VvZG4vb0g3SEVtRnMyUW42MkthT1ZnUk9ZTHB3SEEzN2NpVVRPY3hyQU54NDZCenZsUzRNWjA3d3dqak5TOFJ2UjJKZnlHaWZ3SW5TZEdaM0RTeDAzcTBmempWSUxXZTgxM0tlQkV2Y2J6MFBuUHhBWE5rNUlDeFkyQ1FlSUduZk5mNER2dHU5UjN6M2V0N0Y1SFoyUXlNYlVQdEJ3VTcxRjQvbCtrVEN2M1lEalppMlJKbzluUHV2WEpOVkxEb0hmQzgybHppbWhrQ3JGUm9rYjFPb2RMa2FNaVNoa21nVDBVSWpIOFZCbENjRUNBSXZ5TUlrRkNIQ0lSb0J5NUtPOG5tNmhxQXdpWUJnWHBubk9Ud05YVnFNNzhUOVg3eGdMUlNFWWtSRHNlcjVWVk8xTkFkUEo3a2VVR3I2TnZRQWVDamJPWUJnbkIxN2JXQ3lGSlpQRUNMc3pUOUNpbitDa3RaY2ZaZFprd3dnb0YyVjdheTd3b0VEU0ZtdHJ0WkJ5UHZISlcxcGFtT2xXQ1RPYnJES0pYNU1HUU44czFoL3NmVmFmNDVRb0s1dkVvWTRkVmxVMERvam1wMTVWdWhkc2w4UVdzOGFZZUgxbUMyWEY1WjNWWXBaNkUyUDMvakMyYXBIZnBXcHZGcE50ZjZYTjZWWVNMbjhFcjdDV0lWNHdUQWR1U3E1dEFYd2hlQ3VlQ1ExcmNTdG9FT2JQRk5rL0h6QkY2QWpUOEdmT0RnQzR6SURZWERZZmVJbkdNSXNML0VObi9sNFg1Um8rZHJ1SHVmRnZrVHh3anRjNnhMclI2N3hKd3gzR1ZGSjBocUg2WmhPOTNpd1RDQ3dBT3AyZXVDSXozUC9nczhwbW5JdFZsNlp3S0VpRE4ya1NlbDdIak1LWEJ3bWQ4QlB1dmJhZlBYRU5HaFhCNytIQzRvSStrMFBSOFh1SGxaNGp0K2paTVV1Y05MeXdqeCt6ZVRJWHdvVEZHeTdxS1dZaXdicGtDL20vZnp4UHppbmtMSlNrYnZRUnI4RkNYUlNrbTZ1WUdjY2dQTkVudFl2UGtVMUh5Ky93T2w5R0VMQUFBQWVKeGpZR1JnWUFEaS9tdkgvOGZ6MjN4bDRHWmlBSUZydTVSdXcrai9YLzd2WW1waFBBUGtjakNBcFFHWjh3NzllSnhqWUdSZ1lEencvd0FEQTFQRC95Ly92ek8xTUFCRmtBSFRXUUM2MUFoREFBQUFlSnlWVnR0UnhEQU1sSytTSzhXbFVJcEtvWlNVUWdmY0I4d3dnR05zV1pKWFRzTEFoeWJ4UzVGMlYzS0lpTkpHZEtOcGZSeXRsaHUzTmE3N0xkYzk1VnA5cmI5MzYrZG9qTkZYOE1uZ1U5N0J6N2F1eGZmZi9UVS8vL1kzWXU1UDhVY1c5M244WXF4cmJOYkdPaWUrSHpMZTAwUFh3OTRUeXhxTDRJbStOQjhXUFBlUTcwUFd2OXkvY3VHeHVlbDhWcno0aXR1akJUOXlmc1FROEcvenRBMDcrTWg2YnB3dDBkL0V5L3lrSExGS0E0TXZXZU91cjdqUHNMblMyVUhIZHY1Q0c3NmZMM3c3MXd2bk9wZHNqaFVuZS9aY3pURG5EWEsxZUJHendPWFVYT0FIOWc3ZEQ1emtXd3lHOVNqam9TK2JNdzRqZHVwcnhUWFhzdkk5MTJET3p1YmwrelM0OWR6L1lsZ0x2MWpVZmF0QmhqZ2t4dnB0NDFHcnNuZldFV0trK0thNyt4UU5wMmZYUWtFT3JaWVYyOUsvSlpxZ3FSUHZvZGhuTkw4WnA3M1BXTWMrMHhIRXYySkFBeWZNK1daNnlOQmpGazZGZTE3NHprdGVMWjdXaDBwNmFxYlAyVlBxWjNLOVlxMjNNeHZpNG5WZC9UM0RPTVE0L0JIbWFmRlpMYjIwL25CdnR2QnZuSG0vWThpSjhONks1dmxTeEVQODVYTS9yaGZsdXNYK2VhaUxnY1d1ZDg3dWxsV1R1dFl3ZkxQNXRXZGM1ckROSEU5N285ZDcxRTNRUFBTYXVkYnFBblFTTk9zY1dEOEVqV3hRci9aZHk0WGIrbU9wTlpyeHpiNEIySHFNaGpQc3krN2pHMnE4eGpNbnZZbHN2dU11dFZxR2JydTJ2WDVMMEFWRkN6RXN2by9jbjhSMndCYTRYc3c0OUh4NThqRCtNeUxIczgvMi81dG8rRy9qdmNMOEF2YlNyM0NkbGRjWDY4bjJ2YjVQK0MyNEYrOHMrVjljK1NUdEcxdU0yL1F6NzBqOHQxRzlvUmF6OW1TTlA5MmxMeFRINUxXK0QwMjNHQWppNCtYTzRQcHh4blBvaDZUeHRIMC9FMDVhRndBQUFBQUFBQUJtQU9ZQkRBRitBZGdDTWdLT0F1Z0RtZ1FjQlBBRmFBV3FCZXdHTGdad0JwUUd1QWJjQndJSFNBZCtCN1FIN0FnaUNFZ0lnQWk0Q1BBSktBbE9DWElKckFubUNpQUtXQXFRQ3NnTEFnczZDMkFMb2d2a0RDWU1hQXlhRE40TklnMW9EYTRONEE0U0RsZ09uQTdnRHlRUGFBK3NEL0FRTkJCa0VKWVF4aEVrRVdvUnNCSTBFczRUSkJPZUUvNFVNQlNPRk5BVldoV1VGZkFXZEJkQ0Y5NFlSQmlJR093WlNobWlHaXdhbGhyeUd5UWJYQnVVRzh3Y0loeGFISkljNkIxVUhhSWVOQjZrSDM0ZjNpQXdJRm9nOENGTUlXSWhvaUlTSW5JaW5pTHlJNVlrTkNTTUpNZ2xEaVYwSmhZbWZpYktKdm9uY0NnRUtNQXBKaW1XS2Y0cVdpck1LMGdya0N2dUxHd3N0QzBHTFlRdHNDM2NMZ291Tmk1UUxtb3VnaTZ3THQ0dkRDODZMMVF2dkRBd01KSXd5REU0TVlveHpESUVNajR5WkRMY016QXo2RFI4TlJJMWlEWFVOancybURid04wUTN5amcyT0pZNDdEbTJPZTQ2SmpwZU9wWTYyanNjTzJJN3FEdk9PL1E4R2p4V1BKSTh6ajBJUFM0OWJqMnVQY2crRmo2bVB1by9JRDlVUDhwQUZFQnFRTFJCQ2tFNFFZUkNBRUpHUXF4RERFTk1ROGhGT0VWaVJiUkY0a1kyUm5aR3ZrY3FSNVpIK2toUVNKQkk1a2tzU2RKS0hFcHdTc0JMU2t1QVMraE1NRXlXVE41TmFrMmlUZHBPYWs2SVR3QlBiRSt5VUM1UWJsRElVU3hSVWxHc1VoeFNkbEtvVXZwVEpsTjRVNlJVQUZSWVZLNVUzbFZJVlk1VjZGWWlWbUJXb0ZiS1Z4QlhibGZvV0ZSWXdGa1NXVkJabEZucVdpWmFuRnJzV3laYllsdjBYQzVjZWx6TVhUQmRtbDRJWGxCZXpsOGdYMzVmeW1BVVlHWmd1bUQ0WVlwaDNtSXNZb3BpMkdOT1kzaGtObVVhWlR4bG5HWGlaalptM0djbVoyQm5sR2V5Wi94b29Ha01hWFpwcUdvbWFuaHE0R3MyYTJ4cmttdjRiQ0Jzakd6OGJUcHRrbTNZYm1CdS9tK2FiK2h3SUhCa2NLWnhDbkZ1Y2RSeU9uS01jd0p6VUhPU2MrSjBoSFQwZFR4MW1uWHFkaGgyWW5hS2R1aDNGbmR3ZDlCNGxuamFlWXA1MG5vZ2VtaDZwSHNLZTJSN3FueEFmSDU4MG4wcWZYNTlybjRZZm5wK3BIN3VmengvZEgvYWdCS0Ftb0RhZ2VLQ2lJTFFnMEtEc0lQY2hCS0VQb1IwaE1TRktvV3NoZ3lHaW9kY2g4YUlSb2htaUtpSThJa29pVnFKZ0ltbWljeUo4b29paWxLS2dvcXlpeVNMcm94b2pNcU5BbzAyalY2Tm1JM3NqanFPcm84Q2oxU1BySS9va0V5UXZwRW9rZ0NTZEpMbWt6cVRhSk9raytDVUVwUXVsR3lVc0pUZ2xRcVZkcFcrbGVxV2lwYXlsdUtYRXBlaW1CQ1loSmtPbVRTWm5KbmVta0thbXBySW15Q2JVcHVtbStpY0dKeWluT1NkTEoxaW5iU2Q5SjVBbnBxZThKOUFuOUtnQ3FCZW9McWc5cUVpb1VDaGZxSENvaFNpWktLcW90cWpkS1JLcEpDazVLVTRwWXlsMktZc3BwU25KcWRtcDg2b09xaVdxUHlwUkttT3FlNnFUcXBxcW9hcW9xc3dxM2lyeHF3UXJKaXROSzJZcmhDdVlLNlVydWl2VHErNnNCQ3dkTERJc1JDeFlyR21zbnl6QkxPcXM5QzBKclNTdE5LMVlMV3d0ZnEyTXJhUXRzYTNGTGRLdDVTM3dMZ2l1SzY1TXJsNHVlYTZMTHNpdTM2N3lMd2V2SzY4K3IxT3ZiaStJTDZRdnhpL2lNQU93SXJCSE1Ic3dsekN6TU0rdzdERHlzUk14TTdFNk1VV3hYVEZ3TVhxeGt6R1dzWjR4czdHOE1jbXgxTEhmc2ZzeUJiSVJNaVd5UWpKY3NuNnltaktvc3RHeTg3TU1zeWt6UmpOWHMyU3pkTE9HTTVLenJMTzNNODZ6N2JQOXRBaTBHYlErdEZxMGN6U0J0Sm8wc3JUSU5PZzFGalVwTlQ4MVZUVnJOWUUxbExXd3RjMDEzVFh1dGZrMkRMWWp0am8yVGpaY3RtNjJmN2FMdHFlMnV6YmR0dlMzRDdjZnR6RzNSTGRNTjI4M2lqZWdOK2s0RkxnaU9EczRVVGhqT0hZNG5EaXlPTSs0NFRqdk9RWTVKVGxGT1ZLNVk3bUZ1WjI1eFRuZnVlMjZETG9mdWltNk5icFB1bWE2aURxbk9yaTZ4YnJkdXVtN0Fyc1NPemM3UDd0ZnUzdzdtVHV3TzhTNzNEdjJQQTA4SGJ3eHZEdzhRenhUUEdROGpUeWRQTW04NFI0bkdOZ1pHQmdPc3Z3alVHQkFRU1lnSmdMQ0JrWS9vUDVEQUE1QndMOEFIaWNwWkhOU3NOQUZJWFA5QTlzdTFLUnJ1U0NVZ1FoTFlWczZxcWJkbHNvWkNuMFo5S21KSm1RREMxOUQ3ZStnNC9oVS9nQTR0cTFOK2t0cUVVUnpEQXozejF6N21HWUFEakZDeFQyWDVQbm5oWHJUZUVTcXJnVUxxT0ZLK0VLODUxd0ZRMU1oR3M0eDcxd0hiZEloUnM0d3lNbnFNb0pWeTA4Q1N0YzQxbTR4QjF2d21WMDhTNWNRVmUxaGF1NFVKNXdEVGNxRks3RFV3L0NEYlRWNjlERWxnWmJuWmxJZjJaeWFaeWFpUW1EeGJGTXYrcWVUclBBeE9RNjNkd2lEdmNRTjlLeFRxZFdMMmkybzJ5ejdGbnJrNSthaUhLM0RrTkRTV3JXZW02ZGxiVkp2OVB4UlhmbUpzSVFCakVzQ0FOc29aRnhIZkgrazA1d2VZNzVoUTIvdmtHSUFJcy91ZWtmZm8vUFVuWUZSVi91Y3ZoUEhWSytacmhIdHh1eEdoY0pVM1pyVmdnejdIak5zTUVTUFZZdGZLNzlvak5pT21ScnpnaUwyeVRGMlpxVk9lc09Wa1ZYZ2o0NlBQeHZmb2RkblBRQm5vK0xpZ0FBQUhpY2JWa0Z1T3pVRVg0enN5NVgzbnM0RkN1VUFvdFR0S1c0RkdtaExTN1o1T3dtYjdOSlhtVDM3cU1DeFYxYWFIRnBDN1RRNHU3UTRsQjNkM2YzemprbjJjMWV1TiszeWY5UGppUkhadjQ1ZHdrdTBYL0ZKYS81aHk4REFrRUJpbENDTWxTZ0NqV29Rd09hTUFPek1BZnpzQlNXd1hKWURWYUhOV0JOV0F2V2huVmdYVmdQWGdmcnd3YXdJV3dFRzhQcllSUFlGTjRBbThFYllYUFlBcmFFRm13Rlc4TTJzQzFzQjl2RERyQWp2QWwyZ3AxaEY5Z1Zkb1BkNGMzd0Z0Z0QzZ3A3d2w2d04rd0QrOEorc0Q4Y0FBZkNRZkEyT0JnT2dVUGhNSGc3dkFNT2h5UGduZkF1ZURjY0NVZkIwWEFNSEF2SHdmRndBcHdJSjRFQmJUREJBZ0VkNklJTkRxeUFIcmpRQnc5OENHQWxoQkJCREFrTVlBZ0xNSUpWY0RLOEI5NEw3NFAzd3lsd0tud0FUb1BUNFF3NEU4NkNzK0VjT0JmT2cvUGhBcmdRTG9LTDRSSzRGRDRJSDRMTDRITDRNSHdFcm9BcjRTcTRHcTZCYStFNnVCNXVnQnZoby9BeCtEamNCRGZETGZBSitDVGNDcmZCcCtEVGNEdmNBWGZDWFhBMzNBUDN3bjF3UHp3QUQ4SkQ4REE4QW8vQ1kvQTRQQUZQd2xQd05Id0dQZ3ZQd0xQd0hEd1BMOENMOEJLOERLL0E1K0R6OEFYNElud0p2Z3hmZ2EvQzErRHI4QTM0Sm53THZnM2ZnZS9DOStENzhBUDRJZndJZmd3L2daL0N6K0RuOEF2NEpmd0tmZzIvZ2QvQzcrRDM4QWY0SS93Si9neC9nYi9DMytEdjhBLzRKL3dML2czL2dmL0MvM0FKQWlJU0ZyQ0lKU3hqQmF0WXd6bzJzSWt6T0l0ek9JOUxjUmt1eDlWd2RWd0QxOFMxY0cxY0I5ZkY5ZkIxdUQ1dWdCdmlScmd4dmg0M3dVM3hEYmdadmhFM3h5MXdTMnpoVnJnMWJvUGI0bmE0UGU2QU8rS2JjQ2ZjR1hmQlhYRTMzQjNmakcvQlBmQ3R1Q2Z1aFh2alByZ3Y3b2Y3NHdGNElCNkViOE9EOFJBOEZBL0R0K003OEhBOEF0K0o3OEozNDVGNEZCNk54K0N4ZUJ3ZWp5ZmdpWGdTR3RoR0V5MFUyTUV1MnVqZ0N1eWhpMzMwME1jQVYyS0lFY2FZNEFDSHVJQWpYSVVuNDN2d3ZmZytmRCtlZ3FmaUIvQTBQQjNQd0RQeExEd2J6OEZ6OFR3OEh5L0FDL0VpdkJndndVdnhnL2dodkF3dnh3L2pSL0FLdkJLdndxdnhHcndXcjhQcjhRYThFVCtLSDhPUDQwMTRNOTZDbjhCUDRxMTRHMzRLUDQyMzR4MTRKOTZGZCtNOWVDL2VoL2ZqQS9nZ1BvUVA0eVA0S0Q2R2orTVQrQ1EraFUvalovQ3orQXcraTgvaDgvZ0N2b2d2NGN2NENuNE9QNDlmd0MvaWwvREwrQlg4S240TnY0N2Z3Ry9pdC9EYitCMzhMbjRQdjQ4L3dCL2lqL0RIK0JQOEtmNE1mNDYvd0YvaXIvRFgrQnY4TGY0T2Y0OS93RC9pbi9EUCtCZjhLLzROLzQ3L3dIL2l2L0RmK0IvOEwvNlBsaEFRRWxHQmlsU2lNbFdvU2pXcVU0T2FORU96TkVmenRKU1cwWEphalZhbk5XaE5Xb3ZXcG5Wb1hWcVBYa2ZyMHdhMElXMUVHOVByYVJQYWxONUFtOUViYVhQYWdyYWtGbTFGVzlNMnRDMXRSOXZURHJRanZZbDJvcDFwRjlxVmRxUGQ2YzMwRnRxRDNrcDcwbDYwTisxRCs5Sit0RDhkUUFmU1FmUTJPcGdPb1VQcE1Ibzd2WU1PcHlQb25mUXVlamNkU1VmUjBYUU1IVXZIMGZGMEFwMUlKNUZCYlRMSklrRWQ2cEpORHEyZ0hyblVKNDk4Q21nbGhSUlJUQWtOYUVnTE5LSlZkREs5aDk1TDc2UDMweWwwS24yQVRxUFQ2UXc2azg2aXMra2NPcGZPby9QcEFycVFMcUtMNlJLNmxENUlINkxMNkhMNk1IMkVycUFyNlNxNm1xNmhhK2s2dXA1dW9CdnBvL1F4K2pqZFJEZlRMZlFKK2lUZFNyZlJwK2pUZER2ZFFYZlNYWFEzM1VQMzBuMTBQejFBRDlKRDlEQTlRby9TWS9RNFBVRlAwbFAwTkgyR1BrdlAwTFAwSEQxUEw5Q0w5Qks5VEs4c2FSaVdGWW9vYXJWOXZ6Y21waEZhSmNOYWtVUngzWENOc044eVhkL2s1NjdUOVZxbThHSVJOaldSWlp6T3FLYVpLenF5aG9TaDA3WGpxdUc2SXV3Nklxb2EvWGJpR3A0cE5qYjZJblJNdzJ0RnFvcmhkUk9qSzFxT2JEVUlSZXg0M1JJWHRQMXducCs1b21YNVNWdmRodDYwUlhhM2RNcWllcDJkTWlWQkxlTkRMNFg2UFJWVU5Tb2FKMEhaQ0UzYkdZalZqREQwaHkzRGpWdW1FNXBwN1ZkYlpVT3J2OHFxMmx6MktuTVN6RXhzaTlycmhINmZKeUdPL2Y2eVJWYlp4L0pGTnRYRDBrWEcyTTkzSUt2TlRxaXFrZXN3V3BrWTRhcytLN1V1K3F6VXV2aXpVbk1TNUd5eG4zN0YvSlJOejFUZW9ocWJtekx4K3pjbWhpUkltOGhOd0xRbDEyaCs0R2VuVEhMNkZjL1Z6dzMyYk00aTI1dkxjZFhhVE03QUw1ZzJwaGVRZ3FwVTJuQnVVS2N0dVZmTkQrYnNsQ2tKVWo0ZXhPYVl5d1pteGt4VmJvd3B2MWRGa3lRZHdVZ05vWjBuZzlxRVZGSm9aMkJRMG1BZEk0b2MzdEVEZm1XK0M0ODNZeXNhTWVwSEZZTnZvUlAxME9EdlRTekhiMWtpTWtNbmlCM2ZxN1FOc3pka3gxRnZHeFp2WjlNV1pxK29jTE50cUozZmlrekRGZFEyWkdIUGFobU9MQnlhdmlYa1N6VXlIQXJER2hPdTQ1VlRVdUI3eEsxRmdsdDBXL0pTeWRnc2c1Nkl4dy95M1BiOWdPdkdOcmNhOHplTWVIamR1SmtSMFEvaTBmaFJKM0hkTWJFTnR6T2JFVGxMMHZObFBIS055RjQ5WTdFZENwR1ZpYWd0ckVKYmlMRFdGdndHcW1oQnduTGJNVWU4TUd0dHgvTk5kb255aTV3d3RpMWp4STYzSjRwdDEvRzRydStxUzh5WGZyc2cvWE5GWHZwRzJHdTAvYUVyWjBaKzNaZ0VqaGRWMi82Q0hucGlWT1NmaUxqQWduemVkZjJCS0xkRHcyR25QTjhPSGRFeGVmQmFmV0d4TzNhcll3dVg0YVVnUW1vbjNVbzdjVnlMcXpOd1hmYkpuZ0tSR1BGc0pLSEhaYUlhMTVaZkV2dGhRODZ3WnhtaG5OQ1pNVkZ2MUJ4VDdqQmVQbUVMcG12MERibUlKalg2anBkRWt4cUJtMFNUaDdIVEYxRWxvOXc5UnhSRExhRVVjaFFKL1pJbVhDNklFbGRFeEdGdG5uOWl5cWRQVzlRK25iTG9mVHBsWXBlaXVZb29HaXFIb0tGMkNCcm5IY0tVSmRmUmxFT1lNaVZCUlhQMkRBemkxc1NUVlJXWHcxSTNSY2dobUtjd0ZqWFQxc1dFVWRXd0xjZEhJVjRqSWpVR2ptaW9LVW0vS0NXNjE2SWljM3lWc3NDSmJEL1FRNXN6MUZQaTgzNmYxVmdwQkZtd251TXpHdmZrOHVOSHRRbE4yKzk1OHF0ejdXdERXaTh3aGw2dW5xUnBieXNUSWJ4Y2I0cW50VUxlSmJsYWtoWVZYTWJYUWVoNytlbGZiRlBCZHBFdG5kQnBJMGU5ekpMVEo0dHRVODNsTmNyOElpTTc3b2xsNkkySmJLQ1pFUjJBTTVaYlc0dHRVOTNtMTlmOElxTmN5cWtsQ1hpVWVLODMwZy8wL05pMFM1ck1tcTRUcU5uV1czbG13bVdZcUk1cFVVMjd2SHBpbnErUjRCcUdDaEE4NlV2WmtsanFqVjNmc0xTUG1ETE5hWm9FMmZORzNsQlVwR0M2U2J1dWdnTTdNeGFLR3B0K3YrL3dwRXZNKzc0ckNoS1dUTC9URVlKTXY4dThHNVZOMzAzNkh1OGFMczVDVnZaUlRuRWx2Y3RDL1lBallVUGVsU0xtVXMweEdUcVdxR1JzM3ZTOWdSajVZWXU5ZTV3V3pGbTQxMkJVbFpkMEFrTHAvWlRFYnJVNUxQYW1MQ3d6UEY3VEUwdVo0NnZKY2F4Z2hpdysrQkpGdHVHRVVjRk0ycnhWK2NKdm00UXlBSkNaeEJYTGlBMFpFZ3VXTURwMWpzKzlXTy9mY29xcmxtTjBQWjZZcU15bzczc1dXWjVSdDN5WFE1R1M1QXFuVVhGZTR3NDdkdzVvc3AxbDB4WlZxamxsS3lwV3Mvek1ZVmF5MmExWVNiOHRnMkJCZmw5UnJCQm1QTVBVQ1ZoMHRHeTFhU2QwOG1Rdy9XVFFGRHpBcmgrSUZ2KzgyVEhUaTdxUzhSSjdmdzVqVlpHRXZ2cXlCb2NhbTZXK2todVZqQ3pOQmFEMGphZE11dFhsZVZNY09pcGpxT2VNTmJFUUtGWGp4dk1aSEF1dTVwU2xuaks1a0VvYWN4V1dEWjdoU2ordDNOZWEwNVowdy9LRDVhLzFvRGxsckhONGJsbThZZ0w1K1l5Vi9pQkd6UTZydUZhbTFScUtkZnhRRXVvWUM2V082SE5ZYlhRYzRWcXNtM2pwamVvZHVYQkYyRm9oNGtySGNiVlkwMEJuU3pWTnBDVFVVRG1KcW9hOENUV1NjNjRmODZnSmR5NkQ0d0ZVQnFmUHlhQitsZ3FUU1hlcFFSZFVDa0cvVDJCMWRCY3lIczVxNUE4NW0vUTVxZFNsbFdUUWNNQ2o3dXZ5UXorMENoTEpkdnF5SThuNkpiN3dCODkzbkZDK29jeElFNDU3SWl4SUMxY05lZFJZdmM3d2l1L3FqeFc4WlF1U0Z2a1M5ZW9kbG04OFpISjlsalF1ZEhock56dStuOU9vWTJZTHR5OUgxdzk3cnRPSnkrbVVGTmtmRExtQkpHWWxXTzZ5bmduWUMzWU5YdC9VRmYxYWx3V1FDRm5iUklVdVYydDJ1ZStveFJLUlg5a3BzdUJyaTJyWGR6dXFONDJrODV6cGhvYVZwQXZlQ0NwMnVvalEzaGJ0N2REZWZzNld5OVAybGZMak1MOVFWd2JYV2NVdlZWTTRNSGh0cFZBWXBwalZVSTY0OHVaNXJoS3JIRmVlc0premNQU2JNQkhPS0JJS1V6Z0Rmb0dxcHJ3WWRaM0lkS0xJRHlQZGV4VHdBMVdFUFdOUGxHMWU2YkhSSmR1eXlqWm5FdHhBVGQ0RG0yTlNWR1FZeGxWMWJRc2o1aUlMUnRmM3lqYkhNVDhjMWZXYWJ3V0o3RTFqem9mTVhsU3cvYjVvMkg0VU9MRmVsTE5qRW8zNlBFR1ZqSFBGSk5SendSTTBNMkVxblpqUUtGYnZrdkdLMDJKWHpsOVdjVGcyeU15cDdsZzZMa2dIbnVLaTJpRWxkZVVxbmxUOGpsZlZ3RS9pb2tJbHppRTRsRFg0bGtReHB5ZlM0MldrN25nZFAzVjFHdXY1TDBqTUxRMjRKbzlGU1g2TFk4NnNZRy9SOHVWSmpYUXh4RU5TNForSzk1WHMrS2JrY3BUbkxNdmxzRk4wQmNlVkdWZndNbFZyUWJudkNXMW9tS2k0Vk1sSWxSZStWQ2s4MzY1Y0g1eG10QXZTbVRGbFNTLzlkMFdLRFRVV0N2Q1dVUGZFTGNqN0RFc1B2YWFWbDYxa2dyU3BnTnlKa2xYSHJDRFJNbFlxM2RiMHNjeGltMUpUaTJ3Nm1DOHlza3pQV2RRdXlIRzFDM0pjNzRLY2djV1l5N2VCRThsODJrMDRQRmwrV09TSmRzd1NYejJXQWRJN3ovU05RRzV5ZGpwcVpDZTBMQ0huZ1ZWNWx5TVdFYU02UDR4U29kbFVtQmVCM3hNdGU0b042amxXa0xqRURyZm54TlFYZHBrbEZTL09VYlh2c0FoaHJ4L01LS1IybFh5THVSeFYwYVkyTVRTVXIwNFhYRk9UZE4rbHpEZGp5ZEtDYVNLaVNLM3Z0OU9Zc3pTREhvYzJSOHZIYVZOSlU3WjZ2RzhadW5xQXhyVFE5em5ROUgxZTNpb0xiL2I5SkJLWjN5bjJrNGlIMmhNSms2b25ocEh5Y2syV3dpTEtvay9EYjB2ZDB1cUdmaExNcENUeEZDMm4zMUhtZlNpM1h6MHdwSHRyaHdtUFJ5QVBROVh5TFdsWVY2MXowREk0TTFOWTZtaEdvY0VPT3JDTGdUeHhhUVNHZkVVOWVFVkZpRE9oY3JxZWEvS3VCNHdZU21vNnJ1NUZRVm5RNDYxYmx1MnJkNXJNVVNQRnFucEtCbElnYzBlU0ZBTWVzNmlxM2xBMldWU296dGRSK2tJRmlmbVNkT3N5K0dZSnBjTHBGR3VTam93dWxib2JpY3VCYjVuOG5SVDRmaVh3d3pnMFdDWUVmaUpkTzYvZ3FvcmtMVmJ4YTBpOW5SMDNxUU15dlN5V3ZZYTlHSVF5OUFlOFZJV1Y4UE5Ha0t4YUpYV0J3MUdsdEZJZEo4MXkxaGpsVk4rRXAwSXk0OVdWaVdPeGVqSHQyc3FFMTRMTzlqVlV1N2djR2lZWGprdWNqMWgrZnhtSHJqZzlhWlp4aVdPc1dEcXhaVjg1TXpGSkpWaG1LdGRraGFXRXI3U0lCTFZRZE9WSkhPTkdLRGpVeHExdGxkL01TQzBGY3NZMXJQTE5sUjdmTFNwVUQwVThGSHJwbFZOY0NGbVBsMlJNRlhFdGpMSXBJWWExVUdXa2N2QVpCa0xEUXNTcVkwNmV4bms4SFpuL1g1WVpZcC9kRmM4Q3ArSGwxRlpobXJEY0R4dVJrRUpSSzdaNlN1VGNselRtV3pqZ0RjZnhXeWxjZHk1RDJVbkkrRkhjMENqMUVJclVXWm4xT0lTb0Y0NXNwVngxU1FXVlBDdHBVdUJiMEpTWFFBb2JxWDVueGt4S1JLc2hqemNDZmJiV25jMFJlWmpZSEhONStzSnR5cVhKM1NkeXlaazhsblgxTHcxSGJjeHlpcHRULytab0tNYnVRYzFoUmtvU0dDNVhpVmwvQjNPUnkrc2hsQ2xSOXYyWllmeG9zUGpSb0JqMTJmZVZvNzR2RDFpcWtlY1BXWXYyeEN3ckN0bGRZQnNxSmpWelBPRytGR00vbUFxM21ieUJ3N0tpNmdCTElTOVIvNzdSMFczS3d1NVA4U1FveUh1VG5hYzg4OVdqVTJSbUNiWTVlcm5ZRHVlMkthdW51WTA4ZVMxcFBDZWxVVDQ1cUNxRDFFOEZpWnE4STRKSkdxTllxcG5yVEdKV1lweHk4OUtRMG0wa3p6SWs1a3hZNy9TcXhFT0ROelJiUTdrMUJvNFljcU9odzlOc3N5dnYydFVvYVd1M1VtSTBORWFWS0dFWHdCa2xSWWxYajNobmhQcDVKUnA1cHRxd0VwU2prUlF4b3NHSnVFdzgyUHM2VVZHUm1ycXFxVithd1Z3c216WTFVeG9tM2E2d1NwcVY5UzNpc3FiVW8zRXFBU2FVMk0wVytDZTdqRmkxeHNhQ1U5Y3ZvUS9NdVF4dlJNTmw0MExNUGxyNnI1ckM3SVJpdXhMYnZGakRyaWhMd0o0SFkzcys1dHlubjNhbk12NjV2RVhPMjVSQlR0T3l2Q0U5RlY4N2I1cytMNi9uSGpGTyt1MUluM09tbUJlaVF2eWh2VnFzamtTVXg5T3dvZEs3VEdCb2tna016VEtCb1ZucVBoUXB4REpTeEg1WCttRU9NOVVNY3QrY0pnbXBySXJTWDN1emZQVWluWE9wczhjY2wyVWpkWUpSVktnaWw1VmFFeEpVc2dPRFdpd2wwVWkvdW9KY25GTU5pdU5SSlI3b2cydU1CeFgrMUZDNHJsRk5WSWJuZUtMQ1NJY0ZDZVlTanhQdk1KS1ppR2x5QWxoTERVNDhLaVdlMU0xc3lTUndTY09TUGthckpaR1ZqcFdDYWJSallhRS9Td0g5dkt4dzM2cXF1enB1VmlnUzdPcmptc0o2RkNVc3lrdlVZUFhrUmF4QlpEYmJ6RWpQWTNrL1pweTA4V1NrVFA5TEtpTU56ajZTVEs3V05KRml0S2hnWWVBWWJsRmUyQ0FUK1ZuV0t5NUhveXlucm12OW9oWlBodnZjZGkzRmNvWlRtQVJOZGhqQ1ZoSlFwZ1pqVmxTK29UVFVtMk5vQytHYTh0aXRQSlJwSXF1ZW9kTnhha1BPcDdUeWI2UlFuWGpPcHFUUE82L3ZySnB3enNrbG4wazVxeEtXb2FLa2FXWG82LytJbDRZaDZ6YTd1TkFLMmVlTWhMWXVXZkovL1FNRzhRPT1cIikgZm9ybWF0KFwid29mZlwiKTsgfVxuXG4uZmEsXG4uZmFzIHtcbiAgZm9udC1mYW1pbHk6ICdGb250IEF3ZXNvbWUgNSBQcm8nO1xuICBmb250LXdlaWdodDogOTAwOyB9XG5cbi8qIVxuICogRm9udCBBd2Vzb21lIFBybyA1LjAuNyBieSBAZm9udGF3ZXNvbWUgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbVxuICogTGljZW5zZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tL2xpY2Vuc2UgKENvbW1lcmNpYWwgTGljZW5zZSlcbiAqL1xuLmZhLFxuLmZhcyxcbi5mYXIsXG4uZmFsLFxuLmZhYiB7XG4gIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7XG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgZm9udC12YXJpYW50OiBub3JtYWw7XG4gIHRleHQtcmVuZGVyaW5nOiBhdXRvO1xuICBsaW5lLWhlaWdodDogMTsgfVxuXG4uZmEtbGcge1xuICBmb250LXNpemU6IDEuMzMzMzNlbTtcbiAgbGluZS1oZWlnaHQ6IDAuNzVlbTtcbiAgdmVydGljYWwtYWxpZ246IC0uMDY2N2VtOyB9XG5cbi5mYS14cyB7XG4gIGZvbnQtc2l6ZTogLjc1ZW07IH1cblxuLmZhLXNtIHtcbiAgZm9udC1zaXplOiAuODc1ZW07IH1cblxuLmZhLTF4IHtcbiAgZm9udC1zaXplOiAxZW07IH1cblxuLmZhLTJ4IHtcbiAgZm9udC1zaXplOiAyZW07IH1cblxuLmZhLTN4IHtcbiAgZm9udC1zaXplOiAzZW07IH1cblxuLmZhLTR4IHtcbiAgZm9udC1zaXplOiA0ZW07IH1cblxuLmZhLTV4IHtcbiAgZm9udC1zaXplOiA1ZW07IH1cblxuLmZhLTZ4IHtcbiAgZm9udC1zaXplOiA2ZW07IH1cblxuLmZhLTd4IHtcbiAgZm9udC1zaXplOiA3ZW07IH1cblxuLmZhLTh4IHtcbiAgZm9udC1zaXplOiA4ZW07IH1cblxuLmZhLTl4IHtcbiAgZm9udC1zaXplOiA5ZW07IH1cblxuLmZhLTEweCB7XG4gIGZvbnQtc2l6ZTogMTBlbTsgfVxuXG4uZmEtZncge1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIHdpZHRoOiAxLjI1ZW07IH1cblxuLmZhLXVsIHtcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xuICBtYXJnaW4tbGVmdDogMi41ZW07XG4gIHBhZGRpbmctbGVmdDogMDsgfVxuICAuZmEtdWwgPiBsaSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlOyB9XG5cbi5mYS1saSB7XG4gIGxlZnQ6IC0yZW07XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB3aWR0aDogMmVtO1xuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxuXG4uZmEtYm9yZGVyIHtcbiAgYm9yZGVyOiBzb2xpZCAwLjA4ZW0gI2VlZTtcbiAgYm9yZGVyLXJhZGl1czogLjFlbTtcbiAgcGFkZGluZzogLjJlbSAuMjVlbSAuMTVlbTsgfVxuXG4uZmEtcHVsbC1sZWZ0IHtcbiAgZmxvYXQ6IGxlZnQ7IH1cblxuLmZhLXB1bGwtcmlnaHQge1xuICBmbG9hdDogcmlnaHQ7IH1cblxuLmZhLmZhLXB1bGwtbGVmdCxcbi5mYXMuZmEtcHVsbC1sZWZ0LFxuLmZhci5mYS1wdWxsLWxlZnQsXG4uZmFsLmZhLXB1bGwtbGVmdCxcbi5mYWIuZmEtcHVsbC1sZWZ0IHtcbiAgbWFyZ2luLXJpZ2h0OiAuM2VtOyB9XG5cbi5mYS5mYS1wdWxsLXJpZ2h0LFxuLmZhcy5mYS1wdWxsLXJpZ2h0LFxuLmZhci5mYS1wdWxsLXJpZ2h0LFxuLmZhbC5mYS1wdWxsLXJpZ2h0LFxuLmZhYi5mYS1wdWxsLXJpZ2h0IHtcbiAgbWFyZ2luLWxlZnQ6IC4zZW07IH1cblxuLmZhLXNwaW4ge1xuICBhbmltYXRpb246IGZhLXNwaW4gMnMgaW5maW5pdGUgbGluZWFyOyB9XG5cbi5mYS1wdWxzZSB7XG4gIGFuaW1hdGlvbjogZmEtc3BpbiAxcyBpbmZpbml0ZSBzdGVwcyg4KTsgfVxuXG5Aa2V5ZnJhbWVzIGZhLXNwaW4ge1xuICAwJSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfSB9XG5cbi5mYS1yb3RhdGUtOTAge1xuICAtbXMtZmlsdGVyOiBcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CYXNpY0ltYWdlKHJvdGF0aW9uPTEpXCI7XG4gIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTsgfVxuXG4uZmEtcm90YXRlLTE4MCB7XG4gIC1tcy1maWx0ZXI6IFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJhc2ljSW1hZ2Uocm90YXRpb249MilcIjtcbiAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTsgfVxuXG4uZmEtcm90YXRlLTI3MCB7XG4gIC1tcy1maWx0ZXI6IFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJhc2ljSW1hZ2Uocm90YXRpb249MylcIjtcbiAgdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTsgfVxuXG4uZmEtZmxpcC1ob3Jpem9udGFsIHtcbiAgLW1zLWZpbHRlcjogXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmFzaWNJbWFnZShyb3RhdGlvbj0wLCBtaXJyb3I9MSlcIjtcbiAgdHJhbnNmb3JtOiBzY2FsZSgtMSwgMSk7IH1cblxuLmZhLWZsaXAtdmVydGljYWwge1xuICAtbXMtZmlsdGVyOiBcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CYXNpY0ltYWdlKHJvdGF0aW9uPTIsIG1pcnJvcj0xKVwiO1xuICB0cmFuc2Zvcm06IHNjYWxlKDEsIC0xKTsgfVxuXG4uZmEtZmxpcC1ob3Jpem9udGFsLmZhLWZsaXAtdmVydGljYWwge1xuICAtbXMtZmlsdGVyOiBcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CYXNpY0ltYWdlKHJvdGF0aW9uPTIsIG1pcnJvcj0xKVwiO1xuICB0cmFuc2Zvcm06IHNjYWxlKC0xLCAtMSk7IH1cblxuOnJvb3QgLmZhLXJvdGF0ZS05MCxcbjpyb290IC5mYS1yb3RhdGUtMTgwLFxuOnJvb3QgLmZhLXJvdGF0ZS0yNzAsXG46cm9vdCAuZmEtZmxpcC1ob3Jpem9udGFsLFxuOnJvb3QgLmZhLWZsaXAtdmVydGljYWwge1xuICBmaWx0ZXI6IG5vbmU7IH1cblxuLmZhLXN0YWNrIHtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICBoZWlnaHQ6IDJlbTtcbiAgbGluZS1oZWlnaHQ6IDJlbTtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICB3aWR0aDogMmVtOyB9XG5cbi5mYS1zdGFjay0xeCxcbi5mYS1zdGFjay0yeCB7XG4gIGxlZnQ6IDA7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB3aWR0aDogMTAwJTsgfVxuXG4uZmEtc3RhY2stMXgge1xuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxuXG4uZmEtc3RhY2stMngge1xuICBmb250LXNpemU6IDJlbTsgfVxuXG4uZmEtaW52ZXJzZSB7XG4gIGNvbG9yOiAjZmZmOyB9XG5cbi8qIEZvbnQgQXdlc29tZSB1c2VzIHRoZSBVbmljb2RlIFByaXZhdGUgVXNlIEFyZWEgKFBVQSkgdG8gZW5zdXJlIHNjcmVlblxucmVhZGVycyBkbyBub3QgcmVhZCBvZmYgcmFuZG9tIGNoYXJhY3RlcnMgdGhhdCByZXByZXNlbnQgaWNvbnMgKi9cbi5mYS01MDBweDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI2ZVwiOyB9XG5cbi5mYS1hY2Nlc3NpYmxlLWljb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNjhcIjsgfVxuXG4uZmEtYWNjdXNvZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNjlcIjsgfVxuXG4uZmEtYWRkcmVzcy1ib29rOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmI5XCI7IH1cblxuLmZhLWFkZHJlc3MtY2FyZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJiYlwiOyB9XG5cbi5mYS1hZGp1c3Q6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNDJcIjsgfVxuXG4uZmEtYWRuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTcwXCI7IH1cblxuLmZhLWFkdmVyc2FsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzZhXCI7IH1cblxuLmZhLWFmZmlsaWF0ZXRoZW1lOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzZiXCI7IH1cblxuLmZhLWFsYXJtLWNsb2NrOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzRlXCI7IH1cblxuLmZhLWFsZ29saWE6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNmNcIjsgfVxuXG4uZmEtYWxpZ24tY2VudGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDM3XCI7IH1cblxuLmZhLWFsaWduLWp1c3RpZnk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMzlcIjsgfVxuXG4uZmEtYWxpZ24tbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAzNlwiOyB9XG5cbi5mYS1hbGlnbi1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAzOFwiOyB9XG5cbi5mYS1hbGxlcmdpZXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NjFcIjsgfVxuXG4uZmEtYW1hem9uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjcwXCI7IH1cblxuLmZhLWFtYXpvbi1wYXk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MmNcIjsgfVxuXG4uZmEtYW1idWxhbmNlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGY5XCI7IH1cblxuLmZhLWFtZXJpY2FuLXNpZ24tbGFuZ3VhZ2UtaW50ZXJwcmV0aW5nOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmEzXCI7IH1cblxuLmZhLWFtaWxpYTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM2ZFwiOyB9XG5cbi5mYS1hbmNob3I6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxM2RcIjsgfVxuXG4uZmEtYW5kcm9pZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE3YlwiOyB9XG5cbi5mYS1hbmdlbGxpc3Q6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMDlcIjsgfVxuXG4uZmEtYW5nbGUtZG91YmxlLWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMDNcIjsgfVxuXG4uZmEtYW5nbGUtZG91YmxlLWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMDBcIjsgfVxuXG4uZmEtYW5nbGUtZG91YmxlLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTAxXCI7IH1cblxuLmZhLWFuZ2xlLWRvdWJsZS11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEwMlwiOyB9XG5cbi5mYS1hbmdsZS1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTA3XCI7IH1cblxuLmZhLWFuZ2xlLWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMDRcIjsgfVxuXG4uZmEtYW5nbGUtcmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMDVcIjsgfVxuXG4uZmEtYW5nbGUtdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMDZcIjsgfVxuXG4uZmEtYW5ncnljcmVhdGl2ZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM2ZVwiOyB9XG5cbi5mYS1hbmd1bGFyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDIwXCI7IH1cblxuLmZhLWFwcC1zdG9yZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM2ZlwiOyB9XG5cbi5mYS1hcHAtc3RvcmUtaW9zOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzcwXCI7IH1cblxuLmZhLWFwcGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzcxXCI7IH1cblxuLmZhLWFwcGxlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTc5XCI7IH1cblxuLmZhLWFwcGxlLXBheTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQxNVwiOyB9XG5cbi5mYS1hcmNoaXZlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTg3XCI7IH1cblxuLmZhLWFycm93LWFsdC1jaXJjbGUtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM1OFwiOyB9XG5cbi5mYS1hcnJvdy1hbHQtY2lyY2xlLWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNTlcIjsgfVxuXG4uZmEtYXJyb3ctYWx0LWNpcmNsZS1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM1YVwiOyB9XG5cbi5mYS1hcnJvdy1hbHQtY2lyY2xlLXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzViXCI7IH1cblxuLmZhLWFycm93LWFsdC1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzU0XCI7IH1cblxuLmZhLWFycm93LWFsdC1mcm9tLWJvdHRvbTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM0NlwiOyB9XG5cbi5mYS1hcnJvdy1hbHQtZnJvbS1sZWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzQ3XCI7IH1cblxuLmZhLWFycm93LWFsdC1mcm9tLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzQ4XCI7IH1cblxuLmZhLWFycm93LWFsdC1mcm9tLXRvcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM0OVwiOyB9XG5cbi5mYS1hcnJvdy1hbHQtbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM1NVwiOyB9XG5cbi5mYS1hcnJvdy1hbHQtcmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNTZcIjsgfVxuXG4uZmEtYXJyb3ctYWx0LXNxdWFyZS1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzUwXCI7IH1cblxuLmZhLWFycm93LWFsdC1zcXVhcmUtbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM1MVwiOyB9XG5cbi5mYS1hcnJvdy1hbHQtc3F1YXJlLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzUyXCI7IH1cblxuLmZhLWFycm93LWFsdC1zcXVhcmUtdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNTNcIjsgfVxuXG4uZmEtYXJyb3ctYWx0LXRvLWJvdHRvbTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM0YVwiOyB9XG5cbi5mYS1hcnJvdy1hbHQtdG8tbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM0YlwiOyB9XG5cbi5mYS1hcnJvdy1hbHQtdG8tcmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNGNcIjsgfVxuXG4uZmEtYXJyb3ctYWx0LXRvLXRvcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM0ZFwiOyB9XG5cbi5mYS1hcnJvdy1hbHQtdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNTdcIjsgfVxuXG4uZmEtYXJyb3ctY2lyY2xlLWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYWJcIjsgfVxuXG4uZmEtYXJyb3ctY2lyY2xlLWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYThcIjsgfVxuXG4uZmEtYXJyb3ctY2lyY2xlLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGE5XCI7IH1cblxuLmZhLWFycm93LWNpcmNsZS11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBhYVwiOyB9XG5cbi5mYS1hcnJvdy1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDYzXCI7IH1cblxuLmZhLWFycm93LWZyb20tYm90dG9tOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzQyXCI7IH1cblxuLmZhLWFycm93LWZyb20tbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM0M1wiOyB9XG5cbi5mYS1hcnJvdy1mcm9tLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzQ0XCI7IH1cblxuLmZhLWFycm93LWZyb20tdG9wOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzQ1XCI7IH1cblxuLmZhLWFycm93LWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNjBcIjsgfVxuXG4uZmEtYXJyb3ctcmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNjFcIjsgfVxuXG4uZmEtYXJyb3ctc3F1YXJlLWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMzlcIjsgfVxuXG4uZmEtYXJyb3ctc3F1YXJlLWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzM2FcIjsgfVxuXG4uZmEtYXJyb3ctc3F1YXJlLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzNiXCI7IH1cblxuLmZhLWFycm93LXNxdWFyZS11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMzY1wiOyB9XG5cbi5mYS1hcnJvdy10by1ib3R0b206YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzM2RcIjsgfVxuXG4uZmEtYXJyb3ctdG8tbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMzZVwiOyB9XG5cbi5mYS1hcnJvdy10by1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM0MFwiOyB9XG5cbi5mYS1hcnJvdy10by10b3A6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNDFcIjsgfVxuXG4uZmEtYXJyb3ctdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNjJcIjsgfVxuXG4uZmEtYXJyb3dzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDQ3XCI7IH1cblxuLmZhLWFycm93cy1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYjJcIjsgfVxuXG4uZmEtYXJyb3dzLWFsdC1oOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzM3XCI7IH1cblxuLmZhLWFycm93cy1hbHQtdjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMzOFwiOyB9XG5cbi5mYS1hcnJvd3MtaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA3ZVwiOyB9XG5cbi5mYS1hcnJvd3MtdjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA3ZFwiOyB9XG5cbi5mYS1hc3Npc3RpdmUtbGlzdGVuaW5nLXN5c3RlbXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYTJcIjsgfVxuXG4uZmEtYXN0ZXJpc2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNjlcIjsgfVxuXG4uZmEtYXN5bW1ldHJpazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM3MlwiOyB9XG5cbi5mYS1hdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFmYVwiOyB9XG5cbi5mYS1hdWRpYmxlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzczXCI7IH1cblxuLmZhLWF1ZGlvLWRlc2NyaXB0aW9uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjllXCI7IH1cblxuLmZhLWF1dG9wcmVmaXhlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQxY1wiOyB9XG5cbi5mYS1hdmlhbmV4OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzc0XCI7IH1cblxuLmZhLWF2aWF0bzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQyMVwiOyB9XG5cbi5mYS1hd3M6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNzVcIjsgfVxuXG4uZmEtYmFja3dhcmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNGFcIjsgfVxuXG4uZmEtYmFkZ2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMzVcIjsgfVxuXG4uZmEtYmFkZ2UtY2hlY2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMzZcIjsgfVxuXG4uZmEtYmFsYW5jZS1zY2FsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI0ZVwiOyB9XG5cbi5mYS1iYW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNWVcIjsgfVxuXG4uZmEtYmFuZC1haWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NjJcIjsgfVxuXG4uZmEtYmFuZGNhbXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZDVcIjsgfVxuXG4uZmEtYmFyY29kZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAyYVwiOyB9XG5cbi5mYS1iYXJjb2RlLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ2M1wiOyB9XG5cbi5mYS1iYXJjb2RlLXJlYWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NjRcIjsgfVxuXG4uZmEtYmFyY29kZS1zY2FuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDY1XCI7IH1cblxuLmZhLWJhcnM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYzlcIjsgfVxuXG4uZmEtYmFzZWJhbGw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MzJcIjsgfVxuXG4uZmEtYmFzZWJhbGwtYmFsbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQzM1wiOyB9XG5cbi5mYS1iYXNrZXRiYWxsLWJhbGw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MzRcIjsgfVxuXG4uZmEtYmFza2V0YmFsbC1ob29wOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDM1XCI7IH1cblxuLmZhLWJhdGg6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyY2RcIjsgfVxuXG4uZmEtYmF0dGVyeS1ib2x0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzc2XCI7IH1cblxuLmZhLWJhdHRlcnktZW1wdHk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNDRcIjsgfVxuXG4uZmEtYmF0dGVyeS1mdWxsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjQwXCI7IH1cblxuLmZhLWJhdHRlcnktaGFsZjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI0MlwiOyB9XG5cbi5mYS1iYXR0ZXJ5LXF1YXJ0ZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNDNcIjsgfVxuXG4uZmEtYmF0dGVyeS1zbGFzaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM3N1wiOyB9XG5cbi5mYS1iYXR0ZXJ5LXRocmVlLXF1YXJ0ZXJzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjQxXCI7IH1cblxuLmZhLWJlZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIzNlwiOyB9XG5cbi5mYS1iZWVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGZjXCI7IH1cblxuLmZhLWJlaGFuY2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYjRcIjsgfVxuXG4uZmEtYmVoYW5jZS1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYjVcIjsgfVxuXG4uZmEtYmVsbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBmM1wiOyB9XG5cbi5mYS1iZWxsLXNsYXNoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWY2XCI7IH1cblxuLmZhLWJpY3ljbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMDZcIjsgfVxuXG4uZmEtYmltb2JqZWN0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzc4XCI7IH1cblxuLmZhLWJpbm9jdWxhcnM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZTVcIjsgfVxuXG4uZmEtYmlydGhkYXktY2FrZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFmZFwiOyB9XG5cbi5mYS1iaXRidWNrZXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNzFcIjsgfVxuXG4uZmEtYml0Y29pbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM3OVwiOyB9XG5cbi5mYS1iaXR5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzdhXCI7IH1cblxuLmZhLWJsYWNrLXRpZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI3ZVwiOyB9XG5cbi5mYS1ibGFja2JlcnJ5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzdiXCI7IH1cblxuLmZhLWJsaW5kOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjlkXCI7IH1cblxuLmZhLWJsb2dnZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzN2NcIjsgfVxuXG4uZmEtYmxvZ2dlci1iOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzdkXCI7IH1cblxuLmZhLWJsdWV0b290aDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI5M1wiOyB9XG5cbi5mYS1ibHVldG9vdGgtYjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI5NFwiOyB9XG5cbi5mYS1ib2xkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDMyXCI7IH1cblxuLmZhLWJvbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZTdcIjsgfVxuXG4uZmEtYm9tYjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFlMlwiOyB9XG5cbi5mYS1ib29rOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDJkXCI7IH1cblxuLmZhLWJvb2ttYXJrOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDJlXCI7IH1cblxuLmZhLWJvd2xpbmctYmFsbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQzNlwiOyB9XG5cbi5mYS1ib3dsaW5nLXBpbnM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MzdcIjsgfVxuXG4uZmEtYm94OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDY2XCI7IH1cblxuLmZhLWJveC1jaGVjazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ2N1wiOyB9XG5cbi5mYS1ib3hlczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ2OFwiOyB9XG5cbi5mYS1ib3hpbmctZ2xvdmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MzhcIjsgfVxuXG4uZmEtYnJhaWxsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJhMVwiOyB9XG5cbi5mYS1icmllZmNhc2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYjFcIjsgfVxuXG4uZmEtYnJpZWZjYXNlLW1lZGljYWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NjlcIjsgfVxuXG4uZmEtYnJvd3NlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM3ZVwiOyB9XG5cbi5mYS1idGM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNWFcIjsgfVxuXG4uZmEtYnVnOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTg4XCI7IH1cblxuLmZhLWJ1aWxkaW5nOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWFkXCI7IH1cblxuLmZhLWJ1bGxob3JuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGExXCI7IH1cblxuLmZhLWJ1bGxzZXllOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTQwXCI7IH1cblxuLmZhLWJ1cm46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NmFcIjsgfVxuXG4uZmEtYnVyb21vYmVsZXhwZXJ0ZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM3ZlwiOyB9XG5cbi5mYS1idXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMDdcIjsgfVxuXG4uZmEtYnV5c2VsbGFkczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIwZFwiOyB9XG5cbi5mYS1jYWxjdWxhdG9yOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWVjXCI7IH1cblxuLmZhLWNhbGVuZGFyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTMzXCI7IH1cblxuLmZhLWNhbGVuZGFyLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA3M1wiOyB9XG5cbi5mYS1jYWxlbmRhci1jaGVjazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI3NFwiOyB9XG5cbi5mYS1jYWxlbmRhci1lZGl0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzMzXCI7IH1cblxuLmZhLWNhbGVuZGFyLWV4Y2xhbWF0aW9uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzM0XCI7IH1cblxuLmZhLWNhbGVuZGFyLW1pbnVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjcyXCI7IH1cblxuLmZhLWNhbGVuZGFyLXBsdXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNzFcIjsgfVxuXG4uZmEtY2FsZW5kYXItdGltZXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNzNcIjsgfVxuXG4uZmEtY2FtZXJhOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDMwXCI7IH1cblxuLmZhLWNhbWVyYS1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMzJcIjsgfVxuXG4uZmEtY2FtZXJhLXJldHJvOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDgzXCI7IH1cblxuLmZhLWNhcHN1bGVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDZiXCI7IH1cblxuLmZhLWNhcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFiOVwiOyB9XG5cbi5mYS1jYXJldC1jaXJjbGUtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMyZFwiOyB9XG5cbi5mYS1jYXJldC1jaXJjbGUtbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMyZVwiOyB9XG5cbi5mYS1jYXJldC1jaXJjbGUtcmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMzBcIjsgfVxuXG4uZmEtY2FyZXQtY2lyY2xlLXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzMxXCI7IH1cblxuLmZhLWNhcmV0LWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZDdcIjsgfVxuXG4uZmEtY2FyZXQtbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBkOVwiOyB9XG5cbi5mYS1jYXJldC1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBkYVwiOyB9XG5cbi5mYS1jYXJldC1zcXVhcmUtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE1MFwiOyB9XG5cbi5mYS1jYXJldC1zcXVhcmUtbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE5MVwiOyB9XG5cbi5mYS1jYXJldC1zcXVhcmUtcmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNTJcIjsgfVxuXG4uZmEtY2FyZXQtc3F1YXJlLXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTUxXCI7IH1cblxuLmZhLWNhcmV0LXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGQ4XCI7IH1cblxuLmZhLWNhcnQtYXJyb3ctZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIxOFwiOyB9XG5cbi5mYS1jYXJ0LXBsdXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMTdcIjsgfVxuXG4uZmEtY2MtYW1hem9uLXBheTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQyZFwiOyB9XG5cbi5mYS1jYy1hbWV4OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWYzXCI7IH1cblxuLmZhLWNjLWFwcGxlLXBheTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQxNlwiOyB9XG5cbi5mYS1jYy1kaW5lcnMtY2x1YjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI0Y1wiOyB9XG5cbi5mYS1jYy1kaXNjb3ZlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFmMlwiOyB9XG5cbi5mYS1jYy1qY2I6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNGJcIjsgfVxuXG4uZmEtY2MtbWFzdGVyY2FyZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFmMVwiOyB9XG5cbi5mYS1jYy1wYXlwYWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZjRcIjsgfVxuXG4uZmEtY2Mtc3RyaXBlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWY1XCI7IH1cblxuLmZhLWNjLXZpc2E6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZjBcIjsgfVxuXG4uZmEtY2VudGVyY29kZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM4MFwiOyB9XG5cbi5mYS1jZXJ0aWZpY2F0ZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBhM1wiOyB9XG5cbi5mYS1jaGFydC1hcmVhOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWZlXCI7IH1cblxuLmZhLWNoYXJ0LWJhcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA4MFwiOyB9XG5cbi5mYS1jaGFydC1saW5lOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjAxXCI7IH1cblxuLmZhLWNoYXJ0LXBpZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIwMFwiOyB9XG5cbi5mYS1jaGVjazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAwY1wiOyB9XG5cbi5mYS1jaGVjay1jaXJjbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNThcIjsgfVxuXG4uZmEtY2hlY2stc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTRhXCI7IH1cblxuLmZhLWNoZXNzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDM5XCI7IH1cblxuLmZhLWNoZXNzLWJpc2hvcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQzYVwiOyB9XG5cbi5mYS1jaGVzcy1iaXNob3AtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDNiXCI7IH1cblxuLmZhLWNoZXNzLWJvYXJkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDNjXCI7IH1cblxuLmZhLWNoZXNzLWNsb2NrOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDNkXCI7IH1cblxuLmZhLWNoZXNzLWNsb2NrLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQzZVwiOyB9XG5cbi5mYS1jaGVzcy1raW5nOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDNmXCI7IH1cblxuLmZhLWNoZXNzLWtpbmctYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDQwXCI7IH1cblxuLmZhLWNoZXNzLWtuaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ0MVwiOyB9XG5cbi5mYS1jaGVzcy1rbmlnaHQtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDQyXCI7IH1cblxuLmZhLWNoZXNzLXBhd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NDNcIjsgfVxuXG4uZmEtY2hlc3MtcGF3bi1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NDRcIjsgfVxuXG4uZmEtY2hlc3MtcXVlZW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NDVcIjsgfVxuXG4uZmEtY2hlc3MtcXVlZW4tYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDQ2XCI7IH1cblxuLmZhLWNoZXNzLXJvb2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NDdcIjsgfVxuXG4uZmEtY2hlc3Mtcm9vay1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NDhcIjsgfVxuXG4uZmEtY2hldnJvbi1jaXJjbGUtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEzYVwiOyB9XG5cbi5mYS1jaGV2cm9uLWNpcmNsZS1sZWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTM3XCI7IH1cblxuLmZhLWNoZXZyb24tY2lyY2xlLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTM4XCI7IH1cblxuLmZhLWNoZXZyb24tY2lyY2xlLXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTM5XCI7IH1cblxuLmZhLWNoZXZyb24tZG91YmxlLWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMjJcIjsgfVxuXG4uZmEtY2hldnJvbi1kb3VibGUtbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMyM1wiOyB9XG5cbi5mYS1jaGV2cm9uLWRvdWJsZS1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMyNFwiOyB9XG5cbi5mYS1jaGV2cm9uLWRvdWJsZS11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMyNVwiOyB9XG5cbi5mYS1jaGV2cm9uLWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNzhcIjsgfVxuXG4uZmEtY2hldnJvbi1sZWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDUzXCI7IH1cblxuLmZhLWNoZXZyb24tcmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNTRcIjsgfVxuXG4uZmEtY2hldnJvbi1zcXVhcmUtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMyOVwiOyB9XG5cbi5mYS1jaGV2cm9uLXNxdWFyZS1sZWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzJhXCI7IH1cblxuLmZhLWNoZXZyb24tc3F1YXJlLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzJiXCI7IH1cblxuLmZhLWNoZXZyb24tc3F1YXJlLXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzJjXCI7IH1cblxuLmZhLWNoZXZyb24tdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNzdcIjsgfVxuXG4uZmEtY2hpbGQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYWVcIjsgfVxuXG4uZmEtY2hyb21lOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjY4XCI7IH1cblxuLmZhLWNpcmNsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjExMVwiOyB9XG5cbi5mYS1jaXJjbGUtbm90Y2g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxY2VcIjsgfVxuXG4uZmEtY2xpcGJvYXJkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzI4XCI7IH1cblxuLmZhLWNsaXBib2FyZC1jaGVjazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ2Y1wiOyB9XG5cbi5mYS1jbGlwYm9hcmQtbGlzdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ2ZFwiOyB9XG5cbi5mYS1jbG9jazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAxN1wiOyB9XG5cbi5mYS1jbG9uZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI0ZFwiOyB9XG5cbi5mYS1jbG9zZWQtY2FwdGlvbmluZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIwYVwiOyB9XG5cbi5mYS1jbG91ZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBjMlwiOyB9XG5cbi5mYS1jbG91ZC1kb3dubG9hZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBlZFwiOyB9XG5cbi5mYS1jbG91ZC1kb3dubG9hZC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzODFcIjsgfVxuXG4uZmEtY2xvdWQtdXBsb2FkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGVlXCI7IH1cblxuLmZhLWNsb3VkLXVwbG9hZC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzODJcIjsgfVxuXG4uZmEtY2xvdWRzY2FsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM4M1wiOyB9XG5cbi5mYS1jbG91ZHNtaXRoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzg0XCI7IH1cblxuLmZhLWNsb3VkdmVyc2lmeTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM4NVwiOyB9XG5cbi5mYS1jbHViOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzI3XCI7IH1cblxuLmZhLWNvZGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMjFcIjsgfVxuXG4uZmEtY29kZS1icmFuY2g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMjZcIjsgfVxuXG4uZmEtY29kZS1jb21taXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzODZcIjsgfVxuXG4uZmEtY29kZS1tZXJnZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM4N1wiOyB9XG5cbi5mYS1jb2RlcGVuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWNiXCI7IH1cblxuLmZhLWNvZGllcGllOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjg0XCI7IH1cblxuLmZhLWNvZmZlZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBmNFwiOyB9XG5cbi5mYS1jb2c6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMTNcIjsgfVxuXG4uZmEtY29nczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA4NVwiOyB9XG5cbi5mYS1jb2x1bW5zOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGRiXCI7IH1cblxuLmZhLWNvbW1lbnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNzVcIjsgfVxuXG4uZmEtY29tbWVudC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyN2FcIjsgfVxuXG4uZmEtY29tbWVudHM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwODZcIjsgfVxuXG4uZmEtY29tcGFzczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE0ZVwiOyB9XG5cbi5mYS1jb21wcmVzczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA2NlwiOyB9XG5cbi5mYS1jb21wcmVzcy1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MjJcIjsgfVxuXG4uZmEtY29tcHJlc3Mtd2lkZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMyNlwiOyB9XG5cbi5mYS1jb25uZWN0ZGV2ZWxvcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIwZVwiOyB9XG5cbi5mYS1jb250YW86YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNmRcIjsgfVxuXG4uZmEtY29udmV5b3ItYmVsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ2ZVwiOyB9XG5cbi5mYS1jb252ZXlvci1iZWx0LWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ2ZlwiOyB9XG5cbi5mYS1jb3B5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGM1XCI7IH1cblxuLmZhLWNvcHlyaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFmOVwiOyB9XG5cbi5mYS1jcGFuZWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzODhcIjsgfVxuXG4uZmEtY3JlYXRpdmUtY29tbW9uczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI1ZVwiOyB9XG5cbi5mYS1jcmVkaXQtY2FyZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA5ZFwiOyB9XG5cbi5mYS1jcmVkaXQtY2FyZC1ibGFuazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM4OVwiOyB9XG5cbi5mYS1jcmVkaXQtY2FyZC1mcm9udDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM4YVwiOyB9XG5cbi5mYS1jcmlja2V0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDQ5XCI7IH1cblxuLmZhLWNyb3A6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMjVcIjsgfVxuXG4uZmEtY3Jvc3NoYWlyczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA1YlwiOyB9XG5cbi5mYS1jc3MzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTNjXCI7IH1cblxuLmZhLWNzczMtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzhiXCI7IH1cblxuLmZhLWN1YmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYjJcIjsgfVxuXG4uZmEtY3ViZXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYjNcIjsgfVxuXG4uZmEtY3VybGluZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ0YVwiOyB9XG5cbi5mYS1jdXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYzRcIjsgfVxuXG4uZmEtY3V0dGxlZmlzaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM4Y1wiOyB9XG5cbi5mYS1kLWFuZC1kOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzhkXCI7IH1cblxuLmZhLWRhc2hjdWJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjEwXCI7IH1cblxuLmZhLWRhdGFiYXNlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWMwXCI7IH1cblxuLmZhLWRlYWY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYTRcIjsgfVxuXG4uZmEtZGVsaWNpb3VzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWE1XCI7IH1cblxuLmZhLWRlcGxveWRvZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM4ZVwiOyB9XG5cbi5mYS1kZXNrcHJvOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzhmXCI7IH1cblxuLmZhLWRlc2t0b3A6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMDhcIjsgfVxuXG4uZmEtZGVza3RvcC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOTBcIjsgfVxuXG4uZmEtZGV2aWFudGFydDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFiZFwiOyB9XG5cbi5mYS1kaWFnbm9zZXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NzBcIjsgfVxuXG4uZmEtZGlhbW9uZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIxOVwiOyB9XG5cbi5mYS1kaWdnOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWE2XCI7IH1cblxuLmZhLWRpZ2l0YWwtb2NlYW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOTFcIjsgfVxuXG4uZmEtZGlzY29yZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM5MlwiOyB9XG5cbi5mYS1kaXNjb3Vyc2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOTNcIjsgfVxuXG4uZmEtZG5hOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDcxXCI7IH1cblxuLmZhLWRvY2h1YjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM5NFwiOyB9XG5cbi5mYS1kb2NrZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOTVcIjsgfVxuXG4uZmEtZG9sbGFyLXNpZ246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNTVcIjsgfVxuXG4uZmEtZG9sbHk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NzJcIjsgfVxuXG4uZmEtZG9sbHktZW1wdHk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NzNcIjsgfVxuXG4uZmEtZG9sbHktZmxhdGJlZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ3NFwiOyB9XG5cbi5mYS1kb2xseS1mbGF0YmVkLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ3NVwiOyB9XG5cbi5mYS1kb2xseS1mbGF0YmVkLWVtcHR5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDc2XCI7IH1cblxuLmZhLWRvdC1jaXJjbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxOTJcIjsgfVxuXG4uZmEtZG93bmxvYWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMTlcIjsgfVxuXG4uZmEtZHJhZnQyZGlnaXRhbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM5NlwiOyB9XG5cbi5mYS1kcmliYmJsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE3ZFwiOyB9XG5cbi5mYS1kcmliYmJsZS1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOTdcIjsgfVxuXG4uZmEtZHJvcGJveDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE2YlwiOyB9XG5cbi5mYS1kcnVwYWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYTlcIjsgfVxuXG4uZmEtZHVtYmJlbGw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NGJcIjsgfVxuXG4uZmEtZHlhbG9nOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzk5XCI7IH1cblxuLmZhLWVhcmx5YmlyZHM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOWFcIjsgfVxuXG4uZmEtZWRnZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI4MlwiOyB9XG5cbi5mYS1lZGl0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDQ0XCI7IH1cblxuLmZhLWVqZWN0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDUyXCI7IH1cblxuLmZhLWVsZW1lbnRvcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQzMFwiOyB9XG5cbi5mYS1lbGxpcHNpcy1oOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTQxXCI7IH1cblxuLmZhLWVsbGlwc2lzLWgtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzliXCI7IH1cblxuLmZhLWVsbGlwc2lzLXY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNDJcIjsgfVxuXG4uZmEtZWxsaXBzaXMtdi1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOWNcIjsgfVxuXG4uZmEtZW1iZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MjNcIjsgfVxuXG4uZmEtZW1waXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWQxXCI7IH1cblxuLmZhLWVudmVsb3BlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGUwXCI7IH1cblxuLmZhLWVudmVsb3BlLW9wZW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYjZcIjsgfVxuXG4uZmEtZW52ZWxvcGUtc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTk5XCI7IH1cblxuLmZhLWVudmlyYTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI5OVwiOyB9XG5cbi5mYS1lcmFzZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMmRcIjsgfVxuXG4uZmEtZXJsYW5nOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzlkXCI7IH1cblxuLmZhLWV0aGVyZXVtOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDJlXCI7IH1cblxuLmZhLWV0c3k6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZDdcIjsgfVxuXG4uZmEtZXVyby1zaWduOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTUzXCI7IH1cblxuLmZhLWV4Y2hhbmdlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGVjXCI7IH1cblxuLmZhLWV4Y2hhbmdlLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM2MlwiOyB9XG5cbi5mYS1leGNsYW1hdGlvbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEyYVwiOyB9XG5cbi5mYS1leGNsYW1hdGlvbi1jaXJjbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNmFcIjsgfVxuXG4uZmEtZXhjbGFtYXRpb24tc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzIxXCI7IH1cblxuLmZhLWV4Y2xhbWF0aW9uLXRyaWFuZ2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDcxXCI7IH1cblxuLmZhLWV4cGFuZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA2NVwiOyB9XG5cbi5mYS1leHBhbmQtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDI0XCI7IH1cblxuLmZhLWV4cGFuZC1hcnJvd3M6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMWRcIjsgfVxuXG4uZmEtZXhwYW5kLWFycm93cy1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMWVcIjsgfVxuXG4uZmEtZXhwYW5kLXdpZGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMjBcIjsgfVxuXG4uZmEtZXhwZWRpdGVkc3NsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjNlXCI7IH1cblxuLmZhLWV4dGVybmFsLWxpbms6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwOGVcIjsgfVxuXG4uZmEtZXh0ZXJuYWwtbGluay1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNWRcIjsgfVxuXG4uZmEtZXh0ZXJuYWwtbGluay1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNGNcIjsgfVxuXG4uZmEtZXh0ZXJuYWwtbGluay1zcXVhcmUtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzYwXCI7IH1cblxuLmZhLWV5ZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA2ZVwiOyB9XG5cbi5mYS1leWUtZHJvcHBlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFmYlwiOyB9XG5cbi5mYS1leWUtc2xhc2g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNzBcIjsgfVxuXG4uZmEtZmFjZWJvb2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwOWFcIjsgfVxuXG4uZmEtZmFjZWJvb2stZjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM5ZVwiOyB9XG5cbi5mYS1mYWNlYm9vay1tZXNzZW5nZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzOWZcIjsgfVxuXG4uZmEtZmFjZWJvb2stc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDgyXCI7IH1cblxuLmZhLWZhc3QtYmFja3dhcmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNDlcIjsgfVxuXG4uZmEtZmFzdC1mb3J3YXJkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDUwXCI7IH1cblxuLmZhLWZheDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFhY1wiOyB9XG5cbi5mYS1mZW1hbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxODJcIjsgfVxuXG4uZmEtZmllbGQtaG9ja2V5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDRjXCI7IH1cblxuLmZhLWZpZ2h0ZXItamV0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGZiXCI7IH1cblxuLmZhLWZpbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNWJcIjsgfVxuXG4uZmEtZmlsZS1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNWNcIjsgfVxuXG4uZmEtZmlsZS1hcmNoaXZlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWM2XCI7IH1cblxuLmZhLWZpbGUtYXVkaW86YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYzdcIjsgfVxuXG4uZmEtZmlsZS1jaGVjazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMxNlwiOyB9XG5cbi5mYS1maWxlLWNvZGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYzlcIjsgfVxuXG4uZmEtZmlsZS1lZGl0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzFjXCI7IH1cblxuLmZhLWZpbGUtZXhjZWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYzNcIjsgfVxuXG4uZmEtZmlsZS1leGNsYW1hdGlvbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMxYVwiOyB9XG5cbi5mYS1maWxlLWltYWdlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWM1XCI7IH1cblxuLmZhLWZpbGUtbWVkaWNhbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ3N1wiOyB9XG5cbi5mYS1maWxlLW1lZGljYWwtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDc4XCI7IH1cblxuLmZhLWZpbGUtbWludXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMThcIjsgfVxuXG4uZmEtZmlsZS1wZGY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYzFcIjsgfVxuXG4uZmEtZmlsZS1wbHVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzE5XCI7IH1cblxuLmZhLWZpbGUtcG93ZXJwb2ludDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFjNFwiOyB9XG5cbi5mYS1maWxlLXRpbWVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzE3XCI7IH1cblxuLmZhLWZpbGUtdmlkZW86YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYzhcIjsgfVxuXG4uZmEtZmlsZS13b3JkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWMyXCI7IH1cblxuLmZhLWZpbG06YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMDhcIjsgfVxuXG4uZmEtZmlsbS1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYTBcIjsgfVxuXG4uZmEtZmlsdGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGIwXCI7IH1cblxuLmZhLWZpcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNmRcIjsgfVxuXG4uZmEtZmlyZS1leHRpbmd1aXNoZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMzRcIjsgfVxuXG4uZmEtZmlyZWZveDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI2OVwiOyB9XG5cbi5mYS1maXJzdC1haWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NzlcIjsgfVxuXG4uZmEtZmlyc3Qtb3JkZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYjBcIjsgfVxuXG4uZmEtZmlyc3RkcmFmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNhMVwiOyB9XG5cbi5mYS1mbGFnOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDI0XCI7IH1cblxuLmZhLWZsYWctY2hlY2tlcmVkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTFlXCI7IH1cblxuLmZhLWZsYXNrOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGMzXCI7IH1cblxuLmZhLWZsaWNrcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE2ZVwiOyB9XG5cbi5mYS1mbGlwYm9hcmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NGRcIjsgfVxuXG4uZmEtZmx5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDE3XCI7IH1cblxuLmZhLWZvbGRlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA3YlwiOyB9XG5cbi5mYS1mb2xkZXItb3BlbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA3Y1wiOyB9XG5cbi5mYS1mb250OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDMxXCI7IH1cblxuLmZhLWZvbnQtYXdlc29tZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJiNFwiOyB9XG5cbi5mYS1mb250LWF3ZXNvbWUtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzVjXCI7IH1cblxuLmZhLWZvbnQtYXdlc29tZS1mbGFnOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDI1XCI7IH1cblxuLmZhLWZvbnRpY29uczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI4MFwiOyB9XG5cbi5mYS1mb250aWNvbnMtZmk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYTJcIjsgfVxuXG4uZmEtZm9vdGJhbGwtYmFsbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ0ZVwiOyB9XG5cbi5mYS1mb290YmFsbC1oZWxtZXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NGZcIjsgfVxuXG4uZmEtZm9ya2xpZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0N2FcIjsgfVxuXG4uZmEtZm9ydC1hd2Vzb21lOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjg2XCI7IH1cblxuLmZhLWZvcnQtYXdlc29tZS1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYTNcIjsgfVxuXG4uZmEtZm9ydW1iZWU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMTFcIjsgfVxuXG4uZmEtZm9yd2FyZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA0ZVwiOyB9XG5cbi5mYS1mb3Vyc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTgwXCI7IH1cblxuLmZhLWZyZWUtY29kZS1jYW1wOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmM1XCI7IH1cblxuLmZhLWZyZWVic2Q6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYTRcIjsgfVxuXG4uZmEtZnJvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMTlcIjsgfVxuXG4uZmEtZnV0Ym9sOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWUzXCI7IH1cblxuLmZhLWdhbWVwYWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMWJcIjsgfVxuXG4uZmEtZ2F2ZWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZTNcIjsgfVxuXG4uZmEtZ2VtOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2E1XCI7IH1cblxuLmZhLWdlbmRlcmxlc3M6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMmRcIjsgfVxuXG4uZmEtZ2V0LXBvY2tldDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI2NVwiOyB9XG5cbi5mYS1nZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI2MFwiOyB9XG5cbi5mYS1nZy1jaXJjbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNjFcIjsgfVxuXG4uZmEtZ2lmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA2YlwiOyB9XG5cbi5mYS1naXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZDNcIjsgfVxuXG4uZmEtZ2l0LXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFkMlwiOyB9XG5cbi5mYS1naXRodWI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwOWJcIjsgfVxuXG4uZmEtZ2l0aHViLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjExM1wiOyB9XG5cbi5mYS1naXRodWItc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDkyXCI7IH1cblxuLmZhLWdpdGtyYWtlbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNhNlwiOyB9XG5cbi5mYS1naXRsYWI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyOTZcIjsgfVxuXG4uZmEtZ2l0dGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDI2XCI7IH1cblxuLmZhLWdsYXNzLW1hcnRpbmk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMDBcIjsgfVxuXG4uZmEtZ2xpZGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYTVcIjsgfVxuXG4uZmEtZ2xpZGUtZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJhNlwiOyB9XG5cbi5mYS1nbG9iZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBhY1wiOyB9XG5cbi5mYS1nb2ZvcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYTdcIjsgfVxuXG4uZmEtZ29sZi1iYWxsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDUwXCI7IH1cblxuLmZhLWdvbGYtY2x1YjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ1MVwiOyB9XG5cbi5mYS1nb29kcmVhZHM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYThcIjsgfVxuXG4uZmEtZ29vZHJlYWRzLWc6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYTlcIjsgfVxuXG4uZmEtZ29vZ2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWEwXCI7IH1cblxuLmZhLWdvb2dsZS1kcml2ZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNhYVwiOyB9XG5cbi5mYS1nb29nbGUtcGxheTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNhYlwiOyB9XG5cbi5mYS1nb29nbGUtcGx1czpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJiM1wiOyB9XG5cbi5mYS1nb29nbGUtcGx1cy1nOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGQ1XCI7IH1cblxuLmZhLWdvb2dsZS1wbHVzLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBkNFwiOyB9XG5cbi5mYS1nb29nbGUtd2FsbGV0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWVlXCI7IH1cblxuLmZhLWdyYWR1YXRpb24tY2FwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTlkXCI7IH1cblxuLmZhLWdyYXRpcGF5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTg0XCI7IH1cblxuLmZhLWdyYXY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZDZcIjsgfVxuXG4uZmEtZ3JpcGZpcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYWNcIjsgfVxuXG4uZmEtZ3J1bnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYWRcIjsgfVxuXG4uZmEtZ3VscDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNhZVwiOyB9XG5cbi5mYS1oLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBmZFwiOyB9XG5cbi5mYS1oMTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMxM1wiOyB9XG5cbi5mYS1oMjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMxNFwiOyB9XG5cbi5mYS1oMzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMxNVwiOyB9XG5cbi5mYS1oYWNrZXItbmV3czpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFkNFwiOyB9XG5cbi5mYS1oYWNrZXItbmV3cy1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYWZcIjsgfVxuXG4uZmEtaGFuZC1ob2xkaW5nLWJveDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ3YlwiOyB9XG5cbi5mYS1oYW5kLWxpemFyZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI1OFwiOyB9XG5cbi5mYS1oYW5kLXBhcGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjU2XCI7IH1cblxuLmZhLWhhbmQtcGVhY2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNWJcIjsgfVxuXG4uZmEtaGFuZC1wb2ludC1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGE3XCI7IH1cblxuLmZhLWhhbmQtcG9pbnQtbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBhNVwiOyB9XG5cbi5mYS1oYW5kLXBvaW50LXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGE0XCI7IH1cblxuLmZhLWhhbmQtcG9pbnQtdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYTZcIjsgfVxuXG4uZmEtaGFuZC1wb2ludGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjVhXCI7IH1cblxuLmZhLWhhbmQtcmVjZWl2aW5nOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDdjXCI7IH1cblxuLmZhLWhhbmQtcm9jazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI1NVwiOyB9XG5cbi5mYS1oYW5kLXNjaXNzb3JzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjU3XCI7IH1cblxuLmZhLWhhbmQtc3BvY2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNTlcIjsgfVxuXG4uZmEtaGFuZHNoYWtlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmI1XCI7IH1cblxuLmZhLWhhc2h0YWc6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyOTJcIjsgfVxuXG4uZmEtaGRkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGEwXCI7IH1cblxuLmZhLWhlYWRpbmc6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZGNcIjsgfVxuXG4uZmEtaGVhZHBob25lczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAyNVwiOyB9XG5cbi5mYS1oZWFydDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAwNFwiOyB9XG5cbi5mYS1oZWFydGJlYXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMWVcIjsgfVxuXG4uZmEtaGV4YWdvbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMxMlwiOyB9XG5cbi5mYS1oaXBzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDUyXCI7IH1cblxuLmZhLWhpcmUtYS1oZWxwZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYjBcIjsgfVxuXG4uZmEtaGlzdG9yeTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFkYVwiOyB9XG5cbi5mYS1ob2NrZXktcHVjazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ1M1wiOyB9XG5cbi5mYS1ob2NrZXktc3RpY2tzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDU0XCI7IH1cblxuLmZhLWhvbWU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMTVcIjsgfVxuXG4uZmEtaG9vbGk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MjdcIjsgfVxuXG4uZmEtaG9zcGl0YWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZjhcIjsgfVxuXG4uZmEtaG9zcGl0YWwtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDdkXCI7IH1cblxuLmZhLWhvc3BpdGFsLXN5bWJvbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ3ZVwiOyB9XG5cbi5mYS1ob3RqYXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYjFcIjsgfVxuXG4uZmEtaG91cmdsYXNzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjU0XCI7IH1cblxuLmZhLWhvdXJnbGFzcy1lbmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNTNcIjsgfVxuXG4uZmEtaG91cmdsYXNzLWhhbGY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNTJcIjsgfVxuXG4uZmEtaG91cmdsYXNzLXN0YXJ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjUxXCI7IH1cblxuLmZhLWhvdXp6OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjdjXCI7IH1cblxuLmZhLWh0bWw1OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTNiXCI7IH1cblxuLmZhLWh1YnNwb3Q6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYjJcIjsgfVxuXG4uZmEtaS1jdXJzb3I6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNDZcIjsgfVxuXG4uZmEtaWQtYmFkZ2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYzFcIjsgfVxuXG4uZmEtaWQtY2FyZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJjMlwiOyB9XG5cbi5mYS1pZC1jYXJkLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ3ZlwiOyB9XG5cbi5mYS1pbWFnZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAzZVwiOyB9XG5cbi5mYS1pbWFnZXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMDJcIjsgfVxuXG4uZmEtaW1kYjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJkOFwiOyB9XG5cbi5mYS1pbmJveDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAxY1wiOyB9XG5cbi5mYS1pbmJveC1pbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMxMFwiOyB9XG5cbi5mYS1pbmJveC1vdXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMTFcIjsgfVxuXG4uZmEtaW5kZW50OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDNjXCI7IH1cblxuLmZhLWluZHVzdHJ5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjc1XCI7IH1cblxuLmZhLWluZHVzdHJ5LWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNiM1wiOyB9XG5cbi5mYS1pbmZvOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTI5XCI7IH1cblxuLmZhLWluZm8tY2lyY2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDVhXCI7IH1cblxuLmZhLWluZm8tc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzBmXCI7IH1cblxuLmZhLWluc3RhZ3JhbTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE2ZFwiOyB9XG5cbi5mYS1pbnRlcm5ldC1leHBsb3JlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI2YlwiOyB9XG5cbi5mYS1pbnZlbnRvcnk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0ODBcIjsgfVxuXG4uZmEtaW94aG9zdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIwOFwiOyB9XG5cbi5mYS1pdGFsaWM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMzNcIjsgfVxuXG4uZmEtaXR1bmVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2I0XCI7IH1cblxuLmZhLWl0dW5lcy1ub3RlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2I1XCI7IH1cblxuLmZhLWphY2stby1sYW50ZXJuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzBlXCI7IH1cblxuLmZhLWplbmtpbnM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYjZcIjsgfVxuXG4uZmEtam9nZXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYjdcIjsgfVxuXG4uZmEtam9vbWxhOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWFhXCI7IH1cblxuLmZhLWpzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2I4XCI7IH1cblxuLmZhLWpzLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNiOVwiOyB9XG5cbi5mYS1qc2ZpZGRsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFjY1wiOyB9XG5cbi5mYS1rZXk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwODRcIjsgfVxuXG4uZmEta2V5Ym9hcmQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMWNcIjsgfVxuXG4uZmEta2V5Y2RuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2JhXCI7IH1cblxuLmZhLWtpY2tzdGFydGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2JiXCI7IH1cblxuLmZhLWtpY2tzdGFydGVyLWs6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYmNcIjsgfVxuXG4uZmEta29ydnVlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDJmXCI7IH1cblxuLmZhLWxhbmd1YWdlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWFiXCI7IH1cblxuLmZhLWxhcHRvcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEwOVwiOyB9XG5cbi5mYS1sYXJhdmVsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2JkXCI7IH1cblxuLmZhLWxhc3RmbTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIwMlwiOyB9XG5cbi5mYS1sYXN0Zm0tc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjAzXCI7IH1cblxuLmZhLWxlYWY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNmNcIjsgfVxuXG4uZmEtbGVhbnB1YjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIxMlwiOyB9XG5cbi5mYS1sZW1vbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA5NFwiOyB9XG5cbi5mYS1sZXNzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDFkXCI7IH1cblxuLmZhLWxldmVsLWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNDlcIjsgfVxuXG4uZmEtbGV2ZWwtZG93bi1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYmVcIjsgfVxuXG4uZmEtbGV2ZWwtdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNDhcIjsgfVxuXG4uZmEtbGV2ZWwtdXAtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2JmXCI7IH1cblxuLmZhLWxpZmUtcmluZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFjZFwiOyB9XG5cbi5mYS1saWdodGJ1bGI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZWJcIjsgfVxuXG4uZmEtbGluZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNjMFwiOyB9XG5cbi5mYS1saW5rOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGMxXCI7IH1cblxuLmZhLWxpbmtlZGluOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDhjXCI7IH1cblxuLmZhLWxpbmtlZGluLWluOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGUxXCI7IH1cblxuLmZhLWxpbm9kZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJiOFwiOyB9XG5cbi5mYS1saW51eDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE3Y1wiOyB9XG5cbi5mYS1saXJhLXNpZ246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxOTVcIjsgfVxuXG4uZmEtbGlzdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAzYVwiOyB9XG5cbi5mYS1saXN0LWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAyMlwiOyB9XG5cbi5mYS1saXN0LW9sOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGNiXCI7IH1cblxuLmZhLWxpc3QtdWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwY2FcIjsgfVxuXG4uZmEtbG9jYXRpb24tYXJyb3c6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMjRcIjsgfVxuXG4uZmEtbG9jazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAyM1wiOyB9XG5cbi5mYS1sb2NrLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMwZFwiOyB9XG5cbi5mYS1sb2NrLW9wZW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYzFcIjsgfVxuXG4uZmEtbG9jay1vcGVuLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNjMlwiOyB9XG5cbi5mYS1sb25nLWFycm93LWFsdC1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzA5XCI7IH1cblxuLmZhLWxvbmctYXJyb3ctYWx0LWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMGFcIjsgfVxuXG4uZmEtbG9uZy1hcnJvdy1hbHQtcmlnaHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMGJcIjsgfVxuXG4uZmEtbG9uZy1hcnJvdy1hbHQtdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMGNcIjsgfVxuXG4uZmEtbG9uZy1hcnJvdy1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTc1XCI7IH1cblxuLmZhLWxvbmctYXJyb3ctbGVmdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE3N1wiOyB9XG5cbi5mYS1sb25nLWFycm93LXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTc4XCI7IH1cblxuLmZhLWxvbmctYXJyb3ctdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNzZcIjsgfVxuXG4uZmEtbG93LXZpc2lvbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJhOFwiOyB9XG5cbi5mYS1sdWNoYWRvcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ1NVwiOyB9XG5cbi5mYS1seWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2MzXCI7IH1cblxuLmZhLW1hZ2VudG86YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYzRcIjsgfVxuXG4uZmEtbWFnaWM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZDBcIjsgfVxuXG4uZmEtbWFnbmV0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDc2XCI7IH1cblxuLmZhLW1hbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxODNcIjsgfVxuXG4uZmEtbWFwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjc5XCI7IH1cblxuLmZhLW1hcC1tYXJrZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNDFcIjsgfVxuXG4uZmEtbWFwLW1hcmtlci1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYzVcIjsgfVxuXG4uZmEtbWFwLXBpbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI3NlwiOyB9XG5cbi5mYS1tYXAtc2lnbnM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNzdcIjsgfVxuXG4uZmEtbWFyczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIyMlwiOyB9XG5cbi5mYS1tYXJzLWRvdWJsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIyN1wiOyB9XG5cbi5mYS1tYXJzLXN0cm9rZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIyOVwiOyB9XG5cbi5mYS1tYXJzLXN0cm9rZS1oOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjJiXCI7IH1cblxuLmZhLW1hcnMtc3Ryb2tlLXY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMmFcIjsgfVxuXG4uZmEtbWF4Y2RuOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTM2XCI7IH1cblxuLmZhLW1lZGFwcHM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYzZcIjsgfVxuXG4uZmEtbWVkaXVtOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjNhXCI7IH1cblxuLmZhLW1lZGl1bS1tOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2M3XCI7IH1cblxuLmZhLW1lZGtpdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBmYVwiOyB9XG5cbi5mYS1tZWRydDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNjOFwiOyB9XG5cbi5mYS1tZWV0dXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZTBcIjsgfVxuXG4uZmEtbWVoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTFhXCI7IH1cblxuLmZhLW1lcmN1cnk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMjNcIjsgfVxuXG4uZmEtbWljcm9jaGlwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmRiXCI7IH1cblxuLmZhLW1pY3JvcGhvbmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMzBcIjsgfVxuXG4uZmEtbWljcm9waG9uZS1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzYzlcIjsgfVxuXG4uZmEtbWljcm9waG9uZS1zbGFzaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEzMVwiOyB9XG5cbi5mYS1taWNyb3NvZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzY2FcIjsgfVxuXG4uZmEtbWludXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwNjhcIjsgfVxuXG4uZmEtbWludXMtY2lyY2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDU2XCI7IH1cblxuLmZhLW1pbnVzLWhleGFnb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMDdcIjsgfVxuXG4uZmEtbWludXMtb2N0YWdvbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMwOFwiOyB9XG5cbi5mYS1taW51cy1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNDZcIjsgfVxuXG4uZmEtbWl4OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2NiXCI7IH1cblxuLmZhLW1peGNsb3VkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjg5XCI7IH1cblxuLmZhLW1penVuaTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNjY1wiOyB9XG5cbi5mYS1tb2JpbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMGJcIjsgfVxuXG4uZmEtbW9iaWxlLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNjZFwiOyB9XG5cbi5mYS1tb2JpbGUtYW5kcm9pZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNjZVwiOyB9XG5cbi5mYS1tb2JpbGUtYW5kcm9pZC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzY2ZcIjsgfVxuXG4uZmEtbW9keDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI4NVwiOyB9XG5cbi5mYS1tb25lcm86YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZDBcIjsgfVxuXG4uZmEtbW9uZXktYmlsbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBkNlwiOyB9XG5cbi5mYS1tb25leS1iaWxsLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNkMVwiOyB9XG5cbi5mYS1tb29uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTg2XCI7IH1cblxuLmZhLW1vdG9yY3ljbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMWNcIjsgfVxuXG4uZmEtbW91c2UtcG9pbnRlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI0NVwiOyB9XG5cbi5mYS1tdXNpYzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAwMVwiOyB9XG5cbi5mYS1uYXBzdGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2QyXCI7IH1cblxuLmZhLW5ldXRlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIyY1wiOyB9XG5cbi5mYS1uZXdzcGFwZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZWFcIjsgfVxuXG4uZmEtbmludGVuZG8tc3dpdGNoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDE4XCI7IH1cblxuLmZhLW5vZGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MTlcIjsgfVxuXG4uZmEtbm9kZS1qczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNkM1wiOyB9XG5cbi5mYS1ub3Rlcy1tZWRpY2FsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDgxXCI7IH1cblxuLmZhLW5wbTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNkNFwiOyB9XG5cbi5mYS1uczg6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZDVcIjsgfVxuXG4uZmEtbnV0cml0aW9uaXg6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZDZcIjsgfVxuXG4uZmEtb2JqZWN0LWdyb3VwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjQ3XCI7IH1cblxuLmZhLW9iamVjdC11bmdyb3VwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjQ4XCI7IH1cblxuLmZhLW9jdGFnb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMDZcIjsgfVxuXG4uZmEtb2Rub2tsYXNzbmlraTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI2M1wiOyB9XG5cbi5mYS1vZG5va2xhc3NuaWtpLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI2NFwiOyB9XG5cbi5mYS1vcGVuY2FydDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIzZFwiOyB9XG5cbi5mYS1vcGVuaWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxOWJcIjsgfVxuXG4uZmEtb3BlcmE6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNmFcIjsgfVxuXG4uZmEtb3B0aW4tbW9uc3RlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIzY1wiOyB9XG5cbi5mYS1vc2k6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MWFcIjsgfVxuXG4uZmEtb3V0ZGVudDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAzYlwiOyB9XG5cbi5mYS1wYWdlNDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNkN1wiOyB9XG5cbi5mYS1wYWdlbGluZXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxOGNcIjsgfVxuXG4uZmEtcGFpbnQtYnJ1c2g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZmNcIjsgfVxuXG4uZmEtcGFsZmVkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2Q4XCI7IH1cblxuLmZhLXBhbGxldDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ4MlwiOyB9XG5cbi5mYS1wYWxsZXQtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDgzXCI7IH1cblxuLmZhLXBhcGVyLXBsYW5lOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWQ4XCI7IH1cblxuLmZhLXBhcGVyY2xpcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBjNlwiOyB9XG5cbi5mYS1wYXJhZ3JhcGg6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZGRcIjsgfVxuXG4uZmEtcGFzdGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZWFcIjsgfVxuXG4uZmEtcGF0cmVvbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNkOVwiOyB9XG5cbi5mYS1wYXVzZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA0Y1wiOyB9XG5cbi5mYS1wYXVzZS1jaXJjbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyOGJcIjsgfVxuXG4uZmEtcGF3OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWIwXCI7IH1cblxuLmZhLXBheXBhbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFlZFwiOyB9XG5cbi5mYS1wZW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMDRcIjsgfVxuXG4uZmEtcGVuLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjMwNVwiOyB9XG5cbi5mYS1wZW4tc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTRiXCI7IH1cblxuLmZhLXBlbmNpbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA0MFwiOyB9XG5cbi5mYS1wZW5jaWwtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzAzXCI7IH1cblxuLmZhLXBlbm5hbnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NTZcIjsgfVxuXG4uZmEtcGVyY2VudDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI5NVwiOyB9XG5cbi5mYS1wZXJpc2NvcGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZGFcIjsgfVxuXG4uZmEtcGhhYnJpY2F0b3I6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZGJcIjsgfVxuXG4uZmEtcGhvZW5peC1mcmFtZXdvcms6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZGNcIjsgfVxuXG4uZmEtcGhvbmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwOTVcIjsgfVxuXG4uZmEtcGhvbmUtc2xhc2g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZGRcIjsgfVxuXG4uZmEtcGhvbmUtc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDk4XCI7IH1cblxuLmZhLXBob25lLXZvbHVtZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJhMFwiOyB9XG5cbi5mYS1waHA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NTdcIjsgfVxuXG4uZmEtcGllZC1waXBlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJhZVwiOyB9XG5cbi5mYS1waWVkLXBpcGVyLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFhOFwiOyB9XG5cbi5mYS1waWVkLXBpcGVyLXBwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWE3XCI7IH1cblxuLmZhLXBpbGxzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDg0XCI7IH1cblxuLmZhLXBpbnRlcmVzdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBkMlwiOyB9XG5cbi5mYS1waW50ZXJlc3QtcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIzMVwiOyB9XG5cbi5mYS1waW50ZXJlc3Qtc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGQzXCI7IH1cblxuLmZhLXBsYW5lOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDcyXCI7IH1cblxuLmZhLXBsYW5lLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNkZVwiOyB9XG5cbi5mYS1wbGF5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDRiXCI7IH1cblxuLmZhLXBsYXktY2lyY2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTQ0XCI7IH1cblxuLmZhLXBsYXlzdGF0aW9uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2RmXCI7IH1cblxuLmZhLXBsdWc6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZTZcIjsgfVxuXG4uZmEtcGx1czpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA2N1wiOyB9XG5cbi5mYS1wbHVzLWNpcmNsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA1NVwiOyB9XG5cbi5mYS1wbHVzLWhleGFnb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzMDBcIjsgfVxuXG4uZmEtcGx1cy1vY3RhZ29uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzAxXCI7IH1cblxuLmZhLXBsdXMtc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGZlXCI7IH1cblxuLmZhLXBvZGNhc3Q6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyY2VcIjsgfVxuXG4uZmEtcG9vOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmZlXCI7IH1cblxuLmZhLXBvcnRyYWl0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2UwXCI7IH1cblxuLmZhLXBvdW5kLXNpZ246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNTRcIjsgfVxuXG4uZmEtcG93ZXItb2ZmOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDExXCI7IH1cblxuLmZhLXByZXNjcmlwdGlvbi1ib3R0bGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0ODVcIjsgfVxuXG4uZmEtcHJlc2NyaXB0aW9uLWJvdHRsZS1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0ODZcIjsgfVxuXG4uZmEtcHJpbnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMmZcIjsgfVxuXG4uZmEtcHJvY2VkdXJlczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ4N1wiOyB9XG5cbi5mYS1wcm9kdWN0LWh1bnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyODhcIjsgfVxuXG4uZmEtcHVzaGVkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2UxXCI7IH1cblxuLmZhLXB1enpsZS1waWVjZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEyZVwiOyB9XG5cbi5mYS1weXRob246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZTJcIjsgfVxuXG4uZmEtcXE6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZDZcIjsgfVxuXG4uZmEtcXJjb2RlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDI5XCI7IH1cblxuLmZhLXF1ZXN0aW9uOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTI4XCI7IH1cblxuLmZhLXF1ZXN0aW9uLWNpcmNsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA1OVwiOyB9XG5cbi5mYS1xdWVzdGlvbi1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZmRcIjsgfVxuXG4uZmEtcXVpZGRpdGNoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDU4XCI7IH1cblxuLmZhLXF1aW5zY2FwZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ1OVwiOyB9XG5cbi5mYS1xdW9yYTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJjNFwiOyB9XG5cbi5mYS1xdW90ZS1sZWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTBkXCI7IH1cblxuLmZhLXF1b3RlLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTBlXCI7IH1cblxuLmZhLXJhY3F1ZXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NWFcIjsgfVxuXG4uZmEtcmFuZG9tOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDc0XCI7IH1cblxuLmZhLXJhdmVscnk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZDlcIjsgfVxuXG4uZmEtcmVhY3Q6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MWJcIjsgfVxuXG4uZmEtcmViZWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZDBcIjsgfVxuXG4uZmEtcmVjdGFuZ2xlLWxhbmRzY2FwZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJmYVwiOyB9XG5cbi5mYS1yZWN0YW5nbGUtcG9ydHJhaXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZmJcIjsgfVxuXG4uZmEtcmVjdGFuZ2xlLXdpZGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZmNcIjsgfVxuXG4uZmEtcmVjeWNsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFiOFwiOyB9XG5cbi5mYS1yZWQtcml2ZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZTNcIjsgfVxuXG4uZmEtcmVkZGl0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWExXCI7IH1cblxuLmZhLXJlZGRpdC1hbGllbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI4MVwiOyB9XG5cbi5mYS1yZWRkaXQtc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWEyXCI7IH1cblxuLmZhLXJlZG86YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMWVcIjsgfVxuXG4uZmEtcmVkby1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZjlcIjsgfVxuXG4uZmEtcmVnaXN0ZXJlZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI1ZFwiOyB9XG5cbi5mYS1yZW5kYWN0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2U0XCI7IH1cblxuLmZhLXJlbnJlbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE4YlwiOyB9XG5cbi5mYS1yZXBlYXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNjNcIjsgfVxuXG4uZmEtcmVwZWF0LTE6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNjVcIjsgfVxuXG4uZmEtcmVwZWF0LTEtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMzY2XCI7IH1cblxuLmZhLXJlcGVhdC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzNjRcIjsgfVxuXG4uZmEtcmVwbHk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZTVcIjsgfVxuXG4uZmEtcmVwbHktYWxsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTIyXCI7IH1cblxuLmZhLXJlcGx5ZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNlNlwiOyB9XG5cbi5mYS1yZXNvbHZpbmc6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZTdcIjsgfVxuXG4uZmEtcmV0d2VldDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA3OVwiOyB9XG5cbi5mYS1yZXR3ZWV0LWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM2MVwiOyB9XG5cbi5mYS1yb2FkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDE4XCI7IH1cblxuLmZhLXJvY2tldDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEzNVwiOyB9XG5cbi5mYS1yb2NrZXRjaGF0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2U4XCI7IH1cblxuLmZhLXJvY2tybXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZTlcIjsgfVxuXG4uZmEtcnNzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDllXCI7IH1cblxuLmZhLXJzcy1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNDNcIjsgfVxuXG4uZmEtcnVibGUtc2lnbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE1OFwiOyB9XG5cbi5mYS1ydXBlZS1zaWduOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTU2XCI7IH1cblxuLmZhLXNhZmFyaTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI2N1wiOyB9XG5cbi5mYS1zYXNzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDFlXCI7IH1cblxuLmZhLXNhdmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwYzdcIjsgfVxuXG4uZmEtc2Nhbm5lcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ4OFwiOyB9XG5cbi5mYS1zY2FubmVyLWtleWJvYXJkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDg5XCI7IH1cblxuLmZhLXNjYW5uZXItdG91Y2hzY3JlZW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0OGFcIjsgfVxuXG4uZmEtc2NobGl4OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2VhXCI7IH1cblxuLmZhLXNjcmliZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI4YVwiOyB9XG5cbi5mYS1zY3J1YmJlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJmOFwiOyB9XG5cbi5mYS1zZWFyY2g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMDJcIjsgfVxuXG4uZmEtc2VhcmNoLW1pbnVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDEwXCI7IH1cblxuLmZhLXNlYXJjaC1wbHVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDBlXCI7IH1cblxuLmZhLXNlYXJjaGVuZ2luOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2ViXCI7IH1cblxuLmZhLXNlbGxjYXN0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmRhXCI7IH1cblxuLmZhLXNlbGxzeTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIxM1wiOyB9XG5cbi5mYS1zZXJ2ZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMzNcIjsgfVxuXG4uZmEtc2VydmljZXN0YWNrOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2VjXCI7IH1cblxuLmZhLXNoYXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDY0XCI7IH1cblxuLmZhLXNoYXJlLWFsbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjM2N1wiOyB9XG5cbi5mYS1zaGFyZS1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZTBcIjsgfVxuXG4uZmEtc2hhcmUtYWx0LXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFlMVwiOyB9XG5cbi5mYS1zaGFyZS1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNGRcIjsgfVxuXG4uZmEtc2hla2VsLXNpZ246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMGJcIjsgfVxuXG4uZmEtc2hpZWxkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTMyXCI7IH1cblxuLmZhLXNoaWVsZC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZWRcIjsgfVxuXG4uZmEtc2hpZWxkLWNoZWNrOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmY3XCI7IH1cblxuLmZhLXNoaXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMWFcIjsgfVxuXG4uZmEtc2hpcHBpbmctZmFzdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ4YlwiOyB9XG5cbi5mYS1zaGlwcGluZy10aW1lZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ4Y1wiOyB9XG5cbi5mYS1zaGlydHNpbmJ1bGs6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMTRcIjsgfVxuXG4uZmEtc2hvcHBpbmctYmFnOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjkwXCI7IH1cblxuLmZhLXNob3BwaW5nLWJhc2tldDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI5MVwiOyB9XG5cbi5mYS1zaG9wcGluZy1jYXJ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDdhXCI7IH1cblxuLmZhLXNob3dlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJjY1wiOyB9XG5cbi5mYS1zaHV0dGxlY29jazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ1YlwiOyB9XG5cbi5mYS1zaWduLWluOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDkwXCI7IH1cblxuLmZhLXNpZ24taW4tYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmY2XCI7IH1cblxuLmZhLXNpZ24tbGFuZ3VhZ2U6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYTdcIjsgfVxuXG4uZmEtc2lnbi1vdXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwOGJcIjsgfVxuXG4uZmEtc2lnbi1vdXQtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmY1XCI7IH1cblxuLmZhLXNpZ25hbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAxMlwiOyB9XG5cbi5mYS1zaW1wbHlidWlsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIxNVwiOyB9XG5cbi5mYS1zaXN0cml4OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2VlXCI7IH1cblxuLmZhLXNpdGVtYXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwZThcIjsgfVxuXG4uZmEtc2t5YXRsYXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMTZcIjsgfVxuXG4uZmEtc2t5cGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxN2VcIjsgfVxuXG4uZmEtc2xhY2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxOThcIjsgfVxuXG4uZmEtc2xhY2staGFzaDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNlZlwiOyB9XG5cbi5mYS1zbGlkZXJzLWg6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZGVcIjsgfVxuXG4uZmEtc2xpZGVycy1oLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNmMFwiOyB9XG5cbi5mYS1zbGlkZXJzLXY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZjFcIjsgfVxuXG4uZmEtc2xpZGVycy12LXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNmMlwiOyB9XG5cbi5mYS1zbGlkZXNoYXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWU3XCI7IH1cblxuLmZhLXNtaWxlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTE4XCI7IH1cblxuLmZhLXNtb2tpbmc6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0OGRcIjsgfVxuXG4uZmEtc25hcGNoYXQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYWJcIjsgfVxuXG4uZmEtc25hcGNoYXQtZ2hvc3Q6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYWNcIjsgfVxuXG4uZmEtc25hcGNoYXQtc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmFkXCI7IH1cblxuLmZhLXNub3dmbGFrZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJkY1wiOyB9XG5cbi5mYS1zb3J0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGRjXCI7IH1cblxuLmZhLXNvcnQtYWxwaGEtZG93bjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE1ZFwiOyB9XG5cbi5mYS1zb3J0LWFscGhhLXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTVlXCI7IH1cblxuLmZhLXNvcnQtYW1vdW50LWRvd246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNjBcIjsgfVxuXG4uZmEtc29ydC1hbW91bnQtdXA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNjFcIjsgfVxuXG4uZmEtc29ydC1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGRkXCI7IH1cblxuLmZhLXNvcnQtbnVtZXJpYy1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTYyXCI7IH1cblxuLmZhLXNvcnQtbnVtZXJpYy11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE2M1wiOyB9XG5cbi5mYS1zb3J0LXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGRlXCI7IH1cblxuLmZhLXNvdW5kY2xvdWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYmVcIjsgfVxuXG4uZmEtc3BhY2Utc2h1dHRsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE5N1wiOyB9XG5cbi5mYS1zcGFkZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJmNFwiOyB9XG5cbi5mYS1zcGVha2FwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2YzXCI7IH1cblxuLmZhLXNwaW5uZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMTBcIjsgfVxuXG4uZmEtc3Bpbm5lci10aGlyZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNmNFwiOyB9XG5cbi5mYS1zcG90aWZ5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWJjXCI7IH1cblxuLmZhLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBjOFwiOyB9XG5cbi5mYS1zcXVhcmUtZnVsbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ1Y1wiOyB9XG5cbi5mYS1zdGFjay1leGNoYW5nZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE4ZFwiOyB9XG5cbi5mYS1zdGFjay1vdmVyZmxvdzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE2Y1wiOyB9XG5cbi5mYS1zdGFyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDA1XCI7IH1cblxuLmZhLXN0YXItZXhjbGFtYXRpb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZjNcIjsgfVxuXG4uZmEtc3Rhci1oYWxmOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDg5XCI7IH1cblxuLmZhLXN0YXlsaW5rZWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZjVcIjsgfVxuXG4uZmEtc3RlYW06YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYjZcIjsgfVxuXG4uZmEtc3RlYW0tc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWI3XCI7IH1cblxuLmZhLXN0ZWFtLXN5bWJvbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNmNlwiOyB9XG5cbi5mYS1zdGVwLWJhY2t3YXJkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDQ4XCI7IH1cblxuLmZhLXN0ZXAtZm9yd2FyZDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA1MVwiOyB9XG5cbi5mYS1zdGV0aG9zY29wZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBmMVwiOyB9XG5cbi5mYS1zdGlja2VyLW11bGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZjdcIjsgfVxuXG4uZmEtc3RpY2t5LW5vdGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNDlcIjsgfVxuXG4uZmEtc3RvcDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA0ZFwiOyB9XG5cbi5mYS1zdG9wLWNpcmNsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI4ZFwiOyB9XG5cbi5mYS1zdG9wd2F0Y2g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZjJcIjsgfVxuXG4uZmEtc3RyYXZhOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDI4XCI7IH1cblxuLmZhLXN0cmVldC12aWV3OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjFkXCI7IH1cblxuLmZhLXN0cmlrZXRocm91Z2g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwY2NcIjsgfVxuXG4uZmEtc3RyaXBlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDI5XCI7IH1cblxuLmZhLXN0cmlwZS1zOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDJhXCI7IH1cblxuLmZhLXN0dWRpb3ZpbmFyaTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjNmOFwiOyB9XG5cbi5mYS1zdHVtYmxldXBvbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFhNFwiOyB9XG5cbi5mYS1zdHVtYmxldXBvbi1jaXJjbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYTNcIjsgfVxuXG4uZmEtc3Vic2NyaXB0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTJjXCI7IH1cblxuLmZhLXN1YndheTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIzOVwiOyB9XG5cbi5mYS1zdWl0Y2FzZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBmMlwiOyB9XG5cbi5mYS1zdW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxODVcIjsgfVxuXG4uZmEtc3VwZXJwb3dlcnM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZGRcIjsgfVxuXG4uZmEtc3VwZXJzY3JpcHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxMmJcIjsgfVxuXG4uZmEtc3VwcGxlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2Y5XCI7IH1cblxuLmZhLXN5bmM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMjFcIjsgfVxuXG4uZmEtc3luYy1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZjFcIjsgfVxuXG4uZmEtc3lyaW5nZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ4ZVwiOyB9XG5cbi5mYS10YWJsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBjZVwiOyB9XG5cbi5mYS10YWJsZS10ZW5uaXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0NWRcIjsgfVxuXG4uZmEtdGFibGV0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTBhXCI7IH1cblxuLmZhLXRhYmxldC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZmFcIjsgfVxuXG4uZmEtdGFibGV0LWFuZHJvaWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZmJcIjsgfVxuXG4uZmEtdGFibGV0LWFuZHJvaWQtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2ZjXCI7IH1cblxuLmZhLXRhYmxldC1ydWdnZWQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0OGZcIjsgfVxuXG4uZmEtdGFibGV0czpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ5MFwiOyB9XG5cbi5mYS10YWNob21ldGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGU0XCI7IH1cblxuLmZhLXRhY2hvbWV0ZXItYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmM2ZkXCI7IH1cblxuLmZhLXRhZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAyYlwiOyB9XG5cbi5mYS10YWdzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDJjXCI7IH1cblxuLmZhLXRhc2tzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGFlXCI7IH1cblxuLmZhLXRheGk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxYmFcIjsgfVxuXG4uZmEtdGVsZWdyYW06YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYzZcIjsgfVxuXG4uZmEtdGVsZWdyYW0tcGxhbmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZmVcIjsgfVxuXG4uZmEtdGVuY2VudC13ZWlibzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFkNVwiOyB9XG5cbi5mYS10ZW5uaXMtYmFsbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ1ZVwiOyB9XG5cbi5mYS10ZXJtaW5hbDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjEyMFwiOyB9XG5cbi5mYS10ZXh0LWhlaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAzNFwiOyB9XG5cbi5mYS10ZXh0LXdpZHRoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDM1XCI7IH1cblxuLmZhLXRoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDBhXCI7IH1cblxuLmZhLXRoLWxhcmdlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDA5XCI7IH1cblxuLmZhLXRoLWxpc3Q6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMGJcIjsgfVxuXG4uZmEtdGhlbWVpc2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmIyXCI7IH1cblxuLmZhLXRoZXJtb21ldGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDkxXCI7IH1cblxuLmZhLXRoZXJtb21ldGVyLWVtcHR5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmNiXCI7IH1cblxuLmZhLXRoZXJtb21ldGVyLWZ1bGw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYzdcIjsgfVxuXG4uZmEtdGhlcm1vbWV0ZXItaGFsZjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJjOVwiOyB9XG5cbi5mYS10aGVybW9tZXRlci1xdWFydGVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmNhXCI7IH1cblxuLmZhLXRoZXJtb21ldGVyLXRocmVlLXF1YXJ0ZXJzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmM4XCI7IH1cblxuLmZhLXRodW1icy1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTY1XCI7IH1cblxuLmZhLXRodW1icy11cDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE2NFwiOyB9XG5cbi5mYS10aHVtYnRhY2s6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwOGRcIjsgfVxuXG4uZmEtdGlja2V0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTQ1XCI7IH1cblxuLmZhLXRpY2tldC1hbHQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYzZmZcIjsgfVxuXG4uZmEtdGltZXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMGRcIjsgfVxuXG4uZmEtdGltZXMtY2lyY2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDU3XCI7IH1cblxuLmZhLXRpbWVzLWhleGFnb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZWVcIjsgfVxuXG4uZmEtdGltZXMtb2N0YWdvbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJmMFwiOyB9XG5cbi5mYS10aW1lcy1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZDNcIjsgfVxuXG4uZmEtdGludDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA0M1wiOyB9XG5cbi5mYS10b2dnbGUtb2ZmOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjA0XCI7IH1cblxuLmZhLXRvZ2dsZS1vbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIwNVwiOyB9XG5cbi5mYS10cmFkZW1hcms6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNWNcIjsgfVxuXG4uZmEtdHJhaW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMzhcIjsgfVxuXG4uZmEtdHJhbnNnZW5kZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMjRcIjsgfVxuXG4uZmEtdHJhbnNnZW5kZXItYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjI1XCI7IH1cblxuLmZhLXRyYXNoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWY4XCI7IH1cblxuLmZhLXRyYXNoLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJlZFwiOyB9XG5cbi5mYS10cmVlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWJiXCI7IH1cblxuLmZhLXRyZWUtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDAwXCI7IH1cblxuLmZhLXRyZWxsbzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE4MVwiOyB9XG5cbi5mYS10cmlhbmdsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJlY1wiOyB9XG5cbi5mYS10cmlwYWR2aXNvcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI2MlwiOyB9XG5cbi5mYS10cm9waHk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwOTFcIjsgfVxuXG4uZmEtdHJvcGh5LWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJlYlwiOyB9XG5cbi5mYS10cnVjazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBkMVwiOyB9XG5cbi5mYS10dHk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZTRcIjsgfVxuXG4uZmEtdHVtYmxyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTczXCI7IH1cblxuLmZhLXR1bWJsci1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNzRcIjsgfVxuXG4uZmEtdHY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyNmNcIjsgfVxuXG4uZmEtdHYtcmV0cm86YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MDFcIjsgfVxuXG4uZmEtdHdpdGNoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWU4XCI7IH1cblxuLmZhLXR3aXR0ZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwOTlcIjsgfVxuXG4uZmEtdHdpdHRlci1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwODFcIjsgfVxuXG4uZmEtdHlwbzM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MmJcIjsgfVxuXG4uZmEtdWJlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQwMlwiOyB9XG5cbi5mYS11aWtpdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQwM1wiOyB9XG5cbi5mYS11bWJyZWxsYTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBlOVwiOyB9XG5cbi5mYS11bmRlcmxpbmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwY2RcIjsgfVxuXG4uZmEtdW5kbzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjBlMlwiOyB9XG5cbi5mYS11bmRvLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJlYVwiOyB9XG5cbi5mYS11bmlyZWdpc3RyeTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQwNFwiOyB9XG5cbi5mYS11bml2ZXJzYWwtYWNjZXNzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjlhXCI7IH1cblxuLmZhLXVuaXZlcnNpdHk6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxOWNcIjsgfVxuXG4uZmEtdW5saW5rOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTI3XCI7IH1cblxuLmZhLXVubG9jazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjA5Y1wiOyB9XG5cbi5mYS11bmxvY2stYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTNlXCI7IH1cblxuLmZhLXVudGFwcGQ6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MDVcIjsgfVxuXG4uZmEtdXBsb2FkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDkzXCI7IH1cblxuLmZhLXVzYjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI4N1wiOyB9XG5cbi5mYS11c2QtY2lyY2xlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmU4XCI7IH1cblxuLmZhLXVzZC1zcXVhcmU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZTlcIjsgfVxuXG4uZmEtdXNlcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjAwN1wiOyB9XG5cbi5mYS11c2VyLWFsdDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQwNlwiOyB9XG5cbi5mYS11c2VyLWNpcmNsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJiZFwiOyB9XG5cbi5mYS11c2VyLW1kOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGYwXCI7IH1cblxuLmZhLXVzZXItcGx1czpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIzNFwiOyB9XG5cbi5mYS11c2VyLXNlY3JldDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIxYlwiOyB9XG5cbi5mYS11c2VyLXRpbWVzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjM1XCI7IH1cblxuLmZhLXVzZXJzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGMwXCI7IH1cblxuLmZhLXVzc3VubmFoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDA3XCI7IH1cblxuLmZhLXV0ZW5zaWwtZm9yazpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJlM1wiOyB9XG5cbi5mYS11dGVuc2lsLWtuaWZlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmU0XCI7IH1cblxuLmZhLXV0ZW5zaWwtc3Bvb246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZTVcIjsgfVxuXG4uZmEtdXRlbnNpbHM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZTdcIjsgfVxuXG4uZmEtdXRlbnNpbHMtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmU2XCI7IH1cblxuLmZhLXZhYWRpbjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQwOFwiOyB9XG5cbi5mYS12ZW51czpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIyMVwiOyB9XG5cbi5mYS12ZW51cy1kb3VibGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMjZcIjsgfVxuXG4uZmEtdmVudXMtbWFyczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjIyOFwiOyB9XG5cbi5mYS12aWFjb2luOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjM3XCI7IH1cblxuLmZhLXZpYWRlbzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjJhOVwiOyB9XG5cbi5mYS12aWFkZW8tc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmFhXCI7IH1cblxuLmZhLXZpYWw6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0OTJcIjsgfVxuXG4uZmEtdmlhbHM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0OTNcIjsgfVxuXG4uZmEtdmliZXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MDlcIjsgfVxuXG4uZmEtdmlkZW86YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwM2RcIjsgfVxuXG4uZmEtdmltZW86YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MGFcIjsgfVxuXG4uZmEtdmltZW8tc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTk0XCI7IH1cblxuLmZhLXZpbWVvLXY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyN2RcIjsgfVxuXG4uZmEtdmluZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjFjYVwiOyB9XG5cbi5mYS12azpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE4OVwiOyB9XG5cbi5mYS12bnY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MGJcIjsgfVxuXG4uZmEtdm9sbGV5YmFsbC1iYWxsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDVmXCI7IH1cblxuLmZhLXZvbHVtZS1kb3duOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDI3XCI7IH1cblxuLmZhLXZvbHVtZS1tdXRlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmUyXCI7IH1cblxuLmZhLXZvbHVtZS1vZmY6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYwMjZcIjsgfVxuXG4uZmEtdm9sdW1lLXVwOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMDI4XCI7IH1cblxuLmZhLXZ1ZWpzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDFmXCI7IH1cblxuLmZhLXdhcmVob3VzZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ5NFwiOyB9XG5cbi5mYS13YXJlaG91c2UtYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDk1XCI7IH1cblxuLmZhLXdhdGNoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmUxXCI7IH1cblxuLmZhLXdlaWJvOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMThhXCI7IH1cblxuLmZhLXdlaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ5NlwiOyB9XG5cbi5mYS13ZWl4aW46YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZDdcIjsgfVxuXG4uZmEtd2hhdHNhcHA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyMzJcIjsgfVxuXG4uZmEtd2hhdHNhcHAtc3F1YXJlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDBjXCI7IH1cblxuLmZhLXdoZWVsY2hhaXI6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxOTNcIjsgfVxuXG4uZmEtd2hpc3RsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQ2MFwiOyB9XG5cbi5mYS13aG1jczpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQwZFwiOyB9XG5cbi5mYS13aWZpOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMWViXCI7IH1cblxuLmZhLXdpa2lwZWRpYS13OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMjY2XCI7IH1cblxuLmZhLXdpbmRvdzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQwZVwiOyB9XG5cbi5mYS13aW5kb3ctYWx0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDBmXCI7IH1cblxuLmZhLXdpbmRvdy1jbG9zZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQxMFwiOyB9XG5cbi5mYS13aW5kb3ctbWF4aW1pemU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyZDBcIjsgfVxuXG4uZmEtd2luZG93LW1pbmltaXplOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmQxXCI7IH1cblxuLmZhLXdpbmRvdy1yZXN0b3JlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmQyXCI7IH1cblxuLmZhLXdpbmRvd3M6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxN2FcIjsgfVxuXG4uZmEtd29uLXNpZ246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNTlcIjsgfVxuXG4uZmEtd29yZHByZXNzOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMTlhXCI7IH1cblxuLmZhLXdvcmRwcmVzcy1zaW1wbGU6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MTFcIjsgfVxuXG4uZmEtd3BiZWdpbm5lcjpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjI5N1wiOyB9XG5cbi5mYS13cGV4cGxvcmVyOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMmRlXCI7IH1cblxuLmZhLXdwZm9ybXM6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyOThcIjsgfVxuXG4uZmEtd3JlbmNoOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmMGFkXCI7IH1cblxuLmZhLXgtcmF5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDk3XCI7IH1cblxuLmZhLXhib3g6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGY0MTJcIjsgfVxuXG4uZmEteGluZzpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE2OFwiOyB9XG5cbi5mYS14aW5nLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE2OVwiOyB9XG5cbi5mYS15LWNvbWJpbmF0b3I6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyM2JcIjsgfVxuXG4uZmEteWFob286YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxOWVcIjsgfVxuXG4uZmEteWFuZGV4OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDEzXCI7IH1cblxuLmZhLXlhbmRleC1pbnRlcm5hdGlvbmFsOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXFxmNDE0XCI7IH1cblxuLmZhLXllbHA6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxZTlcIjsgfVxuXG4uZmEteWVuLXNpZ246YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYxNTdcIjsgfVxuXG4uZmEteW9hc3Q6YmVmb3JlIHtcbiAgY29udGVudDogXCJcXGYyYjFcIjsgfVxuXG4uZmEteW91dHViZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjE2N1wiOyB9XG5cbi5mYS15b3V0dWJlLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIlxcZjQzMVwiOyB9XG5cbi5zci1vbmx5IHtcbiAgYm9yZGVyOiAwO1xuICBjbGlwOiByZWN0KDAsIDAsIDAsIDApO1xuICBoZWlnaHQ6IDFweDtcbiAgbWFyZ2luOiAtMXB4O1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBwYWRkaW5nOiAwO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHdpZHRoOiAxcHg7IH1cblxuLnNyLW9ubHktZm9jdXNhYmxlOmFjdGl2ZSwgLnNyLW9ubHktZm9jdXNhYmxlOmZvY3VzIHtcbiAgY2xpcDogYXV0bztcbiAgaGVpZ2h0OiBhdXRvO1xuICBtYXJnaW46IDA7XG4gIG92ZXJmbG93OiB2aXNpYmxlO1xuICBwb3NpdGlvbjogc3RhdGljO1xuICB3aWR0aDogYXV0bzsgfVxuXG5ibG9ja3F1b3RlIHtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nOiAwOyB9XG4gIGJsb2NrcXVvdGUgcCB7XG4gICAgYm9yZGVyOiAxcHggc29saWQgI2U4ZThlODtcbiAgICBib3JkZXItbGVmdDogMC41cmVtIHNvbGlkICNlOGU4ZTg7XG4gICAgbWFyZ2luOiAuNXJlbSAwO1xuICAgIHBhZGRpbmc6IC41cmVtIDFyZW0gLjVyZW0gMS41cmVtOyB9XG5cbnByZSwgY29kZSB7XG4gIGJvcmRlci1yYWRpdXM6IC4yNWVtO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOGY4OyB9XG5cbnByZSB7XG4gIG92ZXJmbG93LXg6IGF1dG87XG4gIGZvbnQtc2l6ZTogLjlyZW07XG4gIHBhZGRpbmc6IDFyZW07IH1cbiAgcHJlIGNvZGUge1xuICAgIHBhZGRpbmc6IDA7IH1cblxuY29kZSB7XG4gIHBhZGRpbmc6IC4yZW0gLjVlbTsgfVxuXG5odG1sIHtcbiAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgSGVsdmV0aWNhLCBBcmlhbDtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBsaW5lLWhlaWdodDogMS41O1xuICBjb2xvcjogIzJCMkQzMzsgfVxuXG5ib2R5IHtcbiAgaGVpZ2h0OiAxMDAlOyB9XG5cbioge1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XG5cbi5iY3gtZG9jLW5hdiB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgYm90dG9tOiAwO1xuICB3aWR0aDogMzAwcHg7XG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgb3ZlcmZsb3cteTogYXV0bztcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YyZjJmMjtcbiAgcGFkZGluZzogLjVyZW07XG4gIHRyYW5zaXRpb246IGxlZnQgZWFzZSAyMDBtcztcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2U4ZThlODsgfVxuICAuYmN4LWRvYy1uYXYgaDEsIC5iY3gtZG9jLW5hdiBoMiwgLmJjeC1kb2MtbmF2IGgzLCAuYmN4LWRvYy1uYXYgaDQsIC5iY3gtZG9jLW5hdiBoNSwgLmJjeC1kb2MtbmF2IGg2IHtcbiAgICBtYXJnaW46IC44ZW0gMCAuNGVtOyB9XG4gIC5iY3gtZG9jLW5hdiAuY2xvc2UtbWVudSB7XG4gICAgZGlzcGxheTogbm9uZTsgfVxuXG4uYmN4LWRvYy1uYXYtYmFja2Ryb3Age1xuICBkaXNwbGF5OiBub25lOyB9XG5cbmEubGluayB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gIGZvbnQtc2l6ZTogLjg1cmVtOyB9XG4gIGEubGluay5yZW1vdGUtbGluayB7XG4gICAgZm9udC1zaXplOiAwLjc1cmVtO1xuICAgIG1hcmdpbjogNHB4IDA7IH1cbiAgYS5saW5rLmRlcHJlY2F0ZWQsIGEubGluay5kZXByZWNhdGVkOnZpc2l0ZWQge1xuICAgIHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoO1xuICAgIGNvbG9yOiAjNjY2OyB9XG4gIGEubGluaywgYS5saW5rOnZpc2l0ZWQge1xuICAgIGNvbG9yOiAjMkIyRDMzO1xuICAgIHBhZGRpbmc6IDRweCA1cHggNHB4IDEwcHg7XG4gICAgbWFyZ2luOiAycHggMDsgfVxuICBhLmxpbmsuYWN0aXZlLCBhLmxpbmsuYWN0aXZlLmRlcHJlY2F0ZWQsIGEubGluay5hY3RpdmU6dmlzaXRlZCwgYS5saW5rLmFjdGl2ZTp2aXNpdGVkLmRlcHJlY2F0ZWQge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM1RDk5QkQ7XG4gICAgY29sb3I6ICNmZmY7IH1cbiAgYS5saW5rOmhvdmVyLCBhLmxpbms6aG92ZXIuZGVwcmVjYXRlZCwgYS5saW5rOmhvdmVyOnZpc2l0ZWQsIGEubGluazpob3Zlcjp2aXNpdGVkLmRlcHJlY2F0ZWQge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM2NjY7XG4gICAgY29sb3I6ICNmZmY7IH1cbiAgICBhLmxpbms6aG92ZXIuYWN0aXZlLCBhLmxpbms6aG92ZXIuZGVwcmVjYXRlZC5hY3RpdmUsIGEubGluazpob3Zlcjp2aXNpdGVkLmFjdGl2ZSwgYS5saW5rOmhvdmVyOnZpc2l0ZWQuZGVwcmVjYXRlZC5hY3RpdmUge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzVEOTlCRDtcbiAgICAgIGNvbG9yOiAjZmZmOyB9XG5cbi5iY3gtZG9jLW1haW4ge1xuICB6LWluZGV4OiAxO1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDMwMHB4O1xuICBib3R0b206IDA7XG4gIHJpZ2h0OiAwO1xuICBwYWRkaW5nOiAxcmVtIC43NXJlbTtcbiAgdHJhbnNpdGlvbjogbGVmdCBlYXNlIDIwMG1zO1xuICBvdmVyZmxvdy14OiBoaWRkZW47XG4gIG92ZXJmbG93LXk6IGF1dG87IH1cblxuLmJjeC1vdmVybGF5LXNwaW5uZXIge1xuICBjb2xvcjogIzMwQTFDMTtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICByaWdodDogMDtcbiAgYm90dG9tOiAwO1xuICBjb2xvcjogIzVEOTlCRDsgfVxuXG4uYmN4LWRvYy1kZW1vIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC13cmFwOiBub3dyYXA7XG4gIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICBtYXJnaW4tbGVmdDogLS43NXJlbTtcbiAgbWFyZ2luLXJpZ2h0OiAtLjc1cmVtOyB9XG4gIC5iY3gtZG9jLW1haW4gPiAuYmN4LWRvYy1kZW1vIHtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGhlaWdodDogMTAwJTsgfVxuICBjb21wb3NlID4gLmJjeC1kb2MtZGVtbyB7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBib3gtc2hhZG93OiAwIDAgMXJlbSAjZThlOGU4OyB9XG4gIC5iY3gtZG9jLWRlbW8gLmRlbW8tYXBwIHtcbiAgICBtYXJnaW46IDFyZW07XG4gICAgZmxleC1ncm93OiAwOyB9XG4gIC5iY3gtZG9jLWRlbW8gLmRlbW8tY29kZSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGZsZXgtZ3JvdzogMTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IH1cbiAgICAuYmN4LWRvYy1kZW1vIC5kZW1vLWNvZGUgLmJjeC1zZWxlY3Qge1xuICAgICAgZmxleC1ncm93OiAwO1xuICAgICAgZmxleC1zaHJpbms6IDA7IH1cbiAgICAuYmN4LWRvYy1kZW1vIC5kZW1vLWNvZGUgZGlzcGxheS1zb3VyY2Uge1xuICAgICAgZmxleDogMSAxIDA7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cblxuLmRpc3BsYXktc291cmNlIHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxuXG5zZWxlY3QuYmN4LXNlbGVjdCB7XG4gIGFwcGVhcmFuY2U6IG5vbmU7XG4gIGJvcmRlci1yYWRpdXM6IDA7XG4gIGJvcmRlcjogMDtcbiAgY29sb3I6ICNmZmY7XG4gIHBhZGRpbmc6IC4yNXJlbSAuNXJlbSAuMjVyZW0gMS41cmVtO1xuICBmb250LXNpemU6IC44NXJlbTtcbiAgYmFja2dyb3VuZDogIzZkOTBhMyB1cmwoXCJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGY4LCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA0IDUnJTNFJTNDcGF0aCBmaWxsPSd3aGl0ZScgZD0nTTIgMEwwIDJoNHptMCA1TDAgM2g0eicvJTNFJTNDL3N2ZyUzRVwiKSBuby1yZXBlYXQgbGVmdCAwLjVyZW0gY2VudGVyO1xuICBiYWNrZ3JvdW5kLXNpemU6IDhweCAxMHB4OyB9XG5cbi5iY3gtb3Blbi1tZW51IHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgei1pbmRleDogMjtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICBtYXgtd2lkdGg6IDEwMCU7XG4gIHBhZGRpbmc6IC40cmVtIC42cmVtIC40cmVtIC41cmVtO1xuICBjb2xvcjogI2ZmZjtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzVEOTlCRDtcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IC42cmVtO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgY3Vyc29yOiBkZWZhdWx0OyB9XG4gIC5iY3gtb3Blbi1tZW51IC5mYS1iYXJzIHtcbiAgICBtYXJnaW4tcmlnaHQ6IC4yNXJlbTsgfVxuXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3MjBweCkge1xuICAuYmN4LWRvYy1tYWluID4gLmJjeC1kb2MtZGVtbyAuZGVtby1hcHAge1xuICAgIG1pbi1oZWlnaHQ6IDEwMHB4OyB9XG4gIGNvbXBvc2UgPiAuYmN4LWRvYy1kZW1vIC5kZW1vLWFwcCB7XG4gICAgbWluLXdpZHRoOiAzMDBweDsgfVxuICBjb21wb3NlID4gLmJjeC1kb2MtZGVtbyAuZGVtby1jb2RlIHtcbiAgICBtaW4taGVpZ2h0OiAzMDBweDsgfVxuICAuQ29kZU1pcnJvci1mdWxsc2NyZWVuIHtcbiAgICBsZWZ0OiAzMDBweDsgfVxuICAuYmN4LW9wZW4tbWVudSB7XG4gICAgbGVmdDogMzAwcHg7XG4gICAgbWF4LXdpZHRoOiBjYWxjKDEwMCUgLSAzMDBweCk7IH1cbiAgICAuYmN4LW9wZW4tbWVudSAuZmEtYmFycyB7XG4gICAgICBkaXNwbGF5OiBub25lOyB9IH1cblxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTAyMHB4KSB7XG4gIGNvbXBvc2UgPiAuYmN4LWRvYy1kZW1vIHtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyB9IH1cblxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNzIwcHgpIHtcbiAgY29tcG9zZSA+IC5iY3gtZG9jLWRlbW8gLmRlbW8tY29kZSB7XG4gICAgbWluLWhlaWdodDogMjAwcHg7IH1cbiAgLmJjeC1kb2MtbmF2IHtcbiAgICB6LWluZGV4OiA0O1xuICAgIGxlZnQ6IC0zMDBweDsgfVxuICAgIC5iY3gtZG9jLW5hdi5tZW51LW9wZW4ge1xuICAgICAgbGVmdDogMDtcbiAgICAgIGJveC1zaGFkb3c6IDAgMCAycmVtIHJnYmEoMCwgMCwgMCwgMC4zKTsgfVxuICAgICAgLmJjeC1kb2MtbmF2Lm1lbnUtb3BlbiAub3Blbi1tZW51IHtcbiAgICAgICAgZGlzcGxheTogbm9uZTsgfVxuICAgIC5iY3gtZG9jLW5hdiAuY2xvc2UtbWVudSB7XG4gICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHotaW5kZXg6IDI7XG4gICAgICB0b3A6IDA7XG4gICAgICByaWdodDogMDtcbiAgICAgIGZvbnQtc2l6ZTogMS4xcmVtO1xuICAgICAgcGFkZGluZzogLjRyZW0gLjVyZW0gLjRyZW0gLjZyZW07XG4gICAgICBjb2xvcjogIzY2NjtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNlOGU4ZTg7XG4gICAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAuNnJlbTsgfVxuICAuYmN4LWRvYy1uYXYtYmFja2Ryb3Age1xuICAgIHotaW5kZXg6IDM7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIGJvdHRvbTogMDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEwMiwgMTAyLCAxMDIsIDAuNik7IH1cbiAgLmJjeC1kb2MtbWFpbiB7XG4gICAgbGVmdDogMDsgfSB9XG4iLCJAZm9udC1mYWNlIHtcbiAgZm9udC1mYW1pbHk6ICdGb250IEF3ZXNvbWUgNSBCcmFuZHMnO1xuICBmb250LXN0eWxlOiBub3JtYWw7XG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG4gIHNyYzogdXJsKCRmYS1icmFuZHMtNDAwKSBmb3JtYXQoJ3dvZmYnKTtcbn1cblxuLmZhYiB7XG4gIGZvbnQtZmFtaWx5OiAnRm9udCBBd2Vzb21lIDUgQnJhbmRzJztcbn1cblxuQGZvbnQtZmFjZSB7XG4gIGZvbnQtZmFtaWx5OiAnRm9udCBBd2Vzb21lIDUgUHJvJztcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xuICBmb250LXdlaWdodDogMzAwO1xuICBzcmM6IHVybCgkZmEtbGlnaHQtMzAwKSBmb3JtYXQoJ3dvZmYnKTtcbn1cblxuLmZhbCB7XG4gIGZvbnQtZmFtaWx5OiAnRm9udCBBd2Vzb21lIDUgUHJvJztcbiAgZm9udC13ZWlnaHQ6IDMwMDtcbn1cblxuQGZvbnQtZmFjZSB7XG4gIGZvbnQtZmFtaWx5OiAnRm9udCBBd2Vzb21lIDUgUHJvJztcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xuICBmb250LXdlaWdodDogNDAwO1xuICBzcmM6IHVybCgkZmEtcmVndWxhci00MDApIGZvcm1hdCgnd29mZicpO1xufVxuXG4uZmFyIHtcbiAgZm9udC1mYW1pbHk6ICdGb250IEF3ZXNvbWUgNSBQcm8nO1xuICBmb250LXdlaWdodDogNDAwO1xufVxuXG5AZm9udC1mYWNlIHtcbiAgZm9udC1mYW1pbHk6ICdGb250IEF3ZXNvbWUgNSBQcm8nO1xuICBmb250LXN0eWxlOiBub3JtYWw7XG4gIGZvbnQtd2VpZ2h0OiA5MDA7XG4gIHNyYzogdXJsKCRmYS1zb2xpZC05MDApIGZvcm1hdCgnd29mZicpO1xufVxuXG4uZmEsXG4uZmFzIHtcbiAgZm9udC1mYW1pbHk6ICdGb250IEF3ZXNvbWUgNSBQcm8nO1xuICBmb250LXdlaWdodDogOTAwO1xufVxuXG5cbiIsIi8qIVxuICogRm9udCBBd2Vzb21lIFBybyA1LjAuNyBieSBAZm9udGF3ZXNvbWUgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbVxuICogTGljZW5zZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tL2xpY2Vuc2UgKENvbW1lcmNpYWwgTGljZW5zZSlcbiAqL1xuQGltcG9ydCAndmFyaWFibGVzJztcbkBpbXBvcnQgJ21peGlucyc7XG5AaW1wb3J0ICdjb3JlJztcbkBpbXBvcnQgJ2xhcmdlcic7XG5AaW1wb3J0ICdmaXhlZC13aWR0aCc7XG5AaW1wb3J0ICdsaXN0JztcbkBpbXBvcnQgJ2JvcmRlcmVkLXB1bGxlZCc7XG5AaW1wb3J0ICdhbmltYXRlZCc7XG5AaW1wb3J0ICdyb3RhdGVkLWZsaXBwZWQnO1xuQGltcG9ydCAnc3RhY2tlZCc7XG5AaW1wb3J0ICdpY29ucyc7XG5AaW1wb3J0ICdzY3JlZW4tcmVhZGVyJztcbiIsIi8vIEJhc2UgQ2xhc3MgRGVmaW5pdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4uI3skZmEtY3NzLXByZWZpeH0sXG4uZmFzLFxuLmZhcixcbi5mYWwsXG4uZmFiIHtcbiAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xuICBmb250LXZhcmlhbnQ6IG5vcm1hbDtcbiAgdGV4dC1yZW5kZXJpbmc6IGF1dG87XG4gIGxpbmUtaGVpZ2h0OiAxO1xufVxuIiwiLy8gSWNvbiBTaXplc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBtYWtlcyB0aGUgZm9udCAzMyUgbGFyZ2VyIHJlbGF0aXZlIHRvIHRoZSBpY29uIGNvbnRhaW5lclxuLiN7JGZhLWNzcy1wcmVmaXh9LWxnIHtcbiAgZm9udC1zaXplOiAoNGVtIC8gMyk7XG4gIGxpbmUtaGVpZ2h0OiAoM2VtIC8gNCk7XG4gIHZlcnRpY2FsLWFsaWduOiAtLjA2NjdlbTtcbn1cblxuLiN7JGZhLWNzcy1wcmVmaXh9LXhzIHtcbiAgZm9udC1zaXplOiAuNzVlbTtcbn1cblxuLiN7JGZhLWNzcy1wcmVmaXh9LXNtIHtcbiAgZm9udC1zaXplOiAuODc1ZW07XG59XG5cbkBmb3IgJGkgZnJvbSAxIHRocm91Z2ggMTAge1xuICAuI3skZmEtY3NzLXByZWZpeH0tI3skaX14IHtcbiAgICBmb250LXNpemU6ICRpICogMWVtO1xuICB9XG59XG4iLCIvLyBGaXhlZCBXaWR0aCBJY29uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZ3IHtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB3aWR0aDogKDIwZW0gLyAxNik7XG59XG4iLCIvLyBMaXN0IEljb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi4jeyRmYS1jc3MtcHJlZml4fS11bCB7XG4gIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcbiAgbWFyZ2luLWxlZnQ6ICRmYS1saS13aWR0aCAqIDUvNDtcbiAgcGFkZGluZy1sZWZ0OiAwO1xuXG4gID4gbGkgeyBwb3NpdGlvbjogcmVsYXRpdmU7IH1cbn1cblxuLiN7JGZhLWNzcy1wcmVmaXh9LWxpIHtcbiAgbGVmdDogLSRmYS1saS13aWR0aDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIHdpZHRoOiAkZmEtbGktd2lkdGg7XG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xufVxuIiwiLy8gVmFyaWFibGVzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4kZmEtZm9udC1wYXRoOiAgICAgICAgICAgICAgICBcIi4uL3dlYmZvbnRzXCIgIWRlZmF1bHQ7XG4kZmEtZm9udC1zaXplLWJhc2U6ICAgICAgICAgICAxNnB4ICFkZWZhdWx0O1xuJGZhLWNzcy1wcmVmaXg6ICAgICAgICAgICAgICAgZmEgIWRlZmF1bHQ7XG4kZmEtdmVyc2lvbjogICAgICAgICAgICAgICAgICBcIjUuMC43XCIgIWRlZmF1bHQ7XG4kZmEtYm9yZGVyLWNvbG9yOiAgICAgICAgICAgICAjZWVlICFkZWZhdWx0O1xuJGZhLWludmVyc2U6ICAgICAgICAgICAgICAgICAgI2ZmZiAhZGVmYXVsdDtcbiRmYS1saS13aWR0aDogICAgICAgICAgICAgICAgIDJlbSAhZGVmYXVsdDtcblxuLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gdXNlZCB0byBzZXQgY29udGVudCBwcm9wZXJ0eVxuQGZ1bmN0aW9uIGZhLWNvbnRlbnQoJGZhLXZhcikge1xuICBAcmV0dXJuIHVucXVvdGUoXCJcXFwiI3sgJGZhLXZhciB9XFxcIlwiKTtcbn1cblxuJGZhLXZhci01MDBweDogXFxmMjZlO1xuJGZhLXZhci1hY2Nlc3NpYmxlLWljb246IFxcZjM2ODtcbiRmYS12YXItYWNjdXNvZnQ6IFxcZjM2OTtcbiRmYS12YXItYWRkcmVzcy1ib29rOiBcXGYyYjk7XG4kZmEtdmFyLWFkZHJlc3MtY2FyZDogXFxmMmJiO1xuJGZhLXZhci1hZGp1c3Q6IFxcZjA0MjtcbiRmYS12YXItYWRuOiBcXGYxNzA7XG4kZmEtdmFyLWFkdmVyc2FsOiBcXGYzNmE7XG4kZmEtdmFyLWFmZmlsaWF0ZXRoZW1lOiBcXGYzNmI7XG4kZmEtdmFyLWFsYXJtLWNsb2NrOiBcXGYzNGU7XG4kZmEtdmFyLWFsZ29saWE6IFxcZjM2YztcbiRmYS12YXItYWxpZ24tY2VudGVyOiBcXGYwMzc7XG4kZmEtdmFyLWFsaWduLWp1c3RpZnk6IFxcZjAzOTtcbiRmYS12YXItYWxpZ24tbGVmdDogXFxmMDM2O1xuJGZhLXZhci1hbGlnbi1yaWdodDogXFxmMDM4O1xuJGZhLXZhci1hbGxlcmdpZXM6IFxcZjQ2MTtcbiRmYS12YXItYW1hem9uOiBcXGYyNzA7XG4kZmEtdmFyLWFtYXpvbi1wYXk6IFxcZjQyYztcbiRmYS12YXItYW1idWxhbmNlOiBcXGYwZjk7XG4kZmEtdmFyLWFtZXJpY2FuLXNpZ24tbGFuZ3VhZ2UtaW50ZXJwcmV0aW5nOiBcXGYyYTM7XG4kZmEtdmFyLWFtaWxpYTogXFxmMzZkO1xuJGZhLXZhci1hbmNob3I6IFxcZjEzZDtcbiRmYS12YXItYW5kcm9pZDogXFxmMTdiO1xuJGZhLXZhci1hbmdlbGxpc3Q6IFxcZjIwOTtcbiRmYS12YXItYW5nbGUtZG91YmxlLWRvd246IFxcZjEwMztcbiRmYS12YXItYW5nbGUtZG91YmxlLWxlZnQ6IFxcZjEwMDtcbiRmYS12YXItYW5nbGUtZG91YmxlLXJpZ2h0OiBcXGYxMDE7XG4kZmEtdmFyLWFuZ2xlLWRvdWJsZS11cDogXFxmMTAyO1xuJGZhLXZhci1hbmdsZS1kb3duOiBcXGYxMDc7XG4kZmEtdmFyLWFuZ2xlLWxlZnQ6IFxcZjEwNDtcbiRmYS12YXItYW5nbGUtcmlnaHQ6IFxcZjEwNTtcbiRmYS12YXItYW5nbGUtdXA6IFxcZjEwNjtcbiRmYS12YXItYW5ncnljcmVhdGl2ZTogXFxmMzZlO1xuJGZhLXZhci1hbmd1bGFyOiBcXGY0MjA7XG4kZmEtdmFyLWFwcC1zdG9yZTogXFxmMzZmO1xuJGZhLXZhci1hcHAtc3RvcmUtaW9zOiBcXGYzNzA7XG4kZmEtdmFyLWFwcGVyOiBcXGYzNzE7XG4kZmEtdmFyLWFwcGxlOiBcXGYxNzk7XG4kZmEtdmFyLWFwcGxlLXBheTogXFxmNDE1O1xuJGZhLXZhci1hcmNoaXZlOiBcXGYxODc7XG4kZmEtdmFyLWFycm93LWFsdC1jaXJjbGUtZG93bjogXFxmMzU4O1xuJGZhLXZhci1hcnJvdy1hbHQtY2lyY2xlLWxlZnQ6IFxcZjM1OTtcbiRmYS12YXItYXJyb3ctYWx0LWNpcmNsZS1yaWdodDogXFxmMzVhO1xuJGZhLXZhci1hcnJvdy1hbHQtY2lyY2xlLXVwOiBcXGYzNWI7XG4kZmEtdmFyLWFycm93LWFsdC1kb3duOiBcXGYzNTQ7XG4kZmEtdmFyLWFycm93LWFsdC1mcm9tLWJvdHRvbTogXFxmMzQ2O1xuJGZhLXZhci1hcnJvdy1hbHQtZnJvbS1sZWZ0OiBcXGYzNDc7XG4kZmEtdmFyLWFycm93LWFsdC1mcm9tLXJpZ2h0OiBcXGYzNDg7XG4kZmEtdmFyLWFycm93LWFsdC1mcm9tLXRvcDogXFxmMzQ5O1xuJGZhLXZhci1hcnJvdy1hbHQtbGVmdDogXFxmMzU1O1xuJGZhLXZhci1hcnJvdy1hbHQtcmlnaHQ6IFxcZjM1NjtcbiRmYS12YXItYXJyb3ctYWx0LXNxdWFyZS1kb3duOiBcXGYzNTA7XG4kZmEtdmFyLWFycm93LWFsdC1zcXVhcmUtbGVmdDogXFxmMzUxO1xuJGZhLXZhci1hcnJvdy1hbHQtc3F1YXJlLXJpZ2h0OiBcXGYzNTI7XG4kZmEtdmFyLWFycm93LWFsdC1zcXVhcmUtdXA6IFxcZjM1MztcbiRmYS12YXItYXJyb3ctYWx0LXRvLWJvdHRvbTogXFxmMzRhO1xuJGZhLXZhci1hcnJvdy1hbHQtdG8tbGVmdDogXFxmMzRiO1xuJGZhLXZhci1hcnJvdy1hbHQtdG8tcmlnaHQ6IFxcZjM0YztcbiRmYS12YXItYXJyb3ctYWx0LXRvLXRvcDogXFxmMzRkO1xuJGZhLXZhci1hcnJvdy1hbHQtdXA6IFxcZjM1NztcbiRmYS12YXItYXJyb3ctY2lyY2xlLWRvd246IFxcZjBhYjtcbiRmYS12YXItYXJyb3ctY2lyY2xlLWxlZnQ6IFxcZjBhODtcbiRmYS12YXItYXJyb3ctY2lyY2xlLXJpZ2h0OiBcXGYwYTk7XG4kZmEtdmFyLWFycm93LWNpcmNsZS11cDogXFxmMGFhO1xuJGZhLXZhci1hcnJvdy1kb3duOiBcXGYwNjM7XG4kZmEtdmFyLWFycm93LWZyb20tYm90dG9tOiBcXGYzNDI7XG4kZmEtdmFyLWFycm93LWZyb20tbGVmdDogXFxmMzQzO1xuJGZhLXZhci1hcnJvdy1mcm9tLXJpZ2h0OiBcXGYzNDQ7XG4kZmEtdmFyLWFycm93LWZyb20tdG9wOiBcXGYzNDU7XG4kZmEtdmFyLWFycm93LWxlZnQ6IFxcZjA2MDtcbiRmYS12YXItYXJyb3ctcmlnaHQ6IFxcZjA2MTtcbiRmYS12YXItYXJyb3ctc3F1YXJlLWRvd246IFxcZjMzOTtcbiRmYS12YXItYXJyb3ctc3F1YXJlLWxlZnQ6IFxcZjMzYTtcbiRmYS12YXItYXJyb3ctc3F1YXJlLXJpZ2h0OiBcXGYzM2I7XG4kZmEtdmFyLWFycm93LXNxdWFyZS11cDogXFxmMzNjO1xuJGZhLXZhci1hcnJvdy10by1ib3R0b206IFxcZjMzZDtcbiRmYS12YXItYXJyb3ctdG8tbGVmdDogXFxmMzNlO1xuJGZhLXZhci1hcnJvdy10by1yaWdodDogXFxmMzQwO1xuJGZhLXZhci1hcnJvdy10by10b3A6IFxcZjM0MTtcbiRmYS12YXItYXJyb3ctdXA6IFxcZjA2MjtcbiRmYS12YXItYXJyb3dzOiBcXGYwNDc7XG4kZmEtdmFyLWFycm93cy1hbHQ6IFxcZjBiMjtcbiRmYS12YXItYXJyb3dzLWFsdC1oOiBcXGYzMzc7XG4kZmEtdmFyLWFycm93cy1hbHQtdjogXFxmMzM4O1xuJGZhLXZhci1hcnJvd3MtaDogXFxmMDdlO1xuJGZhLXZhci1hcnJvd3MtdjogXFxmMDdkO1xuJGZhLXZhci1hc3Npc3RpdmUtbGlzdGVuaW5nLXN5c3RlbXM6IFxcZjJhMjtcbiRmYS12YXItYXN0ZXJpc2s6IFxcZjA2OTtcbiRmYS12YXItYXN5bW1ldHJpazogXFxmMzcyO1xuJGZhLXZhci1hdDogXFxmMWZhO1xuJGZhLXZhci1hdWRpYmxlOiBcXGYzNzM7XG4kZmEtdmFyLWF1ZGlvLWRlc2NyaXB0aW9uOiBcXGYyOWU7XG4kZmEtdmFyLWF1dG9wcmVmaXhlcjogXFxmNDFjO1xuJGZhLXZhci1hdmlhbmV4OiBcXGYzNzQ7XG4kZmEtdmFyLWF2aWF0bzogXFxmNDIxO1xuJGZhLXZhci1hd3M6IFxcZjM3NTtcbiRmYS12YXItYmFja3dhcmQ6IFxcZjA0YTtcbiRmYS12YXItYmFkZ2U6IFxcZjMzNTtcbiRmYS12YXItYmFkZ2UtY2hlY2s6IFxcZjMzNjtcbiRmYS12YXItYmFsYW5jZS1zY2FsZTogXFxmMjRlO1xuJGZhLXZhci1iYW46IFxcZjA1ZTtcbiRmYS12YXItYmFuZC1haWQ6IFxcZjQ2MjtcbiRmYS12YXItYmFuZGNhbXA6IFxcZjJkNTtcbiRmYS12YXItYmFyY29kZTogXFxmMDJhO1xuJGZhLXZhci1iYXJjb2RlLWFsdDogXFxmNDYzO1xuJGZhLXZhci1iYXJjb2RlLXJlYWQ6IFxcZjQ2NDtcbiRmYS12YXItYmFyY29kZS1zY2FuOiBcXGY0NjU7XG4kZmEtdmFyLWJhcnM6IFxcZjBjOTtcbiRmYS12YXItYmFzZWJhbGw6IFxcZjQzMjtcbiRmYS12YXItYmFzZWJhbGwtYmFsbDogXFxmNDMzO1xuJGZhLXZhci1iYXNrZXRiYWxsLWJhbGw6IFxcZjQzNDtcbiRmYS12YXItYmFza2V0YmFsbC1ob29wOiBcXGY0MzU7XG4kZmEtdmFyLWJhdGg6IFxcZjJjZDtcbiRmYS12YXItYmF0dGVyeS1ib2x0OiBcXGYzNzY7XG4kZmEtdmFyLWJhdHRlcnktZW1wdHk6IFxcZjI0NDtcbiRmYS12YXItYmF0dGVyeS1mdWxsOiBcXGYyNDA7XG4kZmEtdmFyLWJhdHRlcnktaGFsZjogXFxmMjQyO1xuJGZhLXZhci1iYXR0ZXJ5LXF1YXJ0ZXI6IFxcZjI0MztcbiRmYS12YXItYmF0dGVyeS1zbGFzaDogXFxmMzc3O1xuJGZhLXZhci1iYXR0ZXJ5LXRocmVlLXF1YXJ0ZXJzOiBcXGYyNDE7XG4kZmEtdmFyLWJlZDogXFxmMjM2O1xuJGZhLXZhci1iZWVyOiBcXGYwZmM7XG4kZmEtdmFyLWJlaGFuY2U6IFxcZjFiNDtcbiRmYS12YXItYmVoYW5jZS1zcXVhcmU6IFxcZjFiNTtcbiRmYS12YXItYmVsbDogXFxmMGYzO1xuJGZhLXZhci1iZWxsLXNsYXNoOiBcXGYxZjY7XG4kZmEtdmFyLWJpY3ljbGU6IFxcZjIwNjtcbiRmYS12YXItYmltb2JqZWN0OiBcXGYzNzg7XG4kZmEtdmFyLWJpbm9jdWxhcnM6IFxcZjFlNTtcbiRmYS12YXItYmlydGhkYXktY2FrZTogXFxmMWZkO1xuJGZhLXZhci1iaXRidWNrZXQ6IFxcZjE3MTtcbiRmYS12YXItYml0Y29pbjogXFxmMzc5O1xuJGZhLXZhci1iaXR5OiBcXGYzN2E7XG4kZmEtdmFyLWJsYWNrLXRpZTogXFxmMjdlO1xuJGZhLXZhci1ibGFja2JlcnJ5OiBcXGYzN2I7XG4kZmEtdmFyLWJsaW5kOiBcXGYyOWQ7XG4kZmEtdmFyLWJsb2dnZXI6IFxcZjM3YztcbiRmYS12YXItYmxvZ2dlci1iOiBcXGYzN2Q7XG4kZmEtdmFyLWJsdWV0b290aDogXFxmMjkzO1xuJGZhLXZhci1ibHVldG9vdGgtYjogXFxmMjk0O1xuJGZhLXZhci1ib2xkOiBcXGYwMzI7XG4kZmEtdmFyLWJvbHQ6IFxcZjBlNztcbiRmYS12YXItYm9tYjogXFxmMWUyO1xuJGZhLXZhci1ib29rOiBcXGYwMmQ7XG4kZmEtdmFyLWJvb2ttYXJrOiBcXGYwMmU7XG4kZmEtdmFyLWJvd2xpbmctYmFsbDogXFxmNDM2O1xuJGZhLXZhci1ib3dsaW5nLXBpbnM6IFxcZjQzNztcbiRmYS12YXItYm94OiBcXGY0NjY7XG4kZmEtdmFyLWJveC1jaGVjazogXFxmNDY3O1xuJGZhLXZhci1ib3hlczogXFxmNDY4O1xuJGZhLXZhci1ib3hpbmctZ2xvdmU6IFxcZjQzODtcbiRmYS12YXItYnJhaWxsZTogXFxmMmExO1xuJGZhLXZhci1icmllZmNhc2U6IFxcZjBiMTtcbiRmYS12YXItYnJpZWZjYXNlLW1lZGljYWw6IFxcZjQ2OTtcbiRmYS12YXItYnJvd3NlcjogXFxmMzdlO1xuJGZhLXZhci1idGM6IFxcZjE1YTtcbiRmYS12YXItYnVnOiBcXGYxODg7XG4kZmEtdmFyLWJ1aWxkaW5nOiBcXGYxYWQ7XG4kZmEtdmFyLWJ1bGxob3JuOiBcXGYwYTE7XG4kZmEtdmFyLWJ1bGxzZXllOiBcXGYxNDA7XG4kZmEtdmFyLWJ1cm46IFxcZjQ2YTtcbiRmYS12YXItYnVyb21vYmVsZXhwZXJ0ZTogXFxmMzdmO1xuJGZhLXZhci1idXM6IFxcZjIwNztcbiRmYS12YXItYnV5c2VsbGFkczogXFxmMjBkO1xuJGZhLXZhci1jYWxjdWxhdG9yOiBcXGYxZWM7XG4kZmEtdmFyLWNhbGVuZGFyOiBcXGYxMzM7XG4kZmEtdmFyLWNhbGVuZGFyLWFsdDogXFxmMDczO1xuJGZhLXZhci1jYWxlbmRhci1jaGVjazogXFxmMjc0O1xuJGZhLXZhci1jYWxlbmRhci1lZGl0OiBcXGYzMzM7XG4kZmEtdmFyLWNhbGVuZGFyLWV4Y2xhbWF0aW9uOiBcXGYzMzQ7XG4kZmEtdmFyLWNhbGVuZGFyLW1pbnVzOiBcXGYyNzI7XG4kZmEtdmFyLWNhbGVuZGFyLXBsdXM6IFxcZjI3MTtcbiRmYS12YXItY2FsZW5kYXItdGltZXM6IFxcZjI3MztcbiRmYS12YXItY2FtZXJhOiBcXGYwMzA7XG4kZmEtdmFyLWNhbWVyYS1hbHQ6IFxcZjMzMjtcbiRmYS12YXItY2FtZXJhLXJldHJvOiBcXGYwODM7XG4kZmEtdmFyLWNhcHN1bGVzOiBcXGY0NmI7XG4kZmEtdmFyLWNhcjogXFxmMWI5O1xuJGZhLXZhci1jYXJldC1jaXJjbGUtZG93bjogXFxmMzJkO1xuJGZhLXZhci1jYXJldC1jaXJjbGUtbGVmdDogXFxmMzJlO1xuJGZhLXZhci1jYXJldC1jaXJjbGUtcmlnaHQ6IFxcZjMzMDtcbiRmYS12YXItY2FyZXQtY2lyY2xlLXVwOiBcXGYzMzE7XG4kZmEtdmFyLWNhcmV0LWRvd246IFxcZjBkNztcbiRmYS12YXItY2FyZXQtbGVmdDogXFxmMGQ5O1xuJGZhLXZhci1jYXJldC1yaWdodDogXFxmMGRhO1xuJGZhLXZhci1jYXJldC1zcXVhcmUtZG93bjogXFxmMTUwO1xuJGZhLXZhci1jYXJldC1zcXVhcmUtbGVmdDogXFxmMTkxO1xuJGZhLXZhci1jYXJldC1zcXVhcmUtcmlnaHQ6IFxcZjE1MjtcbiRmYS12YXItY2FyZXQtc3F1YXJlLXVwOiBcXGYxNTE7XG4kZmEtdmFyLWNhcmV0LXVwOiBcXGYwZDg7XG4kZmEtdmFyLWNhcnQtYXJyb3ctZG93bjogXFxmMjE4O1xuJGZhLXZhci1jYXJ0LXBsdXM6IFxcZjIxNztcbiRmYS12YXItY2MtYW1hem9uLXBheTogXFxmNDJkO1xuJGZhLXZhci1jYy1hbWV4OiBcXGYxZjM7XG4kZmEtdmFyLWNjLWFwcGxlLXBheTogXFxmNDE2O1xuJGZhLXZhci1jYy1kaW5lcnMtY2x1YjogXFxmMjRjO1xuJGZhLXZhci1jYy1kaXNjb3ZlcjogXFxmMWYyO1xuJGZhLXZhci1jYy1qY2I6IFxcZjI0YjtcbiRmYS12YXItY2MtbWFzdGVyY2FyZDogXFxmMWYxO1xuJGZhLXZhci1jYy1wYXlwYWw6IFxcZjFmNDtcbiRmYS12YXItY2Mtc3RyaXBlOiBcXGYxZjU7XG4kZmEtdmFyLWNjLXZpc2E6IFxcZjFmMDtcbiRmYS12YXItY2VudGVyY29kZTogXFxmMzgwO1xuJGZhLXZhci1jZXJ0aWZpY2F0ZTogXFxmMGEzO1xuJGZhLXZhci1jaGFydC1hcmVhOiBcXGYxZmU7XG4kZmEtdmFyLWNoYXJ0LWJhcjogXFxmMDgwO1xuJGZhLXZhci1jaGFydC1saW5lOiBcXGYyMDE7XG4kZmEtdmFyLWNoYXJ0LXBpZTogXFxmMjAwO1xuJGZhLXZhci1jaGVjazogXFxmMDBjO1xuJGZhLXZhci1jaGVjay1jaXJjbGU6IFxcZjA1ODtcbiRmYS12YXItY2hlY2stc3F1YXJlOiBcXGYxNGE7XG4kZmEtdmFyLWNoZXNzOiBcXGY0Mzk7XG4kZmEtdmFyLWNoZXNzLWJpc2hvcDogXFxmNDNhO1xuJGZhLXZhci1jaGVzcy1iaXNob3AtYWx0OiBcXGY0M2I7XG4kZmEtdmFyLWNoZXNzLWJvYXJkOiBcXGY0M2M7XG4kZmEtdmFyLWNoZXNzLWNsb2NrOiBcXGY0M2Q7XG4kZmEtdmFyLWNoZXNzLWNsb2NrLWFsdDogXFxmNDNlO1xuJGZhLXZhci1jaGVzcy1raW5nOiBcXGY0M2Y7XG4kZmEtdmFyLWNoZXNzLWtpbmctYWx0OiBcXGY0NDA7XG4kZmEtdmFyLWNoZXNzLWtuaWdodDogXFxmNDQxO1xuJGZhLXZhci1jaGVzcy1rbmlnaHQtYWx0OiBcXGY0NDI7XG4kZmEtdmFyLWNoZXNzLXBhd246IFxcZjQ0MztcbiRmYS12YXItY2hlc3MtcGF3bi1hbHQ6IFxcZjQ0NDtcbiRmYS12YXItY2hlc3MtcXVlZW46IFxcZjQ0NTtcbiRmYS12YXItY2hlc3MtcXVlZW4tYWx0OiBcXGY0NDY7XG4kZmEtdmFyLWNoZXNzLXJvb2s6IFxcZjQ0NztcbiRmYS12YXItY2hlc3Mtcm9vay1hbHQ6IFxcZjQ0ODtcbiRmYS12YXItY2hldnJvbi1jaXJjbGUtZG93bjogXFxmMTNhO1xuJGZhLXZhci1jaGV2cm9uLWNpcmNsZS1sZWZ0OiBcXGYxMzc7XG4kZmEtdmFyLWNoZXZyb24tY2lyY2xlLXJpZ2h0OiBcXGYxMzg7XG4kZmEtdmFyLWNoZXZyb24tY2lyY2xlLXVwOiBcXGYxMzk7XG4kZmEtdmFyLWNoZXZyb24tZG91YmxlLWRvd246IFxcZjMyMjtcbiRmYS12YXItY2hldnJvbi1kb3VibGUtbGVmdDogXFxmMzIzO1xuJGZhLXZhci1jaGV2cm9uLWRvdWJsZS1yaWdodDogXFxmMzI0O1xuJGZhLXZhci1jaGV2cm9uLWRvdWJsZS11cDogXFxmMzI1O1xuJGZhLXZhci1jaGV2cm9uLWRvd246IFxcZjA3ODtcbiRmYS12YXItY2hldnJvbi1sZWZ0OiBcXGYwNTM7XG4kZmEtdmFyLWNoZXZyb24tcmlnaHQ6IFxcZjA1NDtcbiRmYS12YXItY2hldnJvbi1zcXVhcmUtZG93bjogXFxmMzI5O1xuJGZhLXZhci1jaGV2cm9uLXNxdWFyZS1sZWZ0OiBcXGYzMmE7XG4kZmEtdmFyLWNoZXZyb24tc3F1YXJlLXJpZ2h0OiBcXGYzMmI7XG4kZmEtdmFyLWNoZXZyb24tc3F1YXJlLXVwOiBcXGYzMmM7XG4kZmEtdmFyLWNoZXZyb24tdXA6IFxcZjA3NztcbiRmYS12YXItY2hpbGQ6IFxcZjFhZTtcbiRmYS12YXItY2hyb21lOiBcXGYyNjg7XG4kZmEtdmFyLWNpcmNsZTogXFxmMTExO1xuJGZhLXZhci1jaXJjbGUtbm90Y2g6IFxcZjFjZTtcbiRmYS12YXItY2xpcGJvYXJkOiBcXGYzMjg7XG4kZmEtdmFyLWNsaXBib2FyZC1jaGVjazogXFxmNDZjO1xuJGZhLXZhci1jbGlwYm9hcmQtbGlzdDogXFxmNDZkO1xuJGZhLXZhci1jbG9jazogXFxmMDE3O1xuJGZhLXZhci1jbG9uZTogXFxmMjRkO1xuJGZhLXZhci1jbG9zZWQtY2FwdGlvbmluZzogXFxmMjBhO1xuJGZhLXZhci1jbG91ZDogXFxmMGMyO1xuJGZhLXZhci1jbG91ZC1kb3dubG9hZDogXFxmMGVkO1xuJGZhLXZhci1jbG91ZC1kb3dubG9hZC1hbHQ6IFxcZjM4MTtcbiRmYS12YXItY2xvdWQtdXBsb2FkOiBcXGYwZWU7XG4kZmEtdmFyLWNsb3VkLXVwbG9hZC1hbHQ6IFxcZjM4MjtcbiRmYS12YXItY2xvdWRzY2FsZTogXFxmMzgzO1xuJGZhLXZhci1jbG91ZHNtaXRoOiBcXGYzODQ7XG4kZmEtdmFyLWNsb3VkdmVyc2lmeTogXFxmMzg1O1xuJGZhLXZhci1jbHViOiBcXGYzMjc7XG4kZmEtdmFyLWNvZGU6IFxcZjEyMTtcbiRmYS12YXItY29kZS1icmFuY2g6IFxcZjEyNjtcbiRmYS12YXItY29kZS1jb21taXQ6IFxcZjM4NjtcbiRmYS12YXItY29kZS1tZXJnZTogXFxmMzg3O1xuJGZhLXZhci1jb2RlcGVuOiBcXGYxY2I7XG4kZmEtdmFyLWNvZGllcGllOiBcXGYyODQ7XG4kZmEtdmFyLWNvZmZlZTogXFxmMGY0O1xuJGZhLXZhci1jb2c6IFxcZjAxMztcbiRmYS12YXItY29nczogXFxmMDg1O1xuJGZhLXZhci1jb2x1bW5zOiBcXGYwZGI7XG4kZmEtdmFyLWNvbW1lbnQ6IFxcZjA3NTtcbiRmYS12YXItY29tbWVudC1hbHQ6IFxcZjI3YTtcbiRmYS12YXItY29tbWVudHM6IFxcZjA4NjtcbiRmYS12YXItY29tcGFzczogXFxmMTRlO1xuJGZhLXZhci1jb21wcmVzczogXFxmMDY2O1xuJGZhLXZhci1jb21wcmVzcy1hbHQ6IFxcZjQyMjtcbiRmYS12YXItY29tcHJlc3Mtd2lkZTogXFxmMzI2O1xuJGZhLXZhci1jb25uZWN0ZGV2ZWxvcDogXFxmMjBlO1xuJGZhLXZhci1jb250YW86IFxcZjI2ZDtcbiRmYS12YXItY29udmV5b3ItYmVsdDogXFxmNDZlO1xuJGZhLXZhci1jb252ZXlvci1iZWx0LWFsdDogXFxmNDZmO1xuJGZhLXZhci1jb3B5OiBcXGYwYzU7XG4kZmEtdmFyLWNvcHlyaWdodDogXFxmMWY5O1xuJGZhLXZhci1jcGFuZWw6IFxcZjM4ODtcbiRmYS12YXItY3JlYXRpdmUtY29tbW9uczogXFxmMjVlO1xuJGZhLXZhci1jcmVkaXQtY2FyZDogXFxmMDlkO1xuJGZhLXZhci1jcmVkaXQtY2FyZC1ibGFuazogXFxmMzg5O1xuJGZhLXZhci1jcmVkaXQtY2FyZC1mcm9udDogXFxmMzhhO1xuJGZhLXZhci1jcmlja2V0OiBcXGY0NDk7XG4kZmEtdmFyLWNyb3A6IFxcZjEyNTtcbiRmYS12YXItY3Jvc3NoYWlyczogXFxmMDViO1xuJGZhLXZhci1jc3MzOiBcXGYxM2M7XG4kZmEtdmFyLWNzczMtYWx0OiBcXGYzOGI7XG4kZmEtdmFyLWN1YmU6IFxcZjFiMjtcbiRmYS12YXItY3ViZXM6IFxcZjFiMztcbiRmYS12YXItY3VybGluZzogXFxmNDRhO1xuJGZhLXZhci1jdXQ6IFxcZjBjNDtcbiRmYS12YXItY3V0dGxlZmlzaDogXFxmMzhjO1xuJGZhLXZhci1kLWFuZC1kOiBcXGYzOGQ7XG4kZmEtdmFyLWRhc2hjdWJlOiBcXGYyMTA7XG4kZmEtdmFyLWRhdGFiYXNlOiBcXGYxYzA7XG4kZmEtdmFyLWRlYWY6IFxcZjJhNDtcbiRmYS12YXItZGVsaWNpb3VzOiBcXGYxYTU7XG4kZmEtdmFyLWRlcGxveWRvZzogXFxmMzhlO1xuJGZhLXZhci1kZXNrcHJvOiBcXGYzOGY7XG4kZmEtdmFyLWRlc2t0b3A6IFxcZjEwODtcbiRmYS12YXItZGVza3RvcC1hbHQ6IFxcZjM5MDtcbiRmYS12YXItZGV2aWFudGFydDogXFxmMWJkO1xuJGZhLXZhci1kaWFnbm9zZXM6IFxcZjQ3MDtcbiRmYS12YXItZGlhbW9uZDogXFxmMjE5O1xuJGZhLXZhci1kaWdnOiBcXGYxYTY7XG4kZmEtdmFyLWRpZ2l0YWwtb2NlYW46IFxcZjM5MTtcbiRmYS12YXItZGlzY29yZDogXFxmMzkyO1xuJGZhLXZhci1kaXNjb3Vyc2U6IFxcZjM5MztcbiRmYS12YXItZG5hOiBcXGY0NzE7XG4kZmEtdmFyLWRvY2h1YjogXFxmMzk0O1xuJGZhLXZhci1kb2NrZXI6IFxcZjM5NTtcbiRmYS12YXItZG9sbGFyLXNpZ246IFxcZjE1NTtcbiRmYS12YXItZG9sbHk6IFxcZjQ3MjtcbiRmYS12YXItZG9sbHktZW1wdHk6IFxcZjQ3MztcbiRmYS12YXItZG9sbHktZmxhdGJlZDogXFxmNDc0O1xuJGZhLXZhci1kb2xseS1mbGF0YmVkLWFsdDogXFxmNDc1O1xuJGZhLXZhci1kb2xseS1mbGF0YmVkLWVtcHR5OiBcXGY0NzY7XG4kZmEtdmFyLWRvdC1jaXJjbGU6IFxcZjE5MjtcbiRmYS12YXItZG93bmxvYWQ6IFxcZjAxOTtcbiRmYS12YXItZHJhZnQyZGlnaXRhbDogXFxmMzk2O1xuJGZhLXZhci1kcmliYmJsZTogXFxmMTdkO1xuJGZhLXZhci1kcmliYmJsZS1zcXVhcmU6IFxcZjM5NztcbiRmYS12YXItZHJvcGJveDogXFxmMTZiO1xuJGZhLXZhci1kcnVwYWw6IFxcZjFhOTtcbiRmYS12YXItZHVtYmJlbGw6IFxcZjQ0YjtcbiRmYS12YXItZHlhbG9nOiBcXGYzOTk7XG4kZmEtdmFyLWVhcmx5YmlyZHM6IFxcZjM5YTtcbiRmYS12YXItZWRnZTogXFxmMjgyO1xuJGZhLXZhci1lZGl0OiBcXGYwNDQ7XG4kZmEtdmFyLWVqZWN0OiBcXGYwNTI7XG4kZmEtdmFyLWVsZW1lbnRvcjogXFxmNDMwO1xuJGZhLXZhci1lbGxpcHNpcy1oOiBcXGYxNDE7XG4kZmEtdmFyLWVsbGlwc2lzLWgtYWx0OiBcXGYzOWI7XG4kZmEtdmFyLWVsbGlwc2lzLXY6IFxcZjE0MjtcbiRmYS12YXItZWxsaXBzaXMtdi1hbHQ6IFxcZjM5YztcbiRmYS12YXItZW1iZXI6IFxcZjQyMztcbiRmYS12YXItZW1waXJlOiBcXGYxZDE7XG4kZmEtdmFyLWVudmVsb3BlOiBcXGYwZTA7XG4kZmEtdmFyLWVudmVsb3BlLW9wZW46IFxcZjJiNjtcbiRmYS12YXItZW52ZWxvcGUtc3F1YXJlOiBcXGYxOTk7XG4kZmEtdmFyLWVudmlyYTogXFxmMjk5O1xuJGZhLXZhci1lcmFzZXI6IFxcZjEyZDtcbiRmYS12YXItZXJsYW5nOiBcXGYzOWQ7XG4kZmEtdmFyLWV0aGVyZXVtOiBcXGY0MmU7XG4kZmEtdmFyLWV0c3k6IFxcZjJkNztcbiRmYS12YXItZXVyby1zaWduOiBcXGYxNTM7XG4kZmEtdmFyLWV4Y2hhbmdlOiBcXGYwZWM7XG4kZmEtdmFyLWV4Y2hhbmdlLWFsdDogXFxmMzYyO1xuJGZhLXZhci1leGNsYW1hdGlvbjogXFxmMTJhO1xuJGZhLXZhci1leGNsYW1hdGlvbi1jaXJjbGU6IFxcZjA2YTtcbiRmYS12YXItZXhjbGFtYXRpb24tc3F1YXJlOiBcXGYzMjE7XG4kZmEtdmFyLWV4Y2xhbWF0aW9uLXRyaWFuZ2xlOiBcXGYwNzE7XG4kZmEtdmFyLWV4cGFuZDogXFxmMDY1O1xuJGZhLXZhci1leHBhbmQtYWx0OiBcXGY0MjQ7XG4kZmEtdmFyLWV4cGFuZC1hcnJvd3M6IFxcZjMxZDtcbiRmYS12YXItZXhwYW5kLWFycm93cy1hbHQ6IFxcZjMxZTtcbiRmYS12YXItZXhwYW5kLXdpZGU6IFxcZjMyMDtcbiRmYS12YXItZXhwZWRpdGVkc3NsOiBcXGYyM2U7XG4kZmEtdmFyLWV4dGVybmFsLWxpbms6IFxcZjA4ZTtcbiRmYS12YXItZXh0ZXJuYWwtbGluay1hbHQ6IFxcZjM1ZDtcbiRmYS12YXItZXh0ZXJuYWwtbGluay1zcXVhcmU6IFxcZjE0YztcbiRmYS12YXItZXh0ZXJuYWwtbGluay1zcXVhcmUtYWx0OiBcXGYzNjA7XG4kZmEtdmFyLWV5ZTogXFxmMDZlO1xuJGZhLXZhci1leWUtZHJvcHBlcjogXFxmMWZiO1xuJGZhLXZhci1leWUtc2xhc2g6IFxcZjA3MDtcbiRmYS12YXItZmFjZWJvb2s6IFxcZjA5YTtcbiRmYS12YXItZmFjZWJvb2stZjogXFxmMzllO1xuJGZhLXZhci1mYWNlYm9vay1tZXNzZW5nZXI6IFxcZjM5ZjtcbiRmYS12YXItZmFjZWJvb2stc3F1YXJlOiBcXGYwODI7XG4kZmEtdmFyLWZhc3QtYmFja3dhcmQ6IFxcZjA0OTtcbiRmYS12YXItZmFzdC1mb3J3YXJkOiBcXGYwNTA7XG4kZmEtdmFyLWZheDogXFxmMWFjO1xuJGZhLXZhci1mZW1hbGU6IFxcZjE4MjtcbiRmYS12YXItZmllbGQtaG9ja2V5OiBcXGY0NGM7XG4kZmEtdmFyLWZpZ2h0ZXItamV0OiBcXGYwZmI7XG4kZmEtdmFyLWZpbGU6IFxcZjE1YjtcbiRmYS12YXItZmlsZS1hbHQ6IFxcZjE1YztcbiRmYS12YXItZmlsZS1hcmNoaXZlOiBcXGYxYzY7XG4kZmEtdmFyLWZpbGUtYXVkaW86IFxcZjFjNztcbiRmYS12YXItZmlsZS1jaGVjazogXFxmMzE2O1xuJGZhLXZhci1maWxlLWNvZGU6IFxcZjFjOTtcbiRmYS12YXItZmlsZS1lZGl0OiBcXGYzMWM7XG4kZmEtdmFyLWZpbGUtZXhjZWw6IFxcZjFjMztcbiRmYS12YXItZmlsZS1leGNsYW1hdGlvbjogXFxmMzFhO1xuJGZhLXZhci1maWxlLWltYWdlOiBcXGYxYzU7XG4kZmEtdmFyLWZpbGUtbWVkaWNhbDogXFxmNDc3O1xuJGZhLXZhci1maWxlLW1lZGljYWwtYWx0OiBcXGY0Nzg7XG4kZmEtdmFyLWZpbGUtbWludXM6IFxcZjMxODtcbiRmYS12YXItZmlsZS1wZGY6IFxcZjFjMTtcbiRmYS12YXItZmlsZS1wbHVzOiBcXGYzMTk7XG4kZmEtdmFyLWZpbGUtcG93ZXJwb2ludDogXFxmMWM0O1xuJGZhLXZhci1maWxlLXRpbWVzOiBcXGYzMTc7XG4kZmEtdmFyLWZpbGUtdmlkZW86IFxcZjFjODtcbiRmYS12YXItZmlsZS13b3JkOiBcXGYxYzI7XG4kZmEtdmFyLWZpbG06IFxcZjAwODtcbiRmYS12YXItZmlsbS1hbHQ6IFxcZjNhMDtcbiRmYS12YXItZmlsdGVyOiBcXGYwYjA7XG4kZmEtdmFyLWZpcmU6IFxcZjA2ZDtcbiRmYS12YXItZmlyZS1leHRpbmd1aXNoZXI6IFxcZjEzNDtcbiRmYS12YXItZmlyZWZveDogXFxmMjY5O1xuJGZhLXZhci1maXJzdC1haWQ6IFxcZjQ3OTtcbiRmYS12YXItZmlyc3Qtb3JkZXI6IFxcZjJiMDtcbiRmYS12YXItZmlyc3RkcmFmdDogXFxmM2ExO1xuJGZhLXZhci1mbGFnOiBcXGYwMjQ7XG4kZmEtdmFyLWZsYWctY2hlY2tlcmVkOiBcXGYxMWU7XG4kZmEtdmFyLWZsYXNrOiBcXGYwYzM7XG4kZmEtdmFyLWZsaWNrcjogXFxmMTZlO1xuJGZhLXZhci1mbGlwYm9hcmQ6IFxcZjQ0ZDtcbiRmYS12YXItZmx5OiBcXGY0MTc7XG4kZmEtdmFyLWZvbGRlcjogXFxmMDdiO1xuJGZhLXZhci1mb2xkZXItb3BlbjogXFxmMDdjO1xuJGZhLXZhci1mb250OiBcXGYwMzE7XG4kZmEtdmFyLWZvbnQtYXdlc29tZTogXFxmMmI0O1xuJGZhLXZhci1mb250LWF3ZXNvbWUtYWx0OiBcXGYzNWM7XG4kZmEtdmFyLWZvbnQtYXdlc29tZS1mbGFnOiBcXGY0MjU7XG4kZmEtdmFyLWZvbnRpY29uczogXFxmMjgwO1xuJGZhLXZhci1mb250aWNvbnMtZmk6IFxcZjNhMjtcbiRmYS12YXItZm9vdGJhbGwtYmFsbDogXFxmNDRlO1xuJGZhLXZhci1mb290YmFsbC1oZWxtZXQ6IFxcZjQ0ZjtcbiRmYS12YXItZm9ya2xpZnQ6IFxcZjQ3YTtcbiRmYS12YXItZm9ydC1hd2Vzb21lOiBcXGYyODY7XG4kZmEtdmFyLWZvcnQtYXdlc29tZS1hbHQ6IFxcZjNhMztcbiRmYS12YXItZm9ydW1iZWU6IFxcZjIxMTtcbiRmYS12YXItZm9yd2FyZDogXFxmMDRlO1xuJGZhLXZhci1mb3Vyc3F1YXJlOiBcXGYxODA7XG4kZmEtdmFyLWZyZWUtY29kZS1jYW1wOiBcXGYyYzU7XG4kZmEtdmFyLWZyZWVic2Q6IFxcZjNhNDtcbiRmYS12YXItZnJvd246IFxcZjExOTtcbiRmYS12YXItZnV0Ym9sOiBcXGYxZTM7XG4kZmEtdmFyLWdhbWVwYWQ6IFxcZjExYjtcbiRmYS12YXItZ2F2ZWw6IFxcZjBlMztcbiRmYS12YXItZ2VtOiBcXGYzYTU7XG4kZmEtdmFyLWdlbmRlcmxlc3M6IFxcZjIyZDtcbiRmYS12YXItZ2V0LXBvY2tldDogXFxmMjY1O1xuJGZhLXZhci1nZzogXFxmMjYwO1xuJGZhLXZhci1nZy1jaXJjbGU6IFxcZjI2MTtcbiRmYS12YXItZ2lmdDogXFxmMDZiO1xuJGZhLXZhci1naXQ6IFxcZjFkMztcbiRmYS12YXItZ2l0LXNxdWFyZTogXFxmMWQyO1xuJGZhLXZhci1naXRodWI6IFxcZjA5YjtcbiRmYS12YXItZ2l0aHViLWFsdDogXFxmMTEzO1xuJGZhLXZhci1naXRodWItc3F1YXJlOiBcXGYwOTI7XG4kZmEtdmFyLWdpdGtyYWtlbjogXFxmM2E2O1xuJGZhLXZhci1naXRsYWI6IFxcZjI5NjtcbiRmYS12YXItZ2l0dGVyOiBcXGY0MjY7XG4kZmEtdmFyLWdsYXNzLW1hcnRpbmk6IFxcZjAwMDtcbiRmYS12YXItZ2xpZGU6IFxcZjJhNTtcbiRmYS12YXItZ2xpZGUtZzogXFxmMmE2O1xuJGZhLXZhci1nbG9iZTogXFxmMGFjO1xuJGZhLXZhci1nb2ZvcmU6IFxcZjNhNztcbiRmYS12YXItZ29sZi1iYWxsOiBcXGY0NTA7XG4kZmEtdmFyLWdvbGYtY2x1YjogXFxmNDUxO1xuJGZhLXZhci1nb29kcmVhZHM6IFxcZjNhODtcbiRmYS12YXItZ29vZHJlYWRzLWc6IFxcZjNhOTtcbiRmYS12YXItZ29vZ2xlOiBcXGYxYTA7XG4kZmEtdmFyLWdvb2dsZS1kcml2ZTogXFxmM2FhO1xuJGZhLXZhci1nb29nbGUtcGxheTogXFxmM2FiO1xuJGZhLXZhci1nb29nbGUtcGx1czogXFxmMmIzO1xuJGZhLXZhci1nb29nbGUtcGx1cy1nOiBcXGYwZDU7XG4kZmEtdmFyLWdvb2dsZS1wbHVzLXNxdWFyZTogXFxmMGQ0O1xuJGZhLXZhci1nb29nbGUtd2FsbGV0OiBcXGYxZWU7XG4kZmEtdmFyLWdyYWR1YXRpb24tY2FwOiBcXGYxOWQ7XG4kZmEtdmFyLWdyYXRpcGF5OiBcXGYxODQ7XG4kZmEtdmFyLWdyYXY6IFxcZjJkNjtcbiRmYS12YXItZ3JpcGZpcmU6IFxcZjNhYztcbiRmYS12YXItZ3J1bnQ6IFxcZjNhZDtcbiRmYS12YXItZ3VscDogXFxmM2FlO1xuJGZhLXZhci1oLXNxdWFyZTogXFxmMGZkO1xuJGZhLXZhci1oMTogXFxmMzEzO1xuJGZhLXZhci1oMjogXFxmMzE0O1xuJGZhLXZhci1oMzogXFxmMzE1O1xuJGZhLXZhci1oYWNrZXItbmV3czogXFxmMWQ0O1xuJGZhLXZhci1oYWNrZXItbmV3cy1zcXVhcmU6IFxcZjNhZjtcbiRmYS12YXItaGFuZC1ob2xkaW5nLWJveDogXFxmNDdiO1xuJGZhLXZhci1oYW5kLWxpemFyZDogXFxmMjU4O1xuJGZhLXZhci1oYW5kLXBhcGVyOiBcXGYyNTY7XG4kZmEtdmFyLWhhbmQtcGVhY2U6IFxcZjI1YjtcbiRmYS12YXItaGFuZC1wb2ludC1kb3duOiBcXGYwYTc7XG4kZmEtdmFyLWhhbmQtcG9pbnQtbGVmdDogXFxmMGE1O1xuJGZhLXZhci1oYW5kLXBvaW50LXJpZ2h0OiBcXGYwYTQ7XG4kZmEtdmFyLWhhbmQtcG9pbnQtdXA6IFxcZjBhNjtcbiRmYS12YXItaGFuZC1wb2ludGVyOiBcXGYyNWE7XG4kZmEtdmFyLWhhbmQtcmVjZWl2aW5nOiBcXGY0N2M7XG4kZmEtdmFyLWhhbmQtcm9jazogXFxmMjU1O1xuJGZhLXZhci1oYW5kLXNjaXNzb3JzOiBcXGYyNTc7XG4kZmEtdmFyLWhhbmQtc3BvY2s6IFxcZjI1OTtcbiRmYS12YXItaGFuZHNoYWtlOiBcXGYyYjU7XG4kZmEtdmFyLWhhc2h0YWc6IFxcZjI5MjtcbiRmYS12YXItaGRkOiBcXGYwYTA7XG4kZmEtdmFyLWhlYWRpbmc6IFxcZjFkYztcbiRmYS12YXItaGVhZHBob25lczogXFxmMDI1O1xuJGZhLXZhci1oZWFydDogXFxmMDA0O1xuJGZhLXZhci1oZWFydGJlYXQ6IFxcZjIxZTtcbiRmYS12YXItaGV4YWdvbjogXFxmMzEyO1xuJGZhLXZhci1oaXBzOiBcXGY0NTI7XG4kZmEtdmFyLWhpcmUtYS1oZWxwZXI6IFxcZjNiMDtcbiRmYS12YXItaGlzdG9yeTogXFxmMWRhO1xuJGZhLXZhci1ob2NrZXktcHVjazogXFxmNDUzO1xuJGZhLXZhci1ob2NrZXktc3RpY2tzOiBcXGY0NTQ7XG4kZmEtdmFyLWhvbWU6IFxcZjAxNTtcbiRmYS12YXItaG9vbGk6IFxcZjQyNztcbiRmYS12YXItaG9zcGl0YWw6IFxcZjBmODtcbiRmYS12YXItaG9zcGl0YWwtYWx0OiBcXGY0N2Q7XG4kZmEtdmFyLWhvc3BpdGFsLXN5bWJvbDogXFxmNDdlO1xuJGZhLXZhci1ob3RqYXI6IFxcZjNiMTtcbiRmYS12YXItaG91cmdsYXNzOiBcXGYyNTQ7XG4kZmEtdmFyLWhvdXJnbGFzcy1lbmQ6IFxcZjI1MztcbiRmYS12YXItaG91cmdsYXNzLWhhbGY6IFxcZjI1MjtcbiRmYS12YXItaG91cmdsYXNzLXN0YXJ0OiBcXGYyNTE7XG4kZmEtdmFyLWhvdXp6OiBcXGYyN2M7XG4kZmEtdmFyLWh0bWw1OiBcXGYxM2I7XG4kZmEtdmFyLWh1YnNwb3Q6IFxcZjNiMjtcbiRmYS12YXItaS1jdXJzb3I6IFxcZjI0NjtcbiRmYS12YXItaWQtYmFkZ2U6IFxcZjJjMTtcbiRmYS12YXItaWQtY2FyZDogXFxmMmMyO1xuJGZhLXZhci1pZC1jYXJkLWFsdDogXFxmNDdmO1xuJGZhLXZhci1pbWFnZTogXFxmMDNlO1xuJGZhLXZhci1pbWFnZXM6IFxcZjMwMjtcbiRmYS12YXItaW1kYjogXFxmMmQ4O1xuJGZhLXZhci1pbmJveDogXFxmMDFjO1xuJGZhLXZhci1pbmJveC1pbjogXFxmMzEwO1xuJGZhLXZhci1pbmJveC1vdXQ6IFxcZjMxMTtcbiRmYS12YXItaW5kZW50OiBcXGYwM2M7XG4kZmEtdmFyLWluZHVzdHJ5OiBcXGYyNzU7XG4kZmEtdmFyLWluZHVzdHJ5LWFsdDogXFxmM2IzO1xuJGZhLXZhci1pbmZvOiBcXGYxMjk7XG4kZmEtdmFyLWluZm8tY2lyY2xlOiBcXGYwNWE7XG4kZmEtdmFyLWluZm8tc3F1YXJlOiBcXGYzMGY7XG4kZmEtdmFyLWluc3RhZ3JhbTogXFxmMTZkO1xuJGZhLXZhci1pbnRlcm5ldC1leHBsb3JlcjogXFxmMjZiO1xuJGZhLXZhci1pbnZlbnRvcnk6IFxcZjQ4MDtcbiRmYS12YXItaW94aG9zdDogXFxmMjA4O1xuJGZhLXZhci1pdGFsaWM6IFxcZjAzMztcbiRmYS12YXItaXR1bmVzOiBcXGYzYjQ7XG4kZmEtdmFyLWl0dW5lcy1ub3RlOiBcXGYzYjU7XG4kZmEtdmFyLWphY2stby1sYW50ZXJuOiBcXGYzMGU7XG4kZmEtdmFyLWplbmtpbnM6IFxcZjNiNjtcbiRmYS12YXItam9nZXQ6IFxcZjNiNztcbiRmYS12YXItam9vbWxhOiBcXGYxYWE7XG4kZmEtdmFyLWpzOiBcXGYzYjg7XG4kZmEtdmFyLWpzLXNxdWFyZTogXFxmM2I5O1xuJGZhLXZhci1qc2ZpZGRsZTogXFxmMWNjO1xuJGZhLXZhci1rZXk6IFxcZjA4NDtcbiRmYS12YXIta2V5Ym9hcmQ6IFxcZjExYztcbiRmYS12YXIta2V5Y2RuOiBcXGYzYmE7XG4kZmEtdmFyLWtpY2tzdGFydGVyOiBcXGYzYmI7XG4kZmEtdmFyLWtpY2tzdGFydGVyLWs6IFxcZjNiYztcbiRmYS12YXIta29ydnVlOiBcXGY0MmY7XG4kZmEtdmFyLWxhbmd1YWdlOiBcXGYxYWI7XG4kZmEtdmFyLWxhcHRvcDogXFxmMTA5O1xuJGZhLXZhci1sYXJhdmVsOiBcXGYzYmQ7XG4kZmEtdmFyLWxhc3RmbTogXFxmMjAyO1xuJGZhLXZhci1sYXN0Zm0tc3F1YXJlOiBcXGYyMDM7XG4kZmEtdmFyLWxlYWY6IFxcZjA2YztcbiRmYS12YXItbGVhbnB1YjogXFxmMjEyO1xuJGZhLXZhci1sZW1vbjogXFxmMDk0O1xuJGZhLXZhci1sZXNzOiBcXGY0MWQ7XG4kZmEtdmFyLWxldmVsLWRvd246IFxcZjE0OTtcbiRmYS12YXItbGV2ZWwtZG93bi1hbHQ6IFxcZjNiZTtcbiRmYS12YXItbGV2ZWwtdXA6IFxcZjE0ODtcbiRmYS12YXItbGV2ZWwtdXAtYWx0OiBcXGYzYmY7XG4kZmEtdmFyLWxpZmUtcmluZzogXFxmMWNkO1xuJGZhLXZhci1saWdodGJ1bGI6IFxcZjBlYjtcbiRmYS12YXItbGluZTogXFxmM2MwO1xuJGZhLXZhci1saW5rOiBcXGYwYzE7XG4kZmEtdmFyLWxpbmtlZGluOiBcXGYwOGM7XG4kZmEtdmFyLWxpbmtlZGluLWluOiBcXGYwZTE7XG4kZmEtdmFyLWxpbm9kZTogXFxmMmI4O1xuJGZhLXZhci1saW51eDogXFxmMTdjO1xuJGZhLXZhci1saXJhLXNpZ246IFxcZjE5NTtcbiRmYS12YXItbGlzdDogXFxmMDNhO1xuJGZhLXZhci1saXN0LWFsdDogXFxmMDIyO1xuJGZhLXZhci1saXN0LW9sOiBcXGYwY2I7XG4kZmEtdmFyLWxpc3QtdWw6IFxcZjBjYTtcbiRmYS12YXItbG9jYXRpb24tYXJyb3c6IFxcZjEyNDtcbiRmYS12YXItbG9jazogXFxmMDIzO1xuJGZhLXZhci1sb2NrLWFsdDogXFxmMzBkO1xuJGZhLXZhci1sb2NrLW9wZW46IFxcZjNjMTtcbiRmYS12YXItbG9jay1vcGVuLWFsdDogXFxmM2MyO1xuJGZhLXZhci1sb25nLWFycm93LWFsdC1kb3duOiBcXGYzMDk7XG4kZmEtdmFyLWxvbmctYXJyb3ctYWx0LWxlZnQ6IFxcZjMwYTtcbiRmYS12YXItbG9uZy1hcnJvdy1hbHQtcmlnaHQ6IFxcZjMwYjtcbiRmYS12YXItbG9uZy1hcnJvdy1hbHQtdXA6IFxcZjMwYztcbiRmYS12YXItbG9uZy1hcnJvdy1kb3duOiBcXGYxNzU7XG4kZmEtdmFyLWxvbmctYXJyb3ctbGVmdDogXFxmMTc3O1xuJGZhLXZhci1sb25nLWFycm93LXJpZ2h0OiBcXGYxNzg7XG4kZmEtdmFyLWxvbmctYXJyb3ctdXA6IFxcZjE3NjtcbiRmYS12YXItbG93LXZpc2lvbjogXFxmMmE4O1xuJGZhLXZhci1sdWNoYWRvcjogXFxmNDU1O1xuJGZhLXZhci1seWZ0OiBcXGYzYzM7XG4kZmEtdmFyLW1hZ2VudG86IFxcZjNjNDtcbiRmYS12YXItbWFnaWM6IFxcZjBkMDtcbiRmYS12YXItbWFnbmV0OiBcXGYwNzY7XG4kZmEtdmFyLW1hbGU6IFxcZjE4MztcbiRmYS12YXItbWFwOiBcXGYyNzk7XG4kZmEtdmFyLW1hcC1tYXJrZXI6IFxcZjA0MTtcbiRmYS12YXItbWFwLW1hcmtlci1hbHQ6IFxcZjNjNTtcbiRmYS12YXItbWFwLXBpbjogXFxmMjc2O1xuJGZhLXZhci1tYXAtc2lnbnM6IFxcZjI3NztcbiRmYS12YXItbWFyczogXFxmMjIyO1xuJGZhLXZhci1tYXJzLWRvdWJsZTogXFxmMjI3O1xuJGZhLXZhci1tYXJzLXN0cm9rZTogXFxmMjI5O1xuJGZhLXZhci1tYXJzLXN0cm9rZS1oOiBcXGYyMmI7XG4kZmEtdmFyLW1hcnMtc3Ryb2tlLXY6IFxcZjIyYTtcbiRmYS12YXItbWF4Y2RuOiBcXGYxMzY7XG4kZmEtdmFyLW1lZGFwcHM6IFxcZjNjNjtcbiRmYS12YXItbWVkaXVtOiBcXGYyM2E7XG4kZmEtdmFyLW1lZGl1bS1tOiBcXGYzYzc7XG4kZmEtdmFyLW1lZGtpdDogXFxmMGZhO1xuJGZhLXZhci1tZWRydDogXFxmM2M4O1xuJGZhLXZhci1tZWV0dXA6IFxcZjJlMDtcbiRmYS12YXItbWVoOiBcXGYxMWE7XG4kZmEtdmFyLW1lcmN1cnk6IFxcZjIyMztcbiRmYS12YXItbWljcm9jaGlwOiBcXGYyZGI7XG4kZmEtdmFyLW1pY3JvcGhvbmU6IFxcZjEzMDtcbiRmYS12YXItbWljcm9waG9uZS1hbHQ6IFxcZjNjOTtcbiRmYS12YXItbWljcm9waG9uZS1zbGFzaDogXFxmMTMxO1xuJGZhLXZhci1taWNyb3NvZnQ6IFxcZjNjYTtcbiRmYS12YXItbWludXM6IFxcZjA2ODtcbiRmYS12YXItbWludXMtY2lyY2xlOiBcXGYwNTY7XG4kZmEtdmFyLW1pbnVzLWhleGFnb246IFxcZjMwNztcbiRmYS12YXItbWludXMtb2N0YWdvbjogXFxmMzA4O1xuJGZhLXZhci1taW51cy1zcXVhcmU6IFxcZjE0NjtcbiRmYS12YXItbWl4OiBcXGYzY2I7XG4kZmEtdmFyLW1peGNsb3VkOiBcXGYyODk7XG4kZmEtdmFyLW1penVuaTogXFxmM2NjO1xuJGZhLXZhci1tb2JpbGU6IFxcZjEwYjtcbiRmYS12YXItbW9iaWxlLWFsdDogXFxmM2NkO1xuJGZhLXZhci1tb2JpbGUtYW5kcm9pZDogXFxmM2NlO1xuJGZhLXZhci1tb2JpbGUtYW5kcm9pZC1hbHQ6IFxcZjNjZjtcbiRmYS12YXItbW9keDogXFxmMjg1O1xuJGZhLXZhci1tb25lcm86IFxcZjNkMDtcbiRmYS12YXItbW9uZXktYmlsbDogXFxmMGQ2O1xuJGZhLXZhci1tb25leS1iaWxsLWFsdDogXFxmM2QxO1xuJGZhLXZhci1tb29uOiBcXGYxODY7XG4kZmEtdmFyLW1vdG9yY3ljbGU6IFxcZjIxYztcbiRmYS12YXItbW91c2UtcG9pbnRlcjogXFxmMjQ1O1xuJGZhLXZhci1tdXNpYzogXFxmMDAxO1xuJGZhLXZhci1uYXBzdGVyOiBcXGYzZDI7XG4kZmEtdmFyLW5ldXRlcjogXFxmMjJjO1xuJGZhLXZhci1uZXdzcGFwZXI6IFxcZjFlYTtcbiRmYS12YXItbmludGVuZG8tc3dpdGNoOiBcXGY0MTg7XG4kZmEtdmFyLW5vZGU6IFxcZjQxOTtcbiRmYS12YXItbm9kZS1qczogXFxmM2QzO1xuJGZhLXZhci1ub3Rlcy1tZWRpY2FsOiBcXGY0ODE7XG4kZmEtdmFyLW5wbTogXFxmM2Q0O1xuJGZhLXZhci1uczg6IFxcZjNkNTtcbiRmYS12YXItbnV0cml0aW9uaXg6IFxcZjNkNjtcbiRmYS12YXItb2JqZWN0LWdyb3VwOiBcXGYyNDc7XG4kZmEtdmFyLW9iamVjdC11bmdyb3VwOiBcXGYyNDg7XG4kZmEtdmFyLW9jdGFnb246IFxcZjMwNjtcbiRmYS12YXItb2Rub2tsYXNzbmlraTogXFxmMjYzO1xuJGZhLXZhci1vZG5va2xhc3NuaWtpLXNxdWFyZTogXFxmMjY0O1xuJGZhLXZhci1vcGVuY2FydDogXFxmMjNkO1xuJGZhLXZhci1vcGVuaWQ6IFxcZjE5YjtcbiRmYS12YXItb3BlcmE6IFxcZjI2YTtcbiRmYS12YXItb3B0aW4tbW9uc3RlcjogXFxmMjNjO1xuJGZhLXZhci1vc2k6IFxcZjQxYTtcbiRmYS12YXItb3V0ZGVudDogXFxmMDNiO1xuJGZhLXZhci1wYWdlNDogXFxmM2Q3O1xuJGZhLXZhci1wYWdlbGluZXM6IFxcZjE4YztcbiRmYS12YXItcGFpbnQtYnJ1c2g6IFxcZjFmYztcbiRmYS12YXItcGFsZmVkOiBcXGYzZDg7XG4kZmEtdmFyLXBhbGxldDogXFxmNDgyO1xuJGZhLXZhci1wYWxsZXQtYWx0OiBcXGY0ODM7XG4kZmEtdmFyLXBhcGVyLXBsYW5lOiBcXGYxZDg7XG4kZmEtdmFyLXBhcGVyY2xpcDogXFxmMGM2O1xuJGZhLXZhci1wYXJhZ3JhcGg6IFxcZjFkZDtcbiRmYS12YXItcGFzdGU6IFxcZjBlYTtcbiRmYS12YXItcGF0cmVvbjogXFxmM2Q5O1xuJGZhLXZhci1wYXVzZTogXFxmMDRjO1xuJGZhLXZhci1wYXVzZS1jaXJjbGU6IFxcZjI4YjtcbiRmYS12YXItcGF3OiBcXGYxYjA7XG4kZmEtdmFyLXBheXBhbDogXFxmMWVkO1xuJGZhLXZhci1wZW46IFxcZjMwNDtcbiRmYS12YXItcGVuLWFsdDogXFxmMzA1O1xuJGZhLXZhci1wZW4tc3F1YXJlOiBcXGYxNGI7XG4kZmEtdmFyLXBlbmNpbDogXFxmMDQwO1xuJGZhLXZhci1wZW5jaWwtYWx0OiBcXGYzMDM7XG4kZmEtdmFyLXBlbm5hbnQ6IFxcZjQ1NjtcbiRmYS12YXItcGVyY2VudDogXFxmMjk1O1xuJGZhLXZhci1wZXJpc2NvcGU6IFxcZjNkYTtcbiRmYS12YXItcGhhYnJpY2F0b3I6IFxcZjNkYjtcbiRmYS12YXItcGhvZW5peC1mcmFtZXdvcms6IFxcZjNkYztcbiRmYS12YXItcGhvbmU6IFxcZjA5NTtcbiRmYS12YXItcGhvbmUtc2xhc2g6IFxcZjNkZDtcbiRmYS12YXItcGhvbmUtc3F1YXJlOiBcXGYwOTg7XG4kZmEtdmFyLXBob25lLXZvbHVtZTogXFxmMmEwO1xuJGZhLXZhci1waHA6IFxcZjQ1NztcbiRmYS12YXItcGllZC1waXBlcjogXFxmMmFlO1xuJGZhLXZhci1waWVkLXBpcGVyLWFsdDogXFxmMWE4O1xuJGZhLXZhci1waWVkLXBpcGVyLXBwOiBcXGYxYTc7XG4kZmEtdmFyLXBpbGxzOiBcXGY0ODQ7XG4kZmEtdmFyLXBpbnRlcmVzdDogXFxmMGQyO1xuJGZhLXZhci1waW50ZXJlc3QtcDogXFxmMjMxO1xuJGZhLXZhci1waW50ZXJlc3Qtc3F1YXJlOiBcXGYwZDM7XG4kZmEtdmFyLXBsYW5lOiBcXGYwNzI7XG4kZmEtdmFyLXBsYW5lLWFsdDogXFxmM2RlO1xuJGZhLXZhci1wbGF5OiBcXGYwNGI7XG4kZmEtdmFyLXBsYXktY2lyY2xlOiBcXGYxNDQ7XG4kZmEtdmFyLXBsYXlzdGF0aW9uOiBcXGYzZGY7XG4kZmEtdmFyLXBsdWc6IFxcZjFlNjtcbiRmYS12YXItcGx1czogXFxmMDY3O1xuJGZhLXZhci1wbHVzLWNpcmNsZTogXFxmMDU1O1xuJGZhLXZhci1wbHVzLWhleGFnb246IFxcZjMwMDtcbiRmYS12YXItcGx1cy1vY3RhZ29uOiBcXGYzMDE7XG4kZmEtdmFyLXBsdXMtc3F1YXJlOiBcXGYwZmU7XG4kZmEtdmFyLXBvZGNhc3Q6IFxcZjJjZTtcbiRmYS12YXItcG9vOiBcXGYyZmU7XG4kZmEtdmFyLXBvcnRyYWl0OiBcXGYzZTA7XG4kZmEtdmFyLXBvdW5kLXNpZ246IFxcZjE1NDtcbiRmYS12YXItcG93ZXItb2ZmOiBcXGYwMTE7XG4kZmEtdmFyLXByZXNjcmlwdGlvbi1ib3R0bGU6IFxcZjQ4NTtcbiRmYS12YXItcHJlc2NyaXB0aW9uLWJvdHRsZS1hbHQ6IFxcZjQ4NjtcbiRmYS12YXItcHJpbnQ6IFxcZjAyZjtcbiRmYS12YXItcHJvY2VkdXJlczogXFxmNDg3O1xuJGZhLXZhci1wcm9kdWN0LWh1bnQ6IFxcZjI4ODtcbiRmYS12YXItcHVzaGVkOiBcXGYzZTE7XG4kZmEtdmFyLXB1enpsZS1waWVjZTogXFxmMTJlO1xuJGZhLXZhci1weXRob246IFxcZjNlMjtcbiRmYS12YXItcXE6IFxcZjFkNjtcbiRmYS12YXItcXJjb2RlOiBcXGYwMjk7XG4kZmEtdmFyLXF1ZXN0aW9uOiBcXGYxMjg7XG4kZmEtdmFyLXF1ZXN0aW9uLWNpcmNsZTogXFxmMDU5O1xuJGZhLXZhci1xdWVzdGlvbi1zcXVhcmU6IFxcZjJmZDtcbiRmYS12YXItcXVpZGRpdGNoOiBcXGY0NTg7XG4kZmEtdmFyLXF1aW5zY2FwZTogXFxmNDU5O1xuJGZhLXZhci1xdW9yYTogXFxmMmM0O1xuJGZhLXZhci1xdW90ZS1sZWZ0OiBcXGYxMGQ7XG4kZmEtdmFyLXF1b3RlLXJpZ2h0OiBcXGYxMGU7XG4kZmEtdmFyLXJhY3F1ZXQ6IFxcZjQ1YTtcbiRmYS12YXItcmFuZG9tOiBcXGYwNzQ7XG4kZmEtdmFyLXJhdmVscnk6IFxcZjJkOTtcbiRmYS12YXItcmVhY3Q6IFxcZjQxYjtcbiRmYS12YXItcmViZWw6IFxcZjFkMDtcbiRmYS12YXItcmVjdGFuZ2xlLWxhbmRzY2FwZTogXFxmMmZhO1xuJGZhLXZhci1yZWN0YW5nbGUtcG9ydHJhaXQ6IFxcZjJmYjtcbiRmYS12YXItcmVjdGFuZ2xlLXdpZGU6IFxcZjJmYztcbiRmYS12YXItcmVjeWNsZTogXFxmMWI4O1xuJGZhLXZhci1yZWQtcml2ZXI6IFxcZjNlMztcbiRmYS12YXItcmVkZGl0OiBcXGYxYTE7XG4kZmEtdmFyLXJlZGRpdC1hbGllbjogXFxmMjgxO1xuJGZhLXZhci1yZWRkaXQtc3F1YXJlOiBcXGYxYTI7XG4kZmEtdmFyLXJlZG86IFxcZjAxZTtcbiRmYS12YXItcmVkby1hbHQ6IFxcZjJmOTtcbiRmYS12YXItcmVnaXN0ZXJlZDogXFxmMjVkO1xuJGZhLXZhci1yZW5kYWN0OiBcXGYzZTQ7XG4kZmEtdmFyLXJlbnJlbjogXFxmMThiO1xuJGZhLXZhci1yZXBlYXQ6IFxcZjM2MztcbiRmYS12YXItcmVwZWF0LTE6IFxcZjM2NTtcbiRmYS12YXItcmVwZWF0LTEtYWx0OiBcXGYzNjY7XG4kZmEtdmFyLXJlcGVhdC1hbHQ6IFxcZjM2NDtcbiRmYS12YXItcmVwbHk6IFxcZjNlNTtcbiRmYS12YXItcmVwbHktYWxsOiBcXGYxMjI7XG4kZmEtdmFyLXJlcGx5ZDogXFxmM2U2O1xuJGZhLXZhci1yZXNvbHZpbmc6IFxcZjNlNztcbiRmYS12YXItcmV0d2VldDogXFxmMDc5O1xuJGZhLXZhci1yZXR3ZWV0LWFsdDogXFxmMzYxO1xuJGZhLXZhci1yb2FkOiBcXGYwMTg7XG4kZmEtdmFyLXJvY2tldDogXFxmMTM1O1xuJGZhLXZhci1yb2NrZXRjaGF0OiBcXGYzZTg7XG4kZmEtdmFyLXJvY2tybXM6IFxcZjNlOTtcbiRmYS12YXItcnNzOiBcXGYwOWU7XG4kZmEtdmFyLXJzcy1zcXVhcmU6IFxcZjE0MztcbiRmYS12YXItcnVibGUtc2lnbjogXFxmMTU4O1xuJGZhLXZhci1ydXBlZS1zaWduOiBcXGYxNTY7XG4kZmEtdmFyLXNhZmFyaTogXFxmMjY3O1xuJGZhLXZhci1zYXNzOiBcXGY0MWU7XG4kZmEtdmFyLXNhdmU6IFxcZjBjNztcbiRmYS12YXItc2Nhbm5lcjogXFxmNDg4O1xuJGZhLXZhci1zY2FubmVyLWtleWJvYXJkOiBcXGY0ODk7XG4kZmEtdmFyLXNjYW5uZXItdG91Y2hzY3JlZW46IFxcZjQ4YTtcbiRmYS12YXItc2NobGl4OiBcXGYzZWE7XG4kZmEtdmFyLXNjcmliZDogXFxmMjhhO1xuJGZhLXZhci1zY3J1YmJlcjogXFxmMmY4O1xuJGZhLXZhci1zZWFyY2g6IFxcZjAwMjtcbiRmYS12YXItc2VhcmNoLW1pbnVzOiBcXGYwMTA7XG4kZmEtdmFyLXNlYXJjaC1wbHVzOiBcXGYwMGU7XG4kZmEtdmFyLXNlYXJjaGVuZ2luOiBcXGYzZWI7XG4kZmEtdmFyLXNlbGxjYXN0OiBcXGYyZGE7XG4kZmEtdmFyLXNlbGxzeTogXFxmMjEzO1xuJGZhLXZhci1zZXJ2ZXI6IFxcZjIzMztcbiRmYS12YXItc2VydmljZXN0YWNrOiBcXGYzZWM7XG4kZmEtdmFyLXNoYXJlOiBcXGYwNjQ7XG4kZmEtdmFyLXNoYXJlLWFsbDogXFxmMzY3O1xuJGZhLXZhci1zaGFyZS1hbHQ6IFxcZjFlMDtcbiRmYS12YXItc2hhcmUtYWx0LXNxdWFyZTogXFxmMWUxO1xuJGZhLXZhci1zaGFyZS1zcXVhcmU6IFxcZjE0ZDtcbiRmYS12YXItc2hla2VsLXNpZ246IFxcZjIwYjtcbiRmYS12YXItc2hpZWxkOiBcXGYxMzI7XG4kZmEtdmFyLXNoaWVsZC1hbHQ6IFxcZjNlZDtcbiRmYS12YXItc2hpZWxkLWNoZWNrOiBcXGYyZjc7XG4kZmEtdmFyLXNoaXA6IFxcZjIxYTtcbiRmYS12YXItc2hpcHBpbmctZmFzdDogXFxmNDhiO1xuJGZhLXZhci1zaGlwcGluZy10aW1lZDogXFxmNDhjO1xuJGZhLXZhci1zaGlydHNpbmJ1bGs6IFxcZjIxNDtcbiRmYS12YXItc2hvcHBpbmctYmFnOiBcXGYyOTA7XG4kZmEtdmFyLXNob3BwaW5nLWJhc2tldDogXFxmMjkxO1xuJGZhLXZhci1zaG9wcGluZy1jYXJ0OiBcXGYwN2E7XG4kZmEtdmFyLXNob3dlcjogXFxmMmNjO1xuJGZhLXZhci1zaHV0dGxlY29jazogXFxmNDViO1xuJGZhLXZhci1zaWduLWluOiBcXGYwOTA7XG4kZmEtdmFyLXNpZ24taW4tYWx0OiBcXGYyZjY7XG4kZmEtdmFyLXNpZ24tbGFuZ3VhZ2U6IFxcZjJhNztcbiRmYS12YXItc2lnbi1vdXQ6IFxcZjA4YjtcbiRmYS12YXItc2lnbi1vdXQtYWx0OiBcXGYyZjU7XG4kZmEtdmFyLXNpZ25hbDogXFxmMDEyO1xuJGZhLXZhci1zaW1wbHlidWlsdDogXFxmMjE1O1xuJGZhLXZhci1zaXN0cml4OiBcXGYzZWU7XG4kZmEtdmFyLXNpdGVtYXA6IFxcZjBlODtcbiRmYS12YXItc2t5YXRsYXM6IFxcZjIxNjtcbiRmYS12YXItc2t5cGU6IFxcZjE3ZTtcbiRmYS12YXItc2xhY2s6IFxcZjE5ODtcbiRmYS12YXItc2xhY2staGFzaDogXFxmM2VmO1xuJGZhLXZhci1zbGlkZXJzLWg6IFxcZjFkZTtcbiRmYS12YXItc2xpZGVycy1oLXNxdWFyZTogXFxmM2YwO1xuJGZhLXZhci1zbGlkZXJzLXY6IFxcZjNmMTtcbiRmYS12YXItc2xpZGVycy12LXNxdWFyZTogXFxmM2YyO1xuJGZhLXZhci1zbGlkZXNoYXJlOiBcXGYxZTc7XG4kZmEtdmFyLXNtaWxlOiBcXGYxMTg7XG4kZmEtdmFyLXNtb2tpbmc6IFxcZjQ4ZDtcbiRmYS12YXItc25hcGNoYXQ6IFxcZjJhYjtcbiRmYS12YXItc25hcGNoYXQtZ2hvc3Q6IFxcZjJhYztcbiRmYS12YXItc25hcGNoYXQtc3F1YXJlOiBcXGYyYWQ7XG4kZmEtdmFyLXNub3dmbGFrZTogXFxmMmRjO1xuJGZhLXZhci1zb3J0OiBcXGYwZGM7XG4kZmEtdmFyLXNvcnQtYWxwaGEtZG93bjogXFxmMTVkO1xuJGZhLXZhci1zb3J0LWFscGhhLXVwOiBcXGYxNWU7XG4kZmEtdmFyLXNvcnQtYW1vdW50LWRvd246IFxcZjE2MDtcbiRmYS12YXItc29ydC1hbW91bnQtdXA6IFxcZjE2MTtcbiRmYS12YXItc29ydC1kb3duOiBcXGYwZGQ7XG4kZmEtdmFyLXNvcnQtbnVtZXJpYy1kb3duOiBcXGYxNjI7XG4kZmEtdmFyLXNvcnQtbnVtZXJpYy11cDogXFxmMTYzO1xuJGZhLXZhci1zb3J0LXVwOiBcXGYwZGU7XG4kZmEtdmFyLXNvdW5kY2xvdWQ6IFxcZjFiZTtcbiRmYS12YXItc3BhY2Utc2h1dHRsZTogXFxmMTk3O1xuJGZhLXZhci1zcGFkZTogXFxmMmY0O1xuJGZhLXZhci1zcGVha2FwOiBcXGYzZjM7XG4kZmEtdmFyLXNwaW5uZXI6IFxcZjExMDtcbiRmYS12YXItc3Bpbm5lci10aGlyZDogXFxmM2Y0O1xuJGZhLXZhci1zcG90aWZ5OiBcXGYxYmM7XG4kZmEtdmFyLXNxdWFyZTogXFxmMGM4O1xuJGZhLXZhci1zcXVhcmUtZnVsbDogXFxmNDVjO1xuJGZhLXZhci1zdGFjay1leGNoYW5nZTogXFxmMThkO1xuJGZhLXZhci1zdGFjay1vdmVyZmxvdzogXFxmMTZjO1xuJGZhLXZhci1zdGFyOiBcXGYwMDU7XG4kZmEtdmFyLXN0YXItZXhjbGFtYXRpb246IFxcZjJmMztcbiRmYS12YXItc3Rhci1oYWxmOiBcXGYwODk7XG4kZmEtdmFyLXN0YXlsaW5rZWQ6IFxcZjNmNTtcbiRmYS12YXItc3RlYW06IFxcZjFiNjtcbiRmYS12YXItc3RlYW0tc3F1YXJlOiBcXGYxYjc7XG4kZmEtdmFyLXN0ZWFtLXN5bWJvbDogXFxmM2Y2O1xuJGZhLXZhci1zdGVwLWJhY2t3YXJkOiBcXGYwNDg7XG4kZmEtdmFyLXN0ZXAtZm9yd2FyZDogXFxmMDUxO1xuJGZhLXZhci1zdGV0aG9zY29wZTogXFxmMGYxO1xuJGZhLXZhci1zdGlja2VyLW11bGU6IFxcZjNmNztcbiRmYS12YXItc3RpY2t5LW5vdGU6IFxcZjI0OTtcbiRmYS12YXItc3RvcDogXFxmMDRkO1xuJGZhLXZhci1zdG9wLWNpcmNsZTogXFxmMjhkO1xuJGZhLXZhci1zdG9wd2F0Y2g6IFxcZjJmMjtcbiRmYS12YXItc3RyYXZhOiBcXGY0Mjg7XG4kZmEtdmFyLXN0cmVldC12aWV3OiBcXGYyMWQ7XG4kZmEtdmFyLXN0cmlrZXRocm91Z2g6IFxcZjBjYztcbiRmYS12YXItc3RyaXBlOiBcXGY0Mjk7XG4kZmEtdmFyLXN0cmlwZS1zOiBcXGY0MmE7XG4kZmEtdmFyLXN0dWRpb3ZpbmFyaTogXFxmM2Y4O1xuJGZhLXZhci1zdHVtYmxldXBvbjogXFxmMWE0O1xuJGZhLXZhci1zdHVtYmxldXBvbi1jaXJjbGU6IFxcZjFhMztcbiRmYS12YXItc3Vic2NyaXB0OiBcXGYxMmM7XG4kZmEtdmFyLXN1YndheTogXFxmMjM5O1xuJGZhLXZhci1zdWl0Y2FzZTogXFxmMGYyO1xuJGZhLXZhci1zdW46IFxcZjE4NTtcbiRmYS12YXItc3VwZXJwb3dlcnM6IFxcZjJkZDtcbiRmYS12YXItc3VwZXJzY3JpcHQ6IFxcZjEyYjtcbiRmYS12YXItc3VwcGxlOiBcXGYzZjk7XG4kZmEtdmFyLXN5bmM6IFxcZjAyMTtcbiRmYS12YXItc3luYy1hbHQ6IFxcZjJmMTtcbiRmYS12YXItc3lyaW5nZTogXFxmNDhlO1xuJGZhLXZhci10YWJsZTogXFxmMGNlO1xuJGZhLXZhci10YWJsZS10ZW5uaXM6IFxcZjQ1ZDtcbiRmYS12YXItdGFibGV0OiBcXGYxMGE7XG4kZmEtdmFyLXRhYmxldC1hbHQ6IFxcZjNmYTtcbiRmYS12YXItdGFibGV0LWFuZHJvaWQ6IFxcZjNmYjtcbiRmYS12YXItdGFibGV0LWFuZHJvaWQtYWx0OiBcXGYzZmM7XG4kZmEtdmFyLXRhYmxldC1ydWdnZWQ6IFxcZjQ4ZjtcbiRmYS12YXItdGFibGV0czogXFxmNDkwO1xuJGZhLXZhci10YWNob21ldGVyOiBcXGYwZTQ7XG4kZmEtdmFyLXRhY2hvbWV0ZXItYWx0OiBcXGYzZmQ7XG4kZmEtdmFyLXRhZzogXFxmMDJiO1xuJGZhLXZhci10YWdzOiBcXGYwMmM7XG4kZmEtdmFyLXRhc2tzOiBcXGYwYWU7XG4kZmEtdmFyLXRheGk6IFxcZjFiYTtcbiRmYS12YXItdGVsZWdyYW06IFxcZjJjNjtcbiRmYS12YXItdGVsZWdyYW0tcGxhbmU6IFxcZjNmZTtcbiRmYS12YXItdGVuY2VudC13ZWlibzogXFxmMWQ1O1xuJGZhLXZhci10ZW5uaXMtYmFsbDogXFxmNDVlO1xuJGZhLXZhci10ZXJtaW5hbDogXFxmMTIwO1xuJGZhLXZhci10ZXh0LWhlaWdodDogXFxmMDM0O1xuJGZhLXZhci10ZXh0LXdpZHRoOiBcXGYwMzU7XG4kZmEtdmFyLXRoOiBcXGYwMGE7XG4kZmEtdmFyLXRoLWxhcmdlOiBcXGYwMDk7XG4kZmEtdmFyLXRoLWxpc3Q6IFxcZjAwYjtcbiRmYS12YXItdGhlbWVpc2xlOiBcXGYyYjI7XG4kZmEtdmFyLXRoZXJtb21ldGVyOiBcXGY0OTE7XG4kZmEtdmFyLXRoZXJtb21ldGVyLWVtcHR5OiBcXGYyY2I7XG4kZmEtdmFyLXRoZXJtb21ldGVyLWZ1bGw6IFxcZjJjNztcbiRmYS12YXItdGhlcm1vbWV0ZXItaGFsZjogXFxmMmM5O1xuJGZhLXZhci10aGVybW9tZXRlci1xdWFydGVyOiBcXGYyY2E7XG4kZmEtdmFyLXRoZXJtb21ldGVyLXRocmVlLXF1YXJ0ZXJzOiBcXGYyYzg7XG4kZmEtdmFyLXRodW1icy1kb3duOiBcXGYxNjU7XG4kZmEtdmFyLXRodW1icy11cDogXFxmMTY0O1xuJGZhLXZhci10aHVtYnRhY2s6IFxcZjA4ZDtcbiRmYS12YXItdGlja2V0OiBcXGYxNDU7XG4kZmEtdmFyLXRpY2tldC1hbHQ6IFxcZjNmZjtcbiRmYS12YXItdGltZXM6IFxcZjAwZDtcbiRmYS12YXItdGltZXMtY2lyY2xlOiBcXGYwNTc7XG4kZmEtdmFyLXRpbWVzLWhleGFnb246IFxcZjJlZTtcbiRmYS12YXItdGltZXMtb2N0YWdvbjogXFxmMmYwO1xuJGZhLXZhci10aW1lcy1zcXVhcmU6IFxcZjJkMztcbiRmYS12YXItdGludDogXFxmMDQzO1xuJGZhLXZhci10b2dnbGUtb2ZmOiBcXGYyMDQ7XG4kZmEtdmFyLXRvZ2dsZS1vbjogXFxmMjA1O1xuJGZhLXZhci10cmFkZW1hcms6IFxcZjI1YztcbiRmYS12YXItdHJhaW46IFxcZjIzODtcbiRmYS12YXItdHJhbnNnZW5kZXI6IFxcZjIyNDtcbiRmYS12YXItdHJhbnNnZW5kZXItYWx0OiBcXGYyMjU7XG4kZmEtdmFyLXRyYXNoOiBcXGYxZjg7XG4kZmEtdmFyLXRyYXNoLWFsdDogXFxmMmVkO1xuJGZhLXZhci10cmVlOiBcXGYxYmI7XG4kZmEtdmFyLXRyZWUtYWx0OiBcXGY0MDA7XG4kZmEtdmFyLXRyZWxsbzogXFxmMTgxO1xuJGZhLXZhci10cmlhbmdsZTogXFxmMmVjO1xuJGZhLXZhci10cmlwYWR2aXNvcjogXFxmMjYyO1xuJGZhLXZhci10cm9waHk6IFxcZjA5MTtcbiRmYS12YXItdHJvcGh5LWFsdDogXFxmMmViO1xuJGZhLXZhci10cnVjazogXFxmMGQxO1xuJGZhLXZhci10dHk6IFxcZjFlNDtcbiRmYS12YXItdHVtYmxyOiBcXGYxNzM7XG4kZmEtdmFyLXR1bWJsci1zcXVhcmU6IFxcZjE3NDtcbiRmYS12YXItdHY6IFxcZjI2YztcbiRmYS12YXItdHYtcmV0cm86IFxcZjQwMTtcbiRmYS12YXItdHdpdGNoOiBcXGYxZTg7XG4kZmEtdmFyLXR3aXR0ZXI6IFxcZjA5OTtcbiRmYS12YXItdHdpdHRlci1zcXVhcmU6IFxcZjA4MTtcbiRmYS12YXItdHlwbzM6IFxcZjQyYjtcbiRmYS12YXItdWJlcjogXFxmNDAyO1xuJGZhLXZhci11aWtpdDogXFxmNDAzO1xuJGZhLXZhci11bWJyZWxsYTogXFxmMGU5O1xuJGZhLXZhci11bmRlcmxpbmU6IFxcZjBjZDtcbiRmYS12YXItdW5kbzogXFxmMGUyO1xuJGZhLXZhci11bmRvLWFsdDogXFxmMmVhO1xuJGZhLXZhci11bmlyZWdpc3RyeTogXFxmNDA0O1xuJGZhLXZhci11bml2ZXJzYWwtYWNjZXNzOiBcXGYyOWE7XG4kZmEtdmFyLXVuaXZlcnNpdHk6IFxcZjE5YztcbiRmYS12YXItdW5saW5rOiBcXGYxMjc7XG4kZmEtdmFyLXVubG9jazogXFxmMDljO1xuJGZhLXZhci11bmxvY2stYWx0OiBcXGYxM2U7XG4kZmEtdmFyLXVudGFwcGQ6IFxcZjQwNTtcbiRmYS12YXItdXBsb2FkOiBcXGYwOTM7XG4kZmEtdmFyLXVzYjogXFxmMjg3O1xuJGZhLXZhci11c2QtY2lyY2xlOiBcXGYyZTg7XG4kZmEtdmFyLXVzZC1zcXVhcmU6IFxcZjJlOTtcbiRmYS12YXItdXNlcjogXFxmMDA3O1xuJGZhLXZhci11c2VyLWFsdDogXFxmNDA2O1xuJGZhLXZhci11c2VyLWNpcmNsZTogXFxmMmJkO1xuJGZhLXZhci11c2VyLW1kOiBcXGYwZjA7XG4kZmEtdmFyLXVzZXItcGx1czogXFxmMjM0O1xuJGZhLXZhci11c2VyLXNlY3JldDogXFxmMjFiO1xuJGZhLXZhci11c2VyLXRpbWVzOiBcXGYyMzU7XG4kZmEtdmFyLXVzZXJzOiBcXGYwYzA7XG4kZmEtdmFyLXVzc3VubmFoOiBcXGY0MDc7XG4kZmEtdmFyLXV0ZW5zaWwtZm9yazogXFxmMmUzO1xuJGZhLXZhci11dGVuc2lsLWtuaWZlOiBcXGYyZTQ7XG4kZmEtdmFyLXV0ZW5zaWwtc3Bvb246IFxcZjJlNTtcbiRmYS12YXItdXRlbnNpbHM6IFxcZjJlNztcbiRmYS12YXItdXRlbnNpbHMtYWx0OiBcXGYyZTY7XG4kZmEtdmFyLXZhYWRpbjogXFxmNDA4O1xuJGZhLXZhci12ZW51czogXFxmMjIxO1xuJGZhLXZhci12ZW51cy1kb3VibGU6IFxcZjIyNjtcbiRmYS12YXItdmVudXMtbWFyczogXFxmMjI4O1xuJGZhLXZhci12aWFjb2luOiBcXGYyMzc7XG4kZmEtdmFyLXZpYWRlbzogXFxmMmE5O1xuJGZhLXZhci12aWFkZW8tc3F1YXJlOiBcXGYyYWE7XG4kZmEtdmFyLXZpYWw6IFxcZjQ5MjtcbiRmYS12YXItdmlhbHM6IFxcZjQ5MztcbiRmYS12YXItdmliZXI6IFxcZjQwOTtcbiRmYS12YXItdmlkZW86IFxcZjAzZDtcbiRmYS12YXItdmltZW86IFxcZjQwYTtcbiRmYS12YXItdmltZW8tc3F1YXJlOiBcXGYxOTQ7XG4kZmEtdmFyLXZpbWVvLXY6IFxcZjI3ZDtcbiRmYS12YXItdmluZTogXFxmMWNhO1xuJGZhLXZhci12azogXFxmMTg5O1xuJGZhLXZhci12bnY6IFxcZjQwYjtcbiRmYS12YXItdm9sbGV5YmFsbC1iYWxsOiBcXGY0NWY7XG4kZmEtdmFyLXZvbHVtZS1kb3duOiBcXGYwMjc7XG4kZmEtdmFyLXZvbHVtZS1tdXRlOiBcXGYyZTI7XG4kZmEtdmFyLXZvbHVtZS1vZmY6IFxcZjAyNjtcbiRmYS12YXItdm9sdW1lLXVwOiBcXGYwMjg7XG4kZmEtdmFyLXZ1ZWpzOiBcXGY0MWY7XG4kZmEtdmFyLXdhcmVob3VzZTogXFxmNDk0O1xuJGZhLXZhci13YXJlaG91c2UtYWx0OiBcXGY0OTU7XG4kZmEtdmFyLXdhdGNoOiBcXGYyZTE7XG4kZmEtdmFyLXdlaWJvOiBcXGYxOGE7XG4kZmEtdmFyLXdlaWdodDogXFxmNDk2O1xuJGZhLXZhci13ZWl4aW46IFxcZjFkNztcbiRmYS12YXItd2hhdHNhcHA6IFxcZjIzMjtcbiRmYS12YXItd2hhdHNhcHAtc3F1YXJlOiBcXGY0MGM7XG4kZmEtdmFyLXdoZWVsY2hhaXI6IFxcZjE5MztcbiRmYS12YXItd2hpc3RsZTogXFxmNDYwO1xuJGZhLXZhci13aG1jczogXFxmNDBkO1xuJGZhLXZhci13aWZpOiBcXGYxZWI7XG4kZmEtdmFyLXdpa2lwZWRpYS13OiBcXGYyNjY7XG4kZmEtdmFyLXdpbmRvdzogXFxmNDBlO1xuJGZhLXZhci13aW5kb3ctYWx0OiBcXGY0MGY7XG4kZmEtdmFyLXdpbmRvdy1jbG9zZTogXFxmNDEwO1xuJGZhLXZhci13aW5kb3ctbWF4aW1pemU6IFxcZjJkMDtcbiRmYS12YXItd2luZG93LW1pbmltaXplOiBcXGYyZDE7XG4kZmEtdmFyLXdpbmRvdy1yZXN0b3JlOiBcXGYyZDI7XG4kZmEtdmFyLXdpbmRvd3M6IFxcZjE3YTtcbiRmYS12YXItd29uLXNpZ246IFxcZjE1OTtcbiRmYS12YXItd29yZHByZXNzOiBcXGYxOWE7XG4kZmEtdmFyLXdvcmRwcmVzcy1zaW1wbGU6IFxcZjQxMTtcbiRmYS12YXItd3BiZWdpbm5lcjogXFxmMjk3O1xuJGZhLXZhci13cGV4cGxvcmVyOiBcXGYyZGU7XG4kZmEtdmFyLXdwZm9ybXM6IFxcZjI5ODtcbiRmYS12YXItd3JlbmNoOiBcXGYwYWQ7XG4kZmEtdmFyLXgtcmF5OiBcXGY0OTc7XG4kZmEtdmFyLXhib3g6IFxcZjQxMjtcbiRmYS12YXIteGluZzogXFxmMTY4O1xuJGZhLXZhci14aW5nLXNxdWFyZTogXFxmMTY5O1xuJGZhLXZhci15LWNvbWJpbmF0b3I6IFxcZjIzYjtcbiRmYS12YXIteWFob286IFxcZjE5ZTtcbiRmYS12YXIteWFuZGV4OiBcXGY0MTM7XG4kZmEtdmFyLXlhbmRleC1pbnRlcm5hdGlvbmFsOiBcXGY0MTQ7XG4kZmEtdmFyLXllbHA6IFxcZjFlOTtcbiRmYS12YXIteWVuLXNpZ246IFxcZjE1NztcbiRmYS12YXIteW9hc3Q6IFxcZjJiMTtcbiRmYS12YXIteW91dHViZTogXFxmMTY3O1xuJGZhLXZhci15b3V0dWJlLXNxdWFyZTogXFxmNDMxO1xuIiwiLy8gQm9yZGVyZWQgJiBQdWxsZWRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLiN7JGZhLWNzcy1wcmVmaXh9LWJvcmRlciB7XG4gIGJvcmRlcjogc29saWQgLjA4ZW0gJGZhLWJvcmRlci1jb2xvcjtcbiAgYm9yZGVyLXJhZGl1czogLjFlbTtcbiAgcGFkZGluZzogLjJlbSAuMjVlbSAuMTVlbTtcbn1cblxuLiN7JGZhLWNzcy1wcmVmaXh9LXB1bGwtbGVmdCB7IGZsb2F0OiBsZWZ0OyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcHVsbC1yaWdodCB7IGZsb2F0OiByaWdodDsgfVxuXG4uI3skZmEtY3NzLXByZWZpeH0sXG4uZmFzLFxuLmZhcixcbi5mYWwsXG4uZmFiIHtcbiAgJi4jeyRmYS1jc3MtcHJlZml4fS1wdWxsLWxlZnQgeyBtYXJnaW4tcmlnaHQ6IC4zZW07IH1cbiAgJi4jeyRmYS1jc3MtcHJlZml4fS1wdWxsLXJpZ2h0IHsgbWFyZ2luLWxlZnQ6IC4zZW07IH1cbn1cbiIsIi8vIEFuaW1hdGVkIEljb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4uI3skZmEtY3NzLXByZWZpeH0tc3BpbiB7XG4gIGFuaW1hdGlvbjogZmEtc3BpbiAycyBpbmZpbml0ZSBsaW5lYXI7XG59XG5cbi4jeyRmYS1jc3MtcHJlZml4fS1wdWxzZSB7XG4gIGFuaW1hdGlvbjogZmEtc3BpbiAxcyBpbmZpbml0ZSBzdGVwcyg4KTtcbn1cblxuQGtleWZyYW1lcyBmYS1zcGluIHtcbiAgMCUge1xuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuICB9XG5cbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcbiAgfVxufVxuIiwiLy8gUm90YXRlZCAmIEZsaXBwZWQgSWNvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLiN7JGZhLWNzcy1wcmVmaXh9LXJvdGF0ZS05MCAgeyBAaW5jbHVkZSBmYS1pY29uLXJvdGF0ZSg5MGRlZywgMSk7ICB9XG4uI3skZmEtY3NzLXByZWZpeH0tcm90YXRlLTE4MCB7IEBpbmNsdWRlIGZhLWljb24tcm90YXRlKDE4MGRlZywgMik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yb3RhdGUtMjcwIHsgQGluY2x1ZGUgZmEtaWNvbi1yb3RhdGUoMjcwZGVnLCAzKTsgfVxuXG4uI3skZmEtY3NzLXByZWZpeH0tZmxpcC1ob3Jpem9udGFsIHsgQGluY2x1ZGUgZmEtaWNvbi1mbGlwKC0xLCAxLCAwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZsaXAtdmVydGljYWwgICB7IEBpbmNsdWRlIGZhLWljb24tZmxpcCgxLCAtMSwgMik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mbGlwLWhvcml6b250YWwuI3skZmEtY3NzLXByZWZpeH0tZmxpcC12ZXJ0aWNhbCB7IEBpbmNsdWRlIGZhLWljb24tZmxpcCgtMSwgLTEsIDIpOyB9XG5cbi8vIEhvb2sgZm9yIElFOC05XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbjpyb290IHtcbiAgLiN7JGZhLWNzcy1wcmVmaXh9LXJvdGF0ZS05MCxcbiAgLiN7JGZhLWNzcy1wcmVmaXh9LXJvdGF0ZS0xODAsXG4gIC4jeyRmYS1jc3MtcHJlZml4fS1yb3RhdGUtMjcwLFxuICAuI3skZmEtY3NzLXByZWZpeH0tZmxpcC1ob3Jpem9udGFsLFxuICAuI3skZmEtY3NzLXByZWZpeH0tZmxpcC12ZXJ0aWNhbCB7XG4gICAgZmlsdGVyOiBub25lO1xuICB9XG59XG4iLCIvLyBNaXhpbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkBtaXhpbiBmYS1pY29uIHtcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG4gIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xuICBmb250LXZhcmlhbnQ6IG5vcm1hbDtcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgbGluZS1oZWlnaHQ6IDE7XG4gIHZlcnRpY2FsLWFsaWduOiAtLjEyNWVtO1xufVxuXG5AbWl4aW4gZmEtaWNvbi1yb3RhdGUoJGRlZ3JlZXMsICRyb3RhdGlvbikge1xuICAtbXMtZmlsdGVyOiBcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CYXNpY0ltYWdlKHJvdGF0aW9uPSN7JHJvdGF0aW9ufSlcIjtcbiAgdHJhbnNmb3JtOiByb3RhdGUoJGRlZ3JlZXMpO1xufVxuXG5AbWl4aW4gZmEtaWNvbi1mbGlwKCRob3JpeiwgJHZlcnQsICRyb3RhdGlvbikge1xuICAtbXMtZmlsdGVyOiBcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CYXNpY0ltYWdlKHJvdGF0aW9uPSN7JHJvdGF0aW9ufSwgbWlycm9yPTEpXCI7XG4gIHRyYW5zZm9ybTogc2NhbGUoJGhvcml6LCAkdmVydCk7XG59XG5cblxuLy8gT25seSBkaXNwbGF5IGNvbnRlbnQgdG8gc2NyZWVuIHJlYWRlcnMuIEEgbGEgQm9vdHN0cmFwIDQuXG4vL1xuLy8gU2VlOiBodHRwOi8vYTExeXByb2plY3QuY29tL3Bvc3RzL2hvdy10by1oaWRlLWNvbnRlbnQvXG5cbkBtaXhpbiBzci1vbmx5IHtcbiAgYm9yZGVyOiAwO1xuICBjbGlwOiByZWN0KDAsIDAsIDAsIDApO1xuICBoZWlnaHQ6IDFweDtcbiAgbWFyZ2luOiAtMXB4O1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBwYWRkaW5nOiAwO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHdpZHRoOiAxcHg7XG59XG5cbi8vIFVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIC5zci1vbmx5IHRvIG9ubHkgZGlzcGxheSBjb250ZW50IHdoZW4gaXQncyBmb2N1c2VkLlxuLy9cbi8vIFVzZWZ1bCBmb3IgXCJTa2lwIHRvIG1haW4gY29udGVudFwiIGxpbmtzOyBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9OT1RFLVdDQUcyMC1URUNIUy0yMDEzMDkwNS9HMVxuLy9cbi8vIENyZWRpdDogSFRNTDUgQm9pbGVycGxhdGVcblxuQG1peGluIHNyLW9ubHktZm9jdXNhYmxlIHtcbiAgJjphY3RpdmUsXG4gICY6Zm9jdXMge1xuICAgIGNsaXA6IGF1dG87XG4gICAgaGVpZ2h0OiBhdXRvO1xuICAgIG1hcmdpbjogMDtcbiAgICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgICBwb3NpdGlvbjogc3RhdGljO1xuICAgIHdpZHRoOiBhdXRvO1xuICB9XG59XG4iLCIvLyBTdGFja2VkIEljb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi4jeyRmYS1jc3MtcHJlZml4fS1zdGFjayB7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgaGVpZ2h0OiAyZW07XG4gIGxpbmUtaGVpZ2h0OiAyZW07XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgd2lkdGg6IDJlbTtcbn1cblxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0YWNrLTF4LFxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0YWNrLTJ4IHtcbiAgbGVmdDogMDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIHdpZHRoOiAxMDAlO1xufVxuXG4uI3skZmEtY3NzLXByZWZpeH0tc3RhY2stMXgge1xuICBsaW5lLWhlaWdodDogaW5oZXJpdDtcbn1cblxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0YWNrLTJ4IHtcbiAgZm9udC1zaXplOiAyZW07XG59XG5cbi4jeyRmYS1jc3MtcHJlZml4fS1pbnZlcnNlIHtcbiAgY29sb3I6ICRmYS1pbnZlcnNlO1xufVxuIiwiLyogRm9udCBBd2Vzb21lIHVzZXMgdGhlIFVuaWNvZGUgUHJpdmF0ZSBVc2UgQXJlYSAoUFVBKSB0byBlbnN1cmUgc2NyZWVuXG5yZWFkZXJzIGRvIG5vdCByZWFkIG9mZiByYW5kb20gY2hhcmFjdGVycyB0aGF0IHJlcHJlc2VudCBpY29ucyAqL1xuXG4uI3skZmEtY3NzLXByZWZpeH0tNTAwcHg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLTUwMHB4KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFjY2Vzc2libGUtaWNvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYWNjZXNzaWJsZS1pY29uKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFjY3Vzb2Z0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hY2N1c29mdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hZGRyZXNzLWJvb2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFkZHJlc3MtYm9vayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hZGRyZXNzLWNhcmQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFkZHJlc3MtY2FyZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hZGp1c3Q6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFkanVzdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hZG46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFkbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hZHZlcnNhbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYWR2ZXJzYWwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYWZmaWxpYXRldGhlbWU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFmZmlsaWF0ZXRoZW1lKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFsYXJtLWNsb2NrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbGFybS1jbG9jayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbGdvbGlhOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbGdvbGlhKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFsaWduLWNlbnRlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYWxpZ24tY2VudGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFsaWduLWp1c3RpZnk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFsaWduLWp1c3RpZnkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYWxpZ24tbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYWxpZ24tbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbGlnbi1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYWxpZ24tcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYWxsZXJnaWVzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbGxlcmdpZXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYW1hem9uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbWF6b24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYW1hem9uLXBheTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW1hem9uLXBheSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbWJ1bGFuY2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFtYnVsYW5jZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbWVyaWNhbi1zaWduLWxhbmd1YWdlLWludGVycHJldGluZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW1lcmljYW4tc2lnbi1sYW5ndWFnZS1pbnRlcnByZXRpbmcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYW1pbGlhOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbWlsaWEpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYW5jaG9yOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hbmNob3IpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYW5kcm9pZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW5kcm9pZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbmdlbGxpc3Q6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFuZ2VsbGlzdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbmdsZS1kb3VibGUtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW5nbGUtZG91YmxlLWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYW5nbGUtZG91YmxlLWxlZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFuZ2xlLWRvdWJsZS1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFuZ2xlLWRvdWJsZS1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW5nbGUtZG91YmxlLXJpZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFuZ2xlLWRvdWJsZS11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW5nbGUtZG91YmxlLXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFuZ2xlLWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFuZ2xlLWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYW5nbGUtbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW5nbGUtbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hbmdsZS1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW5nbGUtcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYW5nbGUtdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFuZ2xlLXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFuZ3J5Y3JlYXRpdmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFuZ3J5Y3JlYXRpdmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYW5ndWxhcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYW5ndWxhcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcHAtc3RvcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFwcC1zdG9yZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcHAtc3RvcmUtaW9zOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcHAtc3RvcmUtaW9zKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFwcGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcHBlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcHBsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXBwbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXBwbGUtcGF5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcHBsZS1wYXkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJjaGl2ZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJjaGl2ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1hbHQtY2lyY2xlLWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC1jaXJjbGUtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1hbHQtY2lyY2xlLWxlZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC1jaXJjbGUtbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1hbHQtY2lyY2xlLXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1hbHQtY2lyY2xlLXJpZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC1jaXJjbGUtdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC1jaXJjbGUtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctYWx0LWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC1mcm9tLWJvdHRvbTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LWZyb20tYm90dG9tKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC1mcm9tLWxlZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC1mcm9tLWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctYWx0LWZyb20tcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC1mcm9tLXJpZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC1mcm9tLXRvcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LWZyb20tdG9wKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC1sZWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1hbHQtbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1hbHQtcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC1yaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1hbHQtc3F1YXJlLWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC1zcXVhcmUtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1hbHQtc3F1YXJlLWxlZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC1zcXVhcmUtbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1hbHQtc3F1YXJlLXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1hbHQtc3F1YXJlLXJpZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWFsdC1zcXVhcmUtdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC1zcXVhcmUtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctYWx0LXRvLWJvdHRvbTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LXRvLWJvdHRvbSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1hbHQtdG8tbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LXRvLWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctYWx0LXRvLXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1hbHQtdG8tcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctYWx0LXRvLXRvcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctYWx0LXRvLXRvcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1hbHQtdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWFsdC11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1jaXJjbGUtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctY2lyY2xlLWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctY2lyY2xlLWxlZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWNpcmNsZS1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWNpcmNsZS1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctY2lyY2xlLXJpZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWNpcmNsZS11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctY2lyY2xlLXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctZnJvbS1ib3R0b206YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWZyb20tYm90dG9tKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWZyb20tbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctZnJvbS1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWZyb20tcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWZyb20tcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctZnJvbS10b3A6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWZyb20tdG9wKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LWxlZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LXJpZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93LXNxdWFyZS1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1zcXVhcmUtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy1zcXVhcmUtbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctc3F1YXJlLWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctc3F1YXJlLXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1zcXVhcmUtcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctc3F1YXJlLXVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy1zcXVhcmUtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctdG8tYm90dG9tOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy10by1ib3R0b20pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctdG8tbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctdG8tbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hcnJvdy10by1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3ctdG8tcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctdG8tdG9wOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvdy10by10b3ApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3ctdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93LXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93czpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXJyb3dzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93cy1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93cy1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3dzLWFsdC1oOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvd3MtYWx0LWgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3dzLWFsdC12OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvd3MtYWx0LXYpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXJyb3dzLWg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFycm93cy1oKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWFycm93cy12OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hcnJvd3Mtdik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hc3Npc3RpdmUtbGlzdGVuaW5nLXN5c3RlbXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWFzc2lzdGl2ZS1saXN0ZW5pbmctc3lzdGVtcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hc3RlcmlzazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXN0ZXJpc2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXN5bW1ldHJpazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXN5bW1ldHJpayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXVkaWJsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXVkaWJsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hdWRpby1kZXNjcmlwdGlvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXVkaW8tZGVzY3JpcHRpb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXV0b3ByZWZpeGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1hdXRvcHJlZml4ZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYXZpYW5leDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYXZpYW5leCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hdmlhdG86YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWF2aWF0byk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1hd3M6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWF3cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYWNrd2FyZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmFja3dhcmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmFkZ2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJhZGdlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJhZGdlLWNoZWNrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYWRnZS1jaGVjayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYWxhbmNlLXNjYWxlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYWxhbmNlLXNjYWxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJhbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmFuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJhbmQtYWlkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYW5kLWFpZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYW5kY2FtcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmFuZGNhbXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmFyY29kZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmFyY29kZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXJjb2RlLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmFyY29kZS1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmFyY29kZS1yZWFkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYXJjb2RlLXJlYWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmFyY29kZS1zY2FuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYXJjb2RlLXNjYW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmFyczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmFycyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXNlYmFsbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmFzZWJhbGwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmFzZWJhbGwtYmFsbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmFzZWJhbGwtYmFsbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXNrZXRiYWxsLWJhbGw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJhc2tldGJhbGwtYmFsbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXNrZXRiYWxsLWhvb3A6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJhc2tldGJhbGwtaG9vcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXRoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYXRoKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJhdHRlcnktYm9sdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmF0dGVyeS1ib2x0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJhdHRlcnktZW1wdHk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJhdHRlcnktZW1wdHkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmF0dGVyeS1mdWxsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYXR0ZXJ5LWZ1bGwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmF0dGVyeS1oYWxmOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYXR0ZXJ5LWhhbGYpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmF0dGVyeS1xdWFydGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYXR0ZXJ5LXF1YXJ0ZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmF0dGVyeS1zbGFzaDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmF0dGVyeS1zbGFzaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iYXR0ZXJ5LXRocmVlLXF1YXJ0ZXJzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iYXR0ZXJ5LXRocmVlLXF1YXJ0ZXJzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJlZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmVkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJlZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJlZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmVoYW5jZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmVoYW5jZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iZWhhbmNlLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmVoYW5jZS1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmVsbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmVsbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iZWxsLXNsYXNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iZWxsLXNsYXNoKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJpY3ljbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJpY3ljbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmltb2JqZWN0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iaW1vYmplY3QpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYmlub2N1bGFyczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmlub2N1bGFycyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1iaXJ0aGRheS1jYWtlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1iaXJ0aGRheS1jYWtlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJpdGJ1Y2tldDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYml0YnVja2V0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJpdGNvaW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJpdGNvaW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYml0eTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYml0eSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ibGFjay10aWU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJsYWNrLXRpZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ibGFja2JlcnJ5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ibGFja2JlcnJ5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJsaW5kOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ibGluZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ibG9nZ2VyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ibG9nZ2VyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJsb2dnZXItYjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmxvZ2dlci1iKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJsdWV0b290aDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYmx1ZXRvb3RoKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJsdWV0b290aC1iOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ibHVldG9vdGgtYik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ib2xkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ib2xkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJvbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJvbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYm9tYjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYm9tYik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ib29rOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ib29rKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJvb2ttYXJrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ib29rbWFyayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ib3dsaW5nLWJhbGw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJvd2xpbmctYmFsbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ib3dsaW5nLXBpbnM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJvd2xpbmctcGlucyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ib3g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJveCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ib3gtY2hlY2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJveC1jaGVjayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ib3hlczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYm94ZXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYm94aW5nLWdsb3ZlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ib3hpbmctZ2xvdmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYnJhaWxsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYnJhaWxsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1icmllZmNhc2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJyaWVmY2FzZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1icmllZmNhc2UtbWVkaWNhbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYnJpZWZjYXNlLW1lZGljYWwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYnJvd3NlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYnJvd3Nlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1idGM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJ0Yyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1idWc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJ1Zyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1idWlsZGluZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYnVpbGRpbmcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYnVsbGhvcm46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJ1bGxob3JuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJ1bGxzZXllOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1idWxsc2V5ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1idXJuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1idXJuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWJ1cm9tb2JlbGV4cGVydGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWJ1cm9tb2JlbGV4cGVydGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYnVzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1idXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tYnV5c2VsbGFkczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItYnV5c2VsbGFkcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYWxjdWxhdG9yOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYWxjdWxhdG9yKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhbGVuZGFyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYWxlbmRhcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYWxlbmRhci1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhbGVuZGFyLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYWxlbmRhci1jaGVjazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FsZW5kYXItY2hlY2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FsZW5kYXItZWRpdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FsZW5kYXItZWRpdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYWxlbmRhci1leGNsYW1hdGlvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FsZW5kYXItZXhjbGFtYXRpb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FsZW5kYXItbWludXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhbGVuZGFyLW1pbnVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhbGVuZGFyLXBsdXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhbGVuZGFyLXBsdXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FsZW5kYXItdGltZXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhbGVuZGFyLXRpbWVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhbWVyYTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FtZXJhKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhbWVyYS1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhbWVyYS1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FtZXJhLXJldHJvOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYW1lcmEtcmV0cm8pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2Fwc3VsZXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhcHN1bGVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhcmV0LWNpcmNsZS1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYXJldC1jaXJjbGUtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYXJldC1jaXJjbGUtbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FyZXQtY2lyY2xlLWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FyZXQtY2lyY2xlLXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYXJldC1jaXJjbGUtcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FyZXQtY2lyY2xlLXVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYXJldC1jaXJjbGUtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FyZXQtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FyZXQtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYXJldC1sZWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYXJldC1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhcmV0LXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYXJldC1yaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYXJldC1zcXVhcmUtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FyZXQtc3F1YXJlLWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2FyZXQtc3F1YXJlLWxlZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhcmV0LXNxdWFyZS1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhcmV0LXNxdWFyZS1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FyZXQtc3F1YXJlLXJpZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhcmV0LXNxdWFyZS11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2FyZXQtc3F1YXJlLXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNhcmV0LXVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYXJldC11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYXJ0LWFycm93LWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhcnQtYXJyb3ctZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYXJ0LXBsdXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNhcnQtcGx1cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYy1hbWF6b24tcGF5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYy1hbWF6b24tcGF5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNjLWFtZXg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNjLWFtZXgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2MtYXBwbGUtcGF5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYy1hcHBsZS1wYXkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2MtZGluZXJzLWNsdWI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNjLWRpbmVycy1jbHViKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNjLWRpc2NvdmVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYy1kaXNjb3Zlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYy1qY2I6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNjLWpjYik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jYy1tYXN0ZXJjYXJkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jYy1tYXN0ZXJjYXJkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNjLXBheXBhbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2MtcGF5cGFsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNjLXN0cmlwZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2Mtc3RyaXBlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNjLXZpc2E6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNjLXZpc2EpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2VudGVyY29kZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2VudGVyY29kZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jZXJ0aWZpY2F0ZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2VydGlmaWNhdGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hhcnQtYXJlYTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hhcnQtYXJlYSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGFydC1iYXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoYXJ0LWJhcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGFydC1saW5lOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGFydC1saW5lKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoYXJ0LXBpZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hhcnQtcGllKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZWNrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGVjayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGVjay1jaXJjbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZWNrLWNpcmNsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGVjay1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZWNrLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGVzczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3MpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hlc3MtYmlzaG9wOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGVzcy1iaXNob3ApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hlc3MtYmlzaG9wLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3MtYmlzaG9wLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGVzcy1ib2FyZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3MtYm9hcmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hlc3MtY2xvY2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXNzLWNsb2NrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXNzLWNsb2NrLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3MtY2xvY2stYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXNzLWtpbmc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXNzLWtpbmcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hlc3Mta2luZy1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXNzLWtpbmctYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXNzLWtuaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3Mta25pZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXNzLWtuaWdodC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXNzLWtuaWdodC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hlc3MtcGF3bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3MtcGF3bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGVzcy1wYXduLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3MtcGF3bi1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hlc3MtcXVlZW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXNzLXF1ZWVuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXNzLXF1ZWVuLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hlc3MtcXVlZW4tYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXNzLXJvb2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXNzLXJvb2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hlc3Mtcm9vay1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXNzLXJvb2stYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXZyb24tY2lyY2xlLWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXZyb24tY2lyY2xlLWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hldnJvbi1jaXJjbGUtbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hldnJvbi1jaXJjbGUtbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGV2cm9uLWNpcmNsZS1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hldnJvbi1jaXJjbGUtcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hldnJvbi1jaXJjbGUtdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXZyb24tY2lyY2xlLXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXZyb24tZG91YmxlLWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXZyb24tZG91YmxlLWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hldnJvbi1kb3VibGUtbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hldnJvbi1kb3VibGUtbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGV2cm9uLWRvdWJsZS1yaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hldnJvbi1kb3VibGUtcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hldnJvbi1kb3VibGUtdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXZyb24tZG91YmxlLXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXZyb24tZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hldnJvbi1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXZyb24tbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hldnJvbi1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXZyb24tcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNoZXZyb24tcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hldnJvbi1zcXVhcmUtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hldnJvbi1zcXVhcmUtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGV2cm9uLXNxdWFyZS1sZWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGV2cm9uLXNxdWFyZS1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNoZXZyb24tc3F1YXJlLXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaGV2cm9uLXNxdWFyZS1yaWdodCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGV2cm9uLXNxdWFyZS11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hldnJvbi1zcXVhcmUtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hldnJvbi11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hldnJvbi11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jaGlsZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2hpbGQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2hyb21lOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaHJvbWUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2lyY2xlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaXJjbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2lyY2xlLW5vdGNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jaXJjbGUtbm90Y2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2xpcGJvYXJkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jbGlwYm9hcmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2xpcGJvYXJkLWNoZWNrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jbGlwYm9hcmQtY2hlY2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2xpcGJvYXJkLWxpc3Q6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNsaXBib2FyZC1saXN0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNsb2NrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jbG9jayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jbG9uZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2xvbmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2xvc2VkLWNhcHRpb25pbmc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNsb3NlZC1jYXB0aW9uaW5nKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNsb3VkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jbG91ZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jbG91ZC1kb3dubG9hZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2xvdWQtZG93bmxvYWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2xvdWQtZG93bmxvYWQtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jbG91ZC1kb3dubG9hZC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2xvdWQtdXBsb2FkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jbG91ZC11cGxvYWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2xvdWQtdXBsb2FkLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2xvdWQtdXBsb2FkLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jbG91ZHNjYWxlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jbG91ZHNjYWxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNsb3Vkc21pdGg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNsb3Vkc21pdGgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2xvdWR2ZXJzaWZ5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jbG91ZHZlcnNpZnkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY2x1YjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY2x1Yik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jb2RlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jb2RlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvZGUtYnJhbmNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jb2RlLWJyYW5jaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jb2RlLWNvbW1pdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29kZS1jb21taXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29kZS1tZXJnZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29kZS1tZXJnZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jb2RlcGVuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jb2RlcGVuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvZGllcGllOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jb2RpZXBpZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jb2ZmZWU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvZmZlZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jb2c6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jb2dzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jb2dzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvbHVtbnM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvbHVtbnMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29tbWVudDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29tbWVudCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jb21tZW50LWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29tbWVudC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29tbWVudHM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvbW1lbnRzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvbXBhc3M6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvbXBhc3MpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29tcHJlc3M6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvbXByZXNzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvbXByZXNzLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29tcHJlc3MtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvbXByZXNzLXdpZGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvbXByZXNzLXdpZGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29ubmVjdGRldmVsb3A6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvbm5lY3RkZXZlbG9wKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvbnRhbzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY29udGFvKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvbnZleW9yLWJlbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvbnZleW9yLWJlbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29udmV5b3ItYmVsdC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvbnZleW9yLWJlbHQtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNvcHk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNvcHkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY29weXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jb3B5cmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY3BhbmVsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jcGFuZWwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY3JlYXRpdmUtY29tbW9uczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY3JlYXRpdmUtY29tbW9ucyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jcmVkaXQtY2FyZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY3JlZGl0LWNhcmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY3JlZGl0LWNhcmQtYmxhbms6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNyZWRpdC1jYXJkLWJsYW5rKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNyZWRpdC1jYXJkLWZyb250OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jcmVkaXQtY2FyZC1mcm9udCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jcmlja2V0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jcmlja2V0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNyb3A6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWNyb3ApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tY3Jvc3NoYWlyczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY3Jvc3NoYWlycyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jc3MzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jc3MzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWNzczMtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jc3MzLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jdWJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jdWJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWN1YmVzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jdWJlcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1jdXJsaW5nOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1jdXJsaW5nKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWN1dDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItY3V0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWN1dHRsZWZpc2g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWN1dHRsZWZpc2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZC1hbmQtZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZC1hbmQtZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kYXNoY3ViZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZGFzaGN1YmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZGF0YWJhc2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRhdGFiYXNlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRlYWY6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRlYWYpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZGVsaWNpb3VzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kZWxpY2lvdXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZGVwbG95ZG9nOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kZXBsb3lkb2cpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZGVza3BybzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZGVza3Bybyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kZXNrdG9wOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kZXNrdG9wKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRlc2t0b3AtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kZXNrdG9wLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kZXZpYW50YXJ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kZXZpYW50YXJ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRpYWdub3NlczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZGlhZ25vc2VzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRpYW1vbmQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRpYW1vbmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZGlnZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZGlnZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kaWdpdGFsLW9jZWFuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kaWdpdGFsLW9jZWFuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRpc2NvcmQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRpc2NvcmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZGlzY291cnNlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kaXNjb3Vyc2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZG5hOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kbmEpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZG9jaHViOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kb2NodWIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZG9ja2VyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kb2NrZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZG9sbGFyLXNpZ246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRvbGxhci1zaWduKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRvbGx5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kb2xseSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kb2xseS1lbXB0eTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZG9sbHktZW1wdHkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZG9sbHktZmxhdGJlZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZG9sbHktZmxhdGJlZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kb2xseS1mbGF0YmVkLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZG9sbHktZmxhdGJlZC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZG9sbHktZmxhdGJlZC1lbXB0eTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZG9sbHktZmxhdGJlZC1lbXB0eSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kb3QtY2lyY2xlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kb3QtY2lyY2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRvd25sb2FkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kb3dubG9hZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kcmFmdDJkaWdpdGFsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kcmFmdDJkaWdpdGFsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRyaWJiYmxlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kcmliYmJsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kcmliYmJsZS1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWRyaWJiYmxlLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1kcm9wYm94OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kcm9wYm94KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWRydXBhbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZHJ1cGFsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWR1bWJiZWxsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1kdW1iYmVsbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1keWFsb2c6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWR5YWxvZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1lYXJseWJpcmRzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lYXJseWJpcmRzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWVkZ2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWVkZ2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZWRpdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZWRpdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1lamVjdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZWplY3QpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZWxlbWVudG9yOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lbGVtZW50b3IpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZWxsaXBzaXMtaDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZWxsaXBzaXMtaCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1lbGxpcHNpcy1oLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZWxsaXBzaXMtaC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZWxsaXBzaXMtdjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZWxsaXBzaXMtdik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1lbGxpcHNpcy12LWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZWxsaXBzaXMtdi1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZW1iZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWVtYmVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWVtcGlyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZW1waXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWVudmVsb3BlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lbnZlbG9wZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1lbnZlbG9wZS1vcGVuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1lbnZlbG9wZS1vcGVuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWVudmVsb3BlLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZW52ZWxvcGUtc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWVudmlyYTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZW52aXJhKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWVyYXNlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXJhc2VyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWVybGFuZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXJsYW5nKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV0aGVyZXVtOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ldGhlcmV1bSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ldHN5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ldHN5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV1cm8tc2lnbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXVyby1zaWduKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV4Y2hhbmdlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1leGNoYW5nZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1leGNoYW5nZS1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV4Y2hhbmdlLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1leGNsYW1hdGlvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXhjbGFtYXRpb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXhjbGFtYXRpb24tY2lyY2xlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1leGNsYW1hdGlvbi1jaXJjbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXhjbGFtYXRpb24tc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1leGNsYW1hdGlvbi1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXhjbGFtYXRpb24tdHJpYW5nbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV4Y2xhbWF0aW9uLXRyaWFuZ2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV4cGFuZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXhwYW5kKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV4cGFuZC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV4cGFuZC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXhwYW5kLWFycm93czpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXhwYW5kLWFycm93cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1leHBhbmQtYXJyb3dzLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXhwYW5kLWFycm93cy1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXhwYW5kLXdpZGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV4cGFuZC13aWRlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV4cGVkaXRlZHNzbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXhwZWRpdGVkc3NsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV4dGVybmFsLWxpbms6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV4dGVybmFsLWxpbmspOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXh0ZXJuYWwtbGluay1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV4dGVybmFsLWxpbmstYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWV4dGVybmFsLWxpbmstc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1leHRlcm5hbC1saW5rLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1leHRlcm5hbC1saW5rLXNxdWFyZS1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV4dGVybmFsLWxpbmstc3F1YXJlLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1leWU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWV5ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1leWUtZHJvcHBlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZXllLWRyb3BwZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZXllLXNsYXNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1leWUtc2xhc2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmFjZWJvb2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZhY2Vib29rKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZhY2Vib29rLWY6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZhY2Vib29rLWYpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmFjZWJvb2stbWVzc2VuZ2VyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mYWNlYm9vay1tZXNzZW5nZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmFjZWJvb2stc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mYWNlYm9vay1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmFzdC1iYWNrd2FyZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmFzdC1iYWNrd2FyZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mYXN0LWZvcndhcmQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZhc3QtZm9yd2FyZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mYXg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZheCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mZW1hbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZlbWFsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWVsZC1ob2NrZXk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpZWxkLWhvY2tleSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWdodGVyLWpldDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlnaHRlci1qZXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWxlLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsZS1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsZS1hcmNoaXZlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLWFyY2hpdmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsZS1hdWRpbzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsZS1hdWRpbyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWxlLWNoZWNrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLWNoZWNrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpbGUtY29kZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsZS1jb2RlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpbGUtZWRpdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsZS1lZGl0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpbGUtZXhjZWw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpbGUtZXhjZWwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsZS1leGNsYW1hdGlvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsZS1leGNsYW1hdGlvbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWxlLWltYWdlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLWltYWdlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpbGUtbWVkaWNhbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsZS1tZWRpY2FsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpbGUtbWVkaWNhbC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpbGUtbWVkaWNhbC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsZS1taW51czpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsZS1taW51cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWxlLXBkZjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsZS1wZGYpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsZS1wbHVzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLXBsdXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsZS1wb3dlcnBvaW50OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLXBvd2VycG9pbnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsZS10aW1lczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsZS10aW1lcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1maWxlLXZpZGVvOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maWxlLXZpZGVvKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpbGUtd29yZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsZS13b3JkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpbG06YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpbG0pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlsbS1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpbG0tYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpbHRlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmlsdGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlyZS1leHRpbmd1aXNoZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpcmUtZXh0aW5ndWlzaGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpcmVmb3g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpcmVmb3gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlyc3QtYWlkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1maXJzdC1haWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmlyc3Qtb3JkZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpcnN0LW9yZGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZpcnN0ZHJhZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZpcnN0ZHJhZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmxhZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmxhZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mbGFnLWNoZWNrZXJlZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmxhZy1jaGVja2VyZWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZmxhc2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZsYXNrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZsaWNrcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmxpY2tyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZsaXBib2FyZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmxpcGJvYXJkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZseTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZmx5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZvbGRlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZm9sZGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZvbGRlci1vcGVuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mb2xkZXItb3Blbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mb250OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mb250KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZvbnQtYXdlc29tZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZm9udC1hd2Vzb21lKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZvbnQtYXdlc29tZS1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZvbnQtYXdlc29tZS1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm9udC1hd2Vzb21lLWZsYWc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZvbnQtYXdlc29tZS1mbGFnKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZvbnRpY29uczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZm9udGljb25zKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZvbnRpY29ucy1maTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZm9udGljb25zLWZpKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZvb3RiYWxsLWJhbGw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZvb3RiYWxsLWJhbGwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm9vdGJhbGwtaGVsbWV0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mb290YmFsbC1oZWxtZXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm9ya2xpZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZvcmtsaWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZvcnQtYXdlc29tZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZm9ydC1hd2Vzb21lKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZvcnQtYXdlc29tZS1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZvcnQtYXdlc29tZS1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm9ydW1iZWU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZvcnVtYmVlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWZvcndhcmQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWZvcndhcmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZm91cnNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZm91cnNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mcmVlLWNvZGUtY2FtcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZnJlZS1jb2RlLWNhbXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZnJlZWJzZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZnJlZWJzZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1mcm93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZnJvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZnV0Ym9sOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1mdXRib2wpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2FtZXBhZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ2FtZXBhZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1nYXZlbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ2F2ZWwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2VtOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1nZW0pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2VuZGVybGVzczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ2VuZGVybGVzcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1nZXQtcG9ja2V0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1nZXQtcG9ja2V0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdnOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1nZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1nZy1jaXJjbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdnLWNpcmNsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1naWZ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1naWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdpdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ2l0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdpdC1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdpdC1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2l0aHViOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1naXRodWIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2l0aHViLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ2l0aHViLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1naXRodWItc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1naXRodWItc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdpdGtyYWtlbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ2l0a3Jha2VuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdpdGxhYjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ2l0bGFiKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdpdHRlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ2l0dGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdsYXNzLW1hcnRpbmk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdsYXNzLW1hcnRpbmkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2xpZGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdsaWRlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdsaWRlLWc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdsaWRlLWcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ2xvYmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdsb2JlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdvZm9yZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ29mb3JlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdvbGYtYmFsbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ29sZi1iYWxsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdvbGYtY2x1YjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ29sZi1jbHViKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdvb2RyZWFkczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ29vZHJlYWRzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdvb2RyZWFkcy1nOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1nb29kcmVhZHMtZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1nb29nbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdvb2dsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1nb29nbGUtZHJpdmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdvb2dsZS1kcml2ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1nb29nbGUtcGxheTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ29vZ2xlLXBsYXkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ29vZ2xlLXBsdXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdvb2dsZS1wbHVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdvb2dsZS1wbHVzLWc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdvb2dsZS1wbHVzLWcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ29vZ2xlLXBsdXMtc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1nb29nbGUtcGx1cy1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ29vZ2xlLXdhbGxldDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ29vZ2xlLXdhbGxldCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ncmFkdWF0aW9uLWNhcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItZ3JhZHVhdGlvbi1jYXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ3JhdGlwYXk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdyYXRpcGF5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdyYXY6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdyYXYpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tZ3JpcGZpcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWdyaXBmaXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWdydW50OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ncnVudCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ndWxwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ndWxwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWgtc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oMTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaDEpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taDI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWgyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWgzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oMyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oYWNrZXItbmV3czpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGFja2VyLW5ld3MpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGFja2VyLW5ld3Mtc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oYWNrZXItbmV3cy1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGFuZC1ob2xkaW5nLWJveDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGFuZC1ob2xkaW5nLWJveCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oYW5kLWxpemFyZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGFuZC1saXphcmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGFuZC1wYXBlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGFuZC1wYXBlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oYW5kLXBlYWNlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oYW5kLXBlYWNlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhhbmQtcG9pbnQtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGFuZC1wb2ludC1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhhbmQtcG9pbnQtbGVmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGFuZC1wb2ludC1sZWZ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhhbmQtcG9pbnQtcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhhbmQtcG9pbnQtcmlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGFuZC1wb2ludC11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGFuZC1wb2ludC11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oYW5kLXBvaW50ZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhhbmQtcG9pbnRlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oYW5kLXJlY2VpdmluZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGFuZC1yZWNlaXZpbmcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGFuZC1yb2NrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oYW5kLXJvY2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGFuZC1zY2lzc29yczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGFuZC1zY2lzc29ycyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oYW5kLXNwb2NrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oYW5kLXNwb2NrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhhbmRzaGFrZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGFuZHNoYWtlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhhc2h0YWc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhhc2h0YWcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGRkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oZGQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGVhZGluZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGVhZGluZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oZWFkcGhvbmVzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oZWFkcGhvbmVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhlYXJ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oZWFydCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oZWFydGJlYXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhlYXJ0YmVhdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oZXhhZ29uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oZXhhZ29uKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhpcHM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhpcHMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taGlyZS1hLWhlbHBlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaGlyZS1hLWhlbHBlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1oaXN0b3J5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1oaXN0b3J5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhvY2tleS1wdWNrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ob2NrZXktcHVjayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ob2NrZXktc3RpY2tzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ob2NrZXktc3RpY2tzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhvbWU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhvbWUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taG9vbGk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhvb2xpKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhvc3BpdGFsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ob3NwaXRhbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ob3NwaXRhbC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhvc3BpdGFsLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ob3NwaXRhbC1zeW1ib2w6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhvc3BpdGFsLXN5bWJvbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ob3RqYXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhvdGphcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ob3VyZ2xhc3M6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhvdXJnbGFzcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ob3VyZ2xhc3MtZW5kOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ob3VyZ2xhc3MtZW5kKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWhvdXJnbGFzcy1oYWxmOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ob3VyZ2xhc3MtaGFsZik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ob3VyZ2xhc3Mtc3RhcnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWhvdXJnbGFzcy1zdGFydCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ob3V6ejpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaG91enopOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taHRtbDU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWh0bWw1KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWh1YnNwb3Q6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWh1YnNwb3QpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taS1jdXJzb3I6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWktY3Vyc29yKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWlkLWJhZGdlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pZC1iYWRnZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pZC1jYXJkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pZC1jYXJkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWlkLWNhcmQtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pZC1jYXJkLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pbWFnZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaW1hZ2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taW1hZ2VzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pbWFnZXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taW1kYjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaW1kYik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pbmJveDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaW5ib3gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taW5ib3gtaW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWluYm94LWluKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWluYm94LW91dDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaW5ib3gtb3V0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWluZGVudDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaW5kZW50KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWluZHVzdHJ5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pbmR1c3RyeSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pbmR1c3RyeS1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWluZHVzdHJ5LWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pbmZvOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pbmZvKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWluZm8tY2lyY2xlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pbmZvLWNpcmNsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1pbmZvLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaW5mby1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taW5zdGFncmFtOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pbnN0YWdyYW0pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taW50ZXJuZXQtZXhwbG9yZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWludGVybmV0LWV4cGxvcmVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWludmVudG9yeTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItaW52ZW50b3J5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWlveGhvc3Q6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWlveGhvc3QpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taXRhbGljOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pdGFsaWMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taXR1bmVzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1pdHVuZXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0taXR1bmVzLW5vdGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWl0dW5lcy1ub3RlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWphY2stby1sYW50ZXJuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1qYWNrLW8tbGFudGVybik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1qZW5raW5zOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1qZW5raW5zKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWpvZ2V0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1qb2dldCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1qb29tbGE6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWpvb21sYSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1qczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItanMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tanMtc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1qcy1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tanNmaWRkbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWpzZmlkZGxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWtleTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXIta2V5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWtleWJvYXJkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1rZXlib2FyZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1rZXljZG46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWtleWNkbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1raWNrc3RhcnRlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXIta2lja3N0YXJ0ZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0ta2lja3N0YXJ0ZXItazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXIta2lja3N0YXJ0ZXItayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1rb3J2dWU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWtvcnZ1ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sYW5ndWFnZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGFuZ3VhZ2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGFwdG9wOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sYXB0b3ApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGFyYXZlbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGFyYXZlbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sYXN0Zm06YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxhc3RmbSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sYXN0Zm0tc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sYXN0Zm0tc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxlYWY6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxlYWYpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGVhbnB1YjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGVhbnB1Yik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sZW1vbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGVtb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGVzczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGVzcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sZXZlbC1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sZXZlbC1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxldmVsLWRvd24tYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sZXZlbC1kb3duLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sZXZlbC11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGV2ZWwtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGV2ZWwtdXAtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sZXZlbC11cC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGlmZS1yaW5nOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1saWZlLXJpbmcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGlnaHRidWxiOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1saWdodGJ1bGIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGluZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGluZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1saW5rOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1saW5rKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxpbmtlZGluOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1saW5rZWRpbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1saW5rZWRpbi1pbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGlua2VkaW4taW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGlub2RlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1saW5vZGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGludXg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxpbnV4KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxpcmEtc2lnbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGlyYS1zaWduKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxpc3Q6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxpc3QpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGlzdC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxpc3QtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxpc3Qtb2w6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxpc3Qtb2wpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbGlzdC11bDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbGlzdC11bCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sb2NhdGlvbi1hcnJvdzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbG9jYXRpb24tYXJyb3cpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbG9jazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbG9jayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sb2NrLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbG9jay1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbG9jay1vcGVuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sb2NrLW9wZW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbG9jay1vcGVuLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbG9jay1vcGVuLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sb25nLWFycm93LWFsdC1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sb25nLWFycm93LWFsdC1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxvbmctYXJyb3ctYWx0LWxlZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxvbmctYXJyb3ctYWx0LWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbG9uZy1hcnJvdy1hbHQtcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxvbmctYXJyb3ctYWx0LXJpZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxvbmctYXJyb3ctYWx0LXVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sb25nLWFycm93LWFsdC11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sb25nLWFycm93LWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxvbmctYXJyb3ctZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sb25nLWFycm93LWxlZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxvbmctYXJyb3ctbGVmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sb25nLWFycm93LXJpZ2h0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1sb25nLWFycm93LXJpZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LWxvbmctYXJyb3ctdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLWxvbmctYXJyb3ctdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbG93LXZpc2lvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbG93LXZpc2lvbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1sdWNoYWRvcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbHVjaGFkb3IpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbHlmdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbHlmdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tYWdlbnRvOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tYWdlbnRvKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1hZ2ljOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tYWdpYyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tYWduZXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1hZ25ldCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tYWxlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tYWxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1hcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWFwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1hcC1tYXJrZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1hcC1tYXJrZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWFwLW1hcmtlci1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1hcC1tYXJrZXItYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1hcC1waW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1hcC1waW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWFwLXNpZ25zOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tYXAtc2lnbnMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWFyczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWFycyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tYXJzLWRvdWJsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWFycy1kb3VibGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWFycy1zdHJva2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1hcnMtc3Ryb2tlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1hcnMtc3Ryb2tlLWg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1hcnMtc3Ryb2tlLWgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWFycy1zdHJva2UtdjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWFycy1zdHJva2Utdik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tYXhjZG46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1heGNkbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tZWRhcHBzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tZWRhcHBzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1lZGl1bTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWVkaXVtKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1lZGl1bS1tOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tZWRpdW0tbSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tZWRraXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1lZGtpdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tZWRydDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWVkcnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWVldHVwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tZWV0dXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWVoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tZWgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWVyY3VyeTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWVyY3VyeSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1taWNyb2NoaXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1pY3JvY2hpcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1taWNyb3Bob25lOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1taWNyb3Bob25lKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1pY3JvcGhvbmUtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1taWNyb3Bob25lLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1taWNyb3Bob25lLXNsYXNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1taWNyb3Bob25lLXNsYXNoKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1pY3Jvc29mdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWljcm9zb2Z0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1pbnVzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1taW51cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1taW51cy1jaXJjbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1pbnVzLWNpcmNsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1taW51cy1oZXhhZ29uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1taW51cy1oZXhhZ29uKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1pbnVzLW9jdGFnb246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1pbnVzLW9jdGFnb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWludXMtc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1taW51cy1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWl4OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1taXgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbWl4Y2xvdWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1peGNsb3VkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1penVuaTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbWl6dW5pKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1vYmlsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbW9iaWxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1vYmlsZS1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1vYmlsZS1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbW9iaWxlLWFuZHJvaWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1vYmlsZS1hbmRyb2lkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1vYmlsZS1hbmRyb2lkLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbW9iaWxlLWFuZHJvaWQtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1vZHg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1vZHgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbW9uZXJvOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tb25lcm8pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbW9uZXktYmlsbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbW9uZXktYmlsbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tb25leS1iaWxsLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbW9uZXktYmlsbC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbW9vbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbW9vbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1tb3RvcmN5Y2xlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1tb3RvcmN5Y2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW1vdXNlLXBvaW50ZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW1vdXNlLXBvaW50ZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbXVzaWM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW11c2ljKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW5hcHN0ZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW5hcHN0ZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbmV1dGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1uZXV0ZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbmV3c3BhcGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1uZXdzcGFwZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbmludGVuZG8tc3dpdGNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1uaW50ZW5kby1zd2l0Y2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbm9kZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItbm9kZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ub2RlLWpzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ub2RlLWpzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW5vdGVzLW1lZGljYWw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW5vdGVzLW1lZGljYWwpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbnBtOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ucG0pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbnM4OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1uczgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tbnV0cml0aW9uaXg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW51dHJpdGlvbml4KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW9iamVjdC1ncm91cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItb2JqZWN0LWdyb3VwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW9iamVjdC11bmdyb3VwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1vYmplY3QtdW5ncm91cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1vY3RhZ29uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1vY3RhZ29uKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW9kbm9rbGFzc25pa2k6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW9kbm9rbGFzc25pa2kpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tb2Rub2tsYXNzbmlraS1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW9kbm9rbGFzc25pa2ktc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LW9wZW5jYXJ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1vcGVuY2FydCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1vcGVuaWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW9wZW5pZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1vcGVyYTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItb3BlcmEpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tb3B0aW4tbW9uc3RlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItb3B0aW4tbW9uc3Rlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1vc2k6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLW9zaSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1vdXRkZW50OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1vdXRkZW50KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBhZ2U0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wYWdlNCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wYWdlbGluZXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBhZ2VsaW5lcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wYWludC1icnVzaDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGFpbnQtYnJ1c2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGFsZmVkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wYWxmZWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGFsbGV0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wYWxsZXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGFsbGV0LWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGFsbGV0LWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wYXBlci1wbGFuZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGFwZXItcGxhbmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGFwZXJjbGlwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wYXBlcmNsaXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGFyYWdyYXBoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wYXJhZ3JhcGgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGFzdGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBhc3RlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBhdHJlb246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBhdHJlb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGF1c2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBhdXNlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBhdXNlLWNpcmNsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGF1c2UtY2lyY2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBhdzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGF3KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBheXBhbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGF5cGFsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBlbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGVuKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBlbi1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBlbi1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGVuLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGVuLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wZW5jaWw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBlbmNpbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wZW5jaWwtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wZW5jaWwtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBlbm5hbnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBlbm5hbnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGVyY2VudDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGVyY2VudCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wZXJpc2NvcGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBlcmlzY29wZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1waGFicmljYXRvcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGhhYnJpY2F0b3IpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGhvZW5peC1mcmFtZXdvcms6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBob2VuaXgtZnJhbWV3b3JrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBob25lOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1waG9uZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1waG9uZS1zbGFzaDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGhvbmUtc2xhc2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGhvbmUtc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1waG9uZS1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGhvbmUtdm9sdW1lOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1waG9uZS12b2x1bWUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGhwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1waHApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGllZC1waXBlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGllZC1waXBlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1waWVkLXBpcGVyLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGllZC1waXBlci1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGllZC1waXBlci1wcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGllZC1waXBlci1wcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1waWxsczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGlsbHMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGludGVyZXN0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1waW50ZXJlc3QpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGludGVyZXN0LXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBpbnRlcmVzdC1wKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBpbnRlcmVzdC1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBpbnRlcmVzdC1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGxhbmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBsYW5lKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBsYW5lLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGxhbmUtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBsYXk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBsYXkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGxheS1jaXJjbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBsYXktY2lyY2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBsYXlzdGF0aW9uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wbGF5c3RhdGlvbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wbHVnOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wbHVnKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBsdXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBsdXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcGx1cy1jaXJjbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXBsdXMtY2lyY2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBsdXMtaGV4YWdvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGx1cy1oZXhhZ29uKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBsdXMtb2N0YWdvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcGx1cy1vY3RhZ29uKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBsdXMtc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wbHVzLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wb2RjYXN0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wb2RjYXN0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBvbzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcG9vKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBvcnRyYWl0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wb3J0cmFpdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wb3VuZC1zaWduOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wb3VuZC1zaWduKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXBvd2VyLW9mZjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcG93ZXItb2ZmKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXByZXNjcmlwdGlvbi1ib3R0bGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXByZXNjcmlwdGlvbi1ib3R0bGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcHJlc2NyaXB0aW9uLWJvdHRsZS1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXByZXNjcmlwdGlvbi1ib3R0bGUtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXByaW50OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wcmludCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1wcm9jZWR1cmVzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1wcm9jZWR1cmVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXByb2R1Y3QtaHVudDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcHJvZHVjdC1odW50KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXB1c2hlZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcHVzaGVkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXB1enpsZS1waWVjZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcHV6emxlLXBpZWNlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXB5dGhvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcHl0aG9uKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXFxOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1xcSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1xcmNvZGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXFyY29kZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1xdWVzdGlvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcXVlc3Rpb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcXVlc3Rpb24tY2lyY2xlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1xdWVzdGlvbi1jaXJjbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcXVlc3Rpb24tc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1xdWVzdGlvbi1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcXVpZGRpdGNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1xdWlkZGl0Y2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcXVpbnNjYXBlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1xdWluc2NhcGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcXVvcmE6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXF1b3JhKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXF1b3RlLWxlZnQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXF1b3RlLWxlZnQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcXVvdGUtcmlnaHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXF1b3RlLXJpZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJhY3F1ZXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJhY3F1ZXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmFuZG9tOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yYW5kb20pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmF2ZWxyeTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmF2ZWxyeSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZWFjdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmVhY3QpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmViZWw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlYmVsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJlY3RhbmdsZS1sYW5kc2NhcGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlY3RhbmdsZS1sYW5kc2NhcGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVjdGFuZ2xlLXBvcnRyYWl0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZWN0YW5nbGUtcG9ydHJhaXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVjdGFuZ2xlLXdpZGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlY3RhbmdsZS13aWRlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJlY3ljbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlY3ljbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVkLXJpdmVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZWQtcml2ZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVkZGl0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZWRkaXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVkZGl0LWFsaWVuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZWRkaXQtYWxpZW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVkZGl0LXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmVkZGl0LXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZWRvOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZWRvKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJlZG8tYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZWRvLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yZWdpc3RlcmVkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZWdpc3RlcmVkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJlbmRhY3Q6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlbmRhY3QpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVucmVuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZW5yZW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVwZWF0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yZXBlYXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVwZWF0LTE6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlcGVhdC0xKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJlcGVhdC0xLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmVwZWF0LTEtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJlcGVhdC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlcGVhdC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmVwbHk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJlcGx5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJlcGx5LWFsbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmVwbHktYWxsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJlcGx5ZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmVwbHlkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJlc29sdmluZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcmVzb2x2aW5nKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJldHdlZXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJldHdlZXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcmV0d2VldC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJldHdlZXQtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJvYWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJvYWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcm9ja2V0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yb2NrZXQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcm9ja2V0Y2hhdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcm9ja2V0Y2hhdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1yb2Nrcm1zOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1yb2Nrcm1zKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJzczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcnNzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXJzcy1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXJzcy1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tcnVibGUtc2lnbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItcnVibGUtc2lnbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1ydXBlZS1zaWduOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1ydXBlZS1zaWduKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNhZmFyaTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2FmYXJpKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNhc3M6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNhc3MpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2F2ZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2F2ZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zY2FubmVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zY2FubmVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNjYW5uZXIta2V5Ym9hcmQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNjYW5uZXIta2V5Ym9hcmQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2Nhbm5lci10b3VjaHNjcmVlbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2Nhbm5lci10b3VjaHNjcmVlbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zY2hsaXg6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNjaGxpeCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zY3JpYmQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNjcmliZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zY3J1YmJlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2NydWJiZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2VhcmNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zZWFyY2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2VhcmNoLW1pbnVzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zZWFyY2gtbWludXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2VhcmNoLXBsdXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNlYXJjaC1wbHVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNlYXJjaGVuZ2luOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zZWFyY2hlbmdpbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zZWxsY2FzdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2VsbGNhc3QpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2VsbHN5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zZWxsc3kpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2VydmVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zZXJ2ZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2VydmljZXN0YWNrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zZXJ2aWNlc3RhY2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2hhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNoYXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNoYXJlLWFsbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2hhcmUtYWxsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNoYXJlLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2hhcmUtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNoYXJlLWFsdC1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNoYXJlLWFsdC1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2hhcmUtc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaGFyZS1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2hla2VsLXNpZ246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNoZWtlbC1zaWduKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNoaWVsZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2hpZWxkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNoaWVsZC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNoaWVsZC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2hpZWxkLWNoZWNrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaGllbGQtY2hlY2spOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2hpcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2hpcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaGlwcGluZy1mYXN0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaGlwcGluZy1mYXN0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNoaXBwaW5nLXRpbWVkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaGlwcGluZy10aW1lZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaGlydHNpbmJ1bGs6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNoaXJ0c2luYnVsayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaG9wcGluZy1iYWc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNob3BwaW5nLWJhZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaG9wcGluZy1iYXNrZXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNob3BwaW5nLWJhc2tldCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaG9wcGluZy1jYXJ0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaG9wcGluZy1jYXJ0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNob3dlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2hvd2VyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNodXR0bGVjb2NrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaHV0dGxlY29jayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaWduLWluOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaWduLWluKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNpZ24taW4tYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaWduLWluLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaWduLWxhbmd1YWdlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaWduLWxhbmd1YWdlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNpZ24tb3V0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaWduLW91dCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaWduLW91dC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNpZ24tb3V0LWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaWduYWw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNpZ25hbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaW1wbHlidWlsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2ltcGx5YnVpbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2lzdHJpeDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2lzdHJpeCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zaXRlbWFwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zaXRlbWFwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNreWF0bGFzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1za3lhdGxhcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1za3lwZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2t5cGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2xhY2s6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNsYWNrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNsYWNrLWhhc2g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNsYWNrLWhhc2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2xpZGVycy1oOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zbGlkZXJzLWgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc2xpZGVycy1oLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc2xpZGVycy1oLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zbGlkZXJzLXY6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNsaWRlcnMtdik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zbGlkZXJzLXYtc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zbGlkZXJzLXYtc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNsaWRlc2hhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNsaWRlc2hhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc21pbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNtaWxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNtb2tpbmc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNtb2tpbmcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc25hcGNoYXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNuYXBjaGF0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNuYXBjaGF0LWdob3N0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zbmFwY2hhdC1naG9zdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zbmFwY2hhdC1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNuYXBjaGF0LXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zbm93Zmxha2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNub3dmbGFrZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zb3J0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zb3J0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNvcnQtYWxwaGEtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc29ydC1hbHBoYS1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNvcnQtYWxwaGEtdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNvcnQtYWxwaGEtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc29ydC1hbW91bnQtZG93bjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc29ydC1hbW91bnQtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zb3J0LWFtb3VudC11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc29ydC1hbW91bnQtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc29ydC1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zb3J0LWRvd24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc29ydC1udW1lcmljLWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNvcnQtbnVtZXJpYy1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNvcnQtbnVtZXJpYy11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc29ydC1udW1lcmljLXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNvcnQtdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNvcnQtdXApOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc291bmRjbG91ZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc291bmRjbG91ZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zcGFjZS1zaHV0dGxlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zcGFjZS1zaHV0dGxlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNwYWRlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zcGFkZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zcGVha2FwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zcGVha2FwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNwaW5uZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXNwaW5uZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3Bpbm5lci10aGlyZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3Bpbm5lci10aGlyZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zcG90aWZ5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zcG90aWZ5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXNxdWFyZS1mdWxsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zcXVhcmUtZnVsbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdGFjay1leGNoYW5nZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3RhY2stZXhjaGFuZ2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3RhY2stb3ZlcmZsb3c6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0YWNrLW92ZXJmbG93KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0YXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0YXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3Rhci1leGNsYW1hdGlvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3Rhci1leGNsYW1hdGlvbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdGFyLWhhbGY6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0YXItaGFsZik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdGF5bGlua2VkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdGF5bGlua2VkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0ZWFtOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdGVhbSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdGVhbS1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0ZWFtLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdGVhbS1zeW1ib2w6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0ZWFtLXN5bWJvbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdGVwLWJhY2t3YXJkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdGVwLWJhY2t3YXJkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0ZXAtZm9yd2FyZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3RlcC1mb3J3YXJkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0ZXRob3Njb3BlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdGV0aG9zY29wZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdGlja2VyLW11bGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0aWNrZXItbXVsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdGlja3ktbm90ZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3RpY2t5LW5vdGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3RvcDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3RvcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdG9wLWNpcmNsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3RvcC1jaXJjbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3RvcHdhdGNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdG9wd2F0Y2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3RyYXZhOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdHJhdmEpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3RyZWV0LXZpZXc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0cmVldC12aWV3KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0cmlrZXRocm91Z2g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0cmlrZXRocm91Z2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3RyaXBlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdHJpcGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3RyaXBlLXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0cmlwZS1zKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0dWRpb3ZpbmFyaTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3R1ZGlvdmluYXJpKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN0dW1ibGV1cG9uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdHVtYmxldXBvbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdHVtYmxldXBvbi1jaXJjbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN0dW1ibGV1cG9uLWNpcmNsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdWJzY3JpcHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN1YnNjcmlwdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdWJ3YXk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN1YndheSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdWl0Y2FzZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItc3VpdGNhc2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3VuOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tc3VwZXJwb3dlcnM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN1cGVycG93ZXJzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN1cGVyc2NyaXB0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zdXBlcnNjcmlwdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zdXBwbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXN1cHBsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zeW5jOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zeW5jKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXN5bmMtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zeW5jLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS1zeXJpbmdlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci1zeXJpbmdlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRhYmxlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10YWJsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10YWJsZS10ZW5uaXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRhYmxlLXRlbm5pcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10YWJsZXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRhYmxldCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10YWJsZXQtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10YWJsZXQtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRhYmxldC1hbmRyb2lkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10YWJsZXQtYW5kcm9pZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10YWJsZXQtYW5kcm9pZC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRhYmxldC1hbmRyb2lkLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10YWJsZXQtcnVnZ2VkOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10YWJsZXQtcnVnZ2VkKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRhYmxldHM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRhYmxldHMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGFjaG9tZXRlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGFjaG9tZXRlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10YWNob21ldGVyLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGFjaG9tZXRlci1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGFnOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10YWcpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGFnczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGFncyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10YXNrczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGFza3MpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGF4aTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGF4aSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10ZWxlZ3JhbTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGVsZWdyYW0pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGVsZWdyYW0tcGxhbmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRlbGVncmFtLXBsYW5lKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRlbmNlbnQtd2VpYm86YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRlbmNlbnQtd2VpYm8pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGVubmlzLWJhbGw6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRlbm5pcy1iYWxsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRlcm1pbmFsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10ZXJtaW5hbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10ZXh0LWhlaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGV4dC1oZWlnaHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGV4dC13aWR0aDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGV4dC13aWR0aCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10aDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGgpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGgtbGFyZ2U6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRoLWxhcmdlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRoLWxpc3Q6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRoLWxpc3QpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGhlbWVpc2xlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10aGVtZWlzbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGhlcm1vbWV0ZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRoZXJtb21ldGVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRoZXJtb21ldGVyLWVtcHR5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10aGVybW9tZXRlci1lbXB0eSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10aGVybW9tZXRlci1mdWxsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10aGVybW9tZXRlci1mdWxsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRoZXJtb21ldGVyLWhhbGY6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRoZXJtb21ldGVyLWhhbGYpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGhlcm1vbWV0ZXItcXVhcnRlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGhlcm1vbWV0ZXItcXVhcnRlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10aGVybW9tZXRlci10aHJlZS1xdWFydGVyczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGhlcm1vbWV0ZXItdGhyZWUtcXVhcnRlcnMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGh1bWJzLWRvd246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRodW1icy1kb3duKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRodW1icy11cDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGh1bWJzLXVwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRodW1idGFjazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGh1bWJ0YWNrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRpY2tldDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGlja2V0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRpY2tldC1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRpY2tldC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGltZXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRpbWVzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRpbWVzLWNpcmNsZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGltZXMtY2lyY2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRpbWVzLWhleGFnb246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRpbWVzLWhleGFnb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdGltZXMtb2N0YWdvbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdGltZXMtb2N0YWdvbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10aW1lcy1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRpbWVzLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10aW50OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10aW50KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRvZ2dsZS1vZmY6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRvZ2dsZS1vZmYpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdG9nZ2xlLW9uOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10b2dnbGUtb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdHJhZGVtYXJrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10cmFkZW1hcmspOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdHJhaW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRyYWluKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRyYW5zZ2VuZGVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10cmFuc2dlbmRlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10cmFuc2dlbmRlci1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRyYW5zZ2VuZGVyLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10cmFzaDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdHJhc2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdHJhc2gtYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10cmFzaC1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdHJlZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdHJlZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10cmVlLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdHJlZS1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdHJlbGxvOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10cmVsbG8pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdHJpYW5nbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRyaWFuZ2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRyaXBhZHZpc29yOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10cmlwYWR2aXNvcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10cm9waHk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXRyb3BoeSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10cm9waHktYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10cm9waHktYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXRydWNrOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10cnVjayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10dHk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXR0eSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10dW1ibHI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXR1bWJscik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10dW1ibHItc3F1YXJlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10dW1ibHItc3F1YXJlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXR2OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10dik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10di1yZXRybzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdHYtcmV0cm8pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdHdpdGNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci10d2l0Y2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdHdpdHRlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdHdpdHRlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS10d2l0dGVyLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdHdpdHRlci1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdHlwbzM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXR5cG8zKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXViZXI6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXViZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdWlraXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVpa2l0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVtYnJlbGxhOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11bWJyZWxsYSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11bmRlcmxpbmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVuZGVybGluZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11bmRvOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11bmRvKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVuZG8tYWx0OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11bmRvLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11bmlyZWdpc3RyeTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdW5pcmVnaXN0cnkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdW5pdmVyc2FsLWFjY2VzczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdW5pdmVyc2FsLWFjY2Vzcyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11bml2ZXJzaXR5OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11bml2ZXJzaXR5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVubGluazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdW5saW5rKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVubG9jazpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdW5sb2NrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVubG9jay1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVubG9jay1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdW50YXBwZDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdW50YXBwZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11cGxvYWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVwbG9hZCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11c2I6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVzYik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11c2QtY2lyY2xlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11c2QtY2lyY2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVzZC1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVzZC1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdXNlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdXNlcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11c2VyLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdXNlci1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdXNlci1jaXJjbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVzZXItY2lyY2xlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVzZXItbWQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVzZXItbWQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdXNlci1wbHVzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11c2VyLXBsdXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdXNlci1zZWNyZXQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVzZXItc2VjcmV0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVzZXItdGltZXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVzZXItdGltZXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdXNlcnM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXVzZXJzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXVzc3VubmFoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11c3N1bm5haCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11dGVuc2lsLWZvcms6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXV0ZW5zaWwtZm9yayk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS11dGVuc2lsLWtuaWZlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci11dGVuc2lsLWtuaWZlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXV0ZW5zaWwtc3Bvb246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXV0ZW5zaWwtc3Bvb24pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdXRlbnNpbHM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXV0ZW5zaWxzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXV0ZW5zaWxzLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdXRlbnNpbHMtYWx0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZhYWRpbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdmFhZGluKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZlbnVzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12ZW51cyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS12ZW51cy1kb3VibGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZlbnVzLWRvdWJsZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS12ZW51cy1tYXJzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12ZW51cy1tYXJzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZpYWNvaW46YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZpYWNvaW4pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdmlhZGVvOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12aWFkZW8pOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdmlhZGVvLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdmlhZGVvLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS12aWFsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12aWFsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZpYWxzOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12aWFscyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS12aWJlcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdmliZXIpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdmlkZW86YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZpZGVvKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZpbWVvOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12aW1lbyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS12aW1lby1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZpbWVvLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS12aW1lby12OmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12aW1lby12KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZpbmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZpbmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdms6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZrKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZudjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdm52KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZvbGxleWJhbGwtYmFsbDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdm9sbGV5YmFsbC1iYWxsKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXZvbHVtZS1kb3duOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci12b2x1bWUtZG93bik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS12b2x1bWUtbXV0ZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdm9sdW1lLW11dGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0tdm9sdW1lLW9mZjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdm9sdW1lLW9mZik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS12b2x1bWUtdXA6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXZvbHVtZS11cCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS12dWVqczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItdnVlanMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2FyZWhvdXNlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13YXJlaG91c2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2FyZWhvdXNlLWFsdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd2FyZWhvdXNlLWFsdCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13YXRjaDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd2F0Y2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2VpYm86YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdlaWJvKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdlaWdodDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd2VpZ2h0KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdlaXhpbjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd2VpeGluKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdoYXRzYXBwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13aGF0c2FwcCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13aGF0c2FwcC1zcXVhcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdoYXRzYXBwLXNxdWFyZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13aGVlbGNoYWlyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13aGVlbGNoYWlyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdoaXN0bGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdoaXN0bGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2htY3M6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdobWNzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdpZmk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdpZmkpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2lraXBlZGlhLXc6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdpa2lwZWRpYS13KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdpbmRvdzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd2luZG93KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdpbmRvdy1hbHQ6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdpbmRvdy1hbHQpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2luZG93LWNsb3NlOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13aW5kb3ctY2xvc2UpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2luZG93LW1heGltaXplOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13aW5kb3ctbWF4aW1pemUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2luZG93LW1pbmltaXplOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13aW5kb3ctbWluaW1pemUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td2luZG93LXJlc3RvcmU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdpbmRvdy1yZXN0b3JlKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdpbmRvd3M6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdpbmRvd3MpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td29uLXNpZ246YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdvbi1zaWduKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdvcmRwcmVzczpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd29yZHByZXNzKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdvcmRwcmVzcy1zaW1wbGU6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdvcmRwcmVzcy1zaW1wbGUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td3BiZWdpbm5lcjpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXItd3BiZWdpbm5lcik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS13cGV4cGxvcmVyOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13cGV4cGxvcmVyKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXdwZm9ybXM6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXdwZm9ybXMpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0td3JlbmNoOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci13cmVuY2gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0teC1yYXk6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXgtcmF5KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXhib3g6YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXhib3gpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0teGluZzpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXIteGluZyk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS14aW5nLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXIteGluZy1zcXVhcmUpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0teS1jb21iaW5hdG9yOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci15LWNvbWJpbmF0b3IpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0teWFob286YmVmb3JlIHsgY29udGVudDogZmEtY29udGVudCgkZmEtdmFyLXlhaG9vKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXlhbmRleDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXIteWFuZGV4KTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXlhbmRleC1pbnRlcm5hdGlvbmFsOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci15YW5kZXgtaW50ZXJuYXRpb25hbCk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS15ZWxwOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci15ZWxwKTsgfVxuLiN7JGZhLWNzcy1wcmVmaXh9LXllbi1zaWduOmJlZm9yZSB7IGNvbnRlbnQ6IGZhLWNvbnRlbnQoJGZhLXZhci15ZW4tc2lnbik7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS15b2FzdDpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXIteW9hc3QpOyB9XG4uI3skZmEtY3NzLXByZWZpeH0teW91dHViZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXIteW91dHViZSk7IH1cbi4jeyRmYS1jc3MtcHJlZml4fS15b3V0dWJlLXNxdWFyZTpiZWZvcmUgeyBjb250ZW50OiBmYS1jb250ZW50KCRmYS12YXIteW91dHViZS1zcXVhcmUpOyB9XG4iLCIvLyBTY3JlZW4gUmVhZGVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4uc3Itb25seSB7IEBpbmNsdWRlIHNyLW9ubHk7IH1cbi5zci1vbmx5LWZvY3VzYWJsZSB7IEBpbmNsdWRlIHNyLW9ubHktZm9jdXNhYmxlOyB9XG4iLCJibG9ja3F1b3RlIHtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nOiAwO1xuXG4gIHAge1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICRsaWdodGdyYXk7XG4gICAgYm9yZGVyLWxlZnQ6IC41cmVtIHNvbGlkICRsaWdodGdyYXk7XG4gICAgbWFyZ2luOiAuNXJlbSAwO1xuICAgIHBhZGRpbmc6IC41cmVtIDFyZW0gLjVyZW0gMS41cmVtO1xuICB9XG59XG5cbnByZSwgY29kZSB7XG4gIGJvcmRlci1yYWRpdXM6IC4yNWVtO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAkY29kZS1iZztcbn1cblxucHJlIHtcbiAgb3ZlcmZsb3cteDogYXV0bztcbiAgZm9udC1zaXplOiAuOXJlbTtcbiAgcGFkZGluZzogMXJlbTtcblxuICBjb2RlIHtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG59XG5cbmNvZGUge1xuICBwYWRkaW5nOiAuMmVtIC41ZW07XG59XG4iLCJcbiRibHVlOiAgICAjMzBBMUMxO1xuJGluZGlnbzogICM2NjEwZjI7XG4kcHVycGxlOiAgIzZmNDJjMTtcbiRwaW5rOiAgICAjRDA2NTY2O1xuJHJlZDogICAgICNERDYxNjM7XG4kb3JhbmdlOiAgI0Q1NkQ1OTtcbiR5ZWxsb3c6ICAjRkVDRDNEO1xuJGdyZWVuOiAgICMzNEMzNzE7XG4kdGVhbDogICAgIzIwYzk5NztcbiRjeWFuOiAgICAjNUQ5OUJEO1xuXG4kZGFyay1jeWFuOiAjNmQ5MGEzO1xuXG4kd2hpdGU6ICAjZmZmO1xuJGxpZ2h0Z3JheTogI2U4ZThlODtcbiRiZzogI2YyZjJmMjtcbiRjb2RlLWJnOiAjZjhmOGY4O1xuJGdyYXk6ICM2NjY7XG4kY2hhcmNvYWw6ICMyQjJEMzM7XG4kYmxhY2s6ICAjMDAwO1xuJHNoYWRvdzogdHJhbnNwYXJlbnRpemUoJGJsYWNrLCAuOTUpO1xuJGRhcmstc2hhZG93OiB0cmFuc3BhcmVudGl6ZSgkYmxhY2ssIC43KTtcblxuJHJlZC1saWdodDogbGlnaHRlbigkcmVkLCAzNSUpO1xuJGN5YW4tbGlnaHQ6IGxpZ2h0ZW4oJGN5YW4sIDM4JSk7XG4keWVsbG93LWxpZ2h0OiBsaWdodGVuKCR5ZWxsb3csIDM1JSk7XG4kYmx1ZS1saWdodDogbGlnaHRlbigkYmx1ZSwgNDUlKTtcbiRncmVlbi1saWdodDogbGlnaHRlbigkZ3JlZW4sIDQ1JSk7XG4iLCJAaW1wb3J0IFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplXCI7XG5cbkBpbXBvcnQgXCJpbmxpbmUtZmlsZXNcIjtcbkBpbXBvcnQgXCJmYS1mb250XCI7XG5AaW1wb3J0IFwiLi4vLi4vLi4vZmE1L3Njc3MvZm9udGF3ZXNvbWVcIjtcblxuQGltcG9ydCBcImNvbG9yc1wiO1xuQGltcG9ydCBcIm1hcmstZG93blwiO1xuXG5odG1sIHtcbiAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgSGVsdmV0aWNhLCBBcmlhbDtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBsaW5lLWhlaWdodDogMS41O1xuICBjb2xvcjogJGNoYXJjb2FsO1xufVxuXG5ib2R5IHtcbiAgaGVpZ2h0OiAxMDAlO1xufVxuXG4qIHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbn1cblxuJG5hdi13aWR0aDogMzAwcHg7XG4kY29sbHBhc2Utd2lkdGg6IDcyMHB4O1xuXG4uYmN4LWRvYy1uYXYge1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDA7XG4gIGJvdHRvbTogMDtcbiAgd2lkdGg6ICRuYXYtd2lkdGg7XG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgb3ZlcmZsb3cteTogYXV0bztcbiAgYmFja2dyb3VuZC1jb2xvcjogJGJnO1xuICBwYWRkaW5nOiAuNXJlbTtcbiAgdHJhbnNpdGlvbjogbGVmdCBlYXNlIDIwMG1zO1xuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAkbGlnaHRncmF5O1xuXG4gIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYge1xuICAgIG1hcmdpbjogLjhlbSAwIC40ZW07XG4gIH1cblxuICAuY2xvc2UtbWVudSB7XG4gICAgZGlzcGxheTogbm9uZTtcbiAgfVxufVxuXG4uYmN4LWRvYy1uYXYtYmFja2Ryb3Age1xuICBkaXNwbGF5OiBub25lO1xufVxuXG5hLmxpbmsge1xuICBkaXNwbGF5OiBibG9jaztcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICBmb250LXNpemU6IC44NXJlbTtcblxuICAmLnJlbW90ZS1saW5rIHtcbiAgICBmb250LXNpemU6IDAuNzVyZW07XG4gICAgbWFyZ2luOiA0cHggMDtcbiAgfVxuXG4gICYuZGVwcmVjYXRlZCwge1xuICAgICYsICY6dmlzaXRlZCB7XG4gICAgICB0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaDtcbiAgICAgIGNvbG9yOiAkZ3JheTtcbiAgICB9XG4gIH1cblxuICAmLCAmOnZpc2l0ZWQge1xuICAgIGNvbG9yOiAkY2hhcmNvYWw7XG4gICAgcGFkZGluZzogNHB4IDVweCA0cHggMTBweDtcbiAgICBtYXJnaW46IDJweCAwO1xuICB9XG5cbiAgJi5hY3RpdmUge1xuICAgICYsICY6dmlzaXRlZCB7XG4gICAgICAmLCAmLmRlcHJlY2F0ZWQge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkY3lhbjtcbiAgICAgICAgY29sb3I6ICR3aGl0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAmOmhvdmVyIHtcbiAgICAmLCAmOnZpc2l0ZWQge1xuICAgICAgJiwgJi5kZXByZWNhdGVkIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGdyYXk7XG4gICAgICAgIGNvbG9yOiAkd2hpdGU7XG5cbiAgICAgICAgJi5hY3RpdmUge1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRjeWFuO1xuICAgICAgICAgIGNvbG9yOiAkd2hpdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLmJjeC1kb2MtbWFpbiB7XG4gIHotaW5kZXg6IDE7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgbGVmdDogJG5hdi13aWR0aDtcbiAgYm90dG9tOiAwO1xuICByaWdodDogMDtcbiAgcGFkZGluZzogMXJlbSAuNzVyZW07XG4gIHRyYW5zaXRpb246IGxlZnQgZWFzZSAyMDBtcztcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICBvdmVyZmxvdy15OiBhdXRvO1xufVxuXG4uYmN4LW92ZXJsYXktc3Bpbm5lciB7XG4gIGNvbG9yOiAkYmx1ZTtcblxuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDA7XG4gIHJpZ2h0OiAwO1xuICBib3R0b206IDA7XG4gIGNvbG9yOiAkY3lhbjtcbn1cblxuLmJjeC1kb2MtZGVtbyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtd3JhcDogbm93cmFwO1xuICBhbGlnbi1pdGVtczogc3RyZXRjaDtcblxuICBtYXJnaW4tbGVmdDogLS43NXJlbTtcbiAgbWFyZ2luLXJpZ2h0OiAtLjc1cmVtO1xuXG4gIC5iY3gtZG9jLW1haW4gPiAmIHtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGhlaWdodDogMTAwJTtcbiAgfVxuXG4gIGNvbXBvc2UgPiAmIHtcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgIGJveC1zaGFkb3c6IDAgMCAxcmVtICRsaWdodGdyYXk7XG4gIH1cblxuICAuZGVtby1hcHAge1xuICAgIG1hcmdpbjogMXJlbTtcbiAgICBmbGV4LWdyb3c6IDA7XG4gIH1cblxuICAuZGVtby1jb2RlIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgZmxleC1ncm93OiAxO1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXG4gICAgLmJjeC1zZWxlY3Qge1xuICAgICAgZmxleC1ncm93OiAwO1xuICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgfVxuXG4gICAgZGlzcGxheS1zb3VyY2Uge1xuICAgICAgZmxleDogMSAxIDA7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgfVxuICB9XG59XG5cbi5kaXNwbGF5LXNvdXJjZSB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbnNlbGVjdC5iY3gtc2VsZWN0IHtcbiAgYXBwZWFyYW5jZTogbm9uZTtcbiAgYm9yZGVyLXJhZGl1czogMDtcbiAgYm9yZGVyOiAwO1xuICBjb2xvcjogJHdoaXRlO1xuICBwYWRkaW5nOiAuMjVyZW0gLjVyZW0gLjI1cmVtIDEuNXJlbTtcbiAgZm9udC1zaXplOiAuODVyZW07XG4gIGJhY2tncm91bmQ6ICRkYXJrLWN5YW4gdXJsKFwiZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmOCwlM0NzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB2aWV3Qm94PScwIDAgNCA1JyUzRSUzQ3BhdGggZmlsbD0nd2hpdGUnIGQ9J00yIDBMMCAyaDR6bTAgNUwwIDNoNHonLyUzRSUzQy9zdmclM0VcIikgbm8tcmVwZWF0IGxlZnQgLjVyZW0gY2VudGVyO1xuICBiYWNrZ3JvdW5kLXNpemU6IDhweCAxMHB4O1xufVxuXG4uYmN4LW9wZW4tbWVudSB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHotaW5kZXg6IDI7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgbWF4LXdpZHRoOiAxMDAlO1xuICBwYWRkaW5nOiAuNHJlbSAuNnJlbSAuNHJlbSAuNXJlbTtcbiAgY29sb3I6ICR3aGl0ZTtcbiAgYmFja2dyb3VuZC1jb2xvcjogJGN5YW47XG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAuNnJlbTtcblxuICBvdmVyZmxvdzogaGlkZGVuO1xuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcblxuICBjdXJzb3I6IGRlZmF1bHQ7XG5cbiAgLmZhLWJhcnMge1xuICAgIG1hcmdpbi1yaWdodDogLjI1cmVtO1xuICB9XG59XG5cbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6ICRjb2xscGFzZS13aWR0aCkge1xuICAuYmN4LWRvYy1tYWluID4gLmJjeC1kb2MtZGVtbyB7XG4gICAgLmRlbW8tYXBwIHtcbiAgICAgIG1pbi1oZWlnaHQ6IDEwMHB4O1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvc2UgPiAuYmN4LWRvYy1kZW1vIHtcbiAgICAuZGVtby1hcHAge1xuICAgICAgbWluLXdpZHRoOiAzMDBweDtcbiAgICB9XG5cbiAgICAuZGVtby1jb2RlIHtcbiAgICAgIG1pbi1oZWlnaHQ6IDMwMHB4O1xuICAgIH1cbiAgfVxuXG4gIC5Db2RlTWlycm9yLWZ1bGxzY3JlZW4ge1xuICAgIGxlZnQ6ICRuYXYtd2lkdGg7XG4gIH1cblxuICAuYmN4LW9wZW4tbWVudSB7XG4gICAgbGVmdDogJG5hdi13aWR0aDtcbiAgICBtYXgtd2lkdGg6IGNhbGMoMTAwJSAtICN7JG5hdi13aWR0aH0pO1xuXG4gICAgLmZhLWJhcnMge1xuICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gIH1cbn1cblxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogJGNvbGxwYXNlLXdpZHRoICsgJG5hdi13aWR0aCkge1xuICBjb21wb3NlID4gLmJjeC1kb2MtZGVtbyB7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgfVxufVxuXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAkY29sbHBhc2Utd2lkdGgpIHtcbiAgY29tcG9zZSA+IC5iY3gtZG9jLWRlbW8ge1xuICAgIC5kZW1vLWNvZGUge1xuICAgICAgbWluLWhlaWdodDogMjAwcHg7XG4gICAgfVxuICB9XG5cbiAgLmJjeC1kb2MtbmF2IHtcbiAgICB6LWluZGV4OiA0O1xuICAgIGxlZnQ6IC0kbmF2LXdpZHRoO1xuXG4gICAgJi5tZW51LW9wZW4ge1xuICAgICAgbGVmdDogMDtcbiAgICAgIGJveC1zaGFkb3c6IDAgMCAycmVtICRkYXJrLXNoYWRvdztcblxuICAgICAgLm9wZW4tbWVudSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLmNsb3NlLW1lbnUge1xuICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB6LWluZGV4OiAyO1xuICAgICAgdG9wOiAwO1xuICAgICAgcmlnaHQ6IDA7XG4gICAgICBmb250LXNpemU6IDEuMXJlbTtcbiAgICAgIHBhZGRpbmc6IC40cmVtIC41cmVtIC40cmVtIC42cmVtO1xuICAgICAgY29sb3I6ICRncmF5O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGxpZ2h0Z3JheTtcbiAgICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IC42cmVtO1xuICAgIH1cbiAgfVxuXG4gIC5iY3gtZG9jLW5hdi1iYWNrZHJvcCB7XG4gICAgei1pbmRleDogMztcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgcmlnaHQ6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50aXplKCRncmF5LCAuNCk7XG4gIH1cblxuICAuYmN4LWRvYy1tYWluIHtcbiAgICBsZWZ0OiAwO1xuICB9XG59XG5cbiJdfQ== */\n"; });
define('bcx-doc-base/dist/elements/bcx-doc-nav',['require','exports','module','aurelia-framework','aurelia-event-aggregator','aurelia-pal','lodash'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.BcxDocNav = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _dec2, _class, _desc, _value, _class2, _descriptor;

var _aureliaFramework = require('aurelia-framework');

var _aureliaEventAggregator = require('aurelia-event-aggregator');

var _aureliaPal = require('aurelia-pal');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var BcxDocNav = exports.BcxDocNav = (_dec = (0, _aureliaFramework.inject)(_aureliaEventAggregator.EventAggregator), _dec2 = (0, _aureliaFramework.computedFrom)('router.currentInstruction'), _dec(_class = (_class2 = function () {
  function BcxDocNav(ea) {
    _classCallCheck(this, BcxDocNav);

    _initDefineProp(this, 'router', _descriptor, this);

    this.menuOpen = false;

    this.ea = ea;
  }

  BcxDocNav.prototype.attached = function attached() {
    var _this = this;

    var sections = (0, _lodash2.default)(this.router.navigation).map('settings.section').compact().uniq().value();

    var sectionedNavigation = [];
    _lodash2.default.each(sections, function (section) {
      sectionedNavigation.push({
        name: section,
        navs: _lodash2.default.filter(_this.router.navigation, function (n) {
          return _lodash2.default.get(n, 'settings.section') === section;
        })
      });
    });

    this.sectionedNavigation = sectionedNavigation;

    this.afterNavigation = this.ea.subscribe('router:navigation:complete', function () {
      _this.menuOpen = false;
      var main = _aureliaPal.DOM.querySelector('.bcx-doc-main');
      if (main) main.scrollTop = 0;
    });
  };

  BcxDocNav.prototype.detached = function detached() {
    if (this.afterNavigation) {
      this.afterNavigation.dispose();
      this.afterNavigation = null;
    }
  };

  _createClass(BcxDocNav, [{
    key: 'currentTitle',
    get: function get() {
      var currentInstruction = this.router.currentInstruction;

      if (currentInstruction) {
        var section = currentInstruction.config.settings.section;
        var title = currentInstruction.config.title;
        if (section) title = section + ': ' + title;
        return title;
      }
    }
  }]);

  return BcxDocNav;
}(), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'router', [_aureliaFramework.bindable], {
  enumerable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class2.prototype, 'currentTitle', [_dec2], Object.getOwnPropertyDescriptor(_class2.prototype, 'currentTitle'), _class2.prototype)), _class2)) || _class);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVsZW1lbnRzL2JjeC1kb2MtbmF2LmpzIl0sIm5hbWVzIjpbIkJjeERvY05hdiIsImVhIiwibWVudU9wZW4iLCJhdHRhY2hlZCIsInNlY3Rpb25zIiwicm91dGVyIiwibmF2aWdhdGlvbiIsIm1hcCIsImNvbXBhY3QiLCJ1bmlxIiwidmFsdWUiLCJzZWN0aW9uZWROYXZpZ2F0aW9uIiwiZWFjaCIsInB1c2giLCJuYW1lIiwic2VjdGlvbiIsIm5hdnMiLCJmaWx0ZXIiLCJnZXQiLCJuIiwiYWZ0ZXJOYXZpZ2F0aW9uIiwic3Vic2NyaWJlIiwibWFpbiIsInF1ZXJ5U2VsZWN0b3IiLCJzY3JvbGxUb3AiLCJkZXRhY2hlZCIsImRpc3Bvc2UiLCJjdXJyZW50SW5zdHJ1Y3Rpb24iLCJjb25maWciLCJzZXR0aW5ncyIsInRpdGxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBR2FBLFMsV0FBQUEsUyxXQURaLHNFLFVBb0NFLG9DQUFhLDJCQUFiLEM7QUEvQkQscUJBQVlDLEVBQVosRUFBZ0I7QUFBQTs7QUFBQTs7QUFBQSxTQUZoQkMsUUFFZ0IsR0FGTCxLQUVLOztBQUNkLFNBQUtELEVBQUwsR0FBVUEsRUFBVjtBQUNEOztzQkFFREUsUSx1QkFBVztBQUFBOztBQUNULFFBQU1DLFdBQVcsc0JBQUUsS0FBS0MsTUFBTCxDQUFZQyxVQUFkLEVBQTBCQyxHQUExQixDQUE4QixrQkFBOUIsRUFBa0RDLE9BQWxELEdBQTREQyxJQUE1RCxHQUFtRUMsS0FBbkUsRUFBakI7O0FBRUEsUUFBTUMsc0JBQXNCLEVBQTVCO0FBQ0EscUJBQUVDLElBQUYsQ0FBT1IsUUFBUCxFQUFpQixtQkFBVztBQUMxQk8sMEJBQW9CRSxJQUFwQixDQUF5QjtBQUN2QkMsY0FBTUMsT0FEaUI7QUFFdkJDLGNBQU0saUJBQUVDLE1BQUYsQ0FBUyxNQUFLWixNQUFMLENBQVlDLFVBQXJCLEVBQWlDO0FBQUEsaUJBQUssaUJBQUVZLEdBQUYsQ0FBTUMsQ0FBTixFQUFTLGtCQUFULE1BQWlDSixPQUF0QztBQUFBLFNBQWpDO0FBRmlCLE9BQXpCO0FBSUQsS0FMRDs7QUFPQSxTQUFLSixtQkFBTCxHQUEyQkEsbUJBQTNCOztBQUVBLFNBQUtTLGVBQUwsR0FBdUIsS0FBS25CLEVBQUwsQ0FBUW9CLFNBQVIsQ0FBa0IsNEJBQWxCLEVBQWdELFlBQU07QUFDM0UsWUFBS25CLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSxVQUFJb0IsT0FBTyxnQkFBSUMsYUFBSixDQUFrQixlQUFsQixDQUFYO0FBQ0EsVUFBSUQsSUFBSixFQUFVQSxLQUFLRSxTQUFMLEdBQWlCLENBQWpCO0FBQ1gsS0FKc0IsQ0FBdkI7QUFLRCxHOztzQkFFREMsUSx1QkFBVztBQUNULFFBQUksS0FBS0wsZUFBVCxFQUEwQjtBQUN4QixXQUFLQSxlQUFMLENBQXFCTSxPQUFyQjtBQUNBLFdBQUtOLGVBQUwsR0FBdUIsSUFBdkI7QUFDRDtBQUNGLEc7Ozs7d0JBR21CO0FBQUEsVUFDWE8sa0JBRFcsR0FDVyxLQUFLdEIsTUFEaEIsQ0FDWHNCLGtCQURXOztBQUVsQixVQUFJQSxrQkFBSixFQUF3QjtBQUN0QixZQUFNWixVQUFVWSxtQkFBbUJDLE1BQW5CLENBQTBCQyxRQUExQixDQUFtQ2QsT0FBbkQ7QUFDQSxZQUFJZSxRQUFRSCxtQkFBbUJDLE1BQW5CLENBQTBCRSxLQUF0QztBQUNBLFlBQUlmLE9BQUosRUFBYWUsUUFBUWYsVUFBVSxJQUFWLEdBQWlCZSxLQUF6QjtBQUNiLGVBQU9BLEtBQVA7QUFDRDtBQUNGIiwiZmlsZSI6ImVsZW1lbnRzL2JjeC1kb2MtbmF2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtpbmplY3QsIGJpbmRhYmxlLCBjb21wdXRlZEZyb219IGZyb20gJ2F1cmVsaWEtZnJhbWV3b3JrJztcbmltcG9ydCB7RXZlbnRBZ2dyZWdhdG9yfSBmcm9tICdhdXJlbGlhLWV2ZW50LWFnZ3JlZ2F0b3InO1xuaW1wb3J0IHtET019IGZyb20gJ2F1cmVsaWEtcGFsJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cbkBpbmplY3QoRXZlbnRBZ2dyZWdhdG9yKVxuZXhwb3J0IGNsYXNzIEJjeERvY05hdiB7XG4gIEBiaW5kYWJsZSByb3V0ZXI7XG4gIG1lbnVPcGVuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoZWEpIHtcbiAgICB0aGlzLmVhID0gZWE7XG4gIH1cblxuICBhdHRhY2hlZCgpIHtcbiAgICBjb25zdCBzZWN0aW9ucyA9IF8odGhpcy5yb3V0ZXIubmF2aWdhdGlvbikubWFwKCdzZXR0aW5ncy5zZWN0aW9uJykuY29tcGFjdCgpLnVuaXEoKS52YWx1ZSgpO1xuXG4gICAgY29uc3Qgc2VjdGlvbmVkTmF2aWdhdGlvbiA9IFtdO1xuICAgIF8uZWFjaChzZWN0aW9ucywgc2VjdGlvbiA9PiB7XG4gICAgICBzZWN0aW9uZWROYXZpZ2F0aW9uLnB1c2goe1xuICAgICAgICBuYW1lOiBzZWN0aW9uLFxuICAgICAgICBuYXZzOiBfLmZpbHRlcih0aGlzLnJvdXRlci5uYXZpZ2F0aW9uLCBuID0+IF8uZ2V0KG4sICdzZXR0aW5ncy5zZWN0aW9uJykgPT09IHNlY3Rpb24pXG4gICAgICB9KVxuICAgIH0pO1xuXG4gICAgdGhpcy5zZWN0aW9uZWROYXZpZ2F0aW9uID0gc2VjdGlvbmVkTmF2aWdhdGlvbjtcblxuICAgIHRoaXMuYWZ0ZXJOYXZpZ2F0aW9uID0gdGhpcy5lYS5zdWJzY3JpYmUoJ3JvdXRlcjpuYXZpZ2F0aW9uOmNvbXBsZXRlJywgKCkgPT4ge1xuICAgICAgdGhpcy5tZW51T3BlbiA9IGZhbHNlO1xuICAgICAgbGV0IG1haW4gPSBET00ucXVlcnlTZWxlY3RvcignLmJjeC1kb2MtbWFpbicpO1xuICAgICAgaWYgKG1haW4pIG1haW4uc2Nyb2xsVG9wID0gMDtcbiAgICB9KTtcbiAgfVxuXG4gIGRldGFjaGVkKCkge1xuICAgIGlmICh0aGlzLmFmdGVyTmF2aWdhdGlvbikge1xuICAgICAgdGhpcy5hZnRlck5hdmlnYXRpb24uZGlzcG9zZSgpO1xuICAgICAgdGhpcy5hZnRlck5hdmlnYXRpb24gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIEBjb21wdXRlZEZyb20oJ3JvdXRlci5jdXJyZW50SW5zdHJ1Y3Rpb24nKVxuICBnZXQgY3VycmVudFRpdGxlICgpIHtcbiAgICBjb25zdCB7Y3VycmVudEluc3RydWN0aW9ufSA9IHRoaXMucm91dGVyO1xuICAgIGlmIChjdXJyZW50SW5zdHJ1Y3Rpb24pIHtcbiAgICAgIGNvbnN0IHNlY3Rpb24gPSBjdXJyZW50SW5zdHJ1Y3Rpb24uY29uZmlnLnNldHRpbmdzLnNlY3Rpb247XG4gICAgICBsZXQgdGl0bGUgPSBjdXJyZW50SW5zdHJ1Y3Rpb24uY29uZmlnLnRpdGxlO1xuICAgICAgaWYgKHNlY3Rpb24pIHRpdGxlID0gc2VjdGlvbiArICc6ICcgKyB0aXRsZTtcbiAgICAgIHJldHVybiB0aXRsZTtcbiAgICB9XG4gIH1cbn1cblxuIl19

});

define('text!bcx-doc-base/dist/elements/bcx-doc-nav.html', ['module'], function(module) { module.exports = "<template>\n  <div\n    if.bind=\"menuOpen\"\n    class=\"bcx-doc-nav-backdrop\"\n    click.trigger=\"menuOpen = false & leftClick\"></div>\n\n  <div class=\"bcx-doc-nav ${menuOpen ? 'menu-open' : ''}\">\n    <i class=\"far fa-times close-menu\" click.trigger=\"menuOpen = false & leftClick\"></i>\n\n    <slot name=\"top\"></slot>\n\n    <template repeat.for=\"section of sectionedNavigation\">\n      <h4><em>${section.name}</em></h4>\n      <a\n        repeat.for=\"row of section.navs\"\n        class=\"link ${row.isActive ? 'active' : ''} ${row.settings.deprecated ? 'deprecated' : ''}\"\n        href.bind=\"row.href\"\n      >${row.title}</a>\n    </template>\n\n    <slot></slot>\n  </div>\n\n\n  <div class=\"bcx-open-menu\" click.trigger=\"menuOpen = true & leftClick\">\n    <i class=\"far fa-bars\"></i>\n    ${currentTitle}\n  </div>\n</template>\n"; });
define('bcx-doc-base/dist/elements/code-viewer',['require','exports','module','aurelia-framework','codemirror','codemirror/addon/selection/active-line','codemirror/addon/display/fullscreen','codemirror/addon/lint/lint','codemirror/mode/markdown/markdown','codemirror/mode/javascript/javascript','codemirror/mode/css/css','codemirror/mode/xml/xml','codemirror/mode/htmlmixed/htmlmixed'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.CodeViewer = undefined;

var _desc, _value, _class, _descriptor, _descriptor2;

var _aureliaFramework = require('aurelia-framework');

var _codemirror = require('codemirror');

var _codemirror2 = _interopRequireDefault(_codemirror);

require('codemirror/addon/selection/active-line');

require('codemirror/addon/display/fullscreen');

require('codemirror/addon/lint/lint');

require('codemirror/mode/markdown/markdown');

require('codemirror/mode/javascript/javascript');

require('codemirror/mode/css/css');

require('codemirror/mode/xml/xml');

require('codemirror/mode/htmlmixed/htmlmixed');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

function cleanMode(mode) {
  mode = (mode || '').toLowerCase();
  if (mode === 'md' || mode === 'markdown') return 'text/x-markdown';
  if (mode === 'html' || mode === 'htm') return 'text/html';

  if (mode === 'js' || mode === 'javascript') return 'text/javascript';
  if (mode === 'ts' || mode === 'typescript') return 'application/typescript';
  if (mode === 'json') return 'application/json';

  if (mode === 'css') return 'text/css';
  if (mode === 'scss') return 'text/x-scss';

  return null;
}

var CodeViewer = exports.CodeViewer = (_class = function () {
  function CodeViewer() {
    _classCallCheck(this, CodeViewer);

    _initDefineProp(this, 'value', _descriptor, this);

    _initDefineProp(this, 'mode', _descriptor2, this);

    this.fullScreen = false;
  }

  CodeViewer.prototype.valueChanged = function valueChanged(newValue) {
    var cm = this.cm;

    if (!cm) return;
    cm.setValue(newValue);
  };

  CodeViewer.prototype.modeChanged = function modeChanged(newMode) {
    var cm = this.cm;

    if (!cm) return;
    cm.setOption('mode', cleanMode(newMode));
  };

  CodeViewer.prototype.toggleFullScreen = function toggleFullScreen() {
    var cm = this.cm;

    if (!cm) return;
    this.fullScreen = !this.fullScreen;
    cm.setOption('fullScreen', this.fullScreen);
  };

  CodeViewer.prototype.attached = function attached() {
    this.cm = (0, _codemirror2.default)(this.viewer, {
      value: this.value,
      mode: cleanMode(this.mode),

      lineNumbers: true,
      styleActiveLine: true,
      readOnly: true,
      lineWrapping: true,
      gutters: ["CodeMirror-lint-markers"],
      lint: true
    });
  };

  CodeViewer.prototype.detached = function detached() {
    if (!this.cm) return;
    this.cm.off(this.onChange);
    delete this.cm;

    var cmDom = this.viewer.querySelector('.CodeMirror');
    if (cmDom) {
      this.viewer.removeChild(cmDom);
    }
  };

  return CodeViewer;
}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'value', [_aureliaFramework.bindable], {
  enumerable: true,
  initializer: function initializer() {
    return '';
  }
}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'mode', [_aureliaFramework.bindable], {
  enumerable: true,
  initializer: null
})), _class);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVsZW1lbnRzL2NvZGUtdmlld2VyLmpzIl0sIm5hbWVzIjpbImNsZWFuTW9kZSIsIm1vZGUiLCJ0b0xvd2VyQ2FzZSIsIkNvZGVWaWV3ZXIiLCJmdWxsU2NyZWVuIiwidmFsdWVDaGFuZ2VkIiwibmV3VmFsdWUiLCJjbSIsInNldFZhbHVlIiwibW9kZUNoYW5nZWQiLCJuZXdNb2RlIiwic2V0T3B0aW9uIiwidG9nZ2xlRnVsbFNjcmVlbiIsImF0dGFjaGVkIiwidmlld2VyIiwidmFsdWUiLCJsaW5lTnVtYmVycyIsInN0eWxlQWN0aXZlTGluZSIsInJlYWRPbmx5IiwibGluZVdyYXBwaW5nIiwiZ3V0dGVycyIsImxpbnQiLCJkZXRhY2hlZCIsIm9mZiIsIm9uQ2hhbmdlIiwiY21Eb20iLCJxdWVyeVNlbGVjdG9yIiwicmVtb3ZlQ2hpbGQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsU0FBU0EsU0FBVCxDQUFvQkMsSUFBcEIsRUFBMEI7QUFDeEJBLFNBQU8sQ0FBQ0EsUUFBUSxFQUFULEVBQWFDLFdBQWIsRUFBUDtBQUNBLE1BQUlELFNBQVMsSUFBVCxJQUFpQkEsU0FBUyxVQUE5QixFQUEwQyxPQUFPLGlCQUFQO0FBQzFDLE1BQUlBLFNBQVMsTUFBVCxJQUFtQkEsU0FBUyxLQUFoQyxFQUF1QyxPQUFPLFdBQVA7O0FBRXZDLE1BQUlBLFNBQVMsSUFBVCxJQUFpQkEsU0FBUyxZQUE5QixFQUE0QyxPQUFPLGlCQUFQO0FBQzVDLE1BQUlBLFNBQVMsSUFBVCxJQUFpQkEsU0FBUyxZQUE5QixFQUE0QyxPQUFPLHdCQUFQO0FBQzVDLE1BQUlBLFNBQVMsTUFBYixFQUFxQixPQUFPLGtCQUFQOztBQUVyQixNQUFJQSxTQUFTLEtBQWIsRUFBb0IsT0FBTyxVQUFQO0FBQ3BCLE1BQUlBLFNBQVMsTUFBYixFQUFxQixPQUFPLGFBQVA7O0FBRXJCLFNBQU8sSUFBUDtBQUNEOztJQUVZRSxVLFdBQUFBLFU7Ozs7Ozs7O1NBR1hDLFUsR0FBYSxLOzs7dUJBRWJDLFkseUJBQWFDLFEsRUFBVTtBQUFBLFFBQ2RDLEVBRGMsR0FDUixJQURRLENBQ2RBLEVBRGM7O0FBRXJCLFFBQUksQ0FBQ0EsRUFBTCxFQUFTO0FBQ1RBLE9BQUdDLFFBQUgsQ0FBWUYsUUFBWjtBQUNELEc7O3VCQUVERyxXLHdCQUFZQyxPLEVBQVM7QUFBQSxRQUNaSCxFQURZLEdBQ04sSUFETSxDQUNaQSxFQURZOztBQUVuQixRQUFJLENBQUNBLEVBQUwsRUFBUztBQUNUQSxPQUFHSSxTQUFILENBQWEsTUFBYixFQUFxQlgsVUFBVVUsT0FBVixDQUFyQjtBQUNELEc7O3VCQUVERSxnQiwrQkFBbUI7QUFBQSxRQUNWTCxFQURVLEdBQ0osSUFESSxDQUNWQSxFQURVOztBQUVqQixRQUFJLENBQUNBLEVBQUwsRUFBUztBQUNULFNBQUtILFVBQUwsR0FBa0IsQ0FBQyxLQUFLQSxVQUF4QjtBQUNBRyxPQUFHSSxTQUFILENBQWEsWUFBYixFQUEyQixLQUFLUCxVQUFoQztBQUNELEc7O3VCQUVEUyxRLHVCQUFXO0FBQ1QsU0FBS04sRUFBTCxHQUFVLDBCQUFXLEtBQUtPLE1BQWhCLEVBQXdCO0FBQ2hDQyxhQUFPLEtBQUtBLEtBRG9CO0FBRWhDZCxZQUFNRCxVQUFVLEtBQUtDLElBQWYsQ0FGMEI7O0FBSWhDZSxtQkFBYSxJQUptQjtBQUtoQ0MsdUJBQWlCLElBTGU7QUFNaENDLGdCQUFVLElBTnNCO0FBT2hDQyxvQkFBYyxJQVBrQjtBQVFoQ0MsZUFBUyxDQUFDLHlCQUFELENBUnVCO0FBU2hDQyxZQUFNO0FBVDBCLEtBQXhCLENBQVY7QUFXRCxHOzt1QkFFREMsUSx1QkFBVztBQUNULFFBQUksQ0FBQyxLQUFLZixFQUFWLEVBQWM7QUFDZCxTQUFLQSxFQUFMLENBQVFnQixHQUFSLENBQVksS0FBS0MsUUFBakI7QUFDQSxXQUFPLEtBQUtqQixFQUFaOztBQUlBLFFBQU1rQixRQUFRLEtBQUtYLE1BQUwsQ0FBWVksYUFBWixDQUEwQixhQUExQixDQUFkO0FBQ0EsUUFBSUQsS0FBSixFQUFXO0FBQ1QsV0FBS1gsTUFBTCxDQUFZYSxXQUFaLENBQXdCRixLQUF4QjtBQUNEO0FBQ0YsRzs7Ozs7O1dBaERpQixFIiwiZmlsZSI6ImVsZW1lbnRzL2NvZGUtdmlld2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtiaW5kYWJsZX0gZnJvbSAnYXVyZWxpYS1mcmFtZXdvcmsnO1xuaW1wb3J0IENvZGVNaXJyb3IgZnJvbSAnY29kZW1pcnJvcic7XG5pbXBvcnQgXCJjb2RlbWlycm9yL2FkZG9uL3NlbGVjdGlvbi9hY3RpdmUtbGluZVwiO1xuaW1wb3J0IFwiY29kZW1pcnJvci9hZGRvbi9kaXNwbGF5L2Z1bGxzY3JlZW5cIjtcbmltcG9ydCBcImNvZGVtaXJyb3IvYWRkb24vbGludC9saW50XCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL21vZGUvbWFya2Rvd24vbWFya2Rvd25cIjtcbmltcG9ydCBcImNvZGVtaXJyb3IvbW9kZS9qYXZhc2NyaXB0L2phdmFzY3JpcHRcIjtcbmltcG9ydCBcImNvZGVtaXJyb3IvbW9kZS9jc3MvY3NzXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL21vZGUveG1sL3htbFwiO1xuaW1wb3J0IFwiY29kZW1pcnJvci9tb2RlL2h0bWxtaXhlZC9odG1sbWl4ZWRcIjtcblxuZnVuY3Rpb24gY2xlYW5Nb2RlIChtb2RlKSB7XG4gIG1vZGUgPSAobW9kZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgaWYgKG1vZGUgPT09ICdtZCcgfHwgbW9kZSA9PT0gJ21hcmtkb3duJykgcmV0dXJuICd0ZXh0L3gtbWFya2Rvd24nO1xuICBpZiAobW9kZSA9PT0gJ2h0bWwnIHx8IG1vZGUgPT09ICdodG0nKSByZXR1cm4gJ3RleHQvaHRtbCc7XG4gIC8vIG1vZGUvamF2YXNjcmlwdC9qYXZhc2NyaXB0XG4gIGlmIChtb2RlID09PSAnanMnIHx8IG1vZGUgPT09ICdqYXZhc2NyaXB0JykgcmV0dXJuICd0ZXh0L2phdmFzY3JpcHQnO1xuICBpZiAobW9kZSA9PT0gJ3RzJyB8fCBtb2RlID09PSAndHlwZXNjcmlwdCcpIHJldHVybiAnYXBwbGljYXRpb24vdHlwZXNjcmlwdCc7XG4gIGlmIChtb2RlID09PSAnanNvbicpIHJldHVybiAnYXBwbGljYXRpb24vanNvbic7XG4gIC8vIHN1cHBvcnRlZCBieSBtb2RlL2Nzcy9jc3NcbiAgaWYgKG1vZGUgPT09ICdjc3MnKSByZXR1cm4gJ3RleHQvY3NzJztcbiAgaWYgKG1vZGUgPT09ICdzY3NzJykgcmV0dXJuICd0ZXh0L3gtc2Nzcyc7XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBjbGFzcyBDb2RlVmlld2VyIHtcbiAgQGJpbmRhYmxlIHZhbHVlID0gJyc7XG4gIEBiaW5kYWJsZSBtb2RlO1xuICBmdWxsU2NyZWVuID0gZmFsc2U7XG5cbiAgdmFsdWVDaGFuZ2VkKG5ld1ZhbHVlKSB7XG4gICAgY29uc3Qge2NtfSA9IHRoaXM7XG4gICAgaWYgKCFjbSkgcmV0dXJuO1xuICAgIGNtLnNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgfVxuXG4gIG1vZGVDaGFuZ2VkKG5ld01vZGUpIHtcbiAgICBjb25zdCB7Y219ID0gdGhpcztcbiAgICBpZiAoIWNtKSByZXR1cm47XG4gICAgY20uc2V0T3B0aW9uKCdtb2RlJywgY2xlYW5Nb2RlKG5ld01vZGUpKTtcbiAgfVxuXG4gIHRvZ2dsZUZ1bGxTY3JlZW4oKSB7XG4gICAgY29uc3Qge2NtfSA9IHRoaXM7XG4gICAgaWYgKCFjbSkgcmV0dXJuO1xuICAgIHRoaXMuZnVsbFNjcmVlbiA9ICF0aGlzLmZ1bGxTY3JlZW47XG4gICAgY20uc2V0T3B0aW9uKCdmdWxsU2NyZWVuJywgdGhpcy5mdWxsU2NyZWVuKTtcbiAgfVxuXG4gIGF0dGFjaGVkKCkge1xuICAgIHRoaXMuY20gPSBDb2RlTWlycm9yKHRoaXMudmlld2VyLCB7XG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgIG1vZGU6IGNsZWFuTW9kZSh0aGlzLm1vZGUpLFxuICAgICAgLy8gdGhlbWU6ICdzb2xhcml6ZWQgZGFyaycsXG4gICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgICAgIHN0eWxlQWN0aXZlTGluZTogdHJ1ZSxcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgbGluZVdyYXBwaW5nOiB0cnVlLFxuICAgICAgZ3V0dGVyczogW1wiQ29kZU1pcnJvci1saW50LW1hcmtlcnNcIl0sXG4gICAgICBsaW50OiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBkZXRhY2hlZCgpIHtcbiAgICBpZiAoIXRoaXMuY20pIHJldHVybjtcbiAgICB0aGlzLmNtLm9mZih0aGlzLm9uQ2hhbmdlKTtcbiAgICBkZWxldGUgdGhpcy5jbTtcblxuICAgIC8vIGF1cmVsaWEga2VlcHMgdmlldyBpbiBjYWNoZSAocmV0dXJuVG9DYWNoZSkuXG4gICAgLy8gdGhpcyBtYWtlcyBzdXJlIHRvIGNsZWFuIHVwIGNvZGVtaXJyb3IgaW5zdGFuY2UuXG4gICAgY29uc3QgY21Eb20gPSB0aGlzLnZpZXdlci5xdWVyeVNlbGVjdG9yKCcuQ29kZU1pcnJvcicpO1xuICAgIGlmIChjbURvbSkge1xuICAgICAgdGhpcy52aWV3ZXIucmVtb3ZlQ2hpbGQoY21Eb20pO1xuICAgIH1cbiAgfVxuXG59XG5cbiJdfQ==

});

define('text!bcx-doc-base/dist/elements/code-viewer.css', ['module'], function(module) { module.exports = ".code-viewer {\n  box-sizing: border-box;\n  display: block;\n  position: absolute;\n  font-size: 12px;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0; }\n\n.full-screen-button {\n  z-index: 9999;\n  position: absolute;\n  cursor: default;\n  top: 0;\n  right: 0;\n  font-size: 1.1rem;\n  padding: .4rem .5rem .4rem .6rem;\n  color: #666;\n  background-color: rgba(255, 255, 255, 0.8);\n  border-bottom-left-radius: .6rem;\n  border: 1px solid #e8e8e8;\n  box-shadow: 0 0 1rem rgba(0, 0, 0, 0.05); }\n  .full-screen-button.full-screen {\n    position: fixed; }\n\n.full-screen-button.full-screen, .CodeMirror-fullscreen {\n  top: 1.9rem; }\n\n.CodeMirror-fullscreen {\n  border-top: 1px solid #e8e8e8; }\n\n.CodeMirror {\n  width: 100%;\n  height: 100%; }\n\n/* The lint marker gutter */\n.CodeMirror-lint-markers {\n  width: 16px; }\n\n.CodeMirror-lint-tooltip {\n  background-color: #ffd;\n  border: 1px solid black;\n  border-radius: 4px 4px 4px 4px;\n  color: black;\n  font-family: monospace;\n  font-size: 10pt;\n  overflow: hidden;\n  padding: 2px 5px;\n  position: fixed;\n  white-space: pre;\n  white-space: pre-wrap;\n  z-index: 5100;\n  max-width: 600px;\n  opacity: 0;\n  transition: opacity .4s; }\n\n.CodeMirror-lint-mark-error, .CodeMirror-lint-mark-warning, .CodeMirror-lint-mark-info {\n  background-position: left bottom;\n  background-repeat: repeat-x; }\n\n.CodeMirror-lint-mark-error {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==\"); }\n\n.CodeMirror-lint-mark-warning {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\"); }\n\n.CodeMirror-lint-mark-info {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\"); }\n\n.CodeMirror-lint-marker-error, .CodeMirror-lint-marker-warning, .CodeMirror-lint-marker-info {\n  background-position: center center;\n  background-repeat: no-repeat;\n  cursor: pointer;\n  display: inline-block;\n  height: 16px;\n  width: 16px;\n  vertical-align: middle;\n  position: relative; }\n\n.CodeMirror-lint-message-error, .CodeMirror-lint-message-warning, .CodeMirror-lint-message-info {\n  padding-left: 18px;\n  background-position: top left;\n  background-repeat: no-repeat; }\n\n.CodeMirror-lint-marker-error, .CodeMirror-lint-message-error {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=\"); }\n\n.CodeMirror-lint-marker-warning, .CodeMirror-lint-message-warning {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=\"); }\n\n.CodeMirror-lint-marker-info, .CodeMirror-lint-message-info {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAABCJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyI+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjU8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjwvdGlmZjpZUmVzb2x1dGlvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjE2PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6Q29sb3JTcGFjZT4xPC9leGlmOkNvbG9yU3BhY2U+CiAgICAgICAgIDxleGlmOlBpeGVsWURpbWVuc2lvbj4xNjwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgICAgIDxkYzpzdWJqZWN0PgogICAgICAgICAgICA8cmRmOkJhZy8+CiAgICAgICAgIDwvZGM6c3ViamVjdD4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTYtMTItMjBUMTA6MTI6OTY8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPlBpeGVsbWF0b3IgMy42PC94bXA6Q3JlYXRvclRvb2w+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgrJGuvQAAAB+0lEQVQ4Ec2STWgTQRiG393Z/Owmkf7E0hiIiB5sRYQqFb00oBc9qIiBngpexEtF8SBSDx7En4N40pZgUMGL6KWIgmd7EKrUg1Kak4ixkbq2ZpPN7s7uTHemhRhLoAcPzmGWmff9Ht7vmwX+63XhQfHhyO13fPx+sdQpqNpJmJ4+kXq1dOzsrHUQn62BsXuPLnYBXPnb3xHwtnK0VPWyUmeKpt39eq2sT+D0pgBPJseyz36MFjgUNG4ABmlghXZv3WfM2ZsCvHFOPf/lp8NyLv0OM8C4imXWV8Ilrv8J2dDCxNSdA6/N44eEqSdqSq/p9crvkteTOZN7mZeH9a0dUOBk5vfIC8qjIGoA00tLm481W3+8ikU3M5W6zNeEUG0DjOcfn3xfG94uehfpVTAM3ZxHlWYl6Iu9Ax+t/bmd3QtX1gO0A+asvZOiOE4cqceIiw9XB9AfWURMdUCUIOQqqLPUeeS5JkytBOd45Lu7rU9ceiwqjZRFoMiX5/B4TI5UQIhCkxiGHGYLUFTo4a4ZOfkEqUMnNpLEwtCteXxzcoILQ7WxSy8jqdURdsfEXQsQHp5WClsGE5/KzcCgjKlNxlEr27tZwNUwi+tG4C+bfvrnQmPPESTRFIANv6Z450QCo5RhVmeoBHFkqA+qMdQaFlbQiwDXFV8U/5O1Ci6fuR8n2bVhAAAAAElFTkSuQmCC\"); }\n\n.CodeMirror-lint-marker-multiple {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC\");\n  background-repeat: no-repeat;\n  background-position: right bottom;\n  width: 100%;\n  height: 100%; }\n\n/*# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVsZW1lbnRzL2NvZGUtdmlld2VyLnNjc3MiLCJjc3MvX2NvbG9ycy5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBO0VBQ0UsdUJBQXNCO0VBQ3RCLGVBQWM7RUFDZCxtQkFBa0I7RUFDbEIsZ0JBQWU7RUFDZixPQUFNO0VBQ04sUUFBTztFQUNQLFNBQVE7RUFDUixVQUFTLEVBQ1Y7O0FBRUQ7RUFDRSxjQUFhO0VBQ2IsbUJBQWtCO0VBQ2xCLGdCQUFlO0VBQ2YsT0FBTTtFQUNOLFNBQVE7RUFDUixrQkFBaUI7RUFDakIsaUNBQWdDO0VBQ2hDLFlDSFM7RURJVCwyQ0FBNEM7RUFDNUMsaUNBQWdDO0VBQ2hDLDBCQ1RpQjtFRFVqQix5Q0NKa0MsRURTbkM7RUFqQkQ7SUFlSSxnQkFBZSxFQUNoQjs7QUFHSDtFQUNFLFlBQVcsRUFDWjs7QUFFRDtFQUNFLDhCQ3RCaUIsRUR1QmxCOztBQUVEO0VBQ0UsWUFBVztFQUNYLGFBQVksRUFDYjs7QUFFRCw0QkFBNEI7QUFDNUI7RUFDRSxZQUFXLEVBQ1o7O0FBRUQ7RUFDRSx1QkFBc0I7RUFDdEIsd0JBQXVCO0VBQ3ZCLCtCQUE4QjtFQUM5QixhQUFZO0VBQ1osdUJBQXNCO0VBQ3RCLGdCQUFlO0VBQ2YsaUJBQWdCO0VBQ2hCLGlCQUFnQjtFQUNoQixnQkFBZTtFQUNmLGlCQUFnQjtFQUNoQixzQkFBcUI7RUFDckIsY0FBYTtFQUNiLGlCQUFnQjtFQUNoQixXQUFVO0VBQ1Ysd0JBQXVCLEVBQ3hCOztBQUVEO0VBQ0UsaUNBQWdDO0VBQ2hDLDRCQUEyQixFQUM1Qjs7QUFFRDtFQUNFLG9UQUNpUyxFQUVsUzs7QUFFRDtFQUNFLGdWQUErVSxFQUNoVjs7QUFFRDtFQUNFLGdWQUErVSxFQUNoVjs7QUFFRDtFQUNFLG1DQUFrQztFQUNsQyw2QkFBNEI7RUFDNUIsZ0JBQWU7RUFDZixzQkFBcUI7RUFDckIsYUFBWTtFQUNaLFlBQVc7RUFDWCx1QkFBc0I7RUFDdEIsbUJBQWtCLEVBQ25COztBQUVEO0VBQ0UsbUJBQWtCO0VBQ2xCLDhCQUE2QjtFQUM3Qiw2QkFBNEIsRUFDN0I7O0FBRUQ7RUFDRSxvVEFBbVQsRUFDcFQ7O0FBRUQ7RUFDRSx3V0FBdVcsRUFDeFc7O0FBRUQ7RUFDRSxndUVBQSt0RSxFQUNodUU7O0FBRUQ7RUFDRSx3TkFBdU47RUFDdk4sNkJBQTRCO0VBQzVCLGtDQUFpQztFQUNqQyxZQUFXO0VBQ1gsYUFBWSxFQUNiIiwiZmlsZSI6ImVsZW1lbnRzL2NvZGUtdmlld2VyLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIkBpbXBvcnQgXCIuLi9jc3MvY29sb3JzXCI7XG5cbi5jb2RlLXZpZXdlciB7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGZvbnQtc2l6ZTogMTJweDtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICByaWdodDogMDtcbiAgYm90dG9tOiAwO1xufVxuXG4uZnVsbC1zY3JlZW4tYnV0dG9uIHtcbiAgei1pbmRleDogOTk5OTtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBjdXJzb3I6IGRlZmF1bHQ7XG4gIHRvcDogMDtcbiAgcmlnaHQ6IDA7XG4gIGZvbnQtc2l6ZTogMS4xcmVtO1xuICBwYWRkaW5nOiAuNHJlbSAuNXJlbSAuNHJlbSAuNnJlbTtcbiAgY29sb3I6ICRncmF5O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudGl6ZSgkd2hpdGUsIC4yKTtcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogLjZyZW07XG4gIGJvcmRlcjogMXB4IHNvbGlkICRsaWdodGdyYXk7XG4gIGJveC1zaGFkb3c6IDAgMCAxcmVtICRzaGFkb3c7XG5cbiAgJi5mdWxsLXNjcmVlbiB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICB9XG59XG5cbi5mdWxsLXNjcmVlbi1idXR0b24uZnVsbC1zY3JlZW4sIC5Db2RlTWlycm9yLWZ1bGxzY3JlZW4ge1xuICB0b3A6IDEuOXJlbTtcbn1cblxuLkNvZGVNaXJyb3ItZnVsbHNjcmVlbiB7XG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAkbGlnaHRncmF5O1xufVxuXG4uQ29kZU1pcnJvciB7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG59XG5cbi8qIFRoZSBsaW50IG1hcmtlciBndXR0ZXIgKi9cbi5Db2RlTWlycm9yLWxpbnQtbWFya2VycyB7XG4gIHdpZHRoOiAxNnB4O1xufVxuXG4uQ29kZU1pcnJvci1saW50LXRvb2x0aXAge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZkO1xuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcbiAgYm9yZGVyLXJhZGl1czogNHB4IDRweCA0cHggNHB4O1xuICBjb2xvcjogYmxhY2s7XG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gIGZvbnQtc2l6ZTogMTBwdDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgcGFkZGluZzogMnB4IDVweDtcbiAgcG9zaXRpb246IGZpeGVkO1xuICB3aGl0ZS1zcGFjZTogcHJlO1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG4gIHotaW5kZXg6IDUxMDA7XG4gIG1heC13aWR0aDogNjAwcHg7XG4gIG9wYWNpdHk6IDA7XG4gIHRyYW5zaXRpb246IG9wYWNpdHkgLjRzO1xufVxuXG4uQ29kZU1pcnJvci1saW50LW1hcmstZXJyb3IsIC5Db2RlTWlycm9yLWxpbnQtbWFyay13YXJuaW5nLCAuQ29kZU1pcnJvci1saW50LW1hcmstaW5mbyB7XG4gIGJhY2tncm91bmQtcG9zaXRpb246IGxlZnQgYm90dG9tO1xuICBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0LXg7XG59XG5cbi5Db2RlTWlycm9yLWxpbnQtbWFyay1lcnJvciB7XG4gIGJhY2tncm91bmQtaW1hZ2U6XG4gIHVybChcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQVFBQUFBRENBWUFBQUMwOUs3R0FBQUFBWE5TUjBJQXJzNGM2UUFBQUFaaVMwZEVBUDhBL3dEL29MMm5rd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFBZDBTVTFGQjlzSkR3NGNPQ1cxL0tJQUFBQVpkRVZZZEVOdmJXMWxiblFBUTNKbFlYUmxaQ0IzYVhSb0lFZEpUVkJYZ1E0WEFBQUFIRWxFUVZRSTEyTmdnSUwvREF6L0dkQTUveGtZL3FQS01EQXdBQURMWndmNXJ2bStMUUFBQUFCSlJVNUVya0pnZ2c9PVwiKVxuICA7XG59XG5cbi5Db2RlTWlycm9yLWxpbnQtbWFyay13YXJuaW5nIHtcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBUUFBQUFEQ0FZQUFBQzA5SzdHQUFBQUFYTlNSMElBcnM0YzZRQUFBQVppUzBkRUFQOEEvd0Qvb0wybmt3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQUFkMFNVMUZCOXNKRmhRWEViaFRnN1lBQUFBWmRFVllkRU52YlcxbGJuUUFRM0psWVhSbFpDQjNhWFJvSUVkSlRWQlhnUTRYQUFBQU1rbEVRVlFJMTJOa2dJSXZKM1FYTWpBd2RETitPYUVieXNEQTRNUEF3TkROd01Dd2lPSExDZDF6WDA3bzZrQlZHUUVBS0JBTnRvYnNrTk1BQUFBQVNVVk9SSzVDWUlJPVwiKTtcbn1cblxuLkNvZGVNaXJyb3ItbGludC1tYXJrLWluZm8ge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFRQUFBQURDQVlBQUFDMDlLN0dBQUFBQVhOU1IwSUFyczRjNlFBQUFBWmlTMGRFQVA4QS93RC9vTDJua3dBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBQWQwU1UxRkI5c0pGaFFYRWJoVGc3WUFBQUFaZEVWWWRFTnZiVzFsYm5RQVEzSmxZWFJsWkNCM2FYUm9JRWRKVFZCWGdRNFhBQUFBTWtsRVFWUUkxMk5rZ0lJdkozUVhNakF3ZEROK09hRWJ5c0RBNE1QQXdORE53TUN3aU9ITENkMXpYMDdvNmtCVkdRRUFLQkFOdG9ic2tOTUFBQUFBU1VWT1JLNUNZSUk9XCIpO1xufVxuXG4uQ29kZU1pcnJvci1saW50LW1hcmtlci1lcnJvciwgLkNvZGVNaXJyb3ItbGludC1tYXJrZXItd2FybmluZywgLkNvZGVNaXJyb3ItbGludC1tYXJrZXItaW5mbyB7XG4gIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciBjZW50ZXI7XG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICBoZWlnaHQ6IDE2cHg7XG4gIHdpZHRoOiAxNnB4O1xuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbi5Db2RlTWlycm9yLWxpbnQtbWVzc2FnZS1lcnJvciwgLkNvZGVNaXJyb3ItbGludC1tZXNzYWdlLXdhcm5pbmcsIC5Db2RlTWlycm9yLWxpbnQtbWVzc2FnZS1pbmZvIHtcbiAgcGFkZGluZy1sZWZ0OiAxOHB4O1xuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiB0b3AgbGVmdDtcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbn1cblxuLkNvZGVNaXJyb3ItbGludC1tYXJrZXItZXJyb3IsIC5Db2RlTWlycm9yLWxpbnQtbWVzc2FnZS1lcnJvciB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBTUFBQUFvTFE5VEFBQUFIbEJNVkVXN0FBQzdBQUN4QUFDN0FBQzdBQUFBQUFDNEFBQzVBQUQvLy8rN0FBQVVkY2xwQUFBQUJuUlNUbE1Ybk9SU2l3Q0swWktTQUFBQVRVbEVRVlI0Mm1XUE9RN0FRQWdEdVFMeC96OGNzWVJtUFJJRkl3Ukdub3NScnBhbXZrS2kwRlRJaU1BU1IzaGhLVytoQU42L3RJV2h1OVBEV2lUR05Fa1R0SU91Y0E1T3lyOWNrUGdBV20wR1BCb2c2djRBQUFBQVNVVk9SSzVDWUlJPVwiKTtcbn1cblxuLkNvZGVNaXJyb3ItbGludC1tYXJrZXItd2FybmluZywgLkNvZGVNaXJyb3ItbGludC1tZXNzYWdlLXdhcm5pbmcge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQU1BQUFBb0xROVRBQUFBTmxCTVZFWC91d0R2cndEL3V3RC91d0QvdXdEL3V3RC91d0QvdXdEL3V3RDZ0d0QvdXdBQUFBRHVyd0QydFFEN3VBRCt1Z0FBQUFEL3V3RGhtZVRSQUFBQURIUlNUbE1KOG1OMUVZY2JtaWl4Z0FDbTdXYnVBQUFBVmtsRVFWUjQybjNQVVFxQUlCQkZVVTFMTGMzdS9qZGJPSm9XMVAwOERBOUdiYTgrWVdKNmdOSm9OWUlCekFBMmNoQnRoNWtMbUc5WVVvRzBOSEFVd0ZYd085THVCUUwxZ2lDUWI4Z0M5T3JvMnZwNXJuY0NJWThMOHVFeDVaa0FBQUFBU1VWT1JLNUNZSUk9XCIpO1xufVxuXG4uQ29kZU1pcnJvci1saW50LW1hcmtlci1pbmZvLCAuQ29kZU1pcnJvci1saW50LW1lc3NhZ2UtaW5mbyB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FZQUFBQWY4LzloQUFBQUFYTlNSMElBcnM0YzZRQUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQkNKcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWxoTlVDQkRiM0psSURVdU5DNHdJajRLSUNBZ1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNEtJQ0FnSUNBZ1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZkR2xtWmowaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTBhV1ptTHpFdU1DOGlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbVY0YVdZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZaWGhwWmk4eExqQXZJZ29nSUNBZ0lDQWdJQ0FnSUNCNGJXeHVjenBrWXowaWFIUjBjRG92TDNCMWNtd3ViM0puTDJSakwyVnNaVzFsYm5Sekx6RXVNUzhpQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T25odGNEMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMeUkrQ2lBZ0lDQWdJQ0FnSUR4MGFXWm1PbEpsYzI5c2RYUnBiMjVWYm1sMFBqSThMM1JwWm1ZNlVtVnpiMngxZEdsdmJsVnVhWFErQ2lBZ0lDQWdJQ0FnSUR4MGFXWm1Pa052YlhCeVpYTnphVzl1UGpVOEwzUnBabVk2UTI5dGNISmxjM05wYjI0K0NpQWdJQ0FnSUNBZ0lEeDBhV1ptT2xoU1pYTnZiSFYwYVc5dVBqY3lQQzkwYVdabU9saFNaWE52YkhWMGFXOXVQZ29nSUNBZ0lDQWdJQ0E4ZEdsbVpqcFBjbWxsYm5SaGRHbHZiajR4UEM5MGFXWm1Pazl5YVdWdWRHRjBhVzl1UGdvZ0lDQWdJQ0FnSUNBOGRHbG1aanBaVW1WemIyeDFkR2x2Ymo0M01qd3ZkR2xtWmpwWlVtVnpiMngxZEdsdmJqNEtJQ0FnSUNBZ0lDQWdQR1Y0YVdZNlVHbDRaV3hZUkdsdFpXNXphVzl1UGpFMlBDOWxlR2xtT2xCcGVHVnNXRVJwYldWdWMybHZiajRLSUNBZ0lDQWdJQ0FnUEdWNGFXWTZRMjlzYjNKVGNHRmpaVDR4UEM5bGVHbG1Pa052Ykc5eVUzQmhZMlUrQ2lBZ0lDQWdJQ0FnSUR4bGVHbG1PbEJwZUdWc1dVUnBiV1Z1YzJsdmJqNHhOand2WlhocFpqcFFhWGhsYkZsRWFXMWxibk5wYjI0K0NpQWdJQ0FnSUNBZ0lEeGtZenB6ZFdKcVpXTjBQZ29nSUNBZ0lDQWdJQ0FnSUNBOGNtUm1Pa0poWnk4K0NpQWdJQ0FnSUNBZ0lEd3ZaR002YzNWaWFtVmpkRDRLSUNBZ0lDQWdJQ0FnUEhodGNEcE5iMlJwWm5sRVlYUmxQakl3TVRZdE1USXRNakJVTVRBNk1USTZPVFk4TDNodGNEcE5iMlJwWm5sRVlYUmxQZ29nSUNBZ0lDQWdJQ0E4ZUcxd09rTnlaV0YwYjNKVWIyOXNQbEJwZUdWc2JXRjBiM0lnTXk0MlBDOTRiWEE2UTNKbFlYUnZjbFJ2YjJ3K0NpQWdJQ0FnSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGdvZ0lDQThMM0prWmpwU1JFWStDand2ZURwNGJYQnRaWFJoUGdySkd1dlFBQUFCKzBsRVFWUTRFYzJTVFdnVFFSaUczOTNaL093bWtmN0UwaGlJaUI1c1JZUXFGYjAwb0JjOXFJaUJuZ3BleEV0RjhTQlNEeDdFbjRONDBwWmdVTUdMNktXSWdtZDdFS3JVZzFLYWs0aXhrYnEyWnBQTjdzN3VUSGVtaFJoTG9BY1B6bUdXbWZmOUh0N3Ztd1grNjNYaFFmSGh5TzEzZlB4K3NkUXBxTnBKbUo0K2tYcTFkT3pzckhVUW42MkJzWHVQTG5ZQlhQbmIzeEh3dG5LMFZQV3lVbWVLcHQzOWVxMnNUK0QwcGdCUEpzZXl6MzZNRmpnVU5HNEFCbWxnaFhadjNXZk0yWnNDdkhGT1BmL2xwOE55THYwT004QzRpbVhXVjhJbHJ2OEoyZERDeE5TZEE2L040NGVFcVNkcVNxL3A5Y3J2a3RlVE9aTjdtWmVIOWEwZFVPQms1dmZJQzhxaklHb0EwMHRMbTQ4MVczKzhpa1UzTTVXNnpOZUVVRzBEak9jZm4zeGZHOTR1ZWhmcFZUQU0zWnhIbFdZbDZJdTlBeCt0L2JtZDNRdFgxZ08wQSthc3ZaT2lPRTRjcWNlSWl3OVhCOUFmV1VSTWRVQ1VJT1FxcUxQVWVlUzVKa3l0Qk9kNDVMdTdyVTljZWl3cWpaUkZvTWlYNS9CNFRJNVVRSWhDa3hpR0hHWUxVRlRvNGE0Wk9ma0VxVU1uTnBMRXd0Q3RlWHh6Y29JTFE3V3hTeThqcWRVUmRzZkVYUXNRSHA1V0Nsc0dFNS9LemNDZ2pLbE54bEVyMjd0WndOVXdpK3RHNEMrYmZ2cm5RbVBQRVNUUkZJQU52Nlo0NTBRQ281UmhWbWVvQkhGa3FBK3FNZFFhRmxiUWl3RFhGVjhVLzVPMUNpNmZ1UjhuMmJWaEFBQUFBRWxGVGtTdVFtQ0MnKTtcbn1cblxuLkNvZGVNaXJyb3ItbGludC1tYXJrZXItbXVsdGlwbGUge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFjQUFBQUhDQU1BQUFEempLZmhBQUFBQ1ZCTVZFVUFBQUFBQUFDL3Y3OTE0a3lIQUFBQUFYUlNUbE1BUU9iWVpnQUFBQ05KUkVGVWVObzFpb0VKQUFBSXdtei9IOTBpRkZTR0pnRk1lM2dhTFowb2QrOS9BUVowQURvc2JZcmFBQUFBQUVsRlRrU3VRbUNDXCIpO1xuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiByaWdodCBib3R0b207XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG59XG4iLCJcbiRibHVlOiAgICAjMzBBMUMxO1xuJGluZGlnbzogICM2NjEwZjI7XG4kcHVycGxlOiAgIzZmNDJjMTtcbiRwaW5rOiAgICAjRDA2NTY2O1xuJHJlZDogICAgICNERDYxNjM7XG4kb3JhbmdlOiAgI0Q1NkQ1OTtcbiR5ZWxsb3c6ICAjRkVDRDNEO1xuJGdyZWVuOiAgICMzNEMzNzE7XG4kdGVhbDogICAgIzIwYzk5NztcbiRjeWFuOiAgICAjNUQ5OUJEO1xuXG4kZGFyay1jeWFuOiAjNmQ5MGEzO1xuXG4kd2hpdGU6ICAjZmZmO1xuJGxpZ2h0Z3JheTogI2U4ZThlODtcbiRiZzogI2YyZjJmMjtcbiRjb2RlLWJnOiAjZjhmOGY4O1xuJGdyYXk6ICM2NjY7XG4kY2hhcmNvYWw6ICMyQjJEMzM7XG4kYmxhY2s6ICAjMDAwO1xuJHNoYWRvdzogdHJhbnNwYXJlbnRpemUoJGJsYWNrLCAuOTUpO1xuJGRhcmstc2hhZG93OiB0cmFuc3BhcmVudGl6ZSgkYmxhY2ssIC43KTtcblxuJHJlZC1saWdodDogbGlnaHRlbigkcmVkLCAzNSUpO1xuJGN5YW4tbGlnaHQ6IGxpZ2h0ZW4oJGN5YW4sIDM4JSk7XG4keWVsbG93LWxpZ2h0OiBsaWdodGVuKCR5ZWxsb3csIDM1JSk7XG4kYmx1ZS1saWdodDogbGlnaHRlbigkYmx1ZSwgNDUlKTtcbiRncmVlbi1saWdodDogbGlnaHRlbigkZ3JlZW4sIDQ1JSk7XG4iXX0= */\n"; });
define('text!bcx-doc-base/dist/elements/code-viewer.html', ['module'], function(module) { module.exports = "<template ref=\"viewer\" class=\"code-viewer\">\n  <require from=\"codemirror/lib/codemirror.css\"></require>\n  <require from=\"codemirror/addon/display/fullscreen.css\"></require>\n  <require from=\"./code-viewer.css\"></require>\n\n  <div\n    class=\"full-screen-button ${fullScreen ? 'full-screen' : ''}\"\n    click.trigger=\"toggleFullScreen() & leftClick\"\n  >\n    <i class=\"far fa-${fullScreen ? 'compress' : 'expand'}\" aria-hidden=\"true\"></i>\n  </div>\n</template>\n"; });
define('bcx-doc-base/dist/elements/display-source',['require','exports','module','aurelia-framework','aurelia-pal'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.DisplaySource = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _desc, _value, _class, _descriptor;

var _aureliaFramework = require('aurelia-framework');

var _aureliaPal = require('aurelia-pal');

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var DisplaySource = exports.DisplaySource = (_dec = (0, _aureliaFramework.computedFrom)('source'), (_class = function () {
  function DisplaySource() {
    _classCallCheck(this, DisplaySource);

    _initDefineProp(this, 'source', _descriptor, this);

    this.fileContent = '';
    this.loading = false;
  }

  DisplaySource.prototype.bind = function bind() {
    this.reloadContent();
  };

  DisplaySource.prototype.sourceChanged = function sourceChanged() {
    this.reloadContent();
  };

  DisplaySource.prototype.reloadContent = function reloadContent() {
    var _this = this;

    this.fileContent = '';
    this.loading = true;

    _aureliaPal.PLATFORM.global.require(['text!../' + this.source], function (content) {
      _this.fileContent = content;
      _this.loading = false;
    }, function () {
      _this.fileContent = 'Failed to load ' + _this.source;
      _this.loading = false;
    });
  };

  _createClass(DisplaySource, [{
    key: 'ext',
    get: function get() {
      var idx = this.source.lastIndexOf('.');
      if (idx !== -1) return this.source.substr(idx + 1);
      return null;
    }
  }]);

  return DisplaySource;
}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'source', [_aureliaFramework.bindable], {
  enumerable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class.prototype, 'ext', [_dec], Object.getOwnPropertyDescriptor(_class.prototype, 'ext'), _class.prototype)), _class));
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVsZW1lbnRzL2Rpc3BsYXktc291cmNlLmpzIl0sIm5hbWVzIjpbIkRpc3BsYXlTb3VyY2UiLCJmaWxlQ29udGVudCIsImxvYWRpbmciLCJiaW5kIiwicmVsb2FkQ29udGVudCIsInNvdXJjZUNoYW5nZWQiLCJnbG9iYWwiLCJyZXF1aXJlIiwic291cmNlIiwiY29udGVudCIsImlkeCIsImxhc3RJbmRleE9mIiwic3Vic3RyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFYUEsYSxXQUFBQSxhLFdBNkJWLG9DQUFhLFFBQWIsQzs7Ozs7O1NBM0JEQyxXLEdBQWMsRTtTQUNkQyxPLEdBQVUsSzs7OzBCQUVWQyxJLG1CQUFPO0FBQ0wsU0FBS0MsYUFBTDtBQUNELEc7OzBCQUVEQyxhLDRCQUFnQjtBQUNkLFNBQUtELGFBQUw7QUFDRCxHOzswQkFFREEsYSw0QkFBZ0I7QUFBQTs7QUFDZCxTQUFLSCxXQUFMLEdBQW1CLEVBQW5CO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLElBQWY7O0FBRUEseUJBQVNJLE1BQVQsQ0FBZ0JDLE9BQWhCLENBQXdCLGNBQVksS0FBS0MsTUFBakIsQ0FBeEIsRUFDRSxtQkFBVztBQUNULFlBQUtQLFdBQUwsR0FBbUJRLE9BQW5CO0FBQ0EsWUFBS1AsT0FBTCxHQUFlLEtBQWY7QUFDRCxLQUpILEVBS0UsWUFBTTtBQUNKLFlBQUtELFdBQUwsR0FBbUIsb0JBQW9CLE1BQUtPLE1BQTVDO0FBQ0EsWUFBS04sT0FBTCxHQUFlLEtBQWY7QUFDRCxLQVJIO0FBVUQsRzs7Ozt3QkFHUztBQUNSLFVBQU1RLE1BQU0sS0FBS0YsTUFBTCxDQUFZRyxXQUFaLENBQXdCLEdBQXhCLENBQVo7QUFDQSxVQUFJRCxRQUFRLENBQUMsQ0FBYixFQUFnQixPQUFPLEtBQUtGLE1BQUwsQ0FBWUksTUFBWixDQUFtQkYsTUFBTSxDQUF6QixDQUFQO0FBQ2hCLGFBQU8sSUFBUDtBQUNEIiwiZmlsZSI6ImVsZW1lbnRzL2Rpc3BsYXktc291cmNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtiaW5kYWJsZSwgY29tcHV0ZWRGcm9tfSBmcm9tICdhdXJlbGlhLWZyYW1ld29yayc7XG5pbXBvcnQge1BMQVRGT1JNfSBmcm9tICdhdXJlbGlhLXBhbCc7XG5cbmV4cG9ydCBjbGFzcyBEaXNwbGF5U291cmNlIHtcbiAgQGJpbmRhYmxlIHNvdXJjZTtcbiAgZmlsZUNvbnRlbnQgPSAnJztcbiAgbG9hZGluZyA9IGZhbHNlO1xuXG4gIGJpbmQoKSB7XG4gICAgdGhpcy5yZWxvYWRDb250ZW50KCk7XG4gIH1cblxuICBzb3VyY2VDaGFuZ2VkKCkge1xuICAgIHRoaXMucmVsb2FkQ29udGVudCgpO1xuICB9XG5cbiAgcmVsb2FkQ29udGVudCgpIHtcbiAgICB0aGlzLmZpbGVDb250ZW50ID0gJyc7XG4gICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcblxuICAgIFBMQVRGT1JNLmdsb2JhbC5yZXF1aXJlKFtgdGV4dCEuLi8ke3RoaXMuc291cmNlfWBdLFxuICAgICAgY29udGVudCA9PiB7XG4gICAgICAgIHRoaXMuZmlsZUNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuZmlsZUNvbnRlbnQgPSAnRmFpbGVkIHRvIGxvYWQgJyArIHRoaXMuc291cmNlO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgQGNvbXB1dGVkRnJvbSgnc291cmNlJylcbiAgZ2V0IGV4dCgpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnNvdXJjZS5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChpZHggIT09IC0xKSByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic3RyKGlkeCArIDEpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4iXX0=

});

define('text!bcx-doc-base/dist/elements/display-source.html', ['module'], function(module) { module.exports = "<template>\n  <code-viewer value.bind=\"fileContent\" mode.bind=\"ext\"></code-viewer>\n  <div if.bind=\"loading\" class=\"bcx-overlay-spinner\">\n    <i class=\"far fa-circle-notch fa-spin fa-2x fa-fw\"></i>\n  </div>\n</template>\n"; });
define('bcx-doc-base/dist/elements/display-sources',['require','exports','module','aurelia-framework'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.DisplaySources = undefined;

var _desc, _value, _class, _descriptor;

var _aureliaFramework = require('aurelia-framework');

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

var DisplaySources = exports.DisplaySources = (_class = function () {
  function DisplaySources() {
    _classCallCheck(this, DisplaySources);

    _initDefineProp(this, 'sources', _descriptor, this);

    this.fullScreen = false;
  }

  DisplaySources.prototype.bind = function bind() {
    if (this.sources && this.sources.length) {
      this.selected = this.sources[0];
    }
  };

  return DisplaySources;
}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'sources', [_aureliaFramework.bindable], {
  enumerable: true,
  initializer: null
})), _class);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVsZW1lbnRzL2Rpc3BsYXktc291cmNlcy5qcyJdLCJuYW1lcyI6WyJEaXNwbGF5U291cmNlcyIsImZ1bGxTY3JlZW4iLCJiaW5kIiwic291cmNlcyIsImxlbmd0aCIsInNlbGVjdGVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRWFBLGMsV0FBQUEsYzs7Ozs7O1NBR1hDLFUsR0FBYSxLOzs7MkJBRWJDLEksbUJBQU87QUFDTCxRQUFJLEtBQUtDLE9BQUwsSUFBZ0IsS0FBS0EsT0FBTCxDQUFhQyxNQUFqQyxFQUF5QztBQUN2QyxXQUFLQyxRQUFMLEdBQWdCLEtBQUtGLE9BQUwsQ0FBYSxDQUFiLENBQWhCO0FBQ0Q7QUFDRixHIiwiZmlsZSI6ImVsZW1lbnRzL2Rpc3BsYXktc291cmNlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YmluZGFibGV9IGZyb20gJ2F1cmVsaWEtZnJhbWV3b3JrJztcblxuZXhwb3J0IGNsYXNzIERpc3BsYXlTb3VyY2VzIHtcbiAgQGJpbmRhYmxlIHNvdXJjZXM7XG4gIHNlbGVjdGVkO1xuICBmdWxsU2NyZWVuID0gZmFsc2U7XG5cbiAgYmluZCgpIHtcbiAgICBpZiAodGhpcy5zb3VyY2VzICYmIHRoaXMuc291cmNlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNvdXJjZXNbMF07XG4gICAgfVxuICB9XG59XG4iXX0=

});

define('text!bcx-doc-base/dist/elements/display-sources.html', ['module'], function(module) { module.exports = "<template>\n  <select class=\"bcx-select\" value.bind=\"selected\">\n    <option repeat.for=\"source of sources\" model.bind=\"source\">${source}</option>\n  </select>\n\n  <display-source class=\"display-source\" if.bind=\"selected\" source.bind=\"selected\"></display-source>\n</template>\n"; });
define('bcx-doc-base/dist/index',['require','exports','module','aurelia-pal'],function (require, exports, module) {'use strict';

exports.__esModule = true;
exports.configure = configure;

var _aureliaPal = require('aurelia-pal');

function configure(config) {
  config.globalResources([_aureliaPal.PLATFORM.moduleName('./binding-behaviors/left-click'), _aureliaPal.PLATFORM.moduleName('./elements/bcx-doc-nav'), _aureliaPal.PLATFORM.moduleName('./elements/code-viewer'), _aureliaPal.PLATFORM.moduleName('./elements/display-source'), _aureliaPal.PLATFORM.moduleName('./elements/display-sources')]);
}
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbImNvbmZpZ3VyZSIsImNvbmZpZyIsImdsb2JhbFJlc291cmNlcyIsIm1vZHVsZU5hbWUiXSwibWFwcGluZ3MiOiI7OztRQUVnQkEsUyxHQUFBQSxTOztBQUZoQjs7QUFFTyxTQUFTQSxTQUFULENBQW1CQyxNQUFuQixFQUEyQjtBQUNoQ0EsU0FBT0MsZUFBUCxDQUF1QixDQUNyQixxQkFBU0MsVUFBVCxDQUFvQixnQ0FBcEIsQ0FEcUIsRUFFckIscUJBQVNBLFVBQVQsQ0FBb0Isd0JBQXBCLENBRnFCLEVBR3JCLHFCQUFTQSxVQUFULENBQW9CLHdCQUFwQixDQUhxQixFQUlyQixxQkFBU0EsVUFBVCxDQUFvQiwyQkFBcEIsQ0FKcUIsRUFLckIscUJBQVNBLFVBQVQsQ0FBb0IsNEJBQXBCLENBTHFCLENBQXZCO0FBT0QiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1BMQVRGT1JNfSBmcm9tICdhdXJlbGlhLXBhbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25maWd1cmUoY29uZmlnKSB7XG4gIGNvbmZpZy5nbG9iYWxSZXNvdXJjZXMoW1xuICAgIFBMQVRGT1JNLm1vZHVsZU5hbWUoJy4vYmluZGluZy1iZWhhdmlvcnMvbGVmdC1jbGljaycpLFxuICAgIFBMQVRGT1JNLm1vZHVsZU5hbWUoJy4vZWxlbWVudHMvYmN4LWRvYy1uYXYnKSxcbiAgICBQTEFURk9STS5tb2R1bGVOYW1lKCcuL2VsZW1lbnRzL2NvZGUtdmlld2VyJyksXG4gICAgUExBVEZPUk0ubW9kdWxlTmFtZSgnLi9lbGVtZW50cy9kaXNwbGF5LXNvdXJjZScpLFxuICAgIFBMQVRGT1JNLm1vZHVsZU5hbWUoJy4vZWxlbWVudHMvZGlzcGxheS1zb3VyY2VzJyksXG4gIF0pO1xufVxuIl19

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/addon/display/fullscreen',["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineOption("fullScreen", false, function(cm, val, old) {
    if (old == CodeMirror.Init) old = false;
    if (!old == !val) return;
    if (val) setFullscreen(cm);
    else setNormal(cm);
  });

  function setFullscreen(cm) {
    var wrap = cm.getWrapperElement();
    cm.state.fullScreenRestore = {scrollTop: window.pageYOffset, scrollLeft: window.pageXOffset,
                                  width: wrap.style.width, height: wrap.style.height};
    wrap.style.width = "";
    wrap.style.height = "auto";
    wrap.className += " CodeMirror-fullscreen";
    document.documentElement.style.overflow = "hidden";
    cm.refresh();
  }

  function setNormal(cm) {
    var wrap = cm.getWrapperElement();
    wrap.className = wrap.className.replace(/\s*CodeMirror-fullscreen\b/, "");
    document.documentElement.style.overflow = "";
    var info = cm.state.fullScreenRestore;
    wrap.style.width = info.width; wrap.style.height = info.height;
    window.scrollTo(info.scrollLeft, info.scrollTop);
    cm.refresh();
  }
});

define('text!codemirror/addon/display/fullscreen.css', ['module'], function(module) { module.exports = ".CodeMirror-fullscreen {\n  position: fixed;\n  top: 0; left: 0; right: 0; bottom: 0;\n  height: auto;\n  z-index: 9;\n}\n"; });
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/addon/lint/lint',["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  var GUTTER_ID = "CodeMirror-lint-markers";

  function showTooltip(e, content) {
    var tt = document.createElement("div");
    tt.className = "CodeMirror-lint-tooltip";
    tt.appendChild(content.cloneNode(true));
    document.body.appendChild(tt);

    function position(e) {
      if (!tt.parentNode) return CodeMirror.off(document, "mousemove", position);
      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + "px";
      tt.style.left = (e.clientX + 5) + "px";
    }
    CodeMirror.on(document, "mousemove", position);
    position(e);
    if (tt.style.opacity != null) tt.style.opacity = 1;
    return tt;
  }
  function rm(elt) {
    if (elt.parentNode) elt.parentNode.removeChild(elt);
  }
  function hideTooltip(tt) {
    if (!tt.parentNode) return;
    if (tt.style.opacity == null) rm(tt);
    tt.style.opacity = 0;
    setTimeout(function() { rm(tt); }, 600);
  }

  function showTooltipFor(e, content, node) {
    var tooltip = showTooltip(e, content);
    function hide() {
      CodeMirror.off(node, "mouseout", hide);
      if (tooltip) { hideTooltip(tooltip); tooltip = null; }
    }
    var poll = setInterval(function() {
      if (tooltip) for (var n = node;; n = n.parentNode) {
        if (n && n.nodeType == 11) n = n.host;
        if (n == document.body) return;
        if (!n) { hide(); break; }
      }
      if (!tooltip) return clearInterval(poll);
    }, 400);
    CodeMirror.on(node, "mouseout", hide);
  }

  function LintState(cm, options, hasGutter) {
    this.marked = [];
    this.options = options;
    this.timeout = null;
    this.hasGutter = hasGutter;
    this.onMouseOver = function(e) { onMouseOver(cm, e); };
    this.waitingFor = 0
  }

  function parseOptions(_cm, options) {
    if (options instanceof Function) return {getAnnotations: options};
    if (!options || options === true) options = {};
    return options;
  }

  function clearMarks(cm) {
    var state = cm.state.lint;
    if (state.hasGutter) cm.clearGutter(GUTTER_ID);
    for (var i = 0; i < state.marked.length; ++i)
      state.marked[i].clear();
    state.marked.length = 0;
  }

  function makeMarker(labels, severity, multiple, tooltips) {
    var marker = document.createElement("div"), inner = marker;
    marker.className = "CodeMirror-lint-marker-" + severity;
    if (multiple) {
      inner = marker.appendChild(document.createElement("div"));
      inner.className = "CodeMirror-lint-marker-multiple";
    }

    if (tooltips != false) CodeMirror.on(inner, "mouseover", function(e) {
      showTooltipFor(e, labels, inner);
    });

    return marker;
  }

  function getMaxSeverity(a, b) {
    if (a == "error") return a;
    else return b;
  }

  function groupByLine(annotations) {
    var lines = [];
    for (var i = 0; i < annotations.length; ++i) {
      var ann = annotations[i], line = ann.from.line;
      (lines[line] || (lines[line] = [])).push(ann);
    }
    return lines;
  }

  function annotationTooltip(ann) {
    var severity = ann.severity;
    if (!severity) severity = "error";
    var tip = document.createElement("div");
    tip.className = "CodeMirror-lint-message-" + severity;
    if (typeof ann.messageHTML != 'undefined') {
        tip.innerHTML = ann.messageHTML;
    } else {
        tip.appendChild(document.createTextNode(ann.message));
    }
    return tip;
  }

  function lintAsync(cm, getAnnotations, passOptions) {
    var state = cm.state.lint
    var id = ++state.waitingFor
    function abort() {
      id = -1
      cm.off("change", abort)
    }
    cm.on("change", abort)
    getAnnotations(cm.getValue(), function(annotations, arg2) {
      cm.off("change", abort)
      if (state.waitingFor != id) return
      if (arg2 && annotations instanceof CodeMirror) annotations = arg2
      cm.operation(function() {updateLinting(cm, annotations)})
    }, passOptions, cm);
  }

  function startLinting(cm) {
    var state = cm.state.lint, options = state.options;
    /*
     * Passing rules in `options` property prevents JSHint (and other linters) from complaining
     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.
     */
    var passOptions = options.options || options;
    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), "lint");
    if (!getAnnotations) return;
    if (options.async || getAnnotations.async) {
      lintAsync(cm, getAnnotations, passOptions)
    } else {
      var annotations = getAnnotations(cm.getValue(), passOptions, cm);
      if (!annotations) return;
      if (annotations.then) annotations.then(function(issues) {
        cm.operation(function() {updateLinting(cm, issues)})
      });
      else cm.operation(function() {updateLinting(cm, annotations)})
    }
  }

  function updateLinting(cm, annotationsNotSorted) {
    clearMarks(cm);
    var state = cm.state.lint, options = state.options;

    var annotations = groupByLine(annotationsNotSorted);

    for (var line = 0; line < annotations.length; ++line) {
      var anns = annotations[line];
      if (!anns) continue;

      var maxSeverity = null;
      var tipLabel = state.hasGutter && document.createDocumentFragment();

      for (var i = 0; i < anns.length; ++i) {
        var ann = anns[i];
        var severity = ann.severity;
        if (!severity) severity = "error";
        maxSeverity = getMaxSeverity(maxSeverity, severity);

        if (options.formatAnnotation) ann = options.formatAnnotation(ann);
        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));

        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {
          className: "CodeMirror-lint-mark-" + severity,
          __annotation: ann
        }));
      }

      if (state.hasGutter)
        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,
                                                       state.options.tooltips));
    }
    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);
  }

  function onChange(cm) {
    var state = cm.state.lint;
    if (!state) return;
    clearTimeout(state.timeout);
    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);
  }

  function popupTooltips(annotations, e) {
    var target = e.target || e.srcElement;
    var tooltip = document.createDocumentFragment();
    for (var i = 0; i < annotations.length; i++) {
      var ann = annotations[i];
      tooltip.appendChild(annotationTooltip(ann));
    }
    showTooltipFor(e, tooltip, target);
  }

  function onMouseOver(cm, e) {
    var target = e.target || e.srcElement;
    if (!/\bCodeMirror-lint-mark-/.test(target.className)) return;
    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;
    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, "client"));

    var annotations = [];
    for (var i = 0; i < spans.length; ++i) {
      var ann = spans[i].__annotation;
      if (ann) annotations.push(ann);
    }
    if (annotations.length) popupTooltips(annotations, e);
  }

  CodeMirror.defineOption("lint", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      clearMarks(cm);
      if (cm.state.lint.options.lintOnChange !== false)
        cm.off("change", onChange);
      CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
      clearTimeout(cm.state.lint.timeout);
      delete cm.state.lint;
    }

    if (val) {
      var gutters = cm.getOption("gutters"), hasLintGutter = false;
      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;
      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);
      if (state.options.lintOnChange !== false)
        cm.on("change", onChange);
      if (state.options.tooltips != false && state.options.tooltips != "gutter")
        CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);

      startLinting(cm);
    }
  });

  CodeMirror.defineExtension("performLint", function() {
    if (this.state.lint) startLinting(this);
  });
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/addon/selection/active-line',["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  var WRAP_CLASS = "CodeMirror-activeline";
  var BACK_CLASS = "CodeMirror-activeline-background";
  var GUTT_CLASS = "CodeMirror-activeline-gutter";

  CodeMirror.defineOption("styleActiveLine", false, function(cm, val, old) {
    var prev = old == CodeMirror.Init ? false : old;
    if (val == prev) return
    if (prev) {
      cm.off("beforeSelectionChange", selectionChange);
      clearActiveLines(cm);
      delete cm.state.activeLines;
    }
    if (val) {
      cm.state.activeLines = [];
      updateActiveLines(cm, cm.listSelections());
      cm.on("beforeSelectionChange", selectionChange);
    }
  });

  function clearActiveLines(cm) {
    for (var i = 0; i < cm.state.activeLines.length; i++) {
      cm.removeLineClass(cm.state.activeLines[i], "wrap", WRAP_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "background", BACK_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "gutter", GUTT_CLASS);
    }
  }

  function sameArray(a, b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++)
      if (a[i] != b[i]) return false;
    return true;
  }

  function updateActiveLines(cm, ranges) {
    var active = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      var option = cm.getOption("styleActiveLine");
      if (typeof option == "object" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())
        continue
      var line = cm.getLineHandleVisualStart(range.head.line);
      if (active[active.length - 1] != line) active.push(line);
    }
    if (sameArray(cm.state.activeLines, active)) return;
    cm.operation(function() {
      clearActiveLines(cm);
      for (var i = 0; i < active.length; i++) {
        cm.addLineClass(active[i], "wrap", WRAP_CLASS);
        cm.addLineClass(active[i], "background", BACK_CLASS);
        cm.addLineClass(active[i], "gutter", GUTT_CLASS);
      }
      cm.state.activeLines = active;
    });
  }

  function selectionChange(cm, sel) {
    updateActiveLines(cm, sel.ranges);
  }
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define('codemirror/lib/codemirror',factory) :
	(global.CodeMirror = factory());
}(this, (function () { 'use strict';

// Kludges for bugs and behavior differences that can't be feature
// detected are enabled based on userAgent etc sniffing.
var userAgent = navigator.userAgent;
var platform = navigator.platform;

var gecko = /gecko\/\d/i.test(userAgent);
var ie_upto10 = /MSIE \d/.test(userAgent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
var edge = /Edge\/(\d+)/.exec(userAgent);
var ie = ie_upto10 || ie_11up || edge;
var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
var webkit = !edge && /WebKit\//.test(userAgent);
var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
var chrome = !edge && /Chrome\//.test(userAgent);
var presto = /Opera\//.test(userAgent);
var safari = /Apple Computer/.test(navigator.vendor);
var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
var phantom = /PhantomJS/.test(userAgent);

var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
var android = /Android/.test(userAgent);
// This is woefully incomplete. Suggestions for alternative methods welcome.
var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
var mac = ios || /Mac/.test(platform);
var chromeOS = /\bCrOS\b/.test(userAgent);
var windows = /win/i.test(platform);

var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
if (presto_version) { presto_version = Number(presto_version[1]); }
if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
// Some browsers use the wrong event properties to signal cmd/ctrl on OS X
var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
var captureRightClick = gecko || (ie && ie_version >= 9);

function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

var rmClass = function(node, cls) {
  var current = node.className;
  var match = classTest(cls).exec(current);
  if (match) {
    var after = current.slice(match.index + match[0].length);
    node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
  }
};

function removeChildren(e) {
  for (var count = e.childNodes.length; count > 0; --count)
    { e.removeChild(e.firstChild); }
  return e
}

function removeChildrenAndAdd(parent, e) {
  return removeChildren(parent).appendChild(e)
}

function elt(tag, content, className, style) {
  var e = document.createElement(tag);
  if (className) { e.className = className; }
  if (style) { e.style.cssText = style; }
  if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
  return e
}
// wrapper for elt, which removes the elt from the accessibility tree
function eltP(tag, content, className, style) {
  var e = elt(tag, content, className, style);
  e.setAttribute("role", "presentation");
  return e
}

var range;
if (document.createRange) { range = function(node, start, end, endNode) {
  var r = document.createRange();
  r.setEnd(endNode || node, end);
  r.setStart(node, start);
  return r
}; }
else { range = function(node, start, end) {
  var r = document.body.createTextRange();
  try { r.moveToElementText(node.parentNode); }
  catch(e) { return r }
  r.collapse(true);
  r.moveEnd("character", end);
  r.moveStart("character", start);
  return r
}; }

function contains(parent, child) {
  if (child.nodeType == 3) // Android browser always returns false when child is a textnode
    { child = child.parentNode; }
  if (parent.contains)
    { return parent.contains(child) }
  do {
    if (child.nodeType == 11) { child = child.host; }
    if (child == parent) { return true }
  } while (child = child.parentNode)
}

function activeElt() {
  // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
  // IE < 10 will throw when accessed while the page is loading or in an iframe.
  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
  var activeElement;
  try {
    activeElement = document.activeElement;
  } catch(e) {
    activeElement = document.body || null;
  }
  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
    { activeElement = activeElement.shadowRoot.activeElement; }
  return activeElement
}

function addClass(node, cls) {
  var current = node.className;
  if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
}
function joinClasses(a, b) {
  var as = a.split(" ");
  for (var i = 0; i < as.length; i++)
    { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
  return b
}

var selectInput = function(node) { node.select(); };
if (ios) // Mobile Safari apparently has a bug where select() is broken.
  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
else if (ie) // Suppress mysterious IE10 errors
  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

function bind(f) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function(){return f.apply(null, args)}
}

function copyObj(obj, target, overwrite) {
  if (!target) { target = {}; }
  for (var prop in obj)
    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
      { target[prop] = obj[prop]; } }
  return target
}

// Counts the column offset in a string, taking tabs into account.
// Used mostly to find indentation.
function countColumn(string, end, tabSize, startIndex, startValue) {
  if (end == null) {
    end = string.search(/[^\s\u00a0]/);
    if (end == -1) { end = string.length; }
  }
  for (var i = startIndex || 0, n = startValue || 0;;) {
    var nextTab = string.indexOf("\t", i);
    if (nextTab < 0 || nextTab >= end)
      { return n + (end - i) }
    n += nextTab - i;
    n += tabSize - (n % tabSize);
    i = nextTab + 1;
  }
}

var Delayed = function() {this.id = null;};
Delayed.prototype.set = function (ms, f) {
  clearTimeout(this.id);
  this.id = setTimeout(f, ms);
};

function indexOf(array, elt) {
  for (var i = 0; i < array.length; ++i)
    { if (array[i] == elt) { return i } }
  return -1
}

// Number of pixels added to scroller and sizer to hide scrollbar
var scrollerGap = 30;

// Returned or thrown by various protocols to signal 'I'm not
// handling this'.
var Pass = {toString: function(){return "CodeMirror.Pass"}};

// Reused option objects for setSelection & friends
var sel_dontScroll = {scroll: false};
var sel_mouse = {origin: "*mouse"};
var sel_move = {origin: "+move"};

// The inverse of countColumn -- find the offset that corresponds to
// a particular column.
function findColumn(string, goal, tabSize) {
  for (var pos = 0, col = 0;;) {
    var nextTab = string.indexOf("\t", pos);
    if (nextTab == -1) { nextTab = string.length; }
    var skipped = nextTab - pos;
    if (nextTab == string.length || col + skipped >= goal)
      { return pos + Math.min(skipped, goal - col) }
    col += nextTab - pos;
    col += tabSize - (col % tabSize);
    pos = nextTab + 1;
    if (col >= goal) { return pos }
  }
}

var spaceStrs = [""];
function spaceStr(n) {
  while (spaceStrs.length <= n)
    { spaceStrs.push(lst(spaceStrs) + " "); }
  return spaceStrs[n]
}

function lst(arr) { return arr[arr.length-1] }

function map(array, f) {
  var out = [];
  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
  return out
}

function insertSorted(array, value, score) {
  var pos = 0, priority = score(value);
  while (pos < array.length && score(array[pos]) <= priority) { pos++; }
  array.splice(pos, 0, value);
}

function nothing() {}

function createObj(base, props) {
  var inst;
  if (Object.create) {
    inst = Object.create(base);
  } else {
    nothing.prototype = base;
    inst = new nothing();
  }
  if (props) { copyObj(props, inst); }
  return inst
}

var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
function isWordCharBasic(ch) {
  return /\w/.test(ch) || ch > "\x80" &&
    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
}
function isWordChar(ch, helper) {
  if (!helper) { return isWordCharBasic(ch) }
  if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
  return helper.test(ch)
}

function isEmpty(obj) {
  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
  return true
}

// Extending unicode characters. A series of a non-extending char +
// any number of extending chars is treated as a single unit as far
// as editing and measuring is concerned. This is not fully correct,
// since some scripts/fonts/browsers also treat other configurations
// of code points as a group.
var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
function skipExtendingChars(str, pos, dir) {
  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
  return pos
}

// Returns the value from the range [`from`; `to`] that satisfies
// `pred` and is closest to `from`. Assumes that at least `to`
// satisfies `pred`. Supports `from` being greater than `to`.
function findFirst(pred, from, to) {
  // At any point we are certain `to` satisfies `pred`, don't know
  // whether `from` does.
  var dir = from > to ? -1 : 1;
  for (;;) {
    if (from == to) { return from }
    var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
    if (mid == from) { return pred(mid) ? from : to }
    if (pred(mid)) { to = mid; }
    else { from = mid + dir; }
  }
}

// The display handles the DOM integration, both for input reading
// and content drawing. It holds references to DOM nodes and
// display-related state.

function Display(place, doc, input) {
  var d = this;
  this.input = input;

  // Covers bottom-right square when both scrollbars are present.
  d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
  d.scrollbarFiller.setAttribute("cm-not-content", "true");
  // Covers bottom of gutter when coverGutterNextToScrollbar is on
  // and h scrollbar is present.
  d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
  d.gutterFiller.setAttribute("cm-not-content", "true");
  // Will contain the actual code, positioned to cover the viewport.
  d.lineDiv = eltP("div", null, "CodeMirror-code");
  // Elements are added to these to represent selection and cursors.
  d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
  d.cursorDiv = elt("div", null, "CodeMirror-cursors");
  // A visibility: hidden element used to find the size of things.
  d.measure = elt("div", null, "CodeMirror-measure");
  // When lines outside of the viewport are measured, they are drawn in this.
  d.lineMeasure = elt("div", null, "CodeMirror-measure");
  // Wraps everything that needs to exist inside the vertically-padded coordinate system
  d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                    null, "position: relative; outline: none");
  var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
  // Moved around its parent to cover visible view.
  d.mover = elt("div", [lines], null, "position: relative");
  // Set to the height of the document, allowing scrolling.
  d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
  d.sizerWidth = null;
  // Behavior of elts with overflow: auto and padding is
  // inconsistent across browsers. This is used to ensure the
  // scrollable area is big enough.
  d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
  // Will contain the gutters, if any.
  d.gutters = elt("div", null, "CodeMirror-gutters");
  d.lineGutter = null;
  // Actual scrollable element.
  d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
  d.scroller.setAttribute("tabIndex", "-1");
  // The element in which the editor lives.
  d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

  if (place) {
    if (place.appendChild) { place.appendChild(d.wrapper); }
    else { place(d.wrapper); }
  }

  // Current rendered range (may be bigger than the view window).
  d.viewFrom = d.viewTo = doc.first;
  d.reportedViewFrom = d.reportedViewTo = doc.first;
  // Information about the rendered lines.
  d.view = [];
  d.renderedView = null;
  // Holds info about a single rendered line when it was rendered
  // for measurement, while not in view.
  d.externalMeasured = null;
  // Empty space (in pixels) above the view
  d.viewOffset = 0;
  d.lastWrapHeight = d.lastWrapWidth = 0;
  d.updateLineNumbers = null;

  d.nativeBarWidth = d.barHeight = d.barWidth = 0;
  d.scrollbarsClipped = false;

  // Used to only resize the line number gutter when necessary (when
  // the amount of lines crosses a boundary that makes its width change)
  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
  // Set to true when a non-horizontal-scrolling line widget is
  // added. As an optimization, line widget aligning is skipped when
  // this is false.
  d.alignWidgets = false;

  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

  // Tracks the maximum line length so that the horizontal scrollbar
  // can be kept static when scrolling.
  d.maxLine = null;
  d.maxLineLength = 0;
  d.maxLineChanged = false;

  // Used for measuring wheel scrolling granularity
  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

  // True when shift is held down.
  d.shift = false;

  // Used to track whether anything happened since the context menu
  // was opened.
  d.selForContextMenu = null;

  d.activeTouch = null;

  input.init(d);
}

// Find the line object corresponding to the given line number.
function getLine(doc, n) {
  n -= doc.first;
  if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
  var chunk = doc;
  while (!chunk.lines) {
    for (var i = 0;; ++i) {
      var child = chunk.children[i], sz = child.chunkSize();
      if (n < sz) { chunk = child; break }
      n -= sz;
    }
  }
  return chunk.lines[n]
}

// Get the part of a document between two positions, as an array of
// strings.
function getBetween(doc, start, end) {
  var out = [], n = start.line;
  doc.iter(start.line, end.line + 1, function (line) {
    var text = line.text;
    if (n == end.line) { text = text.slice(0, end.ch); }
    if (n == start.line) { text = text.slice(start.ch); }
    out.push(text);
    ++n;
  });
  return out
}
// Get the lines between from and to, as array of strings.
function getLines(doc, from, to) {
  var out = [];
  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
  return out
}

// Update the height of a line, propagating the height change
// upwards to parent nodes.
function updateLineHeight(line, height) {
  var diff = height - line.height;
  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
}

// Given a line object, find its line number by walking up through
// its parent links.
function lineNo(line) {
  if (line.parent == null) { return null }
  var cur = line.parent, no = indexOf(cur.lines, line);
  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
    for (var i = 0;; ++i) {
      if (chunk.children[i] == cur) { break }
      no += chunk.children[i].chunkSize();
    }
  }
  return no + cur.first
}

// Find the line at the given vertical position, using the height
// information in the document tree.
function lineAtHeight(chunk, h) {
  var n = chunk.first;
  outer: do {
    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
      var child = chunk.children[i$1], ch = child.height;
      if (h < ch) { chunk = child; continue outer }
      h -= ch;
      n += child.chunkSize();
    }
    return n
  } while (!chunk.lines)
  var i = 0;
  for (; i < chunk.lines.length; ++i) {
    var line = chunk.lines[i], lh = line.height;
    if (h < lh) { break }
    h -= lh;
  }
  return n + i
}

function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

function lineNumberFor(options, i) {
  return String(options.lineNumberFormatter(i + options.firstLineNumber))
}

// A Pos instance represents a position within the text.
function Pos(line, ch, sticky) {
  if ( sticky === void 0 ) sticky = null;

  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
  this.line = line;
  this.ch = ch;
  this.sticky = sticky;
}

// Compare two positions, return 0 if they are the same, a negative
// number when a is less, and a positive number otherwise.
function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

function copyPos(x) {return Pos(x.line, x.ch)}
function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

// Most of the external API clips given positions to make sure they
// actually exist within the document.
function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
function clipPos(doc, pos) {
  if (pos.line < doc.first) { return Pos(doc.first, 0) }
  var last = doc.first + doc.size - 1;
  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
  return clipToLen(pos, getLine(doc, pos.line).text.length)
}
function clipToLen(pos, linelen) {
  var ch = pos.ch;
  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
  else if (ch < 0) { return Pos(pos.line, 0) }
  else { return pos }
}
function clipPosArray(doc, array) {
  var out = [];
  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
  return out
}

// Optimize some code when these features are not used.
var sawReadOnlySpans = false;
var sawCollapsedSpans = false;

function seeReadOnlySpans() {
  sawReadOnlySpans = true;
}

function seeCollapsedSpans() {
  sawCollapsedSpans = true;
}

// TEXTMARKER SPANS

function MarkedSpan(marker, from, to) {
  this.marker = marker;
  this.from = from; this.to = to;
}

// Search an array of spans for a span matching the given marker.
function getMarkedSpanFor(spans, marker) {
  if (spans) { for (var i = 0; i < spans.length; ++i) {
    var span = spans[i];
    if (span.marker == marker) { return span }
  } }
}
// Remove a span from an array, returning undefined if no spans are
// left (we don't store arrays for lines without spans).
function removeMarkedSpan(spans, span) {
  var r;
  for (var i = 0; i < spans.length; ++i)
    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
  return r
}
// Add a span to a line.
function addMarkedSpan(line, span) {
  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
  span.marker.attachLine(line);
}

// Used for the algorithm that adjusts markers for a change in the
// document. These functions cut an array of spans at a given
// character position, returning an array of remaining chunks (or
// undefined if nothing remains).
function markedSpansBefore(old, startCh, isInsert) {
  var nw;
  if (old) { for (var i = 0; i < old.length; ++i) {
    var span = old[i], marker = span.marker;
    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
    if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
    }
  } }
  return nw
}
function markedSpansAfter(old, endCh, isInsert) {
  var nw;
  if (old) { for (var i = 0; i < old.length; ++i) {
    var span = old[i], marker = span.marker;
    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
    if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                            span.to == null ? null : span.to - endCh));
    }
  } }
  return nw
}

// Given a change object, compute the new set of marker spans that
// cover the line in which the change took place. Removes spans
// entirely within the change, reconnects spans belonging to the
// same marker that appear on both sides of the change, and cuts off
// spans partially within the change. Returns an array of span
// arrays with one element for each line in (after) the change.
function stretchSpansOverChange(doc, change) {
  if (change.full) { return null }
  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
  if (!oldFirst && !oldLast) { return null }

  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
  // Get the spans that 'stick out' on both sides
  var first = markedSpansBefore(oldFirst, startCh, isInsert);
  var last = markedSpansAfter(oldLast, endCh, isInsert);

  // Next, merge those two ends
  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
  if (first) {
    // Fix up .to properties of first
    for (var i = 0; i < first.length; ++i) {
      var span = first[i];
      if (span.to == null) {
        var found = getMarkedSpanFor(last, span.marker);
        if (!found) { span.to = startCh; }
        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
      }
    }
  }
  if (last) {
    // Fix up .from in last (or move them into first in case of sameLine)
    for (var i$1 = 0; i$1 < last.length; ++i$1) {
      var span$1 = last[i$1];
      if (span$1.to != null) { span$1.to += offset; }
      if (span$1.from == null) {
        var found$1 = getMarkedSpanFor(first, span$1.marker);
        if (!found$1) {
          span$1.from = offset;
          if (sameLine) { (first || (first = [])).push(span$1); }
        }
      } else {
        span$1.from += offset;
        if (sameLine) { (first || (first = [])).push(span$1); }
      }
    }
  }
  // Make sure we didn't create any zero-length spans
  if (first) { first = clearEmptySpans(first); }
  if (last && last != first) { last = clearEmptySpans(last); }

  var newMarkers = [first];
  if (!sameLine) {
    // Fill gap with whole-line-spans
    var gap = change.text.length - 2, gapMarkers;
    if (gap > 0 && first)
      { for (var i$2 = 0; i$2 < first.length; ++i$2)
        { if (first[i$2].to == null)
          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
    for (var i$3 = 0; i$3 < gap; ++i$3)
      { newMarkers.push(gapMarkers); }
    newMarkers.push(last);
  }
  return newMarkers
}

// Remove spans that are empty and don't have a clearWhenEmpty
// option of false.
function clearEmptySpans(spans) {
  for (var i = 0; i < spans.length; ++i) {
    var span = spans[i];
    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
      { spans.splice(i--, 1); }
  }
  if (!spans.length) { return null }
  return spans
}

// Used to 'clip' out readOnly ranges when making a change.
function removeReadOnlyRanges(doc, from, to) {
  var markers = null;
  doc.iter(from.line, to.line + 1, function (line) {
    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
      var mark = line.markedSpans[i].marker;
      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
        { (markers || (markers = [])).push(mark); }
    } }
  });
  if (!markers) { return null }
  var parts = [{from: from, to: to}];
  for (var i = 0; i < markers.length; ++i) {
    var mk = markers[i], m = mk.find(0);
    for (var j = 0; j < parts.length; ++j) {
      var p = parts[j];
      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
        { newParts.push({from: p.from, to: m.from}); }
      if (dto > 0 || !mk.inclusiveRight && !dto)
        { newParts.push({from: m.to, to: p.to}); }
      parts.splice.apply(parts, newParts);
      j += newParts.length - 3;
    }
  }
  return parts
}

// Connect or disconnect spans from a line.
function detachMarkedSpans(line) {
  var spans = line.markedSpans;
  if (!spans) { return }
  for (var i = 0; i < spans.length; ++i)
    { spans[i].marker.detachLine(line); }
  line.markedSpans = null;
}
function attachMarkedSpans(line, spans) {
  if (!spans) { return }
  for (var i = 0; i < spans.length; ++i)
    { spans[i].marker.attachLine(line); }
  line.markedSpans = spans;
}

// Helpers used when computing which overlapping collapsed span
// counts as the larger one.
function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

// Returns a number indicating which of two overlapping collapsed
// spans is larger (and thus includes the other). Falls back to
// comparing ids when the spans cover exactly the same range.
function compareCollapsedMarkers(a, b) {
  var lenDiff = a.lines.length - b.lines.length;
  if (lenDiff != 0) { return lenDiff }
  var aPos = a.find(), bPos = b.find();
  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
  if (fromCmp) { return -fromCmp }
  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
  if (toCmp) { return toCmp }
  return b.id - a.id
}

// Find out whether a line ends or starts in a collapsed span. If
// so, return the marker for that span.
function collapsedSpanAtSide(line, start) {
  var sps = sawCollapsedSpans && line.markedSpans, found;
  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
    sp = sps[i];
    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
        (!found || compareCollapsedMarkers(found, sp.marker) < 0))
      { found = sp.marker; }
  } }
  return found
}
function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

// Test whether there exists a collapsed span that partially
// overlaps (covers the start or end, but not both) of a new span.
// Such overlap is not allowed.
function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
  var line = getLine(doc, lineNo$$1);
  var sps = sawCollapsedSpans && line.markedSpans;
  if (sps) { for (var i = 0; i < sps.length; ++i) {
    var sp = sps[i];
    if (!sp.marker.collapsed) { continue }
    var found = sp.marker.find(0);
    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
      { return true }
  } }
}

// A visual line is a line as drawn on the screen. Folding, for
// example, can cause multiple logical lines to appear on the same
// visual line. This finds the start of the visual line that the
// given line is part of (usually that is the line itself).
function visualLine(line) {
  var merged;
  while (merged = collapsedSpanAtStart(line))
    { line = merged.find(-1, true).line; }
  return line
}

function visualLineEnd(line) {
  var merged;
  while (merged = collapsedSpanAtEnd(line))
    { line = merged.find(1, true).line; }
  return line
}

// Returns an array of logical lines that continue the visual line
// started by the argument, or undefined if there are no such lines.
function visualLineContinued(line) {
  var merged, lines;
  while (merged = collapsedSpanAtEnd(line)) {
    line = merged.find(1, true).line
    ;(lines || (lines = [])).push(line);
  }
  return lines
}

// Get the line number of the start of the visual line that the
// given line number is part of.
function visualLineNo(doc, lineN) {
  var line = getLine(doc, lineN), vis = visualLine(line);
  if (line == vis) { return lineN }
  return lineNo(vis)
}

// Get the line number of the start of the next visual line after
// the given line.
function visualLineEndNo(doc, lineN) {
  if (lineN > doc.lastLine()) { return lineN }
  var line = getLine(doc, lineN), merged;
  if (!lineIsHidden(doc, line)) { return lineN }
  while (merged = collapsedSpanAtEnd(line))
    { line = merged.find(1, true).line; }
  return lineNo(line) + 1
}

// Compute whether a line is hidden. Lines count as hidden when they
// are part of a visual line that starts with another line, or when
// they are entirely covered by collapsed, non-widget span.
function lineIsHidden(doc, line) {
  var sps = sawCollapsedSpans && line.markedSpans;
  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
    sp = sps[i];
    if (!sp.marker.collapsed) { continue }
    if (sp.from == null) { return true }
    if (sp.marker.widgetNode) { continue }
    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
      { return true }
  } }
}
function lineIsHiddenInner(doc, line, span) {
  if (span.to == null) {
    var end = span.marker.find(1, true);
    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
  }
  if (span.marker.inclusiveRight && span.to == line.text.length)
    { return true }
  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
    sp = line.markedSpans[i];
    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
        (sp.to == null || sp.to != span.from) &&
        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
        lineIsHiddenInner(doc, line, sp)) { return true }
  }
}

// Find the height above the given line.
function heightAtLine(lineObj) {
  lineObj = visualLine(lineObj);

  var h = 0, chunk = lineObj.parent;
  for (var i = 0; i < chunk.lines.length; ++i) {
    var line = chunk.lines[i];
    if (line == lineObj) { break }
    else { h += line.height; }
  }
  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
      var cur = p.children[i$1];
      if (cur == chunk) { break }
      else { h += cur.height; }
    }
  }
  return h
}

// Compute the character length of a line, taking into account
// collapsed ranges (see markText) that might hide parts, and join
// other lines onto it.
function lineLength(line) {
  if (line.height == 0) { return 0 }
  var len = line.text.length, merged, cur = line;
  while (merged = collapsedSpanAtStart(cur)) {
    var found = merged.find(0, true);
    cur = found.from.line;
    len += found.from.ch - found.to.ch;
  }
  cur = line;
  while (merged = collapsedSpanAtEnd(cur)) {
    var found$1 = merged.find(0, true);
    len -= cur.text.length - found$1.from.ch;
    cur = found$1.to.line;
    len += cur.text.length - found$1.to.ch;
  }
  return len
}

// Find the longest line in the document.
function findMaxLine(cm) {
  var d = cm.display, doc = cm.doc;
  d.maxLine = getLine(doc, doc.first);
  d.maxLineLength = lineLength(d.maxLine);
  d.maxLineChanged = true;
  doc.iter(function (line) {
    var len = lineLength(line);
    if (len > d.maxLineLength) {
      d.maxLineLength = len;
      d.maxLine = line;
    }
  });
}

// BIDI HELPERS

function iterateBidiSections(order, from, to, f) {
  if (!order) { return f(from, to, "ltr", 0) }
  var found = false;
  for (var i = 0; i < order.length; ++i) {
    var part = order[i];
    if (part.from < to && part.to > from || from == to && part.to == from) {
      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
      found = true;
    }
  }
  if (!found) { f(from, to, "ltr"); }
}

var bidiOther = null;
function getBidiPartAt(order, ch, sticky) {
  var found;
  bidiOther = null;
  for (var i = 0; i < order.length; ++i) {
    var cur = order[i];
    if (cur.from < ch && cur.to > ch) { return i }
    if (cur.to == ch) {
      if (cur.from != cur.to && sticky == "before") { found = i; }
      else { bidiOther = i; }
    }
    if (cur.from == ch) {
      if (cur.from != cur.to && sticky != "before") { found = i; }
      else { bidiOther = i; }
    }
  }
  return found != null ? found : bidiOther
}

// Bidirectional ordering algorithm
// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
// that this (partially) implements.

// One-char codes used for character types:
// L (L):   Left-to-Right
// R (R):   Right-to-Left
// r (AL):  Right-to-Left Arabic
// 1 (EN):  European Number
// + (ES):  European Number Separator
// % (ET):  European Number Terminator
// n (AN):  Arabic Number
// , (CS):  Common Number Separator
// m (NSM): Non-Spacing Mark
// b (BN):  Boundary Neutral
// s (B):   Paragraph Separator
// t (S):   Segment Separator
// w (WS):  Whitespace
// N (ON):  Other Neutrals

// Returns null if characters are ordered as they appear
// (left-to-right), or an array of sections ({from, to, level}
// objects) in the order in which they occur visually.
var bidiOrdering = (function() {
  // Character types for codepoints 0 to 0xff
  var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
  // Character types for codepoints 0x600 to 0x6f9
  var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
  function charType(code) {
    if (code <= 0xf7) { return lowTypes.charAt(code) }
    else if (0x590 <= code && code <= 0x5f4) { return "R" }
    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
    else if (0x6ee <= code && code <= 0x8ac) { return "r" }
    else if (0x2000 <= code && code <= 0x200b) { return "w" }
    else if (code == 0x200c) { return "b" }
    else { return "L" }
  }

  var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

  function BidiSpan(level, from, to) {
    this.level = level;
    this.from = from; this.to = to;
  }

  return function(str, direction) {
    var outerType = direction == "ltr" ? "L" : "R";

    if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
    var len = str.length, types = [];
    for (var i = 0; i < len; ++i)
      { types.push(charType(str.charCodeAt(i))); }

    // W1. Examine each non-spacing mark (NSM) in the level run, and
    // change the type of the NSM to the type of the previous
    // character. If the NSM is at the start of the level run, it will
    // get the type of sor.
    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
      var type = types[i$1];
      if (type == "m") { types[i$1] = prev; }
      else { prev = type; }
    }

    // W2. Search backwards from each instance of a European number
    // until the first strong type (R, L, AL, or sor) is found. If an
    // AL is found, change the type of the European number to Arabic
    // number.
    // W3. Change all ALs to R.
    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
      var type$1 = types[i$2];
      if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
    }

    // W4. A single European separator between two European numbers
    // changes to a European number. A single common separator between
    // two numbers of the same type changes to that type.
    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
      var type$2 = types[i$3];
      if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
      else if (type$2 == "," && prev$1 == types[i$3+1] &&
               (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
      prev$1 = type$2;
    }

    // W5. A sequence of European terminators adjacent to European
    // numbers changes to all European numbers.
    // W6. Otherwise, separators and terminators change to Other
    // Neutral.
    for (var i$4 = 0; i$4 < len; ++i$4) {
      var type$3 = types[i$4];
      if (type$3 == ",") { types[i$4] = "N"; }
      else if (type$3 == "%") {
        var end = (void 0);
        for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
        var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
        for (var j = i$4; j < end; ++j) { types[j] = replace; }
        i$4 = end - 1;
      }
    }

    // W7. Search backwards from each instance of a European number
    // until the first strong type (R, L, or sor) is found. If an L is
    // found, then change the type of the European number to L.
    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
      var type$4 = types[i$5];
      if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
      else if (isStrong.test(type$4)) { cur$1 = type$4; }
    }

    // N1. A sequence of neutrals takes the direction of the
    // surrounding strong text if the text on both sides has the same
    // direction. European and Arabic numbers act as if they were R in
    // terms of their influence on neutrals. Start-of-level-run (sor)
    // and end-of-level-run (eor) are used at level run boundaries.
    // N2. Any remaining neutrals take the embedding direction.
    for (var i$6 = 0; i$6 < len; ++i$6) {
      if (isNeutral.test(types[i$6])) {
        var end$1 = (void 0);
        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
        var before = (i$6 ? types[i$6-1] : outerType) == "L";
        var after = (end$1 < len ? types[end$1] : outerType) == "L";
        var replace$1 = before == after ? (before ? "L" : "R") : outerType;
        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
        i$6 = end$1 - 1;
      }
    }

    // Here we depart from the documented algorithm, in order to avoid
    // building up an actual levels array. Since there are only three
    // levels (0, 1, 2) in an implementation that doesn't take
    // explicit embedding into account, we can build up the order on
    // the fly, without following the level-based algorithm.
    var order = [], m;
    for (var i$7 = 0; i$7 < len;) {
      if (countsAsLeft.test(types[i$7])) {
        var start = i$7;
        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
        order.push(new BidiSpan(0, start, i$7));
      } else {
        var pos = i$7, at = order.length;
        for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
        for (var j$2 = pos; j$2 < i$7;) {
          if (countsAsNum.test(types[j$2])) {
            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }
            var nstart = j$2;
            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
            order.splice(at, 0, new BidiSpan(2, nstart, j$2));
            pos = j$2;
          } else { ++j$2; }
        }
        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
      }
    }
    if (direction == "ltr") {
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
    }

    return direction == "rtl" ? order.reverse() : order
  }
})();

// Get the bidi ordering for the given line (and cache it). Returns
// false for lines that are fully left-to-right, and an array of
// BidiSpan objects otherwise.
function getOrder(line, direction) {
  var order = line.order;
  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
  return order
}

// EVENT HANDLING

// Lightweight event framework. on/off also work on DOM nodes,
// registering native DOM handlers.

var noHandlers = [];

var on = function(emitter, type, f) {
  if (emitter.addEventListener) {
    emitter.addEventListener(type, f, false);
  } else if (emitter.attachEvent) {
    emitter.attachEvent("on" + type, f);
  } else {
    var map$$1 = emitter._handlers || (emitter._handlers = {});
    map$$1[type] = (map$$1[type] || noHandlers).concat(f);
  }
};

function getHandlers(emitter, type) {
  return emitter._handlers && emitter._handlers[type] || noHandlers
}

function off(emitter, type, f) {
  if (emitter.removeEventListener) {
    emitter.removeEventListener(type, f, false);
  } else if (emitter.detachEvent) {
    emitter.detachEvent("on" + type, f);
  } else {
    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
    if (arr) {
      var index = indexOf(arr, f);
      if (index > -1)
        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
    }
  }
}

function signal(emitter, type /*, values...*/) {
  var handlers = getHandlers(emitter, type);
  if (!handlers.length) { return }
  var args = Array.prototype.slice.call(arguments, 2);
  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
}

// The DOM events that CodeMirror handles can be overridden by
// registering a (non-DOM) handler on the editor for the event name,
// and preventDefault-ing the event in that handler.
function signalDOMEvent(cm, e, override) {
  if (typeof e == "string")
    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
  signal(cm, override || e.type, cm, e);
  return e_defaultPrevented(e) || e.codemirrorIgnore
}

function signalCursorActivity(cm) {
  var arr = cm._handlers && cm._handlers.cursorActivity;
  if (!arr) { return }
  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
    { set.push(arr[i]); } }
}

function hasHandler(emitter, type) {
  return getHandlers(emitter, type).length > 0
}

// Add on and off methods to a constructor's prototype, to make
// registering events on such objects more convenient.
function eventMixin(ctor) {
  ctor.prototype.on = function(type, f) {on(this, type, f);};
  ctor.prototype.off = function(type, f) {off(this, type, f);};
}

// Due to the fact that we still support jurassic IE versions, some
// compatibility wrappers are needed.

function e_preventDefault(e) {
  if (e.preventDefault) { e.preventDefault(); }
  else { e.returnValue = false; }
}
function e_stopPropagation(e) {
  if (e.stopPropagation) { e.stopPropagation(); }
  else { e.cancelBubble = true; }
}
function e_defaultPrevented(e) {
  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
}
function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

function e_target(e) {return e.target || e.srcElement}
function e_button(e) {
  var b = e.which;
  if (b == null) {
    if (e.button & 1) { b = 1; }
    else if (e.button & 2) { b = 3; }
    else if (e.button & 4) { b = 2; }
  }
  if (mac && e.ctrlKey && b == 1) { b = 3; }
  return b
}

// Detect drag-and-drop
var dragAndDrop = function() {
  // There is *some* kind of drag-and-drop support in IE6-8, but I
  // couldn't get it to work yet.
  if (ie && ie_version < 9) { return false }
  var div = elt('div');
  return "draggable" in div || "dragDrop" in div
}();

var zwspSupported;
function zeroWidthElement(measure) {
  if (zwspSupported == null) {
    var test = elt("span", "\u200b");
    removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
    if (measure.firstChild.offsetHeight != 0)
      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
  }
  var node = zwspSupported ? elt("span", "\u200b") :
    elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
  node.setAttribute("cm-text", "");
  return node
}

// Feature-detect IE's crummy client rect reporting for bidi text
var badBidiRects;
function hasBadBidiRects(measure) {
  if (badBidiRects != null) { return badBidiRects }
  var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
  var r0 = range(txt, 0, 1).getBoundingClientRect();
  var r1 = range(txt, 1, 2).getBoundingClientRect();
  removeChildren(measure);
  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
  return badBidiRects = (r1.right - r0.right < 3)
}

// See if "".split is the broken IE version, if so, provide an
// alternative way to split lines.
var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
  var pos = 0, result = [], l = string.length;
  while (pos <= l) {
    var nl = string.indexOf("\n", pos);
    if (nl == -1) { nl = string.length; }
    var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
    var rt = line.indexOf("\r");
    if (rt != -1) {
      result.push(line.slice(0, rt));
      pos += rt + 1;
    } else {
      result.push(line);
      pos = nl + 1;
    }
  }
  return result
} : function (string) { return string.split(/\r\n?|\n/); };

var hasSelection = window.getSelection ? function (te) {
  try { return te.selectionStart != te.selectionEnd }
  catch(e) { return false }
} : function (te) {
  var range$$1;
  try {range$$1 = te.ownerDocument.selection.createRange();}
  catch(e) {}
  if (!range$$1 || range$$1.parentElement() != te) { return false }
  return range$$1.compareEndPoints("StartToEnd", range$$1) != 0
};

var hasCopyEvent = (function () {
  var e = elt("div");
  if ("oncopy" in e) { return true }
  e.setAttribute("oncopy", "return;");
  return typeof e.oncopy == "function"
})();

var badZoomedRects = null;
function hasBadZoomedRects(measure) {
  if (badZoomedRects != null) { return badZoomedRects }
  var node = removeChildrenAndAdd(measure, elt("span", "x"));
  var normal = node.getBoundingClientRect();
  var fromRange = range(node, 0, 1).getBoundingClientRect();
  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
}

// Known modes, by name and by MIME
var modes = {};
var mimeModes = {};

// Extra arguments are stored as the mode's dependencies, which is
// used by (legacy) mechanisms like loadmode.js to automatically
// load a mode. (Preferred mechanism is the require/define calls.)
function defineMode(name, mode) {
  if (arguments.length > 2)
    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
  modes[name] = mode;
}

function defineMIME(mime, spec) {
  mimeModes[mime] = spec;
}

// Given a MIME type, a {name, ...options} config object, or a name
// string, return a mode config object.
function resolveMode(spec) {
  if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
    spec = mimeModes[spec];
  } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
    var found = mimeModes[spec.name];
    if (typeof found == "string") { found = {name: found}; }
    spec = createObj(found, spec);
    spec.name = found.name;
  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
    return resolveMode("application/xml")
  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
    return resolveMode("application/json")
  }
  if (typeof spec == "string") { return {name: spec} }
  else { return spec || {name: "null"} }
}

// Given a mode spec (anything that resolveMode accepts), find and
// initialize an actual mode object.
function getMode(options, spec) {
  spec = resolveMode(spec);
  var mfactory = modes[spec.name];
  if (!mfactory) { return getMode(options, "text/plain") }
  var modeObj = mfactory(options, spec);
  if (modeExtensions.hasOwnProperty(spec.name)) {
    var exts = modeExtensions[spec.name];
    for (var prop in exts) {
      if (!exts.hasOwnProperty(prop)) { continue }
      if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
      modeObj[prop] = exts[prop];
    }
  }
  modeObj.name = spec.name;
  if (spec.helperType) { modeObj.helperType = spec.helperType; }
  if (spec.modeProps) { for (var prop$1 in spec.modeProps)
    { modeObj[prop$1] = spec.modeProps[prop$1]; } }

  return modeObj
}

// This can be used to attach properties to mode objects from
// outside the actual mode definition.
var modeExtensions = {};
function extendMode(mode, properties) {
  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
  copyObj(properties, exts);
}

function copyState(mode, state) {
  if (state === true) { return state }
  if (mode.copyState) { return mode.copyState(state) }
  var nstate = {};
  for (var n in state) {
    var val = state[n];
    if (val instanceof Array) { val = val.concat([]); }
    nstate[n] = val;
  }
  return nstate
}

// Given a mode and a state (for that mode), find the inner mode and
// state at the position that the state refers to.
function innerMode(mode, state) {
  var info;
  while (mode.innerMode) {
    info = mode.innerMode(state);
    if (!info || info.mode == mode) { break }
    state = info.state;
    mode = info.mode;
  }
  return info || {mode: mode, state: state}
}

function startState(mode, a1, a2) {
  return mode.startState ? mode.startState(a1, a2) : true
}

// STRING STREAM

// Fed to the mode parsers, provides helper functions to make
// parsers more succinct.

var StringStream = function(string, tabSize, lineOracle) {
  this.pos = this.start = 0;
  this.string = string;
  this.tabSize = tabSize || 8;
  this.lastColumnPos = this.lastColumnValue = 0;
  this.lineStart = 0;
  this.lineOracle = lineOracle;
};

StringStream.prototype.eol = function () {return this.pos >= this.string.length};
StringStream.prototype.sol = function () {return this.pos == this.lineStart};
StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
StringStream.prototype.next = function () {
  if (this.pos < this.string.length)
    { return this.string.charAt(this.pos++) }
};
StringStream.prototype.eat = function (match) {
  var ch = this.string.charAt(this.pos);
  var ok;
  if (typeof match == "string") { ok = ch == match; }
  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
  if (ok) {++this.pos; return ch}
};
StringStream.prototype.eatWhile = function (match) {
  var start = this.pos;
  while (this.eat(match)){}
  return this.pos > start
};
StringStream.prototype.eatSpace = function () {
    var this$1 = this;

  var start = this.pos;
  while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }
  return this.pos > start
};
StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
StringStream.prototype.skipTo = function (ch) {
  var found = this.string.indexOf(ch, this.pos);
  if (found > -1) {this.pos = found; return true}
};
StringStream.prototype.backUp = function (n) {this.pos -= n;};
StringStream.prototype.column = function () {
  if (this.lastColumnPos < this.start) {
    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
    this.lastColumnPos = this.start;
  }
  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
};
StringStream.prototype.indentation = function () {
  return countColumn(this.string, null, this.tabSize) -
    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
};
StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
  if (typeof pattern == "string") {
    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
    var substr = this.string.substr(this.pos, pattern.length);
    if (cased(substr) == cased(pattern)) {
      if (consume !== false) { this.pos += pattern.length; }
      return true
    }
  } else {
    var match = this.string.slice(this.pos).match(pattern);
    if (match && match.index > 0) { return null }
    if (match && consume !== false) { this.pos += match[0].length; }
    return match
  }
};
StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
StringStream.prototype.hideFirstChars = function (n, inner) {
  this.lineStart += n;
  try { return inner() }
  finally { this.lineStart -= n; }
};
StringStream.prototype.lookAhead = function (n) {
  var oracle = this.lineOracle;
  return oracle && oracle.lookAhead(n)
};
StringStream.prototype.baseToken = function () {
  var oracle = this.lineOracle;
  return oracle && oracle.baseToken(this.pos)
};

var SavedContext = function(state, lookAhead) {
  this.state = state;
  this.lookAhead = lookAhead;
};

var Context = function(doc, state, line, lookAhead) {
  this.state = state;
  this.doc = doc;
  this.line = line;
  this.maxLookAhead = lookAhead || 0;
  this.baseTokens = null;
  this.baseTokenPos = 1;
};

Context.prototype.lookAhead = function (n) {
  var line = this.doc.getLine(this.line + n);
  if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
  return line
};

Context.prototype.baseToken = function (n) {
    var this$1 = this;

  if (!this.baseTokens) { return null }
  while (this.baseTokens[this.baseTokenPos] <= n)
    { this$1.baseTokenPos += 2; }
  var type = this.baseTokens[this.baseTokenPos + 1];
  return {type: type && type.replace(/( |^)overlay .*/, ""),
          size: this.baseTokens[this.baseTokenPos] - n}
};

Context.prototype.nextLine = function () {
  this.line++;
  if (this.maxLookAhead > 0) { this.maxLookAhead--; }
};

Context.fromSaved = function (doc, saved, line) {
  if (saved instanceof SavedContext)
    { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
  else
    { return new Context(doc, copyState(doc.mode, saved), line) }
};

Context.prototype.save = function (copy) {
  var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
  return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
};


// Compute a style array (an array starting with a mode generation
// -- for invalidation -- followed by pairs of end positions and
// style strings), which is used to highlight the tokens on the
// line.
function highlightLine(cm, line, context, forceToEnd) {
  // A styles array always starts with a number identifying the
  // mode/overlays that it is based on (for easy invalidation).
  var st = [cm.state.modeGen], lineClasses = {};
  // Compute the base array of styles
  runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
          lineClasses, forceToEnd);
  var state = context.state;

  // Run overlays, adjust style array.
  var loop = function ( o ) {
    context.baseTokens = st;
    var overlay = cm.state.overlays[o], i = 1, at = 0;
    context.state = true;
    runMode(cm, line.text, overlay.mode, context, function (end, style) {
      var start = i;
      // Ensure there's a token end at the current position, and that i points at it
      while (at < end) {
        var i_end = st[i];
        if (i_end > end)
          { st.splice(i, 1, end, st[i+1], i_end); }
        i += 2;
        at = Math.min(end, i_end);
      }
      if (!style) { return }
      if (overlay.opaque) {
        st.splice(start, i - start, end, "overlay " + style);
        i = start + 2;
      } else {
        for (; start < i; start += 2) {
          var cur = st[start+1];
          st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
        }
      }
    }, lineClasses);
    context.state = state;
    context.baseTokens = null;
    context.baseTokenPos = 1;
  };

  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
}

function getLineStyles(cm, line, updateFrontier) {
  if (!line.styles || line.styles[0] != cm.state.modeGen) {
    var context = getContextBefore(cm, lineNo(line));
    var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
    var result = highlightLine(cm, line, context);
    if (resetState) { context.state = resetState; }
    line.stateAfter = context.save(!resetState);
    line.styles = result.styles;
    if (result.classes) { line.styleClasses = result.classes; }
    else if (line.styleClasses) { line.styleClasses = null; }
    if (updateFrontier === cm.doc.highlightFrontier)
      { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
  }
  return line.styles
}

function getContextBefore(cm, n, precise) {
  var doc = cm.doc, display = cm.display;
  if (!doc.mode.startState) { return new Context(doc, true, n) }
  var start = findStartLine(cm, n, precise);
  var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
  var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

  doc.iter(start, n, function (line) {
    processLine(cm, line.text, context);
    var pos = context.line;
    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
    context.nextLine();
  });
  if (precise) { doc.modeFrontier = context.line; }
  return context
}

// Lightweight form of highlight -- proceed over this line and
// update state, but don't save a style array. Used for lines that
// aren't currently visible.
function processLine(cm, text, context, startAt) {
  var mode = cm.doc.mode;
  var stream = new StringStream(text, cm.options.tabSize, context);
  stream.start = stream.pos = startAt || 0;
  if (text == "") { callBlankLine(mode, context.state); }
  while (!stream.eol()) {
    readToken(mode, stream, context.state);
    stream.start = stream.pos;
  }
}

function callBlankLine(mode, state) {
  if (mode.blankLine) { return mode.blankLine(state) }
  if (!mode.innerMode) { return }
  var inner = innerMode(mode, state);
  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
}

function readToken(mode, stream, state, inner) {
  for (var i = 0; i < 10; i++) {
    if (inner) { inner[0] = innerMode(mode, state).mode; }
    var style = mode.token(stream, state);
    if (stream.pos > stream.start) { return style }
  }
  throw new Error("Mode " + mode.name + " failed to advance stream.")
}

var Token = function(stream, type, state) {
  this.start = stream.start; this.end = stream.pos;
  this.string = stream.current();
  this.type = type || null;
  this.state = state;
};

// Utility for getTokenAt and getLineTokens
function takeToken(cm, pos, precise, asArray) {
  var doc = cm.doc, mode = doc.mode, style;
  pos = clipPos(doc, pos);
  var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
  var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
  if (asArray) { tokens = []; }
  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
    stream.start = stream.pos;
    style = readToken(mode, stream, context.state);
    if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
  }
  return asArray ? tokens : new Token(stream, style, context.state)
}

function extractLineClasses(type, output) {
  if (type) { for (;;) {
    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
    if (!lineClass) { break }
    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
    var prop = lineClass[1] ? "bgClass" : "textClass";
    if (output[prop] == null)
      { output[prop] = lineClass[2]; }
    else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
      { output[prop] += " " + lineClass[2]; }
  } }
  return type
}

// Run the given mode's parser over a line, calling f for each token.
function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
  var flattenSpans = mode.flattenSpans;
  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
  var curStart = 0, curStyle = null;
  var stream = new StringStream(text, cm.options.tabSize, context), style;
  var inner = cm.options.addModeClass && [null];
  if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
  while (!stream.eol()) {
    if (stream.pos > cm.options.maxHighlightLength) {
      flattenSpans = false;
      if (forceToEnd) { processLine(cm, text, context, stream.pos); }
      stream.pos = text.length;
      style = null;
    } else {
      style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
    }
    if (inner) {
      var mName = inner[0].name;
      if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
    }
    if (!flattenSpans || curStyle != style) {
      while (curStart < stream.start) {
        curStart = Math.min(stream.start, curStart + 5000);
        f(curStart, curStyle);
      }
      curStyle = style;
    }
    stream.start = stream.pos;
  }
  while (curStart < stream.pos) {
    // Webkit seems to refuse to render text nodes longer than 57444
    // characters, and returns inaccurate measurements in nodes
    // starting around 5000 chars.
    var pos = Math.min(stream.pos, curStart + 5000);
    f(pos, curStyle);
    curStart = pos;
  }
}

// Finds the line to start with when starting a parse. Tries to
// find a line with a stateAfter, so that it can start with a
// valid state. If that fails, it returns the line with the
// smallest indentation, which tends to need the least context to
// parse correctly.
function findStartLine(cm, n, precise) {
  var minindent, minline, doc = cm.doc;
  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
  for (var search = n; search > lim; --search) {
    if (search <= doc.first) { return doc.first }
    var line = getLine(doc, search - 1), after = line.stateAfter;
    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
      { return search }
    var indented = countColumn(line.text, null, cm.options.tabSize);
    if (minline == null || minindent > indented) {
      minline = search - 1;
      minindent = indented;
    }
  }
  return minline
}

function retreatFrontier(doc, n) {
  doc.modeFrontier = Math.min(doc.modeFrontier, n);
  if (doc.highlightFrontier < n - 10) { return }
  var start = doc.first;
  for (var line = n - 1; line > start; line--) {
    var saved = getLine(doc, line).stateAfter;
    // change is on 3
    // state on line 1 looked ahead 2 -- so saw 3
    // test 1 + 2 < 3 should cover this
    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
      start = line + 1;
      break
    }
  }
  doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
}

// LINE DATA STRUCTURE

// Line objects. These hold state related to a line, including
// highlighting info (the styles array).
var Line = function(text, markedSpans, estimateHeight) {
  this.text = text;
  attachMarkedSpans(this, markedSpans);
  this.height = estimateHeight ? estimateHeight(this) : 1;
};

Line.prototype.lineNo = function () { return lineNo(this) };
eventMixin(Line);

// Change the content (text, markers) of a line. Automatically
// invalidates cached information and tries to re-estimate the
// line's height.
function updateLine(line, text, markedSpans, estimateHeight) {
  line.text = text;
  if (line.stateAfter) { line.stateAfter = null; }
  if (line.styles) { line.styles = null; }
  if (line.order != null) { line.order = null; }
  detachMarkedSpans(line);
  attachMarkedSpans(line, markedSpans);
  var estHeight = estimateHeight ? estimateHeight(line) : 1;
  if (estHeight != line.height) { updateLineHeight(line, estHeight); }
}

// Detach a line from the document tree and its markers.
function cleanUpLine(line) {
  line.parent = null;
  detachMarkedSpans(line);
}

// Convert a style as returned by a mode (either null, or a string
// containing one or more styles) to a CSS style. This is cached,
// and also looks for line-wide styles.
var styleToClassCache = {};
var styleToClassCacheWithMode = {};
function interpretTokenStyle(style, options) {
  if (!style || /^\s*$/.test(style)) { return null }
  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
  return cache[style] ||
    (cache[style] = style.replace(/\S+/g, "cm-$&"))
}

// Render the DOM representation of the text of a line. Also builds
// up a 'line map', which points at the DOM nodes that represent
// specific stretches of text, and is used by the measuring code.
// The returned object contains the DOM node, this map, and
// information about line-wide styles that were set by the mode.
function buildLineContent(cm, lineView) {
  // The padding-right forces the element to have a 'border', which
  // is needed on Webkit to be able to get line-level bounding
  // rectangles for it (in measureChar).
  var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
  var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                 col: 0, pos: 0, cm: cm,
                 trailingSpace: false,
                 splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
  lineView.measure = {};

  // Iterate over the logical lines that make up this visual line.
  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
    builder.pos = 0;
    builder.addToken = buildToken;
    // Optionally wire in some hacks into the token-rendering
    // algorithm, to deal with browser quirks.
    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
    builder.map = [];
    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
    if (line.styleClasses) {
      if (line.styleClasses.bgClass)
        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
      if (line.styleClasses.textClass)
        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
    }

    // Ensure at least a single node is present, for measuring.
    if (builder.map.length == 0)
      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

    // Store the map and a cache object for the current logical line
    if (i == 0) {
      lineView.measure.map = builder.map;
      lineView.measure.cache = {};
    } else {
      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
    }
  }

  // See issue #2901
  if (webkit) {
    var last = builder.content.lastChild;
    if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
      { builder.content.className = "cm-tab-wrap-hack"; }
  }

  signal(cm, "renderLine", cm, lineView.line, builder.pre);
  if (builder.pre.className)
    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

  return builder
}

function defaultSpecialCharPlaceholder(ch) {
  var token = elt("span", "\u2022", "cm-invalidchar");
  token.title = "\\u" + ch.charCodeAt(0).toString(16);
  token.setAttribute("aria-label", token.title);
  return token
}

// Build up the DOM representation for a single token, and add it to
// the line map. Takes care to render special characters separately.
function buildToken(builder, text, style, startStyle, endStyle, title, css) {
  if (!text) { return }
  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
  var special = builder.cm.state.specialChars, mustWrap = false;
  var content;
  if (!special.test(text)) {
    builder.col += text.length;
    content = document.createTextNode(displayText);
    builder.map.push(builder.pos, builder.pos + text.length, content);
    if (ie && ie_version < 9) { mustWrap = true; }
    builder.pos += text.length;
  } else {
    content = document.createDocumentFragment();
    var pos = 0;
    while (true) {
      special.lastIndex = pos;
      var m = special.exec(text);
      var skipped = m ? m.index - pos : text.length - pos;
      if (skipped) {
        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
        else { content.appendChild(txt); }
        builder.map.push(builder.pos, builder.pos + skipped, txt);
        builder.col += skipped;
        builder.pos += skipped;
      }
      if (!m) { break }
      pos += skipped + 1;
      var txt$1 = (void 0);
      if (m[0] == "\t") {
        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
        txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
        txt$1.setAttribute("role", "presentation");
        txt$1.setAttribute("cm-text", "\t");
        builder.col += tabWidth;
      } else if (m[0] == "\r" || m[0] == "\n") {
        txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
        txt$1.setAttribute("cm-text", m[0]);
        builder.col += 1;
      } else {
        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
        txt$1.setAttribute("cm-text", m[0]);
        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
        else { content.appendChild(txt$1); }
        builder.col += 1;
      }
      builder.map.push(builder.pos, builder.pos + 1, txt$1);
      builder.pos++;
    }
  }
  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
  if (style || startStyle || endStyle || mustWrap || css) {
    var fullStyle = style || "";
    if (startStyle) { fullStyle += startStyle; }
    if (endStyle) { fullStyle += endStyle; }
    var token = elt("span", [content], fullStyle, css);
    if (title) { token.title = title; }
    return builder.content.appendChild(token)
  }
  builder.content.appendChild(content);
}

function splitSpaces(text, trailingBefore) {
  if (text.length > 1 && !/  /.test(text)) { return text }
  var spaceBefore = trailingBefore, result = "";
  for (var i = 0; i < text.length; i++) {
    var ch = text.charAt(i);
    if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
      { ch = "\u00a0"; }
    result += ch;
    spaceBefore = ch == " ";
  }
  return result
}

// Work around nonsense dimensions being reported for stretches of
// right-to-left text.
function buildTokenBadBidi(inner, order) {
  return function (builder, text, style, startStyle, endStyle, title, css) {
    style = style ? style + " cm-force-border" : "cm-force-border";
    var start = builder.pos, end = start + text.length;
    for (;;) {
      // Find the part that overlaps with the start of this text
      var part = (void 0);
      for (var i = 0; i < order.length; i++) {
        part = order[i];
        if (part.to > start && part.from <= start) { break }
      }
      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }
      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
      startStyle = null;
      text = text.slice(part.to - start);
      start = part.to;
    }
  }
}

function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
  var widget = !ignoreWidget && marker.widgetNode;
  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
    if (!widget)
      { widget = builder.content.appendChild(document.createElement("span")); }
    widget.setAttribute("cm-marker", marker.id);
  }
  if (widget) {
    builder.cm.display.input.setUneditable(widget);
    builder.content.appendChild(widget);
  }
  builder.pos += size;
  builder.trailingSpace = false;
}

// Outputs a number of spans to make up a line, taking highlighting
// and marked text into account.
function insertLineContent(line, builder, styles) {
  var spans = line.markedSpans, allText = line.text, at = 0;
  if (!spans) {
    for (var i$1 = 1; i$1 < styles.length; i$1+=2)
      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
    return
  }

  var len = allText.length, pos = 0, i = 1, text = "", style, css;
  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
  for (;;) {
    if (nextChange == pos) { // Update current marker set
      spanStyle = spanEndStyle = spanStartStyle = title = css = "";
      collapsed = null; nextChange = Infinity;
      var foundBookmarks = [], endStyles = (void 0);
      for (var j = 0; j < spans.length; ++j) {
        var sp = spans[j], m = sp.marker;
        if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
          foundBookmarks.push(m);
        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
          if (sp.to != null && sp.to != pos && nextChange > sp.to) {
            nextChange = sp.to;
            spanEndStyle = "";
          }
          if (m.className) { spanStyle += " " + m.className; }
          if (m.css) { css = (css ? css + ";" : "") + m.css; }
          if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
          if (m.title && !title) { title = m.title; }
          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
            { collapsed = sp; }
        } else if (sp.from > pos && nextChange > sp.from) {
          nextChange = sp.from;
        }
      }
      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
      if (collapsed && (collapsed.from || 0) == pos) {
        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                           collapsed.marker, collapsed.from == null);
        if (collapsed.to == null) { return }
        if (collapsed.to == pos) { collapsed = false; }
      }
    }
    if (pos >= len) { break }

    var upto = Math.min(len, nextChange);
    while (true) {
      if (text) {
        var end = pos + text.length;
        if (!collapsed) {
          var tokenText = end > upto ? text.slice(0, upto - pos) : text;
          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
        }
        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
        pos = end;
        spanStartStyle = "";
      }
      text = allText.slice(at, at = styles[i++]);
      style = interpretTokenStyle(styles[i++], builder.cm.options);
    }
  }
}


// These objects are used to represent the visible (currently drawn)
// part of the document. A LineView may correspond to multiple
// logical lines, if those are connected by collapsed ranges.
function LineView(doc, line, lineN) {
  // The starting line
  this.line = line;
  // Continuing lines, if any
  this.rest = visualLineContinued(line);
  // Number of logical lines in this visual line
  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
  this.node = this.text = null;
  this.hidden = lineIsHidden(doc, line);
}

// Create a range of LineView objects for the given lines.
function buildViewArray(cm, from, to) {
  var array = [], nextPos;
  for (var pos = from; pos < to; pos = nextPos) {
    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
    nextPos = pos + view.size;
    array.push(view);
  }
  return array
}

var operationGroup = null;

function pushOperation(op) {
  if (operationGroup) {
    operationGroup.ops.push(op);
  } else {
    op.ownsGroup = operationGroup = {
      ops: [op],
      delayedCallbacks: []
    };
  }
}

function fireCallbacksForOps(group) {
  // Calls delayed callbacks and cursorActivity handlers until no
  // new ones appear
  var callbacks = group.delayedCallbacks, i = 0;
  do {
    for (; i < callbacks.length; i++)
      { callbacks[i].call(null); }
    for (var j = 0; j < group.ops.length; j++) {
      var op = group.ops[j];
      if (op.cursorActivityHandlers)
        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
    }
  } while (i < callbacks.length)
}

function finishOperation(op, endCb) {
  var group = op.ownsGroup;
  if (!group) { return }

  try { fireCallbacksForOps(group); }
  finally {
    operationGroup = null;
    endCb(group);
  }
}

var orphanDelayedCallbacks = null;

// Often, we want to signal events at a point where we are in the
// middle of some work, but don't want the handler to start calling
// other methods on the editor, which might be in an inconsistent
// state or simply not expect any other events to happen.
// signalLater looks whether there are any handlers, and schedules
// them to be executed when the last operation ends, or, if no
// operation is active, when a timeout fires.
function signalLater(emitter, type /*, values...*/) {
  var arr = getHandlers(emitter, type);
  if (!arr.length) { return }
  var args = Array.prototype.slice.call(arguments, 2), list;
  if (operationGroup) {
    list = operationGroup.delayedCallbacks;
  } else if (orphanDelayedCallbacks) {
    list = orphanDelayedCallbacks;
  } else {
    list = orphanDelayedCallbacks = [];
    setTimeout(fireOrphanDelayed, 0);
  }
  var loop = function ( i ) {
    list.push(function () { return arr[i].apply(null, args); });
  };

  for (var i = 0; i < arr.length; ++i)
    loop( i );
}

function fireOrphanDelayed() {
  var delayed = orphanDelayedCallbacks;
  orphanDelayedCallbacks = null;
  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
}

// When an aspect of a line changes, a string is added to
// lineView.changes. This updates the relevant part of the line's
// DOM structure.
function updateLineForChanges(cm, lineView, lineN, dims) {
  for (var j = 0; j < lineView.changes.length; j++) {
    var type = lineView.changes[j];
    if (type == "text") { updateLineText(cm, lineView); }
    else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
    else if (type == "class") { updateLineClasses(cm, lineView); }
    else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
  }
  lineView.changes = null;
}

// Lines with gutter elements, widgets or a background class need to
// be wrapped, and have the extra elements added to the wrapper div
function ensureLineWrapped(lineView) {
  if (lineView.node == lineView.text) {
    lineView.node = elt("div", null, null, "position: relative");
    if (lineView.text.parentNode)
      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
    lineView.node.appendChild(lineView.text);
    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
  }
  return lineView.node
}

function updateLineBackground(cm, lineView) {
  var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
  if (cls) { cls += " CodeMirror-linebackground"; }
  if (lineView.background) {
    if (cls) { lineView.background.className = cls; }
    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
  } else if (cls) {
    var wrap = ensureLineWrapped(lineView);
    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    cm.display.input.setUneditable(lineView.background);
  }
}

// Wrapper around buildLineContent which will reuse the structure
// in display.externalMeasured when possible.
function getLineContent(cm, lineView) {
  var ext = cm.display.externalMeasured;
  if (ext && ext.line == lineView.line) {
    cm.display.externalMeasured = null;
    lineView.measure = ext.measure;
    return ext.built
  }
  return buildLineContent(cm, lineView)
}

// Redraw the line's text. Interacts with the background and text
// classes because the mode may output tokens that influence these
// classes.
function updateLineText(cm, lineView) {
  var cls = lineView.text.className;
  var built = getLineContent(cm, lineView);
  if (lineView.text == lineView.node) { lineView.node = built.pre; }
  lineView.text.parentNode.replaceChild(built.pre, lineView.text);
  lineView.text = built.pre;
  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
    lineView.bgClass = built.bgClass;
    lineView.textClass = built.textClass;
    updateLineClasses(cm, lineView);
  } else if (cls) {
    lineView.text.className = cls;
  }
}

function updateLineClasses(cm, lineView) {
  updateLineBackground(cm, lineView);
  if (lineView.line.wrapClass)
    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
  else if (lineView.node != lineView.text)
    { lineView.node.className = ""; }
  var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
  lineView.text.className = textClass || "";
}

function updateLineGutter(cm, lineView, lineN, dims) {
  if (lineView.gutter) {
    lineView.node.removeChild(lineView.gutter);
    lineView.gutter = null;
  }
  if (lineView.gutterBackground) {
    lineView.node.removeChild(lineView.gutterBackground);
    lineView.gutterBackground = null;
  }
  if (lineView.line.gutterClass) {
    var wrap = ensureLineWrapped(lineView);
    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                    ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
    cm.display.input.setUneditable(lineView.gutterBackground);
    wrap.insertBefore(lineView.gutterBackground, lineView.text);
  }
  var markers = lineView.line.gutterMarkers;
  if (cm.options.lineNumbers || markers) {
    var wrap$1 = ensureLineWrapped(lineView);
    var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
    cm.display.input.setUneditable(gutterWrap);
    wrap$1.insertBefore(gutterWrap, lineView.text);
    if (lineView.line.gutterClass)
      { gutterWrap.className += " " + lineView.line.gutterClass; }
    if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
      { lineView.lineNumber = gutterWrap.appendChild(
        elt("div", lineNumberFor(cm.options, lineN),
            "CodeMirror-linenumber CodeMirror-gutter-elt",
            ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {
      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
      if (found)
        { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                   ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
    } }
  }
}

function updateLineWidgets(cm, lineView, dims) {
  if (lineView.alignable) { lineView.alignable = null; }
  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
    next = node.nextSibling;
    if (node.className == "CodeMirror-linewidget")
      { lineView.node.removeChild(node); }
  }
  insertLineWidgets(cm, lineView, dims);
}

// Build a line's DOM representation from scratch
function buildLineElement(cm, lineView, lineN, dims) {
  var built = getLineContent(cm, lineView);
  lineView.text = lineView.node = built.pre;
  if (built.bgClass) { lineView.bgClass = built.bgClass; }
  if (built.textClass) { lineView.textClass = built.textClass; }

  updateLineClasses(cm, lineView);
  updateLineGutter(cm, lineView, lineN, dims);
  insertLineWidgets(cm, lineView, dims);
  return lineView.node
}

// A lineView may contain multiple logical lines (when merged by
// collapsed spans). The widgets for all of them need to be drawn.
function insertLineWidgets(cm, lineView, dims) {
  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
}

function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
  if (!line.widgets) { return }
  var wrap = ensureLineWrapped(lineView);
  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
    var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
    if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
    positionLineWidget(widget, node, lineView, dims);
    cm.display.input.setUneditable(node);
    if (allowAbove && widget.above)
      { wrap.insertBefore(node, lineView.gutter || lineView.text); }
    else
      { wrap.appendChild(node); }
    signalLater(widget, "redraw");
  }
}

function positionLineWidget(widget, node, lineView, dims) {
  if (widget.noHScroll) {
    (lineView.alignable || (lineView.alignable = [])).push(node);
    var width = dims.wrapperWidth;
    node.style.left = dims.fixedPos + "px";
    if (!widget.coverGutter) {
      width -= dims.gutterTotalWidth;
      node.style.paddingLeft = dims.gutterTotalWidth + "px";
    }
    node.style.width = width + "px";
  }
  if (widget.coverGutter) {
    node.style.zIndex = 5;
    node.style.position = "relative";
    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
  }
}

function widgetHeight(widget) {
  if (widget.height != null) { return widget.height }
  var cm = widget.doc.cm;
  if (!cm) { return 0 }
  if (!contains(document.body, widget.node)) {
    var parentStyle = "position: relative;";
    if (widget.coverGutter)
      { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
    if (widget.noHScroll)
      { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
    removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
  }
  return widget.height = widget.node.parentNode.offsetHeight
}

// Return true when the given mouse event happened in a widget
function eventInWidget(display, e) {
  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
    if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
        (n.parentNode == display.sizer && n != display.mover))
      { return true }
  }
}

// POSITION MEASUREMENT

function paddingTop(display) {return display.lineSpace.offsetTop}
function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
function paddingH(display) {
  if (display.cachedPaddingH) { return display.cachedPaddingH }
  var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
  return data
}

function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
function displayWidth(cm) {
  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
}
function displayHeight(cm) {
  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
}

// Ensure the lineView.wrapping.heights array is populated. This is
// an array of bottom offsets for the lines that make up a drawn
// line. When lineWrapping is on, there might be more than one
// height.
function ensureLineHeights(cm, lineView, rect) {
  var wrapping = cm.options.lineWrapping;
  var curWidth = wrapping && displayWidth(cm);
  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
    var heights = lineView.measure.heights = [];
    if (wrapping) {
      lineView.measure.width = curWidth;
      var rects = lineView.text.firstChild.getClientRects();
      for (var i = 0; i < rects.length - 1; i++) {
        var cur = rects[i], next = rects[i + 1];
        if (Math.abs(cur.bottom - next.bottom) > 2)
          { heights.push((cur.bottom + next.top) / 2 - rect.top); }
      }
    }
    heights.push(rect.bottom - rect.top);
  }
}

// Find a line map (mapping character offsets to text nodes) and a
// measurement cache for the given line number. (A line view might
// contain multiple lines when collapsed ranges are present.)
function mapFromLineView(lineView, line, lineN) {
  if (lineView.line == line)
    { return {map: lineView.measure.map, cache: lineView.measure.cache} }
  for (var i = 0; i < lineView.rest.length; i++)
    { if (lineView.rest[i] == line)
      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
    { if (lineNo(lineView.rest[i$1]) > lineN)
      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
}

// Render a line into the hidden node display.externalMeasured. Used
// when measurement is needed for a line that's not in the viewport.
function updateExternalMeasurement(cm, line) {
  line = visualLine(line);
  var lineN = lineNo(line);
  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
  view.lineN = lineN;
  var built = view.built = buildLineContent(cm, view);
  view.text = built.pre;
  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
  return view
}

// Get a {top, bottom, left, right} box (in line-local coordinates)
// for a given character.
function measureChar(cm, line, ch, bias) {
  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
}

// Find a line view that corresponds to the given line number.
function findViewForLine(cm, lineN) {
  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
    { return cm.display.view[findViewIndex(cm, lineN)] }
  var ext = cm.display.externalMeasured;
  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
    { return ext }
}

// Measurement can be split in two steps, the set-up work that
// applies to the whole line, and the measurement of the actual
// character. Functions like coordsChar, that need to do a lot of
// measurements in a row, can thus ensure that the set-up work is
// only done once.
function prepareMeasureForLine(cm, line) {
  var lineN = lineNo(line);
  var view = findViewForLine(cm, lineN);
  if (view && !view.text) {
    view = null;
  } else if (view && view.changes) {
    updateLineForChanges(cm, view, lineN, getDimensions(cm));
    cm.curOp.forceUpdate = true;
  }
  if (!view)
    { view = updateExternalMeasurement(cm, line); }

  var info = mapFromLineView(view, line, lineN);
  return {
    line: line, view: view, rect: null,
    map: info.map, cache: info.cache, before: info.before,
    hasHeights: false
  }
}

// Given a prepared measurement object, measures the position of an
// actual character (or fetches it from the cache).
function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
  if (prepared.before) { ch = -1; }
  var key = ch + (bias || ""), found;
  if (prepared.cache.hasOwnProperty(key)) {
    found = prepared.cache[key];
  } else {
    if (!prepared.rect)
      { prepared.rect = prepared.view.text.getBoundingClientRect(); }
    if (!prepared.hasHeights) {
      ensureLineHeights(cm, prepared.view, prepared.rect);
      prepared.hasHeights = true;
    }
    found = measureCharInner(cm, prepared, ch, bias);
    if (!found.bogus) { prepared.cache[key] = found; }
  }
  return {left: found.left, right: found.right,
          top: varHeight ? found.rtop : found.top,
          bottom: varHeight ? found.rbottom : found.bottom}
}

var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

function nodeAndOffsetInLineMap(map$$1, ch, bias) {
  var node, start, end, collapse, mStart, mEnd;
  // First, search the line map for the text node corresponding to,
  // or closest to, the target character.
  for (var i = 0; i < map$$1.length; i += 3) {
    mStart = map$$1[i];
    mEnd = map$$1[i + 1];
    if (ch < mStart) {
      start = 0; end = 1;
      collapse = "left";
    } else if (ch < mEnd) {
      start = ch - mStart;
      end = start + 1;
    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
      end = mEnd - mStart;
      start = end - 1;
      if (ch >= mEnd) { collapse = "right"; }
    }
    if (start != null) {
      node = map$$1[i + 2];
      if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
        { collapse = bias; }
      if (bias == "left" && start == 0)
        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
          node = map$$1[(i -= 3) + 2];
          collapse = "left";
        } }
      if (bias == "right" && start == mEnd - mStart)
        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
          node = map$$1[(i += 3) + 2];
          collapse = "right";
        } }
      break
    }
  }
  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
}

function getUsefulRect(rects, bias) {
  var rect = nullRect;
  if (bias == "left") { for (var i = 0; i < rects.length; i++) {
    if ((rect = rects[i]).left != rect.right) { break }
  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
    if ((rect = rects[i$1]).left != rect.right) { break }
  } }
  return rect
}

function measureCharInner(cm, prepared, ch, bias) {
  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

  var rect;
  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
        { rect = node.parentNode.getBoundingClientRect(); }
      else
        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
      if (rect.left || rect.right || start == 0) { break }
      end = start;
      start = start - 1;
      collapse = "right";
    }
    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
  } else { // If it is a widget, simply get the box for the whole widget.
    if (start > 0) { collapse = bias = "right"; }
    var rects;
    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
      { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
    else
      { rect = node.getBoundingClientRect(); }
  }
  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
    var rSpan = node.parentNode.getClientRects()[0];
    if (rSpan)
      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
    else
      { rect = nullRect; }
  }

  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
  var mid = (rtop + rbot) / 2;
  var heights = prepared.view.measure.heights;
  var i = 0;
  for (; i < heights.length - 1; i++)
    { if (mid < heights[i]) { break } }
  var top = i ? heights[i - 1] : 0, bot = heights[i];
  var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                top: top, bottom: bot};
  if (!rect.left && !rect.right) { result.bogus = true; }
  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

  return result
}

// Work around problem with bounding client rects on ranges being
// returned incorrectly when zoomed on IE10 and below.
function maybeUpdateRectForZooming(measure, rect) {
  if (!window.screen || screen.logicalXDPI == null ||
      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
    { return rect }
  var scaleX = screen.logicalXDPI / screen.deviceXDPI;
  var scaleY = screen.logicalYDPI / screen.deviceYDPI;
  return {left: rect.left * scaleX, right: rect.right * scaleX,
          top: rect.top * scaleY, bottom: rect.bottom * scaleY}
}

function clearLineMeasurementCacheFor(lineView) {
  if (lineView.measure) {
    lineView.measure.cache = {};
    lineView.measure.heights = null;
    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
      { lineView.measure.caches[i] = {}; } }
  }
}

function clearLineMeasurementCache(cm) {
  cm.display.externalMeasure = null;
  removeChildren(cm.display.lineMeasure);
  for (var i = 0; i < cm.display.view.length; i++)
    { clearLineMeasurementCacheFor(cm.display.view[i]); }
}

function clearCaches(cm) {
  clearLineMeasurementCache(cm);
  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
  cm.display.lineNumChars = null;
}

function pageScrollX() {
  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
  // which causes page_Offset and bounding client rects to use
  // different reference viewports and invalidate our calculations.
  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
  return window.pageXOffset || (document.documentElement || document.body).scrollLeft
}
function pageScrollY() {
  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
  return window.pageYOffset || (document.documentElement || document.body).scrollTop
}

function widgetTopHeight(lineObj) {
  var height = 0;
  if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
    { height += widgetHeight(lineObj.widgets[i]); } } }
  return height
}

// Converts a {top, bottom, left, right} box from line-local
// coordinates into another coordinate system. Context may be one of
// "line", "div" (display.lineDiv), "local"./null (editor), "window",
// or "page".
function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
  if (!includeWidgets) {
    var height = widgetTopHeight(lineObj);
    rect.top += height; rect.bottom += height;
  }
  if (context == "line") { return rect }
  if (!context) { context = "local"; }
  var yOff = heightAtLine(lineObj);
  if (context == "local") { yOff += paddingTop(cm.display); }
  else { yOff -= cm.display.viewOffset; }
  if (context == "page" || context == "window") {
    var lOff = cm.display.lineSpace.getBoundingClientRect();
    yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
    var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
    rect.left += xOff; rect.right += xOff;
  }
  rect.top += yOff; rect.bottom += yOff;
  return rect
}

// Coverts a box from "div" coords to another coordinate system.
// Context may be "window", "page", "div", or "local"./null.
function fromCoordSystem(cm, coords, context) {
  if (context == "div") { return coords }
  var left = coords.left, top = coords.top;
  // First move into "page" coordinate system
  if (context == "page") {
    left -= pageScrollX();
    top -= pageScrollY();
  } else if (context == "local" || !context) {
    var localBox = cm.display.sizer.getBoundingClientRect();
    left += localBox.left;
    top += localBox.top;
  }

  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
}

function charCoords(cm, pos, context, lineObj, bias) {
  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
}

// Returns a box for a given cursor position, which may have an
// 'other' property containing the position of the secondary cursor
// on a bidi boundary.
// A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
// and after `char - 1` in writing order of `char - 1`
// A cursor Pos(line, char, "after") is on the same visual line as `char`
// and before `char` in writing order of `char`
// Examples (upper-case letters are RTL, lower-case are LTR):
//     Pos(0, 1, ...)
//     before   after
// ab     a|b     a|b
// aB     a|B     aB|
// Ab     |Ab     A|b
// AB     B|A     B|A
// Every position after the last character on a line is considered to stick
// to the last character on the line.
function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
  lineObj = lineObj || getLine(cm.doc, pos.line);
  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
  function get(ch, right) {
    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
    if (right) { m.left = m.right; } else { m.right = m.left; }
    return intoCoordSystem(cm, lineObj, m, context)
  }
  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
  if (ch >= lineObj.text.length) {
    ch = lineObj.text.length;
    sticky = "before";
  } else if (ch <= 0) {
    ch = 0;
    sticky = "after";
  }
  if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

  function getBidi(ch, partPos, invert) {
    var part = order[partPos], right = part.level == 1;
    return get(invert ? ch - 1 : ch, right != invert)
  }
  var partPos = getBidiPartAt(order, ch, sticky);
  var other = bidiOther;
  var val = getBidi(ch, partPos, sticky == "before");
  if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
  return val
}

// Used to cheaply estimate the coordinates for a position. Used for
// intermediate scroll updates.
function estimateCoords(cm, pos) {
  var left = 0;
  pos = clipPos(cm.doc, pos);
  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
  var lineObj = getLine(cm.doc, pos.line);
  var top = heightAtLine(lineObj) + paddingTop(cm.display);
  return {left: left, right: left, top: top, bottom: top + lineObj.height}
}

// Positions returned by coordsChar contain some extra information.
// xRel is the relative x position of the input coordinates compared
// to the found position (so xRel > 0 means the coordinates are to
// the right of the character position, for example). When outside
// is true, that means the coordinates lie outside the line's
// vertical range.
function PosWithInfo(line, ch, sticky, outside, xRel) {
  var pos = Pos(line, ch, sticky);
  pos.xRel = xRel;
  if (outside) { pos.outside = true; }
  return pos
}

// Compute the character position closest to the given coordinates.
// Input must be lineSpace-local ("div" coordinate system).
function coordsChar(cm, x, y) {
  var doc = cm.doc;
  y += cm.display.viewOffset;
  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }
  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
  if (lineN > last)
    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }
  if (x < 0) { x = 0; }

  var lineObj = getLine(doc, lineN);
  for (;;) {
    var found = coordsCharInner(cm, lineObj, lineN, x, y);
    var merged = collapsedSpanAtEnd(lineObj);
    var mergedPos = merged && merged.find(0, true);
    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
      { lineN = lineNo(lineObj = mergedPos.to.line); }
    else
      { return found }
  }
}

function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
  y -= widgetTopHeight(lineObj);
  var end = lineObj.text.length;
  var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
  end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
  return {begin: begin, end: end}
}

function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
}

// Returns true if the given side of a box is after the given
// coordinates, in top-to-bottom, left-to-right order.
function boxIsAfter(box, x, y, left) {
  return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
}

function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
  // Move y into line-local coordinate space
  y -= heightAtLine(lineObj);
  var preparedMeasure = prepareMeasureForLine(cm, lineObj);
  // When directly calling `measureCharPrepared`, we have to adjust
  // for the widgets at this line.
  var widgetHeight$$1 = widgetTopHeight(lineObj);
  var begin = 0, end = lineObj.text.length, ltr = true;

  var order = getOrder(lineObj, cm.doc.direction);
  // If the line isn't plain left-to-right text, first figure out
  // which bidi section the coordinates fall into.
  if (order) {
    var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                 (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
    ltr = part.level != 1;
    // The awkward -1 offsets are needed because findFirst (called
    // on these below) will treat its first bound as inclusive,
    // second as exclusive, but we want to actually address the
    // characters in the part's range
    begin = ltr ? part.from : part.to - 1;
    end = ltr ? part.to : part.from - 1;
  }

  // A binary search to find the first character whose bounding box
  // starts after the coordinates. If we run across any whose box wrap
  // the coordinates, store that.
  var chAround = null, boxAround = null;
  var ch = findFirst(function (ch) {
    var box = measureCharPrepared(cm, preparedMeasure, ch);
    box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;
    if (!boxIsAfter(box, x, y, false)) { return false }
    if (box.top <= y && box.left <= x) {
      chAround = ch;
      boxAround = box;
    }
    return true
  }, begin, end);

  var baseX, sticky, outside = false;
  // If a box around the coordinates was found, use that
  if (boxAround) {
    // Distinguish coordinates nearer to the left or right side of the box
    var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
    ch = chAround + (atStart ? 0 : 1);
    sticky = atStart ? "after" : "before";
    baseX = atLeft ? boxAround.left : boxAround.right;
  } else {
    // (Adjust for extended bound, if necessary.)
    if (!ltr && (ch == end || ch == begin)) { ch++; }
    // To determine which side to associate with, get the box to the
    // left of the character and compare it's vertical position to the
    // coordinates
    sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
      (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?
      "after" : "before";
    // Now get accurate coordinates for this place, in order to get a
    // base X position
    var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
    baseX = coords.left;
    outside = y < coords.top || y >= coords.bottom;
  }

  ch = skipExtendingChars(lineObj.text, ch, 1);
  return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)
}

function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
  // Bidi parts are sorted left-to-right, and in a non-line-wrapping
  // situation, we can take this ordering to correspond to the visual
  // ordering. This finds the first part whose end is after the given
  // coordinates.
  var index = findFirst(function (i) {
    var part = order[i], ltr = part.level != 1;
    return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                   "line", lineObj, preparedMeasure), x, y, true)
  }, 0, order.length - 1);
  var part = order[index];
  // If this isn't the first part, the part's start is also after
  // the coordinates, and the coordinates aren't on the same line as
  // that start, move one part back.
  if (index > 0) {
    var ltr = part.level != 1;
    var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"),
                             "line", lineObj, preparedMeasure);
    if (boxIsAfter(start, x, y, true) && start.top > y)
      { part = order[index - 1]; }
  }
  return part
}

function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
  // In a wrapped line, rtl text on wrapping boundaries can do things
  // that don't correspond to the ordering in our `order` array at
  // all, so a binary search doesn't work, and we want to return a
  // part that only spans one line so that the binary search in
  // coordsCharInner is safe. As such, we first find the extent of the
  // wrapped line, and then do a flat search in which we discard any
  // spans that aren't on the line.
  var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
  var begin = ref.begin;
  var end = ref.end;
  if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
  var part = null, closestDist = null;
  for (var i = 0; i < order.length; i++) {
    var p = order[i];
    if (p.from >= end || p.to <= begin) { continue }
    var ltr = p.level != 1;
    var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
    // Weigh against spans ending before this, so that they are only
    // picked if nothing ends after
    var dist = endX < x ? x - endX + 1e9 : endX - x;
    if (!part || closestDist > dist) {
      part = p;
      closestDist = dist;
    }
  }
  if (!part) { part = order[order.length - 1]; }
  // Clip the part to the wrapped line.
  if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
  if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
  return part
}

var measureText;
// Compute the default text height.
function textHeight(display) {
  if (display.cachedTextHeight != null) { return display.cachedTextHeight }
  if (measureText == null) {
    measureText = elt("pre");
    // Measure a bunch of lines, for browsers that compute
    // fractional heights.
    for (var i = 0; i < 49; ++i) {
      measureText.appendChild(document.createTextNode("x"));
      measureText.appendChild(elt("br"));
    }
    measureText.appendChild(document.createTextNode("x"));
  }
  removeChildrenAndAdd(display.measure, measureText);
  var height = measureText.offsetHeight / 50;
  if (height > 3) { display.cachedTextHeight = height; }
  removeChildren(display.measure);
  return height || 1
}

// Compute the default character width.
function charWidth(display) {
  if (display.cachedCharWidth != null) { return display.cachedCharWidth }
  var anchor = elt("span", "xxxxxxxxxx");
  var pre = elt("pre", [anchor]);
  removeChildrenAndAdd(display.measure, pre);
  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
  if (width > 2) { display.cachedCharWidth = width; }
  return width || 10
}

// Do a bulk-read of the DOM positions and sizes needed to draw the
// view, so that we don't interleave reading and writing to the DOM.
function getDimensions(cm) {
  var d = cm.display, left = {}, width = {};
  var gutterLeft = d.gutters.clientLeft;
  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
    width[cm.options.gutters[i]] = n.clientWidth;
  }
  return {fixedPos: compensateForHScroll(d),
          gutterTotalWidth: d.gutters.offsetWidth,
          gutterLeft: left,
          gutterWidth: width,
          wrapperWidth: d.wrapper.clientWidth}
}

// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
// but using getBoundingClientRect to get a sub-pixel-accurate
// result.
function compensateForHScroll(display) {
  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
}

// Returns a function that estimates the height of a line, to use as
// first approximation until the line becomes visible (and is thus
// properly measurable).
function estimateHeight(cm) {
  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
  return function (line) {
    if (lineIsHidden(cm.doc, line)) { return 0 }

    var widgetsHeight = 0;
    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
    } }

    if (wrapping)
      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
    else
      { return widgetsHeight + th }
  }
}

function estimateLineHeights(cm) {
  var doc = cm.doc, est = estimateHeight(cm);
  doc.iter(function (line) {
    var estHeight = est(line);
    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
  });
}

// Given a mouse event, find the corresponding position. If liberal
// is false, it checks whether a gutter or scrollbar was clicked,
// and returns null if it was. forRect is used by rectangular
// selections, and tries to estimate a character position even for
// coordinates beyond the right of the text.
function posFromMouse(cm, e, liberal, forRect) {
  var display = cm.display;
  if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

  var x, y, space = display.lineSpace.getBoundingClientRect();
  // Fails unpredictably on IE[67] when mouse is dragged around quickly.
  try { x = e.clientX - space.left; y = e.clientY - space.top; }
  catch (e) { return null }
  var coords = coordsChar(cm, x, y), line;
  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
  }
  return coords
}

// Find the view element corresponding to a given line. Return null
// when the line isn't visible.
function findViewIndex(cm, n) {
  if (n >= cm.display.viewTo) { return null }
  n -= cm.display.viewFrom;
  if (n < 0) { return null }
  var view = cm.display.view;
  for (var i = 0; i < view.length; i++) {
    n -= view[i].size;
    if (n < 0) { return i }
  }
}

function updateSelection(cm) {
  cm.display.input.showSelection(cm.display.input.prepareSelection());
}

function prepareSelection(cm, primary) {
  if ( primary === void 0 ) primary = true;

  var doc = cm.doc, result = {};
  var curFragment = result.cursors = document.createDocumentFragment();
  var selFragment = result.selection = document.createDocumentFragment();

  for (var i = 0; i < doc.sel.ranges.length; i++) {
    if (!primary && i == doc.sel.primIndex) { continue }
    var range$$1 = doc.sel.ranges[i];
    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }
    var collapsed = range$$1.empty();
    if (collapsed || cm.options.showCursorWhenSelecting)
      { drawSelectionCursor(cm, range$$1.head, curFragment); }
    if (!collapsed)
      { drawSelectionRange(cm, range$$1, selFragment); }
  }
  return result
}

// Draws a cursor for the given range
function drawSelectionCursor(cm, head, output) {
  var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

  var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
  cursor.style.left = pos.left + "px";
  cursor.style.top = pos.top + "px";
  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

  if (pos.other) {
    // Secondary cursor, shown when on a 'jump' in bi-directional text
    var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
    otherCursor.style.display = "";
    otherCursor.style.left = pos.other.left + "px";
    otherCursor.style.top = pos.other.top + "px";
    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
  }
}

function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

// Draws the given range as a highlighted selection
function drawSelectionRange(cm, range$$1, output) {
  var display = cm.display, doc = cm.doc;
  var fragment = document.createDocumentFragment();
  var padding = paddingH(cm.display), leftSide = padding.left;
  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
  var docLTR = doc.direction == "ltr";

  function add(left, top, width, bottom) {
    if (top < 0) { top = 0; }
    top = Math.round(top);
    bottom = Math.round(bottom);
    fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
  }

  function drawForLine(line, fromArg, toArg) {
    var lineObj = getLine(doc, line);
    var lineLen = lineObj.text.length;
    var start, end;
    function coords(ch, bias) {
      return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
    }

    function wrapX(pos, dir, side) {
      var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
      var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
      var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
      return coords(ch, prop)[prop]
    }

    var order = getOrder(lineObj, doc.direction);
    iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
      var ltr = dir == "ltr";
      var fromPos = coords(from, ltr ? "left" : "right");
      var toPos = coords(to - 1, ltr ? "right" : "left");

      var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
      var first = i == 0, last = !order || i == order.length - 1;
      if (toPos.top - fromPos.top <= 3) { // Single line
        var openLeft = (docLTR ? openStart : openEnd) && first;
        var openRight = (docLTR ? openEnd : openStart) && last;
        var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
        var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
        add(left, fromPos.top, right - left, fromPos.bottom);
      } else { // Multiple lines
        var topLeft, topRight, botLeft, botRight;
        if (ltr) {
          topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
          topRight = docLTR ? rightSide : wrapX(from, dir, "before");
          botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
          botRight = docLTR && openEnd && last ? rightSide : toPos.right;
        } else {
          topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
          topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
          botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
          botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
        }
        add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
        if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
        add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
      }

      if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
      if (cmpCoords(toPos, start) < 0) { start = toPos; }
      if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
      if (cmpCoords(toPos, end) < 0) { end = toPos; }
    });
    return {start: start, end: end}
  }

  var sFrom = range$$1.from(), sTo = range$$1.to();
  if (sFrom.line == sTo.line) {
    drawForLine(sFrom.line, sFrom.ch, sTo.ch);
  } else {
    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
    var singleVLine = visualLine(fromLine) == visualLine(toLine);
    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
    if (singleVLine) {
      if (leftEnd.top < rightStart.top - 2) {
        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
      } else {
        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
      }
    }
    if (leftEnd.bottom < rightStart.top)
      { add(leftSide, leftEnd.bottom, null, rightStart.top); }
  }

  output.appendChild(fragment);
}

// Cursor-blinking
function restartBlink(cm) {
  if (!cm.state.focused) { return }
  var display = cm.display;
  clearInterval(display.blinker);
  var on = true;
  display.cursorDiv.style.visibility = "";
  if (cm.options.cursorBlinkRate > 0)
    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
      cm.options.cursorBlinkRate); }
  else if (cm.options.cursorBlinkRate < 0)
    { display.cursorDiv.style.visibility = "hidden"; }
}

function ensureFocus(cm) {
  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
}

function delayBlurEvent(cm) {
  cm.state.delayingBlurEvent = true;
  setTimeout(function () { if (cm.state.delayingBlurEvent) {
    cm.state.delayingBlurEvent = false;
    onBlur(cm);
  } }, 100);
}

function onFocus(cm, e) {
  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }

  if (cm.options.readOnly == "nocursor") { return }
  if (!cm.state.focused) {
    signal(cm, "focus", cm, e);
    cm.state.focused = true;
    addClass(cm.display.wrapper, "CodeMirror-focused");
    // This test prevents this from firing when a context
    // menu is closed (since the input reset would kill the
    // select-all detection hack)
    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
      cm.display.input.reset();
      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
    }
    cm.display.input.receivedFocus();
  }
  restartBlink(cm);
}
function onBlur(cm, e) {
  if (cm.state.delayingBlurEvent) { return }

  if (cm.state.focused) {
    signal(cm, "blur", cm, e);
    cm.state.focused = false;
    rmClass(cm.display.wrapper, "CodeMirror-focused");
  }
  clearInterval(cm.display.blinker);
  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
}

// Read the actual heights of the rendered lines, and update their
// stored heights to match.
function updateHeightsInViewport(cm) {
  var display = cm.display;
  var prevBottom = display.lineDiv.offsetTop;
  for (var i = 0; i < display.view.length; i++) {
    var cur = display.view[i], height = (void 0);
    if (cur.hidden) { continue }
    if (ie && ie_version < 8) {
      var bot = cur.node.offsetTop + cur.node.offsetHeight;
      height = bot - prevBottom;
      prevBottom = bot;
    } else {
      var box = cur.node.getBoundingClientRect();
      height = box.bottom - box.top;
    }
    var diff = cur.line.height - height;
    if (height < 2) { height = textHeight(display); }
    if (diff > .005 || diff < -.005) {
      updateLineHeight(cur.line, height);
      updateWidgetHeight(cur.line);
      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
        { updateWidgetHeight(cur.rest[j]); } }
    }
  }
}

// Read and store the height of line widgets associated with the
// given line.
function updateWidgetHeight(line) {
  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
    var w = line.widgets[i], parent = w.node.parentNode;
    if (parent) { w.height = parent.offsetHeight; }
  } }
}

// Compute the lines that are visible in a given viewport (defaults
// the the current scroll position). viewport may contain top,
// height, and ensure (see op.scrollToPos) properties.
function visibleLines(display, doc, viewport) {
  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
  top = Math.floor(top - paddingTop(display));
  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
  // forces those lines into the viewport (if possible).
  if (viewport && viewport.ensure) {
    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
    if (ensureFrom < from) {
      from = ensureFrom;
      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
      to = ensureTo;
    }
  }
  return {from: from, to: Math.max(to, from + 1)}
}

// Re-align line numbers and gutter marks to compensate for
// horizontal scrolling.
function alignHorizontally(cm) {
  var display = cm.display, view = display.view;
  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
  var gutterW = display.gutters.offsetWidth, left = comp + "px";
  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
    if (cm.options.fixedGutter) {
      if (view[i].gutter)
        { view[i].gutter.style.left = left; }
      if (view[i].gutterBackground)
        { view[i].gutterBackground.style.left = left; }
    }
    var align = view[i].alignable;
    if (align) { for (var j = 0; j < align.length; j++)
      { align[j].style.left = left; } }
  } }
  if (cm.options.fixedGutter)
    { display.gutters.style.left = (comp + gutterW) + "px"; }
}

// Used to ensure that the line number gutter is still the right
// size for the current document size. Returns true when an update
// is needed.
function maybeUpdateLineNumberWidth(cm) {
  if (!cm.options.lineNumbers) { return false }
  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
  if (last.length != display.lineNumChars) {
    var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                               "CodeMirror-linenumber CodeMirror-gutter-elt"));
    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
    display.lineGutter.style.width = "";
    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
    display.lineNumWidth = display.lineNumInnerWidth + padding;
    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
    display.lineGutter.style.width = display.lineNumWidth + "px";
    updateGutterSpace(cm);
    return true
  }
  return false
}

// SCROLLING THINGS INTO VIEW

// If an editor sits on the top or bottom of the window, partially
// scrolled out of view, this ensures that the cursor is visible.
function maybeScrollWindow(cm, rect) {
  if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
  if (rect.top + box.top < 0) { doScroll = true; }
  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
  if (doScroll != null && !phantom) {
    var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
    cm.display.lineSpace.appendChild(scrollNode);
    scrollNode.scrollIntoView(doScroll);
    cm.display.lineSpace.removeChild(scrollNode);
  }
}

// Scroll a given position into view (immediately), verifying that
// it actually became visible (as line heights are accurately
// measured, the position of something may 'drift' during drawing).
function scrollPosIntoView(cm, pos, end, margin) {
  if (margin == null) { margin = 0; }
  var rect;
  if (!cm.options.lineWrapping && pos == end) {
    // Set pos and end to the cursor positions around the character pos sticks to
    // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
    // If pos == Pos(_, 0, "before"), pos and end are unchanged
    pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
    end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
  }
  for (var limit = 0; limit < 5; limit++) {
    var changed = false;
    var coords = cursorCoords(cm, pos);
    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
    rect = {left: Math.min(coords.left, endCoords.left),
            top: Math.min(coords.top, endCoords.top) - margin,
            right: Math.max(coords.left, endCoords.left),
            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
    var scrollPos = calculateScrollPos(cm, rect);
    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
    if (scrollPos.scrollTop != null) {
      updateScrollTop(cm, scrollPos.scrollTop);
      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
    }
    if (scrollPos.scrollLeft != null) {
      setScrollLeft(cm, scrollPos.scrollLeft);
      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
    }
    if (!changed) { break }
  }
  return rect
}

// Scroll a given set of coordinates into view (immediately).
function scrollIntoView(cm, rect) {
  var scrollPos = calculateScrollPos(cm, rect);
  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
}

// Calculate a new scroll position needed to scroll the given
// rectangle into view. Returns an object with scrollTop and
// scrollLeft properties. When these are undefined, the
// vertical/horizontal position does not need to be adjusted.
function calculateScrollPos(cm, rect) {
  var display = cm.display, snapMargin = textHeight(cm.display);
  if (rect.top < 0) { rect.top = 0; }
  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
  var screen = displayHeight(cm), result = {};
  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
  var docBottom = cm.doc.height + paddingVert(display);
  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
  if (rect.top < screentop) {
    result.scrollTop = atTop ? 0 : rect.top;
  } else if (rect.bottom > screentop + screen) {
    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
    if (newTop != screentop) { result.scrollTop = newTop; }
  }

  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
  var tooWide = rect.right - rect.left > screenw;
  if (tooWide) { rect.right = rect.left + screenw; }
  if (rect.left < 10)
    { result.scrollLeft = 0; }
  else if (rect.left < screenleft)
    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
  else if (rect.right > screenw + screenleft - 3)
    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
  return result
}

// Store a relative adjustment to the scroll position in the current
// operation (to be applied when the operation finishes).
function addToScrollTop(cm, top) {
  if (top == null) { return }
  resolveScrollToPos(cm);
  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
}

// Make sure that at the end of the operation the current cursor is
// shown.
function ensureCursorVisible(cm) {
  resolveScrollToPos(cm);
  var cur = cm.getCursor();
  cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
}

function scrollToCoords(cm, x, y) {
  if (x != null || y != null) { resolveScrollToPos(cm); }
  if (x != null) { cm.curOp.scrollLeft = x; }
  if (y != null) { cm.curOp.scrollTop = y; }
}

function scrollToRange(cm, range$$1) {
  resolveScrollToPos(cm);
  cm.curOp.scrollToPos = range$$1;
}

// When an operation has its scrollToPos property set, and another
// scroll action is applied before the end of the operation, this
// 'simulates' scrolling that position into view in a cheap way, so
// that the effect of intermediate scroll commands is not ignored.
function resolveScrollToPos(cm) {
  var range$$1 = cm.curOp.scrollToPos;
  if (range$$1) {
    cm.curOp.scrollToPos = null;
    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
    scrollToCoordsRange(cm, from, to, range$$1.margin);
  }
}

function scrollToCoordsRange(cm, from, to, margin) {
  var sPos = calculateScrollPos(cm, {
    left: Math.min(from.left, to.left),
    top: Math.min(from.top, to.top) - margin,
    right: Math.max(from.right, to.right),
    bottom: Math.max(from.bottom, to.bottom) + margin
  });
  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
}

// Sync the scrollable area and scrollbars, ensure the viewport
// covers the visible area.
function updateScrollTop(cm, val) {
  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
  if (!gecko) { updateDisplaySimple(cm, {top: val}); }
  setScrollTop(cm, val, true);
  if (gecko) { updateDisplaySimple(cm); }
  startWorker(cm, 100);
}

function setScrollTop(cm, val, forceScroll) {
  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
  cm.doc.scrollTop = val;
  cm.display.scrollbars.setScrollTop(val);
  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
}

// Sync scroller and scrollbar, ensure the gutter elements are
// aligned.
function setScrollLeft(cm, val, isScroller, forceScroll) {
  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
  cm.doc.scrollLeft = val;
  alignHorizontally(cm);
  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
  cm.display.scrollbars.setScrollLeft(val);
}

// SCROLLBARS

// Prepare DOM reads needed to update the scrollbars. Done in one
// shot to minimize update/measure roundtrips.
function measureForScrollbars(cm) {
  var d = cm.display, gutterW = d.gutters.offsetWidth;
  var docH = Math.round(cm.doc.height + paddingVert(cm.display));
  return {
    clientHeight: d.scroller.clientHeight,
    viewHeight: d.wrapper.clientHeight,
    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
    viewWidth: d.wrapper.clientWidth,
    barLeft: cm.options.fixedGutter ? gutterW : 0,
    docHeight: docH,
    scrollHeight: docH + scrollGap(cm) + d.barHeight,
    nativeBarWidth: d.nativeBarWidth,
    gutterWidth: gutterW
  }
}

var NativeScrollbars = function(place, scroll, cm) {
  this.cm = cm;
  var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
  var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
  place(vert); place(horiz);

  on(vert, "scroll", function () {
    if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
  });
  on(horiz, "scroll", function () {
    if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
  });

  this.checkedZeroWidth = false;
  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
};

NativeScrollbars.prototype.update = function (measure) {
  var needsH = measure.scrollWidth > measure.clientWidth + 1;
  var needsV = measure.scrollHeight > measure.clientHeight + 1;
  var sWidth = measure.nativeBarWidth;

  if (needsV) {
    this.vert.style.display = "block";
    this.vert.style.bottom = needsH ? sWidth + "px" : "0";
    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
    // A bug in IE8 can cause this value to be negative, so guard it.
    this.vert.firstChild.style.height =
      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
  } else {
    this.vert.style.display = "";
    this.vert.firstChild.style.height = "0";
  }

  if (needsH) {
    this.horiz.style.display = "block";
    this.horiz.style.right = needsV ? sWidth + "px" : "0";
    this.horiz.style.left = measure.barLeft + "px";
    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
    this.horiz.firstChild.style.width =
      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
  } else {
    this.horiz.style.display = "";
    this.horiz.firstChild.style.width = "0";
  }

  if (!this.checkedZeroWidth && measure.clientHeight > 0) {
    if (sWidth == 0) { this.zeroWidthHack(); }
    this.checkedZeroWidth = true;
  }

  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
};

NativeScrollbars.prototype.setScrollLeft = function (pos) {
  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
};

NativeScrollbars.prototype.setScrollTop = function (pos) {
  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
};

NativeScrollbars.prototype.zeroWidthHack = function () {
  var w = mac && !mac_geMountainLion ? "12px" : "18px";
  this.horiz.style.height = this.vert.style.width = w;
  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
  this.disableHoriz = new Delayed;
  this.disableVert = new Delayed;
};

NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
  bar.style.pointerEvents = "auto";
  function maybeDisable() {
    // To find out whether the scrollbar is still visible, we
    // check whether the element under the pixel in the bottom
    // right corner of the scrollbar box is the scrollbar box
    // itself (when the bar is still visible) or its filler child
    // (when the bar is hidden). If it is still visible, we keep
    // it enabled, if it's hidden, we disable pointer events.
    var box = bar.getBoundingClientRect();
    var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
    if (elt$$1 != bar) { bar.style.pointerEvents = "none"; }
    else { delay.set(1000, maybeDisable); }
  }
  delay.set(1000, maybeDisable);
};

NativeScrollbars.prototype.clear = function () {
  var parent = this.horiz.parentNode;
  parent.removeChild(this.horiz);
  parent.removeChild(this.vert);
};

var NullScrollbars = function () {};

NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
NullScrollbars.prototype.setScrollLeft = function () {};
NullScrollbars.prototype.setScrollTop = function () {};
NullScrollbars.prototype.clear = function () {};

function updateScrollbars(cm, measure) {
  if (!measure) { measure = measureForScrollbars(cm); }
  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
  updateScrollbarsInner(cm, measure);
  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
      { updateHeightsInViewport(cm); }
    updateScrollbarsInner(cm, measureForScrollbars(cm));
    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
  }
}

// Re-synchronize the fake scrollbars with the actual size of the
// content.
function updateScrollbarsInner(cm, measure) {
  var d = cm.display;
  var sizes = d.scrollbars.update(measure);

  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
  d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

  if (sizes.right && sizes.bottom) {
    d.scrollbarFiller.style.display = "block";
    d.scrollbarFiller.style.height = sizes.bottom + "px";
    d.scrollbarFiller.style.width = sizes.right + "px";
  } else { d.scrollbarFiller.style.display = ""; }
  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
    d.gutterFiller.style.display = "block";
    d.gutterFiller.style.height = sizes.bottom + "px";
    d.gutterFiller.style.width = measure.gutterWidth + "px";
  } else { d.gutterFiller.style.display = ""; }
}

var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

function initScrollbars(cm) {
  if (cm.display.scrollbars) {
    cm.display.scrollbars.clear();
    if (cm.display.scrollbars.addClass)
      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
  }

  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
    // Prevent clicks in the scrollbars from killing focus
    on(node, "mousedown", function () {
      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
    });
    node.setAttribute("cm-not-content", "true");
  }, function (pos, axis) {
    if (axis == "horizontal") { setScrollLeft(cm, pos); }
    else { updateScrollTop(cm, pos); }
  }, cm);
  if (cm.display.scrollbars.addClass)
    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
}

// Operations are used to wrap a series of changes to the editor
// state in such a way that each change won't have to update the
// cursor and display (which would be awkward, slow, and
// error-prone). Instead, display updates are batched and then all
// combined and executed at once.

var nextOpId = 0;
// Start a new operation.
function startOperation(cm) {
  cm.curOp = {
    cm: cm,
    viewChanged: false,      // Flag that indicates that lines might need to be redrawn
    startHeight: cm.doc.height, // Used to detect need to update scrollbar
    forceUpdate: false,      // Used to force a redraw
    updateInput: null,       // Whether to reset the input textarea
    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
    changeObjs: null,        // Accumulated changes, for firing change events
    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
    selectionChanged: false, // Whether the selection needs to be redrawn
    updateMaxLine: false,    // Set when the widest line needs to be determined anew
    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
    scrollToPos: null,       // Used to scroll to a specific position
    focus: false,
    id: ++nextOpId           // Unique ID
  };
  pushOperation(cm.curOp);
}

// Finish an operation, updating the display and signalling delayed events
function endOperation(cm) {
  var op = cm.curOp;
  finishOperation(op, function (group) {
    for (var i = 0; i < group.ops.length; i++)
      { group.ops[i].cm.curOp = null; }
    endOperations(group);
  });
}

// The DOM updates done when an operation finishes are batched so
// that the minimum number of relayouts are required.
function endOperations(group) {
  var ops = group.ops;
  for (var i = 0; i < ops.length; i++) // Read DOM
    { endOperation_R1(ops[i]); }
  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
    { endOperation_W1(ops[i$1]); }
  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
    { endOperation_R2(ops[i$2]); }
  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
    { endOperation_W2(ops[i$3]); }
  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
    { endOperation_finish(ops[i$4]); }
}

function endOperation_R1(op) {
  var cm = op.cm, display = cm.display;
  maybeClipScrollbars(cm);
  if (op.updateMaxLine) { findMaxLine(cm); }

  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                       op.scrollToPos.to.line >= display.viewTo) ||
    display.maxLineChanged && cm.options.lineWrapping;
  op.update = op.mustUpdate &&
    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
}

function endOperation_W1(op) {
  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
}

function endOperation_R2(op) {
  var cm = op.cm, display = cm.display;
  if (op.updatedDisplay) { updateHeightsInViewport(cm); }

  op.barMeasure = measureForScrollbars(cm);

  // If the max line changed since it was last measured, measure it,
  // and ensure the document's width matches it.
  // updateDisplay_W2 will use these properties to do the actual resizing
  if (display.maxLineChanged && !cm.options.lineWrapping) {
    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
    cm.display.sizerWidth = op.adjustWidthTo;
    op.barMeasure.scrollWidth =
      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
  }

  if (op.updatedDisplay || op.selectionChanged)
    { op.preparedSelection = display.input.prepareSelection(); }
}

function endOperation_W2(op) {
  var cm = op.cm;

  if (op.adjustWidthTo != null) {
    cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
    if (op.maxScrollLeft < cm.doc.scrollLeft)
      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
    cm.display.maxLineChanged = false;
  }

  var takeFocus = op.focus && op.focus == activeElt();
  if (op.preparedSelection)
    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
  if (op.updatedDisplay || op.startHeight != cm.doc.height)
    { updateScrollbars(cm, op.barMeasure); }
  if (op.updatedDisplay)
    { setDocumentHeight(cm, op.barMeasure); }

  if (op.selectionChanged) { restartBlink(cm); }

  if (cm.state.focused && op.updateInput)
    { cm.display.input.reset(op.typing); }
  if (takeFocus) { ensureFocus(op.cm); }
}

function endOperation_finish(op) {
  var cm = op.cm, display = cm.display, doc = cm.doc;

  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

  // Abort mouse wheel delta measurement, when scrolling explicitly
  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
    { display.wheelStartX = display.wheelStartY = null; }

  // Propagate the scroll position to the actual DOM scroller
  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
  // If we need to scroll a specific position into view, do so.
  if (op.scrollToPos) {
    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
    maybeScrollWindow(cm, rect);
  }

  // Fire events for markers that are hidden/unidden by editing or
  // undoing
  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
  if (hidden) { for (var i = 0; i < hidden.length; ++i)
    { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

  if (display.wrapper.offsetHeight)
    { doc.scrollTop = cm.display.scroller.scrollTop; }

  // Fire change events, and delayed event handlers
  if (op.changeObjs)
    { signal(cm, "changes", cm, op.changeObjs); }
  if (op.update)
    { op.update.finish(); }
}

// Run the given function in an operation
function runInOp(cm, f) {
  if (cm.curOp) { return f() }
  startOperation(cm);
  try { return f() }
  finally { endOperation(cm); }
}
// Wraps a function in an operation. Returns the wrapped function.
function operation(cm, f) {
  return function() {
    if (cm.curOp) { return f.apply(cm, arguments) }
    startOperation(cm);
    try { return f.apply(cm, arguments) }
    finally { endOperation(cm); }
  }
}
// Used to add methods to editor and doc instances, wrapping them in
// operations.
function methodOp(f) {
  return function() {
    if (this.curOp) { return f.apply(this, arguments) }
    startOperation(this);
    try { return f.apply(this, arguments) }
    finally { endOperation(this); }
  }
}
function docMethodOp(f) {
  return function() {
    var cm = this.cm;
    if (!cm || cm.curOp) { return f.apply(this, arguments) }
    startOperation(cm);
    try { return f.apply(this, arguments) }
    finally { endOperation(cm); }
  }
}

// Updates the display.view data structure for a given change to the
// document. From and to are in pre-change coordinates. Lendiff is
// the amount of lines added or subtracted by the change. This is
// used for changes that span multiple lines, or change the way
// lines are divided into visual lines. regLineChange (below)
// registers single-line changes.
function regChange(cm, from, to, lendiff) {
  if (from == null) { from = cm.doc.first; }
  if (to == null) { to = cm.doc.first + cm.doc.size; }
  if (!lendiff) { lendiff = 0; }

  var display = cm.display;
  if (lendiff && to < display.viewTo &&
      (display.updateLineNumbers == null || display.updateLineNumbers > from))
    { display.updateLineNumbers = from; }

  cm.curOp.viewChanged = true;

  if (from >= display.viewTo) { // Change after
    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
      { resetView(cm); }
  } else if (to <= display.viewFrom) { // Change before
    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
      resetView(cm);
    } else {
      display.viewFrom += lendiff;
      display.viewTo += lendiff;
    }
  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
    resetView(cm);
  } else if (from <= display.viewFrom) { // Top overlap
    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
    if (cut) {
      display.view = display.view.slice(cut.index);
      display.viewFrom = cut.lineN;
      display.viewTo += lendiff;
    } else {
      resetView(cm);
    }
  } else if (to >= display.viewTo) { // Bottom overlap
    var cut$1 = viewCuttingPoint(cm, from, from, -1);
    if (cut$1) {
      display.view = display.view.slice(0, cut$1.index);
      display.viewTo = cut$1.lineN;
    } else {
      resetView(cm);
    }
  } else { // Gap in the middle
    var cutTop = viewCuttingPoint(cm, from, from, -1);
    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
    if (cutTop && cutBot) {
      display.view = display.view.slice(0, cutTop.index)
        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
        .concat(display.view.slice(cutBot.index));
      display.viewTo += lendiff;
    } else {
      resetView(cm);
    }
  }

  var ext = display.externalMeasured;
  if (ext) {
    if (to < ext.lineN)
      { ext.lineN += lendiff; }
    else if (from < ext.lineN + ext.size)
      { display.externalMeasured = null; }
  }
}

// Register a change to a single line. Type must be one of "text",
// "gutter", "class", "widget"
function regLineChange(cm, line, type) {
  cm.curOp.viewChanged = true;
  var display = cm.display, ext = cm.display.externalMeasured;
  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
    { display.externalMeasured = null; }

  if (line < display.viewFrom || line >= display.viewTo) { return }
  var lineView = display.view[findViewIndex(cm, line)];
  if (lineView.node == null) { return }
  var arr = lineView.changes || (lineView.changes = []);
  if (indexOf(arr, type) == -1) { arr.push(type); }
}

// Clear the view.
function resetView(cm) {
  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
  cm.display.view = [];
  cm.display.viewOffset = 0;
}

function viewCuttingPoint(cm, oldN, newN, dir) {
  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
    { return {index: index, lineN: newN} }
  var n = cm.display.viewFrom;
  for (var i = 0; i < index; i++)
    { n += view[i].size; }
  if (n != oldN) {
    if (dir > 0) {
      if (index == view.length - 1) { return null }
      diff = (n + view[index].size) - oldN;
      index++;
    } else {
      diff = n - oldN;
    }
    oldN += diff; newN += diff;
  }
  while (visualLineNo(cm.doc, newN) != newN) {
    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
    index += dir;
  }
  return {index: index, lineN: newN}
}

// Force the view to cover a given range, adding empty view element
// or clipping off existing ones as needed.
function adjustView(cm, from, to) {
  var display = cm.display, view = display.view;
  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
    display.view = buildViewArray(cm, from, to);
    display.viewFrom = from;
  } else {
    if (display.viewFrom > from)
      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
    else if (display.viewFrom < from)
      { display.view = display.view.slice(findViewIndex(cm, from)); }
    display.viewFrom = from;
    if (display.viewTo < to)
      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
    else if (display.viewTo > to)
      { display.view = display.view.slice(0, findViewIndex(cm, to)); }
  }
  display.viewTo = to;
}

// Count the number of lines in the view whose DOM representation is
// out of date (or nonexistent).
function countDirtyView(cm) {
  var view = cm.display.view, dirty = 0;
  for (var i = 0; i < view.length; i++) {
    var lineView = view[i];
    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
  }
  return dirty
}

// HIGHLIGHT WORKER

function startWorker(cm, time) {
  if (cm.doc.highlightFrontier < cm.display.viewTo)
    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
}

function highlightWorker(cm) {
  var doc = cm.doc;
  if (doc.highlightFrontier >= cm.display.viewTo) { return }
  var end = +new Date + cm.options.workTime;
  var context = getContextBefore(cm, doc.highlightFrontier);
  var changedLines = [];

  doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
    if (context.line >= cm.display.viewFrom) { // Visible
      var oldStyles = line.styles;
      var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
      var highlighted = highlightLine(cm, line, context, true);
      if (resetState) { context.state = resetState; }
      line.styles = highlighted.styles;
      var oldCls = line.styleClasses, newCls = highlighted.classes;
      if (newCls) { line.styleClasses = newCls; }
      else if (oldCls) { line.styleClasses = null; }
      var ischange = !oldStyles || oldStyles.length != line.styles.length ||
        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
      if (ischange) { changedLines.push(context.line); }
      line.stateAfter = context.save();
      context.nextLine();
    } else {
      if (line.text.length <= cm.options.maxHighlightLength)
        { processLine(cm, line.text, context); }
      line.stateAfter = context.line % 5 == 0 ? context.save() : null;
      context.nextLine();
    }
    if (+new Date > end) {
      startWorker(cm, cm.options.workDelay);
      return true
    }
  });
  doc.highlightFrontier = context.line;
  doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
  if (changedLines.length) { runInOp(cm, function () {
    for (var i = 0; i < changedLines.length; i++)
      { regLineChange(cm, changedLines[i], "text"); }
  }); }
}

// DISPLAY DRAWING

var DisplayUpdate = function(cm, viewport, force) {
  var display = cm.display;

  this.viewport = viewport;
  // Store some values that we'll need later (but don't want to force a relayout for)
  this.visible = visibleLines(display, cm.doc, viewport);
  this.editorIsHidden = !display.wrapper.offsetWidth;
  this.wrapperHeight = display.wrapper.clientHeight;
  this.wrapperWidth = display.wrapper.clientWidth;
  this.oldDisplayWidth = displayWidth(cm);
  this.force = force;
  this.dims = getDimensions(cm);
  this.events = [];
};

DisplayUpdate.prototype.signal = function (emitter, type) {
  if (hasHandler(emitter, type))
    { this.events.push(arguments); }
};
DisplayUpdate.prototype.finish = function () {
    var this$1 = this;

  for (var i = 0; i < this.events.length; i++)
    { signal.apply(null, this$1.events[i]); }
};

function maybeClipScrollbars(cm) {
  var display = cm.display;
  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
    display.heightForcer.style.height = scrollGap(cm) + "px";
    display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
    display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
    display.scrollbarsClipped = true;
  }
}

function selectionSnapshot(cm) {
  if (cm.hasFocus()) { return null }
  var active = activeElt();
  if (!active || !contains(cm.display.lineDiv, active)) { return null }
  var result = {activeElt: active};
  if (window.getSelection) {
    var sel = window.getSelection();
    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
      result.anchorNode = sel.anchorNode;
      result.anchorOffset = sel.anchorOffset;
      result.focusNode = sel.focusNode;
      result.focusOffset = sel.focusOffset;
    }
  }
  return result
}

function restoreSelection(snapshot) {
  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
  snapshot.activeElt.focus();
  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
    var sel = window.getSelection(), range$$1 = document.createRange();
    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
    range$$1.collapse(false);
    sel.removeAllRanges();
    sel.addRange(range$$1);
    sel.extend(snapshot.focusNode, snapshot.focusOffset);
  }
}

// Does the actual updating of the line display. Bails out
// (returning false) when there is nothing to be done and forced is
// false.
function updateDisplayIfNeeded(cm, update) {
  var display = cm.display, doc = cm.doc;

  if (update.editorIsHidden) {
    resetView(cm);
    return false
  }

  // Bail out if the visible area is already rendered and nothing changed.
  if (!update.force &&
      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
      display.renderedView == display.view && countDirtyView(cm) == 0)
    { return false }

  if (maybeUpdateLineNumberWidth(cm)) {
    resetView(cm);
    update.dims = getDimensions(cm);
  }

  // Compute a suitable new viewport (from & to)
  var end = doc.first + doc.size;
  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
  if (sawCollapsedSpans) {
    from = visualLineNo(cm.doc, from);
    to = visualLineEndNo(cm.doc, to);
  }

  var different = from != display.viewFrom || to != display.viewTo ||
    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
  adjustView(cm, from, to);

  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
  // Position the mover div to align with the current scroll position
  cm.display.mover.style.top = display.viewOffset + "px";

  var toUpdate = countDirtyView(cm);
  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
    { return false }

  // For big changes, we hide the enclosing element during the
  // update, since that speeds up the operations on most browsers.
  var selSnapshot = selectionSnapshot(cm);
  if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
  patchDisplay(cm, display.updateLineNumbers, update.dims);
  if (toUpdate > 4) { display.lineDiv.style.display = ""; }
  display.renderedView = display.view;
  // There might have been a widget with a focused element that got
  // hidden or updated, if so re-focus it.
  restoreSelection(selSnapshot);

  // Prevent selection and cursors from interfering with the scroll
  // width and height.
  removeChildren(display.cursorDiv);
  removeChildren(display.selectionDiv);
  display.gutters.style.height = display.sizer.style.minHeight = 0;

  if (different) {
    display.lastWrapHeight = update.wrapperHeight;
    display.lastWrapWidth = update.wrapperWidth;
    startWorker(cm, 400);
  }

  display.updateLineNumbers = null;

  return true
}

function postUpdateDisplay(cm, update) {
  var viewport = update.viewport;

  for (var first = true;; first = false) {
    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
      // Clip forced viewport to actual scrollable area.
      if (viewport && viewport.top != null)
        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
      // Updated line heights might result in the drawn area not
      // actually covering the viewport. Keep looping until it does.
      update.visible = visibleLines(cm.display, cm.doc, viewport);
      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
        { break }
    }
    if (!updateDisplayIfNeeded(cm, update)) { break }
    updateHeightsInViewport(cm);
    var barMeasure = measureForScrollbars(cm);
    updateSelection(cm);
    updateScrollbars(cm, barMeasure);
    setDocumentHeight(cm, barMeasure);
    update.force = false;
  }

  update.signal(cm, "update", cm);
  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
    update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
  }
}

function updateDisplaySimple(cm, viewport) {
  var update = new DisplayUpdate(cm, viewport);
  if (updateDisplayIfNeeded(cm, update)) {
    updateHeightsInViewport(cm);
    postUpdateDisplay(cm, update);
    var barMeasure = measureForScrollbars(cm);
    updateSelection(cm);
    updateScrollbars(cm, barMeasure);
    setDocumentHeight(cm, barMeasure);
    update.finish();
  }
}

// Sync the actual display DOM structure with display.view, removing
// nodes for lines that are no longer in view, and creating the ones
// that are not there yet, and updating the ones that are out of
// date.
function patchDisplay(cm, updateNumbersFrom, dims) {
  var display = cm.display, lineNumbers = cm.options.lineNumbers;
  var container = display.lineDiv, cur = container.firstChild;

  function rm(node) {
    var next = node.nextSibling;
    // Works around a throw-scroll bug in OS X Webkit
    if (webkit && mac && cm.display.currentWheelTarget == node)
      { node.style.display = "none"; }
    else
      { node.parentNode.removeChild(node); }
    return next
  }

  var view = display.view, lineN = display.viewFrom;
  // Loop over the elements in the view, syncing cur (the DOM nodes
  // in display.lineDiv) with the view as we go.
  for (var i = 0; i < view.length; i++) {
    var lineView = view[i];
    if (lineView.hidden) {
    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
      var node = buildLineElement(cm, lineView, lineN, dims);
      container.insertBefore(node, cur);
    } else { // Already drawn
      while (cur != lineView.node) { cur = rm(cur); }
      var updateNumber = lineNumbers && updateNumbersFrom != null &&
        updateNumbersFrom <= lineN && lineView.lineNumber;
      if (lineView.changes) {
        if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
        updateLineForChanges(cm, lineView, lineN, dims);
      }
      if (updateNumber) {
        removeChildren(lineView.lineNumber);
        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
      }
      cur = lineView.node.nextSibling;
    }
    lineN += lineView.size;
  }
  while (cur) { cur = rm(cur); }
}

function updateGutterSpace(cm) {
  var width = cm.display.gutters.offsetWidth;
  cm.display.sizer.style.marginLeft = width + "px";
}

function setDocumentHeight(cm, measure) {
  cm.display.sizer.style.minHeight = measure.docHeight + "px";
  cm.display.heightForcer.style.top = measure.docHeight + "px";
  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
}

// Rebuild the gutter elements, ensure the margin to the left of the
// code matches their width.
function updateGutters(cm) {
  var gutters = cm.display.gutters, specs = cm.options.gutters;
  removeChildren(gutters);
  var i = 0;
  for (; i < specs.length; ++i) {
    var gutterClass = specs[i];
    var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
    if (gutterClass == "CodeMirror-linenumbers") {
      cm.display.lineGutter = gElt;
      gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
    }
  }
  gutters.style.display = i ? "" : "none";
  updateGutterSpace(cm);
}

// Make sure the gutters options contains the element
// "CodeMirror-linenumbers" when the lineNumbers option is true.
function setGuttersForLineNumbers(options) {
  var found = indexOf(options.gutters, "CodeMirror-linenumbers");
  if (found == -1 && options.lineNumbers) {
    options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
  } else if (found > -1 && !options.lineNumbers) {
    options.gutters = options.gutters.slice(0);
    options.gutters.splice(found, 1);
  }
}

// Since the delta values reported on mouse wheel events are
// unstandardized between browsers and even browser versions, and
// generally horribly unpredictable, this code starts by measuring
// the scroll effect that the first few mouse wheel events have,
// and, from that, detects the way it can convert deltas to pixel
// offsets afterwards.
//
// The reason we want to know the amount a wheel event will scroll
// is that it gives us a chance to update the display before the
// actual scrolling happens, reducing flickering.

var wheelSamples = 0;
var wheelPixelsPerUnit = null;
// Fill in a browser-detected starting value on browsers where we
// know one. These don't have to be accurate -- the result of them
// being wrong would just be a slight flicker on the first wheel
// scroll (if it is large enough).
if (ie) { wheelPixelsPerUnit = -.53; }
else if (gecko) { wheelPixelsPerUnit = 15; }
else if (chrome) { wheelPixelsPerUnit = -.7; }
else if (safari) { wheelPixelsPerUnit = -1/3; }

function wheelEventDelta(e) {
  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
  else if (dy == null) { dy = e.wheelDelta; }
  return {x: dx, y: dy}
}
function wheelEventPixels(e) {
  var delta = wheelEventDelta(e);
  delta.x *= wheelPixelsPerUnit;
  delta.y *= wheelPixelsPerUnit;
  return delta
}

function onScrollWheel(cm, e) {
  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

  var display = cm.display, scroll = display.scroller;
  // Quit if there's nothing to scroll here
  var canScrollX = scroll.scrollWidth > scroll.clientWidth;
  var canScrollY = scroll.scrollHeight > scroll.clientHeight;
  if (!(dx && canScrollX || dy && canScrollY)) { return }

  // Webkit browsers on OS X abort momentum scrolls when the target
  // of the scroll event is removed from the scrollable element.
  // This hack (see related code in patchDisplay) makes sure the
  // element is kept around.
  if (dy && mac && webkit) {
    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
      for (var i = 0; i < view.length; i++) {
        if (view[i].node == cur) {
          cm.display.currentWheelTarget = cur;
          break outer
        }
      }
    }
  }

  // On some browsers, horizontal scrolling will cause redraws to
  // happen before the gutter has been realigned, causing it to
  // wriggle around in a most unseemly way. When we have an
  // estimated pixels/delta value, we just handle horizontal
  // scrolling entirely here. It'll be slightly off from native, but
  // better than glitching out.
  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
    if (dy && canScrollY)
      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
    // Only prevent default scrolling if vertical scrolling is
    // actually possible. Otherwise, it causes vertical scroll
    // jitter on OSX trackpads when deltaX is small and deltaY
    // is large (issue #3579)
    if (!dy || (dy && canScrollY))
      { e_preventDefault(e); }
    display.wheelStartX = null; // Abort measurement, if in progress
    return
  }

  // 'Project' the visible viewport to cover the area that is being
  // scrolled into view (if we know enough to estimate it).
  if (dy && wheelPixelsPerUnit != null) {
    var pixels = dy * wheelPixelsPerUnit;
    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
    updateDisplaySimple(cm, {top: top, bottom: bot});
  }

  if (wheelSamples < 20) {
    if (display.wheelStartX == null) {
      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
      display.wheelDX = dx; display.wheelDY = dy;
      setTimeout(function () {
        if (display.wheelStartX == null) { return }
        var movedX = scroll.scrollLeft - display.wheelStartX;
        var movedY = scroll.scrollTop - display.wheelStartY;
        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
          (movedX && display.wheelDX && movedX / display.wheelDX);
        display.wheelStartX = display.wheelStartY = null;
        if (!sample) { return }
        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
        ++wheelSamples;
      }, 200);
    } else {
      display.wheelDX += dx; display.wheelDY += dy;
    }
  }
}

// Selection objects are immutable. A new one is created every time
// the selection changes. A selection is one or more non-overlapping
// (and non-touching) ranges, sorted, and an integer that indicates
// which one is the primary selection (the one that's scrolled into
// view, that getCursor returns, etc).
var Selection = function(ranges, primIndex) {
  this.ranges = ranges;
  this.primIndex = primIndex;
};

Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

Selection.prototype.equals = function (other) {
    var this$1 = this;

  if (other == this) { return true }
  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
  for (var i = 0; i < this.ranges.length; i++) {
    var here = this$1.ranges[i], there = other.ranges[i];
    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
  }
  return true
};

Selection.prototype.deepCopy = function () {
    var this$1 = this;

  var out = [];
  for (var i = 0; i < this.ranges.length; i++)
    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }
  return new Selection(out, this.primIndex)
};

Selection.prototype.somethingSelected = function () {
    var this$1 = this;

  for (var i = 0; i < this.ranges.length; i++)
    { if (!this$1.ranges[i].empty()) { return true } }
  return false
};

Selection.prototype.contains = function (pos, end) {
    var this$1 = this;

  if (!end) { end = pos; }
  for (var i = 0; i < this.ranges.length; i++) {
    var range = this$1.ranges[i];
    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
      { return i }
  }
  return -1
};

var Range = function(anchor, head) {
  this.anchor = anchor; this.head = head;
};

Range.prototype.from = function () { return minPos(this.anchor, this.head) };
Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

// Take an unsorted, potentially overlapping set of ranges, and
// build a selection out of it. 'Consumes' ranges array (modifying
// it).
function normalizeSelection(ranges, primIndex) {
  var prim = ranges[primIndex];
  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
  primIndex = indexOf(ranges, prim);
  for (var i = 1; i < ranges.length; i++) {
    var cur = ranges[i], prev = ranges[i - 1];
    if (cmp(prev.to(), cur.from()) >= 0) {
      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
      if (i <= primIndex) { --primIndex; }
      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
    }
  }
  return new Selection(ranges, primIndex)
}

function simpleSelection(anchor, head) {
  return new Selection([new Range(anchor, head || anchor)], 0)
}

// Compute the position of the end of a change (its 'to' property
// refers to the pre-change end).
function changeEnd(change) {
  if (!change.text) { return change.to }
  return Pos(change.from.line + change.text.length - 1,
             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
}

// Adjust a position to refer to the post-change position of the
// same text, or the end of the change if the change covers it.
function adjustForChange(pos, change) {
  if (cmp(pos, change.from) < 0) { return pos }
  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
  return Pos(line, ch)
}

function computeSelAfterChange(doc, change) {
  var out = [];
  for (var i = 0; i < doc.sel.ranges.length; i++) {
    var range = doc.sel.ranges[i];
    out.push(new Range(adjustForChange(range.anchor, change),
                       adjustForChange(range.head, change)));
  }
  return normalizeSelection(out, doc.sel.primIndex)
}

function offsetPos(pos, old, nw) {
  if (pos.line == old.line)
    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
  else
    { return Pos(nw.line + (pos.line - old.line), pos.ch) }
}

// Used by replaceSelections to allow moving the selection to the
// start or around the replaced test. Hint may be "start" or "around".
function computeReplacedSel(doc, changes, hint) {
  var out = [];
  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];
    var from = offsetPos(change.from, oldPrev, newPrev);
    var to = offsetPos(changeEnd(change), oldPrev, newPrev);
    oldPrev = change.to;
    newPrev = to;
    if (hint == "around") {
      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
      out[i] = new Range(inv ? to : from, inv ? from : to);
    } else {
      out[i] = new Range(from, from);
    }
  }
  return new Selection(out, doc.sel.primIndex)
}

// Used to get the editor into a consistent state again when options change.

function loadMode(cm) {
  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
  resetModeState(cm);
}

function resetModeState(cm) {
  cm.doc.iter(function (line) {
    if (line.stateAfter) { line.stateAfter = null; }
    if (line.styles) { line.styles = null; }
  });
  cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
  startWorker(cm, 100);
  cm.state.modeGen++;
  if (cm.curOp) { regChange(cm); }
}

// DOCUMENT DATA STRUCTURE

// By default, updates that start and end at the beginning of a line
// are treated specially, in order to make the association of line
// widgets and marker elements with the text behave more intuitive.
function isWholeLineUpdate(doc, change) {
  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
}

// Perform a change on the document data structure.
function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
  function spansFor(n) {return markedSpans ? markedSpans[n] : null}
  function update(line, text, spans) {
    updateLine(line, text, spans, estimateHeight$$1);
    signalLater(line, "change", line, change);
  }
  function linesFor(start, end) {
    var result = [];
    for (var i = start; i < end; ++i)
      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }
    return result
  }

  var from = change.from, to = change.to, text = change.text;
  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

  // Adjust the line structure
  if (change.full) {
    doc.insert(0, linesFor(0, text.length));
    doc.remove(text.length, doc.size - text.length);
  } else if (isWholeLineUpdate(doc, change)) {
    // This is a whole-line replace. Treated specially to make
    // sure line objects move the way they are supposed to.
    var added = linesFor(0, text.length - 1);
    update(lastLine, lastLine.text, lastSpans);
    if (nlines) { doc.remove(from.line, nlines); }
    if (added.length) { doc.insert(from.line, added); }
  } else if (firstLine == lastLine) {
    if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
    } else {
      var added$1 = linesFor(1, text.length - 1);
      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      doc.insert(from.line + 1, added$1);
    }
  } else if (text.length == 1) {
    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
    doc.remove(from.line + 1, nlines);
  } else {
    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
    var added$2 = linesFor(1, text.length - 1);
    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
    doc.insert(from.line + 1, added$2);
  }

  signalLater(doc, "change", doc, change);
}

// Call f for all linked documents.
function linkedDocs(doc, f, sharedHistOnly) {
  function propagate(doc, skip, sharedHist) {
    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
      var rel = doc.linked[i];
      if (rel.doc == skip) { continue }
      var shared = sharedHist && rel.sharedHist;
      if (sharedHistOnly && !shared) { continue }
      f(rel.doc, shared);
      propagate(rel.doc, doc, shared);
    } }
  }
  propagate(doc, null, true);
}

// Attach a document to an editor.
function attachDoc(cm, doc) {
  if (doc.cm) { throw new Error("This document is already in use.") }
  cm.doc = doc;
  doc.cm = cm;
  estimateLineHeights(cm);
  loadMode(cm);
  setDirectionClass(cm);
  if (!cm.options.lineWrapping) { findMaxLine(cm); }
  cm.options.mode = doc.modeOption;
  regChange(cm);
}

function setDirectionClass(cm) {
  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
}

function directionChanged(cm) {
  runInOp(cm, function () {
    setDirectionClass(cm);
    regChange(cm);
  });
}

function History(startGen) {
  // Arrays of change events and selections. Doing something adds an
  // event to done and clears undo. Undoing moves events from done
  // to undone, redoing moves them in the other direction.
  this.done = []; this.undone = [];
  this.undoDepth = Infinity;
  // Used to track when changes can be merged into a single undo
  // event
  this.lastModTime = this.lastSelTime = 0;
  this.lastOp = this.lastSelOp = null;
  this.lastOrigin = this.lastSelOrigin = null;
  // Used by the isClean() method
  this.generation = this.maxGeneration = startGen || 1;
}

// Create a history change event from an updateDoc-style change
// object.
function historyChangeFromChange(doc, change) {
  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
  return histChange
}

// Pop all selection events off the end of a history array. Stop at
// a change event.
function clearSelectionEvents(array) {
  while (array.length) {
    var last = lst(array);
    if (last.ranges) { array.pop(); }
    else { break }
  }
}

// Find the top change event in the history. Pop off selection
// events that are in the way.
function lastChangeEvent(hist, force) {
  if (force) {
    clearSelectionEvents(hist.done);
    return lst(hist.done)
  } else if (hist.done.length && !lst(hist.done).ranges) {
    return lst(hist.done)
  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
    hist.done.pop();
    return lst(hist.done)
  }
}

// Register a change in the history. Merges changes that are within
// a single operation, or are close together with an origin that
// allows merging (starting with "+") into a single event.
function addChangeToHistory(doc, change, selAfter, opId) {
  var hist = doc.history;
  hist.undone.length = 0;
  var time = +new Date, cur;
  var last;

  if ((hist.lastOp == opId ||
       hist.lastOrigin == change.origin && change.origin &&
       ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
        change.origin.charAt(0) == "*")) &&
      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
    // Merge this change into the last event
    last = lst(cur.changes);
    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
      // Optimized case for simple insertion -- don't want to add
      // new changesets for every character typed
      last.to = changeEnd(change);
    } else {
      // Add new sub-event
      cur.changes.push(historyChangeFromChange(doc, change));
    }
  } else {
    // Can not be merged, start a new event.
    var before = lst(hist.done);
    if (!before || !before.ranges)
      { pushSelectionToHistory(doc.sel, hist.done); }
    cur = {changes: [historyChangeFromChange(doc, change)],
           generation: hist.generation};
    hist.done.push(cur);
    while (hist.done.length > hist.undoDepth) {
      hist.done.shift();
      if (!hist.done[0].ranges) { hist.done.shift(); }
    }
  }
  hist.done.push(selAfter);
  hist.generation = ++hist.maxGeneration;
  hist.lastModTime = hist.lastSelTime = time;
  hist.lastOp = hist.lastSelOp = opId;
  hist.lastOrigin = hist.lastSelOrigin = change.origin;

  if (!last) { signal(doc, "historyAdded"); }
}

function selectionEventCanBeMerged(doc, origin, prev, sel) {
  var ch = origin.charAt(0);
  return ch == "*" ||
    ch == "+" &&
    prev.ranges.length == sel.ranges.length &&
    prev.somethingSelected() == sel.somethingSelected() &&
    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
}

// Called whenever the selection changes, sets the new selection as
// the pending selection in the history, and pushes the old pending
// selection into the 'done' array when it was significantly
// different (in number of selected ranges, emptiness, or time).
function addSelectionToHistory(doc, sel, opId, options) {
  var hist = doc.history, origin = options && options.origin;

  // A new event is started when the previous origin does not match
  // the current, or the origins don't allow matching. Origins
  // starting with * are always merged, those starting with + are
  // merged when similar and close together in time.
  if (opId == hist.lastSelOp ||
      (origin && hist.lastSelOrigin == origin &&
       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
    { hist.done[hist.done.length - 1] = sel; }
  else
    { pushSelectionToHistory(sel, hist.done); }

  hist.lastSelTime = +new Date;
  hist.lastSelOrigin = origin;
  hist.lastSelOp = opId;
  if (options && options.clearRedo !== false)
    { clearSelectionEvents(hist.undone); }
}

function pushSelectionToHistory(sel, dest) {
  var top = lst(dest);
  if (!(top && top.ranges && top.equals(sel)))
    { dest.push(sel); }
}

// Used to store marked span information in the history.
function attachLocalSpans(doc, change, from, to) {
  var existing = change["spans_" + doc.id], n = 0;
  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
    if (line.markedSpans)
      { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
    ++n;
  });
}

// When un/re-doing restores text containing marked spans, those
// that have been explicitly cleared should not be restored.
function removeClearedSpans(spans) {
  if (!spans) { return null }
  var out;
  for (var i = 0; i < spans.length; ++i) {
    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
    else if (out) { out.push(spans[i]); }
  }
  return !out ? spans : out.length ? out : null
}

// Retrieve and filter the old marked spans stored in a change event.
function getOldSpans(doc, change) {
  var found = change["spans_" + doc.id];
  if (!found) { return null }
  var nw = [];
  for (var i = 0; i < change.text.length; ++i)
    { nw.push(removeClearedSpans(found[i])); }
  return nw
}

// Used for un/re-doing changes from the history. Combines the
// result of computing the existing spans with the set of spans that
// existed in the history (so that deleting around a span and then
// undoing brings back the span).
function mergeOldSpans(doc, change) {
  var old = getOldSpans(doc, change);
  var stretched = stretchSpansOverChange(doc, change);
  if (!old) { return stretched }
  if (!stretched) { return old }

  for (var i = 0; i < old.length; ++i) {
    var oldCur = old[i], stretchCur = stretched[i];
    if (oldCur && stretchCur) {
      spans: for (var j = 0; j < stretchCur.length; ++j) {
        var span = stretchCur[j];
        for (var k = 0; k < oldCur.length; ++k)
          { if (oldCur[k].marker == span.marker) { continue spans } }
        oldCur.push(span);
      }
    } else if (stretchCur) {
      old[i] = stretchCur;
    }
  }
  return old
}

// Used both to provide a JSON-safe object in .getHistory, and, when
// detaching a document, to split the history in two
function copyHistoryArray(events, newGroup, instantiateSel) {
  var copy = [];
  for (var i = 0; i < events.length; ++i) {
    var event = events[i];
    if (event.ranges) {
      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
      continue
    }
    var changes = event.changes, newChanges = [];
    copy.push({changes: newChanges});
    for (var j = 0; j < changes.length; ++j) {
      var change = changes[j], m = (void 0);
      newChanges.push({from: change.from, to: change.to, text: change.text});
      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
        if (indexOf(newGroup, Number(m[1])) > -1) {
          lst(newChanges)[prop] = change[prop];
          delete change[prop];
        }
      } } }
    }
  }
  return copy
}

// The 'scroll' parameter given to many of these indicated whether
// the new cursor position should be scrolled into view after
// modifying the selection.

// If shift is held or the extend flag is set, extends a range to
// include a given position (and optionally a second position).
// Otherwise, simply returns the range between the given positions.
// Used for cursor motion and such.
function extendRange(range, head, other, extend) {
  if (extend) {
    var anchor = range.anchor;
    if (other) {
      var posBefore = cmp(head, anchor) < 0;
      if (posBefore != (cmp(other, anchor) < 0)) {
        anchor = head;
        head = other;
      } else if (posBefore != (cmp(head, other) < 0)) {
        head = other;
      }
    }
    return new Range(anchor, head)
  } else {
    return new Range(other || head, head)
  }
}

// Extend the primary selection range, discard the rest.
function extendSelection(doc, head, other, options, extend) {
  if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
  setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
}

// Extend all selections (pos is an array of selections with length
// equal the number of selections)
function extendSelections(doc, heads, options) {
  var out = [];
  var extend = doc.cm && (doc.cm.display.shift || doc.extend);
  for (var i = 0; i < doc.sel.ranges.length; i++)
    { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
  var newSel = normalizeSelection(out, doc.sel.primIndex);
  setSelection(doc, newSel, options);
}

// Updates a single range in the selection.
function replaceOneSelection(doc, i, range, options) {
  var ranges = doc.sel.ranges.slice(0);
  ranges[i] = range;
  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
}

// Reset the selection to a single range.
function setSimpleSelection(doc, anchor, head, options) {
  setSelection(doc, simpleSelection(anchor, head), options);
}

// Give beforeSelectionChange handlers a change to influence a
// selection update.
function filterSelectionChange(doc, sel, options) {
  var obj = {
    ranges: sel.ranges,
    update: function(ranges) {
      var this$1 = this;

      this.ranges = [];
      for (var i = 0; i < ranges.length; i++)
        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                   clipPos(doc, ranges[i].head)); }
    },
    origin: options && options.origin
  };
  signal(doc, "beforeSelectionChange", doc, obj);
  if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }
  else { return sel }
}

function setSelectionReplaceHistory(doc, sel, options) {
  var done = doc.history.done, last = lst(done);
  if (last && last.ranges) {
    done[done.length - 1] = sel;
    setSelectionNoUndo(doc, sel, options);
  } else {
    setSelection(doc, sel, options);
  }
}

// Set a new selection.
function setSelection(doc, sel, options) {
  setSelectionNoUndo(doc, sel, options);
  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
}

function setSelectionNoUndo(doc, sel, options) {
  if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
    { sel = filterSelectionChange(doc, sel, options); }

  var bias = options && options.bias ||
    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

  if (!(options && options.scroll === false) && doc.cm)
    { ensureCursorVisible(doc.cm); }
}

function setSelectionInner(doc, sel) {
  if (sel.equals(doc.sel)) { return }

  doc.sel = sel;

  if (doc.cm) {
    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
    signalCursorActivity(doc.cm);
  }
  signalLater(doc, "cursorActivity", doc);
}

// Verify that the selection does not partially select any atomic
// marked ranges.
function reCheckSelection(doc) {
  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
}

// Return a selection that does not partially select any atomic
// ranges.
function skipAtomicInSelection(doc, sel, bias, mayClear) {
  var out;
  for (var i = 0; i < sel.ranges.length; i++) {
    var range = sel.ranges[i];
    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
    if (out || newAnchor != range.anchor || newHead != range.head) {
      if (!out) { out = sel.ranges.slice(0, i); }
      out[i] = new Range(newAnchor, newHead);
    }
  }
  return out ? normalizeSelection(out, sel.primIndex) : sel
}

function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
  var line = getLine(doc, pos.line);
  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
    var sp = line.markedSpans[i], m = sp.marker;
    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
      if (mayClear) {
        signal(m, "beforeCursorEnter");
        if (m.explicitlyCleared) {
          if (!line.markedSpans) { break }
          else {--i; continue}
        }
      }
      if (!m.atomic) { continue }

      if (oldPos) {
        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
          { return skipAtomicInner(doc, near, pos, dir, mayClear) }
      }

      var far = m.find(dir < 0 ? -1 : 1);
      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
    }
  } }
  return pos
}

// Ensure a given position is not inside an atomic range.
function skipAtomic(doc, pos, oldPos, bias, mayClear) {
  var dir = bias || 1;
  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
  if (!found) {
    doc.cantEdit = true;
    return Pos(doc.first, 0)
  }
  return found
}

function movePos(doc, pos, dir, line) {
  if (dir < 0 && pos.ch == 0) {
    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
    else { return null }
  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
    else { return null }
  } else {
    return new Pos(pos.line, pos.ch + dir)
  }
}

function selectAll(cm) {
  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
}

// UPDATING

// Allow "beforeChange" event handlers to influence a change
function filterChange(doc, change, update) {
  var obj = {
    canceled: false,
    from: change.from,
    to: change.to,
    text: change.text,
    origin: change.origin,
    cancel: function () { return obj.canceled = true; }
  };
  if (update) { obj.update = function (from, to, text, origin) {
    if (from) { obj.from = clipPos(doc, from); }
    if (to) { obj.to = clipPos(doc, to); }
    if (text) { obj.text = text; }
    if (origin !== undefined) { obj.origin = origin; }
  }; }
  signal(doc, "beforeChange", doc, obj);
  if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

  if (obj.canceled) { return null }
  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
}

// Apply a change to a document, and add it to the document's
// history, and propagating it to all linked documents.
function makeChange(doc, change, ignoreReadOnly) {
  if (doc.cm) {
    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
    if (doc.cm.state.suppressEdits) { return }
  }

  if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
    change = filterChange(doc, change, true);
    if (!change) { return }
  }

  // Possibly split or suppress the update based on the presence
  // of read-only spans in its range.
  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
  if (split) {
    for (var i = split.length - 1; i >= 0; --i)
      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
  } else {
    makeChangeInner(doc, change);
  }
}

function makeChangeInner(doc, change) {
  if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
  var selAfter = computeSelAfterChange(doc, change);
  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
  var rebased = [];

  linkedDocs(doc, function (doc, sharedHist) {
    if (!sharedHist && indexOf(rebased, doc.history) == -1) {
      rebaseHist(doc.history, change);
      rebased.push(doc.history);
    }
    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
  });
}

// Revert a change stored in a document's history.
function makeChangeFromHistory(doc, type, allowSelectionOnly) {
  var suppress = doc.cm && doc.cm.state.suppressEdits;
  if (suppress && !allowSelectionOnly) { return }

  var hist = doc.history, event, selAfter = doc.sel;
  var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

  // Verify that there is a useable event (so that ctrl-z won't
  // needlessly clear selection events)
  var i = 0;
  for (; i < source.length; i++) {
    event = source[i];
    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
      { break }
  }
  if (i == source.length) { return }
  hist.lastOrigin = hist.lastSelOrigin = null;

  for (;;) {
    event = source.pop();
    if (event.ranges) {
      pushSelectionToHistory(event, dest);
      if (allowSelectionOnly && !event.equals(doc.sel)) {
        setSelection(doc, event, {clearRedo: false});
        return
      }
      selAfter = event;
    } else if (suppress) {
      source.push(event);
      return
    } else { break }
  }

  // Build up a reverse change object to add to the opposite history
  // stack (redo when undoing, and vice versa).
  var antiChanges = [];
  pushSelectionToHistory(selAfter, dest);
  dest.push({changes: antiChanges, generation: hist.generation});
  hist.generation = event.generation || ++hist.maxGeneration;

  var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

  var loop = function ( i ) {
    var change = event.changes[i];
    change.origin = type;
    if (filter && !filterChange(doc, change, false)) {
      source.length = 0;
      return {}
    }

    antiChanges.push(historyChangeFromChange(doc, change));

    var after = i ? computeSelAfterChange(doc, change) : lst(source);
    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
    var rebased = [];

    // Propagate to the linked documents
    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
    });
  };

  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
    var returned = loop( i$1 );

    if ( returned ) return returned.v;
  }
}

// Sub-views need their line numbers shifted when text is added
// above or below them in the parent document.
function shiftDoc(doc, distance) {
  if (distance == 0) { return }
  doc.first += distance;
  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
    Pos(range.anchor.line + distance, range.anchor.ch),
    Pos(range.head.line + distance, range.head.ch)
  ); }), doc.sel.primIndex);
  if (doc.cm) {
    regChange(doc.cm, doc.first, doc.first - distance, distance);
    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
      { regLineChange(doc.cm, l, "gutter"); }
  }
}

// More lower-level change function, handling only a single document
// (not linked ones).
function makeChangeSingleDoc(doc, change, selAfter, spans) {
  if (doc.cm && !doc.cm.curOp)
    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

  if (change.to.line < doc.first) {
    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
    return
  }
  if (change.from.line > doc.lastLine()) { return }

  // Clip the change to the size of this doc
  if (change.from.line < doc.first) {
    var shift = change.text.length - 1 - (doc.first - change.from.line);
    shiftDoc(doc, shift);
    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
              text: [lst(change.text)], origin: change.origin};
  }
  var last = doc.lastLine();
  if (change.to.line > last) {
    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
              text: [change.text[0]], origin: change.origin};
  }

  change.removed = getBetween(doc, change.from, change.to);

  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
  else { updateDoc(doc, change, spans); }
  setSelectionNoUndo(doc, selAfter, sel_dontScroll);
}

// Handle the interaction of a change to a document with the editor
// that this document is part of.
function makeChangeSingleDocInEditor(cm, change, spans) {
  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

  var recomputeMaxLength = false, checkWidthStart = from.line;
  if (!cm.options.lineWrapping) {
    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
    doc.iter(checkWidthStart, to.line + 1, function (line) {
      if (line == display.maxLine) {
        recomputeMaxLength = true;
        return true
      }
    });
  }

  if (doc.sel.contains(change.from, change.to) > -1)
    { signalCursorActivity(cm); }

  updateDoc(doc, change, spans, estimateHeight(cm));

  if (!cm.options.lineWrapping) {
    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
      var len = lineLength(line);
      if (len > display.maxLineLength) {
        display.maxLine = line;
        display.maxLineLength = len;
        display.maxLineChanged = true;
        recomputeMaxLength = false;
      }
    });
    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
  }

  retreatFrontier(doc, from.line);
  startWorker(cm, 400);

  var lendiff = change.text.length - (to.line - from.line) - 1;
  // Remember that these lines changed, for updating the display
  if (change.full)
    { regChange(cm); }
  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
    { regLineChange(cm, from.line, "text"); }
  else
    { regChange(cm, from.line, to.line + 1, lendiff); }

  var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
  if (changeHandler || changesHandler) {
    var obj = {
      from: from, to: to,
      text: change.text,
      removed: change.removed,
      origin: change.origin
    };
    if (changeHandler) { signalLater(cm, "change", cm, obj); }
    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
  }
  cm.display.selForContextMenu = null;
}

function replaceRange(doc, code, from, to, origin) {
  if (!to) { to = from; }
  if (cmp(to, from) < 0) { var assign;
    (assign = [to, from], from = assign[0], to = assign[1]); }
  if (typeof code == "string") { code = doc.splitLines(code); }
  makeChange(doc, {from: from, to: to, text: code, origin: origin});
}

// Rebasing/resetting history to deal with externally-sourced changes

function rebaseHistSelSingle(pos, from, to, diff) {
  if (to < pos.line) {
    pos.line += diff;
  } else if (from < pos.line) {
    pos.line = from;
    pos.ch = 0;
  }
}

// Tries to rebase an array of history events given a change in the
// document. If the change touches the same lines as the event, the
// event, and everything 'behind' it, is discarded. If the change is
// before the event, the event's positions are updated. Uses a
// copy-on-write scheme for the positions, to avoid having to
// reallocate them all on every rebase, but also avoid problems with
// shared position objects being unsafely updated.
function rebaseHistArray(array, from, to, diff) {
  for (var i = 0; i < array.length; ++i) {
    var sub = array[i], ok = true;
    if (sub.ranges) {
      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
      for (var j = 0; j < sub.ranges.length; j++) {
        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
      }
      continue
    }
    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
      var cur = sub.changes[j$1];
      if (to < cur.from.line) {
        cur.from = Pos(cur.from.line + diff, cur.from.ch);
        cur.to = Pos(cur.to.line + diff, cur.to.ch);
      } else if (from <= cur.to.line) {
        ok = false;
        break
      }
    }
    if (!ok) {
      array.splice(0, i + 1);
      i = 0;
    }
  }
}

function rebaseHist(hist, change) {
  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
  rebaseHistArray(hist.done, from, to, diff);
  rebaseHistArray(hist.undone, from, to, diff);
}

// Utility for applying a change to a line by handle or number,
// returning the number and optionally registering the line as
// changed.
function changeLine(doc, handle, changeType, op) {
  var no = handle, line = handle;
  if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
  else { no = lineNo(handle); }
  if (no == null) { return null }
  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
  return line
}

// The document is represented as a BTree consisting of leaves, with
// chunk of lines in them, and branches, with up to ten leaves or
// other branch nodes below them. The top node is always a branch
// node, and is the document object itself (meaning it has
// additional methods and properties).
//
// All nodes have parent links. The tree is used both to go from
// line numbers to line objects, and to go from objects to numbers.
// It also indexes by height, and is used to convert between height
// and line object, and to find the total height of the document.
//
// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

function LeafChunk(lines) {
  var this$1 = this;

  this.lines = lines;
  this.parent = null;
  var height = 0;
  for (var i = 0; i < lines.length; ++i) {
    lines[i].parent = this$1;
    height += lines[i].height;
  }
  this.height = height;
}

LeafChunk.prototype = {
  chunkSize: function() { return this.lines.length },

  // Remove the n lines at offset 'at'.
  removeInner: function(at, n) {
    var this$1 = this;

    for (var i = at, e = at + n; i < e; ++i) {
      var line = this$1.lines[i];
      this$1.height -= line.height;
      cleanUpLine(line);
      signalLater(line, "delete");
    }
    this.lines.splice(at, n);
  },

  // Helper used to collapse a small branch into a single leaf.
  collapse: function(lines) {
    lines.push.apply(lines, this.lines);
  },

  // Insert the given array of lines at offset 'at', count them as
  // having the given height.
  insertInner: function(at, lines, height) {
    var this$1 = this;

    this.height += height;
    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }
  },

  // Used to iterate over a part of the tree.
  iterN: function(at, n, op) {
    var this$1 = this;

    for (var e = at + n; at < e; ++at)
      { if (op(this$1.lines[at])) { return true } }
  }
};

function BranchChunk(children) {
  var this$1 = this;

  this.children = children;
  var size = 0, height = 0;
  for (var i = 0; i < children.length; ++i) {
    var ch = children[i];
    size += ch.chunkSize(); height += ch.height;
    ch.parent = this$1;
  }
  this.size = size;
  this.height = height;
  this.parent = null;
}

BranchChunk.prototype = {
  chunkSize: function() { return this.size },

  removeInner: function(at, n) {
    var this$1 = this;

    this.size -= n;
    for (var i = 0; i < this.children.length; ++i) {
      var child = this$1.children[i], sz = child.chunkSize();
      if (at < sz) {
        var rm = Math.min(n, sz - at), oldHeight = child.height;
        child.removeInner(at, rm);
        this$1.height -= oldHeight - child.height;
        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }
        if ((n -= rm) == 0) { break }
        at = 0;
      } else { at -= sz; }
    }
    // If the result is smaller than 25 lines, ensure that it is a
    // single leaf node.
    if (this.size - n < 25 &&
        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
      var lines = [];
      this.collapse(lines);
      this.children = [new LeafChunk(lines)];
      this.children[0].parent = this;
    }
  },

  collapse: function(lines) {
    var this$1 = this;

    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }
  },

  insertInner: function(at, lines, height) {
    var this$1 = this;

    this.size += lines.length;
    this.height += height;
    for (var i = 0; i < this.children.length; ++i) {
      var child = this$1.children[i], sz = child.chunkSize();
      if (at <= sz) {
        child.insertInner(at, lines, height);
        if (child.lines && child.lines.length > 50) {
          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
          var remaining = child.lines.length % 25 + 25;
          for (var pos = remaining; pos < child.lines.length;) {
            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
            child.height -= leaf.height;
            this$1.children.splice(++i, 0, leaf);
            leaf.parent = this$1;
          }
          child.lines = child.lines.slice(0, remaining);
          this$1.maybeSpill();
        }
        break
      }
      at -= sz;
    }
  },

  // When a node has grown, check whether it should be split.
  maybeSpill: function() {
    if (this.children.length <= 10) { return }
    var me = this;
    do {
      var spilled = me.children.splice(me.children.length - 5, 5);
      var sibling = new BranchChunk(spilled);
      if (!me.parent) { // Become the parent node
        var copy = new BranchChunk(me.children);
        copy.parent = me;
        me.children = [copy, sibling];
        me = copy;
     } else {
        me.size -= sibling.size;
        me.height -= sibling.height;
        var myIndex = indexOf(me.parent.children, me);
        me.parent.children.splice(myIndex + 1, 0, sibling);
      }
      sibling.parent = me.parent;
    } while (me.children.length > 10)
    me.parent.maybeSpill();
  },

  iterN: function(at, n, op) {
    var this$1 = this;

    for (var i = 0; i < this.children.length; ++i) {
      var child = this$1.children[i], sz = child.chunkSize();
      if (at < sz) {
        var used = Math.min(n, sz - at);
        if (child.iterN(at, used, op)) { return true }
        if ((n -= used) == 0) { break }
        at = 0;
      } else { at -= sz; }
    }
  }
};

// Line widgets are block elements displayed above or below a line.

var LineWidget = function(doc, node, options) {
  var this$1 = this;

  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
    { this$1[opt] = options[opt]; } } }
  this.doc = doc;
  this.node = node;
};

LineWidget.prototype.clear = function () {
    var this$1 = this;

  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
  if (no == null || !ws) { return }
  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }
  if (!ws.length) { line.widgets = null; }
  var height = widgetHeight(this);
  updateLineHeight(line, Math.max(0, line.height - height));
  if (cm) {
    runInOp(cm, function () {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, "widget");
    });
    signalLater(cm, "lineWidgetCleared", cm, this, no);
  }
};

LineWidget.prototype.changed = function () {
    var this$1 = this;

  var oldH = this.height, cm = this.doc.cm, line = this.line;
  this.height = null;
  var diff = widgetHeight(this) - oldH;
  if (!diff) { return }
  updateLineHeight(line, line.height + diff);
  if (cm) {
    runInOp(cm, function () {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
      signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
    });
  }
};
eventMixin(LineWidget);

function adjustScrollWhenAboveVisible(cm, line, diff) {
  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
    { addToScrollTop(cm, diff); }
}

function addLineWidget(doc, handle, node, options) {
  var widget = new LineWidget(doc, node, options);
  var cm = doc.cm;
  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
  changeLine(doc, handle, "widget", function (line) {
    var widgets = line.widgets || (line.widgets = []);
    if (widget.insertAt == null) { widgets.push(widget); }
    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
    widget.line = line;
    if (cm && !lineIsHidden(doc, line)) {
      var aboveVisible = heightAtLine(line) < doc.scrollTop;
      updateLineHeight(line, line.height + widgetHeight(widget));
      if (aboveVisible) { addToScrollTop(cm, widget.height); }
      cm.curOp.forceUpdate = true;
    }
    return true
  });
  if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
  return widget
}

// TEXTMARKERS

// Created with markText and setBookmark methods. A TextMarker is a
// handle that can be used to clear or find a marked position in the
// document. Line objects hold arrays (markedSpans) containing
// {from, to, marker} object pointing to such marker objects, and
// indicating that such a marker is present on that line. Multiple
// lines may point to the same marker when it spans across lines.
// The spans will have null for their from/to properties when the
// marker continues beyond the start/end of the line. Markers have
// links back to the lines they currently touch.

// Collapsed markers have unique ids, in order to be able to order
// them, which is needed for uniquely determining an outer marker
// when they overlap (they may nest, but not partially overlap).
var nextMarkerId = 0;

var TextMarker = function(doc, type) {
  this.lines = [];
  this.type = type;
  this.doc = doc;
  this.id = ++nextMarkerId;
};

// Clear the marker.
TextMarker.prototype.clear = function () {
    var this$1 = this;

  if (this.explicitlyCleared) { return }
  var cm = this.doc.cm, withOp = cm && !cm.curOp;
  if (withOp) { startOperation(cm); }
  if (hasHandler(this, "clear")) {
    var found = this.find();
    if (found) { signalLater(this, "clear", found.from, found.to); }
  }
  var min = null, max = null;
  for (var i = 0; i < this.lines.length; ++i) {
    var line = this$1.lines[i];
    var span = getMarkedSpanFor(line.markedSpans, this$1);
    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text"); }
    else if (cm) {
      if (span.to != null) { max = lineNo(line); }
      if (span.from != null) { min = lineNo(line); }
    }
    line.markedSpans = removeMarkedSpan(line.markedSpans, span);
    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
      { updateLineHeight(line, textHeight(cm.display)); }
  }
  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
    if (len > cm.display.maxLineLength) {
      cm.display.maxLine = visual;
      cm.display.maxLineLength = len;
      cm.display.maxLineChanged = true;
    }
  } }

  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
  this.lines.length = 0;
  this.explicitlyCleared = true;
  if (this.atomic && this.doc.cantEdit) {
    this.doc.cantEdit = false;
    if (cm) { reCheckSelection(cm.doc); }
  }
  if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
  if (withOp) { endOperation(cm); }
  if (this.parent) { this.parent.clear(); }
};

// Find the position of the marker in the document. Returns a {from,
// to} object by default. Side can be passed to get a specific side
// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
// Pos objects returned contain a line object, rather than a line
// number (used to prevent looking up the same line twice).
TextMarker.prototype.find = function (side, lineObj) {
    var this$1 = this;

  if (side == null && this.type == "bookmark") { side = 1; }
  var from, to;
  for (var i = 0; i < this.lines.length; ++i) {
    var line = this$1.lines[i];
    var span = getMarkedSpanFor(line.markedSpans, this$1);
    if (span.from != null) {
      from = Pos(lineObj ? line : lineNo(line), span.from);
      if (side == -1) { return from }
    }
    if (span.to != null) {
      to = Pos(lineObj ? line : lineNo(line), span.to);
      if (side == 1) { return to }
    }
  }
  return from && {from: from, to: to}
};

// Signals that the marker's widget changed, and surrounding layout
// should be recomputed.
TextMarker.prototype.changed = function () {
    var this$1 = this;

  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
  if (!pos || !cm) { return }
  runInOp(cm, function () {
    var line = pos.line, lineN = lineNo(pos.line);
    var view = findViewForLine(cm, lineN);
    if (view) {
      clearLineMeasurementCacheFor(view);
      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
    }
    cm.curOp.updateMaxLine = true;
    if (!lineIsHidden(widget.doc, line) && widget.height != null) {
      var oldHeight = widget.height;
      widget.height = null;
      var dHeight = widgetHeight(widget) - oldHeight;
      if (dHeight)
        { updateLineHeight(line, line.height + dHeight); }
    }
    signalLater(cm, "markerChanged", cm, this$1);
  });
};

TextMarker.prototype.attachLine = function (line) {
  if (!this.lines.length && this.doc.cm) {
    var op = this.doc.cm.curOp;
    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
  }
  this.lines.push(line);
};

TextMarker.prototype.detachLine = function (line) {
  this.lines.splice(indexOf(this.lines, line), 1);
  if (!this.lines.length && this.doc.cm) {
    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
  }
};
eventMixin(TextMarker);

// Create a marker, wire it up to the right lines, and
function markText(doc, from, to, options, type) {
  // Shared markers (across linked documents) are handled separately
  // (markTextShared will call out to this again, once per
  // document).
  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
  // Ensure we are in an operation.
  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

  var marker = new TextMarker(doc, type), diff = cmp(from, to);
  if (options) { copyObj(options, marker, false); }
  // Don't connect empty markers unless clearWhenEmpty is false
  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
    { return marker }
  if (marker.replacedWith) {
    // Showing up as a widget implies collapsed (widget replaces text)
    marker.collapsed = true;
    marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
  }
  if (marker.collapsed) {
    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
      { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
    seeCollapsedSpans();
  }

  if (marker.addToHistory)
    { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

  var curLine = from.line, cm = doc.cm, updateMaxLine;
  doc.iter(curLine, to.line + 1, function (line) {
    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
      { updateMaxLine = true; }
    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
    addMarkedSpan(line, new MarkedSpan(marker,
                                       curLine == from.line ? from.ch : null,
                                       curLine == to.line ? to.ch : null));
    ++curLine;
  });
  // lineIsHidden depends on the presence of the spans, so needs a second pass
  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
  }); }

  if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

  if (marker.readOnly) {
    seeReadOnlySpans();
    if (doc.history.done.length || doc.history.undone.length)
      { doc.clearHistory(); }
  }
  if (marker.collapsed) {
    marker.id = ++nextMarkerId;
    marker.atomic = true;
  }
  if (cm) {
    // Sync editor state
    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
    if (marker.collapsed)
      { regChange(cm, from.line, to.line + 1); }
    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
    if (marker.atomic) { reCheckSelection(cm.doc); }
    signalLater(cm, "markerAdded", cm, marker);
  }
  return marker
}

// SHARED TEXTMARKERS

// A shared marker spans multiple linked documents. It is
// implemented as a meta-marker-object controlling multiple normal
// markers.
var SharedTextMarker = function(markers, primary) {
  var this$1 = this;

  this.markers = markers;
  this.primary = primary;
  for (var i = 0; i < markers.length; ++i)
    { markers[i].parent = this$1; }
};

SharedTextMarker.prototype.clear = function () {
    var this$1 = this;

  if (this.explicitlyCleared) { return }
  this.explicitlyCleared = true;
  for (var i = 0; i < this.markers.length; ++i)
    { this$1.markers[i].clear(); }
  signalLater(this, "clear");
};

SharedTextMarker.prototype.find = function (side, lineObj) {
  return this.primary.find(side, lineObj)
};
eventMixin(SharedTextMarker);

function markTextShared(doc, from, to, options, type) {
  options = copyObj(options);
  options.shared = false;
  var markers = [markText(doc, from, to, options, type)], primary = markers[0];
  var widget = options.widgetNode;
  linkedDocs(doc, function (doc) {
    if (widget) { options.widgetNode = widget.cloneNode(true); }
    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
    for (var i = 0; i < doc.linked.length; ++i)
      { if (doc.linked[i].isParent) { return } }
    primary = lst(markers);
  });
  return new SharedTextMarker(markers, primary)
}

function findSharedMarkers(doc) {
  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
}

function copySharedMarkers(doc, markers) {
  for (var i = 0; i < markers.length; i++) {
    var marker = markers[i], pos = marker.find();
    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
    if (cmp(mFrom, mTo)) {
      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
      marker.markers.push(subMark);
      subMark.parent = marker;
    }
  }
}

function detachSharedMarkers(markers) {
  var loop = function ( i ) {
    var marker = markers[i], linked = [marker.primary.doc];
    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
    for (var j = 0; j < marker.markers.length; j++) {
      var subMarker = marker.markers[j];
      if (indexOf(linked, subMarker.doc) == -1) {
        subMarker.parent = null;
        marker.markers.splice(j--, 1);
      }
    }
  };

  for (var i = 0; i < markers.length; i++) loop( i );
}

var nextDocId = 0;
var Doc = function(text, mode, firstLine, lineSep, direction) {
  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
  if (firstLine == null) { firstLine = 0; }

  BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
  this.first = firstLine;
  this.scrollTop = this.scrollLeft = 0;
  this.cantEdit = false;
  this.cleanGeneration = 1;
  this.modeFrontier = this.highlightFrontier = firstLine;
  var start = Pos(firstLine, 0);
  this.sel = simpleSelection(start);
  this.history = new History(null);
  this.id = ++nextDocId;
  this.modeOption = mode;
  this.lineSep = lineSep;
  this.direction = (direction == "rtl") ? "rtl" : "ltr";
  this.extend = false;

  if (typeof text == "string") { text = this.splitLines(text); }
  updateDoc(this, {from: start, to: start, text: text});
  setSelection(this, simpleSelection(start), sel_dontScroll);
};

Doc.prototype = createObj(BranchChunk.prototype, {
  constructor: Doc,
  // Iterate over the document. Supports two forms -- with only one
  // argument, it calls that for each line in the document. With
  // three, it iterates over the range given by the first two (with
  // the second being non-inclusive).
  iter: function(from, to, op) {
    if (op) { this.iterN(from - this.first, to - from, op); }
    else { this.iterN(this.first, this.first + this.size, from); }
  },

  // Non-public interface for adding and removing lines.
  insert: function(at, lines) {
    var height = 0;
    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
    this.insertInner(at - this.first, lines, height);
  },
  remove: function(at, n) { this.removeInner(at - this.first, n); },

  // From here, the methods are part of the public interface. Most
  // are also available from CodeMirror (editor) instances.

  getValue: function(lineSep) {
    var lines = getLines(this, this.first, this.first + this.size);
    if (lineSep === false) { return lines }
    return lines.join(lineSep || this.lineSeparator())
  },
  setValue: docMethodOp(function(code) {
    var top = Pos(this.first, 0), last = this.first + this.size - 1;
    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                      text: this.splitLines(code), origin: "setValue", full: true}, true);
    if (this.cm) { scrollToCoords(this.cm, 0, 0); }
    setSelection(this, simpleSelection(top), sel_dontScroll);
  }),
  replaceRange: function(code, from, to, origin) {
    from = clipPos(this, from);
    to = to ? clipPos(this, to) : from;
    replaceRange(this, code, from, to, origin);
  },
  getRange: function(from, to, lineSep) {
    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
    if (lineSep === false) { return lines }
    return lines.join(lineSep || this.lineSeparator())
  },

  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
  getLineNumber: function(line) {return lineNo(line)},

  getLineHandleVisualStart: function(line) {
    if (typeof line == "number") { line = getLine(this, line); }
    return visualLine(line)
  },

  lineCount: function() {return this.size},
  firstLine: function() {return this.first},
  lastLine: function() {return this.first + this.size - 1},

  clipPos: function(pos) {return clipPos(this, pos)},

  getCursor: function(start) {
    var range$$1 = this.sel.primary(), pos;
    if (start == null || start == "head") { pos = range$$1.head; }
    else if (start == "anchor") { pos = range$$1.anchor; }
    else if (start == "end" || start == "to" || start === false) { pos = range$$1.to(); }
    else { pos = range$$1.from(); }
    return pos
  },
  listSelections: function() { return this.sel.ranges },
  somethingSelected: function() {return this.sel.somethingSelected()},

  setCursor: docMethodOp(function(line, ch, options) {
    setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
  }),
  setSelection: docMethodOp(function(anchor, head, options) {
    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
  }),
  extendSelection: docMethodOp(function(head, other, options) {
    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
  }),
  extendSelections: docMethodOp(function(heads, options) {
    extendSelections(this, clipPosArray(this, heads), options);
  }),
  extendSelectionsBy: docMethodOp(function(f, options) {
    var heads = map(this.sel.ranges, f);
    extendSelections(this, clipPosArray(this, heads), options);
  }),
  setSelections: docMethodOp(function(ranges, primary, options) {
    var this$1 = this;

    if (!ranges.length) { return }
    var out = [];
    for (var i = 0; i < ranges.length; i++)
      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
                         clipPos(this$1, ranges[i].head)); }
    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
    setSelection(this, normalizeSelection(out, primary), options);
  }),
  addSelection: docMethodOp(function(anchor, head, options) {
    var ranges = this.sel.ranges.slice(0);
    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
  }),

  getSelection: function(lineSep) {
    var this$1 = this;

    var ranges = this.sel.ranges, lines;
    for (var i = 0; i < ranges.length; i++) {
      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
      lines = lines ? lines.concat(sel) : sel;
    }
    if (lineSep === false) { return lines }
    else { return lines.join(lineSep || this.lineSeparator()) }
  },
  getSelections: function(lineSep) {
    var this$1 = this;

    var parts = [], ranges = this.sel.ranges;
    for (var i = 0; i < ranges.length; i++) {
      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }
      parts[i] = sel;
    }
    return parts
  },
  replaceSelection: function(code, collapse, origin) {
    var dup = [];
    for (var i = 0; i < this.sel.ranges.length; i++)
      { dup[i] = code; }
    this.replaceSelections(dup, collapse, origin || "+input");
  },
  replaceSelections: docMethodOp(function(code, collapse, origin) {
    var this$1 = this;

    var changes = [], sel = this.sel;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range$$1 = sel.ranges[i];
      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};
    }
    var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
      { makeChange(this$1, changes[i$1]); }
    if (newSel) { setSelectionReplaceHistory(this, newSel); }
    else if (this.cm) { ensureCursorVisible(this.cm); }
  }),
  undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
  redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

  setExtending: function(val) {this.extend = val;},
  getExtending: function() {return this.extend},

  historySize: function() {
    var hist = this.history, done = 0, undone = 0;
    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
    return {undo: done, redo: undone}
  },
  clearHistory: function() {this.history = new History(this.history.maxGeneration);},

  markClean: function() {
    this.cleanGeneration = this.changeGeneration(true);
  },
  changeGeneration: function(forceSplit) {
    if (forceSplit)
      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
    return this.history.generation
  },
  isClean: function (gen) {
    return this.history.generation == (gen || this.cleanGeneration)
  },

  getHistory: function() {
    return {done: copyHistoryArray(this.history.done),
            undone: copyHistoryArray(this.history.undone)}
  },
  setHistory: function(histData) {
    var hist = this.history = new History(this.history.maxGeneration);
    hist.done = copyHistoryArray(histData.done.slice(0), null, true);
    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
  },

  setGutterMarker: docMethodOp(function(line, gutterID, value) {
    return changeLine(this, line, "gutter", function (line) {
      var markers = line.gutterMarkers || (line.gutterMarkers = {});
      markers[gutterID] = value;
      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
      return true
    })
  }),

  clearGutter: docMethodOp(function(gutterID) {
    var this$1 = this;

    this.iter(function (line) {
      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
        changeLine(this$1, line, "gutter", function () {
          line.gutterMarkers[gutterID] = null;
          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
          return true
        });
      }
    });
  }),

  lineInfo: function(line) {
    var n;
    if (typeof line == "number") {
      if (!isLine(this, line)) { return null }
      n = line;
      line = getLine(this, line);
      if (!line) { return null }
    } else {
      n = lineNo(line);
      if (n == null) { return null }
    }
    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
            widgets: line.widgets}
  },

  addLineClass: docMethodOp(function(handle, where, cls) {
    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
      var prop = where == "text" ? "textClass"
               : where == "background" ? "bgClass"
               : where == "gutter" ? "gutterClass" : "wrapClass";
      if (!line[prop]) { line[prop] = cls; }
      else if (classTest(cls).test(line[prop])) { return false }
      else { line[prop] += " " + cls; }
      return true
    })
  }),
  removeLineClass: docMethodOp(function(handle, where, cls) {
    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
      var prop = where == "text" ? "textClass"
               : where == "background" ? "bgClass"
               : where == "gutter" ? "gutterClass" : "wrapClass";
      var cur = line[prop];
      if (!cur) { return false }
      else if (cls == null) { line[prop] = null; }
      else {
        var found = cur.match(classTest(cls));
        if (!found) { return false }
        var end = found.index + found[0].length;
        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
      }
      return true
    })
  }),

  addLineWidget: docMethodOp(function(handle, node, options) {
    return addLineWidget(this, handle, node, options)
  }),
  removeLineWidget: function(widget) { widget.clear(); },

  markText: function(from, to, options) {
    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
  },
  setBookmark: function(pos, options) {
    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                    insertLeft: options && options.insertLeft,
                    clearWhenEmpty: false, shared: options && options.shared,
                    handleMouseEvents: options && options.handleMouseEvents};
    pos = clipPos(this, pos);
    return markText(this, pos, pos, realOpts, "bookmark")
  },
  findMarksAt: function(pos) {
    pos = clipPos(this, pos);
    var markers = [], spans = getLine(this, pos.line).markedSpans;
    if (spans) { for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if ((span.from == null || span.from <= pos.ch) &&
          (span.to == null || span.to >= pos.ch))
        { markers.push(span.marker.parent || span.marker); }
    } }
    return markers
  },
  findMarks: function(from, to, filter) {
    from = clipPos(this, from); to = clipPos(this, to);
    var found = [], lineNo$$1 = from.line;
    this.iter(from.line, to.line + 1, function (line) {
      var spans = line.markedSpans;
      if (spans) { for (var i = 0; i < spans.length; i++) {
        var span = spans[i];
        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||
              span.from == null && lineNo$$1 != from.line ||
              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&
            (!filter || filter(span.marker)))
          { found.push(span.marker.parent || span.marker); }
      } }
      ++lineNo$$1;
    });
    return found
  },
  getAllMarks: function() {
    var markers = [];
    this.iter(function (line) {
      var sps = line.markedSpans;
      if (sps) { for (var i = 0; i < sps.length; ++i)
        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
    });
    return markers
  },

  posFromIndex: function(off) {
    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
    this.iter(function (line) {
      var sz = line.text.length + sepSize;
      if (sz > off) { ch = off; return true }
      off -= sz;
      ++lineNo$$1;
    });
    return clipPos(this, Pos(lineNo$$1, ch))
  },
  indexFromPos: function (coords) {
    coords = clipPos(this, coords);
    var index = coords.ch;
    if (coords.line < this.first || coords.ch < 0) { return 0 }
    var sepSize = this.lineSeparator().length;
    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
      index += line.text.length + sepSize;
    });
    return index
  },

  copy: function(copyHistory) {
    var doc = new Doc(getLines(this, this.first, this.first + this.size),
                      this.modeOption, this.first, this.lineSep, this.direction);
    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
    doc.sel = this.sel;
    doc.extend = false;
    if (copyHistory) {
      doc.history.undoDepth = this.history.undoDepth;
      doc.setHistory(this.getHistory());
    }
    return doc
  },

  linkedDoc: function(options) {
    if (!options) { options = {}; }
    var from = this.first, to = this.first + this.size;
    if (options.from != null && options.from > from) { from = options.from; }
    if (options.to != null && options.to < to) { to = options.to; }
    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
    if (options.sharedHist) { copy.history = this.history
    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
    copySharedMarkers(copy, findSharedMarkers(this));
    return copy
  },
  unlinkDoc: function(other) {
    var this$1 = this;

    if (other instanceof CodeMirror$1) { other = other.doc; }
    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
      var link = this$1.linked[i];
      if (link.doc != other) { continue }
      this$1.linked.splice(i, 1);
      other.unlinkDoc(this$1);
      detachSharedMarkers(findSharedMarkers(this$1));
      break
    } }
    // If the histories were shared, split them again
    if (other.history == this.history) {
      var splitIds = [other.id];
      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
      other.history = new History(null);
      other.history.done = copyHistoryArray(this.history.done, splitIds);
      other.history.undone = copyHistoryArray(this.history.undone, splitIds);
    }
  },
  iterLinkedDocs: function(f) {linkedDocs(this, f);},

  getMode: function() {return this.mode},
  getEditor: function() {return this.cm},

  splitLines: function(str) {
    if (this.lineSep) { return str.split(this.lineSep) }
    return splitLinesAuto(str)
  },
  lineSeparator: function() { return this.lineSep || "\n" },

  setDirection: docMethodOp(function (dir) {
    if (dir != "rtl") { dir = "ltr"; }
    if (dir == this.direction) { return }
    this.direction = dir;
    this.iter(function (line) { return line.order = null; });
    if (this.cm) { directionChanged(this.cm); }
  })
});

// Public alias.
Doc.prototype.eachLine = Doc.prototype.iter;

// Kludge to work around strange IE behavior where it'll sometimes
// re-fire a series of drag-related events right after the drop (#1551)
var lastDrop = 0;

function onDrop(e) {
  var cm = this;
  clearDragCursor(cm);
  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
    { return }
  e_preventDefault(e);
  if (ie) { lastDrop = +new Date; }
  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
  if (!pos || cm.isReadOnly()) { return }
  // Might be a file drop, in which case we simply extract the text
  // and insert it.
  if (files && files.length && window.FileReader && window.File) {
    var n = files.length, text = Array(n), read = 0;
    var loadFile = function (file, i) {
      if (cm.options.allowDropFileTypes &&
          indexOf(cm.options.allowDropFileTypes, file.type) == -1)
        { return }

      var reader = new FileReader;
      reader.onload = operation(cm, function () {
        var content = reader.result;
        if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = ""; }
        text[i] = content;
        if (++read == n) {
          pos = clipPos(cm.doc, pos);
          var change = {from: pos, to: pos,
                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                        origin: "paste"};
          makeChange(cm.doc, change);
          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
        }
      });
      reader.readAsText(file);
    };
    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }
  } else { // Normal drop
    // Don't do a replace if the drop happened inside of the selected text.
    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
      cm.state.draggingText(e);
      // Ensure the editor is re-focused
      setTimeout(function () { return cm.display.input.focus(); }, 20);
      return
    }
    try {
      var text$1 = e.dataTransfer.getData("Text");
      if (text$1) {
        var selected;
        if (cm.state.draggingText && !cm.state.draggingText.copy)
          { selected = cm.listSelections(); }
        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
          { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
        cm.replaceSelection(text$1, "around", "paste");
        cm.display.input.focus();
      }
    }
    catch(e){}
  }
}

function onDragStart(cm, e) {
  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

  e.dataTransfer.setData("Text", cm.getSelection());
  e.dataTransfer.effectAllowed = "copyMove";

  // Use dummy image instead of default browsers image.
  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
  if (e.dataTransfer.setDragImage && !safari) {
    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    if (presto) {
      img.width = img.height = 1;
      cm.display.wrapper.appendChild(img);
      // Force a relayout, or Opera won't use our image for some obscure reason
      img._top = img.offsetTop;
    }
    e.dataTransfer.setDragImage(img, 0, 0);
    if (presto) { img.parentNode.removeChild(img); }
  }
}

function onDragOver(cm, e) {
  var pos = posFromMouse(cm, e);
  if (!pos) { return }
  var frag = document.createDocumentFragment();
  drawSelectionCursor(cm, pos, frag);
  if (!cm.display.dragCursor) {
    cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
  }
  removeChildrenAndAdd(cm.display.dragCursor, frag);
}

function clearDragCursor(cm) {
  if (cm.display.dragCursor) {
    cm.display.lineSpace.removeChild(cm.display.dragCursor);
    cm.display.dragCursor = null;
  }
}

// These must be handled carefully, because naively registering a
// handler for each editor will cause the editors to never be
// garbage collected.

function forEachCodeMirror(f) {
  if (!document.getElementsByClassName) { return }
  var byClass = document.getElementsByClassName("CodeMirror");
  for (var i = 0; i < byClass.length; i++) {
    var cm = byClass[i].CodeMirror;
    if (cm) { f(cm); }
  }
}

var globalsRegistered = false;
function ensureGlobalHandlers() {
  if (globalsRegistered) { return }
  registerGlobalHandlers();
  globalsRegistered = true;
}
function registerGlobalHandlers() {
  // When the window resizes, we need to refresh active editors.
  var resizeTimer;
  on(window, "resize", function () {
    if (resizeTimer == null) { resizeTimer = setTimeout(function () {
      resizeTimer = null;
      forEachCodeMirror(onResize);
    }, 100); }
  });
  // When the window loses focus, we want to show the editor as blurred
  on(window, "blur", function () { return forEachCodeMirror(onBlur); });
}
// Called when the window resizes
function onResize(cm) {
  var d = cm.display;
  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
    { return }
  // Might be a text scaling operation, clear size caches.
  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
  d.scrollbarsClipped = false;
  cm.setSize();
}

var keyNames = {
  3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
  106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete", 145: "ScrollLock",
  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
};

// Number keys
for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
// Alphabetic keys
for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
// Function keys
for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

var keyMap = {};

keyMap.basic = {
  "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
  "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
  "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
  "Tab": "defaultTab", "Shift-Tab": "indentAuto",
  "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
  "Esc": "singleSelection"
};
// Note that the save and find-related commands aren't defined by
// default. User code or addons can define them. Unknown commands
// are simply ignored.
keyMap.pcDefault = {
  "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
  "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
  "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
  "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
  "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
  "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
  "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
  fallthrough: "basic"
};
// Very basic readline/emacs-style bindings, which are standard on Mac.
keyMap.emacsy = {
  "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
  "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
  "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
  "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
  "Ctrl-O": "openLine"
};
keyMap.macDefault = {
  "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
  "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
  "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
  "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
  "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
  "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
  "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
  fallthrough: ["basic", "emacsy"]
};
keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

// KEYMAP DISPATCH

function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/);
  name = parts[parts.length - 1];
  var alt, ctrl, shift, cmd;
  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
    else if (/^a(lt)?$/i.test(mod)) { alt = true; }
    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
    else if (/^s(hift)?$/i.test(mod)) { shift = true; }
    else { throw new Error("Unrecognized modifier name: " + mod) }
  }
  if (alt) { name = "Alt-" + name; }
  if (ctrl) { name = "Ctrl-" + name; }
  if (cmd) { name = "Cmd-" + name; }
  if (shift) { name = "Shift-" + name; }
  return name
}

// This is a kludge to keep keymaps mostly working as raw objects
// (backwards compatibility) while at the same time support features
// like normalization and multi-stroke key bindings. It compiles a
// new normalized keymap, and then updates the old object to reflect
// this.
function normalizeKeyMap(keymap) {
  var copy = {};
  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
    var value = keymap[keyname];
    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
    if (value == "...") { delete keymap[keyname]; continue }

    var keys = map(keyname.split(" "), normalizeKeyName);
    for (var i = 0; i < keys.length; i++) {
      var val = (void 0), name = (void 0);
      if (i == keys.length - 1) {
        name = keys.join(" ");
        val = value;
      } else {
        name = keys.slice(0, i + 1).join(" ");
        val = "...";
      }
      var prev = copy[name];
      if (!prev) { copy[name] = val; }
      else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
    }
    delete keymap[keyname];
  } }
  for (var prop in copy) { keymap[prop] = copy[prop]; }
  return keymap
}

function lookupKey(key, map$$1, handle, context) {
  map$$1 = getKeyMap(map$$1);
  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
  if (found === false) { return "nothing" }
  if (found === "...") { return "multi" }
  if (found != null && handle(found)) { return "handled" }

  if (map$$1.fallthrough) {
    if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]")
      { return lookupKey(key, map$$1.fallthrough, handle, context) }
    for (var i = 0; i < map$$1.fallthrough.length; i++) {
      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
      if (result) { return result }
    }
  }
}

// Modifier key presses don't count as 'real' key presses for the
// purpose of keymap fallthrough.
function isModifierKey(value) {
  var name = typeof value == "string" ? value : keyNames[value.keyCode];
  return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
}

function addModifierNames(name, event, noShift) {
  var base = name;
  if (event.altKey && base != "Alt") { name = "Alt-" + name; }
  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
  if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
  return name
}

// Look up the name of a key as indicated by an event object.
function keyName(event, noShift) {
  if (presto && event.keyCode == 34 && event["char"]) { return false }
  var name = keyNames[event.keyCode];
  if (name == null || event.altGraphKey) { return false }
  // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
  // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
  if (event.keyCode == 3 && event.code) { name = event.code; }
  return addModifierNames(name, event, noShift)
}

function getKeyMap(val) {
  return typeof val == "string" ? keyMap[val] : val
}

// Helper for deleting text near the selection(s), used to implement
// backspace, delete, and similar functionality.
function deleteNearSelection(cm, compute) {
  var ranges = cm.doc.sel.ranges, kill = [];
  // Build up a set of ranges to kill first, merging overlapping
  // ranges.
  for (var i = 0; i < ranges.length; i++) {
    var toKill = compute(ranges[i]);
    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
      var replaced = kill.pop();
      if (cmp(replaced.from, toKill.from) < 0) {
        toKill.from = replaced.from;
        break
      }
    }
    kill.push(toKill);
  }
  // Next, remove those actual ranges.
  runInOp(cm, function () {
    for (var i = kill.length - 1; i >= 0; i--)
      { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
    ensureCursorVisible(cm);
  });
}

function moveCharLogically(line, ch, dir) {
  var target = skipExtendingChars(line.text, ch + dir, dir);
  return target < 0 || target > line.text.length ? null : target
}

function moveLogically(line, start, dir) {
  var ch = moveCharLogically(line, start.ch, dir);
  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
}

function endOfLine(visually, cm, lineObj, lineNo, dir) {
  if (visually) {
    var order = getOrder(lineObj, cm.doc.direction);
    if (order) {
      var part = dir < 0 ? lst(order) : order[0];
      var moveInStorageOrder = (dir < 0) == (part.level == 1);
      var sticky = moveInStorageOrder ? "after" : "before";
      var ch;
      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
      // it could be that the last bidi part is not on the last visual line,
      // since visual lines contain content order-consecutive chunks.
      // Thus, in rtl, we are looking for the first (content-order) character
      // in the rtl chunk that is on the last line (that is, the same line
      // as the last (content-order) character).
      if (part.level > 0 || cm.doc.direction == "rtl") {
        var prep = prepareMeasureForLine(cm, lineObj);
        ch = dir < 0 ? lineObj.text.length - 1 : 0;
        var targetTop = measureCharPrepared(cm, prep, ch).top;
        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
        if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
      } else { ch = dir < 0 ? part.to : part.from; }
      return new Pos(lineNo, ch, sticky)
    }
  }
  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
}

function moveVisually(cm, line, start, dir) {
  var bidi = getOrder(line, cm.doc.direction);
  if (!bidi) { return moveLogically(line, start, dir) }
  if (start.ch >= line.text.length) {
    start.ch = line.text.length;
    start.sticky = "before";
  } else if (start.ch <= 0) {
    start.ch = 0;
    start.sticky = "after";
  }
  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
  if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
    // nothing interesting happens.
    return moveLogically(line, start, dir)
  }

  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
  var prep;
  var getWrappedLineExtent = function (ch) {
    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
    prep = prep || prepareMeasureForLine(cm, line);
    return wrappedLineExtentChar(cm, line, prep, ch)
  };
  var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

  if (cm.doc.direction == "rtl" || part.level == 1) {
    var moveInStorageOrder = (part.level == 1) == (dir < 0);
    var ch = mv(start, moveInStorageOrder ? 1 : -1);
    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
      // Case 2: We move within an rtl part or in an rtl editor on the same visual line
      var sticky = moveInStorageOrder ? "before" : "after";
      return new Pos(start.line, ch, sticky)
    }
  }

  // Case 3: Could not move within this bidi part in this visual line, so leave
  // the current bidi part

  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
      ? new Pos(start.line, mv(ch, 1), "before")
      : new Pos(start.line, ch, "after"); };

    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
      var part = bidi[partPos];
      var moveInStorageOrder = (dir > 0) == (part.level != 1);
      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
      ch = moveInStorageOrder ? part.from : mv(part.to, -1);
      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
    }
  };

  // Case 3a: Look for other bidi parts on the same visual line
  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
  if (res) { return res }

  // Case 3b: Look for other bidi parts on the next visual line
  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
    if (res) { return res }
  }

  // Case 4: Nowhere to move
  return null
}

// Commands are parameter-less actions that can be performed on an
// editor, mostly used for keybindings.
var commands = {
  selectAll: selectAll,
  singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
  killLine: function (cm) { return deleteNearSelection(cm, function (range) {
    if (range.empty()) {
      var len = getLine(cm.doc, range.head.line).text.length;
      if (range.head.ch == len && range.head.line < cm.lastLine())
        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
      else
        { return {from: range.head, to: Pos(range.head.line, len)} }
    } else {
      return {from: range.from(), to: range.to()}
    }
  }); },
  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
    from: Pos(range.from().line, 0),
    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
  }); }); },
  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
    from: Pos(range.from().line, 0), to: range.from()
  }); }); },
  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
    var top = cm.charCoords(range.head, "div").top + 5;
    var leftPos = cm.coordsChar({left: 0, top: top}, "div");
    return {from: leftPos, to: range.from()}
  }); },
  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
    var top = cm.charCoords(range.head, "div").top + 5;
    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
    return {from: range.from(), to: rightPos }
  }); },
  undo: function (cm) { return cm.undo(); },
  redo: function (cm) { return cm.redo(); },
  undoSelection: function (cm) { return cm.undoSelection(); },
  redoSelection: function (cm) { return cm.redoSelection(); },
  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
    {origin: "+move", bias: 1}
  ); },
  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
    {origin: "+move", bias: 1}
  ); },
  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
    {origin: "+move", bias: -1}
  ); },
  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
    var top = cm.cursorCoords(range.head, "div").top + 5;
    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
  }, sel_move); },
  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
    var top = cm.cursorCoords(range.head, "div").top + 5;
    return cm.coordsChar({left: 0, top: top}, "div")
  }, sel_move); },
  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
    var top = cm.cursorCoords(range.head, "div").top + 5;
    var pos = cm.coordsChar({left: 0, top: top}, "div");
    if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
    return pos
  }, sel_move); },
  goLineUp: function (cm) { return cm.moveV(-1, "line"); },
  goLineDown: function (cm) { return cm.moveV(1, "line"); },
  goPageUp: function (cm) { return cm.moveV(-1, "page"); },
  goPageDown: function (cm) { return cm.moveV(1, "page"); },
  goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
  goCharRight: function (cm) { return cm.moveH(1, "char"); },
  goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
  goColumnRight: function (cm) { return cm.moveH(1, "column"); },
  goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
  goGroupRight: function (cm) { return cm.moveH(1, "group"); },
  goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
  goWordRight: function (cm) { return cm.moveH(1, "word"); },
  delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
  delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
  delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
  delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
  delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
  delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
  indentAuto: function (cm) { return cm.indentSelection("smart"); },
  indentMore: function (cm) { return cm.indentSelection("add"); },
  indentLess: function (cm) { return cm.indentSelection("subtract"); },
  insertTab: function (cm) { return cm.replaceSelection("\t"); },
  insertSoftTab: function (cm) {
    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
    for (var i = 0; i < ranges.length; i++) {
      var pos = ranges[i].from();
      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
      spaces.push(spaceStr(tabSize - col % tabSize));
    }
    cm.replaceSelections(spaces);
  },
  defaultTab: function (cm) {
    if (cm.somethingSelected()) { cm.indentSelection("add"); }
    else { cm.execCommand("insertTab"); }
  },
  // Swap the two chars left and right of each selection's head.
  // Move cursor behind the two swapped characters afterwards.
  //
  // Doesn't consider line feeds a character.
  // Doesn't scan more than one line above to find a character.
  // Doesn't do anything on an empty line.
  // Doesn't do anything with non-empty selections.
  transposeChars: function (cm) { return runInOp(cm, function () {
    var ranges = cm.listSelections(), newSel = [];
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) { continue }
      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
      if (line) {
        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
        if (cur.ch > 0) {
          cur = new Pos(cur.line, cur.ch + 1);
          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                          Pos(cur.line, cur.ch - 2), cur, "+transpose");
        } else if (cur.line > cm.doc.first) {
          var prev = getLine(cm.doc, cur.line - 1).text;
          if (prev) {
            cur = new Pos(cur.line, 1);
            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                            prev.charAt(prev.length - 1),
                            Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
          }
        }
      }
      newSel.push(new Range(cur, cur));
    }
    cm.setSelections(newSel);
  }); },
  newlineAndIndent: function (cm) { return runInOp(cm, function () {
    var sels = cm.listSelections();
    for (var i = sels.length - 1; i >= 0; i--)
      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
    sels = cm.listSelections();
    for (var i$1 = 0; i$1 < sels.length; i$1++)
      { cm.indentLine(sels[i$1].from().line, null, true); }
    ensureCursorVisible(cm);
  }); },
  openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
};


function lineStart(cm, lineN) {
  var line = getLine(cm.doc, lineN);
  var visual = visualLine(line);
  if (visual != line) { lineN = lineNo(visual); }
  return endOfLine(true, cm, visual, lineN, 1)
}
function lineEnd(cm, lineN) {
  var line = getLine(cm.doc, lineN);
  var visual = visualLineEnd(line);
  if (visual != line) { lineN = lineNo(visual); }
  return endOfLine(true, cm, line, lineN, -1)
}
function lineStartSmart(cm, pos) {
  var start = lineStart(cm, pos.line);
  var line = getLine(cm.doc, start.line);
  var order = getOrder(line, cm.doc.direction);
  if (!order || order[0].level == 0) {
    var firstNonWS = Math.max(0, line.text.search(/\S/));
    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
  }
  return start
}

// Run a handler that was bound to a key.
function doHandleBinding(cm, bound, dropShift) {
  if (typeof bound == "string") {
    bound = commands[bound];
    if (!bound) { return false }
  }
  // Ensure previous input has been read, so that the handler sees a
  // consistent view of the document
  cm.display.input.ensurePolled();
  var prevShift = cm.display.shift, done = false;
  try {
    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
    if (dropShift) { cm.display.shift = false; }
    done = bound(cm) != Pass;
  } finally {
    cm.display.shift = prevShift;
    cm.state.suppressEdits = false;
  }
  return done
}

function lookupKeyForEditor(cm, name, handle) {
  for (var i = 0; i < cm.state.keyMaps.length; i++) {
    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
    if (result) { return result }
  }
  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
    || lookupKey(name, cm.options.keyMap, handle, cm)
}

// Note that, despite the name, this function is also used to check
// for bound mouse clicks.

var stopSeq = new Delayed;

function dispatchKey(cm, name, e, handle) {
  var seq = cm.state.keySeq;
  if (seq) {
    if (isModifierKey(name)) { return "handled" }
    if (/\'$/.test(name))
      { cm.state.keySeq = null; }
    else
      { stopSeq.set(50, function () {
        if (cm.state.keySeq == seq) {
          cm.state.keySeq = null;
          cm.display.input.reset();
        }
      }); }
    if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
  }
  return dispatchKeyInner(cm, name, e, handle)
}

function dispatchKeyInner(cm, name, e, handle) {
  var result = lookupKeyForEditor(cm, name, handle);

  if (result == "multi")
    { cm.state.keySeq = name; }
  if (result == "handled")
    { signalLater(cm, "keyHandled", cm, name, e); }

  if (result == "handled" || result == "multi") {
    e_preventDefault(e);
    restartBlink(cm);
  }

  return !!result
}

// Handle a key from the keydown event.
function handleKeyBinding(cm, e) {
  var name = keyName(e, true);
  if (!name) { return false }

  if (e.shiftKey && !cm.state.keySeq) {
    // First try to resolve full name (including 'Shift-'). Failing
    // that, see if there is a cursor-motion command (starting with
    // 'go') bound to the keyname without 'Shift-'.
    return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
        || dispatchKey(cm, name, e, function (b) {
             if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
               { return doHandleBinding(cm, b) }
           })
  } else {
    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
  }
}

// Handle a key from the keypress event
function handleCharBinding(cm, e, ch) {
  return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
}

var lastStoppedKey = null;
function onKeyDown(e) {
  var cm = this;
  cm.curOp.focus = activeElt();
  if (signalDOMEvent(cm, e)) { return }
  // IE does strange things with escape.
  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
  var code = e.keyCode;
  cm.display.shift = code == 16 || e.shiftKey;
  var handled = handleKeyBinding(cm, e);
  if (presto) {
    lastStoppedKey = handled ? code : null;
    // Opera has no cut event... we try to at least catch the key combo
    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
      { cm.replaceSelection("", null, "cut"); }
  }

  // Turn mouse into crosshair when Alt is held on Mac.
  if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
    { showCrossHair(cm); }
}

function showCrossHair(cm) {
  var lineDiv = cm.display.lineDiv;
  addClass(lineDiv, "CodeMirror-crosshair");

  function up(e) {
    if (e.keyCode == 18 || !e.altKey) {
      rmClass(lineDiv, "CodeMirror-crosshair");
      off(document, "keyup", up);
      off(document, "mouseover", up);
    }
  }
  on(document, "keyup", up);
  on(document, "mouseover", up);
}

function onKeyUp(e) {
  if (e.keyCode == 16) { this.doc.sel.shift = false; }
  signalDOMEvent(this, e);
}

function onKeyPress(e) {
  var cm = this;
  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
  var keyCode = e.keyCode, charCode = e.charCode;
  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
  // Some browsers fire keypress events for backspace
  if (ch == "\x08") { return }
  if (handleCharBinding(cm, e, ch)) { return }
  cm.display.input.onKeyPress(e);
}

var DOUBLECLICK_DELAY = 400;

var PastClick = function(time, pos, button) {
  this.time = time;
  this.pos = pos;
  this.button = button;
};

PastClick.prototype.compare = function (time, pos, button) {
  return this.time + DOUBLECLICK_DELAY > time &&
    cmp(pos, this.pos) == 0 && button == this.button
};

var lastClick;
var lastDoubleClick;
function clickRepeat(pos, button) {
  var now = +new Date;
  if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
    lastClick = lastDoubleClick = null;
    return "triple"
  } else if (lastClick && lastClick.compare(now, pos, button)) {
    lastDoubleClick = new PastClick(now, pos, button);
    lastClick = null;
    return "double"
  } else {
    lastClick = new PastClick(now, pos, button);
    lastDoubleClick = null;
    return "single"
  }
}

// A mouse down can be a single click, double click, triple click,
// start of selection drag, start of text drag, new cursor
// (ctrl-click), rectangle drag (alt-drag), or xwin
// middle-click-paste. Or it might be a click on something we should
// not interfere with, such as a scrollbar or widget.
function onMouseDown(e) {
  var cm = this, display = cm.display;
  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
  display.input.ensurePolled();
  display.shift = e.shiftKey;

  if (eventInWidget(display, e)) {
    if (!webkit) {
      // Briefly turn off draggability, to allow widgets to do
      // normal dragging things.
      display.scroller.draggable = false;
      setTimeout(function () { return display.scroller.draggable = true; }, 100);
    }
    return
  }
  if (clickInGutter(cm, e)) { return }
  var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
  window.focus();

  // #3261: make sure, that we're not starting a second selection
  if (button == 1 && cm.state.selectingText)
    { cm.state.selectingText(e); }

  if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

  if (button == 1) {
    if (pos) { leftButtonDown(cm, pos, repeat, e); }
    else if (e_target(e) == display.scroller) { e_preventDefault(e); }
  } else if (button == 2) {
    if (pos) { extendSelection(cm.doc, pos); }
    setTimeout(function () { return display.input.focus(); }, 20);
  } else if (button == 3) {
    if (captureRightClick) { onContextMenu(cm, e); }
    else { delayBlurEvent(cm); }
  }
}

function handleMappedButton(cm, button, pos, repeat, event) {
  var name = "Click";
  if (repeat == "double") { name = "Double" + name; }
  else if (repeat == "triple") { name = "Triple" + name; }
  name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

  return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
    if (typeof bound == "string") { bound = commands[bound]; }
    if (!bound) { return false }
    var done = false;
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
      done = bound(cm, pos) != Pass;
    } finally {
      cm.state.suppressEdits = false;
    }
    return done
  })
}

function configureMouse(cm, repeat, event) {
  var option = cm.getOption("configureMouse");
  var value = option ? option(cm, repeat, event) : {};
  if (value.unit == null) {
    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
    value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
  }
  if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
  if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
  if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
  return value
}

function leftButtonDown(cm, pos, repeat, event) {
  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
  else { cm.curOp.focus = activeElt(); }

  var behavior = configureMouse(cm, repeat, event);

  var sel = cm.doc.sel, contained;
  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
      repeat == "single" && (contained = sel.contains(pos)) > -1 &&
      (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
      (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
    { leftButtonStartDrag(cm, event, pos, behavior); }
  else
    { leftButtonSelect(cm, event, pos, behavior); }
}

// Start a text drag. When it ends, see if any dragging actually
// happen, and treat as a click if it didn't.
function leftButtonStartDrag(cm, event, pos, behavior) {
  var display = cm.display, moved = false;
  var dragEnd = operation(cm, function (e) {
    if (webkit) { display.scroller.draggable = false; }
    cm.state.draggingText = false;
    off(display.wrapper.ownerDocument, "mouseup", dragEnd);
    off(display.wrapper.ownerDocument, "mousemove", mouseMove);
    off(display.scroller, "dragstart", dragStart);
    off(display.scroller, "drop", dragEnd);
    if (!moved) {
      e_preventDefault(e);
      if (!behavior.addNew)
        { extendSelection(cm.doc, pos, null, null, behavior.extend); }
      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
      if (webkit || ie && ie_version == 9)
        { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }
      else
        { display.input.focus(); }
    }
  });
  var mouseMove = function(e2) {
    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
  };
  var dragStart = function () { return moved = true; };
  // Let the drag handler handle this.
  if (webkit) { display.scroller.draggable = true; }
  cm.state.draggingText = dragEnd;
  dragEnd.copy = !behavior.moveOnDrag;
  // IE's approach to draggable
  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
  on(display.wrapper.ownerDocument, "mouseup", dragEnd);
  on(display.wrapper.ownerDocument, "mousemove", mouseMove);
  on(display.scroller, "dragstart", dragStart);
  on(display.scroller, "drop", dragEnd);

  delayBlurEvent(cm);
  setTimeout(function () { return display.input.focus(); }, 20);
}

function rangeForUnit(cm, pos, unit) {
  if (unit == "char") { return new Range(pos, pos) }
  if (unit == "word") { return cm.findWordAt(pos) }
  if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
  var result = unit(cm, pos);
  return new Range(result.from, result.to)
}

// Normal selection, as opposed to text dragging.
function leftButtonSelect(cm, event, start, behavior) {
  var display = cm.display, doc = cm.doc;
  e_preventDefault(event);

  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
  if (behavior.addNew && !behavior.extend) {
    ourIndex = doc.sel.contains(start);
    if (ourIndex > -1)
      { ourRange = ranges[ourIndex]; }
    else
      { ourRange = new Range(start, start); }
  } else {
    ourRange = doc.sel.primary();
    ourIndex = doc.sel.primIndex;
  }

  if (behavior.unit == "rectangle") {
    if (!behavior.addNew) { ourRange = new Range(start, start); }
    start = posFromMouse(cm, event, true, true);
    ourIndex = -1;
  } else {
    var range$$1 = rangeForUnit(cm, start, behavior.unit);
    if (behavior.extend)
      { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }
    else
      { ourRange = range$$1; }
  }

  if (!behavior.addNew) {
    ourIndex = 0;
    setSelection(doc, new Selection([ourRange], 0), sel_mouse);
    startSel = doc.sel;
  } else if (ourIndex == -1) {
    ourIndex = ranges.length;
    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
                 {scroll: false, origin: "*mouse"});
  } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                 {scroll: false, origin: "*mouse"});
    startSel = doc.sel;
  } else {
    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
  }

  var lastPos = start;
  function extendTo(pos) {
    if (cmp(lastPos, pos) == 0) { return }
    lastPos = pos;

    if (behavior.unit == "rectangle") {
      var ranges = [], tabSize = cm.options.tabSize;
      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
           line <= end; line++) {
        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
        if (left == right)
          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
        else if (text.length > leftPos)
          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
      }
      if (!ranges.length) { ranges.push(new Range(start, start)); }
      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                   {origin: "*mouse", scroll: false});
      cm.scrollIntoView(pos);
    } else {
      var oldRange = ourRange;
      var range$$1 = rangeForUnit(cm, pos, behavior.unit);
      var anchor = oldRange.anchor, head;
      if (cmp(range$$1.anchor, anchor) > 0) {
        head = range$$1.head;
        anchor = minPos(oldRange.from(), range$$1.anchor);
      } else {
        head = range$$1.anchor;
        anchor = maxPos(oldRange.to(), range$$1.head);
      }
      var ranges$1 = startSel.ranges.slice(0);
      ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
    }
  }

  var editorSize = display.wrapper.getBoundingClientRect();
  // Used to ensure timeout re-tries don't fire when another extend
  // happened in the meantime (clearTimeout isn't reliable -- at
  // least on Chrome, the timeouts still happen even when cleared,
  // if the clear happens after their scheduled firing time).
  var counter = 0;

  function extend(e) {
    var curCount = ++counter;
    var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
    if (!cur) { return }
    if (cmp(cur, lastPos) != 0) {
      cm.curOp.focus = activeElt();
      extendTo(cur);
      var visible = visibleLines(display, doc);
      if (cur.line >= visible.to || cur.line < visible.from)
        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
    } else {
      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
      if (outside) { setTimeout(operation(cm, function () {
        if (counter != curCount) { return }
        display.scroller.scrollTop += outside;
        extend(e);
      }), 50); }
    }
  }

  function done(e) {
    cm.state.selectingText = false;
    counter = Infinity;
    e_preventDefault(e);
    display.input.focus();
    off(display.wrapper.ownerDocument, "mousemove", move);
    off(display.wrapper.ownerDocument, "mouseup", up);
    doc.history.lastSelOrigin = null;
  }

  var move = operation(cm, function (e) {
    if (!e_button(e)) { done(e); }
    else { extend(e); }
  });
  var up = operation(cm, done);
  cm.state.selectingText = up;
  on(display.wrapper.ownerDocument, "mousemove", move);
  on(display.wrapper.ownerDocument, "mouseup", up);
}

// Used when mouse-selecting to adjust the anchor to the proper side
// of a bidi jump depending on the visual position of the head.
function bidiSimplify(cm, range$$1) {
  var anchor = range$$1.anchor;
  var head = range$$1.head;
  var anchorLine = getLine(cm.doc, anchor.line);
  if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }
  var order = getOrder(anchorLine);
  if (!order) { return range$$1 }
  var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
  if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }
  var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
  if (boundary == 0 || boundary == order.length) { return range$$1 }

  // Compute the relative visual position of the head compared to the
  // anchor (<0 is to the left, >0 to the right)
  var leftSide;
  if (head.line != anchor.line) {
    leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
  } else {
    var headIndex = getBidiPartAt(order, head.ch, head.sticky);
    var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
    if (headIndex == boundary - 1 || headIndex == boundary)
      { leftSide = dir < 0; }
    else
      { leftSide = dir > 0; }
  }

  var usePart = order[boundary + (leftSide ? -1 : 0)];
  var from = leftSide == (usePart.level == 1);
  var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
  return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)
}


// Determines whether an event happened in the gutter, and fires the
// handlers for the corresponding event.
function gutterEvent(cm, e, type, prevent) {
  var mX, mY;
  if (e.touches) {
    mX = e.touches[0].clientX;
    mY = e.touches[0].clientY;
  } else {
    try { mX = e.clientX; mY = e.clientY; }
    catch(e) { return false }
  }
  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
  if (prevent) { e_preventDefault(e); }

  var display = cm.display;
  var lineBox = display.lineDiv.getBoundingClientRect();

  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
  mY -= lineBox.top - display.viewOffset;

  for (var i = 0; i < cm.options.gutters.length; ++i) {
    var g = display.gutters.childNodes[i];
    if (g && g.getBoundingClientRect().right >= mX) {
      var line = lineAtHeight(cm.doc, mY);
      var gutter = cm.options.gutters[i];
      signal(cm, type, cm, line, gutter, e);
      return e_defaultPrevented(e)
    }
  }
}

function clickInGutter(cm, e) {
  return gutterEvent(cm, e, "gutterClick", true)
}

// CONTEXT MENU HANDLING

// To make the context menu work, we need to briefly unhide the
// textarea (making it as unobtrusive as possible) to let the
// right-click take effect on it.
function onContextMenu(cm, e) {
  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
  if (signalDOMEvent(cm, e, "contextmenu")) { return }
  cm.display.input.onContextMenu(e);
}

function contextMenuInGutter(cm, e) {
  if (!hasHandler(cm, "gutterContextMenu")) { return false }
  return gutterEvent(cm, e, "gutterContextMenu", false)
}

function themeChanged(cm) {
  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
    cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
  clearCaches(cm);
}

var Init = {toString: function(){return "CodeMirror.Init"}};

var defaults = {};
var optionHandlers = {};

function defineOptions(CodeMirror) {
  var optionHandlers = CodeMirror.optionHandlers;

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) { optionHandlers[name] =
      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
  }

  CodeMirror.defineOption = option;

  // Passed to option handlers when there is no old value.
  CodeMirror.Init = Init;

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function (cm, val) { return cm.setValue(val); }, true);
  option("mode", null, function (cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function (cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);

  option("lineSeparator", null, function (cm, val) {
    cm.doc.lineSep = val;
    if (!val) { return }
    var newBreaks = [], lineNo = cm.doc.first;
    cm.doc.iter(function (line) {
      for (var pos = 0;;) {
        var found = line.text.indexOf(val, pos);
        if (found == -1) { break }
        pos = found + val.length;
        newBreaks.push(Pos(lineNo, found));
      }
      lineNo++;
    });
    for (var i = newBreaks.length - 1; i >= 0; i--)
      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
  });
  option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
    if (old != Init) { cm.refresh(); }
  });
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
  option("electricChars", true);
  option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
    throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
  }, true);
  option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
  option("rtlMoveVisually", !windows);
  option("wholeLineUpdateBefore", true);

  option("theme", "default", function (cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", function (cm, val, old) {
    var next = getKeyMap(val);
    var prev = old != Init && getKeyMap(old);
    if (prev && prev.detach) { prev.detach(cm, next); }
    if (next.attach) { next.attach(cm, prev || null); }
  });
  option("extraKeys", null);
  option("configureMouse", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function (cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
  option("scrollbarStyle", "native", function (cm) {
    initScrollbars(cm);
    updateScrollbars(cm);
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
  }, true);
  option("lineNumbers", false, function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function (integer) { return integer; }, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("resetSelectionOnContextMenu", true);
  option("lineWiseCopyCut", true);
  option("pasteLinesPerSelection", true);

  option("readOnly", false, function (cm, val) {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
    }
    cm.display.input.readOnlyChanged(val);
  });
  option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
  option("dragDrop", true, dragDropChanged);
  option("allowDropFileTypes", null);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1, updateSelection, true);
  option("singleCursorHeightPerLine", true, updateSelection, true);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true, resetModeState, true);
  option("addModeClass", false, resetModeState, true);
  option("pollInterval", 100);
  option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
  option("historyEventDelay", 1250);
  option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
  option("maxHighlightLength", 10000, resetModeState, true);
  option("moveInputWithCursor", true, function (cm, val) {
    if (!val) { cm.display.input.resetPosition(); }
  });

  option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
  option("autofocus", null);
  option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
}

function guttersChanged(cm) {
  updateGutters(cm);
  regChange(cm);
  alignHorizontally(cm);
}

function dragDropChanged(cm, value, old) {
  var wasOn = old && old != Init;
  if (!value != !wasOn) {
    var funcs = cm.display.dragFunctions;
    var toggle = value ? on : off;
    toggle(cm.display.scroller, "dragstart", funcs.start);
    toggle(cm.display.scroller, "dragenter", funcs.enter);
    toggle(cm.display.scroller, "dragover", funcs.over);
    toggle(cm.display.scroller, "dragleave", funcs.leave);
    toggle(cm.display.scroller, "drop", funcs.drop);
  }
}

function wrappingChanged(cm) {
  if (cm.options.lineWrapping) {
    addClass(cm.display.wrapper, "CodeMirror-wrap");
    cm.display.sizer.style.minWidth = "";
    cm.display.sizerWidth = null;
  } else {
    rmClass(cm.display.wrapper, "CodeMirror-wrap");
    findMaxLine(cm);
  }
  estimateLineHeights(cm);
  regChange(cm);
  clearCaches(cm);
  setTimeout(function () { return updateScrollbars(cm); }, 100);
}

// A CodeMirror instance represents an editor. This is the object
// that user code is usually dealing with.

function CodeMirror$1(place, options) {
  var this$1 = this;

  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }

  this.options = options = options ? copyObj(options) : {};
  // Determine effective options based on given values and defaults.
  copyObj(defaults, options, false);
  setGuttersForLineNumbers(options);

  var doc = options.value;
  if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
  this.doc = doc;

  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);
  var display = this.display = new Display(place, doc, input);
  display.wrapper.CodeMirror = this;
  updateGutters(this);
  themeChanged(this);
  if (options.lineWrapping)
    { this.display.wrapper.className += " CodeMirror-wrap"; }
  initScrollbars(this);

  this.state = {
    keyMaps: [],  // stores maps added by addKeyMap
    overlays: [], // highlighting overlays, as added by addOverlay
    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
    overwrite: false,
    delayingBlurEvent: false,
    focused: false,
    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
    selectingText: false,
    draggingText: false,
    highlight: new Delayed(), // stores highlight worker timeout
    keySeq: null,  // Unfinished key sequence
    specialChars: null
  };

  if (options.autofocus && !mobile) { display.input.focus(); }

  // Override magic textarea content restore that IE sometimes does
  // on our hidden textarea on reload
  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

  registerEventHandlers(this);
  ensureGlobalHandlers();

  startOperation(this);
  this.curOp.forceUpdate = true;
  attachDoc(this, doc);

  if ((options.autofocus && !mobile) || this.hasFocus())
    { setTimeout(bind(onFocus, this), 20); }
  else
    { onBlur(this); }

  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
    { optionHandlers[opt](this$1, options[opt], Init); } }
  maybeUpdateLineNumberWidth(this);
  if (options.finishInit) { options.finishInit(this); }
  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }
  endOperation(this);
  // Suppress optimizelegibility in Webkit, since it breaks text
  // measuring on line wrapping boundaries.
  if (webkit && options.lineWrapping &&
      getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
    { display.lineDiv.style.textRendering = "auto"; }
}

// The default configuration options.
CodeMirror$1.defaults = defaults;
// Functions to run when options are changed.
CodeMirror$1.optionHandlers = optionHandlers;

// Attach the necessary event handlers when initializing the editor
function registerEventHandlers(cm) {
  var d = cm.display;
  on(d.scroller, "mousedown", operation(cm, onMouseDown));
  // Older IE's will not fire a second mousedown for a double click
  if (ie && ie_version < 11)
    { on(d.scroller, "dblclick", operation(cm, function (e) {
      if (signalDOMEvent(cm, e)) { return }
      var pos = posFromMouse(cm, e);
      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
      e_preventDefault(e);
      var word = cm.findWordAt(pos);
      extendSelection(cm.doc, word.anchor, word.head);
    })); }
  else
    { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
  // Some browsers fire contextmenu *after* opening the menu, at
  // which point we can't mess with it anymore. Context menu is
  // handled in onMouseDown for these browsers.
  if (!captureRightClick) { on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); }); }

  // Used to suppress mouse event handling when a touch happens
  var touchFinished, prevTouch = {end: 0};
  function finishTouch() {
    if (d.activeTouch) {
      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
      prevTouch = d.activeTouch;
      prevTouch.end = +new Date;
    }
  }
  function isMouseLikeTouchEvent(e) {
    if (e.touches.length != 1) { return false }
    var touch = e.touches[0];
    return touch.radiusX <= 1 && touch.radiusY <= 1
  }
  function farAway(touch, other) {
    if (other.left == null) { return true }
    var dx = other.left - touch.left, dy = other.top - touch.top;
    return dx * dx + dy * dy > 20 * 20
  }
  on(d.scroller, "touchstart", function (e) {
    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
      d.input.ensurePolled();
      clearTimeout(touchFinished);
      var now = +new Date;
      d.activeTouch = {start: now, moved: false,
                       prev: now - prevTouch.end <= 300 ? prevTouch : null};
      if (e.touches.length == 1) {
        d.activeTouch.left = e.touches[0].pageX;
        d.activeTouch.top = e.touches[0].pageY;
      }
    }
  });
  on(d.scroller, "touchmove", function () {
    if (d.activeTouch) { d.activeTouch.moved = true; }
  });
  on(d.scroller, "touchend", function (e) {
    var touch = d.activeTouch;
    if (touch && !eventInWidget(d, e) && touch.left != null &&
        !touch.moved && new Date - touch.start < 300) {
      var pos = cm.coordsChar(d.activeTouch, "page"), range;
      if (!touch.prev || farAway(touch, touch.prev)) // Single tap
        { range = new Range(pos, pos); }
      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
        { range = cm.findWordAt(pos); }
      else // Triple tap
        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
      cm.setSelection(range.anchor, range.head);
      cm.focus();
      e_preventDefault(e);
    }
    finishTouch();
  });
  on(d.scroller, "touchcancel", finishTouch);

  // Sync scrolling between fake scrollbars and real scrollable
  // area, ensure viewport is updated when scrolling.
  on(d.scroller, "scroll", function () {
    if (d.scroller.clientHeight) {
      updateScrollTop(cm, d.scroller.scrollTop);
      setScrollLeft(cm, d.scroller.scrollLeft, true);
      signal(cm, "scroll", cm);
    }
  });

  // Listen to wheel events in order to try and update the viewport on time.
  on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
  on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

  // Prevent wrapper from ever scrolling
  on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

  d.dragFunctions = {
    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
    start: function (e) { return onDragStart(cm, e); },
    drop: operation(cm, onDrop),
    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
  };

  var inp = d.input.getField();
  on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
  on(inp, "keydown", operation(cm, onKeyDown));
  on(inp, "keypress", operation(cm, onKeyPress));
  on(inp, "focus", function (e) { return onFocus(cm, e); });
  on(inp, "blur", function (e) { return onBlur(cm, e); });
}

var initHooks = [];
CodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };

// Indent the given line. The how parameter can be "smart",
// "add"/null, "subtract", or "prev". When aggressive is false
// (typically set to true for forced single-line indents), empty
// lines are not indented, and places where the mode returns Pass
// are left alone.
function indentLine(cm, n, how, aggressive) {
  var doc = cm.doc, state;
  if (how == null) { how = "add"; }
  if (how == "smart") {
    // Fall back to "prev" when the mode doesn't have an indentation
    // method.
    if (!doc.mode.indent) { how = "prev"; }
    else { state = getContextBefore(cm, n).state; }
  }

  var tabSize = cm.options.tabSize;
  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
  if (line.stateAfter) { line.stateAfter = null; }
  var curSpaceString = line.text.match(/^\s*/)[0], indentation;
  if (!aggressive && !/\S/.test(line.text)) {
    indentation = 0;
    how = "not";
  } else if (how == "smart") {
    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
    if (indentation == Pass || indentation > 150) {
      if (!aggressive) { return }
      how = "prev";
    }
  }
  if (how == "prev") {
    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
    else { indentation = 0; }
  } else if (how == "add") {
    indentation = curSpace + cm.options.indentUnit;
  } else if (how == "subtract") {
    indentation = curSpace - cm.options.indentUnit;
  } else if (typeof how == "number") {
    indentation = curSpace + how;
  }
  indentation = Math.max(0, indentation);

  var indentString = "", pos = 0;
  if (cm.options.indentWithTabs)
    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
  if (pos < indentation) { indentString += spaceStr(indentation - pos); }

  if (indentString != curSpaceString) {
    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
    line.stateAfter = null;
    return true
  } else {
    // Ensure that, if the cursor was in the whitespace at the start
    // of the line, it is moved to the end of that space.
    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
      var range = doc.sel.ranges[i$1];
      if (range.head.line == n && range.head.ch < curSpaceString.length) {
        var pos$1 = Pos(n, curSpaceString.length);
        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
        break
      }
    }
  }
}

// This will be set to a {lineWise: bool, text: [string]} object, so
// that, when pasting, we know what kind of selections the copied
// text was made out of.
var lastCopied = null;

function setLastCopied(newLastCopied) {
  lastCopied = newLastCopied;
}

function applyTextInput(cm, inserted, deleted, sel, origin) {
  var doc = cm.doc;
  cm.display.shift = false;
  if (!sel) { sel = doc.sel; }

  var paste = cm.state.pasteIncoming || origin == "paste";
  var textLines = splitLinesAuto(inserted), multiPaste = null;
  // When pasting N lines into N selections, insert one line per selection
  if (paste && sel.ranges.length > 1) {
    if (lastCopied && lastCopied.text.join("\n") == inserted) {
      if (sel.ranges.length % lastCopied.text.length == 0) {
        multiPaste = [];
        for (var i = 0; i < lastCopied.text.length; i++)
          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
      }
    } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
      multiPaste = map(textLines, function (l) { return [l]; });
    }
  }

  var updateInput;
  // Normal behavior is to insert the new text into every selection
  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
    var range$$1 = sel.ranges[i$1];
    var from = range$$1.from(), to = range$$1.to();
    if (range$$1.empty()) {
      if (deleted && deleted > 0) // Handle deletion
        { from = Pos(from.line, from.ch - deleted); }
      else if (cm.state.overwrite && !paste) // Handle overwrite
        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
        { from = to = Pos(from.line, 0); }
    }
    updateInput = cm.curOp.updateInput;
    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                       origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
    makeChange(cm.doc, changeEvent);
    signalLater(cm, "inputRead", cm, changeEvent);
  }
  if (inserted && !paste)
    { triggerElectric(cm, inserted); }

  ensureCursorVisible(cm);
  cm.curOp.updateInput = updateInput;
  cm.curOp.typing = true;
  cm.state.pasteIncoming = cm.state.cutIncoming = false;
}

function handlePaste(e, cm) {
  var pasted = e.clipboardData && e.clipboardData.getData("Text");
  if (pasted) {
    e.preventDefault();
    if (!cm.isReadOnly() && !cm.options.disableInput)
      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
    return true
  }
}

function triggerElectric(cm, inserted) {
  // When an 'electric' character is inserted, immediately trigger a reindent
  if (!cm.options.electricChars || !cm.options.smartIndent) { return }
  var sel = cm.doc.sel;

  for (var i = sel.ranges.length - 1; i >= 0; i--) {
    var range$$1 = sel.ranges[i];
    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }
    var mode = cm.getModeAt(range$$1.head);
    var indented = false;
    if (mode.electricChars) {
      for (var j = 0; j < mode.electricChars.length; j++)
        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
          indented = indentLine(cm, range$$1.head.line, "smart");
          break
        } }
    } else if (mode.electricInput) {
      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))
        { indented = indentLine(cm, range$$1.head.line, "smart"); }
    }
    if (indented) { signalLater(cm, "electricInput", cm, range$$1.head.line); }
  }
}

function copyableRanges(cm) {
  var text = [], ranges = [];
  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
    var line = cm.doc.sel.ranges[i].head.line;
    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
    ranges.push(lineRange);
    text.push(cm.getRange(lineRange.anchor, lineRange.head));
  }
  return {text: text, ranges: ranges}
}

function disableBrowserMagic(field, spellcheck) {
  field.setAttribute("autocorrect", "off");
  field.setAttribute("autocapitalize", "off");
  field.setAttribute("spellcheck", !!spellcheck);
}

function hiddenTextarea() {
  var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
  var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
  // The textarea is kept positioned near the cursor to prevent the
  // fact that it'll be scrolled into view on input from scrolling
  // our fake cursor out of view. On webkit, when wrap=off, paste is
  // very slow. So make the area wide instead.
  if (webkit) { te.style.width = "1000px"; }
  else { te.setAttribute("wrap", "off"); }
  // If border: 0; -- iOS fails to open keyboard (issue #1287)
  if (ios) { te.style.border = "1px solid black"; }
  disableBrowserMagic(te);
  return div
}

// The publicly visible API. Note that methodOp(f) means
// 'wrap f in an operation, performed on its `this` parameter'.

// This is not the complete set of editor methods. Most of the
// methods defined on the Doc type are also injected into
// CodeMirror.prototype, for backwards compatibility and
// convenience.

var addEditorMethods = function(CodeMirror) {
  var optionHandlers = CodeMirror.optionHandlers;

  var helpers = CodeMirror.helpers = {};

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); this.display.input.focus();},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") { return }
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        { operation(this, optionHandlers[option])(this, value, old); }
      signal(this, "optionChange", this, option);
    },

    getOption: function(option) {return this.options[option]},
    getDoc: function() {return this.doc},

    addKeyMap: function(map$$1, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
    },
    removeKeyMap: function(map$$1) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        { if (maps[i] == map$$1 || maps[i].name == map$$1) {
          maps.splice(i, 1);
          return true
        } }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) { throw new Error("Overlays may not be stateful.") }
      insertSorted(this.state.overlays,
                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                    priority: (options && options.priority) || 0},
                   function (overlay) { return overlay.priority; });
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      var this$1 = this;

      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this$1.state.modeGen++;
          regChange(this$1);
          return
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
        else { dir = dir ? "add" : "subtract"; }
      }
      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
    }),
    indentSelection: methodOp(function(how) {
      var this$1 = this;

      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range$$1 = ranges[i];
        if (!range$$1.empty()) {
          var from = range$$1.from(), to = range$$1.to();
          var start = Math.max(end, from.line);
          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            { indentLine(this$1, j, how); }
          var newRanges = this$1.doc.sel.ranges;
          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
        } else if (range$$1.head.line > end) {
          indentLine(this$1, range$$1.head.line, how, true);
          end = range$$1.head.line;
          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      return takeToken(this, pos, precise)
    },

    getLineTokens: function(line, precise) {
      return takeToken(this, Pos(line), precise, true)
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0) { type = styles[2]; }
      else { for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
        else { type = styles[mid * 2 + 2]; break }
      } }
      var cut = type ? type.indexOf("overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) { return mode }
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0]
    },

    getHelpers: function(pos, type) {
      var this$1 = this;

      var found = [];
      if (!helpers.hasOwnProperty(type)) { return found }
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) { found.push(help[mode[type]]); }
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) { found.push(val); }
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i$1 = 0; i$1 < help._global.length; i$1++) {
        var cur = help._global[i$1];
        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
          { found.push(cur.val); }
      }
      return found
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getContextBefore(this, line + 1, precise).state
    },

    cursorCoords: function(start, mode) {
      var pos, range$$1 = this.doc.sel.primary();
      if (start == null) { pos = range$$1.head; }
      else if (typeof start == "object") { pos = clipPos(this.doc, start); }
      else { pos = start ? range$$1.from() : range$$1.to(); }
      return cursorCoords(this, pos, mode || "page")
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page")
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top)
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset)
    },
    heightAtLine: function(line, mode, includeWidgets) {
      var end = false, lineObj;
      if (typeof line == "number") {
        var last = this.doc.first + this.doc.size - 1;
        if (line < this.doc.first) { line = this.doc.first; }
        else if (line > last) { line = last; end = true; }
        lineObj = getLine(this.doc, line);
      } else {
        lineObj = line;
      }
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0)
    },

    defaultTextHeight: function() { return textHeight(this.display) },
    defaultCharWidth: function() { return charWidth(this.display) },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      node.setAttribute("cm-ignore-events", "true");
      this.display.input.setUneditable(node);
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          { top = pos.top - node.offsetHeight; }
        else if (pos.bottom + node.offsetHeight <= vspace)
          { top = pos.bottom; }
        if (left + node.offsetWidth > hspace)
          { left = hspace - node.offsetWidth; }
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") { left = 0; }
        else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
        node.style.left = left + "px";
      }
      if (scroll)
        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: onKeyUp,
    triggerOnMouseDown: methodOp(onMouseDown),

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        { return commands[cmd].call(null, this) }
    },

    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

    findPosH: function(from, amount, unit, visually) {
      var this$1 = this;

      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      var cur = clipPos(this.doc, from);
      for (var i = 0; i < amount; ++i) {
        cur = findPosH(this$1.doc, cur, dir, unit, visually);
        if (cur.hitSide) { break }
      }
      return cur
    },

    moveH: methodOp(function(dir, unit) {
      var this$1 = this;

      this.extendSelectionsBy(function (range$$1) {
        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())
          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }
        else
          { return dir < 0 ? range$$1.from() : range$$1.to() }
      }, sel_move);
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        { doc.replaceSelection("", null, "+delete"); }
      else
        { deleteNearSelection(this, function (range$$1) {
          var other = findPosH(doc, range$$1.head, dir, unit, false);
          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}
        }); }
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var this$1 = this;

      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      var cur = clipPos(this.doc, from);
      for (var i = 0; i < amount; ++i) {
        var coords = cursorCoords(this$1, cur, "div");
        if (x == null) { x = coords.left; }
        else { coords.left = x; }
        cur = findPosV(this$1, coords, dir, unit);
        if (cur.hitSide) { break }
      }
      return cur
    },

    moveV: methodOp(function(dir, unit) {
      var this$1 = this;

      var doc = this.doc, goals = [];
      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function (range$$1) {
        if (collapse)
          { return dir < 0 ? range$$1.from() : range$$1.to() }
        var headPos = cursorCoords(this$1, range$$1.head, "div");
        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }
        goals.push(headPos.left);
        var pos = findPosV(this$1, headPos, dir, unit);
        if (unit == "page" && range$$1 == doc.sel.primary())
          { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
        return pos
      }, sel_move);
      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
        { doc.sel.ranges[i].goalColumn = goals[i]; } }
    }),

    // Find the word at the given position (as returned by coordsChar).
    findWordAt: function(pos) {
      var doc = this.doc, line = getLine(doc, pos.line).text;
      var start = pos.ch, end = pos.ch;
      if (line) {
        var helper = this.getHelper(pos, "wordChars");
        if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
        var startChar = line.charAt(start);
        var check = isWordChar(startChar, helper)
          ? function (ch) { return isWordChar(ch, helper); }
          : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
          : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
        while (start > 0 && check(line.charAt(start - 1))) { --start; }
        while (end < line.length && check(line.charAt(end))) { ++end; }
      }
      return new Range(Pos(pos.line, start), Pos(pos.line, end))
    },

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) { return }
      if (this.state.overwrite = !this.state.overwrite)
        { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
      else
        { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() { return this.display.input.getField() == activeElt() },
    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
    getScrollInfo: function() {
      var scroller = this.display.scroller;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
    },

    scrollIntoView: methodOp(function(range$$1, margin) {
      if (range$$1 == null) {
        range$$1 = {from: this.doc.sel.primary().head, to: null};
        if (margin == null) { margin = this.options.cursorScrollMargin; }
      } else if (typeof range$$1 == "number") {
        range$$1 = {from: Pos(range$$1, 0), to: null};
      } else if (range$$1.from == null) {
        range$$1 = {from: range$$1, to: null};
      }
      if (!range$$1.to) { range$$1.to = range$$1.from; }
      range$$1.margin = margin || 0;

      if (range$$1.from.line != null) {
        scrollToRange(this, range$$1);
      } else {
        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
      }
    }),

    setSize: methodOp(function(width, height) {
      var this$1 = this;

      var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
      if (width != null) { this.display.wrapper.style.width = interpret(width); }
      if (height != null) { this.display.wrapper.style.height = interpret(height); }
      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
      var lineNo$$1 = this.display.viewFrom;
      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, "widget"); break } } }
        ++lineNo$$1;
      });
      this.curOp.forceUpdate = true;
      signal(this, "refresh", this);
    }),

    operation: function(f){return runInOp(this, f)},
    startOperation: function(){return startOperation(this)},
    endOperation: function(){return endOperation(this)},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        { estimateLineHeights(this); }
      signal(this, "refresh", this);
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      this.display.input.reset();
      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
      this.curOp.forceScroll = true;
      signalLater(this, "swapDoc", this, old);
      return old
    }),

    getInputField: function(){return this.display.input.getField()},
    getWrapperElement: function(){return this.display.wrapper},
    getScrollerElement: function(){return this.display.scroller},
    getGutterElement: function(){return this.display.gutters}
  };
  eventMixin(CodeMirror);

  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };
};

// Used for horizontal relative motion. Dir is -1 or 1 (left or
// right), unit can be "char", "column" (like char, but doesn't
// cross line boundaries), "word" (across next word), or "group" (to
// the start of next group of word or non-word-non-whitespace
// chars). The visually param controls whether, in right-to-left
// text, direction 1 means to move towards the next index in the
// string, or towards the character to the right of the current
// position. The resulting position will have a hitSide=true
// property if it reached the end of the document.
function findPosH(doc, pos, dir, unit, visually) {
  var oldPos = pos;
  var origDir = dir;
  var lineObj = getLine(doc, pos.line);
  function findNextLine() {
    var l = pos.line + dir;
    if (l < doc.first || l >= doc.first + doc.size) { return false }
    pos = new Pos(l, pos.ch, pos.sticky);
    return lineObj = getLine(doc, l)
  }
  function moveOnce(boundToLine) {
    var next;
    if (visually) {
      next = moveVisually(doc.cm, lineObj, pos, dir);
    } else {
      next = moveLogically(lineObj, pos, dir);
    }
    if (next == null) {
      if (!boundToLine && findNextLine())
        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }
      else
        { return false }
    } else {
      pos = next;
    }
    return true
  }

  if (unit == "char") {
    moveOnce();
  } else if (unit == "column") {
    moveOnce(true);
  } else if (unit == "word" || unit == "group") {
    var sawType = null, group = unit == "group";
    var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
    for (var first = true;; first = false) {
      if (dir < 0 && !moveOnce(!first)) { break }
      var cur = lineObj.text.charAt(pos.ch) || "\n";
      var type = isWordChar(cur, helper) ? "w"
        : group && cur == "\n" ? "n"
        : !group || /\s/.test(cur) ? null
        : "p";
      if (group && !first && !type) { type = "s"; }
      if (sawType && sawType != type) {
        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
        break
      }

      if (type) { sawType = type; }
      if (dir > 0 && !moveOnce(!first)) { break }
    }
  }
  var result = skipAtomic(doc, pos, oldPos, origDir, true);
  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
  return result
}

// For relative vertical movement. Dir may be -1 or 1. Unit can be
// "page" or "line". The resulting position will have a hitSide=true
// property if it reached the end of the document.
function findPosV(cm, pos, dir, unit) {
  var doc = cm.doc, x = pos.left, y;
  if (unit == "page") {
    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

  } else if (unit == "line") {
    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
  }
  var target;
  for (;;) {
    target = coordsChar(cm, x, y);
    if (!target.outside) { break }
    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
    y += dir * 5;
  }
  return target
}

// CONTENTEDITABLE INPUT STYLE

var ContentEditableInput = function(cm) {
  this.cm = cm;
  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
  this.polling = new Delayed();
  this.composing = null;
  this.gracePeriod = false;
  this.readDOMTimeout = null;
};

ContentEditableInput.prototype.init = function (display) {
    var this$1 = this;

  var input = this, cm = input.cm;
  var div = input.div = display.lineDiv;
  disableBrowserMagic(div, cm.options.spellcheck);

  on(div, "paste", function (e) {
    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
    // IE doesn't fire input events, so we schedule a read for the pasted content in this way
    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
  });

  on(div, "compositionstart", function (e) {
    this$1.composing = {data: e.data, done: false};
  });
  on(div, "compositionupdate", function (e) {
    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
  });
  on(div, "compositionend", function (e) {
    if (this$1.composing) {
      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
      this$1.composing.done = true;
    }
  });

  on(div, "touchstart", function () { return input.forceCompositionEnd(); });

  on(div, "input", function () {
    if (!this$1.composing) { this$1.readFromDOMSoon(); }
  });

  function onCopyCut(e) {
    if (signalDOMEvent(cm, e)) { return }
    if (cm.somethingSelected()) {
      setLastCopied({lineWise: false, text: cm.getSelections()});
      if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
    } else if (!cm.options.lineWiseCopyCut) {
      return
    } else {
      var ranges = copyableRanges(cm);
      setLastCopied({lineWise: true, text: ranges.text});
      if (e.type == "cut") {
        cm.operation(function () {
          cm.setSelections(ranges.ranges, 0, sel_dontScroll);
          cm.replaceSelection("", null, "cut");
        });
      }
    }
    if (e.clipboardData) {
      e.clipboardData.clearData();
      var content = lastCopied.text.join("\n");
      // iOS exposes the clipboard API, but seems to discard content inserted into it
      e.clipboardData.setData("Text", content);
      if (e.clipboardData.getData("Text") == content) {
        e.preventDefault();
        return
      }
    }
    // Old-fashioned briefly-focus-a-textarea hack
    var kludge = hiddenTextarea(), te = kludge.firstChild;
    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
    te.value = lastCopied.text.join("\n");
    var hadFocus = document.activeElement;
    selectInput(te);
    setTimeout(function () {
      cm.display.lineSpace.removeChild(kludge);
      hadFocus.focus();
      if (hadFocus == div) { input.showPrimarySelection(); }
    }, 50);
  }
  on(div, "copy", onCopyCut);
  on(div, "cut", onCopyCut);
};

ContentEditableInput.prototype.prepareSelection = function () {
  var result = prepareSelection(this.cm, false);
  result.focus = this.cm.state.focused;
  return result
};

ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
  if (!info || !this.cm.display.view.length) { return }
  if (info.focus || takeFocus) { this.showPrimarySelection(); }
  this.showMultipleSelections(info);
};

ContentEditableInput.prototype.showPrimarySelection = function () {
  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
  var from = prim.from(), to = prim.to();

  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
    sel.removeAllRanges();
    return
  }

  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
      cmp(minPos(curAnchor, curFocus), from) == 0 &&
      cmp(maxPos(curAnchor, curFocus), to) == 0)
    { return }

  var view = cm.display.view;
  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
      {node: view[0].measure.map[2], offset: 0};
  var end = to.line < cm.display.viewTo && posToDOM(cm, to);
  if (!end) {
    var measure = view[view.length - 1].measure;
    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};
  }

  if (!start || !end) {
    sel.removeAllRanges();
    return
  }

  var old = sel.rangeCount && sel.getRangeAt(0), rng;
  try { rng = range(start.node, start.offset, end.offset, end.node); }
  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
  if (rng) {
    if (!gecko && cm.state.focused) {
      sel.collapse(start.node, start.offset);
      if (!rng.collapsed) {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
    } else {
      sel.removeAllRanges();
      sel.addRange(rng);
    }
    if (old && sel.anchorNode == null) { sel.addRange(old); }
    else if (gecko) { this.startGracePeriod(); }
  }
  this.rememberSelection();
};

ContentEditableInput.prototype.startGracePeriod = function () {
    var this$1 = this;

  clearTimeout(this.gracePeriod);
  this.gracePeriod = setTimeout(function () {
    this$1.gracePeriod = false;
    if (this$1.selectionChanged())
      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
  }, 20);
};

ContentEditableInput.prototype.showMultipleSelections = function (info) {
  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
};

ContentEditableInput.prototype.rememberSelection = function () {
  var sel = window.getSelection();
  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
};

ContentEditableInput.prototype.selectionInEditor = function () {
  var sel = window.getSelection();
  if (!sel.rangeCount) { return false }
  var node = sel.getRangeAt(0).commonAncestorContainer;
  return contains(this.div, node)
};

ContentEditableInput.prototype.focus = function () {
  if (this.cm.options.readOnly != "nocursor") {
    if (!this.selectionInEditor())
      { this.showSelection(this.prepareSelection(), true); }
    this.div.focus();
  }
};
ContentEditableInput.prototype.blur = function () { this.div.blur(); };
ContentEditableInput.prototype.getField = function () { return this.div };

ContentEditableInput.prototype.supportsTouch = function () { return true };

ContentEditableInput.prototype.receivedFocus = function () {
  var input = this;
  if (this.selectionInEditor())
    { this.pollSelection(); }
  else
    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

  function poll() {
    if (input.cm.state.focused) {
      input.pollSelection();
      input.polling.set(input.cm.options.pollInterval, poll);
    }
  }
  this.polling.set(this.cm.options.pollInterval, poll);
};

ContentEditableInput.prototype.selectionChanged = function () {
  var sel = window.getSelection();
  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
};

ContentEditableInput.prototype.pollSelection = function () {
  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
  var sel = window.getSelection(), cm = this.cm;
  // On Android Chrome (version 56, at least), backspacing into an
  // uneditable block element will put the cursor in that element,
  // and then, because it's not editable, hide the virtual keyboard.
  // Because Android doesn't allow us to actually detect backspace
  // presses in a sane way, this code checks for when that happens
  // and simulates a backspace press in this case.
  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {
    this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
    this.blur();
    this.focus();
    return
  }
  if (this.composing) { return }
  this.rememberSelection();
  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
  var head = domToPos(cm, sel.focusNode, sel.focusOffset);
  if (anchor && head) { runInOp(cm, function () {
    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
  }); }
};

ContentEditableInput.prototype.pollContent = function () {
  if (this.readDOMTimeout != null) {
    clearTimeout(this.readDOMTimeout);
    this.readDOMTimeout = null;
  }

  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
  var from = sel.from(), to = sel.to();
  if (from.ch == 0 && from.line > cm.firstLine())
    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
    { to = Pos(to.line + 1, 0); }
  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

  var fromIndex, fromLine, fromNode;
  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
    fromLine = lineNo(display.view[0].line);
    fromNode = display.view[0].node;
  } else {
    fromLine = lineNo(display.view[fromIndex].line);
    fromNode = display.view[fromIndex - 1].node.nextSibling;
  }
  var toIndex = findViewIndex(cm, to.line);
  var toLine, toNode;
  if (toIndex == display.view.length - 1) {
    toLine = display.viewTo - 1;
    toNode = display.lineDiv.lastChild;
  } else {
    toLine = lineNo(display.view[toIndex + 1].line) - 1;
    toNode = display.view[toIndex + 1].node.previousSibling;
  }

  if (!fromNode) { return false }
  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
  while (newText.length > 1 && oldText.length > 1) {
    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
    else { break }
  }

  var cutFront = 0, cutEnd = 0;
  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
    { ++cutFront; }
  var newBot = lst(newText), oldBot = lst(oldText);
  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                           oldBot.length - (oldText.length == 1 ? cutFront : 0));
  while (cutEnd < maxCutEnd &&
         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
    { ++cutEnd; }
  // Try to move start of change to start of selection if ambiguous
  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
    while (cutFront && cutFront > from.ch &&
           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
      cutFront--;
      cutEnd++;
    }
  }

  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
  newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

  var chFrom = Pos(fromLine, cutFront);
  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
    replaceRange(cm.doc, newText, chFrom, chTo, "+input");
    return true
  }
};

ContentEditableInput.prototype.ensurePolled = function () {
  this.forceCompositionEnd();
};
ContentEditableInput.prototype.reset = function () {
  this.forceCompositionEnd();
};
ContentEditableInput.prototype.forceCompositionEnd = function () {
  if (!this.composing) { return }
  clearTimeout(this.readDOMTimeout);
  this.composing = null;
  this.updateFromDOM();
  this.div.blur();
  this.div.focus();
};
ContentEditableInput.prototype.readFromDOMSoon = function () {
    var this$1 = this;

  if (this.readDOMTimeout != null) { return }
  this.readDOMTimeout = setTimeout(function () {
    this$1.readDOMTimeout = null;
    if (this$1.composing) {
      if (this$1.composing.done) { this$1.composing = null; }
      else { return }
    }
    this$1.updateFromDOM();
  }, 80);
};

ContentEditableInput.prototype.updateFromDOM = function () {
    var this$1 = this;

  if (this.cm.isReadOnly() || !this.pollContent())
    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
};

ContentEditableInput.prototype.setUneditable = function (node) {
  node.contentEditable = "false";
};

ContentEditableInput.prototype.onKeyPress = function (e) {
  if (e.charCode == 0) { return }
  e.preventDefault();
  if (!this.cm.isReadOnly())
    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
};

ContentEditableInput.prototype.readOnlyChanged = function (val) {
  this.div.contentEditable = String(val != "nocursor");
};

ContentEditableInput.prototype.onContextMenu = function () {};
ContentEditableInput.prototype.resetPosition = function () {};

ContentEditableInput.prototype.needsContentAttribute = true;

function posToDOM(cm, pos) {
  var view = findViewForLine(cm, pos.line);
  if (!view || view.hidden) { return null }
  var line = getLine(cm.doc, pos.line);
  var info = mapFromLineView(view, line, pos.line);

  var order = getOrder(line, cm.doc.direction), side = "left";
  if (order) {
    var partPos = getBidiPartAt(order, pos.ch);
    side = partPos % 2 ? "right" : "left";
  }
  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
  result.offset = result.collapse == "right" ? result.end : result.start;
  return result
}

function isInGutter(node) {
  for (var scan = node; scan; scan = scan.parentNode)
    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
  return false
}

function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

function domTextBetween(cm, from, to, fromLine, toLine) {
  var text = "", closing = false, lineSep = cm.doc.lineSeparator();
  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
  function close() {
    if (closing) {
      text += lineSep;
      closing = false;
    }
  }
  function addText(str) {
    if (str) {
      close();
      text += str;
    }
  }
  function walk(node) {
    if (node.nodeType == 1) {
      var cmText = node.getAttribute("cm-text");
      if (cmText != null) {
        addText(cmText || node.textContent.replace(/\u200b/g, ""));
        return
      }
      var markerID = node.getAttribute("cm-marker"), range$$1;
      if (markerID) {
        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
        if (found.length && (range$$1 = found[0].find(0)))
          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }
        return
      }
      if (node.getAttribute("contenteditable") == "false") { return }
      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);
      if (isBlock) { close(); }
      for (var i = 0; i < node.childNodes.length; i++)
        { walk(node.childNodes[i]); }
      if (isBlock) { closing = true; }
    } else if (node.nodeType == 3) {
      addText(node.nodeValue);
    }
  }
  for (;;) {
    walk(from);
    if (from == to) { break }
    from = from.nextSibling;
  }
  return text
}

function domToPos(cm, node, offset) {
  var lineNode;
  if (node == cm.display.lineDiv) {
    lineNode = cm.display.lineDiv.childNodes[offset];
    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
    node = null; offset = 0;
  } else {
    for (lineNode = node;; lineNode = lineNode.parentNode) {
      if (!lineNode || lineNode == cm.display.lineDiv) { return null }
      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
    }
  }
  for (var i = 0; i < cm.display.view.length; i++) {
    var lineView = cm.display.view[i];
    if (lineView.node == lineNode)
      { return locateNodeInLineView(lineView, node, offset) }
  }
}

function locateNodeInLineView(lineView, node, offset) {
  var wrapper = lineView.text.firstChild, bad = false;
  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
  if (node == wrapper) {
    bad = true;
    node = wrapper.childNodes[offset];
    offset = 0;
    if (!node) {
      var line = lineView.rest ? lst(lineView.rest) : lineView.line;
      return badPos(Pos(lineNo(line), line.text.length), bad)
    }
  }

  var textNode = node.nodeType == 3 ? node : null, topNode = node;
  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
    textNode = node.firstChild;
    if (offset) { offset = textNode.nodeValue.length; }
  }
  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
  var measure = lineView.measure, maps = measure.maps;

  function find(textNode, topNode, offset) {
    for (var i = -1; i < (maps ? maps.length : 0); i++) {
      var map$$1 = i < 0 ? measure.map : maps[i];
      for (var j = 0; j < map$$1.length; j += 3) {
        var curNode = map$$1[j + 2];
        if (curNode == textNode || curNode == topNode) {
          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
          var ch = map$$1[j] + offset;
          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }
          return Pos(line, ch)
        }
      }
    }
  }
  var found = find(textNode, topNode, offset);
  if (found) { return badPos(found, bad) }

  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
    found = find(after, after.firstChild, 0);
    if (found)
      { return badPos(Pos(found.line, found.ch - dist), bad) }
    else
      { dist += after.textContent.length; }
  }
  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
    found = find(before, before.firstChild, -1);
    if (found)
      { return badPos(Pos(found.line, found.ch + dist$1), bad) }
    else
      { dist$1 += before.textContent.length; }
  }
}

// TEXTAREA INPUT STYLE

var TextareaInput = function(cm) {
  this.cm = cm;
  // See input.poll and input.reset
  this.prevInput = "";

  // Flag that indicates whether we expect input to appear real soon
  // now (after some event like 'keypress' or 'input') and are
  // polling intensively.
  this.pollingFast = false;
  // Self-resetting timeout for the poller
  this.polling = new Delayed();
  // Used to work around IE issue with selection being forgotten when focus moves away from textarea
  this.hasSelection = false;
  this.composing = null;
};

TextareaInput.prototype.init = function (display) {
    var this$1 = this;

  var input = this, cm = this.cm;
  this.createField(display);
  var te = this.textarea;

  display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
  if (ios) { te.style.width = "0px"; }

  on(te, "input", function () {
    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
    input.poll();
  });

  on(te, "paste", function (e) {
    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

    cm.state.pasteIncoming = true;
    input.fastPoll();
  });

  function prepareCopyCut(e) {
    if (signalDOMEvent(cm, e)) { return }
    if (cm.somethingSelected()) {
      setLastCopied({lineWise: false, text: cm.getSelections()});
    } else if (!cm.options.lineWiseCopyCut) {
      return
    } else {
      var ranges = copyableRanges(cm);
      setLastCopied({lineWise: true, text: ranges.text});
      if (e.type == "cut") {
        cm.setSelections(ranges.ranges, null, sel_dontScroll);
      } else {
        input.prevInput = "";
        te.value = ranges.text.join("\n");
        selectInput(te);
      }
    }
    if (e.type == "cut") { cm.state.cutIncoming = true; }
  }
  on(te, "cut", prepareCopyCut);
  on(te, "copy", prepareCopyCut);

  on(display.scroller, "paste", function (e) {
    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
    cm.state.pasteIncoming = true;
    input.focus();
  });

  // Prevent normal selection in the editor (we handle our own)
  on(display.lineSpace, "selectstart", function (e) {
    if (!eventInWidget(display, e)) { e_preventDefault(e); }
  });

  on(te, "compositionstart", function () {
    var start = cm.getCursor("from");
    if (input.composing) { input.composing.range.clear(); }
    input.composing = {
      start: start,
      range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
    };
  });
  on(te, "compositionend", function () {
    if (input.composing) {
      input.poll();
      input.composing.range.clear();
      input.composing = null;
    }
  });
};

TextareaInput.prototype.createField = function (_display) {
  // Wraps and hides input textarea
  this.wrapper = hiddenTextarea();
  // The semihidden textarea that is focused when the editor is
  // focused, and receives input.
  this.textarea = this.wrapper.firstChild;
};

TextareaInput.prototype.prepareSelection = function () {
  // Redraw the selection and/or cursor
  var cm = this.cm, display = cm.display, doc = cm.doc;
  var result = prepareSelection(cm);

  // Move the hidden textarea near the cursor to prevent scrolling artifacts
  if (cm.options.moveInputWithCursor) {
    var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                        headPos.top + lineOff.top - wrapOff.top));
    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                         headPos.left + lineOff.left - wrapOff.left));
  }

  return result
};

TextareaInput.prototype.showSelection = function (drawn) {
  var cm = this.cm, display = cm.display;
  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
  removeChildrenAndAdd(display.selectionDiv, drawn.selection);
  if (drawn.teTop != null) {
    this.wrapper.style.top = drawn.teTop + "px";
    this.wrapper.style.left = drawn.teLeft + "px";
  }
};

// Reset the input to correspond to the selection (or to be empty,
// when not typing and nothing is selected)
TextareaInput.prototype.reset = function (typing) {
  if (this.contextMenuPending || this.composing) { return }
  var cm = this.cm;
  if (cm.somethingSelected()) {
    this.prevInput = "";
    var content = cm.getSelection();
    this.textarea.value = content;
    if (cm.state.focused) { selectInput(this.textarea); }
    if (ie && ie_version >= 9) { this.hasSelection = content; }
  } else if (!typing) {
    this.prevInput = this.textarea.value = "";
    if (ie && ie_version >= 9) { this.hasSelection = null; }
  }
};

TextareaInput.prototype.getField = function () { return this.textarea };

TextareaInput.prototype.supportsTouch = function () { return false };

TextareaInput.prototype.focus = function () {
  if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
    try { this.textarea.focus(); }
    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
  }
};

TextareaInput.prototype.blur = function () { this.textarea.blur(); };

TextareaInput.prototype.resetPosition = function () {
  this.wrapper.style.top = this.wrapper.style.left = 0;
};

TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

// Poll for input changes, using the normal rate of polling. This
// runs as long as the editor is focused.
TextareaInput.prototype.slowPoll = function () {
    var this$1 = this;

  if (this.pollingFast) { return }
  this.polling.set(this.cm.options.pollInterval, function () {
    this$1.poll();
    if (this$1.cm.state.focused) { this$1.slowPoll(); }
  });
};

// When an event has just come in that is likely to add or change
// something in the input textarea, we poll faster, to ensure that
// the change appears on the screen quickly.
TextareaInput.prototype.fastPoll = function () {
  var missed = false, input = this;
  input.pollingFast = true;
  function p() {
    var changed = input.poll();
    if (!changed && !missed) {missed = true; input.polling.set(60, p);}
    else {input.pollingFast = false; input.slowPoll();}
  }
  input.polling.set(20, p);
};

// Read input from the textarea, and update the document to match.
// When something is selected, it is present in the textarea, and
// selected (unless it is huge, in which case a placeholder is
// used). When nothing is selected, the cursor sits after previously
// seen text (can be empty), which is stored in prevInput (we must
// not reset the textarea when typing, because that breaks IME).
TextareaInput.prototype.poll = function () {
    var this$1 = this;

  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
  // Since this is called a *lot*, try to bail out as cheaply as
  // possible when it is clear that nothing happened. hasSelection
  // will be the case when there is a lot of text in the textarea,
  // in which case reading its value would be expensive.
  if (this.contextMenuPending || !cm.state.focused ||
      (hasSelection(input) && !prevInput && !this.composing) ||
      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
    { return false }

  var text = input.value;
  // If nothing changed, bail.
  if (text == prevInput && !cm.somethingSelected()) { return false }
  // Work around nonsensical selection resetting in IE9/10, and
  // inexplicable appearance of private area unicode characters on
  // some key combos in Mac (#2689).
  if (ie && ie_version >= 9 && this.hasSelection === text ||
      mac && /[\uf700-\uf7ff]/.test(text)) {
    cm.display.input.reset();
    return false
  }

  if (cm.doc.sel == cm.display.selForContextMenu) {
    var first = text.charCodeAt(0);
    if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
    if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
  }
  // Find the part of the input that is actually new
  var same = 0, l = Math.min(prevInput.length, text.length);
  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

  runInOp(cm, function () {
    applyTextInput(cm, text.slice(same), prevInput.length - same,
                   null, this$1.composing ? "*compose" : null);

    // Don't leave long text in the textarea, since it makes further polling slow
    if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
    else { this$1.prevInput = text; }

    if (this$1.composing) {
      this$1.composing.range.clear();
      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                         {className: "CodeMirror-composing"});
    }
  });
  return true
};

TextareaInput.prototype.ensurePolled = function () {
  if (this.pollingFast && this.poll()) { this.pollingFast = false; }
};

TextareaInput.prototype.onKeyPress = function () {
  if (ie && ie_version >= 9) { this.hasSelection = null; }
  this.fastPoll();
};

TextareaInput.prototype.onContextMenu = function (e) {
  var input = this, cm = input.cm, display = cm.display, te = input.textarea;
  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
  if (!pos || presto) { return } // Opera is difficult.

  // Reset the current text selection only if the click is done outside of the selection
  // and 'resetSelectionOnContextMenu' option is true.
  var reset = cm.options.resetSelectionOnContextMenu;
  if (reset && cm.doc.sel.contains(pos) == -1)
    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
  input.wrapper.style.cssText = "position: absolute";
  var wrapperBox = input.wrapper.getBoundingClientRect();
  te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
  var oldScrollY;
  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
  display.input.focus();
  if (webkit) { window.scrollTo(null, oldScrollY); }
  display.input.reset();
  // Adds "Select all" to context menu in FF
  if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
  input.contextMenuPending = true;
  display.selForContextMenu = cm.doc.sel;
  clearTimeout(display.detectingSelectAll);

  // Select-all will be greyed out if there's nothing to select, so
  // this adds a zero-width space so that we can later check whether
  // it got selected.
  function prepareSelectAllHack() {
    if (te.selectionStart != null) {
      var selected = cm.somethingSelected();
      var extval = "\u200b" + (selected ? te.value : "");
      te.value = "\u21da"; // Used to catch context-menu undo
      te.value = extval;
      input.prevInput = selected ? "" : "\u200b";
      te.selectionStart = 1; te.selectionEnd = extval.length;
      // Re-set this, in case some other handler touched the
      // selection in the meantime.
      display.selForContextMenu = cm.doc.sel;
    }
  }
  function rehide() {
    input.contextMenuPending = false;
    input.wrapper.style.cssText = oldWrapperCSS;
    te.style.cssText = oldCSS;
    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

    // Try to detect the user choosing select-all
    if (te.selectionStart != null) {
      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
      var i = 0, poll = function () {
        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
            te.selectionEnd > 0 && input.prevInput == "\u200b") {
          operation(cm, selectAll)(cm);
        } else if (i++ < 10) {
          display.detectingSelectAll = setTimeout(poll, 500);
        } else {
          display.selForContextMenu = null;
          display.input.reset();
        }
      };
      display.detectingSelectAll = setTimeout(poll, 200);
    }
  }

  if (ie && ie_version >= 9) { prepareSelectAllHack(); }
  if (captureRightClick) {
    e_stop(e);
    var mouseup = function () {
      off(window, "mouseup", mouseup);
      setTimeout(rehide, 20);
    };
    on(window, "mouseup", mouseup);
  } else {
    setTimeout(rehide, 50);
  }
};

TextareaInput.prototype.readOnlyChanged = function (val) {
  if (!val) { this.reset(); }
  this.textarea.disabled = val == "nocursor";
};

TextareaInput.prototype.setUneditable = function () {};

TextareaInput.prototype.needsContentAttribute = false;

function fromTextArea(textarea, options) {
  options = options ? copyObj(options) : {};
  options.value = textarea.value;
  if (!options.tabindex && textarea.tabIndex)
    { options.tabindex = textarea.tabIndex; }
  if (!options.placeholder && textarea.placeholder)
    { options.placeholder = textarea.placeholder; }
  // Set autofocus to true if this textarea is focused, or if it has
  // autofocus and no other element is focused.
  if (options.autofocus == null) {
    var hasFocus = activeElt();
    options.autofocus = hasFocus == textarea ||
      textarea.getAttribute("autofocus") != null && hasFocus == document.body;
  }

  function save() {textarea.value = cm.getValue();}

  var realSubmit;
  if (textarea.form) {
    on(textarea.form, "submit", save);
    // Deplorable hack to make the submit method do the right thing.
    if (!options.leaveSubmitMethodAlone) {
      var form = textarea.form;
      realSubmit = form.submit;
      try {
        var wrappedSubmit = form.submit = function () {
          save();
          form.submit = realSubmit;
          form.submit();
          form.submit = wrappedSubmit;
        };
      } catch(e) {}
    }
  }

  options.finishInit = function (cm) {
    cm.save = save;
    cm.getTextArea = function () { return textarea; };
    cm.toTextArea = function () {
      cm.toTextArea = isNaN; // Prevent this from being ran twice
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = "";
      if (textarea.form) {
        off(textarea.form, "submit", save);
        if (typeof textarea.form.submit == "function")
          { textarea.form.submit = realSubmit; }
      }
    };
  };

  textarea.style.display = "none";
  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
    options);
  return cm
}

function addLegacyProps(CodeMirror) {
  CodeMirror.off = off;
  CodeMirror.on = on;
  CodeMirror.wheelEventPixels = wheelEventPixels;
  CodeMirror.Doc = Doc;
  CodeMirror.splitLines = splitLinesAuto;
  CodeMirror.countColumn = countColumn;
  CodeMirror.findColumn = findColumn;
  CodeMirror.isWordChar = isWordCharBasic;
  CodeMirror.Pass = Pass;
  CodeMirror.signal = signal;
  CodeMirror.Line = Line;
  CodeMirror.changeEnd = changeEnd;
  CodeMirror.scrollbarModel = scrollbarModel;
  CodeMirror.Pos = Pos;
  CodeMirror.cmpPos = cmp;
  CodeMirror.modes = modes;
  CodeMirror.mimeModes = mimeModes;
  CodeMirror.resolveMode = resolveMode;
  CodeMirror.getMode = getMode;
  CodeMirror.modeExtensions = modeExtensions;
  CodeMirror.extendMode = extendMode;
  CodeMirror.copyState = copyState;
  CodeMirror.startState = startState;
  CodeMirror.innerMode = innerMode;
  CodeMirror.commands = commands;
  CodeMirror.keyMap = keyMap;
  CodeMirror.keyName = keyName;
  CodeMirror.isModifierKey = isModifierKey;
  CodeMirror.lookupKey = lookupKey;
  CodeMirror.normalizeKeyMap = normalizeKeyMap;
  CodeMirror.StringStream = StringStream;
  CodeMirror.SharedTextMarker = SharedTextMarker;
  CodeMirror.TextMarker = TextMarker;
  CodeMirror.LineWidget = LineWidget;
  CodeMirror.e_preventDefault = e_preventDefault;
  CodeMirror.e_stopPropagation = e_stopPropagation;
  CodeMirror.e_stop = e_stop;
  CodeMirror.addClass = addClass;
  CodeMirror.contains = contains;
  CodeMirror.rmClass = rmClass;
  CodeMirror.keyNames = keyNames;
}

// EDITOR CONSTRUCTOR

defineOptions(CodeMirror$1);

addEditorMethods(CodeMirror$1);

// Set up methods on CodeMirror's prototype to redirect to the editor's document.
var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
  { CodeMirror$1.prototype[prop] = (function(method) {
    return function() {return method.apply(this.doc, arguments)}
  })(Doc.prototype[prop]); } }

eventMixin(Doc);

// INPUT HANDLING

CodeMirror$1.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

// MODE DEFINITION AND QUERYING

// Extra arguments are stored as the mode's dependencies, which is
// used by (legacy) mechanisms like loadmode.js to automatically
// load a mode. (Preferred mechanism is the require/define calls.)
CodeMirror$1.defineMode = function(name/*, mode, */) {
  if (!CodeMirror$1.defaults.mode && name != "null") { CodeMirror$1.defaults.mode = name; }
  defineMode.apply(this, arguments);
};

CodeMirror$1.defineMIME = defineMIME;

// Minimal default mode.
CodeMirror$1.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
CodeMirror$1.defineMIME("text/plain", "null");

// EXTENSIONS

CodeMirror$1.defineExtension = function (name, func) {
  CodeMirror$1.prototype[name] = func;
};
CodeMirror$1.defineDocExtension = function (name, func) {
  Doc.prototype[name] = func;
};

CodeMirror$1.fromTextArea = fromTextArea;

addLegacyProps(CodeMirror$1);

CodeMirror$1.version = "5.36.0";

return CodeMirror$1;

})));

define('text!codemirror/lib/codemirror.css', ['module'], function(module) { module.exports = "/* BASICS */\n\n.CodeMirror {\n  /* Set height, width, borders, and global font properties here */\n  font-family: monospace;\n  height: 300px;\n  color: black;\n  direction: ltr;\n}\n\n/* PADDING */\n\n.CodeMirror-lines {\n  padding: 4px 0; /* Vertical padding around content */\n}\n.CodeMirror pre {\n  padding: 0 4px; /* Horizontal padding of content */\n}\n\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  background-color: white; /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n\n.CodeMirror-gutters {\n  border-right: 1px solid #ddd;\n  background-color: #f7f7f7;\n  white-space: nowrap;\n}\n.CodeMirror-linenumbers {}\n.CodeMirror-linenumber {\n  padding: 0 3px 0 5px;\n  min-width: 20px;\n  text-align: right;\n  color: #999;\n  white-space: nowrap;\n}\n\n.CodeMirror-guttermarker { color: black; }\n.CodeMirror-guttermarker-subtle { color: #999; }\n\n/* CURSOR */\n\n.CodeMirror-cursor {\n  border-left: 1px solid black;\n  border-right: none;\n  width: 0;\n}\n/* Shown when moving in bi-directional text */\n.CodeMirror div.CodeMirror-secondarycursor {\n  border-left: 1px solid silver;\n}\n.cm-fat-cursor .CodeMirror-cursor {\n  width: auto;\n  border: 0 !important;\n  background: #7e7;\n}\n.cm-fat-cursor div.CodeMirror-cursors {\n  z-index: 1;\n}\n.cm-fat-cursor-mark {\n  background-color: rgba(20, 255, 20, 0.5);\n  -webkit-animation: blink 1.06s steps(1) infinite;\n  -moz-animation: blink 1.06s steps(1) infinite;\n  animation: blink 1.06s steps(1) infinite;\n}\n.cm-animate-fat-cursor {\n  width: auto;\n  border: 0;\n  -webkit-animation: blink 1.06s steps(1) infinite;\n  -moz-animation: blink 1.06s steps(1) infinite;\n  animation: blink 1.06s steps(1) infinite;\n  background-color: #7e7;\n}\n@-moz-keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n@-webkit-keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n@keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n\n/* Can style cursor different in overwrite (non-insert) mode */\n.CodeMirror-overwrite .CodeMirror-cursor {}\n\n.cm-tab { display: inline-block; text-decoration: inherit; }\n\n.CodeMirror-rulers {\n  position: absolute;\n  left: 0; right: 0; top: -50px; bottom: -20px;\n  overflow: hidden;\n}\n.CodeMirror-ruler {\n  border-left: 1px solid #ccc;\n  top: 0; bottom: 0;\n  position: absolute;\n}\n\n/* DEFAULT THEME */\n\n.cm-s-default .cm-header {color: blue;}\n.cm-s-default .cm-quote {color: #090;}\n.cm-negative {color: #d44;}\n.cm-positive {color: #292;}\n.cm-header, .cm-strong {font-weight: bold;}\n.cm-em {font-style: italic;}\n.cm-link {text-decoration: underline;}\n.cm-strikethrough {text-decoration: line-through;}\n\n.cm-s-default .cm-keyword {color: #708;}\n.cm-s-default .cm-atom {color: #219;}\n.cm-s-default .cm-number {color: #164;}\n.cm-s-default .cm-def {color: #00f;}\n.cm-s-default .cm-variable,\n.cm-s-default .cm-punctuation,\n.cm-s-default .cm-property,\n.cm-s-default .cm-operator {}\n.cm-s-default .cm-variable-2 {color: #05a;}\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\n.cm-s-default .cm-comment {color: #a50;}\n.cm-s-default .cm-string {color: #a11;}\n.cm-s-default .cm-string-2 {color: #f50;}\n.cm-s-default .cm-meta {color: #555;}\n.cm-s-default .cm-qualifier {color: #555;}\n.cm-s-default .cm-builtin {color: #30a;}\n.cm-s-default .cm-bracket {color: #997;}\n.cm-s-default .cm-tag {color: #170;}\n.cm-s-default .cm-attribute {color: #00c;}\n.cm-s-default .cm-hr {color: #999;}\n.cm-s-default .cm-link {color: #00c;}\n\n.cm-s-default .cm-error {color: #f00;}\n.cm-invalidchar {color: #f00;}\n\n.CodeMirror-composing { border-bottom: 2px solid; }\n\n/* Default styles for common addons */\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\n.CodeMirror-activeline-background {background: #e8f2ff;}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\n   the editor. You probably shouldn't touch them. */\n\n.CodeMirror {\n  position: relative;\n  overflow: hidden;\n  background: white;\n}\n\n.CodeMirror-scroll {\n  overflow: scroll !important; /* Things will break if this is overridden */\n  /* 30px is the magic margin used to hide the element's real scrollbars */\n  /* See overflow: hidden in .CodeMirror */\n  margin-bottom: -30px; margin-right: -30px;\n  padding-bottom: 30px;\n  height: 100%;\n  outline: none; /* Prevent dragging from highlighting the element */\n  position: relative;\n}\n.CodeMirror-sizer {\n  position: relative;\n  border-right: 30px solid transparent;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\n   before actual scrolling happens, thus preventing shaking and\n   flickering artifacts. */\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  position: absolute;\n  z-index: 6;\n  display: none;\n}\n.CodeMirror-vscrollbar {\n  right: 0; top: 0;\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n  bottom: 0; left: 0;\n  overflow-y: hidden;\n  overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n  right: 0; bottom: 0;\n}\n.CodeMirror-gutter-filler {\n  left: 0; bottom: 0;\n}\n\n.CodeMirror-gutters {\n  position: absolute; left: 0; top: 0;\n  min-height: 100%;\n  z-index: 3;\n}\n.CodeMirror-gutter {\n  white-space: normal;\n  height: 100%;\n  display: inline-block;\n  vertical-align: top;\n  margin-bottom: -30px;\n}\n.CodeMirror-gutter-wrapper {\n  position: absolute;\n  z-index: 4;\n  background: none !important;\n  border: none !important;\n}\n.CodeMirror-gutter-background {\n  position: absolute;\n  top: 0; bottom: 0;\n  z-index: 4;\n}\n.CodeMirror-gutter-elt {\n  position: absolute;\n  cursor: default;\n  z-index: 4;\n}\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent }\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\n\n.CodeMirror-lines {\n  cursor: text;\n  min-height: 1px; /* prevents collapsing before first draw */\n}\n.CodeMirror pre {\n  /* Reset some styles that the rest of the page might have set */\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\n  border-width: 0;\n  background: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  margin: 0;\n  white-space: pre;\n  word-wrap: normal;\n  line-height: inherit;\n  color: inherit;\n  z-index: 2;\n  position: relative;\n  overflow: visible;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-font-variant-ligatures: contextual;\n  font-variant-ligatures: contextual;\n}\n.CodeMirror-wrap pre {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  word-break: normal;\n}\n\n.CodeMirror-linebackground {\n  position: absolute;\n  left: 0; right: 0; top: 0; bottom: 0;\n  z-index: 0;\n}\n\n.CodeMirror-linewidget {\n  position: relative;\n  z-index: 2;\n  padding: 0.1px; /* Force widget margins to stay inside of the container */\n}\n\n.CodeMirror-widget {}\n\n.CodeMirror-rtl pre { direction: rtl; }\n\n.CodeMirror-code {\n  outline: none;\n}\n\n/* Force content-box sizing for the elements where we expect it */\n.CodeMirror-scroll,\n.CodeMirror-sizer,\n.CodeMirror-gutter,\n.CodeMirror-gutters,\n.CodeMirror-linenumber {\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n\n.CodeMirror-measure {\n  position: absolute;\n  width: 100%;\n  height: 0;\n  overflow: hidden;\n  visibility: hidden;\n}\n\n.CodeMirror-cursor {\n  position: absolute;\n  pointer-events: none;\n}\n.CodeMirror-measure pre { position: static; }\n\ndiv.CodeMirror-cursors {\n  visibility: hidden;\n  position: relative;\n  z-index: 3;\n}\ndiv.CodeMirror-dragcursors {\n  visibility: visible;\n}\n\n.CodeMirror-focused div.CodeMirror-cursors {\n  visibility: visible;\n}\n\n.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\n.CodeMirror-crosshair { cursor: crosshair; }\n.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }\n.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }\n\n.cm-searching {\n  background-color: #ffa;\n  background-color: rgba(255, 255, 0, .4);\n}\n\n/* Used to force a border model for a node */\n.cm-force-border { padding-right: .1px; }\n\n@media print {\n  /* Hide the cursor when printing */\n  .CodeMirror div.CodeMirror-cursors {\n    visibility: hidden;\n  }\n}\n\n/* See issue #2901 */\n.cm-tab-wrap-hack:after { content: ''; }\n\n/* Help users use markselection to safely style text background */\nspan.CodeMirror-selectedtext { background: none; }\n"; });
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/mode/css/css',["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("css", function(config, parserConfig) {
  var inline = parserConfig.inline
  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

  var indentUnit = config.indentUnit,
      tokenHooks = parserConfig.tokenHooks,
      documentTypes = parserConfig.documentTypes || {},
      mediaTypes = parserConfig.mediaTypes || {},
      mediaFeatures = parserConfig.mediaFeatures || {},
      mediaValueKeywords = parserConfig.mediaValueKeywords || {},
      propertyKeywords = parserConfig.propertyKeywords || {},
      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
      fontProperties = parserConfig.fontProperties || {},
      counterDescriptors = parserConfig.counterDescriptors || {},
      colorKeywords = parserConfig.colorKeywords || {},
      valueKeywords = parserConfig.valueKeywords || {},
      allowNested = parserConfig.allowNested,
      lineComment = parserConfig.lineComment,
      supportsAtComponent = parserConfig.supportsAtComponent === true;

  var type, override;
  function ret(style, tp) { type = tp; return style; }

  // Tokenizers

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (tokenHooks[ch]) {
      var result = tokenHooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == "@") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("def", stream.current());
    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
      return ret(null, "compare");
    } else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "#") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("atom", "hash");
    } else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    } else if (ch === "-") {
      if (/[\d.]/.test(stream.peek())) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (stream.match(/^-[\w\\\-]+/)) {
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ret("variable-2", "variable-definition");
        return ret("variable-2", "variable");
      } else if (stream.match(/^\w+-/)) {
        return ret("meta", "meta");
      }
    } else if (/[,+>*\/]/.test(ch)) {
      return ret(null, "select-op");
    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
      return ret("qualifier", "qualifier");
    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
      return ret(null, ch);
    } else if (((ch == "u" || ch == "U") && stream.match(/rl(-prefix)?\(/i)) ||
               ((ch == "d" || ch == "D") && stream.match("omain(", true, true)) ||
               ((ch == "r" || ch == "R") && stream.match("egexp(", true, true))) {
      stream.backUp(1);
      state.tokenize = tokenParenthesized;
      return ret("property", "word");
    } else if (/[\w\\\-]/.test(ch)) {
      stream.eatWhile(/[\w\\\-]/);
      return ret("property", "word");
    } else {
      return ret(null, null);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped) {
          if (quote == ")") stream.backUp(1);
          break;
        }
        escaped = !escaped && ch == "\\";
      }
      if (ch == quote || !escaped && quote != ")") state.tokenize = null;
      return ret("string", "string");
    };
  }

  function tokenParenthesized(stream, state) {
    stream.next(); // Must be '('
    if (!stream.match(/\s*[\"\')]/, false))
      state.tokenize = tokenString(")");
    else
      state.tokenize = null;
    return ret(null, "(");
  }

  // Context management

  function Context(type, indent, prev) {
    this.type = type;
    this.indent = indent;
    this.prev = prev;
  }

  function pushContext(state, stream, type, indent) {
    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
    return type;
  }

  function popContext(state) {
    if (state.context.prev)
      state.context = state.context.prev;
    return state.context.type;
  }

  function pass(type, stream, state) {
    return states[state.context.type](type, stream, state);
  }
  function popAndPass(type, stream, state, n) {
    for (var i = n || 1; i > 0; i--)
      state.context = state.context.prev;
    return pass(type, stream, state);
  }

  // Parser

  function wordAsValue(stream) {
    var word = stream.current().toLowerCase();
    if (valueKeywords.hasOwnProperty(word))
      override = "atom";
    else if (colorKeywords.hasOwnProperty(word))
      override = "keyword";
    else
      override = "variable";
  }

  var states = {};

  states.top = function(type, stream, state) {
    if (type == "{") {
      return pushContext(state, stream, "block");
    } else if (type == "}" && state.context.prev) {
      return popContext(state);
    } else if (supportsAtComponent && /@component/i.test(type)) {
      return pushContext(state, stream, "atComponentBlock");
    } else if (/^@(-moz-)?document$/i.test(type)) {
      return pushContext(state, stream, "documentTypes");
    } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {
      return pushContext(state, stream, "atBlock");
    } else if (/^@(font-face|counter-style)/i.test(type)) {
      state.stateArg = type;
      return "restricted_atBlock_before";
    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {
      return "keyframes";
    } else if (type && type.charAt(0) == "@") {
      return pushContext(state, stream, "at");
    } else if (type == "hash") {
      override = "builtin";
    } else if (type == "word") {
      override = "tag";
    } else if (type == "variable-definition") {
      return "maybeprop";
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    } else if (type == ":") {
      return "pseudo";
    } else if (allowNested && type == "(") {
      return pushContext(state, stream, "parens");
    }
    return state.context.type;
  };

  states.block = function(type, stream, state) {
    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (propertyKeywords.hasOwnProperty(word)) {
        override = "property";
        return "maybeprop";
      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
        override = "string-2";
        return "maybeprop";
      } else if (allowNested) {
        override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
        return "block";
      } else {
        override += " error";
        return "maybeprop";
      }
    } else if (type == "meta") {
      return "block";
    } else if (!allowNested && (type == "hash" || type == "qualifier")) {
      override = "error";
      return "block";
    } else {
      return states.top(type, stream, state);
    }
  };

  states.maybeprop = function(type, stream, state) {
    if (type == ":") return pushContext(state, stream, "prop");
    return pass(type, stream, state);
  };

  states.prop = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
    if (type == "}" || type == "{") return popAndPass(type, stream, state);
    if (type == "(") return pushContext(state, stream, "parens");

    if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
      override += " error";
    } else if (type == "word") {
      wordAsValue(stream);
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    }
    return "prop";
  };

  states.propBlock = function(type, _stream, state) {
    if (type == "}") return popContext(state);
    if (type == "word") { override = "property"; return "maybeprop"; }
    return state.context.type;
  };

  states.parens = function(type, stream, state) {
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == ")") return popContext(state);
    if (type == "(") return pushContext(state, stream, "parens");
    if (type == "interpolation") return pushContext(state, stream, "interpolation");
    if (type == "word") wordAsValue(stream);
    return "parens";
  };

  states.pseudo = function(type, stream, state) {
    if (type == "meta") return "pseudo";

    if (type == "word") {
      override = "variable-3";
      return state.context.type;
    }
    return pass(type, stream, state);
  };

  states.documentTypes = function(type, stream, state) {
    if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
      override = "tag";
      return state.context.type;
    } else {
      return states.atBlock(type, stream, state);
    }
  };

  states.atBlock = function(type, stream, state) {
    if (type == "(") return pushContext(state, stream, "atBlock_parens");
    if (type == "}" || type == ";") return popAndPass(type, stream, state);
    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

    if (type == "interpolation") return pushContext(state, stream, "interpolation");

    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (word == "only" || word == "not" || word == "and" || word == "or")
        override = "keyword";
      else if (mediaTypes.hasOwnProperty(word))
        override = "attribute";
      else if (mediaFeatures.hasOwnProperty(word))
        override = "property";
      else if (mediaValueKeywords.hasOwnProperty(word))
        override = "keyword";
      else if (propertyKeywords.hasOwnProperty(word))
        override = "property";
      else if (nonStandardPropertyKeywords.hasOwnProperty(word))
        override = "string-2";
      else if (valueKeywords.hasOwnProperty(word))
        override = "atom";
      else if (colorKeywords.hasOwnProperty(word))
        override = "keyword";
      else
        override = "error";
    }
    return state.context.type;
  };

  states.atComponentBlock = function(type, stream, state) {
    if (type == "}")
      return popAndPass(type, stream, state);
    if (type == "{")
      return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
    if (type == "word")
      override = "error";
    return state.context.type;
  };

  states.atBlock_parens = function(type, stream, state) {
    if (type == ")") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
    return states.atBlock(type, stream, state);
  };

  states.restricted_atBlock_before = function(type, stream, state) {
    if (type == "{")
      return pushContext(state, stream, "restricted_atBlock");
    if (type == "word" && state.stateArg == "@counter-style") {
      override = "variable";
      return "restricted_atBlock_before";
    }
    return pass(type, stream, state);
  };

  states.restricted_atBlock = function(type, stream, state) {
    if (type == "}") {
      state.stateArg = null;
      return popContext(state);
    }
    if (type == "word") {
      if ((state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||
          (state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))
        override = "error";
      else
        override = "property";
      return "maybeprop";
    }
    return "restricted_atBlock";
  };

  states.keyframes = function(type, stream, state) {
    if (type == "word") { override = "variable"; return "keyframes"; }
    if (type == "{") return pushContext(state, stream, "top");
    return pass(type, stream, state);
  };

  states.at = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == "word") override = "tag";
    else if (type == "hash") override = "builtin";
    return "at";
  };

  states.interpolation = function(type, stream, state) {
    if (type == "}") return popContext(state);
    if (type == "{" || type == ";") return popAndPass(type, stream, state);
    if (type == "word") override = "variable";
    else if (type != "variable" && type != "(" && type != ")") override = "error";
    return "interpolation";
  };

  return {
    startState: function(base) {
      return {tokenize: null,
              state: inline ? "block" : "top",
              stateArg: null,
              context: new Context(inline ? "block" : "top", base || 0, null)};
    },

    token: function(stream, state) {
      if (!state.tokenize && stream.eatSpace()) return null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style && typeof style == "object") {
        type = style[1];
        style = style[0];
      }
      override = style;
      if (type != "comment")
        state.state = states[state.state](type, stream, state);
      return override;
    },

    indent: function(state, textAfter) {
      var cx = state.context, ch = textAfter && textAfter.charAt(0);
      var indent = cx.indent;
      if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
      if (cx.prev) {
        if (ch == "}" && (cx.type == "block" || cx.type == "top" ||
                          cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
          // Resume indentation from parent context.
          cx = cx.prev;
          indent = cx.indent;
        } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
            ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
          // Dedent relative to current context.
          indent = Math.max(0, cx.indent - indentUnit);
        }
      }
      return indent;
    },

    electricChars: "}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    blockCommentContinue: " * ",
    lineComment: lineComment,
    fold: "brace"
  };
});

  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i].toLowerCase()] = true;
    }
    return keys;
  }

  var documentTypes_ = [
    "domain", "regexp", "url", "url-prefix"
  ], documentTypes = keySet(documentTypes_);

  var mediaTypes_ = [
    "all", "aural", "braille", "handheld", "print", "projection", "screen",
    "tty", "tv", "embossed"
  ], mediaTypes = keySet(mediaTypes_);

  var mediaFeatures_ = [
    "width", "min-width", "max-width", "height", "min-height", "max-height",
    "device-width", "min-device-width", "max-device-width", "device-height",
    "min-device-height", "max-device-height", "aspect-ratio",
    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
    "max-color", "color-index", "min-color-index", "max-color-index",
    "monochrome", "min-monochrome", "max-monochrome", "resolution",
    "min-resolution", "max-resolution", "scan", "grid", "orientation",
    "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio",
    "pointer", "any-pointer", "hover", "any-hover"
  ], mediaFeatures = keySet(mediaFeatures_);

  var mediaValueKeywords_ = [
    "landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover",
    "interlace", "progressive"
  ], mediaValueKeywords = keySet(mediaValueKeywords_);

  var propertyKeywords_ = [
    "align-content", "align-items", "align-self", "alignment-adjust",
    "alignment-baseline", "anchor-point", "animation", "animation-delay",
    "animation-direction", "animation-duration", "animation-fill-mode",
    "animation-iteration-count", "animation-name", "animation-play-state",
    "animation-timing-function", "appearance", "azimuth", "backface-visibility",
    "background", "background-attachment", "background-blend-mode", "background-clip",
    "background-color", "background-image", "background-origin", "background-position",
    "background-repeat", "background-size", "baseline-shift", "binding",
    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
    "bookmark-target", "border", "border-bottom", "border-bottom-color",
    "border-bottom-left-radius", "border-bottom-right-radius",
    "border-bottom-style", "border-bottom-width", "border-collapse",
    "border-color", "border-image", "border-image-outset",
    "border-image-repeat", "border-image-slice", "border-image-source",
    "border-image-width", "border-left", "border-left-color",
    "border-left-style", "border-left-width", "border-radius", "border-right",
    "border-right-color", "border-right-style", "border-right-width",
    "border-spacing", "border-style", "border-top", "border-top-color",
    "border-top-left-radius", "border-top-right-radius", "border-top-style",
    "border-top-width", "border-width", "bottom", "box-decoration-break",
    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
    "caption-side", "caret-color", "clear", "clip", "color", "color-profile", "column-count",
    "column-fill", "column-gap", "column-rule", "column-rule-color",
    "column-rule-style", "column-rule-width", "column-span", "column-width",
    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
    "cue-after", "cue-before", "cursor", "direction", "display",
    "dominant-baseline", "drop-initial-after-adjust",
    "drop-initial-after-align", "drop-initial-before-adjust",
    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",
    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",
    "font-stretch", "font-style", "font-synthesis", "font-variant",
    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
    "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow",
    "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap",
    "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap",
    "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns",
    "grid-template-rows", "hanging-punctuation", "height", "hyphens",
    "icon", "image-orientation", "image-rendering", "image-resolution",
    "inline-box-align", "justify-content", "justify-items", "justify-self", "left", "letter-spacing",
    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
    "line-stacking-shift", "line-stacking-strategy", "list-style",
    "list-style-image", "list-style-position", "list-style-type", "margin",
    "margin-bottom", "margin-left", "margin-right", "margin-top",
    "marks", "marquee-direction", "marquee-loop",
    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",
    "nav-left", "nav-right", "nav-up", "object-fit", "object-position",
    "opacity", "order", "orphans", "outline",
    "outline-color", "outline-offset", "outline-style", "outline-width",
    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
    "page", "page-break-after", "page-break-before", "page-break-inside",
    "page-policy", "pause", "pause-after", "pause-before", "perspective",
    "perspective-origin", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "position",
    "presentation-level", "punctuation-trim", "quotes", "region-break-after",
    "region-break-before", "region-break-inside", "region-fragment",
    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",
    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",
    "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin",
    "shape-outside", "size", "speak", "speak-as", "speak-header",
    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
    "tab-size", "table-layout", "target", "target-name", "target-new",
    "target-position", "text-align", "text-align-last", "text-decoration",
    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
    "text-decoration-style", "text-emphasis", "text-emphasis-color",
    "text-emphasis-position", "text-emphasis-style", "text-height",
    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",
    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",
    "text-wrap", "top", "transform", "transform-origin", "transform-style",
    "transition", "transition-delay", "transition-duration",
    "transition-property", "transition-timing-function", "unicode-bidi",
    "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration",
    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
    "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break",
    "word-spacing", "word-wrap", "z-index",
    // SVG-specific
    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
    "color-interpolation", "color-interpolation-filters",
    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
    "glyph-orientation-vertical", "text-anchor", "writing-mode"
  ], propertyKeywords = keySet(propertyKeywords_);

  var nonStandardPropertyKeywords_ = [
    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
    "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside",
    "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button",
    "searchfield-results-decoration", "zoom"
  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);

  var fontProperties_ = [
    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",
    "font-stretch", "font-weight", "font-style"
  ], fontProperties = keySet(fontProperties_);

  var counterDescriptors_ = [
    "additive-symbols", "fallback", "negative", "pad", "prefix", "range",
    "speak-as", "suffix", "symbols", "system"
  ], counterDescriptors = keySet(counterDescriptors_);

  var colorKeywords_ = [
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
    "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
    "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
    "whitesmoke", "yellow", "yellowgreen"
  ], colorKeywords = keySet(colorKeywords_);

  var valueKeywords_ = [
    "above", "absolute", "activeborder", "additive", "activecaption", "afar",
    "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate",
    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
    "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page",
    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",
    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian",
    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
    "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch",
    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
    "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse",
    "compact", "condensed", "contain", "content", "contents",
    "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop",
    "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "dense", "destination-atop",
    "destination-in", "destination-out", "destination-over", "devanagari", "difference",
    "disc", "discard", "disclosure-closed", "disclosure-open", "document",
    "dot-dash", "dot-dot-dash",
    "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig",
    "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed",
    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes",
    "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove",
    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew",
    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
    "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert",
    "italic", "japanese-formal", "japanese-informal", "justify", "kannada",
    "katakana", "katakana-iroha", "keep-all", "khmer",
    "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal",
    "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten",
    "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem",
    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
    "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d",
    "media-controls-background", "media-current-time-display",
    "media-fullscreen-button", "media-mute-button", "media-play-button",
    "media-return-to-realtime-button", "media-rewind-button",
    "media-seek-back-button", "media-seek-forward-button", "media-slider",
    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
    "menu", "menulist", "menulist-button", "menulist-text",
    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize",
    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
    "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote",
    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
    "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter",
    "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d",
    "progress", "push-button", "radial-gradient", "radio", "read-only",
    "read-write", "read-write-plaintext-only", "rectangle", "region",
    "relative", "repeat", "repeating-linear-gradient",
    "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",
    "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY",
    "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running",
    "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen",
    "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield",
    "searchfield-cancel-button", "searchfield-decoration",
    "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end",
    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
    "simp-chinese-formal", "simp-chinese-informal", "single",
    "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
    "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali",
    "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square",
    "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub",
    "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table",
    "table-caption", "table-cell", "table-column", "table-column-group",
    "table-footer-group", "table-header-group", "table-row", "table-row-group",
    "tamil",
    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
    "trad-chinese-formal", "trad-chinese-informal", "transform",
    "translate", "translate3d", "translateX", "translateY", "translateZ",
    "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up",
    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
    "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
    "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor",
    "xx-large", "xx-small"
  ], valueKeywords = keySet(valueKeywords_);

  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)
    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)
    .concat(valueKeywords_);
  CodeMirror.registerHelper("hintWords", "css", allWords);

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ["comment", "comment"];
  }

  CodeMirror.defineMIME("text/css", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    tokenHooks: {
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css"
  });

  CodeMirror.defineMIME("text/x-scss", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      ":": function(stream) {
        if (stream.match(/\s*\{/, false))
          return [null, null]
        return false;
      },
      "$": function(stream) {
        stream.match(/^[\w-]+/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "#": function(stream) {
        if (!stream.eat("{")) return false;
        return [null, "interpolation"];
      }
    },
    name: "css",
    helperType: "scss"
  });

  CodeMirror.defineMIME("text/x-less", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "@": function(stream) {
        if (stream.eat("{")) return [null, "interpolation"];
        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "&": function() {
        return ["atom", "atom"];
      }
    },
    name: "css",
    helperType: "less"
  });

  CodeMirror.defineMIME("text/x-gss", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    supportsAtComponent: true,
    tokenHooks: {
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css",
    helperType: "gss"
  });

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("../xml/xml"), require("../javascript/javascript"), require("../css/css"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/mode/htmlmixed/htmlmixed',["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var defaultTags = {
    script: [
      ["lang", /(javascript|babel)/i, "javascript"],
      ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
      ["type", /./, "text/plain"],
      [null, null, "javascript"]
    ],
    style:  [
      ["lang", /^css$/i, "css"],
      ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
      ["type", /./, "text/plain"],
      [null, null, "css"]
    ]
  };

  function maybeBackup(stream, pat, style) {
    var cur = stream.current(), close = cur.search(pat);
    if (close > -1) {
      stream.backUp(cur.length - close);
    } else if (cur.match(/<\/?$/)) {
      stream.backUp(cur.length);
      if (!stream.match(pat, false)) stream.match(cur);
    }
    return style;
  }

  var attrRegexpCache = {};
  function getAttrRegexp(attr) {
    var regexp = attrRegexpCache[attr];
    if (regexp) return regexp;
    return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
  }

  function getAttrValue(text, attr) {
    var match = text.match(getAttrRegexp(attr))
    return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : ""
  }

  function getTagRegexp(tagName, anchored) {
    return new RegExp((anchored ? "^" : "") + "<\/\s*" + tagName + "\s*>", "i");
  }

  function addTags(from, to) {
    for (var tag in from) {
      var dest = to[tag] || (to[tag] = []);
      var source = from[tag];
      for (var i = source.length - 1; i >= 0; i--)
        dest.unshift(source[i])
    }
  }

  function findMatchingMode(tagInfo, tagText) {
    for (var i = 0; i < tagInfo.length; i++) {
      var spec = tagInfo[i];
      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
    }
  }

  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
    var htmlMode = CodeMirror.getMode(config, {
      name: "xml",
      htmlMode: true,
      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
    });

    var tags = {};
    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
    addTags(defaultTags, tags);
    if (configTags) addTags(configTags, tags);
    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)
      tags.script.unshift(["type", configScript[i].matches, configScript[i].mode])

    function html(stream, state) {
      var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName
      if (tag && !/[<>\s\/]/.test(stream.current()) &&
          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&
          tags.hasOwnProperty(tagName)) {
        state.inTag = tagName + " "
      } else if (state.inTag && tag && />$/.test(stream.current())) {
        var inTag = /^([\S]+) (.*)/.exec(state.inTag)
        state.inTag = null
        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2])
        var mode = CodeMirror.getMode(config, modeSpec)
        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
        state.token = function (stream, state) {
          if (stream.match(endTagA, false)) {
            state.token = html;
            state.localState = state.localMode = null;
            return null;
          }
          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
        };
        state.localMode = mode;
        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, ""));
      } else if (state.inTag) {
        state.inTag += stream.current()
        if (stream.eol()) state.inTag += " "
      }
      return style;
    };

    return {
      startState: function () {
        var state = CodeMirror.startState(htmlMode);
        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};
      },

      copyState: function (state) {
        var local;
        if (state.localState) {
          local = CodeMirror.copyState(state.localMode, state.localState);
        }
        return {token: state.token, inTag: state.inTag,
                localMode: state.localMode, localState: local,
                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
      },

      token: function (stream, state) {
        return state.token(stream, state);
      },

      indent: function (state, textAfter, line) {
        if (!state.localMode || /^\s*<\//.test(textAfter))
          return htmlMode.indent(state.htmlState, textAfter);
        else if (state.localMode.indent)
          return state.localMode.indent(state.localState, textAfter, line);
        else
          return CodeMirror.Pass;
      },

      innerMode: function (state) {
        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
      }
    };
  }, "xml", "javascript", "css");

  CodeMirror.defineMIME("text/html", "htmlmixed");
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/mode/javascript/javascript',["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;
  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    return {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,
      "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
      "await": C
    };
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    } else if (ch == "0" && stream.eat(/o/i)) {
      stream.eatWhile(/[0-7]/i);
      return ret("number", "number");
    } else if (ch == "0" && stream.eat(/b/i)) {
      stream.eatWhile(/[01]/i);
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (expressionAllowed(stream, state, 1)) {
        readRegexp(stream);
        stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
        return ret("regexp", "string-2");
      } else {
        stream.eat("=");
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    } else if (isOperatorChar.test(ch)) {
      if (ch != ">" || !state.lexical || state.lexical.type != ">") {
        if (stream.eat("=")) {
          if (ch == "!" || ch == "=") stream.eat("=")
        } else if (/[<>*+\-]/.test(ch)) {
          stream.eat(ch)
          if (ch == ">") stream.eat(ch)
        }
      }
      return ret("operator", "operator", stream.current());
    } else if (wordRE.test(ch)) {
      stream.eatWhile(wordRE);
      var word = stream.current()
      if (state.lastType != ".") {
        if (keywords.propertyIsEnumerable(word)) {
          var kw = keywords[word]
          return ret(kw.type, kw.style, word)
        }
        if (word == "async" && stream.match(/^(\s|\/\*.*?\*\/)*[\(\w]/, false))
          return ret("async", "keyword", word)
      }
      return ret("variable", "variable", word)
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    if (isTS) { // Try to skip TypeScript return type declarations after the arguments
      var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow))
      if (m) arrow = m.index
    }

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (wordRE.test(ch)) {
        sawSomething = true;
      } else if (/["'\/]/.test(ch)) {
        return;
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    cx.marked = "def";
    if (state.context) {
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      if (parserConfig.globalVars)
        state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  function isModifier(name) {
    return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly"
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
        indent = outer.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
    if (type == "debugger") return cont(expect(";"));
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
    if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), className, poplex); }
    if (type == "variable") {
      if (isTS && value == "declare") {
        cx.marked = "keyword"
        return cont(statement)
      } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
        cx.marked = "keyword"
        if (value == "enum") return cont(enumdef);
        else if (value == "type") return cont(typeexpr, expect("operator"), typeexpr, expect(";"));
        else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
      } else if (isTS && value == "namespace") {
        cx.marked = "keyword"
        return cont(pushlex("form"), expression, block, poplex)
      } else {
        return cont(pushlex("stat"), maybelabel);
      }
    }
    if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"),
                                      block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                     statement, poplex, popcontext);
    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
    if (type == "async") return cont(statement)
    if (value == "@") return cont(expression, statement)
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type, value) {
    return expressionInner(type, value, false);
  }
  function expressionNoComma(type, value) {
    return expressionInner(type, value, true);
  }
  function parenExpr(type) {
    if (type != "(") return pass()
    return cont(pushlex(")"), expression, expect(")"), poplex)
  }
  function expressionInner(type, value, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), classExpression, poplex); }
    if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") return pass(quasi, maybeop);
    if (type == "new") return cont(maybeTarget(noComma));
    if (type == "import") return cont(expression);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
      if (isTS && value == "<" && cx.stream.match(/^([^>]|<.*?>)*>\s*\(/, false))
        return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
    if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }
    if (type == "regexp") {
      cx.state.lastType = cx.marked = "operator"
      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)
      return cont(expr)
    }
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expressionNoComma);
  }
  function maybeTarget(noComma) {
    return function(type) {
      if (type == ".") return cont(noComma ? targetNoComma : target);
      else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)
      else return pass(noComma ? expressionNoComma : expression);
    };
  }
  function target(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
  }
  function targetNoComma(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "async") {
      cx.marked = "property";
      return cont(objprop);
    } else if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params
      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
        cx.state.fatArrowAt = cx.stream.pos + m[0].length
      return cont(afterprop);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (cx.style + " property");
      return cont(afterprop);
    } else if (type == "jsonld-keyword") {
      return cont(afterprop);
    } else if (isTS && isModifier(value)) {
      cx.marked = "keyword"
      return cont(objprop)
    } else if (type == "[") {
      return cont(expression, maybetype, expect("]"), afterprop);
    } else if (type == "spread") {
      return cont(expressionNoComma, afterprop);
    } else if (value == "*") {
      cx.marked = "keyword";
      return cont(objprop);
    } else if (type == ":") {
      return pass(afterprop)
    }
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end, sep) {
    function proceed(type, value) {
      if (sep ? sep.indexOf(type) > -1 : type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(function(type, value) {
          if (type == end || value == end) return pass()
          return pass(what)
        }, proceed);
      }
      if (type == end || value == end) return cont();
      return cont(expect(end));
    }
    return function(type, value) {
      if (type == end || value == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type, value) {
    if (isTS) {
      if (type == ":") return cont(typeexpr);
      if (value == "?") return cont(maybetype);
    }
  }
  function mayberettype(type) {
    if (isTS && type == ":") {
      if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr)
      else return cont(typeexpr)
    }
  }
  function isKW(_, value) {
    if (value == "is") {
      cx.marked = "keyword"
      return cont()
    }
  }
  function typeexpr(type, value) {
    if (value == "keyof" || value == "typeof") {
      cx.marked = "keyword"
      return cont(value == "keyof" ? typeexpr : expression)
    }
    if (type == "variable" || value == "void") {
      cx.marked = "type"
      return cont(afterType)
    }
    if (type == "string" || type == "number" || type == "atom") return cont(afterType);
    if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)
    if (type == "{") return cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType)
    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType)
  }
  function maybeReturnType(type) {
    if (type == "=>") return cont(typeexpr)
  }
  function typeprop(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property"
      return cont(typeprop)
    } else if (value == "?") {
      return cont(typeprop)
    } else if (type == ":") {
      return cont(typeexpr)
    } else if (type == "[") {
      return cont(expression, maybetype, expect("]"), typeprop)
    }
  }
  function typearg(type) {
    if (type == "variable") return cont(typearg)
    else if (type == ":") return cont(typeexpr)
  }
  function afterType(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
    if (value == "|" || type == "." || value == "&") return cont(typeexpr)
    if (type == "[") return cont(expect("]"), afterType)
    if (value == "extends" || value == "implements") { cx.marked = "keyword"; return cont(typeexpr) }
  }
  function maybeTypeArgs(_, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
  }
  function typeparam() {
    return pass(typeexpr, maybeTypeDefault)
  }
  function maybeTypeDefault(_, value) {
    if (value == "=") return cont(typeexpr)
  }
  function vardef(_, value) {
    if (value == "enum") {cx.marked = "keyword"; return cont(enumdef)}
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(pattern) }
    if (type == "variable") { register(value); return cont(); }
    if (type == "spread") return cont(pattern);
    if (type == "[") return contCommasep(pattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    if (type == "spread") return cont(pattern);
    if (type == "}") return pass();
    return cont(expect(":"), pattern, maybeAssign);
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type, value) {
    if (value == "await") return cont(forspec);
    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, expect(";"), forspec2);
    if (type == ";") return cont(forspec2);
    if (type == "variable") return cont(formaybeinof);
    return pass(expression, expect(";"), forspec2);
  }
  function formaybeinof(_type, value) {
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return pass(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef)
  }
  function funarg(type, value) {
    if (value == "@") cont(expression, funarg)
    if (type == "spread") return cont(funarg);
    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(funarg); }
    return pass(pattern, maybetype, maybeAssign);
  }
  function classExpression(type, value) {
    // Class expressions may have an optional name.
    if (type == "variable") return className(type, value);
    return classNameAfter(type, value);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter)
    if (value == "extends" || value == "implements" || (isTS && type == ",")) {
      if (value == "implements") cx.marked = "keyword";
      return cont(isTS ? typeexpr : expression, classNameAfter);
    }
    if (type == "{") return cont(pushlex("}"), classBody, poplex);
  }
  function classBody(type, value) {
    if (type == "async" ||
        (type == "variable" &&
         (value == "static" || value == "get" || value == "set" || (isTS && isModifier(value))) &&
         cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))) {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      return cont(isTS ? classfield : functiondef, classBody);
    }
    if (type == "[")
      return cont(expression, maybetype, expect("]"), isTS ? classfield : functiondef, classBody)
    if (value == "*") {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == ";") return cont(classBody);
    if (type == "}") return cont();
    if (value == "@") return cont(expression, classBody)
  }
  function classfield(type, value) {
    if (value == "?") return cont(classfield)
    if (type == ":") return cont(typeexpr, maybeAssign)
    if (value == "=") return cont(expressionNoComma)
    return pass(functiondef)
  }
  function afterExport(type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
    return pass(statement);
  }
  function exportField(type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
    if (type == "variable") return pass(expressionNoComma, exportField);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    if (type == "(") return pass(expression);
    return pass(importSpec, maybeMoreImports, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    if (value == "*") cx.marked = "keyword";
    return cont(maybeAs);
  }
  function maybeMoreImports(type) {
    if (type == ",") return cont(importSpec, maybeMoreImports)
  }
  function maybeAs(_type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(commasep(expressionNoComma, "]"));
  }
  function enumdef() {
    return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
  }
  function enummember() {
    return pass(pattern, maybeAssign);
  }

  function isContinuedStatement(state, textAfter) {
    return state.lastType == "operator" || state.lastType == "," ||
      isOperatorChar.test(textAfter.charAt(0)) ||
      /[,.]/.test(textAfter.charAt(0));
  }

  function expressionAllowed(stream, state, backUp) {
    return state.tokenize == tokenBase &&
      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
      (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: basecolumn || 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      while ((lexical.type == "stat" || lexical.type == "form") &&
             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
                                   !/^[,\.=+\-*:?[\(]/.test(textAfter))))
        lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    blockCommentContinue: jsonMode ? null : " * ",
    lineComment: jsonMode ? null : "//",
    fold: "brace",
    closeBrackets: "()[]{}''\"\"``",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode,

    expressionAllowed: expressionAllowed,

    skipExpression: function(state) {
      var top = state.cc[state.cc.length - 1]
      if (top == expression || top == expressionNoComma) state.cc.pop()
    }
  };
});

CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/x-javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("../xml/xml"), require("../meta"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/mode/markdown/markdown',["../../lib/codemirror", "../xml/xml", "../meta"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("markdown", function(cmCfg, modeCfg) {

  var htmlMode = CodeMirror.getMode(cmCfg, "text/html");
  var htmlModeMissing = htmlMode.name == "null"

  function getMode(name) {
    if (CodeMirror.findModeByName) {
      var found = CodeMirror.findModeByName(name);
      if (found) name = found.mime || found.mimes[0];
    }
    var mode = CodeMirror.getMode(cmCfg, name);
    return mode.name == "null" ? null : mode;
  }

  // Should characters that affect highlighting be highlighted separate?
  // Does not include characters that will be output (such as `1.` and `-` for lists)
  if (modeCfg.highlightFormatting === undefined)
    modeCfg.highlightFormatting = false;

  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.
  // Excess `>` will emit `error` token.
  if (modeCfg.maxBlockquoteDepth === undefined)
    modeCfg.maxBlockquoteDepth = 0;

  // Turn on task lists? ("- [ ] " and "- [x] ")
  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;

  // Turn on strikethrough syntax
  if (modeCfg.strikethrough === undefined)
    modeCfg.strikethrough = false;

  if (modeCfg.emoji === undefined)
    modeCfg.emoji = false;

  if (modeCfg.fencedCodeBlockHighlighting === undefined)
    modeCfg.fencedCodeBlockHighlighting = true;

  if (modeCfg.xml === undefined)
    modeCfg.xml = true;

  // Allow token types to be overridden by user-provided token types.
  if (modeCfg.tokenTypeOverrides === undefined)
    modeCfg.tokenTypeOverrides = {};

  var tokenTypes = {
    header: "header",
    code: "comment",
    quote: "quote",
    list1: "variable-2",
    list2: "variable-3",
    list3: "keyword",
    hr: "hr",
    image: "image",
    imageAltText: "image-alt-text",
    imageMarker: "image-marker",
    formatting: "formatting",
    linkInline: "link",
    linkEmail: "link",
    linkText: "link",
    linkHref: "string",
    em: "em",
    strong: "strong",
    strikethrough: "strikethrough",
    emoji: "builtin"
  };

  for (var tokenType in tokenTypes) {
    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {
      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
    }
  }

  var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/
  ,   listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/
  ,   taskListRE = /^\[(x| )\](?=\s)/i // Must follow listRE
  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/
  ,   setextHeaderRE = /^ *(?:\={1,}|-{1,})\s*$/
  ,   textRE = /^[^#!\[\]*_\\<>` "'(~:]+/
  ,   fencedCodeRE = /^(~~~+|```+)[ \t]*([\w+#-]*)[^\n`]*$/
  ,   linkDefRE = /^\s*\[[^\]]+?\]:.*$/ // naive link-definition
  ,   punctuation = /[!\"#$%&\'()*+,\-\.\/:;<=>?@\[\\\]^_`{|}~]/
  ,   expandedTab = "    " // CommonMark specifies tab as 4 spaces

  function switchInline(stream, state, f) {
    state.f = state.inline = f;
    return f(stream, state);
  }

  function switchBlock(stream, state, f) {
    state.f = state.block = f;
    return f(stream, state);
  }

  function lineIsEmpty(line) {
    return !line || !/\S/.test(line.string)
  }

  // Blocks

  function blankLine(state) {
    // Reset linkTitle state
    state.linkTitle = false;
    state.linkHref = false;
    state.linkText = false;
    // Reset EM state
    state.em = false;
    // Reset STRONG state
    state.strong = false;
    // Reset strikethrough state
    state.strikethrough = false;
    // Reset state.quote
    state.quote = 0;
    // Reset state.indentedCode
    state.indentedCode = false;
    if (state.f == htmlBlock) {
      state.f = inlineNormal;
      state.block = blockNormal;
    }
    // Reset state.trailingSpace
    state.trailingSpace = 0;
    state.trailingSpaceNewLine = false;
    // Mark this line as blank
    state.prevLine = state.thisLine
    state.thisLine = {stream: null}
    return null;
  }

  function blockNormal(stream, state) {
    var firstTokenOnLine = stream.column() === state.indentation;
    var prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream);
    var prevLineIsIndentedCode = state.indentedCode;
    var prevLineIsHr = state.prevLine.hr;
    var prevLineIsList = state.list !== false;
    var maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;

    state.indentedCode = false;

    var lineIndentation = state.indentation;
    // compute once per line (on first token)
    if (state.indentationDiff === null) {
      state.indentationDiff = state.indentation;
      if (prevLineIsList) {
        // Reset inline styles which shouldn't propagate aross list items
        state.em = false;
        state.strong = false;
        state.code = false;
        state.strikethrough = false;

        state.list = null;
        // While this list item's marker's indentation is less than the deepest
        //  list item's content's indentation,pop the deepest list item
        //  indentation off the stack, and update block indentation state
        while (lineIndentation < state.listStack[state.listStack.length - 1]) {
          state.listStack.pop();
          if (state.listStack.length) {
            state.indentation = state.listStack[state.listStack.length - 1];
          // less than the first list's indent -> the line is no longer a list
          } else {
            state.list = false;
          }
        }
        if (state.list !== false) {
          state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1]
        }
      }
    }

    // not comprehensive (currently only for setext detection purposes)
    var allowsInlineContinuation = (
        !prevLineLineIsEmpty && !prevLineIsHr && !state.prevLine.header &&
        (!prevLineIsList || !prevLineIsIndentedCode) &&
        !state.prevLine.fencedCodeEnd
    );

    var isHr = (state.list === false || prevLineIsHr || prevLineLineIsEmpty) &&
      state.indentation <= maxNonCodeIndentation && stream.match(hrRE);

    var match = null;
    if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd ||
         state.prevLine.header || prevLineLineIsEmpty)) {
      stream.skipToEnd();
      state.indentedCode = true;
      return tokenTypes.code;
    } else if (stream.eatSpace()) {
      return null;
    } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) {
      state.quote = 0;
      state.header = match[1].length;
      state.thisLine.header = true;
      if (modeCfg.highlightFormatting) state.formatting = "header";
      state.f = state.inline;
      return getType(state);
    } else if (state.indentation <= maxNonCodeIndentation && stream.eat('>')) {
      state.quote = firstTokenOnLine ? 1 : state.quote + 1;
      if (modeCfg.highlightFormatting) state.formatting = "quote";
      stream.eatSpace();
      return getType(state);
    } else if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {
      var listType = match[1] ? "ol" : "ul";

      state.indentation = lineIndentation + stream.current().length;
      state.list = true;
      state.quote = 0;

      // Add this list item's content's indentation to the stack
      state.listStack.push(state.indentation);

      if (modeCfg.taskLists && stream.match(taskListRE, false)) {
        state.taskList = true;
      }
      state.f = state.inline;
      if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];
      return getType(state);
    } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, true))) {
      state.quote = 0;
      state.fencedEndRE = new RegExp(match[1] + "+ *$");
      // try switching mode
      state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2]);
      if (state.localMode) state.localState = CodeMirror.startState(state.localMode);
      state.f = state.block = local;
      if (modeCfg.highlightFormatting) state.formatting = "code-block";
      state.code = -1
      return getType(state);
    // SETEXT has lowest block-scope precedence after HR, so check it after
    //  the others (code, blockquote, list...)
    } else if (
      // if setext set, indicates line after ---/===
      state.setext || (
        // line before ---/===
        (!allowsInlineContinuation || !prevLineIsList) && !state.quote && state.list === false &&
        !state.code && !isHr && !linkDefRE.test(stream.string) &&
        (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE))
      )
    ) {
      if ( !state.setext ) {
        state.header = match[0].charAt(0) == '=' ? 1 : 2;
        state.setext = state.header;
      } else {
        state.header = state.setext;
        // has no effect on type so we can reset it now
        state.setext = 0;
        stream.skipToEnd();
        if (modeCfg.highlightFormatting) state.formatting = "header";
      }
      state.thisLine.header = true;
      state.f = state.inline;
      return getType(state);
    } else if (isHr) {
      stream.skipToEnd();
      state.hr = true;
      state.thisLine.hr = true;
      return tokenTypes.hr;
    } else if (stream.peek() === '[') {
      return switchInline(stream, state, footnoteLink);
    }

    return switchInline(stream, state, state.inline);
  }

  function htmlBlock(stream, state) {
    var style = htmlMode.token(stream, state.htmlState);
    if (!htmlModeMissing) {
      var inner = CodeMirror.innerMode(htmlMode, state.htmlState)
      if ((inner.mode.name == "xml" && inner.state.tagStart === null &&
           (!inner.state.context && inner.state.tokenize.isInText)) ||
          (state.md_inside && stream.current().indexOf(">") > -1)) {
        state.f = inlineNormal;
        state.block = blockNormal;
        state.htmlState = null;
      }
    }
    return style;
  }

  function local(stream, state) {
    var currListInd = state.listStack[state.listStack.length - 1] || 0;
    var hasExitedList = state.indentation < currListInd;
    var maxFencedEndInd = currListInd + 3;
    if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {
      if (modeCfg.highlightFormatting) state.formatting = "code-block";
      var returnType;
      if (!hasExitedList) returnType = getType(state)
      state.localMode = state.localState = null;
      state.block = blockNormal;
      state.f = inlineNormal;
      state.fencedEndRE = null;
      state.code = 0
      state.thisLine.fencedCodeEnd = true;
      if (hasExitedList) return switchBlock(stream, state, state.block);
      return returnType;
    } else if (state.localMode) {
      return state.localMode.token(stream, state.localState);
    } else {
      stream.skipToEnd();
      return tokenTypes.code;
    }
  }

  // Inline
  function getType(state) {
    var styles = [];

    if (state.formatting) {
      styles.push(tokenTypes.formatting);

      if (typeof state.formatting === "string") state.formatting = [state.formatting];

      for (var i = 0; i < state.formatting.length; i++) {
        styles.push(tokenTypes.formatting + "-" + state.formatting[i]);

        if (state.formatting[i] === "header") {
          styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.header);
        }

        // Add `formatting-quote` and `formatting-quote-#` for blockquotes
        // Add `error` instead if the maximum blockquote nesting depth is passed
        if (state.formatting[i] === "quote") {
          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
            styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.quote);
          } else {
            styles.push("error");
          }
        }
      }
    }

    if (state.taskOpen) {
      styles.push("meta");
      return styles.length ? styles.join(' ') : null;
    }
    if (state.taskClosed) {
      styles.push("property");
      return styles.length ? styles.join(' ') : null;
    }

    if (state.linkHref) {
      styles.push(tokenTypes.linkHref, "url");
    } else { // Only apply inline styles to non-url text
      if (state.strong) { styles.push(tokenTypes.strong); }
      if (state.em) { styles.push(tokenTypes.em); }
      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }
      if (state.emoji) { styles.push(tokenTypes.emoji); }
      if (state.linkText) { styles.push(tokenTypes.linkText); }
      if (state.code) { styles.push(tokenTypes.code); }
      if (state.image) { styles.push(tokenTypes.image); }
      if (state.imageAltText) { styles.push(tokenTypes.imageAltText, "link"); }
      if (state.imageMarker) { styles.push(tokenTypes.imageMarker); }
    }

    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header); }

    if (state.quote) {
      styles.push(tokenTypes.quote);

      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth
      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
        styles.push(tokenTypes.quote + "-" + state.quote);
      } else {
        styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
      }
    }

    if (state.list !== false) {
      var listMod = (state.listStack.length - 1) % 3;
      if (!listMod) {
        styles.push(tokenTypes.list1);
      } else if (listMod === 1) {
        styles.push(tokenTypes.list2);
      } else {
        styles.push(tokenTypes.list3);
      }
    }

    if (state.trailingSpaceNewLine) {
      styles.push("trailing-space-new-line");
    } else if (state.trailingSpace) {
      styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
    }

    return styles.length ? styles.join(' ') : null;
  }

  function handleText(stream, state) {
    if (stream.match(textRE, true)) {
      return getType(state);
    }
    return undefined;
  }

  function inlineNormal(stream, state) {
    var style = state.text(stream, state);
    if (typeof style !== 'undefined')
      return style;

    if (state.list) { // List marker (*, +, -, 1., etc)
      state.list = null;
      return getType(state);
    }

    if (state.taskList) {
      var taskOpen = stream.match(taskListRE, true)[1] === " ";
      if (taskOpen) state.taskOpen = true;
      else state.taskClosed = true;
      if (modeCfg.highlightFormatting) state.formatting = "task";
      state.taskList = false;
      return getType(state);
    }

    state.taskOpen = false;
    state.taskClosed = false;

    if (state.header && stream.match(/^#+$/, true)) {
      if (modeCfg.highlightFormatting) state.formatting = "header";
      return getType(state);
    }

    var ch = stream.next();

    // Matches link titles present on next line
    if (state.linkTitle) {
      state.linkTitle = false;
      var matchCh = ch;
      if (ch === '(') {
        matchCh = ')';
      }
      matchCh = (matchCh+'').replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1");
      var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
      if (stream.match(new RegExp(regex), true)) {
        return tokenTypes.linkHref;
      }
    }

    // If this block is changed, it may need to be updated in GFM mode
    if (ch === '`') {
      var previousFormatting = state.formatting;
      if (modeCfg.highlightFormatting) state.formatting = "code";
      stream.eatWhile('`');
      var count = stream.current().length
      if (state.code == 0 && (!state.quote || count == 1)) {
        state.code = count
        return getType(state)
      } else if (count == state.code) { // Must be exact
        var t = getType(state)
        state.code = 0
        return t
      } else {
        state.formatting = previousFormatting
        return getType(state)
      }
    } else if (state.code) {
      return getType(state);
    }

    if (ch === '\\') {
      stream.next();
      if (modeCfg.highlightFormatting) {
        var type = getType(state);
        var formattingEscape = tokenTypes.formatting + "-escape";
        return type ? type + " " + formattingEscape : formattingEscape;
      }
    }

    if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
      state.imageMarker = true;
      state.image = true;
      if (modeCfg.highlightFormatting) state.formatting = "image";
      return getType(state);
    }

    if (ch === '[' && state.imageMarker && stream.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, false)) {
      state.imageMarker = false;
      state.imageAltText = true
      if (modeCfg.highlightFormatting) state.formatting = "image";
      return getType(state);
    }

    if (ch === ']' && state.imageAltText) {
      if (modeCfg.highlightFormatting) state.formatting = "image";
      var type = getType(state);
      state.imageAltText = false;
      state.image = false;
      state.inline = state.f = linkHref;
      return type;
    }

    if (ch === '[' && !state.image) {
      state.linkText = true;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      return getType(state);
    }

    if (ch === ']' && state.linkText) {
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      state.linkText = false;
      state.inline = state.f = stream.match(/\(.*?\)| ?\[.*?\]/, false) ? linkHref : inlineNormal
      return type;
    }

    if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
      state.f = state.inline = linkInline;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + tokenTypes.linkInline;
    }

    if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
      state.f = state.inline = linkInline;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + tokenTypes.linkEmail;
    }

    if (modeCfg.xml && ch === '<' && stream.match(/^(!--|[a-z]+(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*>)/i, false)) {
      var end = stream.string.indexOf(">", stream.pos);
      if (end != -1) {
        var atts = stream.string.substring(stream.start, end);
        if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) state.md_inside = true;
      }
      stream.backUp(1);
      state.htmlState = CodeMirror.startState(htmlMode);
      return switchBlock(stream, state, htmlBlock);
    }

    if (modeCfg.xml && ch === '<' && stream.match(/^\/\w*?>/)) {
      state.md_inside = false;
      return "tag";
    } else if (ch === "*" || ch === "_") {
      var len = 1, before = stream.pos == 1 ? " " : stream.string.charAt(stream.pos - 2)
      while (len < 3 && stream.eat(ch)) len++
      var after = stream.peek() || " "
      // See http://spec.commonmark.org/0.27/#emphasis-and-strong-emphasis
      var leftFlanking = !/\s/.test(after) && (!punctuation.test(after) || /\s/.test(before) || punctuation.test(before))
      var rightFlanking = !/\s/.test(before) && (!punctuation.test(before) || /\s/.test(after) || punctuation.test(after))
      var setEm = null, setStrong = null
      if (len % 2) { // Em
        if (!state.em && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
          setEm = true
        else if (state.em == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
          setEm = false
      }
      if (len > 1) { // Strong
        if (!state.strong && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
          setStrong = true
        else if (state.strong == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
          setStrong = false
      }
      if (setStrong != null || setEm != null) {
        if (modeCfg.highlightFormatting) state.formatting = setEm == null ? "strong" : setStrong == null ? "em" : "strong em"
        if (setEm === true) state.em = ch
        if (setStrong === true) state.strong = ch
        var t = getType(state)
        if (setEm === false) state.em = false
        if (setStrong === false) state.strong = false
        return t
      }
    } else if (ch === ' ') {
      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces
        if (stream.peek() === ' ') { // Surrounded by spaces, ignore
          return getType(state);
        } else { // Not surrounded by spaces, back up pointer
          stream.backUp(1);
        }
      }
    }

    if (modeCfg.strikethrough) {
      if (ch === '~' && stream.eatWhile(ch)) {
        if (state.strikethrough) {// Remove strikethrough
          if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
          var t = getType(state);
          state.strikethrough = false;
          return t;
        } else if (stream.match(/^[^\s]/, false)) {// Add strikethrough
          state.strikethrough = true;
          if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
          return getType(state);
        }
      } else if (ch === ' ') {
        if (stream.match(/^~~/, true)) { // Probably surrounded by space
          if (stream.peek() === ' ') { // Surrounded by spaces, ignore
            return getType(state);
          } else { // Not surrounded by spaces, back up pointer
            stream.backUp(2);
          }
        }
      }
    }

    if (modeCfg.emoji && ch === ":" && stream.match(/^[a-z_\d+-]+:/)) {
      state.emoji = true;
      if (modeCfg.highlightFormatting) state.formatting = "emoji";
      var retType = getType(state);
      state.emoji = false;
      return retType;
    }

    if (ch === ' ') {
      if (stream.match(/ +$/, false)) {
        state.trailingSpace++;
      } else if (state.trailingSpace) {
        state.trailingSpaceNewLine = true;
      }
    }

    return getType(state);
  }

  function linkInline(stream, state) {
    var ch = stream.next();

    if (ch === ">") {
      state.f = state.inline = inlineNormal;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + tokenTypes.linkInline;
    }

    stream.match(/^[^>]+/, true);

    return tokenTypes.linkInline;
  }

  function linkHref(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if(stream.eatSpace()){
      return null;
    }
    var ch = stream.next();
    if (ch === '(' || ch === '[') {
      state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
      if (modeCfg.highlightFormatting) state.formatting = "link-string";
      state.linkHref = true;
      return getType(state);
    }
    return 'error';
  }

  var linkRE = {
    ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
    "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/
  }

  function getLinkHrefInside(endChar) {
    return function(stream, state) {
      var ch = stream.next();

      if (ch === endChar) {
        state.f = state.inline = inlineNormal;
        if (modeCfg.highlightFormatting) state.formatting = "link-string";
        var returnState = getType(state);
        state.linkHref = false;
        return returnState;
      }

      stream.match(linkRE[endChar])
      state.linkHref = true;
      return getType(state);
    };
  }

  function footnoteLink(stream, state) {
    if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {
      state.f = footnoteLinkInside;
      stream.next(); // Consume [
      if (modeCfg.highlightFormatting) state.formatting = "link";
      state.linkText = true;
      return getType(state);
    }
    return switchInline(stream, state, inlineNormal);
  }

  function footnoteLinkInside(stream, state) {
    if (stream.match(/^\]:/, true)) {
      state.f = state.inline = footnoteUrl;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var returnType = getType(state);
      state.linkText = false;
      return returnType;
    }

    stream.match(/^([^\]\\]|\\.)+/, true);

    return tokenTypes.linkText;
  }

  function footnoteUrl(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if(stream.eatSpace()){
      return null;
    }
    // Match URL
    stream.match(/^[^\s]+/, true);
    // Check for link title
    if (stream.peek() === undefined) { // End of line, set flag to check next line
      state.linkTitle = true;
    } else { // More content on line, check if link title
      stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
    }
    state.f = state.inline = inlineNormal;
    return tokenTypes.linkHref + " url";
  }

  var mode = {
    startState: function() {
      return {
        f: blockNormal,

        prevLine: {stream: null},
        thisLine: {stream: null},

        block: blockNormal,
        htmlState: null,
        indentation: 0,

        inline: inlineNormal,
        text: handleText,

        formatting: false,
        linkText: false,
        linkHref: false,
        linkTitle: false,
        code: 0,
        em: false,
        strong: false,
        header: 0,
        setext: 0,
        hr: false,
        taskList: false,
        list: false,
        listStack: [],
        quote: 0,
        trailingSpace: 0,
        trailingSpaceNewLine: false,
        strikethrough: false,
        emoji: false,
        fencedEndRE: null
      };
    },

    copyState: function(s) {
      return {
        f: s.f,

        prevLine: s.prevLine,
        thisLine: s.thisLine,

        block: s.block,
        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),
        indentation: s.indentation,

        localMode: s.localMode,
        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,

        inline: s.inline,
        text: s.text,
        formatting: false,
        linkText: s.linkText,
        linkTitle: s.linkTitle,
        linkHref: s.linkHref,
        code: s.code,
        em: s.em,
        strong: s.strong,
        strikethrough: s.strikethrough,
        emoji: s.emoji,
        header: s.header,
        setext: s.setext,
        hr: s.hr,
        taskList: s.taskList,
        list: s.list,
        listStack: s.listStack.slice(0),
        quote: s.quote,
        indentedCode: s.indentedCode,
        trailingSpace: s.trailingSpace,
        trailingSpaceNewLine: s.trailingSpaceNewLine,
        md_inside: s.md_inside,
        fencedEndRE: s.fencedEndRE
      };
    },

    token: function(stream, state) {

      // Reset state.formatting
      state.formatting = false;

      if (stream != state.thisLine.stream) {
        state.header = 0;
        state.hr = false;

        if (stream.match(/^\s*$/, true)) {
          blankLine(state);
          return null;
        }

        state.prevLine = state.thisLine
        state.thisLine = {stream: stream}

        // Reset state.taskList
        state.taskList = false;

        // Reset state.trailingSpace
        state.trailingSpace = 0;
        state.trailingSpaceNewLine = false;

        if (!state.localState) {
          state.f = state.block;
          if (state.f != htmlBlock) {
            var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, expandedTab).length;
            state.indentation = indentation;
            state.indentationDiff = null;
            if (indentation > 0) return null;
          }
        }
      }
      return state.f(stream, state);
    },

    innerMode: function(state) {
      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};
      if (state.localState) return {state: state.localState, mode: state.localMode};
      return {state: state, mode: mode};
    },

    indent: function(state, textAfter, line) {
      if (state.block == htmlBlock && htmlMode.indent) return htmlMode.indent(state.htmlState, textAfter, line)
      if (state.localState && state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line)
      return CodeMirror.Pass
    },

    blankLine: blankLine,

    getType: getType,

    closeBrackets: "()[]{}''\"\"``",
    fold: "markdown"
  };
  return mode;
}, "xml");

CodeMirror.defineMIME("text/markdown", "markdown");

CodeMirror.defineMIME("text/x-markdown", "markdown");

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/mode/meta',["../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  CodeMirror.modeInfo = [
    {name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"]},
    {name: "PGP", mimes: ["application/pgp", "application/pgp-encrypted", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["asc", "pgp", "sig"]},
    {name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"]},
    {name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i},
    {name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"]},
    {name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h", "ino"]},
    {name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"]},
    {name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy"]},
    {name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp"]},
    {name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"]},
    {name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"]},
    {name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"]},
    {name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists.txt$/},
    {name: "CoffeeScript", mimes: ["application/vnd.coffeescript", "text/coffeescript", "text/x-coffeescript"], mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"]},
    {name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"]},
    {name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"]},
    {name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"]},
    {name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"]},
    {name: "CSS", mime: "text/css", mode: "css", ext: ["css"]},
    {name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"]},
    {name: "D", mime: "text/x-d", mode: "d", ext: ["d"]},
    {name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"]},
    {name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"]},
    {name: "Django", mime: "text/x-django", mode: "django"},
    {name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/},
    {name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"]},
    {name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"]},
    {name: "EBNF", mime: "text/x-ebnf", mode: "ebnf"},
    {name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"]},
    {name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"]},
    {name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"]},
    {name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"]},
    {name: "Embedded Javascript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"]},
    {name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"]},
    {name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"]},
    {name: "Esper", mime: "text/x-esper", mode: "sql"},
    {name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"]},
    {name: "FCL", mime: "text/x-fcl", mode: "fcl"},
    {name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"]},
    {name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90"]},
    {name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"]},
    {name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"]},
    {name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"]},
    {name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history).md$/i},
    {name: "Go", mime: "text/x-go", mode: "go", ext: ["go"]},
    {name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"], file: /^Jenkinsfile$/},
    {name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"]},
    {name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"]},
    {name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"]},
    {name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"]},
    {name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"]},
    {name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"]},
    {name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm", "handlebars", "hbs"], alias: ["xhtml"]},
    {name: "HTTP", mime: "message/http", mode: "http"},
    {name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"]},
    {name: "Pug", mime: "text/x-pug", mode: "pug", ext: ["jade", "pug"], alias: ["jade"]},
    {name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"]},
    {name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"]},
    {name: "JavaScript", mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
     mode: "javascript", ext: ["js"], alias: ["ecmascript", "js", "node"]},
    {name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"]},
    {name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"]},
    {name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"]},
    {name: "Jinja2", mime: "null", mode: "jinja2"},
    {name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"]},
    {name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"]},
    {name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"]},
    {name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"]},
    {name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"]},
    {name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"]},
    {name: "mIRC", mime: "text/mirc", mode: "mirc"},
    {name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql"},
    {name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb"]},
    {name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"]},
    {name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"]},
    {name: "MS SQL", mime: "text/x-mssql", mode: "sql"},
    {name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"]},
    {name: "MySQL", mime: "text/x-mysql", mode: "sql"},
    {name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i},
    {name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"]},
    {name: "NTriples", mimes: ["application/n-triples", "application/n-quads", "text/n-triples"],
     mode: "ntriples", ext: ["nt", "nq"]},
    {name: "Objective-C", mime: "text/x-objectivec", mode: "clike", ext: ["m", "mm"], alias: ["objective-c", "objc"]},
    {name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"]},
    {name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"]},
    {name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"]},
    {name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"]},
    {name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"]},
    {name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"]},
    {name: "PHP", mimes: ["text/x-php", "application/x-httpd-php", "application/x-httpd-php-open"], mode: "php", ext: ["php", "php3", "php4", "php5", "php7", "phtml"]},
    {name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"]},
    {name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"]},
    {name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"]},
    {name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"]},
    {name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"]},
    {name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"]},
    {name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/},
    {name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"]},
    {name: "Q", mime: "text/x-q", mode: "q", ext: ["q"]},
    {name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r", "R"], alias: ["rscript"]},
    {name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"]},
    {name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm"},
    {name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"]},
    {name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"]},
    {name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"]},
    {name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"]},
    {name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"]},
    {name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"]},
    {name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"]},
    {name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"]},
    {name: "Shell", mimes: ["text/x-sh", "application/x-sh"], mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/},
    {name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"]},
    {name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"]},
    {name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"]},
    {name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"]},
    {name: "Solr", mime: "text/x-solr", mode: "solr"},
    {name: "SML", mime: "text/x-sml", mode: "mllike", ext: ["sml", "sig", "fun", "smackspec"]},
    {name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"]},
    {name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"]},
    {name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"]},
    {name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"]},
    {name: "SQLite", mime: "text/x-sqlite", mode: "sql"},
    {name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"]},
    {name: "Stylus", mime: "text/x-styl", mode: "stylus", ext: ["styl"]},
    {name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"]},
    {name: "sTeX", mime: "text/x-stex", mode: "stex"},
    {name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx", "tex"], alias: ["tex"]},
    {name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v", "sv", "svh"]},
    {name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"]},
    {name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"]},
    {name: "TiddlyWiki ", mime: "text/x-tiddlywiki", mode: "tiddlywiki"},
    {name: "Tiki wiki", mime: "text/tiki", mode: "tiki"},
    {name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"]},
    {name: "Tornado", mime: "text/x-tornado", mode: "tornado"},
    {name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"]},
    {name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"]},
    {name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"]},
    {name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"]},
    {name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"]},
    {name: "TypeScript-JSX", mime: "text/typescript-jsx", mode: "jsx", ext: ["tsx"], alias: ["tsx"]},
    {name: "Twig", mime: "text/x-twig", mode: "twig"},
    {name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"]},
    {name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"]},
    {name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"]},
    {name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"]},
    {name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"]},
    {name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"]},
    {name: "Vue.js Component", mimes: ["script/x-vue", "text/x-vue"], mode: "vue", ext: ["vue"]},
    {name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd", "svg"], alias: ["rss", "wsdl", "xsd"]},
    {name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"]},
    {name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"]},
    {name: "YAML", mimes: ["text/x-yaml", "text/yaml"], mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"]},
    {name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"]},
    {name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"]},
    {name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"]},
    {name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"]}
  ];
  // Ensure all modes have a mime property for backwards compatibility
  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.mimes) info.mime = info.mimes[0];
  }

  CodeMirror.findModeByMIME = function(mime) {
    mime = mime.toLowerCase();
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.mime == mime) return info;
      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)
        if (info.mimes[j] == mime) return info;
    }
    if (/\+xml$/.test(mime)) return CodeMirror.findModeByMIME("application/xml")
    if (/\+json$/.test(mime)) return CodeMirror.findModeByMIME("application/json")
  };

  CodeMirror.findModeByExtension = function(ext) {
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.ext) for (var j = 0; j < info.ext.length; j++)
        if (info.ext[j] == ext) return info;
    }
  };

  CodeMirror.findModeByFileName = function(filename) {
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.file && info.file.test(filename)) return info;
    }
    var dot = filename.lastIndexOf(".");
    var ext = dot > -1 && filename.substring(dot + 1, filename.length);
    if (ext) return CodeMirror.findModeByExtension(ext);
  };

  CodeMirror.findModeByName = function(name) {
    name = name.toLowerCase();
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.name.toLowerCase() == name) return info;
      if (info.alias) for (var j = 0; j < info.alias.length; j++)
        if (info.alias[j].toLowerCase() == name) return info;
    }
  };
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/mode/xml/xml',["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

var htmlConfig = {
  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                    'track': true, 'wbr': true, 'menuitem': true},
  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                     'th': true, 'tr': true},
  contextGrabbers: {
    'dd': {'dd': true, 'dt': true},
    'dt': {'dd': true, 'dt': true},
    'li': {'li': true},
    'option': {'option': true, 'optgroup': true},
    'optgroup': {'optgroup': true},
    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
    'rp': {'rp': true, 'rt': true},
    'rt': {'rp': true, 'rt': true},
    'tbody': {'tbody': true, 'tfoot': true},
    'td': {'td': true, 'th': true},
    'tfoot': {'tbody': true},
    'th': {'td': true, 'th': true},
    'thead': {'tbody': true, 'tfoot': true},
    'tr': {'tr': true}
  },
  doNotIndent: {"pre": true},
  allowUnquoted: true,
  allowMissing: true,
  caseFold: true
}

var xmlConfig = {
  autoSelfClosers: {},
  implicitlyClosed: {},
  contextGrabbers: {},
  doNotIndent: {},
  allowUnquoted: false,
  allowMissing: false,
  allowMissingTagName: false,
  caseFold: false
}

CodeMirror.defineMode("xml", function(editorConf, config_) {
  var indentUnit = editorConf.indentUnit
  var config = {}
  var defaults = config_.htmlMode ? htmlConfig : xmlConfig
  for (var prop in defaults) config[prop] = defaults[prop]
  for (var prop in config_) config[prop] = config_[prop]

  // Return variables for tokenizers
  var type, setStyle;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "<") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
          else return null;
        } else if (stream.match("--")) {
          return chain(inBlock("comment", "-->"));
        } else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?>");
        return "meta";
      } else {
        type = stream.eat("/") ? "closeTag" : "openTag";
        state.tokenize = inTag;
        return "tag bracket";
      }
    } else if (ch == "&") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
      }
      return ok ? "atom" : "error";
    } else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }
  inText.isInText = true;

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
      state.tokenize = inText;
      type = ch == ">" ? "endTag" : "selfcloseTag";
      return "tag bracket";
    } else if (ch == "=") {
      type = "equals";
      return null;
    } else if (ch == "<") {
      state.tokenize = inText;
      state.state = baseState;
      state.tagName = state.tagStart = null;
      var next = state.tokenize(stream, state);
      return next ? next + " tag error" : "tag error";
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      state.stringStartCol = stream.column();
      return state.tokenize(stream, state);
    } else {
      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
      return "word";
    }
  }

  function inAttribute(quote) {
    var closure = function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
    closure.isInAttribute = true;
    return closure;
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    };
  }
  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "<") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == ">") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  function Context(state, tagName, startOfLine) {
    this.prev = state.context;
    this.tagName = tagName;
    this.indent = state.indented;
    this.startOfLine = startOfLine;
    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
      this.noIndent = true;
  }
  function popContext(state) {
    if (state.context) state.context = state.context.prev;
  }
  function maybePopContext(state, nextTagName) {
    var parentTagName;
    while (true) {
      if (!state.context) {
        return;
      }
      parentTagName = state.context.tagName;
      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext(state);
    }
  }

  function baseState(type, stream, state) {
    if (type == "openTag") {
      state.tagStart = stream.column();
      return tagNameState;
    } else if (type == "closeTag") {
      return closeTagNameState;
    } else {
      return baseState;
    }
  }
  function tagNameState(type, stream, state) {
    if (type == "word") {
      state.tagName = stream.current();
      setStyle = "tag";
      return attrState;
    } else if (config.allowMissingTagName && type == "endTag") {
      setStyle = "tag bracket";
      return attrState(type, stream, state);
    } else {
      setStyle = "error";
      return tagNameState;
    }
  }
  function closeTagNameState(type, stream, state) {
    if (type == "word") {
      var tagName = stream.current();
      if (state.context && state.context.tagName != tagName &&
          config.implicitlyClosed.hasOwnProperty(state.context.tagName))
        popContext(state);
      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
        setStyle = "tag";
        return closeState;
      } else {
        setStyle = "tag error";
        return closeStateErr;
      }
    } else if (config.allowMissingTagName && type == "endTag") {
      setStyle = "tag bracket";
      return closeState(type, stream, state);
    } else {
      setStyle = "error";
      return closeStateErr;
    }
  }

  function closeState(type, _stream, state) {
    if (type != "endTag") {
      setStyle = "error";
      return closeState;
    }
    popContext(state);
    return baseState;
  }
  function closeStateErr(type, stream, state) {
    setStyle = "error";
    return closeState(type, stream, state);
  }

  function attrState(type, _stream, state) {
    if (type == "word") {
      setStyle = "attribute";
      return attrEqState;
    } else if (type == "endTag" || type == "selfcloseTag") {
      var tagName = state.tagName, tagStart = state.tagStart;
      state.tagName = state.tagStart = null;
      if (type == "selfcloseTag" ||
          config.autoSelfClosers.hasOwnProperty(tagName)) {
        maybePopContext(state, tagName);
      } else {
        maybePopContext(state, tagName);
        state.context = new Context(state, tagName, tagStart == state.indented);
      }
      return baseState;
    }
    setStyle = "error";
    return attrState;
  }
  function attrEqState(type, stream, state) {
    if (type == "equals") return attrValueState;
    if (!config.allowMissing) setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrValueState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
    setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrContinuedState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    return attrState(type, stream, state);
  }

  return {
    startState: function(baseIndent) {
      var state = {tokenize: inText,
                   state: baseState,
                   indented: baseIndent || 0,
                   tagName: null, tagStart: null,
                   context: null}
      if (baseIndent != null) state.baseIndent = baseIndent
      return state
    },

    token: function(stream, state) {
      if (!state.tagName && stream.sol())
        state.indented = stream.indentation();

      if (stream.eatSpace()) return null;
      type = null;
      var style = state.tokenize(stream, state);
      if ((style || type) && style != "comment") {
        setStyle = null;
        state.state = state.state(type || style, stream, state);
        if (setStyle)
          style = setStyle == "error" ? style + " error" : setStyle;
      }
      return style;
    },

    indent: function(state, textAfter, fullLine) {
      var context = state.context;
      // Indent multi-line strings (e.g. css).
      if (state.tokenize.isInAttribute) {
        if (state.tagStart == state.indented)
          return state.stringStartCol + 1;
        else
          return state.indented + indentUnit;
      }
      if (context && context.noIndent) return CodeMirror.Pass;
      if (state.tokenize != inTag && state.tokenize != inText)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      // Indent the starts of attribute names.
      if (state.tagName) {
        if (config.multilineTagIndentPastTag !== false)
          return state.tagStart + state.tagName.length + 2;
        else
          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
      }
      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
      if (tagAfter && tagAfter[1]) { // Closing tag spotted
        while (context) {
          if (context.tagName == tagAfter[2]) {
            context = context.prev;
            break;
          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
            context = context.prev;
          } else {
            break;
          }
        }
      } else if (tagAfter) { // Opening tag spotted
        while (context) {
          var grabbers = config.contextGrabbers[context.tagName];
          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
            context = context.prev;
          else
            break;
        }
      }
      while (context && context.prev && !context.startOfLine)
        context = context.prev;
      if (context) return context.indent + indentUnit;
      else return state.baseIndent || 0;
    },

    electricInput: /<\/[\s\w:]+>$/,
    blockCommentStart: "<!--",
    blockCommentEnd: "-->",

    configuration: config.htmlMode ? "html" : "xml",
    helperType: config.htmlMode ? "html" : "xml",

    skipAttribute: function(state) {
      if (state.state == attrValueState)
        state.state = attrState
    }
  };
});

CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

});

/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.5';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Gets the value at `key`, unless `key` is "__proto__".
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function safeGet(object, key) {
    return key == '__proto__'
      ? undefined
      : object[key];
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });

        return result;
      }

      if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });

        return result;
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        if (isObject(srcValue)) {
          stack || (stack = new Stack);
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array == null ? 0 : array.length,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimEnd, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = (lodashFunc.name + ''),
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define('lodash/lodash',[],function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));

define('text/text',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});
define('aurelia-binding',['aurelia-binding/dist/commonjs/aurelia-binding'],function(m){return m;});
define('aurelia-binding.js',['aurelia-binding'],function(m){return m;});
define('aurelia-binding/dist/commonjs/aurelia-binding.js',['aurelia-binding/dist/commonjs/aurelia-binding'],function(m){return m;});
define('aurelia-bootstrapper',['aurelia-bootstrapper/dist/commonjs/aurelia-bootstrapper'],function(m){return m;});
define('aurelia-bootstrapper.js',['aurelia-bootstrapper'],function(m){return m;});
define('aurelia-bootstrapper/dist/commonjs/aurelia-bootstrapper.js',['aurelia-bootstrapper/dist/commonjs/aurelia-bootstrapper'],function(m){return m;});
define('aurelia-dependency-injection',['aurelia-dependency-injection/dist/commonjs/aurelia-dependency-injection'],function(m){return m;});
define('aurelia-dependency-injection.js',['aurelia-dependency-injection'],function(m){return m;});
define('aurelia-dependency-injection/dist/commonjs/aurelia-dependency-injection.js',['aurelia-dependency-injection/dist/commonjs/aurelia-dependency-injection'],function(m){return m;});
define('aurelia-event-aggregator',['aurelia-event-aggregator/dist/commonjs/aurelia-event-aggregator'],function(m){return m;});
define('aurelia-event-aggregator.js',['aurelia-event-aggregator'],function(m){return m;});
define('aurelia-event-aggregator/dist/commonjs/aurelia-event-aggregator.js',['aurelia-event-aggregator/dist/commonjs/aurelia-event-aggregator'],function(m){return m;});
define('aurelia-framework',['aurelia-framework/dist/commonjs/aurelia-framework'],function(m){return m;});
define('aurelia-framework.js',['aurelia-framework'],function(m){return m;});
define('aurelia-framework/dist/commonjs/aurelia-framework.js',['aurelia-framework/dist/commonjs/aurelia-framework'],function(m){return m;});
define('aurelia-history',['aurelia-history/dist/commonjs/aurelia-history'],function(m){return m;});
define('aurelia-history-browser',['aurelia-history-browser/dist/commonjs/aurelia-history-browser'],function(m){return m;});
define('aurelia-history-browser.js',['aurelia-history-browser'],function(m){return m;});
define('aurelia-history-browser/dist/commonjs/aurelia-history-browser.js',['aurelia-history-browser/dist/commonjs/aurelia-history-browser'],function(m){return m;});
define('aurelia-history.js',['aurelia-history'],function(m){return m;});
define('aurelia-history/dist/commonjs/aurelia-history.js',['aurelia-history/dist/commonjs/aurelia-history'],function(m){return m;});
define('aurelia-loader',['aurelia-loader/dist/commonjs/aurelia-loader'],function(m){return m;});
define('aurelia-loader-default',['aurelia-loader-default/dist/commonjs/aurelia-loader-default'],function(m){return m;});
define('aurelia-loader-default.js',['aurelia-loader-default'],function(m){return m;});
define('aurelia-loader-default/dist/commonjs/aurelia-loader-default.js',['aurelia-loader-default/dist/commonjs/aurelia-loader-default'],function(m){return m;});
define('aurelia-loader.js',['aurelia-loader'],function(m){return m;});
define('aurelia-loader/dist/commonjs/aurelia-loader.js',['aurelia-loader/dist/commonjs/aurelia-loader'],function(m){return m;});
define('aurelia-logging',['aurelia-logging/dist/commonjs/aurelia-logging'],function(m){return m;});
define('aurelia-logging-console',['aurelia-logging-console/dist/commonjs/aurelia-logging-console'],function(m){return m;});
define('aurelia-logging-console.js',['aurelia-logging-console'],function(m){return m;});
define('aurelia-logging-console/dist/commonjs/aurelia-logging-console.js',['aurelia-logging-console/dist/commonjs/aurelia-logging-console'],function(m){return m;});
define('aurelia-logging.js',['aurelia-logging'],function(m){return m;});
define('aurelia-logging/dist/commonjs/aurelia-logging.js',['aurelia-logging/dist/commonjs/aurelia-logging'],function(m){return m;});
define('aurelia-metadata',['aurelia-metadata/dist/commonjs/aurelia-metadata'],function(m){return m;});
define('aurelia-metadata.js',['aurelia-metadata'],function(m){return m;});
define('aurelia-metadata/dist/commonjs/aurelia-metadata.js',['aurelia-metadata/dist/commonjs/aurelia-metadata'],function(m){return m;});
define('aurelia-pal',['aurelia-pal/dist/commonjs/aurelia-pal'],function(m){return m;});
define('aurelia-pal-browser',['aurelia-pal-browser/dist/commonjs/aurelia-pal-browser'],function(m){return m;});
define('aurelia-pal-browser.js',['aurelia-pal-browser'],function(m){return m;});
define('aurelia-pal-browser/dist/commonjs/aurelia-pal-browser.js',['aurelia-pal-browser/dist/commonjs/aurelia-pal-browser'],function(m){return m;});
define('aurelia-pal.js',['aurelia-pal'],function(m){return m;});
define('aurelia-pal/dist/commonjs/aurelia-pal.js',['aurelia-pal/dist/commonjs/aurelia-pal'],function(m){return m;});
define('aurelia-path',['aurelia-path/dist/commonjs/aurelia-path'],function(m){return m;});
define('aurelia-path.js',['aurelia-path'],function(m){return m;});
define('aurelia-path/dist/commonjs/aurelia-path.js',['aurelia-path/dist/commonjs/aurelia-path'],function(m){return m;});
define('aurelia-polyfills',['aurelia-polyfills/dist/commonjs/aurelia-polyfills'],function(m){return m;});
define('aurelia-polyfills.js',['aurelia-polyfills'],function(m){return m;});
define('aurelia-polyfills/dist/commonjs/aurelia-polyfills.js',['aurelia-polyfills/dist/commonjs/aurelia-polyfills'],function(m){return m;});
define('aurelia-route-recognizer',['aurelia-route-recognizer/dist/commonjs/aurelia-route-recognizer'],function(m){return m;});
define('aurelia-route-recognizer.js',['aurelia-route-recognizer'],function(m){return m;});
define('aurelia-route-recognizer/dist/commonjs/aurelia-route-recognizer.js',['aurelia-route-recognizer/dist/commonjs/aurelia-route-recognizer'],function(m){return m;});
define('aurelia-router',['aurelia-router/dist/commonjs/aurelia-router'],function(m){return m;});
define('aurelia-router.js',['aurelia-router'],function(m){return m;});
define('aurelia-router/dist/commonjs/aurelia-router.js',['aurelia-router/dist/commonjs/aurelia-router'],function(m){return m;});
define('aurelia-task-queue',['aurelia-task-queue/dist/commonjs/aurelia-task-queue'],function(m){return m;});
define('aurelia-task-queue.js',['aurelia-task-queue'],function(m){return m;});
define('aurelia-task-queue/dist/commonjs/aurelia-task-queue.js',['aurelia-task-queue/dist/commonjs/aurelia-task-queue'],function(m){return m;});
define('aurelia-templating',['aurelia-templating/dist/commonjs/aurelia-templating'],function(m){return m;});
define('aurelia-templating-binding',['aurelia-templating-binding/dist/commonjs/aurelia-templating-binding'],function(m){return m;});
define('aurelia-templating-binding.js',['aurelia-templating-binding'],function(m){return m;});
define('aurelia-templating-binding/dist/commonjs/aurelia-templating-binding.js',['aurelia-templating-binding/dist/commonjs/aurelia-templating-binding'],function(m){return m;});
define('aurelia-templating-resources',['aurelia-templating-resources/dist/commonjs/aurelia-templating-resources'],function(m){return m;});
define('aurelia-templating-resources.js',['aurelia-templating-resources'],function(m){return m;});
define('aurelia-templating-resources/abstract-repeater',['aurelia-templating-resources/dist/commonjs/abstract-repeater'],function(m){return m;});
define('aurelia-templating-resources/abstract-repeater.js',['aurelia-templating-resources/abstract-repeater'],function(m){return m;});
define('aurelia-templating-resources/analyze-view-factory',['aurelia-templating-resources/dist/commonjs/analyze-view-factory'],function(m){return m;});
define('aurelia-templating-resources/analyze-view-factory.js',['aurelia-templating-resources/analyze-view-factory'],function(m){return m;});
define('aurelia-templating-resources/array-repeat-strategy',['aurelia-templating-resources/dist/commonjs/array-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/array-repeat-strategy.js',['aurelia-templating-resources/array-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/attr-binding-behavior',['aurelia-templating-resources/dist/commonjs/attr-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/attr-binding-behavior.js',['aurelia-templating-resources/attr-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/aurelia-hide-style',['aurelia-templating-resources/dist/commonjs/aurelia-hide-style'],function(m){return m;});
define('aurelia-templating-resources/aurelia-hide-style.js',['aurelia-templating-resources/aurelia-hide-style'],function(m){return m;});
define('aurelia-templating-resources/aurelia-templating-resources',['aurelia-templating-resources/dist/commonjs/aurelia-templating-resources'],function(m){return m;});
define('aurelia-templating-resources/aurelia-templating-resources.js',['aurelia-templating-resources/aurelia-templating-resources'],function(m){return m;});
define('aurelia-templating-resources/binding-mode-behaviors',['aurelia-templating-resources/dist/commonjs/binding-mode-behaviors'],function(m){return m;});
define('aurelia-templating-resources/binding-mode-behaviors.js',['aurelia-templating-resources/binding-mode-behaviors'],function(m){return m;});
define('aurelia-templating-resources/binding-signaler',['aurelia-templating-resources/dist/commonjs/binding-signaler'],function(m){return m;});
define('aurelia-templating-resources/binding-signaler.js',['aurelia-templating-resources/binding-signaler'],function(m){return m;});
define('aurelia-templating-resources/compose',['aurelia-templating-resources/dist/commonjs/compose'],function(m){return m;});
define('aurelia-templating-resources/compose.js',['aurelia-templating-resources/compose'],function(m){return m;});
define('aurelia-templating-resources/css-resource',['aurelia-templating-resources/dist/commonjs/css-resource'],function(m){return m;});
define('aurelia-templating-resources/css-resource.js',['aurelia-templating-resources/css-resource'],function(m){return m;});
define('aurelia-templating-resources/debounce-binding-behavior',['aurelia-templating-resources/dist/commonjs/debounce-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/debounce-binding-behavior.js',['aurelia-templating-resources/debounce-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/abstract-repeater.js',['aurelia-templating-resources/dist/commonjs/abstract-repeater'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/analyze-view-factory.js',['aurelia-templating-resources/dist/commonjs/analyze-view-factory'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/array-repeat-strategy.js',['aurelia-templating-resources/dist/commonjs/array-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/attr-binding-behavior.js',['aurelia-templating-resources/dist/commonjs/attr-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/aurelia-hide-style.js',['aurelia-templating-resources/dist/commonjs/aurelia-hide-style'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/aurelia-templating-resources.js',['aurelia-templating-resources/dist/commonjs/aurelia-templating-resources'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/binding-mode-behaviors.js',['aurelia-templating-resources/dist/commonjs/binding-mode-behaviors'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/binding-signaler.js',['aurelia-templating-resources/dist/commonjs/binding-signaler'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/compose.js',['aurelia-templating-resources/dist/commonjs/compose'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/css-resource.js',['aurelia-templating-resources/dist/commonjs/css-resource'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/debounce-binding-behavior.js',['aurelia-templating-resources/dist/commonjs/debounce-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/dynamic-element.js',['aurelia-templating-resources/dist/commonjs/dynamic-element'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/else.js',['aurelia-templating-resources/dist/commonjs/else'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/focus.js',['aurelia-templating-resources/dist/commonjs/focus'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/hide.js',['aurelia-templating-resources/dist/commonjs/hide'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/html-resource-plugin.js',['aurelia-templating-resources/dist/commonjs/html-resource-plugin'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/html-sanitizer.js',['aurelia-templating-resources/dist/commonjs/html-sanitizer'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/if-core.js',['aurelia-templating-resources/dist/commonjs/if-core'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/if.js',['aurelia-templating-resources/dist/commonjs/if'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/map-repeat-strategy.js',['aurelia-templating-resources/dist/commonjs/map-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/null-repeat-strategy.js',['aurelia-templating-resources/dist/commonjs/null-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/number-repeat-strategy.js',['aurelia-templating-resources/dist/commonjs/number-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/repeat-strategy-locator.js',['aurelia-templating-resources/dist/commonjs/repeat-strategy-locator'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/repeat-utilities.js',['aurelia-templating-resources/dist/commonjs/repeat-utilities'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/repeat.js',['aurelia-templating-resources/dist/commonjs/repeat'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/replaceable.js',['aurelia-templating-resources/dist/commonjs/replaceable'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/sanitize-html.js',['aurelia-templating-resources/dist/commonjs/sanitize-html'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/self-binding-behavior.js',['aurelia-templating-resources/dist/commonjs/self-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/set-repeat-strategy.js',['aurelia-templating-resources/dist/commonjs/set-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/show.js',['aurelia-templating-resources/dist/commonjs/show'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/signal-binding-behavior.js',['aurelia-templating-resources/dist/commonjs/signal-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/throttle-binding-behavior.js',['aurelia-templating-resources/dist/commonjs/throttle-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/update-trigger-binding-behavior.js',['aurelia-templating-resources/dist/commonjs/update-trigger-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/dist/commonjs/with.js',['aurelia-templating-resources/dist/commonjs/with'],function(m){return m;});
define('aurelia-templating-resources/dynamic-element',['aurelia-templating-resources/dist/commonjs/dynamic-element'],function(m){return m;});
define('aurelia-templating-resources/dynamic-element.js',['aurelia-templating-resources/dynamic-element'],function(m){return m;});
define('aurelia-templating-resources/else',['aurelia-templating-resources/dist/commonjs/else'],function(m){return m;});
define('aurelia-templating-resources/else.js',['aurelia-templating-resources/else'],function(m){return m;});
define('aurelia-templating-resources/focus',['aurelia-templating-resources/dist/commonjs/focus'],function(m){return m;});
define('aurelia-templating-resources/focus.js',['aurelia-templating-resources/focus'],function(m){return m;});
define('aurelia-templating-resources/hide',['aurelia-templating-resources/dist/commonjs/hide'],function(m){return m;});
define('aurelia-templating-resources/hide.js',['aurelia-templating-resources/hide'],function(m){return m;});
define('aurelia-templating-resources/html-resource-plugin',['aurelia-templating-resources/dist/commonjs/html-resource-plugin'],function(m){return m;});
define('aurelia-templating-resources/html-resource-plugin.js',['aurelia-templating-resources/html-resource-plugin'],function(m){return m;});
define('aurelia-templating-resources/html-sanitizer',['aurelia-templating-resources/dist/commonjs/html-sanitizer'],function(m){return m;});
define('aurelia-templating-resources/html-sanitizer.js',['aurelia-templating-resources/html-sanitizer'],function(m){return m;});
define('aurelia-templating-resources/if',['aurelia-templating-resources/dist/commonjs/if'],function(m){return m;});
define('aurelia-templating-resources/if-core',['aurelia-templating-resources/dist/commonjs/if-core'],function(m){return m;});
define('aurelia-templating-resources/if-core.js',['aurelia-templating-resources/if-core'],function(m){return m;});
define('aurelia-templating-resources/if.js',['aurelia-templating-resources/if'],function(m){return m;});
define('aurelia-templating-resources/map-repeat-strategy',['aurelia-templating-resources/dist/commonjs/map-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/map-repeat-strategy.js',['aurelia-templating-resources/map-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/null-repeat-strategy',['aurelia-templating-resources/dist/commonjs/null-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/null-repeat-strategy.js',['aurelia-templating-resources/null-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/number-repeat-strategy',['aurelia-templating-resources/dist/commonjs/number-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/number-repeat-strategy.js',['aurelia-templating-resources/number-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/repeat',['aurelia-templating-resources/dist/commonjs/repeat'],function(m){return m;});
define('aurelia-templating-resources/repeat-strategy-locator',['aurelia-templating-resources/dist/commonjs/repeat-strategy-locator'],function(m){return m;});
define('aurelia-templating-resources/repeat-strategy-locator.js',['aurelia-templating-resources/repeat-strategy-locator'],function(m){return m;});
define('aurelia-templating-resources/repeat-utilities',['aurelia-templating-resources/dist/commonjs/repeat-utilities'],function(m){return m;});
define('aurelia-templating-resources/repeat-utilities.js',['aurelia-templating-resources/repeat-utilities'],function(m){return m;});
define('aurelia-templating-resources/repeat.js',['aurelia-templating-resources/repeat'],function(m){return m;});
define('aurelia-templating-resources/replaceable',['aurelia-templating-resources/dist/commonjs/replaceable'],function(m){return m;});
define('aurelia-templating-resources/replaceable.js',['aurelia-templating-resources/replaceable'],function(m){return m;});
define('aurelia-templating-resources/sanitize-html',['aurelia-templating-resources/dist/commonjs/sanitize-html'],function(m){return m;});
define('aurelia-templating-resources/sanitize-html.js',['aurelia-templating-resources/sanitize-html'],function(m){return m;});
define('aurelia-templating-resources/self-binding-behavior',['aurelia-templating-resources/dist/commonjs/self-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/self-binding-behavior.js',['aurelia-templating-resources/self-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/set-repeat-strategy',['aurelia-templating-resources/dist/commonjs/set-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/set-repeat-strategy.js',['aurelia-templating-resources/set-repeat-strategy'],function(m){return m;});
define('aurelia-templating-resources/show',['aurelia-templating-resources/dist/commonjs/show'],function(m){return m;});
define('aurelia-templating-resources/show.js',['aurelia-templating-resources/show'],function(m){return m;});
define('aurelia-templating-resources/signal-binding-behavior',['aurelia-templating-resources/dist/commonjs/signal-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/signal-binding-behavior.js',['aurelia-templating-resources/signal-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/throttle-binding-behavior',['aurelia-templating-resources/dist/commonjs/throttle-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/throttle-binding-behavior.js',['aurelia-templating-resources/throttle-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/update-trigger-binding-behavior',['aurelia-templating-resources/dist/commonjs/update-trigger-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/update-trigger-binding-behavior.js',['aurelia-templating-resources/update-trigger-binding-behavior'],function(m){return m;});
define('aurelia-templating-resources/with',['aurelia-templating-resources/dist/commonjs/with'],function(m){return m;});
define('aurelia-templating-resources/with.js',['aurelia-templating-resources/with'],function(m){return m;});
define('aurelia-templating-router',['aurelia-templating-router/dist/commonjs/aurelia-templating-router'],function(m){return m;});
define('aurelia-templating-router.js',['aurelia-templating-router'],function(m){return m;});
define('aurelia-templating-router/aurelia-templating-router',['aurelia-templating-router/dist/commonjs/aurelia-templating-router'],function(m){return m;});
define('aurelia-templating-router/aurelia-templating-router.js',['aurelia-templating-router/aurelia-templating-router'],function(m){return m;});
define('aurelia-templating-router/dist/commonjs/aurelia-templating-router.js',['aurelia-templating-router/dist/commonjs/aurelia-templating-router'],function(m){return m;});
define('aurelia-templating-router/dist/commonjs/route-href.js',['aurelia-templating-router/dist/commonjs/route-href'],function(m){return m;});
define('aurelia-templating-router/dist/commonjs/route-loader.js',['aurelia-templating-router/dist/commonjs/route-loader'],function(m){return m;});
define('aurelia-templating-router/dist/commonjs/router-view.js',['aurelia-templating-router/dist/commonjs/router-view'],function(m){return m;});
define('aurelia-templating-router/route-href',['aurelia-templating-router/dist/commonjs/route-href'],function(m){return m;});
define('aurelia-templating-router/route-href.js',['aurelia-templating-router/route-href'],function(m){return m;});
define('aurelia-templating-router/route-loader',['aurelia-templating-router/dist/commonjs/route-loader'],function(m){return m;});
define('aurelia-templating-router/route-loader.js',['aurelia-templating-router/route-loader'],function(m){return m;});
define('aurelia-templating-router/router-view',['aurelia-templating-router/dist/commonjs/router-view'],function(m){return m;});
define('aurelia-templating-router/router-view.js',['aurelia-templating-router/router-view'],function(m){return m;});
define('aurelia-templating.js',['aurelia-templating'],function(m){return m;});
define('aurelia-templating/dist/commonjs/aurelia-templating.js',['aurelia-templating/dist/commonjs/aurelia-templating'],function(m){return m;});
define('aurelia-testing',['aurelia-testing/dist/commonjs/aurelia-testing'],function(m){return m;});
define('aurelia-testing.js',['aurelia-testing'],function(m){return m;});
define('aurelia-testing/aurelia-testing',['aurelia-testing/dist/commonjs/aurelia-testing'],function(m){return m;});
define('aurelia-testing/aurelia-testing.js',['aurelia-testing/aurelia-testing'],function(m){return m;});
define('aurelia-testing/compile-spy',['aurelia-testing/dist/commonjs/compile-spy'],function(m){return m;});
define('aurelia-testing/compile-spy.js',['aurelia-testing/compile-spy'],function(m){return m;});
define('aurelia-testing/component-tester',['aurelia-testing/dist/commonjs/component-tester'],function(m){return m;});
define('aurelia-testing/component-tester.js',['aurelia-testing/component-tester'],function(m){return m;});
define('aurelia-testing/dist/commonjs/aurelia-testing.js',['aurelia-testing/dist/commonjs/aurelia-testing'],function(m){return m;});
define('aurelia-testing/dist/commonjs/compile-spy.js',['aurelia-testing/dist/commonjs/compile-spy'],function(m){return m;});
define('aurelia-testing/dist/commonjs/component-tester.js',['aurelia-testing/dist/commonjs/component-tester'],function(m){return m;});
define('aurelia-testing/dist/commonjs/view-spy.js',['aurelia-testing/dist/commonjs/view-spy'],function(m){return m;});
define('aurelia-testing/dist/commonjs/wait.js',['aurelia-testing/dist/commonjs/wait'],function(m){return m;});
define('aurelia-testing/view-spy',['aurelia-testing/dist/commonjs/view-spy'],function(m){return m;});
define('aurelia-testing/view-spy.js',['aurelia-testing/view-spy'],function(m){return m;});
define('aurelia-testing/wait',['aurelia-testing/dist/commonjs/wait'],function(m){return m;});
define('aurelia-testing/wait.js',['aurelia-testing/wait'],function(m){return m;});
define('bcx-aurelia-dnd',['bcx-aurelia-dnd/dist/index'],function(m){return m;});
define('bcx-aurelia-dnd.js',['bcx-aurelia-dnd'],function(m){return m;});
define('bcx-aurelia-dnd/dist/index.js',['bcx-aurelia-dnd/dist/index'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat',['bcx-aurelia-reorderable-repeat/dist/index'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat.js',['bcx-aurelia-reorderable-repeat'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/index.js',['bcx-aurelia-reorderable-repeat/dist/index'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/reorderable-after-reordering.js',['bcx-aurelia-reorderable-repeat/dist/reorderable-after-reordering'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/reorderable-direction.js',['bcx-aurelia-reorderable-repeat/dist/reorderable-direction'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-handler-selector.js',['bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-handler-selector'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-preview.js',['bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-preview'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/reorderable-repeat-strategy-locator.js',['bcx-aurelia-reorderable-repeat/dist/reorderable-repeat-strategy-locator'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/reorderable-repeat.js',['bcx-aurelia-reorderable-repeat/dist/reorderable-repeat'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/dist/simple-array-repeat-strategy.js',['bcx-aurelia-reorderable-repeat/dist/simple-array-repeat-strategy'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/index',['bcx-aurelia-reorderable-repeat/dist/index'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/index.js',['bcx-aurelia-reorderable-repeat/index'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-after-reordering',['bcx-aurelia-reorderable-repeat/dist/reorderable-after-reordering'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-after-reordering.js',['bcx-aurelia-reorderable-repeat/reorderable-after-reordering'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-direction',['bcx-aurelia-reorderable-repeat/dist/reorderable-direction'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-direction.js',['bcx-aurelia-reorderable-repeat/reorderable-direction'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-dnd-handler-selector',['bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-handler-selector'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-dnd-handler-selector.js',['bcx-aurelia-reorderable-repeat/reorderable-dnd-handler-selector'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-dnd-preview',['bcx-aurelia-reorderable-repeat/dist/reorderable-dnd-preview'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-dnd-preview.js',['bcx-aurelia-reorderable-repeat/reorderable-dnd-preview'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-repeat',['bcx-aurelia-reorderable-repeat/dist/reorderable-repeat'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-repeat-strategy-locator',['bcx-aurelia-reorderable-repeat/dist/reorderable-repeat-strategy-locator'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-repeat-strategy-locator.js',['bcx-aurelia-reorderable-repeat/reorderable-repeat-strategy-locator'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/reorderable-repeat.js',['bcx-aurelia-reorderable-repeat/reorderable-repeat'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/simple-array-repeat-strategy',['bcx-aurelia-reorderable-repeat/dist/simple-array-repeat-strategy'],function(m){return m;});
define('bcx-aurelia-reorderable-repeat/simple-array-repeat-strategy.js',['bcx-aurelia-reorderable-repeat/simple-array-repeat-strategy'],function(m){return m;});
define('bcx-doc-base',['bcx-doc-base/dist/index'],function(m){return m;});
define('bcx-doc-base.js',['bcx-doc-base'],function(m){return m;});
define('bcx-doc-base/binding-behaviors/left-click',['bcx-doc-base/dist/binding-behaviors/left-click'],function(m){return m;});
define('bcx-doc-base/binding-behaviors/left-click.js',['bcx-doc-base/binding-behaviors/left-click'],function(m){return m;});
define('text!bcx-doc-base/css/doc.css',['text!bcx-doc-base/dist/css/doc.css'],function(m){return m;});
define('bcx-doc-base/dist/binding-behaviors/left-click.js',['bcx-doc-base/dist/binding-behaviors/left-click'],function(m){return m;});
define('bcx-doc-base/dist/elements/bcx-doc-nav.js',['bcx-doc-base/dist/elements/bcx-doc-nav'],function(m){return m;});
define('bcx-doc-base/dist/elements/code-viewer.js',['bcx-doc-base/dist/elements/code-viewer'],function(m){return m;});
define('bcx-doc-base/dist/elements/display-source.js',['bcx-doc-base/dist/elements/display-source'],function(m){return m;});
define('bcx-doc-base/dist/elements/display-sources.js',['bcx-doc-base/dist/elements/display-sources'],function(m){return m;});
define('bcx-doc-base/dist/index.js',['bcx-doc-base/dist/index'],function(m){return m;});
define('bcx-doc-base/elements/bcx-doc-nav',['bcx-doc-base/dist/elements/bcx-doc-nav'],function(m){return m;});
define('text!bcx-doc-base/elements/bcx-doc-nav.html',['text!bcx-doc-base/dist/elements/bcx-doc-nav.html'],function(m){return m;});
define('bcx-doc-base/elements/bcx-doc-nav.js',['bcx-doc-base/elements/bcx-doc-nav'],function(m){return m;});
define('bcx-doc-base/elements/code-viewer',['bcx-doc-base/dist/elements/code-viewer'],function(m){return m;});
define('text!bcx-doc-base/elements/code-viewer.css',['text!bcx-doc-base/dist/elements/code-viewer.css'],function(m){return m;});
define('text!bcx-doc-base/elements/code-viewer.html',['text!bcx-doc-base/dist/elements/code-viewer.html'],function(m){return m;});
define('bcx-doc-base/elements/code-viewer.js',['bcx-doc-base/elements/code-viewer'],function(m){return m;});
define('bcx-doc-base/elements/display-source',['bcx-doc-base/dist/elements/display-source'],function(m){return m;});
define('text!bcx-doc-base/elements/display-source.html',['text!bcx-doc-base/dist/elements/display-source.html'],function(m){return m;});
define('bcx-doc-base/elements/display-source.js',['bcx-doc-base/elements/display-source'],function(m){return m;});
define('bcx-doc-base/elements/display-sources',['bcx-doc-base/dist/elements/display-sources'],function(m){return m;});
define('text!bcx-doc-base/elements/display-sources.html',['text!bcx-doc-base/dist/elements/display-sources.html'],function(m){return m;});
define('bcx-doc-base/elements/display-sources.js',['bcx-doc-base/elements/display-sources'],function(m){return m;});
define('bcx-doc-base/index',['bcx-doc-base/dist/index'],function(m){return m;});
define('bcx-doc-base/index.js',['bcx-doc-base/index'],function(m){return m;});
define('codemirror',['codemirror/lib/codemirror'],function(m){return m;});
define('codemirror.js',['codemirror'],function(m){return m;});
define('codemirror/addon/display/fullscreen.js',['codemirror/addon/display/fullscreen'],function(m){return m;});
define('codemirror/addon/lint/lint.js',['codemirror/addon/lint/lint'],function(m){return m;});
define('codemirror/addon/selection/active-line.js',['codemirror/addon/selection/active-line'],function(m){return m;});
define('codemirror/lib/codemirror.js',['codemirror/lib/codemirror'],function(m){return m;});
define('codemirror/mode/css/css.js',['codemirror/mode/css/css'],function(m){return m;});
define('codemirror/mode/htmlmixed/htmlmixed.js',['codemirror/mode/htmlmixed/htmlmixed'],function(m){return m;});
define('codemirror/mode/javascript/javascript.js',['codemirror/mode/javascript/javascript'],function(m){return m;});
define('codemirror/mode/markdown/markdown.js',['codemirror/mode/markdown/markdown'],function(m){return m;});
define('codemirror/mode/meta.js',['codemirror/mode/meta'],function(m){return m;});
define('codemirror/mode/xml/xml.js',['codemirror/mode/xml/xml'],function(m){return m;});
define('lodash',['lodash/lodash'],function(m){return m;});
define('lodash.js',['lodash'],function(m){return m;});
define('lodash/lodash.js',['lodash/lodash'],function(m){return m;});
define('text',['text/text'],function(m){return m;});
define('text.js',['text'],function(m){return m;});
define('text/text.js',['text/text'],function(m){return m;});
function _aureliaConfigureModuleLoader(){requirejs.config({"baseUrl":"src","paths":{"root":"src","resources":"resources","elements":"resources/elements","attributes":"resources/attributes","valueConverters":"resources/value-converters","bindingBehaviors":"resources/binding-behaviors","app-bundle":"../scripts/app-bundle"},"packages":[],"stubModules":["text"],"shim":{},"bundles":{"app-bundle":["app","text!app.html","app.js","environment","environment.js","main","main.js","resources","resources.js","resources/index","resources/index.js","text!tutorial/faq.html","text!tutorial/overview.html","text!tutorial/typescript-support.html"]}})}